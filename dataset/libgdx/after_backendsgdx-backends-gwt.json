[{"methodBody": ["METHOD_START", "{", "if    ( data   instanceof   byte [  ]  )", "(  ( byte [  ]  )     ( data )  )  [ index ]     =     (  ( byte )     ( val )  )  ;", "else", "(  ( char [  ]  )     ( data )  )  [ index ]     =     (  ( char )     ( val )  )  ;", "}", "METHOD_END"], "methodName": ["cram"], "fileName": "avian.Utf8"}, {"methodBody": ["METHOD_START", "{", "Object   buf    =    new   byte [ length ]  ;", "boolean   isMultiByte    =    false ;", "int   i    =    offset ;", "int   j    =     0  ;", "while    ( i    <     ( offset    +    length )  )     {", "int   x    =    s 8  [  ( i +  +  )  ]  ;", "if    (  ( x    &     1  2  8  )     =  =     0  )     {", "if    ( x    =  =     0  )", "+  + i ;", ". cram ( buf ,     ( j +  +  )  ,    x )  ;", "} else", "if    (  ( x    &     2  2  4  )     =  =     1  9  2  )     {", "if    (  ! isMultiByte )     {", "buf    =     . widen ( buf ,    j ,     ( length    -     1  )  )  ;", "isMultiByte    =    true ;", "}", "int   y    =    s 8  [  ( i +  +  )  ]  ;", ". cram ( buf ,     ( j +  +  )  ,     (  (  ( x    &     3  1  )     <  <     6  )     |     ( y    &     6  3  )  )  )  ;", "} else", "if    (  ( x    &     2  4  0  )     =  =     2  2  4  )     {", "if    (  ! isMultiByte )     {", "buf    =     . widen ( buf ,    j ,     ( length    -     2  )  )  ;", "isMultiByte    =    true ;", "}", "int   y    =    s 8  [  ( i +  +  )  ]  ;", "int   z    =    s 8  [  ( i +  +  )  ]  ;", ". cram ( buf ,     ( j +  +  )  ,     (  (  (  ( x    &     1  5  )     <  <     1  2  )     |     (  ( y    &     6  3  )     <  <     6  )  )     |     ( z    &     6  3  )  )  )  ;", "}", "}", "return    . trim ( buf ,    j )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "avian.Utf8"}, {"methodBody": ["METHOD_START", "{", "Object   decoded    =    Utf 8  . decode ( s 8  ,    offset ,    length )  ;", "if    ( decoded   instanceof   char [  ]  )", "return    (  ( char [  ]  )     ( decoded )  )  ;", "return    (  ( char [  ]  )     ( Utf 8  . widen ( decoded ,    length ,    length )  )  )  ;", "}", "METHOD_END"], "methodName": ["decode16"], "fileName": "avian.Utf8"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   buf    =    new   ByteArrayOutputStream (  )  ;", "for    ( int   i    =    offset ;    i    <     ( offset    +    length )  ;     +  + i )     {", "char   c    =    s 1  6  [ i ]  ;", "if    ( c    =  =     '  \\ u 0  0  0  0  '  )     {", "buf . write (  0  )  ;", "buf . write (  0  )  ;", "} else", "if    ( c    <     1  2  8  )     {", "buf . write ( c )  ;", "} else", "if    ( c    <     2  0  4  8  )     {", "buf . write (  (  1  9  2     |     ( c    >  >  >     6  )  )  )  ;", "buf . write (  (  1  2  8     |     ( c    &     6  3  )  )  )  ;", "} else    {", "buf . write (  (  2  2  4     |     (  ( c    >  >  >     1  2  )     &     1  5  )  )  )  ;", "buf . write (  (  1  2  8     |     (  ( c    >  >  >     6  )     &     6  3  )  )  )  ;", "buf . write (  (  1  2  8     |     ( c    &     6  3  )  )  )  ;", "}", "}", "return   buf . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "avian.Utf8"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( data   instanceof   byte [  ]  )  )", "return   false ;", "byte [  ]    b    =     (  ( byte [  ]  )     ( data )  )  ;", "for    ( int   i    =     0  ;    i    <     ( b . length )  ;     +  + i )     {", "if    (  (  (  ( int )     ( b [ i ]  )  )     &     1  2  8  )     !  =     0  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "avian.Utf8"}, {"methodBody": ["METHOD_START", "{", "if    ( data   instanceof   byte [  ]  )", "return   data ;", "if    (  (  (  ( char [  ]  )     ( data )  )  . length )     =  =    length )", "return   data ;", "char [  ]    result    =    new   char [ length ]  ;", "System . arraycopy ( data ,     0  ,    result ,     0  ,    length )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["trim"], "fileName": "avian.Utf8"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    src    =     (  ( byte [  ]  )     ( data )  )  ;", "char [  ]    result    =    new   char [ capacity ]  ;", "for    ( int   i    =     0  ;    i    <    length ;     +  + i )", "result [ i ]     =     (  ( char )     (  (  ( int )     ( src [ i ]  )  )     &     2  5  5  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["widen"], "fileName": "avian.Utf8"}, {"methodBody": ["METHOD_START", "{", "int   width    =     0  ;", "if    (  ( graphics . getWidth (  )  )     >     ( graphics . getHeight (  )  )  )     {", "width    =    graphics . getHeight (  )  ;", "} else    {", "width    =    graphics . getWidth (  )  ;", "}", ". Resolution   bestDesc    =    null ;", "int   best    =    Integer . MAX _ VALUE ;", "for    ( int   i    =     0  ,    n    =    descriptors . length ;    i    <    n ;    i +  +  )     {", "if    (  ( descriptors [ i ]  . portraitWidth )     <    best )     {", "best    =    descriptors [ i ]  . portraitWidth ;", "bestDesc    =    descriptors [ i ]  ;", "}", "}", "best    =    Integer . MAX _ VALUE ;", "for    ( int   i    =     0  ,    n    =    descriptors . length ;    i    <    n ;    i +  +  )     {", "if    (  ( descriptors [ i ]  . portraitWidth )     <  =    width )     {", "best    =    descriptors [ i ]  . portraitWidth ;", "bestDesc    =    descriptors [ i ]  ;", "}", "}", "return   bestDesc ;", "}", "METHOD_END"], "methodName": ["choose"], "fileName": "com.badlogic.gdx.assets.loaders.resolvers.ResolutionFileResolver"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( originalHandle . parent (  )  )     +     \"  /  \"  )     +    suffix )     +     \"  /  \"  )     +     ( originalHandle . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "com.badlogic.gdx.assets.loaders.resolvers.ResolutionFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   GwtApplication . agentInfo ;", "}", "METHOD_END"], "methodName": ["agentInfo"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "return   new   Preloader ( getPreloaderBaseURL (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPreloader"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "return   preloader . baseUrl ;", "}", "METHOD_END"], "methodName": ["getBaseUrl"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "return   graphics . canvas ;", "}", "METHOD_END"], "methodName": ["getCanvasElement"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "return   loadingListener ;", "}", "METHOD_END"], "methodName": ["getLoadingListener"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "return   new   Label (  \" Sorry ,    your   browser   doesn ' t   seem   to   support   WebGL \"  )  ;", "}", "METHOD_END"], "methodName": ["getNoWebGLSupportWidget"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "return   preloader ;", "}", "METHOD_END"], "methodName": ["getPreloader"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "return    ( GWT . getHostPageBaseURL (  )  )     +     \" assets /  \"  ;", "}", "METHOD_END"], "methodName": ["getPreloaderBaseURL"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "final   Panel   preloaderPanel    =    new   VerticalPanel (  )  ;", "preloaderPanel . setStyleName (  \" gdx - preloader \"  )  ;", "final   Image   logo    =    new   Image (  (  ( GWT . getModuleBaseURL (  )  )     +     \" logo . png \"  )  )  ;", "logo . setStyleName (  \" logo \"  )  ;", "preloaderPanel . add ( logo )  ;", "final   Panel   meterPanel    =    new   SimplePanel (  )  ;", "meterPanel . setStyleName (  \" gdx - meter \"  )  ;", "meterPanel . addStyleName (  \" red \"  )  ;", "final   InlineHTML   meter    =    new   InlineHTML (  )  ;", "final   Style   meterStyle    =    meter . getElement (  )  . getStyle (  )  ;", "meterStyle . setWidth (  0  ,    PCT )  ;", "meterPanel . add ( meter )  ;", "preloaderPanel . add ( meterPanel )  ;", "getRootPanel (  )  . add ( preloaderPanel )  ;", "return   new   Preloader . PreloaderCall (  )     {", "@ Override", "public   void   error ( String   file )     {", "System . out . println (  (  \" error :     \"     +    file )  )  ;", "}", "@ Override", "public   void   update ( Preloader . PreloaderState   state )     {", "meterStyle . setWidth (  (  1  0  0  .  0 F    *     ( state . getProgress (  )  )  )  ,    PCT )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getPreloaderCallback"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "return   root ;", "}", "METHOD_END"], "methodName": ["getRootPanel"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "graphics . update (  )  ;", "if    (  (  ( graphicetWidth (  )  )     !  =     ( lastWidth )  )     |  |     (  ( graphicetHeight (  )  )     !  =     ( lastHeight )  )  )     {", "lastWidth    =    graphicetWidth (  )  ;", "lastHeight    =    graphicetHeight (  )  ;", "gl . glViewport (  0  ,     0  ,    lastWidth ,    lastHeight )  ;", "this . listener . resize ( lastWidth ,    lastHeight )  ;", "}", "runnablesHelper . addAll ( runnables )  ;", "runnables . clear (  )  ;", "for    ( int   i    =     0  ;    i    <     ( runnablesHelper . size )  ;    i +  +  )     {", "runnablesHelper . get ( i )  . run (  )  ;", "}", "runnablesHelper . clear (  )  ;", "( graphics . frameId )  +  +  ;", "listener . render (  )  ;", "input . reset (  )  ;", "}", "METHOD_END"], "methodName": ["mainLoop"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "if    ( visible )     {", "for    ( LifecycleLister   lister    :    lifecycleListers )     {", "lister . resume (  )  ;", "}", "lister . resume (  )  ;", "} else    {", "for    ( LifecycleLister   lister    :    lifecycleListers )     {", "lister . pause (  )  ;", "}", "lister . pause (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onVisibilityChange"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "final   Preloader . PreloaderCallback   callback    =    getPreloaderCallback (  )  ;", "preloader    =    createPreloader (  )  ;", "preloader . preload (  \" assets . txt \"  ,    new   Preloader . PreloaderCallback (  )     {", "@ Override", "public   void   error ( String   file )     {", "callback . error ( file )  ;", "}", "@ Override", "public   void   update ( Preloader . PreloaderState   state )     {", "callback . update ( state )  ;", "if    ( state . hasEnded (  )  )     {", "getRootPanel (  )  . clear (  )  ;", "if    (  ( loadingListener )     !  =    null )", "loadingListener . beforeSetup (  )  ;", "setupLoop (  )  ;", "addEventListeners (  )  ;", "if    (  ( loadingListener )     !  =    null )", "loadingListener . afterSetup (  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["preloadAssets"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "this . loadingListener    =    loadingListener ;", "}", "METHOD_END"], "methodName": ["setLoadingListener"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "try    {", "graphics    =    new   GwtGraphics ( root ,    config )  ;", "}    catch    ( Throwable   e )     {", "root . clear (  )  ;", "root . add ( getNoWebGLSupportWidget (  )  )  ;", "return ;", "}", "lastWidth    =    graphics . getWidth (  )  ;", "lastHeight    =    graphics . getHeight (  )  ;", "Gdx . app    =    this ;", "if    ( config . disableAudio )     {", "Gdx . audio    =    null ;", "} else    {", "Gdx . audio    =    new   GwtAudio (  )  ;", "}", "Gdx . graphics    =    graphics ;", "Gdx . gl 2  0     =    graphics . getGL 2  0  (  )  ;", "Gdx . gl    =    Gdx . gl 2  0  ;", "Gdx . files    =    new   GwtFiles ( preloader )  ;", "this . input    =    new   GwtInput ( graphics . canvas )  ;", "Gdx . input    =    this . input ;", "this . net    =    new   GwtNet ( config )  ;", "Gdx . net    =    this . net ;", "this . clipboard    =    new   GwtClipboard (  )  ;", "updateLogLabelSize (  )  ;", "try    {", "listener . create (  )  ;", "listener . resize ( graphics . getWidth (  )  ,    graphics . getHeight (  )  )  ;", "}    catch    ( Throwable   t )     {", "error (  \"  \"  ,     (  \" exception :     \"     +     ( t . getMessage (  )  )  )  ,    t )  ;", "t . printStackTrace (  )  ;", "throw   new   RuntimeException ( t )  ;", "}", "AnimationScheduler . get (  )  . requestAnimationFrame ( new   AnimationCallback (  )     {", "@ Override", "public   void   execute ( double   timestamp )     {", "try    {", "mainLoop (  )  ;", "}    catch    ( Throwable   t )     {", "error (  \"  \"  ,     (  \" exception :     \"     +     ( t . getMessage (  )  )  )  ,    t )  ;", "throw   new   RuntimeException ( t )  ;", "}", "AnimationScheduler . get (  )  . requestAnimationFrame ( this ,    graphics . canvas )  ;", "}", "}  ,    graphics . canvas )  ;", "}", "METHOD_END"], "methodName": ["setupLoop"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "if    (  ( log )     !  =    null )     {", "if    (  ( graphics )     !  =    null )     {", "log . setSize (  (  ( graphics . getWidth (  )  )     +     \" px \"  )  ,     \"  2  0  0 px \"  )  ;", "} else    {", "log . setSize (  \"  4  0  0 px \"  ,     \"  2  0  0 px \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateLogLabelSize"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplication"}, {"methodBody": ["METHOD_START", "{", "if    (  ( log )     =  =    null )     {", "(  (  )     ( Gdx . app )  )  . log    =    log    =    new   TextArea (  )  ;", "if    (  ( Gdx . graphics )     !  =    null )     {", "log . setSize (  (  ( graphics . getWidth (  )  )     +     \" px \"  )  ,     \"  2  0  0 px \"  )  ;", "} else    {", "log . setSize (  \"  4  0  0 px \"  ,     \"  2  0  0 px \"  )  ;", "}", "log . setReadOnly ( true )  ;", "(  (  )     ( app )  )  . getRootPanel (  )  . add ( log )  ;", "}", "}", "METHOD_END"], "methodName": ["checkLogLabel"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplicationLogger"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buffer    =    new   StringBuffer (  )  ;", "while    ( e    !  =    null )     {", "buffer . app (  (  ( e . getMessage (  )  )     +     \"  \\ n \"  )  )  ;", "e    =    e . getCause (  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getMessages"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplicationLogger"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buffer    =    new   StringBuffer (  )  ;", "for    ( StTraceElement   trace    :    e . getStTrace (  )  )     {", "buffer . append (  (  ( trace . toString (  )  )     +     \"  \\ n \"  )  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getStackTrace"], "fileName": "com.badlogic.gdx.backends.gwt.GwtApplicationLogger"}, {"methodBody": ["METHOD_START", "{", "if    ( systemCursor    =  =     ( SystemCursor . Arrow )  )     {", "return    \" default \"  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . Crosshair )  )     {", "return    \" crosshair \"  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . Hand )  )     {", "return    \" pointer \"  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . HorizontalResize )  )     {", "return    \" ew - resize \"  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . VerticalResize )  )     {", "return    \" ns - resize \"  ;", "} else", "if    ( systemCursor    =  =     ( SystemCursor . Ibeam )  )     {", "return    \" text \"  ;", "} else    {", "throw   new   utils . GdxRuntimeException (  (  \" Unknown   system   cursor    \"     +    systemCursor )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getNameForSystemCursor"], "fileName": "com.badlogic.gdx.backends.gwt.GwtCursor"}, {"methodBody": ["METHOD_START", "{", "return   new   GwtFileHandle ( preloader ,     (  ( file . isEmpty (  )     ?     \"  \"     :     ( file )     +     ( file . endsWith (  \"  /  \"  )     ?     \"  \"     :     \"  /  \"  )  )     +    name )  ,    FileType . Internal )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  (  \" Cannot   copy   to   an   internal   file :     \"     +    dest )  )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  (  \" Cannot   delete   an   internal   file :     \"     +     ( file )  )  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  (  \" Cannot   delete   an   internal   file :     \"     +     ( file )  )  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   preloader . contains ( file )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "String   name    =    name (  )  ;", "int   dotIex    =    name . lastIexOf (  '  .  '  )  ;", "if    ( dotIex    =  =     (  -  1  )  )", "return    \"  \"  ;", "return   name . substring (  ( dotIex    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["extension"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Not   supported   in   GWT   backend \"  )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "path    =    path . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "if    ( path . With (  \"  /  \"  )  )     {", "path    =    path . substring (  0  ,     (  ( path . length (  )  )     -     1  )  )  ;", "}", "return   path ;", "}", "METHOD_END"], "methodName": ["fixSlashes"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   preloader . isDirectory ( file )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   preloader . length ( file )  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   preloader . list ( file )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   preloader . list ( file ,    filter )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   preloader . list ( file ,    filter )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   preloader . list ( file ,    suffix )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  (  \" Cannot   mkdirs   with   an   internal   file :     \"     +     ( file )  )  )  ;", "}", "METHOD_END"], "methodName": ["mkdirs"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  (  \" Cannot   move   an   internal   file :     \"     +     ( file )  )  )  ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "int   index    =    file . lastIndexOf (  '  /  '  )  ;", "if    ( index    <     0  )", "return   file ;", "return   file . substring (  ( index    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "String   name    =    name (  )  ;", "int   dotIex    =    name . lastIexOf (  '  .  '  )  ;", "if    ( dotIex    =  =     (  -  1  )  )", "return   name ;", "return   name . substring (  0  ,    dotIex )  ;", "}", "METHOD_END"], "methodName": ["nameWithoutExtension"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "int   index    =    file . lastIndexOf (  \"  /  \"  )  ;", "String   dir    =     \"  \"  ;", "if    ( index    >     0  )", "dir    =    file . substring (  0  ,    index )  ;", "return   new    ( preloader ,    dir ,    type )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "String   path    =    file ;", "int   dotIndex    =    path . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    =  =     (  -  1  )  )", "return   path ;", "return   path . substring (  0  ,    dotIndex )  ;", "}", "METHOD_END"], "methodName": ["pathWithoutExtension"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "InputStream   in    =    preloader . read ( file )  ;", "if    ( in    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  ( file )     +     \"    does   not   exist \"  )  )  ;", "return   in ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   BufferedInputStream ( read (  )  ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "int   length    =     (  ( int )     ( length (  )  )  )  ;", "if    ( length    =  =     0  )", "length    =     5  1  2  ;", "byte [  ]    buffer    =    new   byte [ length ]  ;", "int   position    =     0  ;", "InputStream   input    =    read (  )  ;", "try    {", "wh    ( true )     {", "int   count    =    input . read ( buffer ,    position ,     (  ( buffer . length )     -    position )  )  ;", "if    ( count    =  =     (  -  1  )  )", "break ;", "position    +  =    count ;", "if    ( position    =  =     ( buffer . length )  )     {", "byte [  ]    newBuffer    =    new   byte [  ( buffer . length )     *     2  ]  ;", "System . arraycopy ( buffer ,     0  ,    newBuffer ,     0  ,    position )  ;", "buffer    =    newBuffer ;", "}", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   f :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( input    !  =    null )", "input . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "if    ( position    <     ( buffer . length )  )     {", "byte [  ]    newBuffer    =    new   byte [ position ]  ;", "System . arraycopy ( buffer ,     0  ,    newBuffer ,     0  ,    position )  ;", "buffer    =    newBuffer ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "InputStream   input    =    read (  )  ;", "int   position    =     0  ;", "try    {", "wh    ( true )     {", "int   count    =    input . read ( bytes ,     ( offset    +    position )  ,     ( size    -    position )  )  ;", "if    ( count    <  =     0  )", "break ;", "position    +  =    count ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   f :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( input    !  =    null )", "input . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "return   position    -    offset ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   readString ( null )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    ( preloader . isText ( file )  )", "return   preloader . texts . get ( file )  ;", "try    {", "return   new   String ( readBytes (  )  ,     \" UTF -  8  \"  )  ;", "}    catch    ( UnsupportedEncodingException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   InputStreamReader ( read (  )  )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   BufferedReader ( reader (  )  ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   BufferedReader ( reader ( charset )  ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   InputStreamReer ( re (  )  ,    charset )  ;", "}    catch    ( UnsupportedEncodingException   e )     {", "throw   new   GdxRuntimeException (  (  (  \" Encoding    '  \"     +    charset )     +     \"  '    not   supported \"  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   parent (  )  . child ( GwtFileHandle . fixSlashes ( name )  )  ;", "}", "METHOD_END"], "methodName": ["sibling"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Cannot   write   to   files   in   GWT   backend \"  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Cannot   write   to   files   in   GWT   backend \"  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Cannot   write   to   files   in   GWT   backend \"  )  ;", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Cannot   write   to   files   in   GWT   backend \"  )  ;", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "writeString ( string ,    append ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Cannot   write   to   files   in   GWT   backend \"  )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "return   writer ( append ,    null )  ;", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Cannot   write   to   files   in   GWT   backend \"  )  ;", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.backends.gwt.GwtFileHandle"}, {"methodBody": ["METHOD_START", "{", "if    ( GWT . isProdMode (  )  )     {", "return    (  ( Float 3  2 Array )     (  (  ( HasArrayBufferView )     ( buffer )  )  . getTypedArray (  )  )  )  . surray ( buffer . position (  )  ,    buffer . remaining (  )  )  ;", "} else    {", "ensureCapacity ( buffer )  ;", "for    ( int   i    =    buffer . position (  )  ,    j    =     0  ;    i    <     ( buffer . limit (  )  )  ;    i +  +     ,    j +  +  )     {", "floatBuffer . set ( j ,    buffer . get ( i )  )  ;", "}", "return   floatBuffer . surray (  0  ,    buffer . remaining (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGL20"}, {"methodBody": ["METHOD_START", "{", "if    ( GWT . isProdMode (  )  )     {", "return    (  ( Int 3  2 Array )     (  (  ( HasArrayBufferView )     ( buffer )  )  . getTypedArray (  )  )  )  . surray ( buffer . position (  )  ,    buffer . remaining (  )  )  ;", "} else    {", "ensureCapacity ( buffer )  ;", "for    ( int   i    =    buffer . position (  )  ,    j    =     0  ;    i    <     ( buffer . limit (  )  )  ;    i +  +     ,    j +  +  )     {", "intBuffer . set ( j ,    buffer . get ( i )  )  ;", "}", "return   intBuffer . surray (  0  ,    buffer . remaining (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGL20"}, {"methodBody": ["METHOD_START", "{", "if    ( GWT . isProdMode (  )  )     {", "return    (  ( Int 1  6 Array )     (  (  ( HasArrayBufferView )     ( buffer )  )  . getTypedArray (  )  )  )  . surray ( buffer . position (  )  ,    buffer . remaining (  )  )  ;", "} else    {", "ensureCapacity ( buffer )  ;", "for    ( int   i    =    buffer . position (  )  ,    j    =     0  ;    i    <     ( buffer . limit (  )  )  ;    i +  +     ,    j +  +  )     {", "shortBuffer . set ( j ,    buffer . get ( i )  )  ;", "}", "return   shortBuffer . surray (  0  ,    buffer . remaining (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGL20"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buffer . remaining (  )  )     >     ( floatBuffer . length (  )  )  )     {", "floatBuffer    =    TypedArrays . createFloat 3  2 Array ( buffer . remaining (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGL20"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buffer . remaining (  )  )     >     ( intBuffer . length (  )  )  )     {", "intBuffer    =    TypedArrays . createInt 3  2 Array ( buffer . remaining (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGL20"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buffer . remaining (  )  )     >     ( shortBuffer . length (  )  )  )     {", "shortBuffer    =    TypedArrays . createInt 1  6 Array ( buffer . remaining (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGL20"}, {"methodBody": ["METHOD_START", "{", "return   uniforms . get ( currProgram )  . get ( location )  ;", "}", "METHOD_END"], "methodName": ["getUniformLocation"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGL20"}, {"methodBody": ["METHOD_START", "{", "int   error    =     0  ;", "if    (  ( error    = letError (  )  )     !  =     ( GL _ NO _ ERROR )  )     {", "throw   new   GdxRuntimeException (  (  (  (  \" GL   error :     \"     +    error )     +     \"  ,     \"  )     +     ( Inter . toHexStri ( error )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkError"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGL20Debug"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isFullscreen (  )  )  )     {", "canvas . setWidth ( config . width )  ;", "canvas . setHeight ( config . height )  ;", "if    (  ( config . fullscreenOrientation )     !  =    null )", "unlockOrientation (  )  ;", "} else    {", "if    (  ( config . fullscreenOrientation )     !  =    null )", "lockOrientation ( config . fullscreenOrientation )  ;", "}", "}", "METHOD_END"], "methodName": ["fullscreenChanged"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGraphics"}, {"methodBody": ["METHOD_START", "{", "return   context ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGraphics"}, {"methodBody": ["METHOD_START", "{", "return   lockOrientationJSNI ( orientation . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["lockOrientation"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGraphics"}, {"methodBody": ["METHOD_START", "{", "return   unlockOrientationJSNI (  )  ;", "}", "METHOD_END"], "methodName": ["unlockOrientation"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGraphics"}, {"methodBody": ["METHOD_START", "{", "long   currTimeStamp    =    System . currentTimeMillis (  )  ;", "deltaTime    =     ( currTimeStamp    -     ( lastTimeStamp )  )     /     1  0  0  0  .  0 F ;", "lastTimeStamp    =    currTimeStamp ;", "time    +  =    deltaTime ;", "( frames )  +  +  ;", "if    (  ( time )     >     1  )     {", "this . fps    =    frames ;", "time    =     0  ;", "frames    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.backends.gwt.GwtGraphics"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( GwtInput . MAX _ TOUCHES )  ;    i +  +  )     {", "if    (  !  ( touchMap . containsValue ( i ,    false )  )  )", "return   i ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getAvailablePointer"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "if    ( button    =  =     ( NativeEvent . BUTTON _ LEFT )  )", "return   Buttons . LEFT ;", "if    ( button    =  =     ( NativeEvent . BUTTON _ RIGHT )  )", "return   Buttons . RIGHT ;", "if    ( button    =  =     ( NativeEvent . BUTTON _ MIDDLE )  )", "return   Buttons . MIDDLE ;", "return   Buttons . LEFT ;", "}", "METHOD_END"], "methodName": ["getButton"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "float   xScaleRatio    =     (  ( target . getWidth (  )  )     *     1  .  0 F )     /     ( target . getClientWidth (  )  )  ;", "return   Math . round (  ( xScaleRatio    *     (  (  (  ( e . getClientX (  )  )     -     ( target . getAbsoluteLeft (  )  )  )     +     ( target . getScrollLeft (  )  )  )     +     ( target . getOwnerDocument (  )  . getScrollLeft (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRelativeX"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "float   xScaleRatio    =     (  ( target . getWidth (  )  )     *     1  .  0 F )     /     ( target . getClientWidth (  )  )  ;", "return   Math . round (  ( xScaleRatio    *     ( touch . getRelativeX ( target )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRelativeX"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "float   yScaleRatio    =     (  ( target . getHeight (  )  )     *     1  .  0 F )     /     ( target . getClientHeight (  )  )  ;", "return   Math . round (  ( yScaleRatio    *     (  (  (  ( e . getClientY (  )  )     -     ( target . getAbsoluteTop (  )  )  )     +     ( target . getScrollTop (  )  )  )     +     ( target . getOwnerDocument (  )  . getScrollTop (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRelativeY"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "float   yScaleRatio    =     (  ( target . getHeight (  )  )     *     1  .  0 F )     /     ( target . getClientHeight (  )  )  ;", "return   Math . round (  ( yScaleRatio    *     ( touch . getRelativeY ( target )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRelativeY"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "TextInputDialogBox   dialog    =    new   TextInputDialogBox ( title ,    text ,    hint )  ;", "final   TextInputListener   capturedListener    =    listener ;", "dialog . setListener ( new   TextInputDialogBox . TextInputDialogListener (  )     {", "@ Override", "public   void   onPositive ( String   text )     {", "if    ( capturedListener    !  =    null )     {", "capturedListener . input ( text )  ;", "}", "}", "@ Override", "public   void   onNegative (  )     {", "if    ( capturedListener    !  =    null )     {", "capturedListener . canceled (  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getTextInput"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "if    ( e . getType (  )  . equals (  \" mousedown \"  )  )     {", "if    (  (  !  ( e . getEventTarget (  )  . equals ( canvas )  )  )     |  |     ( pressedButtons . contains ( getButton ( e . getButton (  )  )  )  )  )     {", "float   mouseX    =    getRelativeX ( e ,    canvas )  ;", "float   mouseY    =    getRelativeY ( e ,    canvas )  ;", "if    (  (  (  ( mouseX    <     0  )     |  |     ( mouseX    >     ( graphics . getWidth (  )  )  )  )     |  |     ( mouseY    <     0  )  )     |  |     ( mouseY    >     ( graphics . getHeight (  )  )  )  )     {", "hasFocus    =    false ;", "}", "return ;", "}", "hasFocus    =    true ;", "this . justTouched    =    true ;", "this . touched [  0  ]     =    true ;", "this . pressedButtons . add ( getButton ( e . getButton (  )  )  )  ;", "this . deltaX [  0  ]     =     0  ;", "this . deltaY [  0  ]     =     0  ;", "if    ( isCursorCatched (  )  )     {", "this . touchX [  0  ]     +  =    getMovementXJSNI ( e )  ;", "this . touchY [  0  ]     +  =    getMovementYJSNI ( e )  ;", "} else    {", "this . touchX [  0  ]     =    getRelativeX ( e ,    canvas )  ;", "this . touchY [  0  ]     =    getRelativeY ( e ,    canvas )  ;", "}", "this . currentEventTimeStamp    =    TimeUtils . nanoTime (  )  ;", "if    (  ( processor )     !  =    null )", "processor . touchDown ( touchX [  0  ]  ,    touchY [  0  ]  ,     0  ,    getButton ( e . getButton (  )  )  )  ;", "}", "if    ( e . getType (  )  . equals (  \" mousemove \"  )  )     {", "if    ( isCursorCatched (  )  )     {", "this . deltaX [  0  ]     =     (  ( int )     ( getMovementXJSNI ( e )  )  )  ;", "this . deltaY [  0  ]     =     (  ( int )     ( getMovementYJSNI ( e )  )  )  ;", "this . touchX [  0  ]     +  =    getMovementXJSNI ( e )  ;", "this . touchY [  0  ]     +  =    getMovementYJSNI ( e )  ;", "} else    {", "this . deltaX [  0  ]     =     ( getRelativeX ( e ,    canvas )  )     -     ( touchX [  0  ]  )  ;", "this . deltaY [  0  ]     =     ( getRelativeY ( e ,    canvas )  )     -     ( touchY [  0  ]  )  ;", "this . touchX [  0  ]     =    getRelativeX ( e ,    canvas )  ;", "this . touchY [  0  ]     =    getRelativeY ( e ,    canvas )  ;", "}", "this . currentEventTimeStamp    =    TimeUtils . nanoTime (  )  ;", "if    (  ( processor )     !  =    null )     {", "if    ( touched [  0  ]  )", "processor . touchDragged ( touchX [  0  ]  ,    touchY [  0  ]  ,     0  )  ;", "else", "processor . mouseMoved ( touchX [  0  ]  ,    touchY [  0  ]  )  ;", "}", "}", "if    ( e . getType (  )  . equals (  \" mouseup \"  )  )     {", "if    (  !  ( pressedButtons . contains ( getButton ( e . getButton (  )  )  )  )  )", "return ;", "this . pressedButtons . remove ( getButton ( e . getButton (  )  )  )  ;", "this . touched [  0  ]     =     ( pressedButtons . size )     >     0  ;", "if    ( isCursorCatched (  )  )     {", "this . deltaX [  0  ]     =     (  ( int )     ( getMovementXJSNI ( e )  )  )  ;", "this . deltaY [  0  ]     =     (  ( int )     ( getMovementYJSNI ( e )  )  )  ;", "this . touchX [  0  ]     +  =    getMovementXJSNI ( e )  ;", "this . touchY [  0  ]     +  =    getMovementYJSNI ( e )  ;", "} else    {", "this . deltaX [  0  ]     =     ( getRelativeX ( e ,    canvas )  )     -     ( touchX [  0  ]  )  ;", "this . deltaY [  0  ]     =     ( getRelativeY ( e ,    canvas )  )     -     ( touchY [  0  ]  )  ;", "this . touchX [  0  ]     =    getRelativeX ( e ,    canvas )  ;", "this . touchY [  0  ]     =    getRelativeY ( e ,    canvas )  ;", "}", "this . currentEventTimeStamp    =    TimeUtils . nanoTime (  )  ;", "this . touched [  0  ]     =    false ;", "if    (  ( processor )     !  =    null )", "processor . touchUp ( touchX [  0  ]  ,    touchY [  0  ]  ,     0  ,    getButton ( e . getButton (  )  )  )  ;", "}", "if    ( e . getType (  )  . equals (  . getMouseWheelEvent (  )  )  )     {", "if    (  ( processor )     !  =    null )     {", "processor . scrolled (  (  ( int )     (  . getMouseWheelVelocity ( e )  )  )  )  ;", "}", "this . currentEventTimeStamp    =    TimeUtils . nanoTime (  )  ;", "e . preventDefault (  )  ;", "}", "if    (  ( e . getType (  )  . equals (  \" keydown \"  )  )     &  &     ( hasFocus )  )     {", "int   code    =     . keyForCode ( e . getKeyCode (  )  )  ;", "if    ( code    =  =     6  7  )     {", "e . preventDefault (  )  ;", "if    (  ( processor )     !  =    null )     {", "processor . keyDown ( code )  ;", "processor . keyTyped (  '  \\ b '  )  ;", "}", "} else    {", "if    (  !  ( pressedKeys [ code ]  )  )     {", "( pressedKeyCount )  +  +  ;", "pressedKeys [ code ]     =    true ;", "keyJustPressed    =    true ;", "justPressedKeys [ code ]     =    true ;", "if    (  ( processor )     !  =    null )     {", "processor . keyDown ( code )  ;", "}", "}", "}", "}", "if    (  ( e . getType (  )  . equals (  \" keypress \"  )  )     &  &     ( hasFocus )  )     {", "char   c    =     (  ( char )     ( e . getCharCode (  )  )  )  ;", "if    (  ( processor )     !  =    null )", "processor . keyTyped ( c )  ;", "}", "if    (  ( e . getType (  )  . equals (  \" keyup \"  )  )     &  &     ( hasFocus )  )     {", "int   code    =     . keyForCode ( e . getKeyCode (  )  )  ;", "if    ( pressedKeys [ code ]  )     {", "( pressedKeyCount )  -  -  ;", "pressedKeys [ code ]     =    false ;", "}", "if    (  ( processor )     !  =    null )     {", "processor . keyUp ( code )  ;", "}", "}", "if    ( e . getType (  )  . equals (  \" touchstart \"  )  )     {", "this . justTouched    =    true ;", "JsArray < Touch >    touches    =    e . getChangedTouches (  )  ;", "for    ( int   i    =     0  ,    j    =    touches . length (  )  ;    i    <    j ;    i +  +  )     {", "Touch   touch    =    touches . get ( i )  ;", "int   real    =    touch . getIdentifier (  )  ;", "int   touchId ;", "touchMap . put ( real ,     ( touchId    =    getAvailablePointer (  )  )  )  ;", "touched [ touchId ]     =    true ;", "touchX [ touchId ]     =    getRelativeX ( touch ,    canvas )  ;", "touchY [ touchId ]     =    getRelativeY ( touch ,    canvas )  ;", "deltaX [ touchId ]     =     0  ;", "deltaY [ touchId ]     =     0  ;", "if    (  ( processor )     !  =    null )     {", "processor . touchDown ( touchX [ touchId ]  ,    touchY [ touchId ]  ,    touchId ,    LEFT )  ;", "}", "}", "this . currentEventTimeStamp    =    TimeUtils . nanoTime (  )  ;", "e . preventDefault (  )  ;", "}", "if    ( e . getType (  )  . equals (  \" touchmove \"  )  )     {", "JsArray < Touch >    touches    =    e . getChangedTouches (  )  ;", "for    ( int   i    =     0  ,    j    =    touches . length (  )  ;    i    <    j ;    i +  +  )     {", "Touch   touch    =    touches . get ( i )  ;", "int   real    =    touch . getIdentifier (  )  ;", "int   touchId    =    touchMap . get ( real )  ;", "deltaX [ touchId ]     =     ( getRelativeX ( touch ,    canvas )  )     -     ( touchX [ touchId ]  )  ;", "deltaY [ touchId ]     =     ( getRelativeY ( touch ,    canvas )  )     -     ( touchY [ touchId ]  )  ;", "touchX [ touchId ]     =    getRelativeX ( touch ,    canvas )  ;", "touchY [ touchId ]     =    getRelativeY ( touch ,    canvas )  ;", "if    (  ( processor )     !  =    null )     {", "processor . touchDragged ( touchX [ touchId ]  ,    touchY [ touchId ]  ,    touchId )  ;", "}", "}", "this . currentEventTimeStamp    =    TimeUtils . nanoTime (  )  ;", "e . preventDefault (  )  ;", "}", "if    ( e . getType (  )  . equals (  \" touchcancel \"  )  )     {", "JsArray < Touch >    touches    =    e . getChangedTouches (  )  ;", "for    ( int   i    =     0  ,    j    =    touches . length (  )  ;    i    <    j ;    i +  +  )     {", "Touch   touch    =    touches . get ( i )  ;", "int   real    =    touch . getIdentifier (  )  ;", "int   touchId    =    touchMap . get ( real )  ;", "touchMap . remove ( real )  ;", "touched [ touchId ]     =    false ;", "deltaX [ touchId ]     =     ( getRelativeX ( touch ,    canvas )  )     -     ( touchX [ touchId ]  )  ;", "deltaY [ touchId ]     =     ( getRelativeY ( touch ,    canvas )  )     -     ( touchY [ touchId ]  )  ;", "touchX [ touchId ]     =    getRelativeX ( touch ,    canvas )  ;", "touchY [ touchId ]     =    getRelativeY ( touch ,    canvas )  ;", "if    (  ( processor )     !  =    null )     {", "processor . touchUp ( touchX [ touchId ]  ,    touchY [ touchId ]  ,    touchId ,    LEFT )  ;", "}", "}", "this . currentEventTimeStamp    =    TimeUtils . nanoTime (  )  ;", "e . preventDefault (  )  ;", "}", "if    ( e . getType (  )  . equals (  \" touchend \"  )  )     {", "JsArray < Touch >    touches    =    e . getChangedTouches (  )  ;", "for    ( int   i    =     0  ,    j    =    touches . length (  )  ;    i    <    j ;    i +  +  )     {", "Touch   touch    =    touches . get ( i )  ;", "int   real    =    touch . getIdentifier (  )  ;", "int   touchId    =    touchMap . get ( real )  ;", "touchMap . remove ( real )  ;", "touched [ touchId ]     =    false ;", "deltaX [ touchId ]     =     ( getRelativeX ( touch ,    canvas )  )     -     ( touchX [ touchId ]  )  ;", "deltaY [ touchId ]     =     ( getRelativeY ( touch ,    canvas )  )     -     ( touchY [ touchId ]  )  ;", "touchX [ touchId ]     =    getRelativeX ( touch ,    canvas )  ;", "touchY [ touchId ]     =    getRelativeY ( touch ,    canvas )  ;", "if    (  ( processor )     !  =    null )     {", "processor . touchUp ( touchX [ touchId ]  ,    touchY [ touchId ]  ,    touchId ,    LEFT )  ;", "}", "}", "this . currentEventTimeStamp    =    TimeUtils . nanoTime (  )  ;", "e . preventDefault (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleEvent"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "GwtInput . addEventListener ( canvas ,     \" mousedown \"  ,    this ,    true )  ;", "GwtInput . addEventListener ( Document . get (  )  ,     \" mousedown \"  ,    this ,    true )  ;", "GwtInput . addEventListener ( canvas ,     \" mouseup \"  ,    this ,    true )  ;", "GwtInput . addEventListener ( Document . get (  )  ,     \" mouseup \"  ,    this ,    true )  ;", "GwtInput . addEventListener ( canvas ,     \" mousemove \"  ,    this ,    true )  ;", "GwtInput . addEventListener ( Document . get (  )  ,     \" mousemove \"  ,    this ,    true )  ;", "GwtInput . addEventListener ( canvas ,    GwtInput . getMouseWheelEvent (  )  ,    this ,    true )  ;", "GwtInput . addEventListener ( Document . get (  )  ,     \" keydown \"  ,    this ,    false )  ;", "GwtInput . addEventListener ( Document . get (  )  ,     \" keyup \"  ,    this ,    false )  ;", "GwtInput . addEventListener ( Document . get (  )  ,     \" keypress \"  ,    this ,    false )  ;", "GwtInput . addEventListener ( canvas ,     \" touchstart \"  ,    this ,    true )  ;", "GwtInput . addEventListener ( canvas ,     \" touchmove \"  ,    this ,    true )  ;", "GwtInput . addEventListener ( canvas ,     \" touchcancel \"  ,    this ,    true )  ;", "GwtInput . addEventListener ( canvas ,     \" touchend \"  ,    this ,    true )  ;", "}", "METHOD_END"], "methodName": ["hookEvents"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "switch    ( keyCode )     {", "case   KeyCodes . KEY _ ALT    :", "return   Keys . ALT _ LEFT ;", "case   KeyCodes . KEY _ BACKSPACE    :", "return   Keys . BACKSPACE ;", "case   KeyCodes . KEY _ CTRL    :", "return   Keys . CONTROL _ LEFT ;", "case   KeyCodes . KEY _ DELETE    :", "return   Keys . DEL ;", "case   KeyCodes . KEY _ DOWN    :", "return   Keys . DOWN ;", "case   KeyCodes . KEY _ END    :", "return   Keys . END ;", "case   KeyCodes . KEY _ ENTER    :", "return   Keys . ENTER ;", "case   KeyCodes . KEY _ ESCAPE    :", "return   Keys . ESCAPE ;", "case   KeyCodes . KEY _ HOME    :", "return   Keys . HOME ;", "case   KeyCodes . KEY _ LEFT    :", "return   Keys . LEFT ;", "case   KeyCodes . KEY _ PAGEDOWN    :", "return   Keys . PAGE _ DOWN ;", "case   KeyCodes . KEY _ PAGEUP    :", "return   Keys . PAGE _ UP ;", "case   KeyCodes . KEY _ RIGHT    :", "return   Keys . RIGHT ;", "case   KeyCodes . KEY _ SHIFT    :", "return   Keys . SHIFT _ LEFT ;", "case   KeyCodes . KEY _ TAB    :", "return   Keys . TAB ;", "case   KeyCodes . KEY _ UP    :", "return   Keys . UP ;", "case    . KEY _ PAUSE    :", "return   Keys . UNKNOWN ;", "case    . KEY _ CAPS _ LOCK    :", "return   Keys . UNKNOWN ;", "case    . KEY _ SPACE    :", "return   Keys . SPACE ;", "case    . KEY _ INSERT    :", "return   Keys . INSERT ;", "case    . KEY _  0     :", "return   Keys . NUM _  0  ;", "case    . KEY _  1     :", "return   Keys . NUM _  1  ;", "case    . KEY _  2     :", "return   Keys . NUM _  2  ;", "case    . KEY _  3     :", "return   Keys . NUM _  3  ;", "case    . KEY _  4     :", "return   Keys . NUM _  4  ;", "case    . KEY _  5     :", "return   Keys . NUM _  5  ;", "case    . KEY _  6     :", "return   Keys . NUM _  6  ;", "case    . KEY _  7     :", "return   Keys . NUM _  7  ;", "case    . KEY _  8     :", "return   Keys . NUM _  8  ;", "case    . KEY _  9     :", "return   Keys . NUM _  9  ;", "case    . KEY _ A    :", "return   Keys . A ;", "case    . KEY _ B    :", "return   Keys . B ;", "case    . KEY _ C    :", "return   Keys . C ;", "case    . KEY _ D    :", "return   Keys . D ;", "case    . KEY _ E    :", "return   Keys . E ;", "case    . KEY _ F    :", "return   Keys . F ;", "case    . KEY _ G    :", "return   Keys . G ;", "case    . KEY _ H    :", "return   Keys . H ;", "case    . KEY _ I    :", "return   Keys . I ;", "case    . KEY _ J    :", "return   Keys . J ;", "case    . KEY _ K    :", "return   Keys . K ;", "case    . KEY _ L    :", "return   Keys . L ;", "case    . KEY _ M    :", "return   Keys . M ;", "case    . KEY _ N    :", "return   Keys . N ;", "case    . KEY _ O    :", "return   Keys . O ;", "case    . KEY _ P    :", "return   Keys . P ;", "case    . KEY _ Q    :", "return   Keys . Q ;", "case    . KEY _ R    :", "return   Keys . R ;", "case    . KEY _ S    :", "return   Keys . S ;", "case    . KEY _ T    :", "return   Keys . T ;", "case    . KEY _ U    :", "return   Keys . U ;", "case    . KEY _ V    :", "return   Keys . V ;", "case    . KEY _ W    :", "return   Keys . W ;", "case    . KEY _ X    :", "return   Keys . X ;", "case    . KEY _ Y    :", "return   Keys . Y ;", "case    . KEY _ Z    :", "return   Keys . Z ;", "case    . KEY _ LEFT _ WINDOW _ KEY    :", "return   Keys . UNKNOWN ;", "case    . KEY _ RIGHT _ WINDOW _ KEY    :", "return   Keys . UNKNOWN ;", "case    . KEY _ NUMPAD 0     :", "return   Keys . NUMPAD _  0  ;", "case    . KEY _ NUMPAD 1     :", "return   Keys . NUMPAD _  1  ;", "case    . KEY _ NUMPAD 2     :", "return   Keys . NUMPAD _  2  ;", "case    . KEY _ NUMPAD 3     :", "return   Keys . NUMPAD _  3  ;", "case    . KEY _ NUMPAD 4     :", "return   Keys . NUMPAD _  4  ;", "case    . KEY _ NUMPAD 5     :", "return   Keys . NUMPAD _  5  ;", "case    . KEY _ NUMPAD 6     :", "return   Keys . NUMPAD _  6  ;", "case    . KEY _ NUMPAD 7     :", "return   Keys . NUMPAD _  7  ;", "case    . KEY _ NUMPAD 8     :", "return   Keys . NUMPAD _  8  ;", "case    . KEY _ NUMPAD 9     :", "return   Keys . NUMPAD _  9  ;", "case    . KEY _ MULTIPLY    :", "return   Keys . UNKNOWN ;", "case    . KEY _ ADD    :", "return   Keys . PLUS ;", "case    . KEY _ SUBTRACT    :", "return   Keys . MINUS ;", "case    . KEY _ DECIMAL _ POINT _ KEY    :", "return   Keys . PERIOD ;", "case    . KEY _ DIVIDE    :", "return   Keys . UNKNOWN ;", "case    . KEY _ F 1     :", "return   Keys . F 1  ;", "case    . KEY _ F 2     :", "return   Keys . F 2  ;", "case    . KEY _ F 3     :", "return   Keys . F 3  ;", "case    . KEY _ F 4     :", "return   Keys . F 4  ;", "case    . KEY _ F 5     :", "return   Keys . F 5  ;", "case    . KEY _ F 6     :", "return   Keys . F 6  ;", "case    . KEY _ F 7     :", "return   Keys . F 7  ;", "case    . KEY _ F 8     :", "return   Keys . F 8  ;", "case    . KEY _ F 9     :", "return   Keys . F 9  ;", "case    . KEY _ F 1  0     :", "return   Keys . F 1  0  ;", "case    . KEY _ F 1  1     :", "return   Keys . F 1  1  ;", "case    . KEY _ F 1  2     :", "return   Keys . F 1  2  ;", "case    . KEY _ NUM _ LOCK    :", "return   Keys . NUM ;", "case    . KEY _ SCROLL _ LOCK    :", "return   Keys . UNKNOWN ;", "case    . KEY _ SEMICOLON    :", "return   Keys . SEMICOLON ;", "case    . KEY _ EQUALS    :", "return   Keys . EQUALS ;", "case    . KEY _ COMMA    :", "return   Keys . COMMA ;", "case    . KEY _ DASH    :", "return   Keys . MINUS ;", "case    . KEY _ PERIOD    :", "return   Keys . PERIOD ;", "case    . KEY _ FORWARD _ SLASH    :", "return   Keys . SLASH ;", "case    . KEY _ GRAVE _ ACCENT    :", "return   Keys . UNKNOWN ;", "case    . KEY _ OPEN _ BRACKET    :", "return   Keys . LEFT _ BRACKET ;", "case    . KEY _ BACKSLASH    :", "return   Keys . BACKSLASH ;", "case    . KEY _ CLOSE _ BRACKET    :", "return   Keys . RIGHT _ BRACKET ;", "case    . KEY _ SINGLE _ QUOTE    :", "return   Keys . APOSTROPHE ;", "default    :", "return   Keys . UNKNOWN ;", "}", "}", "METHOD_END"], "methodName": ["keyForCode"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "justTouched    =    false ;", "if    ( yJustPressed )     {", "yJustPressed    =    false ;", "for    ( int   i    =     0  ;    i    <     ( justPressedKeys . length )  ;    i +  +  )     {", "justPressedKeys [ i ]     =    false ;", "}", "}", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.backends.gwt.GwtInput"}, {"methodBody": ["METHOD_START", "{", "sound . resume (  )  ;", "}", "METHOD_END"], "methodName": ["resume"], "fileName": "com.badlogic.gdx.backends.gwt.GwtMusic"}, {"methodBody": ["METHOD_START", "{", "if    ( key . endsWith (  \" b \"  )  )", "return   new   Boolean ( Boolean . parseBoolean ( value )  )  ;", "if    ( key . endsWith (  \" i \"  )  )", "return   new   Integer ( Integer . parseInt ( value )  )  ;", "if    ( key . endsWith (  \" l \"  )  )", "return   new   Long ( Long . parseLong ( value )  )  ;", "if    ( key . endsWith (  \" f \"  )  )", "return   new   Float ( Float . parseFloat ( value )  )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["toObject"], "fileName": "com.badlogic.gdx.backends.gwt.GwtPreferences"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   Boolean )", "return    (  ( prefix )     +    key )     +     \" b \"  ;", "if    ( value   instanceof   Integer )", "return    (  ( prefix )     +    key )     +     \" i \"  ;", "if    ( value   instanceof   Long )", "return    (  ( prefix )     +    key )     +     \" l \"  ;", "if    ( value   instanceof   Float )", "return    (  ( prefix )     +    key )     +     \" f \"  ;", "return    (  ( prefix )     +    key )     +     \" s \"  ;", "}", "METHOD_END"], "methodName": ["toStorageKey"], "fileName": "com.badlogic.gdx.backends.gwt.GwtPreferences"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( sounds . length )  ;    i +  +  )     {", "int   index    =     (  ( soundIndex )     +    i )     %     ( sounds . length )  ;", "if    (  (  ( sounds [ index ]  )     =  =    null )     |  |     (  !  ( sounds [ index ]  . isPlaying (  )  )  )  )     {", "soundIndex    =     ( index    +     1  )     %     ( sounds . length )  ;", "return   index ;", "}", "}", "int   index    =     ( soundIndex )     %     ( sounds . length )  ;", "soundIndex    =     ( index    +     1  )     %     ( sounds . length )  ;", "return   index ;", "}", "METHOD_END"], "methodName": ["findAvailableSound"], "fileName": "com.badlogic.gdx.backends.gwt.GwtSound"}, {"methodBody": ["METHOD_START", "{", "int   soundId    =    findAvailableSound (  )  ;", "if    ( soundId    >  =     0  )     {", "GwtMusic   sound ;", "if    (  ( sounds [ soundId ]  )     =  =    null )     {", "sounds [ soundId ]     =    new   GwtMusic ( soundFile )  ;", "}", "sound    =    sounds [ soundId ]  ;", "sound . stop (  )  ;", "sound . setPan ( pan ,    volume )  ;", "sound . setLooping ( loop )  ;", "sound . play (  )  ;", "}", "return   soundId ;", "}", "METHOD_END"], "methodName": ["play"], "fileName": "com.badlogic.gdx.backends.gwt.GwtSound"}, {"methodBody": ["METHOD_START", "{", "return   useBrowserCache ;", "}", "METHOD_END"], "methodName": ["isUseBrowserCache"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "return   useInlineBase 6  4  ;", "}", "METHOD_END"], "methodName": ["isUseInlineBase64"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   Text    :", "loadText ( url ,     (  (  . AssetLoaderListener < String >  )     ( listener )  )  )  ;", "break ;", "case   Image    :", "loadImage ( url ,    mimeType ,     (  (  . AssetLoaderListener < ImageElement >  )     ( listener )  )  )  ;", "break ;", "case   Binary    :", "loadBinary ( url ,     (  (  . AssetLoaderListener < Blob >  )     ( listener )  )  )  ;", "break ;", "case   Audio    :", "loadAudio ( url ,     (  (  . AssetLoaderListener < Void >  )     ( listener )  )  )  ;", "break ;", "case   Directory    :", "listener . onSuccess ( null )  ;", "break ;", "default    :", "throw   new   GdxRuntimeException (  (  \" Unsupported   asset   type    \"     +    type )  )  ;", "}", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "if    ( useBrowserCache )     {", "loadBinary ( url ,    new    . AssetLoaderListener < Blob >  (  )     {", "@ Override", "public   void   onProgress ( double   amount )     {", "listener . onProgress ( amount )  ;", "}", "@ Override", "public   void   onFailure (  )     {", "listener . onFailure (  )  ;", "}", "@ Override", "public   void   onSuccess ( Blob   result )     {", "listener . onSuccess ( null )  ;", "}", "}  )  ;", "} else    {", "listener . onSuccess ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["loadAudio"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "XMLHttpRequest   request    =    XMLHttpRequest . create (  )  ;", "request . setOnReadyStateChange ( new   ReadyStateChangeHandler (  )     {", "@ Override", "public   void   onReadyStateChange ( XMLHttpRequest   xhr )     {", "if    (  ( xhr . getReadyState (  )  )     =  =     ( XMLHttpRequest . DONE )  )     {", "if    (  ( xhr . getStatus (  )  )     !  =     2  0  0  )     {", "listener . onFailure (  )  ;", "} else    {", "Int 8 Array   data    =    TypedArrays . createInt 8 Array ( xhr . getResponseArrayBuffer (  )  )  ;", "listener . onSuccess ( new   Blob ( data )  )  ;", "}", "}", "}", "}  )  ;", ". setOnProgress ( request ,    listener )  ;", "request . open (  \" GET \"  ,    url )  ;", "request . setResponseType ( ArrayBuffer )  ;", "request . send (  )  ;", "}", "METHOD_END"], "methodName": ["loadBinary"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "loadImage ( url ,    mimeType ,    null ,    listener )  ;", "}", "METHOD_END"], "methodName": ["loadImage"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( useBrowserCache )     |  |     ( useInlineBase 6  4  )  )     {", "loadBinary ( url ,    new    . AssetLoaderListener < Blob >  (  )     {", "@ Override", "public   void   onProgress ( double   amount )     {", "listener . onProgress ( amount )  ;", "}", "@ Override", "public   void   onFailure (  )     {", "listener . onFailure (  )  ;", "}", "@ Override", "public   void   onSuccess ( Blob   result )     {", "final   ImageElement   image    =     . createImage (  )  ;", "if    ( crossOrigin    !  =    null )     {", "image . setAttribute (  \" crossOrigin \"  ,    crossOrigin )  ;", "}", ". hookImgListener ( image ,    new    . ImgEventListener (  )     {", "@ Override", "public   void   onEvent ( NativeEvent   event )     {", "if    ( event . getType (  )  . equals (  \" error \"  )  )", "listener . onFailure (  )  ;", "else", "listener . onSuccess ( image )  ;", "}", "}  )  ;", "if    ( isUseInlineBase 6  4  (  )  )     {", "image . setSrc (  (  (  (  \" data :  \"     +    mimeType )     +     \"  ; base 6  4  ,  \"  )     +     ( result . toBase 6  4  (  )  )  )  )  ;", "} else    {", "image . setSrc ( url )  ;", "}", "}", "}  )  ;", "} else    {", "final   ImageElement   image    =     . createImage (  )  ;", "if    ( crossOrigin    !  =    null )     {", "image . setAttribute (  \" crossOrigin \"  ,    crossOrigin )  ;", "}", ". hookImgListener ( image ,    new    . ImgEventListener (  )     {", "@ Override", "public   void   onEvent ( NativeEvent   event )     {", "if    ( event . getType (  )  . equals (  \" error \"  )  )", "listener . onFailure (  )  ;", "else", "listener . onSuccess ( image )  ;", "}", "}  )  ;", "image . setSrc ( url )  ;", "}", "}", "METHOD_END"], "methodName": ["loadImage"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "XMLHttpRequest   request    =    XMLHttpRequest . create (  )  ;", "request . setOnReadyStateChange ( new   ReadyStateChangeHandler (  )     {", "@ Override", "public   void   onReadyStateChange ( XMLHttpRequest   xhr )     {", "if    (  ( xhr . getReadyState (  )  )     =  =     ( XMLHttpRequest . DONE )  )     {", "if    (  ( xhr . getStatus (  )  )     !  =     2  0  0  )     {", "listener . onFailure (  )  ;", "} else    {", "listener . onSuccess ( xhr . getResponseText (  )  )  ;", "}", "}", "}", "}  )  ;", ". setOnProgress ( request ,    listener )  ;", "request . open (  \" GET \"  ,    url )  ;", "request . setRequestHeader (  \" Content - Type \"  ,     \" text / plain ;    charset = utf -  8  \"  )  ;", "request . send (  )  ;", "}", "METHOD_END"], "methodName": ["loadText"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "this . useBrowserCache    =    useBrowserCache ;", "}", "METHOD_END"], "methodName": ["setUseBrowserCache"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "this . useInlineBase 6  4     =    useInlineBase 6  4  ;", "}", "METHOD_END"], "methodName": ["setUseInlineBase64"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.AssetDownloader"}, {"methodBody": ["METHOD_START", "{", "return   data . get ( i )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Blob"}, {"methodBody": ["METHOD_START", "{", "return   data . length (  )  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Blob"}, {"methodBody": ["METHOD_START", "{", "return   new   InputStream (  )     {", "@ Override", "public   int   read (  )    throws   IOException    {", "if    (  ( pos )     =  =     ( length (  )  )  )", "return    -  1  ;", "return    ( get (  (  ( pos )  +  +  )  )  )     &     2  5  5  ;", "}", "@ Override", "public   int   available (  )     {", "return    ( length (  )  )     -     ( pos )  ;", "}", "int   pos ;", "}  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Blob"}, {"methodBody": ["METHOD_START", "{", "int   length    =    data . length (  )  ;", "String   base 6  4 code    =     \" ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz 0  1  2  3  4  5  6  7  8  9  +  /  \"  ;", "StringBuil   encoded    =    new   StringBuil (  (  (  ( length    *     4  )     /     3  )     +     2  )  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i    +  =     3  )     {", "if    (  ( length    -    i )     >  =     3  )     {", "int   j    =     (  (  (  ( data . get ( i )  )     &     2  5  5  )     <  <     1  6  )     +     (  (  ( data . get (  ( i    +     1  )  )  )     &     2  5  5  )     <  <     8  )  )     +     (  ( data . get (  ( i    +     2  )  )  )     &     2  5  5  )  ;", "encoded . append ( base 6  4 code . charAt (  (  ( j    >  >     1  8  )     &     6  3  )  )  )  ;", "encoded . append ( base 6  4 code . charAt (  (  ( j    >  >     1  2  )     &     6  3  )  )  )  ;", "encoded . append ( base 6  4 code . charAt (  (  ( j    >  >     6  )     &     6  3  )  )  )  ;", "encoded . append ( base 6  4 code . charAt (  ( j    &     6  3  )  )  )  ;", "} else", "if    (  ( length    -    i )     >  =     2  )     {", "int   j    =     (  (  ( data . get ( i )  )     &     2  5  5  )     <  <     1  6  )     +     (  (  ( data . get (  ( i    +     1  )  )  )     &     2  5  5  )     <  <     8  )  ;", "encoded . append ( base 6  4 code . charAt (  (  ( j    >  >     1  8  )     &     6  3  )  )  )  ;", "encoded . append ( base 6  4 code . charAt (  (  ( j    >  >     1  2  )     &     6  3  )  )  )  ;", "encoded . append ( base 6  4 code . charAt (  (  ( j    >  >     6  )     &     6  3  )  )  )  ;", "encoded . append (  \"  =  \"  )  ;", "} else    {", "int   j    =     (  ( data . get ( i )  )     &     2  5  5  )     <  <     1  6  ;", "encoded . append ( base 6  4 code . charAt (  (  ( j    >  >     1  8  )     &     6  3  )  )  )  ;", "encoded . append ( base 6  4 code . charAt (  (  ( j    >  >     1  2  )     &     6  3  )  )  )  ;", "encoded . append (  \"  =  =  \"  )  ;", "}", "}", "return   encoded . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toBase64"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Blob"}, {"methodBody": ["METHOD_START", "{", "String   name    =    file ;", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    =  =     (  -  1  )  )", "return    \"  \"  ;", "return   name . substring (  ( dotIndex    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["extension"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.DefaultAssetFilter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( extension . equals (  \" mp 3  \"  )  )     |  |     ( extension . equals (  \" ogg \"  )  )  )     |  |     ( extension . equals (  \" wav \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isAudio"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.DefaultAssetFilter"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( extension . equals (  \" jpg \"  )  )     |  |     ( extension . equals (  \" jpeg \"  )  )  )     |  |     ( extension . equals (  \" png \"  )  )  )     |  |     ( extension . equals (  \" bmp \"  )  )  )     |  |     ( extension . equals (  \" gif \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isImage"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.DefaultAssetFilter"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  ( extension . equals (  \" json \"  )  )     |  |     ( extension . equals (  \" xml \"  )  )  )     |  |     ( extension . equals (  \" txt \"  )  )  )     |  |     ( extension . equals (  \" glsl \"  )  )  )     |  |     ( extension . equals (  \" fnt \"  )  )  )     |  |     ( extension . equals (  \" pack \"  )  )  )     |  |     ( extension . equals (  \" obj \"  )  )  )     |  |     ( extension . equals (  \" atlas \"  )  )  )     |  |     ( extension . equals (  \" g 3 dj \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isText"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.DefaultAssetFilter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . getPath (  )  . length (  )  )     =  =     0  )", "return   new    ( new   File ( name )  ,    type )  ;", "return   new    ( new   File ( file ,    name )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "destDir . mkdirs (  )  ;", "[  ]    files    =    sourceDir . list (  )  ;", "for    ( int   i    =     0  ,    n    =    files . length ;    i    <    n ;    i +  +  )     {", "srcFile    =    files [ i ]  ;", "destFile    =    destDir . child ( srcFile . name (  )  )  ;", "if    ( srcFile . isDirectory (  )  )", ". copyDirectory ( srcFile ,    destFile )  ;", "else", ". copyFile ( srcFile ,    destFile )  ;", "}", "}", "METHOD_END"], "methodName": ["copyDirectory"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "try    {", "dest . write ( source . read (  )  ,    false )  ;", "}    catch    ( Exception   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  (  (  (  (  (  (  \" Error   copying   source   file :     \"     +     ( source . file )  )     +     \"     (  \"  )     +     ( source . type )  )     +     \"  )  \\ n \"  )     +     \" To   destination :     \"  )     +     ( dest . file )  )     +     \"     (  \"  )     +     ( dest . type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["copyFile"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "boolean   sourceDir    =    isDirectory (  )  ;", "if    (  ! sourceDir )     {", "if    ( dest . isDirectory (  )  )", "dest    =    dest . child ( name (  )  )  ;", "FileWrapper . copyFile ( this ,    dest )  ;", "return ;", "}", "if    ( dest . exists (  )  )     {", "if    (  !  ( dest . isDirectory (  )  )  )", "throw   new   utils . GdxRuntimeException (  (  \" Destination   exists   but   is   not   a   directory :     \"     +    dest )  )  ;", "} else    {", "dest . mkdirs (  )  ;", "if    (  !  ( dest . isDirectory (  )  )  )", "throw   new   utils . GdxRuntimeException (  (  \" Destination   directory   cannot   be   created :     \"     +    dest )  )  ;", "}", "if    (  ! sourceDir )", "dest    =    dest . child ( name (  )  )  ;", "FileWrapper . copyDirectory ( this ,    dest )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   an   internal   file :     \"     +     ( file )  )  )  ;", "return   file (  )  . delete (  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   delete   an   internal   file :     \"     +     ( file )  )  )  ;", "return   FileWrapper . deleteDirectory ( file (  )  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( file . exists (  )  )     {", "File [  ]    files    =    file . listFiles (  )  ;", "if    ( files    !  =    null )     {", "for    ( int   i    =     0  ,    n    =    files . length ;    i    <    n ;    i +  +  )     {", "if    ( files [ i ]  . isDirectory (  )  )", ". deleteDirectory ( files [ i ]  )  ;", "else", "files [ i ]  . delete (  )  ;", "}", "}", "}", "return   file . delete (  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   Internal    :", "if    ( file . exists (  )  )", "return   true ;", "case   Classpath    :", "return    (  . class . getResource (  (  \"  /  \"     +     ( file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  )  )  )  )     !  =    null ;", "}", "return   file (  )  . exists (  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "String   name    =    file . getName (  )  ;", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    =  =     (  -  1  )  )", "return    \"  \"  ;", "return   name . substring (  ( dotIndex    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["extension"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =    Type . External )  )", "return   new   io ( Gdx . files . getExternalStoragePath (  )  ,    file . getPath (  )  )  ;", "return   file ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Classpath )  )", "return   false ;", "return   file (  )  . isDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   file (  )  . lastModified (  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   file (  )  . length (  )  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   list   a   classpath   directory :     \"     +     ( file )  )  )  ;", "String [  ]    relativePaths    =    file (  )  . list (  )  ;", "if    ( relativePaths    =  =    null )", "return   new   FileWrapper [  0  ]  ;", "FileWrapper [  ]    handles    =    new   FileWrapper [ relativePaths . length ]  ;", "for    ( int   i    =     0  ,    n    =    relativePaths . length ;    i    <    n ;    i +  +  )", "handles [ i ]     =    child ( relativePaths [ i ]  )  ;", "return   handles ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   list   a   classpath   directory :     \"     +     ( file )  )  )  ;", "String [  ]    relativePaths    =    file (  )  . list (  )  ;", "if    ( relativePaths    =  =    null )", "return   new   FileWrapper [  0  ]  ;", "FileWrapper [  ]    handles    =    new   FileWrapper [ relativePaths . length ]  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ,    n    =    relativePaths . length ;    i    <    n ;    i +  +  )     {", "String   path    =    relativePaths [ i ]  ;", "if    (  !  ( path . endsWith ( suffix )  )  )", "continue ;", "handles [ count ]     =    child ( path )  ;", "count +  +  ;", "}", "if    ( count    <     ( relativePaths . length )  )     {", "FileWrapper [  ]    newHandles    =    new   FileWrapper [ count ]  ;", "System . arraycopy ( handles ,     0  ,    newHandles ,     0  ,    count )  ;", "handles    =    newHandles ;", "}", "return   handles ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   mkdirs   with   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   mkdirs   with   an   internal   file :     \"     +     ( file )  )  )  ;", "return   file (  )  . mkdirs (  )  ;", "}", "METHOD_END"], "methodName": ["mkdirs"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   move   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   move   an   internal   file :     \"     +     ( file )  )  )  ;", "copyTo ( dest )  ;", "delete (  )  ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   file . getName (  )  ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "String   name    =    file . getName (  )  ;", "int   dotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( dotIndex    =  =     (  -  1  )  )", "return   name ;", "return   name . substring (  0  ,    dotIndex )  ;", "}", "METHOD_END"], "methodName": ["nameWithoutExtension"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "File   parent    =    file . getParentFile (  )  ;", "if    ( parent    =  =    null )     {", "if    (  ( type )     =  =     ( FileType . Absolute )  )", "parent    =    new   File (  \"  /  \"  )  ;", "else", "parent    =    new   File (  \"  \"  )  ;", "}", "return   new    ( parent ,    type )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   file . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( type )     =  =     ( FileType . Classpath )  )     |  |     (  (  ( type )     =  =     ( FileType . Internal )  )     &  &     (  !  ( file . exists (  )  )  )  )  )     |  |     (  (  ( type )     =  =     ( FileType . Local )  )     &  &     (  !  ( file . exists (  )  )  )  )  )     {", "InputStream   input    =    FileWrapper . class . getResourceAsStream (  (  \"  /  \"     +     ( file . getPath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  )  )  )  ;", "if    ( input    =  =    null )", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" File   not   found :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  )  ;", "return   input ;", "}", "try    {", "return   new   FileInputStream ( file (  )  )  ;", "}    catch    ( Exception   ex )     {", "if    ( file (  )  . isDirectory (  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Cannot   open   a   stream   to   a   directory :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Error   reading   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   new   BufferedInputStream ( read (  )  ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "int   length    =     (  ( int )     ( length (  )  )  )  ;", "if    ( length    =  =     0  )", "length    =     5  1  2  ;", "byte [  ]    buffer    =    new   byte [ length ]  ;", "int   position    =     0  ;", "InputStream   input    =    read (  )  ;", "try    {", "wh    ( true )     {", "int   count    =    input . read ( buffer ,    position ,     (  ( buffer . length )     -    position )  )  ;", "if    ( count    =  =     (  -  1  )  )", "break ;", "position    +  =    count ;", "if    ( position    =  =     ( buffer . length )  )     {", "byte [  ]    newBuffer    =    new   byte [  ( buffer . length )     *     2  ]  ;", "System . arraycopy ( buffer ,     0  ,    newBuffer ,     0  ,    position )  ;", "buffer    =    newBuffer ;", "}", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   f :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( input    !  =    null )", "input . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "if    ( position    <     ( buffer . length )  )     {", "byte [  ]    newBuffer    =    new   byte [ position ]  ;", "System . arraycopy ( buffer ,     0  ,    newBuffer ,     0  ,    position )  ;", "buffer    =    newBuffer ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "InputStream   input    =    read (  )  ;", "int   position    =     0  ;", "try    {", "wh    ( true )     {", "int   count    =    input . read ( bytes ,     ( offset    +    position )  ,     ( size    -    position )  )  ;", "if    ( count    <  =     0  )", "break ;", "position    +  =    count ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   f :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( input    !  =    null )", "input . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "return   position    -    offset ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   readString ( null )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "int   fileLength    =     (  ( int )     ( length (  )  )  )  ;", "if    ( fileLength    =  =     0  )", "fileLength    =     5  1  2  ;", "StringBuilder   output    =    new   StringBuilder ( fileLength )  ;", "InputStreamRere =    null ;", "try    {", "if    ( charset    =  =    null )", "re =    new   InputStreamReread (  )  )  ;", "else", "re =    new   InputStreamReread (  )  ,    charset )  ;", "char [  ]    buffer    =    new   char [  2  5  6  ]  ;", "while    ( true )     {", "int   length    =    reread ( buffer )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "output . append ( buffer ,     0  ,    length )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   layout   file :     \"     +     ( this )  )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( re ;", "}", "return   output . toString (  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   new   InputStreamReader ( read (  )  )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   new   BufferedReader ( new   InputStreamReader ( read (  )  )  ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   BufferedRe ( new   InputStreamRe ( read (  )  ,    charset )  ,    bufferSize )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   file :     \"     +     ( this )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   InputStreamRe ( read (  )  ,    charset )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   GdxRuntimeException (  (  \" Error   reading   file :     \"     +     ( this )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "try    {", "File   file    =    File . createTempFile ( prefix ,    null )  ;", "if    (  !  ( file . delete (  )  )  )", "throw   new   IOException (  (  \" Unable   to   delete   temp   file :     \"     +    file )  )  ;", "if    (  !  ( file . mkdir (  )  )  )", "throw   new   IOException (  (  \" Unable   to   create   temp   directory :     \"     +    file )  )  ;", "return   new    ( file )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  \" Unable   to   create   temp   file .  \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["tempDirectory"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new    ( File . createTempFile ( prefix ,    null )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   GdxRuntimeException (  \" Unable   to   create   temp   file .  \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["tempFile"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   file . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   write   to   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   write   to   an   internal   file :     \"     +     ( file )  )  )  ;", "parent (  )  . mkdirs (  )  ;", "try    {", "return   new   FileOutputStream ( file (  )  ,    append )  ;", "}    catch    ( Exception   ex )     {", "if    ( file (  )  . isDirectory (  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Cannot   open   a   stream   to   a   directory :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Error   writing   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "OutputStream   output    =    null ;", "try    {", "output    =    write ( append )  ;", "byte [  ]    buffer    =    new   byte [  4  0  9  6  ]  ;", "while    ( true )     {", "int   length    =    input . read ( buffer )  ;", "if    ( length    =  =     (  -  1  )  )", "break ;", "output . write ( buffer ,     0  ,    length )  ;", "}", "}    catch    ( Exception   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Error   stream   writing   to   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "try    {", "if    ( input    !  =    null )", "input . close (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "try    {", "if    ( output    !  =    null )", "output . close (  )  ;", "}    catch    ( Exception   ignored )     {", "}", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "OutputStream   output    =    write ( append )  ;", "try    {", "output . write ( bytes )  ;", "}    catch    ( IOException   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Error   writing   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "try    {", "output . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "OutputStream   output    =    write ( append )  ;", "try    {", "output . write ( bytes ,    offset ,    length )  ;", "}    catch    ( IOException   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Error   writing   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "try    {", "output . close (  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "writeString ( string ,    append ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "Writer   writer    =    null ;", "try    {", "writer    =    writer ( append ,    charset )  ;", "writer . write ( string )  ;", "}    catch    ( Exception   ex )     {", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Error   writing   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}    finally    {", "StreamUtils . closeQuietly ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return   writer ( append ,    null )  ;", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type )     =  =     ( FileType . Classpath )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   write   to   a   classpath   file :     \"     +     ( file )  )  )  ;", "if    (  ( type )     =  =     ( FileType . Internal )  )", "throw   new   utils . GdxRuntimeException (  (  \" Cannot   write   to   an   internal   file :     \"     +     ( file )  )  )  ;", "parent (  )  . mkdirs (  )  ;", "try    {", "FileOutputStream   output    =    new   FileOutputStream ( file (  )  ,    append )  ;", "if    ( charset    =  =    null )", "return   new   OutputStreamWriter ( output )  ;", "else", "return   new   OutputStreamWriter ( output ,    charset )  ;", "}    catch    ( IOException   ex )     {", "if    ( file (  )  . isDirectory (  )  )", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Cannot   open   a   stream   to   a   directory :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "throw   new   utils . GdxRuntimeException (  (  (  (  (  \" Error   writing   file :     \"     +     ( file )  )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.FileWrapper"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( texts . containsKey ( url )  )     |  |     ( images . containsKey ( url )  )  )     |  |     ( binaries . containsKey ( url )  )  )     |  |     ( audio . containsKey ( url )  )  )     |  |     ( directories . containsKey ( url )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "return   audio . containsKey ( url )  ;", "}", "METHOD_END"], "methodName": ["isAudio"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "return   binaries . containsKey ( url )  ;", "}", "METHOD_END"], "methodName": ["isBinary"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "return    ( path . startsWith ( url )  )     &  &     (  ( path . indexOf (  '  /  '  ,     (  ( url . length (  )  )     +     1  )  )  )     <     0  )  ;", "}", "METHOD_END"], "methodName": ["isChild"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "return   directories . containsKey ( url )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "return   images . containsKey ( url )  ;", "}", "METHOD_END"], "methodName": ["isImage"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "return   texts . containsKey ( url )  ;", "}", "METHOD_END"], "methodName": ["isText"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "if    ( texts . containsKey ( url )  )     {", "try    {", "return   textet ( url )  . getBytes (  \" UTF -  8  \"  )  . length ;", "}    catch    ( UnsupportedEncodingException   e )     {", "return   textet ( url )  . getBytes (  )  . length ;", "}", "}", "if    ( images . containsKey ( url )  )     {", "return    1  ;", "}", "if    ( binaries . containsKey ( url )  )     {", "return   binarieet ( url )  . length (  )  ;", "}", "if    ( audio . containsKey ( url )  )     {", "return    1  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "Array < FileHandle >    files    =    new   Array < FileHandle >  (  )  ;", "for    ( String   path    :    texts . keys (  )  )     {", "if    ( isChild ( path ,    url )  )     {", "files . add ( new   GwtFileHandle ( this ,    path ,    FileType . Internal )  )  ;", "}", "}", "FileHandle [  ]    list    =    new   FileHandle [ files . size ]  ;", "System . arraycopy ( files . items ,     0  ,    list ,     0  ,    list . length )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "Array < FileHandle >    files    =    new   Array < FileHandle >  (  )  ;", "for    ( String   path    :    texts . keys (  )  )     {", "if    (  ( isChild ( path ,    url )  )     &  &     ( filtaccept ( new   File ( path )  )  )  )     {", "files . add ( new   GwtFileHandle ( this ,    path ,    FileType . Intal )  )  ;", "}", "}", "FileHandle [  ]    list    =    new   FileHandle [ files . size ]  ;", "System . arraycopy ( files . items ,     0  ,    list ,     0  ,    list . length )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "Array < FileHandle >    files    =    new   Array < FileHandle >  (  )  ;", "for    ( String   path    :    texts . keys (  )  )     {", "if    (  ( isChild ( path ,    url )  )     &  &     ( filtaccept ( new   File ( url )  ,    path . substring (  (  ( url . length (  )  )     +     1  )  )  )  )  )     {", "files . add ( new   GwtFileHandle ( this ,    path ,    FileType . Intal )  )  ;", "}", "}", "FileHandle [  ]    list    =    new   FileHandle [ files . size ]  ;", "System . arraycopy ( files . items ,     0  ,    list ,     0  ,    list . length )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "Array < FileHandle >    files    =    new   Array < FileHandle >  (  )  ;", "for    ( String   path    :    texts . keys (  )  )     {", "if    (  ( isChild ( path ,    url )  )     &  &     ( path . With ( suffix )  )  )     {", "files . add ( new   GwtFileHandle ( this ,    path ,    FileType . Internal )  )  ;", "}", "}", "FileHandle [  ]    list    =    new   FileHandle [ files . size ]  ;", "System . arraycopy ( files . items ,     0  ,    list ,     0  ,    list . length )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "final   AssetDownloader   loader    =    new   AssetDownloader (  )  ;", "loader . loadText (  (  ( baseUrl )     +    assetFileUrl )  ,    new   AssetDownloader . AssetLoaderListener < String >  (  )     {", "@ Override", "public   void   onProgress ( double   amount )     {", "}", "@ Override", "public   void   onFailure (  )     {", "callback . error ( assetFileUrl )  ;", "}", "@ Override", "public   void   onSuccess ( String   result )     {", "String [  ]    lines    =    result . split (  \"  \\ n \"  )  ;", "Array < Preloader . Asset >    assets    =    new   Array < Preloader . Asset >  ( lines . length )  ;", "for    ( String   line    :    lines )     {", "String [  ]    tokens    =    line . split (  \"  :  \"  )  ;", "if    (  ( tokens . length )     !  =     4  )     {", "throw   new   GdxRuntimeException (  \" Invalid   assets   description   file .  \"  )  ;", "}", "AssetFilter . AssetType   type    =    AssetFilter . AssetType . Text ;", "if    ( tokens [  0  ]  . equals (  \" i \"  )  )", "type    =    AssetFilter . AssetType . Image ;", "if    ( tokens [  0  ]  . equals (  \" b \"  )  )", "type    =    AssetFilter . AssetType . Binary ;", "if    ( tokens [  0  ]  . equals (  \" a \"  )  )", "type    =    AssetFilter . AssetType . Audio ;", "if    ( tokens [  0  ]  . equals (  \" d \"  )  )", "type    =    AssetFilter . AssetType . Directory ;", "long   size    =    Long . parseLong ( tokens [  2  ]  )  ;", "if    (  ( type    =  =     ( AssetFilter . AssetType . Audio )  )     &  &     (  !  ( loader . isUseBrowserCache (  )  )  )  )     {", "size    =     0  ;", "}", "assets . add ( new   Preloader . Asset ( tokens [  1  ]  . trim (  )  ,    type ,    size ,    tokens [  3  ]  )  )  ;", "}", "final   PState   state    =    new   PState ( assets )  ;", "for    ( int   i    =     0  ;    i    <     ( assets . size )  ;    i +  +  )     {", "final   Preloader . Asset   asset    =    assets . get ( i )  ;", "if    ( contains ( asset . url )  )     {", "asset . loaded    =    asset . size ;", "asset . succeed    =    true ;", "continue ;", "}", "loader . load (  (  ( baseUrl )     +     ( asset . url )  )  ,    asset . type ,    asset . mimeType ,    new   AssetDownloader . AssetLoaderListener < Object >  (  )     {", "@ Override", "public   void   onProgress ( double   amount )     {", "asset . loaded    =     (  ( long )     ( amount )  )  ;", "callback . update ( state )  ;", "}", "@ Override", "public   void   onFailure (  )     {", "asset . failed    =    true ;", "callback . error ( asset . url )  ;", "callback . update ( state )  ;", "}", "@ Override", "public   void   onSuccess ( Object   result )     {", "switch    ( asset . type )     {", "case   Text    :", "texts . put ( asset . url ,     (  ( String )     ( result )  )  )  ;", "break ;", "case   Image    :", "images . put ( asset . url ,     (  ( ImageElement )     ( result )  )  )  ;", "break ;", "case   Binary    :", "binaries . put ( asset . url ,     (  ( Blob )     ( result )  )  )  ;", "break ;", "case   Audio    :", "audio . put ( asset . url ,    null )  ;", "break ;", "case   Directory    :", "directories . put ( asset . url ,    null )  ;", "break ;", "}", "asset . succeed    =    true ;", "callback . update ( state )  ;", "}", "}  )  ;", "}", "callback . update ( state )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["preload"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "if    ( texts . containsKey ( url )  )     {", "try    {", "return   new   ByteArrayInputStream ( textet ( url )  . getBytes (  \" UTF -  8  \"  )  )  ;", "}    catch    ( UnsupportedEncodingException   e )     {", "return   null ;", "}", "}", "if    ( images . containsKey ( url )  )     {", "return   new   ByteArrayInputStream ( new   byte [  1  ]  )  ;", "}", "if    ( binaries . containsKey ( url )  )     {", "return   binarieet ( url )  . read (  )  ;", "}", "if    ( audio . containsKey ( url )  )     {", "return   new   ByteArrayInputStream ( new   byte [  1  ]  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.Preloader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( filter . accept ( destDir . path (  )  ,    true )  )  )", "return ;", "assets . add ( new    . Asset ( destDir ,    AssetFilter . AssetType . Directory )  )  ;", "destDir . mkdirs (  )  ;", "FileWrapper [  ]    files    =    sourceDir . list (  )  ;", "for    ( int   i    =     0  ,    n    =    files . length ;    i    <    n ;    i +  +  )     {", "FileWrapper   srcFile    =    files [ i ]  ;", "FileWrapper   destFile    =    destDir . child ( srcFile . name (  )  )  ;", "if    ( srcFile . isDirectory (  )  )", "copyDirectory ( srcFile ,    destFile ,    filter ,    assets )  ;", "else", "copyFile ( srcFile ,    destFile ,    filter ,    assets )  ;", "}", "}", "METHOD_END"], "methodName": ["copyDirectory"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.PreloaderBundleGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( filter . accept ( dest . path (  )  ,    false )  )  )", "return ;", "try    {", "assets . add ( new    . Asset ( dest ,    filter . getType ( dest . path (  )  )  )  )  ;", "dest . write ( source . read (  )  ,    false )  ;", "}    catch    ( Exception   ex )     {", "throw   new   GdxRuntimeException (  (  (  (  (  \" Error   copying   source   file :     \"     +    source )     +     \"  \\ n \"  )     +     \" To   destination :     \"  )     +    dest )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["copyFile"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.PreloaderBundleGenerator"}, {"methodBody": ["METHOD_START", "{", "String   packageName    =     \" com . badlogic . gdx . backends . gwt . preloader \"  ;", "String   className    =     \" PreloaderBundleImpl \"  ;", "ClassSourceFileComposerFactory   composer    =    new   ClassSourceFileComposerFactory ( packageName ,    className )  ;", "composer . addImplementedInterface (  ( packageName    +     \"  . PreloaderBundle \"  )  )  ;", "PrintWriter   printWriter    =    context . tryCreate ( logger ,    packageName ,    className )  ;", "if    ( printWriter    =  =    null )     {", "return    ( packageName    +     \"  .  \"  )     +    className ;", "}", "SourceWriter   sourceWriter    =    composer . createSourceWriter ( context ,    printWriter )  ;", "sourceWriter . commit ( logger )  ;", "return    ( packageName    +     \"  .  \"  )     +    className ;", "}", "METHOD_END"], "methodName": ["createDummyClass"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.PreloaderBundleGenerator"}, {"methodBody": ["METHOD_START", "{", "ConfigurationProperty   assetFilterClassProperty    =    null ;", "try    {", "assetFilterClassProperty    =    context . getPropertyOracle (  )  . getConfigurationProperty (  \" assetfilterclass \"  )  ;", "}    catch    ( BadPropertyValueException   e )     {", "return   new   DefaultAssetFilter (  )  ;", "}", "if    (  ( assetFilterClassProperty . getValues (  )  . size (  )  )     =  =     0  )     {", "return   new   DefaultAssetFilter (  )  ;", "}", "String   assetFilterClass    =    assetFilterClassProperty . getValues (  )  . get (  0  )  ;", "if    ( assetFilterClass    =  =    null )", "return   new   DefaultAssetFilter (  )  ;", "try    {", "return    (  ( AssetFilter )     ( Class . forName ( assetFilterClass )  . newInstance (  )  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  (  (  \" Couldn ' t   instantiate   custom   AssetFilter    '  \"     +    assetFilterClass )     +     \"  '  ,    make   sure   the   class   is   public   and   has   a   public   default   constructor \"  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getAssetFilter"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.PreloaderBundleGenerator"}, {"methodBody": ["METHOD_START", "{", "ConfigurationProperty   assetPathProperty    =    null ;", "try    {", "assetPathProperty    =    context . getPropertyOracle (  )  . getConfigurationProperty (  \" assetoutputpath \"  )  ;", "}    catch    ( BadPropertyValueException   e )     {", "return   null ;", "}", "if    (  ( assetPathProperty . getValues (  )  . size (  )  )     =  =     0  )     {", "return   null ;", "}", "String   paths    =    assetPathProperty . getValues (  )  . get (  0  )  ;", "if    ( paths    =  =    null )     {", "return   null ;", "} else    {", "ArrayList < String >    existingPaths    =    new   ArrayList < String >  (  )  ;", "String [  ]    tokens    =    paths . split (  \"  ,  \"  )  ;", "String   path    =    null ;", "for    ( String   token    :    tokens )     {", "if    (  ( new   FileWrapper ( token )  . exists (  )  )     |  |     ( new   FileWrapper ( token )  . mkdirs (  )  )  )     {", "path    =    token ;", "}", "}", "if    (  ( path    !  =    null )     &  &     (  !  ( path . endsWith (  \"  /  \"  )  )  )  )     {", "path    +  =     \"  /  \"  ;", "}", "return   path ;", "}", "}", "METHOD_END"], "methodName": ["getAssetOutputPath"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.PreloaderBundleGenerator"}, {"methodBody": ["METHOD_START", "{", "ConfigurationProperty   assetPathProperty    =    null ;", "try    {", "assetPathProperty    =    context . getPropertyOracle (  )  . getConfigurationProperty (  \" assetpath \"  )  ;", "}    catch    ( BadPropertyValueException   e )     {", "throw   new   RuntimeException (  \" No   assetpath   defined .    Add    < set - configuration - property   name =  \\  \" assetpath \\  \"    value =  \\  \" relative / path / to / assets /  \\  \"  /  >    to   your   GWT   projects   gwt . xml   file \"  )  ;", "}", "if    (  ( assetPathProperty . getValues (  )  . size (  )  )     =  =     0  )     {", "throw   new   RuntimeException (  \" No   assetpath   defined .    Add    < set - configuration - property   name =  \\  \" assetpath \\  \"    value =  \\  \" relative / path / to / assets /  \\  \"  /  >    to   your   GWT   projects   gwt . xml   file \"  )  ;", "}", "String   paths    =    assetPathProperty . getValues (  )  . get (  0  )  ;", "if    ( paths    =  =    null )     {", "throw   new   RuntimeException (  \" No   assetpath   defined .    Add    < set - configuration - property   name =  \\  \" assetpath \\  \"    value =  \\  \" relative / path / to / assets /  \\  \"  /  >    to   your   GWT   projects   gwt . xml   file \"  )  ;", "} else    {", "ArrayList < String >    existingPaths    =    new   ArrayList < String >  (  )  ;", "String [  ]    tokens    =    paths . split (  \"  ,  \"  )  ;", "for    ( String   token    :    tokens )     {", "System . out . println ( token )  ;", "if    (  ( new   FileWrapper ( token )  . exists (  )  )     |  |     ( new   FileWrapper (  (  \"  .  .  /  \"     +    token )  )  . exists (  )  )  )     {", "return   token ;", "}", "}", "throw   new   RuntimeException (  \" No   valid   assetpath   defined .    Fix    < set - configuration - property   name =  \\  \" assetpath \\  \"    value =  \\  \" relative / path / to / assets /  \\  \"  /  >    in   your   GWT   projects   gwt . xml   file \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAssetPath"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.PreloaderBundleGenerator"}, {"methodBody": ["METHOD_START", "{", "List < String >    classpathFiles    =    new   ArrayList < String >  (  )  ;", "try    {", "ConfigurationProperty   prop    =    context . getPropertyOracle (  )  . getConfigurationProperty (  \" files . classpath \"  )  ;", "for    ( String   value    :    prop . getValues (  )  )     {", "classpathFiles . add ( value )  ;", "}", "}    catch    ( BadPropertyValueException   e )     {", "}", "return   classpathFiles ;", "}", "METHOD_END"], "methodName": ["getClasspathFiles"], "fileName": "com.badlogic.gdx.backends.gwt.preloader.PreloaderBundleGenerator"}, {"methodBody": ["METHOD_START", "{", "return   placeholder ;", "}", "METHOD_END"], "methodName": ["getPlaceholder"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.PlaceholderTextBox"}, {"methodBody": ["METHOD_START", "{", "placeholder    =     ( text    !  =    null )     ?    text    :     \"  \"  ;", "getElement (  )  . setPropertyString (  \" placeholder \"  ,    placeholder )  ;", "}", "METHOD_END"], "methodName": ["setPlaceholder"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.PlaceholderTextBox"}, {"methodBody": ["METHOD_START", "{", "if    (  ( textFormatter )     !  =    null )     {", "return   textFormatter . getText ( this ,    cur )  ;", "} else    {", "return    (  ( int )     (  1  0  0     *     ( getPercent (  )  )  )  )     +     \"  %  \"  ;", "}", "}", "METHOD_END"], "methodName": ["generateText"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   barElement ;", "}", "METHOD_END"], "methodName": ["getBarElement"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   maxProgress ;", "}", "METHOD_END"], "methodName": ["getMaxProgress"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   minProgress ;", "}", "METHOD_END"], "methodName": ["getMinProgress"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    (  ( maxProgress )     <  =     ( minProgress )  )     {", "return    0  .  0  ;", "}", "double   percent    =     (  ( curProgress )     -     ( minProgress )  )     /     (  ( maxProgress )     -     ( minProgress )  )  ;", "return   Math . max (  0  .  0  ,    Math . min (  1  .  0  ,    percent )  )  ;", "}", "METHOD_END"], "methodName": ["getPercent"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   curProgress ;", "}", "METHOD_END"], "methodName": ["getProgress"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   textElement ;", "}", "METHOD_END"], "methodName": ["getTextElement"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   textFormatter ;", "}", "METHOD_END"], "methodName": ["getTextFormatter"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "return   textVisible ;", "}", "METHOD_END"], "methodName": ["isTextVisible"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    ( textVisible )     {", "int   textWidth    =    DOM . ElementPropertyInt ( textElement ,     \" offsetWidth \"  )  ;", "int   left    =     ( width    /     2  )     -     ( textWidth    /     2  )  ;", "DOM . setStyleAttribute ( textElement ,     \" left \"  ,     ( left    +     \" px \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["onResize"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "int   percent    =     (  ( int )     (  1  0  0     *     ( getPercent (  )  )  )  )  ;", "updateTextStyle ( percent )  ;", "}", "METHOD_END"], "methodName": ["onTextStyleChange"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    ( isAttached (  )  )     {", "int   th    =    DOM . getElementPropertyInt ( getElement (  )  ,     \" clientWidth \"  )  ;", "int   height    =    DOM . getElementPropertyInt ( getElement (  )  ,     \" clientHeight \"  )  ;", "onResize ( th ,    height )  ;", "}", "}", "METHOD_END"], "methodName": ["redraw"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "setProgress ( getProgress (  )  )  ;", "}", "METHOD_END"], "methodName": ["resetProgress"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "DOM . setElementProperty ( barElement ,     \" className \"  ,    barClassName )  ;", "}", "METHOD_END"], "methodName": ["setBarStyleName"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . maxProgress    =    maxProgress ;", "curProgress    =    Math . min ( curProgress ,    maxProgress )  ;", "resetProgress (  )  ;", "}", "METHOD_END"], "methodName": ["setMaxProgress"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . minProgress    =    minProgress ;", "curProgress    =    Math . max ( curProgress ,    minProgress )  ;", "resetProgress (  )  ;", "}", "METHOD_END"], "methodName": ["setMinProgress"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . curProgress    =    Math . max ( minProgress ,    Math . min ( maxProgress ,    curProgress )  )  ;", "int   percent    =     (  ( int )     (  1  0  0     *     ( getPercent (  )  )  )  )  ;", "DOM . setStyleAttribute ( barElement ,     \" width \"  ,     ( percent    +     \"  %  \"  )  )  ;", "DOM . setElementProperty ( textElement ,     \" innerHTML \"  ,    generateText ( curProgress )  )  ;", "updateTextStyle ( percent )  ;", "redraw (  )  ;", "}", "METHOD_END"], "methodName": ["setProgress"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . textFirstHalfClassName    =    textFirstHalfClassName ;", "onTextStyleChange (  )  ;", "}", "METHOD_END"], "methodName": ["setTextFirstHalfStyleName"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . textFormatter    =    textFormatter ;", "}", "METHOD_END"], "methodName": ["setTextFormatter"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . textSecondHalfClassName    =    textSecondHalfClassName ;", "onTextStyleChange (  )  ;", "}", "METHOD_END"], "methodName": ["setTextSecondHalfStyleName"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . textClassName    =    textClassName ;", "onTextStyleChange (  )  ;", "}", "METHOD_END"], "methodName": ["setTextStyleName"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "this . textVisible    =    textVisible ;", "if    ( this . textVisible )     {", "DOM . setStyleAttribute ( textElement ,     \" display \"  ,     \"  \"  )  ;", "redraw (  )  ;", "} else    {", "DOM . setStyleAttribute ( textElement ,     \" display \"  ,     \" none \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setTextVisible"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "if    ( percent    <     5  0  )     {", "DOM . setElementperty ( textElement ,     \" className \"  ,     (  (  ( textClassName )     +     \"     \"  )     +     ( textFirstHalfClassName )  )  )  ;", "} else    {", "DOM . setElementperty ( textElement ,     \" className \"  ,     (  (  ( textClassName )     +     \"     \"  )     +     ( textSecondHalfClassName )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateTextStyle"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ProgressBar"}, {"methodBody": ["METHOD_START", "{", "widgets . put ( widget ,    new   ResizableWidgetCollection . ResizableWidgetInfo ( widget )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < ResizableWidget ,    ResizableWidgetCollection . ResizableWidgetInfo >    entry    :    widgets . entrySet (  )  )     {", "ResizableWidget   widget    =    entry . getKey (  )  ;", "ResizableWidgetCollection . ResizableWidgetInfo   info    =    entry . getValue (  )  ;", "if    ( info . updateSizes (  )  )     {", "if    (  (  (  ( info . getOffsetWidth (  )  )     >     0  )     &  &     (  ( info . getOffsetHeight (  )  )     >     0  )  )     &  &     ( widget . isAttached (  )  )  )     {", "widget . onResize ( info . getOffsetWidth (  )  ,    info . getOffsetHeight (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkWidgetSize"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ResizableWidgetCollection . staticCollection )     =  =    null )     {", "ResizableWidgetCollection . staticCollection    =    new   ResizableWidgetCollection (  )  ;", "}", "return   ResizableWidgetCollection . staticCollection ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "return   resizeCheckDelay ;", "}", "METHOD_END"], "methodName": ["getResizeCheckDelay"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "return   resizeCheckingEnabled ;", "}", "METHOD_END"], "methodName": ["isResizeCheckingEnabled"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "return   widgets . keySet (  )  . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "widgets . remove ( widget )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "this . resizeCheckDelay    =    resizeCheckDelay ;", "}", "METHOD_END"], "methodName": ["setResizeCheckDelay"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "if    ( enabled    &  &     (  !  ( resizeCheckingEnabled )  )  )     {", "resizeCheckingEnabled    =    true ;", "if    (  ( windowHandler )     =  =    null )     {", "windowHandler    =    Window . addeHandler ( this )  ;", "}", "resizeCheckTimer . schedule ( resizeCheckDelay )  ;", "} else", "if    (  (  ! enabled )     &  &     ( resizeCheckingEnabled )  )     {", "resizeCheckingEnabled    =    false ;", "if    (  ( windowHandler )     !  =    null )     {", "windowHandler . removeHandler (  )  ;", "windowHandler    =    null ;", "}", "resizeCheckTimer . cancel (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setResizeCheckingEnabled"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( widget . isAttached (  )  )  )     {", "return ;", "}", ". ResizableWidgetInfo   info    =    widgets . get ( widget )  ;", "if    ( info    !  =    null )     {", "info . updateSizes (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateWidgetSize"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.ResizableWidgetCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( listener )     !  =    null )     {", "listener . onNegative (  )  ;", "}", "this . hide (  )  ;", "}", "METHOD_END"], "methodName": ["onNegative"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.TextInputDialogBox"}, {"methodBody": ["METHOD_START", "{", "if    (  ( listener )     !  =    null )     {", "listener . onPositive ( textBox . get (  )  )  ;", "}", "this . hide (  )  ;", "}", "METHOD_END"], "methodName": ["onPositive"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.TextInputDialogBox"}, {"methodBody": ["METHOD_START", "{", "this . listener    =    listener ;", "}", "METHOD_END"], "methodName": ["setListener"], "fileName": "com.badlogic.gdx.backends.gwt.widgets.TextInputDialogBox"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["extension"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["mkdirs"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["name"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["nameWithoutExtension"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["pathWithoutExtension"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["reader"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["sibling"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   GdxRuntimeException (  \" Stub \"  )  ;", "}", "METHOD_END"], "methodName": ["writer"], "fileName": "com.badlogic.gdx.files.FileHandle"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["deleteDirectory"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["mkdirs"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["moveTo"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["parent"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.badlogic.gdx.files.FileHandleStream"}, {"methodBody": ["METHOD_START", "{", "return    (  ( canvas )     =  =    null )     &  &     (  ( imageElement )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["canUseImageElement"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "if    (  ( blending )     =  =     (  . Blending . None )  )     {", "context . setFillStyle (  . clearColor )  ;", "context . setStrokeStyle (  . clearColor )  ;", "context . setGlobalCompositeOperation (  \" destination - out \"  )  ;", "context . beginPath (  )  ;", "context . arc ( x ,    y ,    radius ,     0  ,     (  2     *     ( Math . PI )  )  ,    false )  ;", "fillOrStrokePath ( drawType )  ;", "context . closePath (  )  ;", "context . setFillStyle ( color )  ;", "context . setStrokeStyle ( color )  ;", "context . setGlobalCompositeOperation ( SOURCE _ OVER )  ;", "}", "context . beginPath (  )  ;", "context . arc ( x ,    y ,    radius ,     0  ,     (  2     *     ( Math . PI )  )  ,    false )  ;", "fillOrStrokePath ( drawType )  ;", "context . closePath (  )  ;", "pixels    =    null ;", "}", "METHOD_END"], "methodName": ["circle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "canvas    =    Canvas . createIfSupported (  )  ;", "canvas . getCanvasElement (  )  . setWidth ( width )  ;", "canvas . getCanvasElement (  )  . setHeight ( height )  ;", "context    =    canvas . getContext 2 d (  )  ;", "context . setGlobalCompositeOperation (  . getComposite (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "circle ( x ,    y ,    radius ,    Pixmap . DrawType . STROKE )  ;", "}", "METHOD_END"], "methodName": ["drawCircle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "line ( x ,    y ,    x 2  ,    y 2  ,    Pixmap . DrawType . STROKE )  ;", "}", "METHOD_END"], "methodName": ["drawLine"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "rectangle ( x ,    y ,     1  ,     1  ,    Pixmap . DrawType . FILL )  ;", "}", "METHOD_END"], "methodName": ["drawPixel"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "setColor ( color )  ;", "drawel ( x ,    y )  ;", "}", "METHOD_END"], "methodName": ["drawPixel"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "CanvasElement   image    =    pixmap . getCanvasElement (  )  ;", "image ( image ,     0  ,     0  ,    image . getWidth (  )  ,    image . getHeight (  )  ,    x ,    y ,    image . getWidth (  )  ,    image . getHeight (  )  )  ;", "}", "METHOD_END"], "methodName": ["drawPixmap"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "CanvasElement   image    =    pixmap . getCanvasElement (  )  ;", "image ( image ,    srcx ,    srcy ,    srcWidth ,    srcHeight ,    x ,    y ,    srcWidth ,    srcHeight )  ;", "}", "METHOD_END"], "methodName": ["drawPixmap"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "image ( pixmap . getCanvasElement (  )  ,    srcx ,    srcy ,    srcWidth ,    srcHeight ,    dstx ,    dsty ,    dstWidth ,    dstHeight )  ;", "}", "METHOD_END"], "methodName": ["drawPixmap"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "rectangle ( x ,    y ,    width ,    height ,    Pixmap . DrawType . STROKE )  ;", "}", "METHOD_END"], "methodName": ["drawRectangle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( canvas )     =  =    null )     {", "create (  )  ;", "if    (  ( imageElement )     !  =    null )     {", "context . setGlobalCompositeOperation ( COPY )  ;", "context . drawImage ( imageElement ,     0  ,     0  )  ;", "context . setGlobalCompositeOperation (  . getComposite (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["ensureCanvasExists"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "context . clearRect (  0  ,     0  ,    getWidth (  )  ,    getHeight (  )  )  ;", "rectangle (  0  ,     0  ,    getWidth (  )  ,    getHeight (  )  ,     . DrawType . FILL )  ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "circle ( x ,    y ,    radius ,    Pixmap . DrawType . FILL )  ;", "}", "METHOD_END"], "methodName": ["fillCircle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "switch    ( dwType )     {", "case   FILL    :", "context . fill (  )  ;", "break ;", "case   STROKE    :", "context . stroke (  )  ;", "break ;", "}", "}", "METHOD_END"], "methodName": ["fillOrStrokePath"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "rectangle ( x ,    y ,    width ,    height ,    Pixmap . DrawType . FILL )  ;", "}", "METHOD_END"], "methodName": ["fillRectangle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "triangle ( x 1  ,    y 1  ,    x 2  ,    y 2  ,    x 3  ,    y 3  ,    Pixmap . DrawType . FILL )  ;", "}", "METHOD_END"], "methodName": ["fillTriangle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   blending ;", "}", "METHOD_END"], "methodName": ["getBlending"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "return   canvasetCanvasElement (  )  ;", "}", "METHOD_END"], "methodName": ["getCanvasElement"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   Composite . SOURCE _ OVER ;", "}", "METHOD_END"], "methodName": ["getComposite"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "return   ntext ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   filter ;", "}", "METHOD_END"], "methodName": ["getFilter"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   format ;", "}", "METHOD_END"], "methodName": ["getFormat"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . GL _ RGBA ;", "}", "METHOD_END"], "methodName": ["getGLFormat"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . GL _ RGBA ;", "}", "METHOD_END"], "methodName": ["getGLInternalFormat"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   GL 2  0  . GL _ UNSIGNED _ BYTE ;", "}", "METHOD_END"], "methodName": ["getGLType"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   height ;", "}", "METHOD_END"], "methodName": ["getHeight"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   imageElement ;", "}", "METHOD_END"], "methodName": ["getImageElement"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "if    (  ( pels )     =  =    null )", "pels    =    context . getImageData (  0  ,     0  ,    width ,    height )  . getData (  )  ;", "int   i    =     ( x    *     4  )     +     (  ( y    *     ( width )  )     *     4  )  ;", "int   r    =     ( pels . get (  ( i    +     0  )  )  )     &     2  5  5  ;", "int   g    =     ( pels . get (  ( i    +     1  )  )  )     &     2  5  5  ;", "int   b    =     ( pels . get (  ( i    +     2  )  )  )     &     2  5  5  ;", "int   a    =     ( pels . get (  ( i    +     3  )  )  )     &     2  5  5  ;", "return    (  (  ( r    <  <     2  4  )     |     ( g    <  <     1  6  )  )     |     ( b    <  <     8  )  )     |    a ;", "}", "METHOD_END"], "methodName": ["getPixel"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   buffer ;", "}", "METHOD_END"], "methodName": ["getPixels"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return   width ;", "}", "METHOD_END"], "methodName": ["getWidth"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "if    (  ( blending )     =  =     (  . Blending . None )  )     {", "context . setFillStyle (  . clearColor )  ;", "context . setStrokeStyle (  . clearColor )  ;", "context . setGlobalCompositeOperation (  \" destination - out \"  )  ;", "context . beginPath (  )  ;", "context . rect ( dstX ,    dstY ,    dstWidth ,    dstHeight )  ;", "fillOrStrokePath (  . DrawType . FILL )  ;", "context . closePath (  )  ;", "context . setFillStyle ( color )  ;", "context . setStrokeStyle ( color )  ;", "context . setGlobalCompositeOperation ( SOURCE _ OVER )  ;", "}", "context . drawImage ( image ,    srcX ,    srcY ,    srcWidth ,    srcHeight ,    dstX ,    dstY ,    dstWidth ,    dstHeight )  ;", "pixels    =    null ;", "}", "METHOD_END"], "methodName": ["image"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "if    (  ( blending )     =  =     (  . Blending . None )  )     {", "context . setFillStyle (  . clearColor )  ;", "context . setStrokeStyle (  . clearColor )  ;", "context . setGlobalCompositeOperation (  \" destination - out \"  )  ;", "context . beginPath (  )  ;", "context . moveTo ( x ,    y )  ;", "context . lineTo ( x 2  ,    y 2  )  ;", "fillOrStrokePath ( drawType )  ;", "context . closePath (  )  ;", "context . setFillStyle ( color )  ;", "context . setStrokeStyle ( color )  ;", "context . setGlobalCompositeOperation ( SOURCE _ OVER )  ;", "}", "context . beginPath (  )  ;", "context . moveTo ( x ,    y )  ;", "context . lineTo ( x 2  ,    y 2  )  ;", "fillOrStrokePath ( drawType )  ;", "context . closePath (  )  ;", "pixels    =    null ;", "}", "METHOD_END"], "methodName": ["line"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  \" rgba (  \"     +    r 2  )     +     \"  ,  \"  )     +    g 2  )     +     \"  ,  \"  )     +    b 2  )     +     \"  ,  \"  )     +    a 2  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["make"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "if    (  ( blending )     =  =     (  . Blending . None )  )     {", "context . setFillStyle (  . clearColor )  ;", "context . setStrokeStyle (  . clearColor )  ;", "context . setGlobalCompositeOperation (  \" destination - out \"  )  ;", "context . beginPath (  )  ;", "context . rect ( x ,    y ,    width ,    height )  ;", "fillOrStrokePath ( drawType )  ;", "context . closePath (  )  ;", "context . setFillStyle ( color )  ;", "context . setStrokeStyle ( color )  ;", "context . setGlobalCompositeOperation ( SOURCE _ OVER )  ;", "}", "context . beginPath (  )  ;", "context . rect ( x ,    y ,    width ,    height )  ;", "fillOrStrokePath ( drawType )  ;", "context . closePath (  )  ;", "pixels    =    null ;", "}", "METHOD_END"], "methodName": ["rectangle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "this . blending    =    blending ;", "this . ensureCanvasExists (  )  ;", "this . context . setGlobalCompositeOperation (  . getComposite (  )  )  ;", "}", "METHOD_END"], "methodName": ["setBlending"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "setColor ( color . r ,    color . g ,    color . b ,    color . a )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "this . r    =     (  ( int )     ( r    *     2  5  5  )  )  ;", "this . g    =     (  ( int )     ( g    *     2  5  5  )  )  ;", "this . b    =     (  ( int )     ( b    *     2  5  5  )  )  ;", "this . a    =    a ;", "color    =     . make ( this . r ,    this . g ,    this . b ,    this . a )  ;", "context . setFillStyle ( color )  ;", "context . setStrokeStyle ( this . color )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "r    =     ( color    >  >  >     2  4  )     &     2  5  5  ;", "g    =     ( color    >  >  >     1  6  )     &     2  5  5  ;", "b    =     ( color    >  >  >     8  )     &     2  5  5  ;", "a    =     ( color    &     2  5  5  )     /     2  5  5  .  0 F ;", "this . color    =     . make ( r ,    g ,    b ,    a )  ;", "context . setFillStyle ( this . color )  ;", "context . setStrokeStyle ( this . color )  ;", "}", "METHOD_END"], "methodName": ["setColor"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "this . filter    =    filter ;", "}", "METHOD_END"], "methodName": ["setFilter"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "ensureCanvasExists (  )  ;", "if    (  ( blending )     =  =     (  . Blending . None )  )     {", "context . setFillStyle (  . clearColor )  ;", "context . setStrokeStyle (  . clearColor )  ;", "context . setGlobalCompositeOperation (  \" destination - out \"  )  ;", "context . beginPath (  )  ;", "context . moveTo ( x 1  ,    y 1  )  ;", "context . lineTo ( x 2  ,    y 2  )  ;", "context . lineTo ( x 3  ,    y 3  )  ;", "context . lineTo ( x 1  ,    y 1  )  ;", "fillOrStrokePath ( drawType )  ;", "context . closePath (  )  ;", "context . setFillStyle ( color )  ;", "context . setStrokeStyle ( color )  ;", "context . setGlobalCompositeOperation ( SOURCE _ OVER )  ;", "}", "context . beginPath (  )  ;", "context . moveTo ( x 1  ,    y 1  )  ;", "context . lineTo ( x 2  ,    y 2  )  ;", "context . lineTo ( x 3  ,    y 3  )  ;", "context . lineTo ( x 1  ,    y 1  )  ;", "fillOrStrokePath ( drawType )  ;", "context . closePath (  )  ;", "pixels    =    null ;", "}", "METHOD_END"], "methodName": ["triangle"], "fileName": "com.badlogic.gdx.graphics.Pixmap"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( Gdx . gl 2  0  )     =  =    null )     &  &     ( FileTextureData . copyToPOT )  )     {", "int   pixmapWidth    =    pixmap . getWidth (  )  ;", "int   pixmapHeight    =    pixmap . getHeight (  )  ;", "int   potWidth    =    MathUtils . nextPowerOfTwo ( pixmapWidth )  ;", "int   potHeight    =    MathUtils . nextPowerOfTwo ( pixmapHeight )  ;", "if    (  ( pixmapWidth    !  =    potWidth )     |  |     ( pixmapHeight    !  =    potHeight )  )     {", "Pixmap   tmp    =    new   Pixmap ( potWidth ,    potHeight ,    pixmap . getFormat (  )  )  ;", "tmp . drawPixmap ( pixmap ,     0  ,     0  ,     0  ,     0  ,    pixmapWidth ,    pixmapHeight )  ;", "pixmap . dispose (  )  ;", "return   tmp ;", "}", "}", "return   pixmap ;", "}", "METHOD_END"], "methodName": ["ensurePot"], "fileName": "com.badlogic.gdx.graphics.glutils.FileTextureData"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFileHandle"], "fileName": "com.badlogic.gdx.graphics.glutils.FileTextureData"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bufferHandle )     =  =     0  )", "throw   new   utils . GdxRuntimeException (  \" No   buffer   allocated !  \"  )  ;", "gl 2  0  . glBindBuffer ( GL _ ELEMENT _ ARRAY _ BUFFER ,    bufferHandle )  ;", "if    ( isDirty )     {", "gl 2  0  . glBufferData ( GL _ ELEMENT _ ARRAY _ BUFFER ,    buffer . limit (  )  ,    buffer ,    usage )  ;", "isDirty    =    false ;", "}", "isBound    =    true ;", "}", "METHOD_END"], "methodName": ["bind"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "GL 2  0    gl    =    Gdx . gl 2  0  ;", "gl . glBind ( GL _ ELEMENT _ ARRAY _ BUFFER ,     0  )  ;", "gl . glDelete ( bufferHandle )  ;", "bufferHandle    =     0  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "isDirty    =    true ;", "return   b ;", "}", "METHOD_END"], "methodName": ["getBuffer"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "return   buffer . limit (  )  ;", "}", "METHOD_END"], "methodName": ["getNumIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "return   buffer . capacity (  )  ;", "}", "METHOD_END"], "methodName": ["getNumMaxIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "bufferHandle    =    gl 2  0  . glGenBuffer (  )  ;", "isDirty    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "isDirty    =    true ;", "buffer . clear (  )  ;", "buffer . put ( indices )  ;", "buffer . flip (  )  ;", "if    ( isBound )     {", "gl 2  0  . glData ( GL _ ELEMENT _ ARRAY _ BUFFER ,    buffer . limit (  )  ,    buffer ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "isDirty    =    true ;", "buffer . clear (  )  ;", "buffer . put ( indices ,    offset ,    count )  ;", "buffer . flip (  )  ;", "if    ( isBound )     {", "gl 2  0  . glData ( GL _ ELEMENT _ ARRAY _ BUFFER ,    buffer . limit (  )  ,    buffer ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "gl 2  0  . glBindBuffer ( GL _ ELEMENT _ ARRAY _ BUFFER ,     0  )  ;", "isBound    =    false ;", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "com.badlogic.gdx.graphics.glutils.IndexBufferObject"}, {"methodBody": ["METHOD_START", "{", "if    ( isBound )     {", "gl 2  0  . glData ( GL _ ARRAY _ BUFFER ,    buffer . limit (  )  ,    buffer ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["bufferChanged"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObject"}, {"methodBody": ["METHOD_START", "{", "bufferHandle    =    gl 2  0  . glGenBuffer (  )  ;", "isDirty    =    true ;", "}", "METHOD_END"], "methodName": ["invalidate"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObject"}, {"methodBody": ["METHOD_START", "{", "boolean   stillValid    =     ( this . cachedLocations . size )     !  =     0  ;", "final   int   numAttributes    =    attributes . size (  )  ;", "if    ( stillValid )     {", "if    ( locations    =  =    null )     {", "for    ( int   i    =     0  ;    stillValid    &  &     ( i    <    numAttributes )  ;    i +  +  )     {", "Attribute   attribute    =    attributes . get ( i )  ;", "int   location    =    shader . getAttributeLocation ( attribute . alias )  ;", "stillValid    =    location    =  =     ( this . cachedLocations . get ( i )  )  ;", "}", "} else    {", "stillValid    =     ( locations . length )     =  =     ( this . cachedLocations . size )  ;", "for    ( int   i    =     0  ;    stillValid    &  &     ( i    <    numAttributes )  ;    i +  +  )     {", "stillValid    =     ( locations [ i ]  )     =  =     ( this . cachedLocations . get ( i )  )  ;", "}", "}", "}", "if    (  ! stillValid )     {", "gl . glBindBuffer ( GL _ ARRAY _ BUFFER ,    bufferHandle )  ;", "unbindAttributes ( shader )  ;", "this . cachedLocations . clear (  )  ;", "for    ( int   i    =     0  ;    i    <    numAttributes ;    i +  +  )     {", "Attribute   attribute    =    attributes . get ( i )  ;", "if    ( locations    =  =    null )     {", "this . cachedLocations . add ( shader . getAttributeLocation ( attribute . alias )  )  ;", "} else    {", "this . cachedLocations . add ( locations [ i ]  )  ;", "}", "int   location    =    this . cachedLocations . get ( i )  ;", "if    ( location    <     0  )     {", "continue ;", "}", "shader . enableAttribute ( location )  ;", "shader . setAttribute ( location ,    attribute . numComponents ,    attribute . type ,    attribute . normalized ,    attributes . vertexSize ,    attribute . offset )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["bindAttributes"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "if    ( isDirty )     {", "gl . glBind ( GL _ ARRAY _ BUFFER ,    bufferHandle )  ;", "buffer . limit ( buffer . limit (  )  )  ;", "gl . glData ( GL _ ARRAY _ BUFFER ,    buffer . limit (  )  ,    buffer ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["bindData"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "if    ( isBound )     {", "gl 2  0  . glData ( GL _ ARRAY _ BUFFER ,    buffer . limit (  )  ,    buffer ,    usage )  ;", "isDirty    =    false ;", "}", "}", "METHOD_END"], "methodName": ["bufferChanged"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "VertexBufferObjectWithVAO . tmpHandle . clear (  )  ;", "gl 3  0  . glGenVertexArrays (  1  ,    VertexBufferObjectWithVAO . tmpHandle )  ;", "vaoHandle    =    VertexBufferObjectWithVAO . tmpHandle . get (  )  ;", "}", "METHOD_END"], "methodName": ["createVAO"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "if    (  ( vaoHandle )     !  =     (  -  1  )  )     {", ". tmpHandle . clear (  )  ;", ". tmpHandle . put ( vaoHandle )  ;", ". tmpHandle . flip (  )  ;", "gl 3  0  . glDeleteVertexArrays (  1  ,     . tmpHandle )  ;", "vaoHandle    =     -  1  ;", "}", "}", "METHOD_END"], "methodName": ["deleteVAO"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cachedLocations )     =  =    null )     {", "return ;", "}", "int   numAttributes    =    attributes . size (  )  ;", "for    ( int   i    =     0  ;    i    <    numAttributes ;    i +  +  )     {", "int   location    =    cachedLocations . get ( i )  ;", "if    ( location    <     0  )     {", "continue ;", "}", "shaderProgram . disableAttribute ( location )  ;", "}", "}", "METHOD_END"], "methodName": ["unbindAttributes"], "fileName": "com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO"}, {"methodBody": ["METHOD_START", "{", "getScale ( Matrix 4  . tmpVec )  ;", "other . getScale ( Matrix 4  . tmpForward )  ;", "getRotation ( Matrix 4  . quat )  ;", "other . getRotation ( Matrix 4  . quat 2  )  ;", "getTranslation ( Matrix 4  . tmpUp )  ;", "other . getTranslation ( Matrix 4  . right )  ;", "setToScaling ( Matrix 4  . tmpVec . scl ( w )  . add ( Matrix 4  . tmpForward . scl (  (  1     -    w )  )  )  )  ;", "rotate ( Matrix 4  . quat . slerp ( Matrix 4  . quat 2  ,     (  1     -    w )  )  )  ;", "setTranslation ( Matrix 4  . tmpUp . scl ( w )  . add ( Matrix 4  . right . scl (  (  1     -    w )  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["avg"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "final   float   w    =     1  .  0 F    /     ( t . length )  ;", ". tmpVec . set ( t [  0  ]  . getScale (  . tmpUp )  . scl ( w )  )  ;", ". quat . set ( t [  0  ]  . getRotation (  . quat 2  )  . exp ( w )  )  ;", ". tmpForward . set ( t [  0  ]  . getTranslation (  . tmpUp )  . scl ( w )  )  ;", "for    ( int   i    =     1  ;    i    <     ( t . length )  ;    i +  +  )     {", ". tmpVec . add ( t [ i ]  . getScale (  . tmpUp )  . scl ( w )  )  ;", ". quat . mul ( t [ i ]  . getRotation (  . quat 2  )  . exp ( w )  )  ;", ". tmpForward . add ( t [ i ]  . getTranslation (  . tmpUp )  . scl ( w )  )  ;", "}", ". quat . nor (  )  ;", "setToScaling (  . tmpVec )  ;", "rotate (  . quat )  ;", "setTranslation (  . tmpForward )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["avg"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmpVec . set ( t [  0  ]  . getScale ( Matrix 4  . tmpUp )  . scl ( w [  0  ]  )  )  ;", "Matrix 4  . quat . set ( t [  0  ]  . getRotation ( Matrix 4  . quat 2  )  . exp ( w [  0  ]  )  )  ;", "Matrix 4  . tmpForward . set ( t [  0  ]  . getTranslation ( Matrix 4  . tmpUp )  . scl ( w [  0  ]  )  )  ;", "for    ( int   i    =     1  ;    i    <     ( t . length )  ;    i +  +  )     {", "Matrix 4  . tmpVec . add ( t [ i ]  . getScale ( Matrix 4  . tmpUp )  . scl ( w [ i ]  )  )  ;", "Matrix 4  . quat . mul ( t [ i ]  . getRotation ( Matrix 4  . quat 2  )  . exp ( w [ i ]  )  )  ;", "Matrix 4  . tmpForward . add ( t [ i ]  . getTranslation ( Matrix 4  . tmpUp )  . scl ( w [ i ]  )  )  ;", "}", "Matrix 4  . quat . nor (  )  ;", "setToScaling ( Matrix 4  . tmpVec )  ;", "rotate ( Matrix 4  . quat )  ;", "setTranslation ( Matrix 4  . tmpForward )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["avg"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   new   Matrix 4  ( this )  ;", "}", "METHOD_END"], "methodName": ["cpy"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["det"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   Matrix 4  . matrix 4  _ det ( values )  ;", "}", "METHOD_END"], "methodName": ["det"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["det3x3"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "dst [  0  ]     =    val [ Matrix 4  . M 0  0  ]  ;", "dst [  1  ]     =    val [ Matrix 4  . M 1  0  ]  ;", "dst [  2  ]     =    val [ Matrix 4  . M 2  0  ]  ;", "dst [  3  ]     =    val [ Matrix 4  . M 0  1  ]  ;", "dst [  4  ]     =    val [ Matrix 4  . M 1  1  ]  ;", "dst [  5  ]     =    val [ Matrix 4  . M 2  1  ]  ;", "dst [  6  ]     =    val [ Matrix 4  . M 0  2  ]  ;", "dst [  7  ]     =    val [ Matrix 4  . M 1  2  ]  ;", "dst [  8  ]     =    val [ Matrix 4  . M 2  2  ]  ;", "dst [  9  ]     =    val [ Matrix 4  . M 0  3  ]  ;", "dst [  1  0  ]     =    val [ Matrix 4  . M 1  3  ]  ;", "dst [  1  1  ]     =    val [ Matrix 4  . M 2  3  ]  ;", "}", "METHOD_END"], "methodName": ["extract4x3Matrix"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   rotation . setFromMatrix ( this )  ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   rotation . setFromMatrix ( normalizeAxes ,    this )  ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   scale . set ( getScaleX (  )  ,    getScaleY (  )  ,    getScaleZ (  )  )  ;", "}", "METHOD_END"], "methodName": ["getScale"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . isZero ( val [ Matrix 4  . M 0  1  ]  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 0  2  ]  )  )     ?    Math . abs ( val [ Matrix 4  . M 0  0  ]  )     :     (  ( float )     ( Math . sqrt ( getScaleXSquared (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleX"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleXSquared"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . isZero ( val [ Matrix 4  . M 1  0  ]  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 1  2  ]  )  )     ?    Math . abs ( val [ Matrix 4  . M 1  1  ]  )     :     (  ( float )     ( Math . sqrt ( getScaleYSquared (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleY"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     +     (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleYSquared"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    ( MathUtils . isZero ( val [ Matrix 4  . M 2  0  ]  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 2  1  ]  )  )     ?    Math . abs ( val [ Matrix 4  . M 2  2  ]  )     :     (  ( float )     ( Math . sqrt ( getScaleZSquared (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleZ"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     +     (  ( val [ Matrix 4  . M 2  1  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  2  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["getScaleZSquared"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "position . x    =    val [ Matrix 4  . M 0  3  ]  ;", "position . y    =    val [ Matrix 4  . M 1  3  ]  ;", "position . z    =    val [ Matrix 4  . M 2  3  ]  ;", "return   position ;", "}", "METHOD_END"], "methodName": ["getTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   val ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    !  (  (  (  (  (  (  (  (  ( MathUtils . isEqual ( val [ Matrix 4  . M 0  0  ]  ,     1  )  )     &  &     ( MathUtils . isEqual ( val [ Matrix 4  . M 1  1  ]  ,     1  )  )  )     &  &     ( MathUtils . isEqual ( val [ Matrix 4  . M 2  2  ]  ,     1  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 0  1  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 0  2  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 1  0  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 1  2  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 2  0  ]  )  )  )     &  &     ( MathUtils . isZero ( val [ Matrix 4  . M 2  1  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasRotationOrScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =     1  ;", "val [ Matrix 4  . M 0  1  ]     =     0  ;", "val [ Matrix 4  . M 0  2  ]     =     0  ;", "val [ Matrix 4  . M 0  3  ]     =     0  ;", "val [ Matrix 4  . M 1  0  ]     =     0  ;", "val [ Matrix 4  . M 1  1  ]     =     1  ;", "val [ Matrix 4  . M 1  2  ]     =     0  ;", "val [ Matrix 4  . M 1  3  ]     =     0  ;", "val [ Matrix 4  . M 2  0  ]     =     0  ;", "val [ Matrix 4  . M 2  1  ]     =     0  ;", "val [ Matrix 4  . M 2  2  ]     =     1  ;", "val [ Matrix 4  . M 2  3  ]     =     0  ;", "val [ Matrix 4  . M 3  0  ]     =     0  ;", "val [ Matrix 4  . M 3  1  ]     =     0  ;", "val [ Matrix 4  . M 3  2  ]     =     0  ;", "val [ Matrix 4  . M 3  3  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["idt"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "float   l _ det    =     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "if    ( l _ det    =  =     0  .  0 F )", "throw   new   RuntimeException (  \" non - invertible   matrix \"  )  ;", "float   inv _ det    =     1  .  0 F    /    l _ det ;", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     -     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =     (  (  (  (  (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )     -     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     -     (  (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  ;", "val [ Matrix 4  . M 0  0  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 0  0  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 0  1  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 0  1  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 0  2  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 0  2  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 0  3  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 0  3  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 1  0  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 1  0  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 1  1  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 1  1  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 1  2  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 1  2  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 1  3  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 1  3  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 2  0  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 2  0  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 2  1  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 2  1  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 2  2  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 2  2  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 2  3  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 2  3  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 3  0  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 3  0  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 3  1  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 3  1  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 3  2  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 3  2  ]  )     *    inv _ det ;", "val [ Matrix 4  . M 3  3  ]     =     ( Matrix 4  . tmp [ Matrix 4  . M 3  3  ]  )     *    inv _ det ;", "return   this ;", "}", "METHOD_END"], "methodName": ["inv"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   Matrix 4  . matrix 4  _ inv ( values )  ;", "}", "METHOD_END"], "methodName": ["inv"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  6  ;    i +  +  )", "this . val [ i ]     =     (  ( this . val [ i ]  )     *     (  1     -    alpha )  )     +     (  ( m . val [ i ]  )     *    alpha )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["lerp"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     -     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  )     +     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["matrix4_det"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "float [  ]    tmp    =    new   float [  1  6  ]  ;", "float   l _ det    =     . matrix 4  _ det ( val )  ;", "if    ( l _ det    =  =     0  )", "return   false ;", "tmp [  . M 0  0  ]     =     (  (  (  (  (  (  ( val [  . M 1  2  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  1  ]  )  )     -     (  (  ( val [  . M 1  3  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     +     (  (  ( val [  . M 1  3  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     -     (  (  ( val [  . M 1  1  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     -     (  (  ( val [  . M 1  2  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  3  ]  )  )  )     +     (  (  ( val [  . M 1  1  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  3  ]  )  )  ;", "tmp [  . M 0  1  ]     =     (  (  (  (  (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  1  ]  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     -     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     +     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     +     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  3  ]  )  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  3  ]  )  )  ;", "tmp [  . M 0  2  ]     =     (  (  (  (  (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 3  1  ]  )  )     -     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     +     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 3  3  ]  )  )  )     +     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 3  3  ]  )  )  ;", "tmp [  . M 0  3  ]     =     (  (  (  (  (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 2  1  ]  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 2  1  ]  )  )  )     -     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 2  2  ]  )  )  )     +     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 2  2  ]  )  )  )     +     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 2  3  ]  )  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 2  3  ]  )  )  ;", "tmp [  . M 1  0  ]     =     (  (  (  (  (  (  ( val [  . M 1  3  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  0  ]  )  )     -     (  (  ( val [  . M 1  2  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  0  ]  )  )  )     -     (  (  ( val [  . M 1  3  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     +     (  (  ( val [  . M 1  0  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     +     (  (  ( val [  . M 1  2  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  3  ]  )  )  )     -     (  (  ( val [  . M 1  0  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  3  ]  )  )  ;", "tmp [  . M 1  1  ]     =     (  (  (  (  (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  0  ]  )  )     -     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  0  ]  )  )  )     +     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  3  ]  )  )  )     +     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  3  ]  )  )  ;", "tmp [  . M 1  2  ]     =     (  (  (  (  (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 3  0  ]  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 3  0  ]  )  )  )     -     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     +     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     +     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 3  3  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 3  3  ]  )  )  ;", "tmp [  . M 1  3  ]     =     (  (  (  (  (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 2  0  ]  )  )     -     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 2  0  ]  )  )  )     +     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 2  2  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 2  2  ]  )  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 2  3  ]  )  )  )     +     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 2  3  ]  )  )  ;", "tmp [  . M 2  0  ]     =     (  (  (  (  (  (  ( val [  . M 1  1  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  0  ]  )  )     -     (  (  ( val [  . M 1  3  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  0  ]  )  )  )     +     (  (  ( val [  . M 1  3  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     -     (  (  ( val [  . M 1  0  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     -     (  (  ( val [  . M 1  1  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  3  ]  )  )  )     +     (  (  ( val [  . M 1  0  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  3  ]  )  )  ;", "tmp [  . M 2  1  ]     =     (  (  (  (  (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  0  ]  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  0  ]  )  )  )     -     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     +     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 2  3  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     +     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  3  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  3  ]  )  )  ;", "tmp [  . M 2  2  ]     =     (  (  (  (  (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 3  0  ]  )  )     -     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 3  0  ]  )  )  )     +     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 3  3  ]  )  )  )     +     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 3  3  ]  )  )  ;", "tmp [  . M 2  3  ]     =     (  (  (  (  (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 2  0  ]  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 2  0  ]  )  )  )     -     (  (  ( val [  . M 0  3  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 2  1  ]  )  )  )     +     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  3  ]  )  )     *     ( val [  . M 2  1  ]  )  )  )     +     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 2  3  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 2  3  ]  )  )  ;", "tmp [  . M 3  0  ]     =     (  (  (  (  (  (  ( val [  . M 1  2  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  0  ]  )  )     -     (  (  ( val [  . M 1  1  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  0  ]  )  )  )     -     (  (  ( val [  . M 1  2  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     +     (  (  ( val [  . M 1  0  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     +     (  (  ( val [  . M 1  1  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     -     (  (  ( val [  . M 1  0  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  2  ]  )  )  ;", "tmp [  . M 3  1  ]     =     (  (  (  (  (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  0  ]  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  0  ]  )  )  )     +     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 2  2  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 2  0  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     +     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 2  1  ]  )  )     *     ( val [  . M 3  2  ]  )  )  ;", "tmp [  . M 3  2  ]     =     (  (  (  (  (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 3  0  ]  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 3  0  ]  )  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     +     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 3  1  ]  )  )  )     +     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 3  2  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 3  2  ]  )  )  ;", "tmp [  . M 3  3  ]     =     (  (  (  (  (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 2  0  ]  )  )     -     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 2  0  ]  )  )  )     +     (  (  ( val [  . M 0  2  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 2  1  ]  )  )  )     -     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  2  ]  )  )     *     ( val [  . M 2  1  ]  )  )  )     -     (  (  ( val [  . M 0  1  ]  )     *     ( val [  . M 1  0  ]  )  )     *     ( val [  . M 2  2  ]  )  )  )     +     (  (  ( val [  . M 0  0  ]  )     *     ( val [  . M 1  1  ]  )  )     *     ( val [  . M 2  2  ]  )  )  ;", "float   inv _ det    =     1  .  0 F    /    l _ det ;", "val [  . M 0  0  ]     =     ( tmp [  . M 0  0  ]  )     *    inv _ det ;", "val [  . M 0  1  ]     =     ( tmp [  . M 0  1  ]  )     *    inv _ det ;", "val [  . M 0  2  ]     =     ( tmp [  . M 0  2  ]  )     *    inv _ det ;", "val [  . M 0  3  ]     =     ( tmp [  . M 0  3  ]  )     *    inv _ det ;", "val [  . M 1  0  ]     =     ( tmp [  . M 1  0  ]  )     *    inv _ det ;", "val [  . M 1  1  ]     =     ( tmp [  . M 1  1  ]  )     *    inv _ det ;", "val [  . M 1  2  ]     =     ( tmp [  . M 1  2  ]  )     *    inv _ det ;", "val [  . M 1  3  ]     =     ( tmp [  . M 1  3  ]  )     *    inv _ det ;", "val [  . M 2  0  ]     =     ( tmp [  . M 2  0  ]  )     *    inv _ det ;", "val [  . M 2  1  ]     =     ( tmp [  . M 2  1  ]  )     *    inv _ det ;", "val [  . M 2  2  ]     =     ( tmp [  . M 2  2  ]  )     *    inv _ det ;", "val [  . M 2  3  ]     =     ( tmp [  . M 2  3  ]  )     *    inv _ det ;", "val [  . M 3  0  ]     =     ( tmp [  . M 3  0  ]  )     *    inv _ det ;", "val [  . M 3  1  ]     =     ( tmp [  . M 3  1  ]  )     *    inv _ det ;", "val [  . M 3  2  ]     =     ( tmp [  . M 3  2  ]  )     *    inv _ det ;", "val [  . M 3  3  ]     =     ( tmp [  . M 3  3  ]  )     *    inv _ det ;", "return   true ;", "}", "METHOD_END"], "methodName": ["matrix4_inv"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "float [  ]    tmp    =    new   float [  1  6  ]  ;", "tmp [  . M 0  0  ]     =     (  (  (  ( mata [  . M 0  0  ]  )     *     ( matb [  . M 0  0  ]  )  )     +     (  ( mata [  . M 0  1  ]  )     *     ( matb [  . M 1  0  ]  )  )  )     +     (  ( mata [  . M 0  2  ]  )     *     ( matb [  . M 2  0  ]  )  )  )     +     (  ( mata [  . M 0  3  ]  )     *     ( matb [  . M 3  0  ]  )  )  ;", "tmp [  . M 0  1  ]     =     (  (  (  ( mata [  . M 0  0  ]  )     *     ( matb [  . M 0  1  ]  )  )     +     (  ( mata [  . M 0  1  ]  )     *     ( matb [  . M 1  1  ]  )  )  )     +     (  ( mata [  . M 0  2  ]  )     *     ( matb [  . M 2  1  ]  )  )  )     +     (  ( mata [  . M 0  3  ]  )     *     ( matb [  . M 3  1  ]  )  )  ;", "tmp [  . M 0  2  ]     =     (  (  (  ( mata [  . M 0  0  ]  )     *     ( matb [  . M 0  2  ]  )  )     +     (  ( mata [  . M 0  1  ]  )     *     ( matb [  . M 1  2  ]  )  )  )     +     (  ( mata [  . M 0  2  ]  )     *     ( matb [  . M 2  2  ]  )  )  )     +     (  ( mata [  . M 0  3  ]  )     *     ( matb [  . M 3  2  ]  )  )  ;", "tmp [  . M 0  3  ]     =     (  (  (  ( mata [  . M 0  0  ]  )     *     ( matb [  . M 0  3  ]  )  )     +     (  ( mata [  . M 0  1  ]  )     *     ( matb [  . M 1  3  ]  )  )  )     +     (  ( mata [  . M 0  2  ]  )     *     ( matb [  . M 2  3  ]  )  )  )     +     (  ( mata [  . M 0  3  ]  )     *     ( matb [  . M 3  3  ]  )  )  ;", "tmp [  . M 1  0  ]     =     (  (  (  ( mata [  . M 1  0  ]  )     *     ( matb [  . M 0  0  ]  )  )     +     (  ( mata [  . M 1  1  ]  )     *     ( matb [  . M 1  0  ]  )  )  )     +     (  ( mata [  . M 1  2  ]  )     *     ( matb [  . M 2  0  ]  )  )  )     +     (  ( mata [  . M 1  3  ]  )     *     ( matb [  . M 3  0  ]  )  )  ;", "tmp [  . M 1  1  ]     =     (  (  (  ( mata [  . M 1  0  ]  )     *     ( matb [  . M 0  1  ]  )  )     +     (  ( mata [  . M 1  1  ]  )     *     ( matb [  . M 1  1  ]  )  )  )     +     (  ( mata [  . M 1  2  ]  )     *     ( matb [  . M 2  1  ]  )  )  )     +     (  ( mata [  . M 1  3  ]  )     *     ( matb [  . M 3  1  ]  )  )  ;", "tmp [  . M 1  2  ]     =     (  (  (  ( mata [  . M 1  0  ]  )     *     ( matb [  . M 0  2  ]  )  )     +     (  ( mata [  . M 1  1  ]  )     *     ( matb [  . M 1  2  ]  )  )  )     +     (  ( mata [  . M 1  2  ]  )     *     ( matb [  . M 2  2  ]  )  )  )     +     (  ( mata [  . M 1  3  ]  )     *     ( matb [  . M 3  2  ]  )  )  ;", "tmp [  . M 1  3  ]     =     (  (  (  ( mata [  . M 1  0  ]  )     *     ( matb [  . M 0  3  ]  )  )     +     (  ( mata [  . M 1  1  ]  )     *     ( matb [  . M 1  3  ]  )  )  )     +     (  ( mata [  . M 1  2  ]  )     *     ( matb [  . M 2  3  ]  )  )  )     +     (  ( mata [  . M 1  3  ]  )     *     ( matb [  . M 3  3  ]  )  )  ;", "tmp [  . M 2  0  ]     =     (  (  (  ( mata [  . M 2  0  ]  )     *     ( matb [  . M 0  0  ]  )  )     +     (  ( mata [  . M 2  1  ]  )     *     ( matb [  . M 1  0  ]  )  )  )     +     (  ( mata [  . M 2  2  ]  )     *     ( matb [  . M 2  0  ]  )  )  )     +     (  ( mata [  . M 2  3  ]  )     *     ( matb [  . M 3  0  ]  )  )  ;", "tmp [  . M 2  1  ]     =     (  (  (  ( mata [  . M 2  0  ]  )     *     ( matb [  . M 0  1  ]  )  )     +     (  ( mata [  . M 2  1  ]  )     *     ( matb [  . M 1  1  ]  )  )  )     +     (  ( mata [  . M 2  2  ]  )     *     ( matb [  . M 2  1  ]  )  )  )     +     (  ( mata [  . M 2  3  ]  )     *     ( matb [  . M 3  1  ]  )  )  ;", "tmp [  . M 2  2  ]     =     (  (  (  ( mata [  . M 2  0  ]  )     *     ( matb [  . M 0  2  ]  )  )     +     (  ( mata [  . M 2  1  ]  )     *     ( matb [  . M 1  2  ]  )  )  )     +     (  ( mata [  . M 2  2  ]  )     *     ( matb [  . M 2  2  ]  )  )  )     +     (  ( mata [  . M 2  3  ]  )     *     ( matb [  . M 3  2  ]  )  )  ;", "tmp [  . M 2  3  ]     =     (  (  (  ( mata [  . M 2  0  ]  )     *     ( matb [  . M 0  3  ]  )  )     +     (  ( mata [  . M 2  1  ]  )     *     ( matb [  . M 1  3  ]  )  )  )     +     (  ( mata [  . M 2  2  ]  )     *     ( matb [  . M 2  3  ]  )  )  )     +     (  ( mata [  . M 2  3  ]  )     *     ( matb [  . M 3  3  ]  )  )  ;", "tmp [  . M 3  0  ]     =     (  (  (  ( mata [  . M 3  0  ]  )     *     ( matb [  . M 0  0  ]  )  )     +     (  ( mata [  . M 3  1  ]  )     *     ( matb [  . M 1  0  ]  )  )  )     +     (  ( mata [  . M 3  2  ]  )     *     ( matb [  . M 2  0  ]  )  )  )     +     (  ( mata [  . M 3  3  ]  )     *     ( matb [  . M 3  0  ]  )  )  ;", "tmp [  . M 3  1  ]     =     (  (  (  ( mata [  . M 3  0  ]  )     *     ( matb [  . M 0  1  ]  )  )     +     (  ( mata [  . M 3  1  ]  )     *     ( matb [  . M 1  1  ]  )  )  )     +     (  ( mata [  . M 3  2  ]  )     *     ( matb [  . M 2  1  ]  )  )  )     +     (  ( mata [  . M 3  3  ]  )     *     ( matb [  . M 3  1  ]  )  )  ;", "tmp [  . M 3  2  ]     =     (  (  (  ( mata [  . M 3  0  ]  )     *     ( matb [  . M 0  2  ]  )  )     +     (  ( mata [  . M 3  1  ]  )     *     ( matb [  . M 1  2  ]  )  )  )     +     (  ( mata [  . M 3  2  ]  )     *     ( matb [  . M 2  2  ]  )  )  )     +     (  ( mata [  . M 3  3  ]  )     *     ( matb [  . M 3  2  ]  )  )  ;", "tmp [  . M 3  3  ]     =     (  (  (  ( mata [  . M 3  0  ]  )     *     ( matb [  . M 0  3  ]  )  )     +     (  ( mata [  . M 3  1  ]  )     *     ( matb [  . M 1  3  ]  )  )  )     +     (  ( mata [  . M 3  2  ]  )     *     ( matb [  . M 2  3  ]  )  )  )     +     (  ( mata [  . M 3  3  ]  )     *     ( matb [  . M 3  3  ]  )  )  ;", "System . arraycopy ( tmp ,     0  ,    mata ,     0  ,     1  6  )  ;", "}", "METHOD_END"], "methodName": ["matrix4_mul"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "float   x    =     (  (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 0  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 0  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 0  2  ]  )  )  )     +     ( mat [ Matrix 4  . M 0  3  ]  )  ;", "float   y    =     (  (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 1  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 1  2  ]  )  )  )     +     ( mat [ Matrix 4  . M 1  3  ]  )  ;", "float   z    =     (  (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 2  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 2  2  ]  )  )  )     +     ( mat [ Matrix 4  . M 2  3  ]  )  ;", "vec [  ( offset    +     0  )  ]     =    x ;", "vec [  ( offset    +     1  )  ]     =    y ;", "vec [  ( offset    +     2  )  ]     =    z ;", "}", "METHOD_END"], "methodName": ["matrix4_mulVec"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "float   inv _ w    =     1  .  0 F    /     (  (  (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 3  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 3  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 3  2  ]  )  )  )     +     ( mat [ Matrix 4  . M 3  3  ]  )  )  ;", "float   x    =     (  (  (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 0  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 0  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 0  2  ]  )  )  )     +     ( mat [ Matrix 4  . M 0  3  ]  )  )     *    inv _ w ;", "float   y    =     (  (  (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 1  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 1  2  ]  )  )  )     +     ( mat [ Matrix 4  . M 1  3  ]  )  )     *    inv _ w ;", "float   z    =     (  (  (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 2  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 2  2  ]  )  )  )     +     ( mat [ Matrix 4  . M 2  3  ]  )  )     *    inv _ w ;", "vec [  ( offset    +     0  )  ]     =    x ;", "vec [  ( offset    +     1  )  ]     =    y ;", "vec [  ( offset    +     2  )  ]     =    z ;", "}", "METHOD_END"], "methodName": ["matrix4_proj"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "float   x    =     (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 0  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 0  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 0  2  ]  )  )  ;", "float   y    =     (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 1  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 1  2  ]  )  )  ;", "float   z    =     (  (  ( vec [  ( offset    +     0  )  ]  )     *     ( mat [ Matrix 4  . M 2  0  ]  )  )     +     (  ( vec [  ( offset    +     1  )  ]  )     *     ( mat [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( vec [  ( offset    +     2  )  ]  )     *     ( mat [ Matrix 4  . M 2  2  ]  )  )  ;", "vec [  ( offset    +     0  )  ]     =    x ;", "vec [  ( offset    +     1  )  ]     =    y ;", "vec [  ( offset    +     2  )  ]     =    z ;", "}", "METHOD_END"], "methodName": ["matrix4_rot"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  0  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  1  ]  )  )     +     (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  1  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  2  ]  )  )     +     (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =     (  (  (  ( val [ Matrix 4  . M 0  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  3  ]  )  )     +     (  ( val [ Matrix 4  . M 0  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  ( val [ Matrix 4  . M 0  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  0  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  1  ]  )  )     +     (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  1  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  2  ]  )  )     +     (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =     (  (  (  ( val [ Matrix 4  . M 1  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  3  ]  )  )     +     (  ( val [ Matrix 4  . M 1  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  ( val [ Matrix 4  . M 1  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( val [ Matrix 4  . M 2  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  0  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  1  ]  )  )     +     (  ( val [ Matrix 4  . M 2  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  1  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  2  ]  )  )     +     (  ( val [ Matrix 4  . M 2  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =     (  (  (  ( val [ Matrix 4  . M 2  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  3  ]  )  )     +     (  ( val [ Matrix 4  . M 2  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  ( val [ Matrix 4  . M 2  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( val [ Matrix 4  . M 3  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( val [ Matrix 4  . M 3  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  ( val [ Matrix 4  . M 3  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  0  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  1  ]  )  )     +     (  ( val [ Matrix 4  . M 3  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 3  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( val [ Matrix 4  . M 3  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  1  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  2  ]  )  )     +     (  ( val [ Matrix 4  . M 3  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( val [ Matrix 4  . M 3  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  ( val [ Matrix 4  . M 3  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =     (  (  (  ( val [ Matrix 4  . M 3  0  ]  )     *     ( matrix . val [ Matrix 4  . M 0  3  ]  )  )     +     (  ( val [ Matrix 4  . M 3  1  ]  )     *     ( matrix . val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  ( val [ Matrix 4  . M 3  2  ]  )     *     ( matrix . val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  ( val [ Matrix 4  . M 3  3  ]  )     *     ( matrix . val [ Matrix 4  . M 3  3  ]  )  )  ;", "return   this . set ( Matrix 4  . tmp )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . matrix 4  _ mul ( mata ,    matb )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 0  0  ]  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 0  3  ]  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 1  0  ]  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 1  3  ]  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  3  ]  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  1  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  3  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  2  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  3  ]  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 2  0  ]  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 2  3  ]  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  0  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  1  ]  )     *     ( val [ Matrix 4  . M 1  0  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  2  ]  )     *     ( val [ Matrix 4  . M 2  0  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  3  ]  )     *     ( val [ Matrix 4  . M 3  0  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  1  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  1  ]  )     *     ( val [ Matrix 4  . M 1  1  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  2  ]  )     *     ( val [ Matrix 4  . M 2  1  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  3  ]  )     *     ( val [ Matrix 4  . M 3  1  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  2  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  1  ]  )     *     ( val [ Matrix 4  . M 1  2  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  2  ]  )     *     ( val [ Matrix 4  . M 2  2  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  3  ]  )     *     ( val [ Matrix 4  . M 3  2  ]  )  )  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =     (  (  (  ( matrix . val [ Matrix 4  . M 3  0  ]  )     *     ( val [ Matrix 4  . M 0  3  ]  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  1  ]  )     *     ( val [ Matrix 4  . M 1  3  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  2  ]  )     *     ( val [ Matrix 4  . M 2  3  ]  )  )  )     +     (  ( matrix . val [ Matrix 4  . M 3  3  ]  )     *     ( val [ Matrix 4  . M 3  3  ]  )  )  ;", "return   this . set ( Matrix 4  . tmp )  ;", "}", "METHOD_END"], "methodName": ["mulLeft"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . matrix 4  _ mulVec ( mat ,    vec ,     0  )  ;", "}", "METHOD_END"], "methodName": ["mulVec"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    numVecs ;    i +  +  )     {", ". matrix 4  _ mulVec ( mat ,    vecs ,    offset )  ;", "offset    +  =    stride ;", "}", "}", "METHOD_END"], "methodName": ["mulVec"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . matrix 4  _ proj ( mat ,    vec ,     0  )  ;", "}", "METHOD_END"], "methodName": ["prj"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    numVecs ;    i +  +  )     {", ". matrix 4  _ proj ( mat ,    vecs ,    offset )  ;", "offset    +  =    stride ;", "}", "}", "METHOD_END"], "methodName": ["prj"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . matrix 4  _ rot ( mat ,    vec ,     0  )  ;", "}", "METHOD_END"], "methodName": ["rot"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    numVecs ;    i +  +  )     {", ". matrix 4  _ rot ( mat ,    vecs ,    offset )  ;", "offset    +  =    stride ;", "}", "}", "METHOD_END"], "methodName": ["rot"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "rotation . toMatrix ( Matrix 4  . tmp )  ;", "Matrix 4  . mul ( val ,    Matrix 4  . tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   rotate ( Matrix 4  . quat . setFromCross ( v 1  ,    v 2  )  )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )", "return   this ;", ". quat . set ( axis ,    degrees )  ;", "return   rotate (  . quat )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )", "return   this ;", ". quat . setFromAxis ( axisX ,    axisY ,    axisZ ,    degrees )  ;", "return   rotate (  . quat )  ;", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )", "return   this ;", ". quat . setFromAxisRad ( axis ,    radians )  ;", "return   rotate (  . quat )  ;", "}", "METHOD_END"], "methodName": ["rotateRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )", "return   this ;", ". quat . setFromAxisRad ( axisX ,    axisY ,    axisZ ,    radians )  ;", "return   rotate (  . quat )  ;", "}", "METHOD_END"], "methodName": ["rotateRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =    scaleX ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =    scaleY ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =    scaleZ ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =     1  ;", "Matrix 4  . mul ( val ,    Matrix 4  . tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scale"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     *  =    scale . x ;", "val [ Matrix 4  . M 1  1  ]     *  =    scale . y ;", "val [ Matrix 4  . M 2  2  ]     *  =    scale . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     *  =    scale ;", "val [ Matrix 4  . M 1  1  ]     *  =    scale ;", "val [ Matrix 4  . M 2  2  ]     *  =    scale ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     *  =    x ;", "val [ Matrix 4  . M 1  1  ]     *  =    y ;", "val [ Matrix 4  . M 2  2  ]     *  =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scl"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =    affine . m 0  0  ;", "val [ Matrix 4  . M 1  0  ]     =    affine . m 1  0  ;", "val [ Matrix 4  . M 2  0  ]     =     0  ;", "val [ Matrix 4  . M 3  0  ]     =     0  ;", "val [ Matrix 4  . M 0  1  ]     =    affine . m 0  1  ;", "val [ Matrix 4  . M 1  1  ]     =    affine . m 1  1  ;", "val [ Matrix 4  . M 2  1  ]     =     0  ;", "val [ Matrix 4  . M 3  1  ]     =     0  ;", "val [ Matrix 4  . M 0  2  ]     =     0  ;", "val [ Matrix 4  . M 1  2  ]     =     0  ;", "val [ Matrix 4  . M 2  2  ]     =     1  ;", "val [ Matrix 4  . M 3  2  ]     =     0  ;", "val [ Matrix 4  . M 0  3  ]     =    affine . m 0  2  ;", "val [ Matrix 4  . M 1  3  ]     =    affine . m 1  2  ;", "val [ Matrix 4  . M 2  3  ]     =     0  ;", "val [ Matrix 4  . M 3  3  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [  0  ]     =    mat . val [  0  ]  ;", "val [  1  ]     =    mat . val [  1  ]  ;", "val [  2  ]     =    mat . val [  2  ]  ;", "val [  3  ]     =     0  ;", "val [  4  ]     =    mat . val [  3  ]  ;", "val [  5  ]     =    mat . val [  4  ]  ;", "val [  6  ]     =    mat . val [  5  ]  ;", "val [  7  ]     =     0  ;", "val [  8  ]     =     0  ;", "val [  9  ]     =     0  ;", "val [  1  0  ]     =     1  ;", "val [  1  1  ]     =     0  ;", "val [  1  2  ]     =    mat . val [  6  ]  ;", "val [  1  3  ]     =    mat . val [  7  ]  ;", "val [  1  4  ]     =     0  ;", "val [  1  5  ]     =    mat . val [  8  ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   this . set ( matrix . val )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( quaternion . x ,    quaternion . y ,    quaternion . z ,    quaternion . w )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( position . x ,    position . y ,    position . z ,    orientation . x ,    orientation . y ,    orientation . z ,    orientation . w )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( position . x ,    position . y ,    position . z ,    orientation . x ,    orientation . y ,    orientation . z ,    orientation . w ,    scale . x ,    scale . y ,    scale . z )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =    xAxis . x ;", "val [ Matrix 4  . M 0  1  ]     =    xAxis . y ;", "val [ Matrix 4  . M 0  2  ]     =    xAxis . z ;", "val [ Matrix 4  . M 1  0  ]     =    yAxis . x ;", "val [ Matrix 4  . M 1  1  ]     =    yAxis . y ;", "val [ Matrix 4  . M 1  2  ]     =    yAxis . z ;", "val [ Matrix 4  . M 2  0  ]     =    zAxis . x ;", "val [ Matrix 4  . M 2  1  ]     =    zAxis . y ;", "val [ Matrix 4  . M 2  2  ]     =    zAxis . z ;", "val [ Matrix 4  . M 0  3  ]     =    pos . x ;", "val [ Matrix 4  . M 1  3  ]     =    pos . y ;", "val [ Matrix 4  . M 2  3  ]     =    pos . z ;", "val [ Matrix 4  . M 3  0  ]     =     0  ;", "val [ Matrix 4  . M 3  1  ]     =     0  ;", "val [ Matrix 4  . M 3  2  ]     =     0  ;", "val [ Matrix 4  . M 3  3  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set (  0  .  0 F ,     0  .  0 F ,     0  .  0 F ,    quaternionX ,    quaternionY ,    quaternionZ ,    quaternionW )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "final   float   xs    =    quaternionX    *     2  .  0 F ;", "final   float   ys    =    quaternionY    *     2  .  0 F ;", "final   float   zs    =    quaternionZ    *     2  .  0 F ;", "final   float   wx    =    quaternionW    *    xs ;", "final   float   wy    =    quaternionW    *    ys ;", "final   float   wz    =    quaternionW    *    zs ;", "final   float   xx    =    quaternionX    *    xs ;", "final   float   xy    =    quaternionX    *    ys ;", "final   float   xz    =    quaternionX    *    zs ;", "final   float   yy    =    quaternionY    *    ys ;", "final   float   yz    =    quaternionY    *    zs ;", "final   float   zz    =    quaternionZ    *    zs ;", "val [  . M 0  0  ]     =     1  .  0 F    -     ( yy    +    zz )  ;", "val [  . M 0  1  ]     =    xy    -    wz ;", "val [  . M 0  2  ]     =    xz    +    wy ;", "val [  . M 0  3  ]     =    translationX ;", "val [  . M 1  0  ]     =    xy    +    wz ;", "val [  . M 1  1  ]     =     1  .  0 F    -     ( xx    +    zz )  ;", "val [  . M 1  2  ]     =    yz    -    wx ;", "val [  . M 1  3  ]     =    translationY ;", "val [  . M 2  0  ]     =    xz    -    wy ;", "val [  . M 2  1  ]     =    yz    +    wx ;", "val [  . M 2  2  ]     =     1  .  0 F    -     ( xx    +    yy )  ;", "val [  . M 2  3  ]     =    translationZ ;", "val [  . M 3  0  ]     =     0  .  0 F ;", "val [  . M 3  1  ]     =     0  .  0 F ;", "val [  . M 3  2  ]     =     0  .  0 F ;", "val [  . M 3  3  ]     =     1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "final   float   xs    =    quaternionX    *     2  .  0 F ;", "final   float   ys    =    quaternionY    *     2  .  0 F ;", "final   float   zs    =    quaternionZ    *     2  .  0 F ;", "final   float   wx    =    quaternionW    *    xs ;", "final   float   wy    =    quaternionW    *    ys ;", "final   float   wz    =    quaternionW    *    zs ;", "final   float   xx    =    quaternionX    *    xs ;", "final   float   xy    =    quaternionX    *    ys ;", "final   float   xz    =    quaternionX    *    zs ;", "final   float   yy    =    quaternionY    *    ys ;", "final   float   yz    =    quaternionY    *    zs ;", "final   float   zz    =    quaternionZ    *    zs ;", "val [  . M 0  0  ]     =    scaleX    *     (  1  .  0 F    -     ( yy    +    zz )  )  ;", "val [  . M 0  1  ]     =    scaleY    *     ( xy    -    wz )  ;", "val [  . M 0  2  ]     =    scaleZ    *     ( xz    +    wy )  ;", "val [  . M 0  3  ]     =    translationX ;", "val [  . M 1  0  ]     =    scaleX    *     ( xy    +    wz )  ;", "val [  . M 1  1  ]     =    scaleY    *     (  1  .  0 F    -     ( xx    +    zz )  )  ;", "val [  . M 1  2  ]     =    scaleZ    *     ( yz    -    wx )  ;", "val [  . M 1  3  ]     =    translationY ;", "val [  . M 2  0  ]     =    scaleX    *     ( xz    -    wy )  ;", "val [  . M 2  1  ]     =    scaleY    *     ( yz    +    wx )  ;", "val [  . M 2  2  ]     =    scaleZ    *     (  1  .  0 F    -     ( xx    +    yy )  )  ;", "val [  . M 2  3  ]     =    translationZ ;", "val [  . M 3  0  ]     =     0  .  0 F ;", "val [  . M 3  1  ]     =     0  .  0 F ;", "val [  . M 3  2  ]     =     0  .  0 F ;", "val [  . M 3  3  ]     =     1  .  0 F ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =    values [ Matrix 4  . M 0  0  ]  ;", "val [ Matrix 4  . M 1  0  ]     =    values [ Matrix 4  . M 1  0  ]  ;", "val [ Matrix 4  . M 2  0  ]     =    values [ Matrix 4  . M 2  0  ]  ;", "val [ Matrix 4  . M 3  0  ]     =    values [ Matrix 4  . M 3  0  ]  ;", "val [ Matrix 4  . M 0  1  ]     =    values [ Matrix 4  . M 0  1  ]  ;", "val [ Matrix 4  . M 1  1  ]     =    values [ Matrix 4  . M 1  1  ]  ;", "val [ Matrix 4  . M 2  1  ]     =    values [ Matrix 4  . M 2  1  ]  ;", "val [ Matrix 4  . M 3  1  ]     =    values [ Matrix 4  . M 3  1  ]  ;", "val [ Matrix 4  . M 0  2  ]     =    values [ Matrix 4  . M 0  2  ]  ;", "val [ Matrix 4  . M 1  2  ]     =    values [ Matrix 4  . M 1  2  ]  ;", "val [ Matrix 4  . M 2  2  ]     =    values [ Matrix 4  . M 2  2  ]  ;", "val [ Matrix 4  . M 3  2  ]     =    values [ Matrix 4  . M 3  2  ]  ;", "val [ Matrix 4  . M 0  3  ]     =    values [ Matrix 4  . M 0  3  ]  ;", "val [ Matrix 4  . M 1  3  ]     =    values [ Matrix 4  . M 1  3  ]  ;", "val [ Matrix 4  . M 2  3  ]     =    values [ Matrix 4  . M 2  3  ]  ;", "val [ Matrix 4  . M 3  3  ]     =    values [ Matrix 4  . M 3  3  ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =    affine . m 0  0  ;", "val [ Matrix 4  . M 1  0  ]     =    affine . m 1  0  ;", "val [ Matrix 4  . M 0  1  ]     =    affine . m 0  1  ;", "val [ Matrix 4  . M 1  1  ]     =    affine . m 1  1  ;", "val [ Matrix 4  . M 0  3  ]     =    affine . m 0  2  ;", "val [ Matrix 4  . M 1  3  ]     =    affine . m 1  2  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAsAffine"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  0  ]     =    mat . val [ Matrix 4  . M 0  0  ]  ;", "val [ Matrix 4  . M 1  0  ]     =    mat . val [ Matrix 4  . M 1  0  ]  ;", "val [ Matrix 4  . M 0  1  ]     =    mat . val [ Matrix 4  . M 0  1  ]  ;", "val [ Matrix 4  . M 1  1  ]     =    mat . val [ Matrix 4  . M 1  1  ]  ;", "val [ Matrix 4  . M 0  3  ]     =    mat . val [ Matrix 4  . M 0  3  ]  ;", "val [ Matrix 4  . M 1  3  ]     =    mat . val [ Matrix 4  . M 1  3  ]  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAsAffine"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . quat . setEulerAngles ( yaw ,    pitch ,    roll )  ;", "return   set ( Matrix 4  . quat )  ;", "}", "METHOD_END"], "methodName": ["setFromEulerAngles"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . quat . setEulerAnglesRad ( yaw ,    pitch ,    roll )  ;", "return   set ( Matrix 4  . quat )  ;", "}", "METHOD_END"], "methodName": ["setFromEulerAnglesRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . l _ vez . set ( direction )  . nor (  )  ;", "Matrix 4  . l _ vex . set ( direction )  . nor (  )  ;", "Matrix 4  . l _ vex . crs ( up )  . nor (  )  ;", "Matrix 4  . l _ vey . set ( Matrix 4  . l _ vex )  . crs ( Matrix 4  . l _ vez )  . nor (  )  ;", "idt (  )  ;", "val [ Matrix 4  . M 0  0  ]     =    Matrix 4  . l _ vex . x ;", "val [ Matrix 4  . M 0  1  ]     =    Matrix 4  . l _ vex . y ;", "val [ Matrix 4  . M 0  2  ]     =    Matrix 4  . l _ vex . z ;", "val [ Matrix 4  . M 1  0  ]     =    Matrix 4  . l _ vey . x ;", "val [ Matrix 4  . M 1  1  ]     =    Matrix 4  . l _ vey . y ;", "val [ Matrix 4  . M 1  2  ]     =    Matrix 4  . l _ vey . z ;", "val [ Matrix 4  . M 2  0  ]     =     -  ( Matrix 4  . l _ vez . x )  ;", "val [ Matrix 4  . M 2  1  ]     =     -  ( Matrix 4  . l _ vez . y )  ;", "val [ Matrix 4  . M 2  2  ]     =     -  ( Matrix 4  . l _ vez . z )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToLookAt"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmpVec . set ( target )  . sub ( position )  ;", "setToLookAt ( Matrix 4  . tmpVec ,    up )  ;", "this . mul ( Matrix 4  . tmpMat . setToTranslation (  (  -  ( position . x )  )  ,     (  -  ( position . y )  )  ,     (  -  ( position . z )  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToLookAt"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "this . idt (  )  ;", "float   x _ orth    =     2     /     ( right    -    left )  ;", "float   y _ orth    =     2     /     ( top    -    bottom )  ;", "float   z _ orth    =     (  -  2  )     /     ( far    -    near )  ;", "float   tx    =     (  -  ( right    +    left )  )     /     ( right    -    left )  ;", "float   ty    =     (  -  ( top    +    bottom )  )     /     ( top    -    bottom )  ;", "float   tz    =     (  -  ( far    +    near )  )     /     ( far    -    near )  ;", "val [  . M 0  0  ]     =    x _ orth ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 3  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =    y _ orth ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 3  1  ]     =     0  ;", "val [  . M 0  2  ]     =     0  ;", "val [  . M 1  2  ]     =     0  ;", "val [  . M 2  2  ]     =    z _ orth ;", "val [  . M 3  2  ]     =     0  ;", "val [  . M 0  3  ]     =    tx ;", "val [  . M 1  3  ]     =    ty ;", "val [  . M 2  3  ]     =    tz ;", "val [  . M 3  3  ]     =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToOrtho"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "setToOrtho ( x ,     ( x    +    width )  ,    y ,     ( y    +    height )  ,     0  ,     1  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToOrtho2D"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "setToOrtho ( x ,     ( x    +    width )  ,    y ,     ( y    +    height )  ,    near ,    far )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToOrtho2D"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "float   l _ fd    =     (  ( float )     (  1  .  0     /     ( Math . tan (  (  ( fovy    *     (  ( Math . PI )     /     1  8  0  )  )     /     2  .  0  )  )  )  )  )  ;", "float   l _ a 1     =     ( far    +    near )     /     ( near    -    far )  ;", "float   l _ a 2     =     (  (  2     *    far )     *    near )     /     ( near    -    far )  ;", "val [  . M 0  0  ]     =    l _ fd    /    aspectRatio ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 3  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =    l _ fd ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 3  1  ]     =     0  ;", "val [  . M 0  2  ]     =     0  ;", "val [  . M 1  2  ]     =     0  ;", "val [  . M 2  2  ]     =    l _ a 1  ;", "val [  . M 3  2  ]     =     -  1  ;", "val [  . M 0  3  ]     =     0  ;", "val [  . M 1  3  ]     =     0  ;", "val [  . M 2  3  ]     =    l _ a 2  ;", "val [  . M 3  3  ]     =     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToProjection"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "float   x    =     (  2  .  0 F    *    near )     /     ( right    -    left )  ;", "float   y    =     (  2  .  0 F    *    near )     /     ( top    -    bottom )  ;", "float   a    =     ( right    +    left )     /     ( right    -    left )  ;", "float   b    =     ( top    +    bottom )     /     ( top    -    bottom )  ;", "float   l _ a 1     =     ( far    +    near )     /     ( near    -    far )  ;", "float   l _ a 2     =     (  (  2     *    far )     *    near )     /     ( near    -    far )  ;", "val [  . M 0  0  ]     =    x ;", "val [  . M 1  0  ]     =     0  ;", "val [  . M 2  0  ]     =     0  ;", "val [  . M 3  0  ]     =     0  ;", "val [  . M 0  1  ]     =     0  ;", "val [  . M 1  1  ]     =    y ;", "val [  . M 2  1  ]     =     0  ;", "val [  . M 3  1  ]     =     0  ;", "val [  . M 0  2  ]     =    a ;", "val [  . M 1  2  ]     =    b ;", "val [  . M 2  2  ]     =    l _ a 1  ;", "val [  . M 3  2  ]     =     -  1  ;", "val [  . M 0  3  ]     =     0  ;", "val [  . M 1  3  ]     =     0  ;", "val [  . M 2  3  ]     =    l _ a 2  ;", "val [  . M 3  3  ]     =     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToProjection"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( Matrix 4  . quat . setFromCross ( v 1  ,    v 2  )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )     {", "idt (  )  ;", "return   this ;", "}", "return   set (  . quat . set ( axis ,    degrees )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( degrees    =  =     0  )     {", "idt (  )  ;", "return   this ;", "}", "return   set (  . quat . setFromAxis ( axisX ,    axisY ,    axisZ ,    degrees )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   set ( Matrix 4  . quat . setFromCross ( x 1  ,    y 1  ,    z 1  ,    x 2  ,    y 2  ,    z 2  )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )     {", "idt (  )  ;", "return   this ;", "}", "return   set (  . quat . setFromAxisRad ( axis ,    radians )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotationRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "if    ( radians    =  =     0  )     {", "idt (  )  ;", "return   this ;", "}", "return   set (  . quat . setFromAxisRad ( axisX ,    axisY ,    axisZ ,    radians )  )  ;", "}", "METHOD_END"], "methodName": ["setToRotationRad"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  0  ]     =    vector . x ;", "val [  . M 1  1  ]     =    vector . y ;", "val [  . M 2  2  ]     =    vector . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  0  ]     =    x ;", "val [  . M 1  1  ]     =    y ;", "val [  . M 2  2  ]     =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  3  ]     =    vector . x ;", "val [  . M 1  3  ]     =    vector . y ;", "val [  . M 2  3  ]     =    vector . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  3  ]     =    x ;", "val [  . M 1  3  ]     =    y ;", "val [  . M 2  3  ]     =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  3  ]     =    translation . x ;", "val [  . M 1  3  ]     =    translation . y ;", "val [  . M 2  3  ]     =    translation . z ;", "val [  . M 0  0  ]     =    scaling . x ;", "val [  . M 1  1  ]     =    scaling . y ;", "val [  . M 2  2  ]     =    scaling . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslationAndScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "idt (  )  ;", "val [  . M 0  3  ]     =    translationX ;", "val [  . M 1  3  ]     =    translationY ;", "val [  . M 2  3  ]     =    translationZ ;", "val [  . M 0  0  ]     =    scalingX ;", "val [  . M 1  1  ]     =    scalingY ;", "val [  . M 2  2  ]     =    scalingZ ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToTranslationAndScaling"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmpForward . set ( forward )  . nor (  )  ;", "Matrix 4  . right . set ( Matrix 4  . tmpForward )  . crs ( up )  . nor (  )  ;", "Matrix 4  . tmpUp . set ( Matrix 4  . right )  . crs ( Matrix 4  . tmpForward )  . nor (  )  ;", "this . set ( Matrix 4  . right ,    Matrix 4  . tmpUp ,    Matrix 4  . tmpForward . scl (  (  -  1  )  )  ,    position )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setToWorld"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     =    vector . x ;", "val [ Matrix 4  . M 1  3  ]     =    vector . y ;", "val [ Matrix 4  . M 2  3  ]     =    vector . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     =    x ;", "val [ Matrix 4  . M 1  3  ]     =    y ;", "val [ Matrix 4  . M 2  3  ]     =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTranslation"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     =     0  ;", "val [ Matrix 4  . M 1  3  ]     =     0  ;", "val [ Matrix 4  . M 2  3  ]     =     0  ;", "return   inv (  )  . tra (  )  ;", "}", "METHOD_END"], "methodName": ["toNormalMatrix"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"  [  \"     +     ( val [ Matrix 4  . M 0  0  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 0  1  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 0  2  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 0  3  ]  )  )     +     \"  ]  \\ n \"  )     +     \"  [  \"  )     +     ( val [ Matrix 4  . M 1  0  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 1  1  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 1  2  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 1  3  ]  )  )     +     \"  ]  \\ n \"  )     +     \"  [  \"  )     +     ( val [ Matrix 4  . M 2  0  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 2  1  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 2  2  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 2  3  ]  )  )     +     \"  ]  \\ n \"  )     +     \"  [  \"  )     +     ( val [ Matrix 4  . M 3  0  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 3  1  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 3  2  ]  )  )     +     \"  |  \"  )     +     ( val [ Matrix 4  . M 3  3  ]  )  )     +     \"  ]  \\ n \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =    val [ Matrix 4  . M 0  0  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =    val [ Matrix 4  . M 1  0  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =    val [ Matrix 4  . M 2  0  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =    val [ Matrix 4  . M 3  0  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =    val [ Matrix 4  . M 0  1  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =    val [ Matrix 4  . M 1  1  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =    val [ Matrix 4  . M 2  1  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =    val [ Matrix 4  . M 3  1  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =    val [ Matrix 4  . M 0  2  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =    val [ Matrix 4  . M 1  2  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =    val [ Matrix 4  . M 2  2  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =    val [ Matrix 4  . M 3  2  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =    val [ Matrix 4  . M 0  3  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =    val [ Matrix 4  . M 1  3  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =    val [ Matrix 4  . M 2  3  ]  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =    val [ Matrix 4  . M 3  3  ]  ;", "return   set ( Matrix 4  . tmp )  ;", "}", "METHOD_END"], "methodName": ["tra"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return   translate ( translation . x ,    translation . y ,    translation . z )  ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "Matrix 4  . tmp [ Matrix 4  . M 0  0  ]     =     1  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 0  3  ]     =    x ;", "Matrix 4  . tmp [ Matrix 4  . M 1  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  1  ]     =     1  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 1  3  ]     =    y ;", "Matrix 4  . tmp [ Matrix 4  . M 2  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  2  ]     =     1  ;", "Matrix 4  . tmp [ Matrix 4  . M 2  3  ]     =    z ;", "Matrix 4  . tmp [ Matrix 4  . M 3  0  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  1  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  2  ]     =     0  ;", "Matrix 4  . tmp [ Matrix 4  . M 3  3  ]     =     1  ;", "Matrix 4  . mul ( val ,    Matrix 4  . tmp )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["translate"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     +  =    vector . x ;", "val [ Matrix 4  . M 1  3  ]     +  =    vector . y ;", "val [ Matrix 4  . M 2  3  ]     +  =    vector . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["trn"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "val [ Matrix 4  . M 0  3  ]     +  =    x ;", "val [ Matrix 4  . M 1  3  ]     +  =    y ;", "val [ Matrix 4  . M 2  3  ]     +  =    z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["trn"], "fileName": "com.badlogic.gdx.math.Matrix4"}, {"methodBody": ["METHOD_START", "{", "return    ( input . isKeyPressed ( ALT _ LEFT )  )     |  |     ( input . isKeyPressed ( ALT _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["alt"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( keycode    =  =     ( Keys . ALT _ LEFT )  )     |  |     ( keycode    =  =     ( Keys . ALT _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["alt"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( UIUtils . isMac )", "return   Gdx . input . isKeyPressed ( Keys . SYM )  ;", "else", "return    ( Gdx . input . isKeyPressed ( Keys . CONTROL _ LEFT )  )     |  |     ( Gdx . input . isKeyPressed ( Keys . CONTROL _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["ctrl"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( UIUtils . isMac )", "return   keycode    =  =     ( Input . Keys . SYM )  ;", "else", "return    ( keycode    =  =     ( Input . Keys . CONTROL _ LEFT )  )     |  |     ( keycode    =  =     ( Input . Keys . CONTROL _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["ctrl"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   input . isButtonPressed ( LEFT )  ;", "}", "METHOD_END"], "methodName": ["left"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   button    =  =     ( Buttons . LEFT )  ;", "}", "METHOD_END"], "methodName": ["left"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   input . isButtonPressed ( MIDDLE )  ;", "}", "METHOD_END"], "methodName": ["middle"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   button    =  =     ( Buttons . MIDDLE )  ;", "}", "METHOD_END"], "methodName": ["middle"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   input . isButtonPressed ( RIGHT )  ;", "}", "METHOD_END"], "methodName": ["right"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return   button    =  =     ( Buttons . RIGHT )  ;", "}", "METHOD_END"], "methodName": ["right"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( input . isKeyPressed ( SHIFT _ LEFT )  )     |  |     ( input . isKeyPressed ( SHIFT _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["shift"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( keycode    =  =     ( Keys . SHIFT _ LEFT )  )     |  |     ( keycode    =  =     ( Keys . SHIFT _ RIGHT )  )  ;", "}", "METHOD_END"], "methodName": ["shift"], "fileName": "com.badlogic.gdx.scenes.scene2d.utils.UIUtils"}, {"methodBody": ["METHOD_START", "{", "final   int   pos    =    buffer . position (  )  ;", "final   float [  ]    result    =    new   float [ buffer . remaining (  )  ]  ;", "buffer . get ( result )  ;", "buffer . position ( pos )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["asFloatArray"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "FloatBuffer   buffer    =    null ;", "if    ( data   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( data )  )  . asFloatBuffer (  )  ;", "else", "if    ( data   instanceof   FloatBuffer )", "buffer    =     (  ( FloatBuffer )     ( data )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" data   must   be   a   ByteBuffer   or   FloatBuffer \"  )  ;", "return   buffer ;", "}", "METHOD_END"], "methodName": ["asFloatBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( dst   instanceof   ByteBuffer )  )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer \"  )  ;", "ByteBuffer   byteBuffer    =     (  ( ByteBuffer )     ( dst )  )  ;", "int   oldPosition    =    byteBuffer . position (  )  ;", "byteBuffer . limit (  ( oldPosition    +    numElements )  )  ;", "byteBuffer . put ( src ,    srcOffset ,    numElements )  ;", "byteBuffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "CharBuffer   buffer    =    null ;", "if    ( dst   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( dst )  )  . asCharBuffer (  )  ;", "else", "if    ( dst   instanceof   CharBuffer )", "buffer    =     (  ( CharBuffer )     ( dst )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer   or   CharBuffer \"  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "CharBuffer   buffer    =    null ;", "if    ( dst   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( dst )  )  . asCharBuffer (  )  ;", "else", "if    ( dst   instanceof   CharBuffer )", "buffer    =     (  ( CharBuffer )     ( dst )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer   or   CharBuffer \"  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . limit (  ( oldPosition    +    numElements )  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "DoubleBuffer   buffer    =    null ;", "if    ( dst   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( dst )  )  . asDoubleBuffer (  )  ;", "else", "if    ( dst   instanceof   DoubleBuffer )", "buffer    =     (  ( DoubleBuffer )     ( dst )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer   or   DoubleBuffer \"  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "DoubleBuffer   buffer    =    null ;", "if    ( dst   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( dst )  )  . asDoubleBuffer (  )  ;", "else", "if    ( dst   instanceof   DoubleBuffer )", "buffer    =     (  ( DoubleBuffer )     ( dst )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer   or   DoubleBuffer \"  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . limit (  ( oldPosition    +    numElements )  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "FloatBuffer   buffer    =    BufferUtils . asFloatBuffer ( dst )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "FloatBuffer   buffer    =    BufferUtils . asFloatBuffer ( dst )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . limit (  ( oldPosition    +    numElements )  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "FloatBuffer   floatBuffer    =    BufferUtils . asFloatBuffer ( dst )  ;", "floatBuffer . clear (  )  ;", "dst . position (  0  )  ;", "floatBuffer . put ( src ,    offset ,    numFloats )  ;", "dst . position (  0  )  ;", "if    ( dst   instanceof   ByteBuffer )", "dst . limit (  ( numFloats    <  <     2  )  )  ;", "else", "dst . limit ( numFloats )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   buffer    =    null ;", "if    ( dst   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( dst )  )  . asIntBuffer (  )  ;", "else", "if    ( dst   instanceof   IntBuffer )", "buffer    =     (  ( IntBuffer )     ( dst )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer   or   IntBuffer \"  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "IntBuffer   buffer    =    null ;", "if    ( dst   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( dst )  )  . asIntBuffer (  )  ;", "else", "if    ( dst   instanceof   IntBuffer )", "buffer    =     (  ( IntBuffer )     ( dst )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer   or   IntBuffer \"  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . limit (  ( oldPosition    +    numElements )  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "int   srcPos    =    src . position (  )  ;", "int   dstPos    =    dst . position (  )  ;", "src . limit (  ( srcPos    +    numElements )  )  ;", "final   boolean   srcIsByte    =    src   instanceof   Byte ;", "final   boolean   dstIsByte    =    dst   instanceof   Byte ;", "dst . limit ( dst . capacity (  )  )  ;", "if    ( srcIsByte    &  &    dstIsByte )", "(  ( Byte )     ( dst )  )  . put (  (  ( Byte )     ( src )  )  )  ;", "else", "if    (  ( srcIsByte    |  |     ( src   instanceof   Char )  )     &  &     ( dstIsByte    |  |     ( dst   instanceof   Char )  )  )", "( dstIsByte    ?     (  ( Byte )     ( dst )  )  . asChar (  )     :     (  ( Char )     ( dst )  )  )  . put (  ( srcIsByte    ?     (  ( Byte )     ( src )  )  . asChar (  )     :     (  ( Char )     ( src )  )  )  )  ;", "else", "if    (  ( srcIsByte    |  |     ( src   instanceof   Short )  )     &  &     ( dstIsByte    |  |     ( dst   instanceof   Short )  )  )", "( dstIsByte    ?     (  ( Byte )     ( dst )  )  . asShort (  )     :     (  ( Short )     ( dst )  )  )  . put (  ( srcIsByte    ?     (  ( Byte )     ( src )  )  . asShort (  )     :     (  ( Short )     ( src )  )  )  )  ;", "else", "if    (  ( srcIsByte    |  |     ( src   instanceof   Int )  )     &  &     ( dstIsByte    |  |     ( dst   instanceof   Int )  )  )", "( dstIsByte    ?     (  ( Byte )     ( dst )  )  . asInt (  )     :     (  ( Int )     ( dst )  )  )  . put (  ( srcIsByte    ?     (  ( Byte )     ( src )  )  . asInt (  )     :     (  ( Int )     ( src )  )  )  )  ;", "else", "if    (  ( srcIsByte    |  |     ( src   instanceof   Long )  )     &  &     ( dstIsByte    |  |     ( dst   instanceof   Long )  )  )", "( dstIsByte    ?     (  ( Byte )     ( dst )  )  . asLong (  )     :     (  ( Long )     ( dst )  )  )  . put (  ( srcIsByte    ?     (  ( Byte )     ( src )  )  . asLong (  )     :     (  ( Long )     ( src )  )  )  )  ;", "else", "if    (  ( srcIsByte    |  |     ( src   instanceof   Float )  )     &  &     ( dstIsByte    |  |     ( dst   instanceof   Float )  )  )", "( dstIsByte    ?     (  ( Byte )     ( dst )  )  . asFloat (  )     :     (  ( Float )     ( dst )  )  )  . put (  ( srcIsByte    ?     (  ( Byte )     ( src )  )  . asFloat (  )     :     (  ( Float )     ( src )  )  )  )  ;", "else", "if    (  ( srcIsByte    |  |     ( src   instanceof   Double )  )     &  &     ( dstIsByte    |  |     ( dst   instanceof   Double )  )  )", "( dstIsByte    ?     (  ( Byte )     ( dst )  )  . asDouble (  )     :     (  ( Double )     ( dst )  )  )  . put (  ( srcIsByte    ?     (  ( Byte )     ( src )  )  . asDouble (  )     :     (  ( Double )     ( src )  )  )  )  ;", "else", "throw   new   GdxRuntimeException (  \" s   must   be   of   same   type   or   Byte \"  )  ;", "src . position ( srcPos )  ;", "dst . flip (  )  ;", "dst . position ( dstPos )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "LongBuffer   buffer    =    null ;", "if    ( dst   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( dst )  )  . asLongBuffer (  )  ;", "else", "if    ( dst   instanceof   LongBuffer )", "buffer    =     (  ( LongBuffer )     ( dst )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer   or   LongBuffer \"  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "LongBuffer   buffer    =    null ;", "if    ( dst   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( dst )  )  . asLongBuffer (  )  ;", "else", "if    ( dst   instanceof   LongBuffer )", "buffer    =     (  ( LongBuffer )     ( dst )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer   or   LongBuffer \"  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . limit (  ( oldPosition    +    numElements )  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "ShortBuffer   buffer    =    null ;", "if    ( dst   instanceof   ByteBuffer )", "buffer    =     (  ( ByteBuffer )     ( dst )  )  . asShortBuffer (  )  ;", "else", "if    ( dst   instanceof   ShortBuffer )", "buffer    =     (  ( ShortBuffer )     ( dst )  )  ;", "if    ( buffer    =  =    null )", "throw   new   GdxRuntimeException (  \" dst   must   be   a   ByteBuffer   or   ShortBuffer \"  )  ;", "int   oldPosition    =    buffer . position (  )  ;", "buffer . limit (  ( oldPosition    +    numElements )  )  ;", "buffer . put ( src ,    srcOffset ,    numElements )  ;", "buffer . position ( oldPosition )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "final   int   size    =    strideInBytes    /     4  ;", "for    ( int   i    =     0  ;    i    <    numVertes ;    i +  +  )     {", "final   int   offset    =    i    *    size ;", "boolean   found    =    true ;", "for    ( int   j    =     0  ;     (  ! found )     &  &     ( j    <    size )  ;    j +  +  )", "if    (  ( vertes [  ( offset    +    j )  ]  )     !  =     ( vertex [ j ]  )  )", "found    =    false ;", "if    ( found )", "return    (  ( long )     ( i )  )  ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "final   int   size    =    strideInBytes    /     4  ;", "for    ( int   i    =     0  ;    i    <    numVertes ;    i +  +  )     {", "final   int   offset    =    i    *    size ;", "boolean   found    =    true ;", "for    ( int   j    =     0  ;     (  ! found )     &  &     ( j    <    size )  ;    j +  +  )", "if    (  (  ( vertes [  ( offset    +    j )  ]  )     >     ( vertex [ j ]  )     ?     ( vertes [  ( offset    +    j )  ]  )     -     ( vertex [ j ]  )     :     ( vertex [ j ]  )     -     ( vertes [  ( offset    +    j )  ]  )  )     >    epsilon )", "found    =    false ;", "if    ( found )", "return    (  ( long )     ( i )  )  ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . findFloats ( vertex ,    strideInBytes ,    BufferUtils . asFloatArray ( BufferUtils . asFloatBuffer ( vertices )  )  ,    numVertices )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . findFloats ( vertex ,    strideInBytes ,    BufferUtils . asFloatArray ( BufferUtils . asFloatBuffer ( vertices )  )  ,    numVertices ,    epsilon )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . findFloats ( BufferUtils . asFloatArray ( BufferUtils . asFloatBuffer ( vertex )  )  ,    strideInBytes ,    vertices ,    numVertices )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . findFloats ( BufferUtils . asFloatArray ( BufferUtils . asFloatBuffer ( vertex )  )  ,    strideInBytes ,    vertices ,    numVertices ,    epsilon )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . findFloats ( BufferUtils . asFloatArray ( BufferUtils . asFloatBuffer ( vertex )  )  ,    strideInBytes ,    BufferUtils . asFloatArray ( BufferUtils . asFloatBuffer ( vertices )  )  ,    numVertices )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   BufferUtils . findFloats ( BufferUtils . asFloatArray ( BufferUtils . asFloatBuffer ( vertex )  )  ,    strideInBytes ,    BufferUtils . asFloatArray ( BufferUtils . asFloatBuffer ( vertices )  )  ,    numVertices ,    epsilon )  ;", "}", "METHOD_END"], "methodName": ["findFloats"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( GWT . isProdMode (  )  )     {", "Byte   buffer    =    Byte . allocateDirect ( numBytes )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer ;", "} else    {", "return   Byte . wrap ( new   byte [ numBytes ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["newByteBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( GWT . isProdMode (  )  )     {", "Byte   buffer    =    Byte . allocateDirect (  ( numChars    *     2  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asChar (  )  ;", "} else    {", "return   Char . wrap ( new   char [ numChars ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["newCharBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( GWT . isProdMode (  )  )     {", "Byte   buffer    =    Byte . allocateDirect (  ( numDoubles    *     8  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asDouble (  )  ;", "} else    {", "return   Double . wrap ( new   double [ numDoubles ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["newDoubleBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( GWT . isProdMode (  )  )     {", "Byte   buffer    =    Byte . allocateDirect (  ( numFloats    *     4  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asFloat (  )  ;", "} else    {", "return   Float . wrap ( new   float [ numFloats ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["newFloatBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( GWT . isProdMode (  )  )     {", "Byte   buffer    =    Byte . allocateDirect (  ( numInts    *     4  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asInt (  )  ;", "} else    {", "return   Int . wrap ( new   int [ numInts ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["newIntBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   LongBuffer . wrap ( new   long [ numLongs ]  )  ;", "}", "METHOD_END"], "methodName": ["newLongBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( GWT . isProdMode (  )  )     {", "Byte   buffer    =    Byte . allocateDirect (  ( numShorts    *     2  )  )  ;", "buffer . order ( ByteOrder . nativeOrder (  )  )  ;", "return   buffer . asShort (  )  ;", "} else    {", "return   Short . wrap ( new   short [ numShorts ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["newShortBuffer"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "FloatBuffer   buffer    =    BufferUtils . asFloatBuffer ( data )  ;", "final   int   pos    =    buffer . position (  )  ;", "int   idx    =    pos ;", "float [  ]    arr    =    BufferUtils . asFloatArray ( buffer )  ;", "int   stride    =    strideInBytes    /     4  ;", "float [  ]    m    =    matrix . val ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   float   x    =    arr [ idx ]  ;", "final   float   y    =    arr [  ( idx    +     1  )  ]  ;", "final   float   z    =     ( dimensions    >  =     3  )     ?    arr [  ( idx    +     2  )  ]     :     1  .  0 F ;", "arr [ idx ]     =     (  ( x    *     ( m [  0  ]  )  )     +     ( y    *     ( m [  3  ]  )  )  )     +     ( z    *     ( m [  6  ]  )  )  ;", "arr [  ( idx    +     1  )  ]     =     (  ( x    *     ( m [  1  ]  )  )     +     ( y    *     ( m [  4  ]  )  )  )     +     ( z    *     ( m [  7  ]  )  )  ;", "if    ( dimensions    >  =     3  )", "arr [  ( idx    +     2  )  ]     =     (  ( x    *     ( m [  2  ]  )  )     +     ( y    *     ( m [  5  ]  )  )  )     +     ( z    *     ( m [  8  ]  )  )  ;", "idx    +  =    stride ;", "}", "buffer . put ( arr )  ;", "buffer . position ( pos )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "FloatBuffer   buffer    =    BufferUtils . asFloatBuffer ( data )  ;", "final   int   pos    =    buffer . position (  )  ;", "int   idx    =    pos ;", "float [  ]    arr    =    BufferUtils . asFloatArray ( buffer )  ;", "int   stride    =    strideInBytes    /     4  ;", "float [  ]    m    =    matrix . val ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "final   float   x    =    arr [ idx ]  ;", "final   float   y    =    arr [  ( idx    +     1  )  ]  ;", "final   float   z    =     ( dimensions    >  =     3  )     ?    arr [  ( idx    +     2  )  ]     :     0  .  0 F ;", "final   float   w    =     ( dimensions    >  =     4  )     ?    arr [  ( idx    +     3  )  ]     :     1  .  0 F ;", "arr [ idx ]     =     (  (  ( x    *     ( m [  0  ]  )  )     +     ( y    *     ( m [  4  ]  )  )  )     +     ( z    *     ( m [  8  ]  )  )  )     +     ( w    *     ( m [  1  2  ]  )  )  ;", "arr [  ( idx    +     1  )  ]     =     (  (  ( x    *     ( m [  1  ]  )  )     +     ( y    *     ( m [  5  ]  )  )  )     +     ( z    *     ( m [  9  ]  )  )  )     +     ( w    *     ( m [  1  3  ]  )  )  ;", "if    ( dimensions    >  =     3  )     {", "arr [  ( idx    +     2  )  ]     =     (  (  ( x    *     ( m [  2  ]  )  )     +     ( y    *     ( m [  6  ]  )  )  )     +     ( z    *     ( m [  1  0  ]  )  )  )     +     ( w    *     ( m [  1  4  ]  )  )  ;", "if    ( dimensions    >  =     4  )", "arr [  ( idx    +     3  )  ]     =     (  (  ( x    *     ( m [  3  ]  )  )     +     ( y    *     ( m [  7  ]  )  )  )     +     ( z    *     ( m [  1  1  ]  )  )  )     +     ( w    *     ( m [  1  5  ]  )  )  ;", "}", "idx    +  =    stride ;", "}", "buffer . put ( arr )  ;", "buffer . position ( pos )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "com.badlogic.gdx.utils.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["doubleToLongBits"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . floatToIntBits ( value )  ;", "}", "METHOD_END"], "methodName": ["floatToIntBits"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . floatToIntBits ( value )  ;", "}", "METHOD_END"], "methodName": ["floatToIntColor"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . floatToIntBits ( value )  ;", "}", "METHOD_END"], "methodName": ["floatToRawIntBits"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat ( value )  ;", "}", "METHOD_END"], "methodName": ["intBitsToFloat"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat (  ( value    &     -  1  6  7  7  7  2  1  7  )  )  ;", "}", "METHOD_END"], "methodName": ["intToFloatColor"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["longBitsToDouble"], "fileName": "com.badlogic.gdx.utils.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "final   int   w    =    graphics . getBackBufferWidth (  )  ;", "final   int   h    =    graphics . getBackBufferHeight (  )  ;", "return    . getFrameBufferPixels (  0  ,     0  ,    w ,    h ,    flipY )  ;", "}", "METHOD_END"], "methodName": ["getFrameBufferPixels"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "gl . glPixelStorei ( GL _ PACK _ ALIGNMENT ,     1  )  ;", "final   ByteBuffer   pixels    =    BufferUnewByteBuffer (  (  ( w    *    h )     *     4  )  )  ;", "gl . glReadPixels ( x ,    y ,    w ,    h ,    GL _ RGBA ,    GL _ UNSIGNED _ BYTE ,    pixels )  ;", "final   int   numBytes    =     ( w    *    h )     *     4  ;", "byte [  ]    lines    =    new   byte [ numBytes ]  ;", "if    ( flipY )     {", "final   int   numBytesPerLine    =    w    *     4  ;", "for    ( int   i    =     0  ;    i    <    h ;    i +  +  )     {", "pixels . position (  (  (  ( h    -    i )     -     1  )     *    numBytesPerLine )  )  ;", "pixels . get ( lines ,     ( i    *    numBytesPerLine )  ,    numBytesPerLine )  ;", "}", "} else    {", "pixels . clear (  )  ;", "pixels . get ( lines )  ;", "}", "return   lines ;", "}", "METHOD_END"], "methodName": ["getFrameBufferPixels"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "gl . glPixelStorei ( GL _ PACK _ ALIGNMENT ,     1  )  ;", "final   Pixmap   pixmap    =    new   Pixmap ( w ,    h ,    Pixmap . Format . RGBA 8  8  8  8  )  ;", "ByteBuffer   pixels    =    BufferUtils . newByteBuffer (  (  ( h    *    w )     *     4  )  )  ;", "gl . glReadPixels ( x ,    y ,    w ,    h ,    GL _ RGBA ,    GL _ UNSIGNED _ BYTE ,    pixels )  ;", ". putPixelsBack ( pixmap ,    pixels )  ;", "return   pixmap ;", "}", "METHOD_END"], "methodName": ["getFrameBufferPixmap"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "final   int   w    =    graphics . getBackBufferWidth (  )  ;", "final   int   h    =    graphics . getBackBufferHeight (  )  ;", "return    . getFrameBufferTexture (  0  ,     0  ,    w ,    h )  ;", "}", "METHOD_END"], "methodName": ["getFrameBufferTexture"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "final   int   potW    =    MathUtils . nextPowerOfTwo ( w )  ;", "final   int   potH    =    MathUtils . nextPowerOfTwo ( h )  ;", "final   Pixmap   pixmap    =     . getFrameBufferPixmap ( x ,    y ,    w ,    h )  ;", "final   Pixmap   potPixmap    =    new   Pixmap ( potW ,    potH ,    Pixmap . Format . RGBA 8  8  8  8  )  ;", "potPixmap . drawPixmap ( pixmap ,     0  ,     0  )  ;", "Texture   texture    =    new   Texture ( potPixmap )  ;", "TextureRegion   textureRegion    =    new   TextureRegion ( texture ,     0  ,    h ,    w ,     (  - h )  )  ;", "potPixmap . dispose (  )  ;", "pixmap . dispose (  )  ;", "return   textureRegion ;", "}", "METHOD_END"], "methodName": ["getFrameBufferTexture"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( pixmap . getWidth (  )  )     =  =     0  )     |  |     (  ( pixmap . getHeight (  )  )     =  =     0  )  )", "return ;", ". putPixelsBack (  (  ( HasArrayBufferView )     ( pixels )  )  . getTypedArray (  )  ,    pixmap . getWidth (  )  ,    pixmap . getHeight (  )  ,    pixmap . getContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["putPixelsBack"], "fileName": "com.badlogic.gdx.utils.ScreenUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( info    =  =    null )", "throw   new   IllegalArgument (  \" info   cannot   be   null .  \"  )  ;", "if    (  ( trace )     =  =    null )", "trace    =    new   StringBuffer (  5  1  2  )  ;", "trace . append (  '  \\ n '  )  ;", "trace . append ( info )  ;", "}", "METHOD_END"], "methodName": ["addTrace"], "fileName": "com.badlogic.gdx.utils.SerializationException"}, {"methodBody": ["METHOD_START", "{", "return   causedBy ( this ,    type )  ;", "}", "METHOD_END"], "methodName": ["causedBy"], "fileName": "com.badlogic.gdx.utils.SerializationException"}, {"methodBody": ["METHOD_START", "{", "Throwable   cause    =    ex . getCause (  )  ;", "if    (  ( cause    =  =    null )     |  |     ( cause    =  =    ex )  )", "return   false ;", "return   false ;", "}", "METHOD_END"], "methodName": ["causedBy"], "fileName": "com.badlogic.gdx.utils.SerializationException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( trace )     =  =    null )", "return   super . getMessage (  )  ;", "StringBuffer   buffer    =    new   StringBuffer (  5  1  2  )  ;", "buffer . append ( super . getMessage (  )  )  ;", "if    (  ( buffer . length (  )  )     >     0  )", "buffer . append (  '  \\ n '  )  ;", "buffer . append (  \"    trace :  \"  )  ;", "buffer . append ( trace )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "com.badlogic.gdx.utils.SerializationException"}, {"methodBody": ["METHOD_START", "{", "buffer . setLength (  0  )  ;", "boolean   changed    =    false ;", "int   placeholder    =     -  1  ;", "int   pnLength    =    pn . length (  )  ;", "for    ( int   i    =     0  ;    i    <    pnLength ;     +  + i )     {", "char   ch    =    pn . charAt ( i )  ;", "if    ( placeholder    <     0  )     {", "if    ( ch    =  =     '  {  '  )     {", "changed    =    true ;", "if    (  (  ( i    +     1  )     <    pnLength )     &  &     (  ( pn . charAt (  ( i    +     1  )  )  )     =  =     '  {  '  )  )     {", "buffer . append ( ch )  ;", "+  + i ;", "} else    {", "placeholder    =     0  ;", "}", "} else    {", "buffer . append ( ch )  ;", "}", "} else    {", "if    ( ch    =  =     '  }  '  )     {", "if    ( placeholder    >  =     ( args . length )  )", "throw   new   IllegalArgumentException (  (  \" Argument   index   out   of   bounds :     \"     +    placeholder )  )  ;", "if    (  ( pn . charAt (  ( i    -     1  )  )  )     =  =     '  {  '  )", "throw   new   IllegalArgumentException (  \" Missing   argument   index   after   a   left   curly   brace \"  )  ;", "if    (  ( args [ placeholder ]  )     =  =    null )", "buffer . append (  \" null \"  )  ;", "else", "buffer . append ( args [ placeholder ]  . toString (  )  )  ;", "placeholder    =     -  1  ;", "} else    {", "if    (  ( ch    <     '  0  '  )     |  |     ( ch    >     '  9  '  )  )", "throw   new   IllegalArgumentException (  (  (  \" Unexpected    '  \"     +    ch )     +     \"  '    while   parsing   argument   index \"  )  )  ;", "placeholder    =     ( placeholder    *     1  0  )     +     ( ch    -     '  0  '  )  ;", "}", "}", "}", "if    ( placeholder    >  =     0  )", "throw   new   IllegalArgumentException (  \" Unmatched   braces   in   the   pn .  \"  )  ;", "return   changed    ?    buffer . toString (  )     :    pn ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "com.badlogic.gdx.utils.TextFormatter"}, {"methodBody": ["METHOD_START", "{", "return   System . currentTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["millis"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return   millis    *     ( TimeUtils . nanosPerMilli )  ;", "}", "METHOD_END"], "methodName": ["millisToNanos"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( System . currentTimeMillis (  )  )     *     ( TimeUtils . nanosPerMilli )  ;", "}", "METHOD_END"], "methodName": ["nanoTime"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return   nanos    /     ( TimeUtils . nanosPerMilli )  ;", "}", "METHOD_END"], "methodName": ["nanosToMillis"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( TimeUtils . millis (  )  )     -    prevTime ;", "}", "METHOD_END"], "methodName": ["timeSinceMillis"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( TimeUtils . nanoTime (  )  )     -    prevTime ;", "}", "METHOD_END"], "methodName": ["timeSinceNanos"], "fileName": "com.badlogic.gdx.utils.TimeUtils"}, {"methodBody": ["METHOD_START", "{", "nchronized ( ta    {", "for    ( int   i    =     0  ,    n    =    taze ;    i    <    n ;    i +  +  )", "taget ( i )  . cancel (  )  ;", "taclear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( tasks )     {", "for    ( int   i    =     0  ,    n    =    tasks . size ;    i    <    n ;    i +  +  )     {", ". Task   task    =    tasks . get ( i )  ;", "task . executeTimeMillis    +  =    delayMillis ;", "}", "}", "}", "METHOD_END"], "methodName": ["delay"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Timer . instance )     =  =    null )     {", "Timer . instance    =    new   Timer (  )  ;", "}", "return   Timer . instance ;", "}", "METHOD_END"], "methodName": ["instance"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   Timer . instance (  )  . postTask ( task )  ;", "}", "METHOD_END"], "methodName": ["post"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   scheduleTask ( task ,     0  ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["postTask"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   Timer . instance (  )  . scheduleTask ( task ,    delaySeconds )  ;", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   Timer . instance (  )  . scheduleTask ( task ,    delaySeconds ,    intervalSeconds )  ;", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   Timer . instance (  )  . scheduleTask ( task ,    delaySeconds ,    intervalSeconds ,    repeatCount )  ;", "}", "METHOD_END"], "methodName": ["schedule"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   scheduleTask ( task ,    delaySeconds ,     0  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["scheduleTask"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "return   scheduleTask ( task ,    delaySeconds ,    intervalSeconds ,    Timer . FOREVER )  ;", "}", "METHOD_END"], "methodName": ["scheduleTask"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( task . repeatCount )     !  =     ( Timer . CANCELLED )  )", "throw   new   IllegalArgumentException (  \" The   same   task   may   not   be   scheduled   twice .  \"  )  ;", "task . executeTimeMillis    =     (  ( TimeUtils . nanoTime (  )  )     /     1  0  0  0  0  0  0  )     +     (  ( long )     ( delaySeconds    *     1  0  0  0  )  )  ;", "task . intervalMillis    =     (  ( long )     ( intervalSeconds    *     1  0  0  0  )  )  ;", "task . repeatCount    =    repeatCount ;", "synchronized ( tasks )     {", "tasks . add ( task )  ;", "}", "Timer . wake (  )  ;", "return   task ;", "}", "METHOD_END"], "methodName": ["scheduleTask"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized . instances )     {", "if    . instances . contains ( this ,    true )  )", "return ;", ". instances . add ( this )  ;", "if    (  . thread )     =  =    null )", ". thread    =    newThread (  )  ;", ". wake (  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( Timer . instances )     {", "Timer . instances . removeValue ( this ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( tasks )     {", "for    ( int   i    =     0  ,    n    =    tasks . size ;    i    <    n ;    i +  +  )     {", ". Task   task    =    tasks . get ( i )  ;", "if    (  ( task . executeTimeMillis )     >    timeMillis )     {", "waitMillis    =    Math . min ( waitMillis ,     (  ( task . executeTimeMillis )     -    timeMillis )  )  ;", "continue ;", "}", "if    (  ( task . repeatCount )     !  =     (  . CANCELLED )  )     {", "if    (  ( task . repeatCount )     =  =     0  )     {", "task . repeatCount    =     . CANCELLED ;", "}", "app . postRunnable ( task )  ;", "}", "if    (  ( task . repeatCount )     =  =     (  . CANCELLED )  )     {", "tasks . removeIndex ( i )  ;", "i -  -  ;", "n -  -  ;", "} else    {", "task . executeTimeMillis    =    timeMillis    +     ( task . intervalMillis )  ;", "waitMillis    =    Math . min ( waitMillis ,    task . intervalMillis )  ;", "if    (  ( task . repeatCount )     >     0  )", "( task . repeatCount )  -  -  ;", "}", "}", "}", "return   waitMillis ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( Timer . instances )     {", "Timer . thread . schedule (  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["wake"], "fileName": "com.badlogic.gdx.utils.Timer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( b    >     0  )     &  &     (  ( state )     =  =     ( Utf 8 Decoder . UTF 8  _ ACCEPT )  )  )     {", "charBuffer [  (  ( charOffset )  +  +  )  ]     =     (  ( char )     ( b    &     2  5  5  )  )  ;", "} else    {", "int   i    =    b    &     2  5  5  ;", "int   type    =    Utf 8 Decoder . BYTE _ TABLE [ i ]  ;", "codePoint    =     (  ( state )     =  =     ( Utf 8 Decoder . UTF 8  _ ACCEPT )  )     ?     (  2  5  5     >  >    type )     &    i    :     ( i    &     6  3  )     |     (  ( codePoint )     <  <     6  )  ;", "int   next    =    Utf 8 Decoder . TRANSITION _ TABLE [  (  ( state )     +    type )  ]  ;", "switch    ( next )     {", "case   Utf 8 Decoder . UTF 8  _ ACCEPT    :", "state    =    next ;", "if    (  ( codePoint )     <     ( Character . MIN _ HIGH _ SURROGATE )  )     {", "charBuffer [  (  ( charOffset )  +  +  )  ]     =     (  ( char )     ( codePoint )  )  ;", "} else    {", "int   codePointLength    =    Character . toChars ( codePoint ,    utf 1  6 Char ,     0  )  ;", "charBuffer [  (  ( charOffset )  +  +  )  ]     =    utf 1  6 Char [  0  ]  ;", "if    ( codePointLength    =  =     2  )", "charBuffer [  (  ( charOffset )  +  +  )  ]     =    utf 1  6 Char [  1  ]  ;", "}", "break ;", "case   Utf 8 Decoder . UTF 8  _ REJECT    :", "codePoint    =     0  ;", "state    =    Utf 8 Decoder . UTF 8  _ ACCEPT ;", "charBuffer [  (  ( charOffset )  +  +  )  ]     =    Utf 8 Decoder . REPLACEMENT ;", "break ;", "default    :", "state    =    next ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.badlogic.gdx.utils.Utf8Decoder"}, {"methodBody": ["METHOD_START", "{", "this . charBuffer    =    charBuffer ;", "this . charOffset    =    charOffset ;", "int   end    =    offset    +    length ;", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )", "d ( b [ i ]  )  ;", "return    ( this . charOffset )     -    charOffset ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "com.badlogic.gdx.utils.Utf8Decoder"}, {"methodBody": ["METHOD_START", "{", "state    =    Utf 8 Decoder . UTF 8  _ ACCEPT ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.utils.Utf8Decoder"}, {"methodBody": ["METHOD_START", "{", "T   result    =    null ;", "try    {", "result    =    task . call (  )  ;", "}    catch    ( Throwable   t )     {", "throw   new   GdxRuntimeException (  (  \" Could   not   submit   Task :     \"     +     ( t . getMessage (  )  )  )  ,    t )  ;", "}", "return   new   Result ( result )  ;", "}", "METHOD_END"], "methodName": ["submit"], "fileName": "com.badlogic.gdx.utils.async.AsyncExecutor"}, {"methodBody": ["METHOD_START", "{", "return   result ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.async.AsyncResult"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isDone"], "fileName": "com.badlogic.gdx.utils.async.AsyncResult"}, {"methodBody": ["METHOD_START", "{", "if    ( annotation . annotationType (  )  . equals ( annotationType )  )     {", "return    (  ( T )     ( annotation )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.Annotation"}, {"methodBody": ["METHOD_START", "{", "return   annotation . annotationType (  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "com.badlogic.gdx.utils.reflect.Annotation"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( array . getClass (  )  )  . getArrayElement ( array ,    index )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.reflect.ArrayReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( array . getClass (  )  )  . getArrayLength ( array )  ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.badlogic.gdx.utils.reflect.ArrayReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . newArray ( c ,    size )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gdx.utils.reflect.ArrayReflection"}, {"methodBody": ["METHOD_START", "{", "ReflectionCache . getType ( array . getClass (  )  )  . setArrayElement ( array ,    index ,    value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.reflect.ArrayReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Cache . forName ( name )  . getClassOfType (  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   Exception (  (  \" Class   not   found :     \"     +    name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    ClassReflection . getAnnotations ( c )  ;", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . getAnnotationType (  )  . equals ( annotationType )  )", "return   annotation ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Type   declType    =    ReflectionCache . getType ( c )  ;", "Annotation [  ]    annotations    =    declType . getDeclaredAnnotations (  )  ;", "Annotation [  ]    result    =    new   Annotation [ annotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "result [ i ]     =    new   Annotation ( annotations [ i ]  )  ;", "}", "Type   superType    =    declType . getSuperclass (  )  ;", "Annotation [  ]    superAnnotations ;", "while    (  !  ( superType . getClassOfType (  )  . equals ( Object . class )  )  )     {", "superAnnotations    =    superType . getDeclaredAnnotations (  )  ;", "for    ( int   i    =     0  ;    i    <     ( superAnnotations . length )  ;    i +  +  )     {", "Type   annotationType    =    ReflectionCache . getType ( superAnnotations [ i ]  . annotationType (  )  )  ;", "if    (  ( annotationType . getDeclaredAnnotation ( Inherited . class )  )     !  =    null )     {", "boolean   duplicate    =    false ;", "for    ( Annotation   annotation    :    result )     {", "if    ( annotation . getAnnotationType (  )  . equals ( annotationType )  )     {", "duplicate    =    true ;", "break ;", "}", "}", "if    (  ! duplicate )     {", "Annotation [  ]    copy    =    new   Annotation [  ( result . length )     +     1  ]  ;", "for    ( int   j    =     0  ;    j    <     ( result . length )  ;    j +  +  )     {", "copy [ j ]     =    result [ j ]  ;", "}", "copy [ result . length ]     =    new   Annotation ( superAnnotations [ i ]  )  ;", "result    =    copy ;", "}", "}", "}", "superType    =    superType . getSuperclass (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . getComponentType (  )  ;", "}", "METHOD_END"], "methodName": ["getComponentType"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Constructor ( Cache . getType ( c )  . getConstructor ( parameterTypes )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  \" Security   violation   while   getting   constructor   for   class :     \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   Exception (  (  \" Constructor   not   found   for   class :     \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getConstructor"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Constructor [  ]    constructors    =    ReflectionCache . getType ( c )  . getConstructors (  )  ;", "Constructor [  ]    result    =    new   Constructor [ constructors . length ]  ;", "for    ( int   i    =     0  ,    j    =    constructors . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Constructor ( constructors [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getConstructors"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Annotation   annotation    =    ReflectionCache . getType ( c )  . getDeclaredAnnotation ( annotationType )  ;", "if    ( annotation    !  =    null )", "return   new   Annotation ( annotation )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    ReflectionCache . getType ( c )  . getDeclaredAnnotations (  )  ;", "Annotation [  ]    result    =    new   Annotation [ annotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "result [ i ]     =    new   Annotation ( annotations [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotations"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Constructor ( Cache . getType ( c )  . getDeclaredConstructor ( parameterTypes )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  \" Security   violation   while   getting   constructor   for   class :     \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   Exception (  (  \" Constructor   not   found   for   class :     \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDeclaredConstructor"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Field ( Cache . getType ( c )  . getDeclaredField ( name )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  (  (  \" Security   violation   while   getting   field :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchFieldException   e )     {", "throw   new   Exception (  (  (  (  \" Field   not   found :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDeclaredField"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Field [  ]    fields    =    ReflectionCache . getType ( c )  . getDeclaredFields (  )  ;", "Field [  ]    result    =    new   Field [ fields . length ]  ;", "for    ( int   i    =     0  ,    j    =    fields . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Field ( fields [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredFields"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Method ( Cache . getType ( c )  . getDeclaredMethod ( name ,    parameterTypes )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  (  (  \" Security   violation   while   getting   method :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   Exception (  (  (  (  \" Method   not   found :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDeclaredMethod"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    ReflectionCache . getType ( c )  . getDeclaredMethods (  )  ;", "Method [  ]    result    =    new   Method [ methods . length ]  ;", "for    ( int   i    =     0  ,    j    =    methods . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Method ( methods [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredMethods"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . getEnumConstants (  )  ;", "}", "METHOD_END"], "methodName": ["getEnumConstants"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Field ( Cache . getType ( c )  . getField ( name )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  (  (  \" Security   violation   while   getting   field :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchFieldException   e )     {", "throw   new   Exception (  (  (  (  \" Field   not   found :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Field [  ]    fields    =    ReflectionCache . getType ( c )  . getFields (  )  ;", "Field [  ]    result    =    new   Field [ fields . length ]  ;", "for    ( int   i    =     0  ,    j    =    fields . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Field ( fields [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getFields"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . getInterfaces (  )  ;", "}", "METHOD_END"], "methodName": ["getInterfaces"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   Method ( Cache . getType ( c )  . getMethod ( name ,    parameterTypes )  )  ;", "}    catch    ( SecurityException   e )     {", "throw   new   Exception (  (  (  (  \" Security   violation   while   getting   method :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   Exception (  (  (  (  \" Method   not   found :     \"     +    name )     +     \"  ,    for   class :     \"  )     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    ReflectionCache . getType ( c )  . getMethods (  )  ;", "Method [  ]    result    =    new   Method [ methods . length ]  ;", "for    ( int   i    =     0  ,    j    =    methods . length ;    i    <    j ;    i +  +  )     {", "result [ i ]     =    new   Method ( methods [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getMethods"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   c . getSimpleName (  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleName"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . isAbstract (  )  ;", "}", "METHOD_END"], "methodName": ["isAbstract"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . isAnnotation (  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    ClassReflection . getAnnotations ( c )  ;", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . getAnnotationType (  )  . equals ( annotationType )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . isArray (  )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "Type   c 1 Type    =    ReflectionCache . getType ( c 1  )  ;", "Type   c 2 Type    =    ReflectionCache . getType ( c 2  )  ;", "return   c 1 Type . isAssignableFrom ( c 2 Type )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . isEnum (  )  ;", "}", "METHOD_END"], "methodName": ["isEnum"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return    ( obj    !  =    null )     &  &     ( ClassReflection . isAssignableFrom ( c ,    obj . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isInstance"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . isInterface (  )  ;", "}", "METHOD_END"], "methodName": ["isInterface"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . isMemberClass (  )  ;", "}", "METHOD_END"], "methodName": ["isMemberClass"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . isPrimitive (  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitive"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getType ( c )  . isStatic (  )  ;", "}", "METHOD_END"], "methodName": ["isStaticClass"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( T )     ( Cache . getType ( c )  . newInstance (  )  )  )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   Exception (  (  \" Could   not   use   default   constructor   of    \"     +     ( c . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gdx.utils.reflect.ClassReflection"}, {"methodBody": ["METHOD_START", "{", "return   constructor . getEnclosingType (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "com.badlogic.gdx.utils.reflect.Constructor"}, {"methodBody": ["METHOD_START", "{", "Parameter [  ]    parameters    =    constructor . getParameters (  )  ;", "Class [  ]    parameterTypes    =    new   Class [ parameters . length ]  ;", "for    ( int   i    =     0  ,    j    =    parameters . length ;    i    <    j ;    i +  +  )     {", "parameterTypes [ i ]     =    parameters [ i ]  . getClazz (  )  ;", "}", "return   parameterTypes ;", "}", "METHOD_END"], "methodName": ["getParameterTypes"], "fileName": "com.badlogic.gdx.utils.reflect.Constructor"}, {"methodBody": ["METHOD_START", "{", "return   constructor . isPublic (  )  ;", "}", "METHOD_END"], "methodName": ["isAccessible"], "fileName": "com.badlogic.gdx.utils.reflect.Constructor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   c . newInstance ( args )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   ReflectionException (  (  \" Illegal   argument ( s )    supplied   to   c   for   class :     \"     +     ( getDeclaringClass (  )  . getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gdx.utils.reflect.Constructor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   field . get ( obj )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   RionException (  (  (  (  (  (  \" Could   not   get    \"     +     ( getDeclaringClass (  )  )  )     +     \"  #  \"  )     +     ( getName (  )  )  )     +     \"  :     \"  )     +     ( e . getMessage (  )  )  )  ,    e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RionException (  (  (  (  \" Illegal   access   to   field    \"     +     ( getName (  )  )  )     +     \"  :     \"  )     +     ( e . getMessage (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    field . getDeclaredAnnotations (  )  ;", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . annotationType (  )  . equals ( annotationType )  )     {", "return   new   Annotation ( annotation )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    field . getDeclaredAnnotations (  )  ;", "Annotation [  ]    result    =    new   Annotation [ annotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "result [ i ]     =    new   Annotation ( annotations [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotations"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . getEnclosingType (  )  . getClassOfType (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "Type   elementType    =    field . getElementType ( index )  ;", "return   elementType    !  =    null    ?    elementType . getClassOfType (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getElementType"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . getType (  )  . getClassOfType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isPublic (  )  ;", "}", "METHOD_END"], "methodName": ["isAccessible"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    field . getDeclaredAnnotations (  )  ;", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . annotationType (  )  . equals ( annotationType )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return    (  (  !  ( isPrivate (  )  )  )     &  &     (  !  ( isProtected (  )  )  )  )     &  &     (  !  ( isPublic (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultAccess"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isFinal (  )  ;", "}", "METHOD_END"], "methodName": ["isFinal"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isPrivate (  )  ;", "}", "METHOD_END"], "methodName": ["isPrivate"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isProtected (  )  ;", "}", "METHOD_END"], "methodName": ["isProtected"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isPublic (  )  ;", "}", "METHOD_END"], "methodName": ["isPublic"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isStatic (  )  ;", "}", "METHOD_END"], "methodName": ["isStatic"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isSynthetic (  )  ;", "}", "METHOD_END"], "methodName": ["isSynthetic"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isTransient (  )  ;", "}", "METHOD_END"], "methodName": ["isTransient"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "return   field . isVolatile (  )  ;", "}", "METHOD_END"], "methodName": ["isVolatile"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "try    {", "field . set ( obj ,    value )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   RionException (  (  (  (  (  (  \" Could   not   set    \"     +     ( getDeclaringClass (  )  )  )     +     \"  #  \"  )     +     ( getName (  )  )  )     +     \"  :     \"  )     +     ( e . getMessage (  )  )  )  ,    e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RionException (  (  (  (  \" Illegal   access   to   field    \"     +     ( getName (  )  )  )     +     \"  :     \"  )     +     ( e . getMessage (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.utils.reflect.Field"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    method . getDeclaredAnnotations (  )  ;", "if    ( annotations    =  =    null )", "return   null ;", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . annotationType (  )  . equals ( annotationType )  )     {", "return   new   Annotation ( annotation )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotation"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    method . getDeclaredAnnotations (  )  ;", "if    ( annotations    =  =    null )", "return   new   Annotation [  0  ]  ;", "Annotation [  ]    result    =    new   Annotation [ annotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "result [ i ]     =    new   Annotation ( annotations [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotations"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . getEnclosingType (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "Parameter [  ]    parameters    =    method . getParameters (  )  ;", "Class [  ]    parameterTypes    =    new   Class [ parameters . length ]  ;", "for    ( int   i    =     0  ,    j    =    parameters . length ;    i    <    j ;    i +  +  )     {", "parameterTypes [ i ]     =    parameters [ i ]  . getClazz (  )  ;", "}", "return   parameterTypes ;", "}", "METHOD_END"], "methodName": ["getParameterTypes"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . getReturnType (  )  ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   method . invoke ( obj ,    args )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   RionException (  (  \" Illegal   argument ( s )    supplied   to   method :     \"     +     ( getName (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isAbstract (  )  ;", "}", "METHOD_END"], "methodName": ["isAbstract"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isPublic (  )  ;", "}", "METHOD_END"], "methodName": ["isAccessible"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    method . getDeclaredAnnotations (  )  ;", "if    ( annotations    !  =    null )     {", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . annotationType (  )  . equals ( annotationType )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return    (  (  !  ( isPrivate (  )  )  )     &  &     (  !  ( isProtected (  )  )  )  )     &  &     (  !  ( isPublic (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultAccess"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isFinal (  )  ;", "}", "METHOD_END"], "methodName": ["isFinal"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isNative (  )  ;", "}", "METHOD_END"], "methodName": ["isNative"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isPrivate (  )  ;", "}", "METHOD_END"], "methodName": ["isPrivate"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isProtected (  )  ;", "}", "METHOD_END"], "methodName": ["isProtected"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isPublic (  )  ;", "}", "METHOD_END"], "methodName": ["isPublic"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isStatic (  )  ;", "}", "METHOD_END"], "methodName": ["isStatic"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "return   method . isVarArgs (  )  ;", "}", "METHOD_END"], "methodName": ["isVarArgs"], "fileName": "com.badlogic.gdx.utils.reflect.Method"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( type )     =  =    null )     &  &     (  ( clazz )     !  =    null )  )", "type    =    Reflection . getType ( clazz )  ;", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gwtref.client.CachedTypeLookup"}, {"methodBody": ["METHOD_START", "{", "return   super . invoke ( null ,    params )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gwtref.client.Constructor"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getFieldValue ( this ,    obj )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   annotations ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotations"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( elementTypes )     !  =    null )     &  &     ( index    >  =     0  )  )     &  &     ( index    <     ( elementTypes . length )  )  )", "return   elementTypes [ index ]  . getType (  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getElementType"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   enclosingType . getType (  )  ;", "}", "METHOD_END"], "methodName": ["getEnclosingType"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   type . getType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   isDefaultAccess ;", "}", "METHOD_END"], "methodName": ["isDefaultAccess"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   isFinal ;", "}", "METHOD_END"], "methodName": ["isFinal"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   isPrivate ;", "}", "METHOD_END"], "methodName": ["isPrivate"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   isProtected ;", "}", "METHOD_END"], "methodName": ["isProtected"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   isPublic ;", "}", "METHOD_END"], "methodName": ["isPublic"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   isStatic ;", "}", "METHOD_END"], "methodName": ["isStatic"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isSynthetic"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   isTransient ;", "}", "METHOD_END"], "methodName": ["isTransient"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   isVolatile ;", "}", "METHOD_END"], "methodName": ["isVolatile"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "ReflectionCache . setFieldValue ( this ,    obj ,    value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gwtref.client.Field"}, {"methodBody": ["METHOD_START", "{", "return   annotations ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotations"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   enclosingType . clazz ;", "}", "METHOD_END"], "methodName": ["getEnclosingType"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   parameters ;", "}", "METHOD_END"], "methodName": ["getParameters"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   returnType . clazz ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parameters . length )     !  =     ( params    !  =    null    ?    params . length    :     0  )  )", "throw   new   IllegalArgumException (  \" Parameter   mismatch \"  )  ;", "return   ReflectionCache . invoke ( this ,    obj ,    params )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isAbstract ;", "}", "METHOD_END"], "methodName": ["isAbstract"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isConstructor ;", "}", "METHOD_END"], "methodName": ["isConstructor"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isDefaultAccess ;", "}", "METHOD_END"], "methodName": ["isDefaultAccess"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isFinal ;", "}", "METHOD_END"], "methodName": ["isFinal"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isMethod ;", "}", "METHOD_END"], "methodName": ["isMethod"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isNative ;", "}", "METHOD_END"], "methodName": ["isNative"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isPrivate ;", "}", "METHOD_END"], "methodName": ["isPrivate"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isProtected ;", "}", "METHOD_END"], "methodName": ["isProtected"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isPublic ;", "}", "METHOD_END"], "methodName": ["isPublic"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isStatic ;", "}", "METHOD_END"], "methodName": ["isStatic"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   isVarArgs ;", "}", "METHOD_END"], "methodName": ["isVarArgs"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "if    ( types    =  =    null )", "turn    ( parameters . length )     =  =     0  ;", "if    (  ( types . length )     !  =     ( parameters . length )  )", "turn   false ;", "for    ( int   i    =     0  ;    i    <     ( types . length )  ;    i +  +  )     {", "Type   t 1     =    parameters [ i ]  . getType (  )  ;", "Type   t 2     =    ReflectionCache . getType ( types [ i ]  )  ;", "if    (  ( t 1     !  =    t 2  )     &  &     (  !  ( t 1  . isAssignableFrom ( t 2  )  )  )  )", "turn   false ;", "}", "turn   true ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return    ( this . name . equals ( name )  )     &  &     ( match ( types )  )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "com.badlogic.gwtref.client.Method"}, {"methodBody": ["METHOD_START", "{", "return   type . clazz ;", "}", "METHOD_END"], "methodName": ["getClazz"], "fileName": "com.badlogic.gwtref.client.Parameter"}, {"methodBody": ["METHOD_START", "{", "return   jnsi ;", "}", "METHOD_END"], "methodName": ["getJnsi"], "fileName": "com.badlogic.gwtref.client.Parameter"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gwtref.client.Parameter"}, {"methodBody": ["METHOD_START", "{", "return   type . getType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gwtref.client.Parameter"}, {"methodBody": ["METHOD_START", "{", "if    ( className . startsWith (  \"  [  \"  )  )     {", "int   dimensions    =     0  ;", "char   c    =    className . charAt (  0  )  ;", "String   suffix    =     \"  \"  ;", "while    ( c    =  =     '  [  '  )     {", "dimensions +  +  ;", "suffix    +  =     \"  [  ]  \"  ;", "c    =    className . charAt ( dimensions )  ;", "}", "char   t    =    className . charAt ( dimensions )  ;", "switch    ( t )     {", "case    ' Z '     :", "return    \" boolean \"     +    suffix ;", "case    ' B '     :", "return    \" byte \"     +    suffix ;", "case    ' C '     :", "return    \" char \"     +    suffix ;", "case    ' L '     :", "return    ( className . substring (  ( dimensions    +     1  )  ,     (  ( className . length (  )  )     -     1  )  )  . replace (  '  $  '  ,     '  .  '  )  )     +    suffix ;", "case    ' D '     :", "return    \" double \"     +    suffix ;", "case    ' F '     :", "return    \" float \"     +    suffix ;", "case    ' I '     :", "return    \" int \"     +    suffix ;", "case    ' J '     :", "return    \" long \"     +    suffix ;", "case    ' S '     :", "return    \" short \"     +    suffix ;", "default    :", "throw   new   IllegalArgumentExcep (  (  (  \" Couldn ' t   transform    '  \"     +    className )     +     \"  '    to   qualified   source   name \"  )  )  ;", "}", "} else    {", "return   className . replace (  '  $  '  ,     '  .  '  )  ;", "}", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "Type   type    =    ReflectionCache . instance . forName ( ReflectionCache . convert ( name )  )  ;", "if    ( type    =  =    null )     {", "throw   new   RuntimeException (  (  (  \" Couldn ' t   find   Type   for   class    '  \"     +    name )     +     \"  '  \"  )  )  ;", "}", "return   type ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . instance . getArrayElement ( type ,    obj ,    i )  ;", "}", "METHOD_END"], "methodName": ["getArrayElement"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . instance . getArrayLength ( type ,    obj )  ;", "}", "METHOD_END"], "methodName": ["getArrayLength"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . instance . get ( field ,    obj )  ;", "}", "METHOD_END"], "methodName": ["getFieldValue"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "if    ( clazz    =  =    null )", "return   null ;", "Type   type    =     . instance . forName (  . convert ( clazz . getName (  )  )  )  ;", "if    ( type    =  =    null )     {", "throw   new   RuntimeException (  (  (  \" Couldn ' t   find   Type   for   class    '  \"     +     ( clazz . getName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . instance . invoke ( method ,    obj ,    params )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . instance . newArray ( ReflectionCache . getType ( componentType )  ,    size )  ;", "}", "METHOD_END"], "methodName": ["newArray"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "ReflectionCache . instance . setArrayElement ( type ,    obj ,    i ,    value )  ;", "}", "METHOD_END"], "methodName": ["setArrayElement"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "ReflectionCache . instance . set ( field ,    obj ,    value )  ;", "}", "METHOD_END"], "methodName": ["setFieldValue"], "fileName": "com.badlogic.gwtref.client.ReflectionCache"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getArrayElement ( this ,    obj ,    i )  ;", "}", "METHOD_END"], "methodName": ["getArrayElement"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionCache . getArrayLength ( this ,    obj )  ;", "}", "METHOD_END"], "methodName": ["getArrayLength"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   clazz ;", "}", "METHOD_END"], "methodName": ["getClassOfType"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   componentType ;", "}", "METHOD_END"], "methodName": ["getComponentType"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "for    ( Constructor   c    :    constructors )     {", "if    (  ( c . isPublic (  )  )     &  &     ( c . match ( parameters )  )  )", "return   c ;", "}", "throw   new   NoSuchMethodException (  )  ;", "}", "METHOD_END"], "methodName": ["getConstructor"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   constructors ;", "}", "METHOD_END"], "methodName": ["getConstructors"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotation . annotation (  )  . equals ( annotation )  )", "return   annotation ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotation"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   annotations ;", "}", "METHOD_END"], "methodName": ["getDeclaredAnnotations"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   getConstructor ( parameterTypes )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredConstructor"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "for    ( Field   f    :    getDeclaredFields (  )  )     {", "if    ( f . name . equals ( name )  )", "return   f ;", "}", "throw   new   NoSuchFieldException (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredField"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   fields ;", "}", "METHOD_END"], "methodName": ["getDeclaredFields"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   m    :    getDeclaredMethods (  )  )     {", "if    ( m . match ( name ,    parameters )  )", "return   m ;", "}", "throw   new   NoSuchMethodException (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredMethod"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   methods ;", "}", "METHOD_END"], "methodName": ["getDeclaredMethods"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   enumConstants ;", "}", "METHOD_END"], "methodName": ["getEnumConstants"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "for    ( Field   f    :    getFields (  )  )     {", "if    ( f . name . equals ( name )  )", "return   f ;", "}", "throw   new   NoSuchFieldException (  )  ;", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "if    (  ( allFields )     =  =    null )     {", "ArrayList < Field >    allFieldsList    =    new   ArrayList < Field >  (  )  ;", "t    =    this ;", "while    ( t    !  =    null )     {", "for    ( Field   f    :    t . fields )     {", "if    ( f . isPublic )", "allFieldsList . add ( f )  ;", "}", "t    =    t . getSuperclass (  )  ;", "}", "allFields    =    allFieldsList . toArray ( new   Field [ allFieldsList . size (  )  ]  )  ;", "}", "return   allFields ;", "}", "METHOD_END"], "methodName": ["getFields"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   interfaces . toArray ( new   Class [ this . interfaces . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["getInterfaces"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   m    :    getMethods (  )  )     {", "if    ( m . match ( name ,    parameters )  )", "return   m ;", "}", "throw   new   NoSuchMethodException (  )  ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "if    (  ( allMethods )     =  =    null )     {", "ArrayList < Method >    allMethodsList    =    new   ArrayList < Method >  (  )  ;", "t    =    this ;", "while    ( t    !  =    null )     {", "for    ( Method   m    :    t . methods )     {", "if    ( m . isPublic (  )  )", "allMethodsList . add ( m )  ;", "}", "t    =    t . getSuperclass (  )  ;", "}", "allMethods    =    allMethodsList . toArray ( new   Method [ allMethodsList . size (  )  ]  )  ;", "}", "return   allMethods ;", "}", "METHOD_END"], "methodName": ["getMethods"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   superClass . getType (  )  ;", "}", "METHOD_END"], "methodName": ["getSuperclass"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   isAbstract ;", "}", "METHOD_END"], "methodName": ["isAbstract"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   isAnnotation ;", "}", "METHOD_END"], "methodName": ["isAnnotation"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   isArray ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( clazz )     =  =     ( otherType . clazz )  )     |  |     (  (  ( clazz )     =  =     ( Object . class )  )     &  &     (  !  ( otherType . isPrimitive )  )  )  )     |  |     ( otherType . assignables . contains ( clazz )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   isEnum ;", "}", "METHOD_END"], "methodName": ["isEnum"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   isInterface ;", "}", "METHOD_END"], "methodName": ["isInterface"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   isMemberClass ;", "}", "METHOD_END"], "methodName": ["isMemberClass"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   isPrimitive ;", "}", "METHOD_END"], "methodName": ["isPrimitive"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   isStatic ;", "}", "METHOD_END"], "methodName": ["isStatic"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "return   getConstructor (  )  . newInstance (  )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "ReflectionCache . setArrayElement ( this ,    obj ,    i ,    value )  ;", "}", "METHOD_END"], "methodName": ["setArrayElement"], "fileName": "com.badlogic.gwtref.client.Type"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( stub . isStatic )  )     &  &     (  !  ( stub . isConstructor )  )  )", "pbn (  (  (  (  \"  (  \"     +     ( stub . enclosingType )  )     +     \"  ) obj \"  )     +     (  ( stub . parameterTypes . size (  )  )     >     0     ?     \"  ,  \"     :     \"  \"  )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( stub . parameterTypes . size (  )  )  ;    i +  +  )     {", "pbn (  (  ( cast ( stub . parameterTypes . get ( i )  ,     (  (  \" params [  \"     +    i )     +     \"  ]  \"  )  )  )     +     ( i    <     (  ( stub . parameterTypes . size (  )  )     -     1  )     ?     \"  ,     \"     :     \"  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addParameters"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  (  (  ( paramType . equals (  \" byte \"  )  )     |  |     ( paramType . equals (  \" short \"  )  )  )     |  |     ( paramType . equals (  \" int \"  )  )  )     |  |     ( paramType . equals (  \" long \"  )  )  )     |  |     ( paramType . equals (  \" float \"  )  )  )     |  |     ( paramType . equals (  \" double \"  )  )  )     {", "return    (  (  (  \"  (  ( Number )  \"     +    arg )     +     \"  )  .  \"  )     +    paramType )     +     \" Value (  )  \"  ;", "} else", "if    ( paramType . equals (  \" boolean \"  )  )     {", "return    (  (  (  \"  (  ( Boolean )  \"     +    arg )     +     \"  )  .  \"  )     +    paramType )     +     \" Value (  )  \"  ;", "} else", "if    ( paramType . equals (  \" char \"  )  )     {", "return    (  (  (  \"  (  ( Character )  \"     +    arg )     +     \"  )  .  \"  )     +    paramType )     +     \" Value (  )  \"  ;", "} else    {", "return    (  (  (  \"  (  (  \"     +    paramType )     +     \"  )  \"  )     +    arg )     +     \"  )  \"  ;", "}", "}", "METHOD_END"], "methodName": ["cast"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "ClassSourceFileComposerFactory   composer    =    new   ClassSourceFileComposerFactory ( packageName ,    simpleName )  ;", "composer . addImplementedInterface (  \" client . IReflectionCache \"  )  ;", "imports ( composer )  ;", "PrintWriter   printWriter    =    context . tryCreate ( logger ,    packageName ,    simpleName )  ;", "if    ( printWriter    =  =    null )     {", "return    (  ( packageName )     +     \"  .  \"  )     +     ( simpleName )  ;", "}", "sw    =    composer . createSourceWriter ( context ,    printWriter )  ;", "generateLookups (  )  ;", "forNameC (  )  ;", "newArrayC (  )  ;", "getArrayLengthT (  )  ;", "getArrayElementT (  )  ;", "setArrayElementT (  )  ;", "getF (  )  ;", "setF (  )  ;", "invokeM (  )  ;", "sw . commit ( logger )  ;", "createProxy ( type )  ;", "return    (  ( packageName )     +     \"  .  \"  )     +     ( simpleName )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "ClassSourceFileComposerFactory   composer    =    new   ClassSourceFileComposerFactory ( type . getPackage (  )  . getName (  )  ,     (  ( type . getSimpleSourceName (  )  )     +     \" Proxy \"  )  )  ;", "PrintWriter   printWriter    =    context . tryCreate ( logger ,    packageName ,    simpleName )  ;", "if    ( printWriter    =  =    null )     {", "return ;", "}", "SourceWriter   writer    =    composer . createSourceWriter ( context ,    printWriter )  ;", "writer . commit ( logger )  ;", "}", "METHOD_END"], "methodName": ["createProxy"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "buffer . setLength (  0  )  ;", "int   id    =     ( nextTypeId )  +  +  ;", "typeNames 2 typeIds . put ( t . getErasedType (  )  . getQualifiedSourceName (  )  ,    id )  ;", "JClassType   c    =    t . isClass (  )  ;", "String   name    =    t . getErasedType (  )  . getQualifiedSourceName (  )  ;", "String   superClass    =    null ;", "if    (  ( c    !  =    null )     &  &     ( isVisible ( c . getSuperclass (  )  )  )  )", "superClass    =     ( c . getSuperclass (  )  . getErasedType (  )  . getQualifiedSourceName (  )  )     +     \"  . class \"  ;", "String   assignables    =    null ;", "String   interfaces    =    null ;", "if    (  ( c    !  =    null )     &  &     (  ( c . getFlattenedSupertypeHierarchy (  )  )     !  =    null )  )     {", "assignables    =     \" new   HashSet < Class >  ( Arrays . asList (  \"  ;", "boolean   used    =    false ;", "for    ( JType   i    :    c . getFlattenedSupertypeHierarchy (  )  )     {", "if    (  (  (  !  ( isVisible ( i )  )  )     |  |     ( i . equals ( t )  )  )     |  |     (  \" Object \"  . equals ( i . getErasedType (  )  . getQualifiedSourceName (  )  )  )  )", "continue ;", "if    ( used )", "assignables    +  =     \"  ,     \"  ;", "assignables    +  =     ( i . getErasedType (  )  . getQualifiedSourceName (  )  )     +     \"  . class \"  ;", "used    =    true ;", "}", "if    ( used )", "assignables    +  =     \"  )  )  \"  ;", "else", "assignables    =    null ;", "}", "if    ( c    =  =    null )     {", "c    =    t . isInterface (  )  ;", "}", "if    (  ( c    !  =    null )     &  &     (  ( c . getImplementedInterfaces (  )  )     !  =    null )  )     {", "interfaces    =     \" new   HashSet < Class >  ( Arrays . asList (  \"  ;", "boolean   used    =    false ;", "for    ( JType   i    :    c . getImplementedInterfaces (  )  )     {", "if    (  (  !  ( isVisible ( i )  )  )     |  |     ( i . equals ( t )  )  )", "continue ;", "if    ( used )", "interfaces    +  =     \"  ,     \"  ;", "interfaces    +  =     ( i . getErasedType (  )  . getQualifiedSourceName (  )  )     +     \"  . class \"  ;", "used    =    true ;", "}", "if    ( used )", "interfaces    +  =     \"  )  )  \"  ;", "else", "interfaces    =    null ;", "}", "String   varName    =     \" c \"     +    id ;", "pb (  (  (  \" private   static   Type    \"     +    varName )     +     \"  ;  \"  )  )  ;", "pb (  (  (  \" private   static   Type    \"     +    varName )     +     \"  (  )     {  \"  )  )  ;", "pb (  (  (  (  (  \" if (  \"     +    varName )     +     \"  !  = null )    return    \"  )     +    varName )     +     \"  ;  \"  )  )  ;", "pb (  (  (  (  (  (  (  (  (  (  (  (  (  ( varName    +     \"     =    new   Type (  \\  \"  \"  )     +    name )     +     \"  \\  \"  ,     \"  )     +    id )     +     \"  ,     \"  )     +    name )     +     \"  . class ,     \"  )     +    superClass )     +     \"  ,     \"  )     +    assignables )     +     \"  ,     \"  )     +    interfaces )     +     \"  )  ;  \"  )  )  ;", "if    (  ( c    =  =    null )     &  &     (  ( t . isArray (  )  )     !  =    null )  )     {", "c    =    t . isArray (  )  ;", "}", "if    ( c    !  =    null )     {", "if    (  ( c . isEnum (  )  )     !  =    null )", "pb (  ( varName    +     \"  . isEnum    =    true ;  \"  )  )  ;", "if    (  ( c . isArray (  )  )     !  =    null )     {", "pb (  ( varName    +     \"  . isArray    =    true ;  \"  )  )  ;", "pb (  ( varName    +     \"  . isStatic    =    false ;  \"  )  )  ;", "pb (  ( varName    +     \"  . isAbstract    =    true ;  \"  )  )  ;", "} else    {", "pb (  (  (  ( varName    +     \"  . isStatic    =     \"  )     +     ( c . isStatic (  )  )  )     +     \"  ;  \"  )  )  ;", "pb (  (  (  ( varName    +     \"  . isAbstract    =     \"  )     +     ( c . isAbstract (  )  )  )     +     \"  ;  \"  )  )  ;", "}", "if    ( c . isMemberType (  )  )", "pb (  ( varName    +     \"  . isMemberClass    =    true ;  \"  )  )  ;", "if    (  ( c . isInterface (  )  )     !  =    null )", "pb (  ( varName    +     \"  . isInterface    =    true ;  \"  )  )  ;", "if    (  ( c . isAnnotation (  )  )     !  =    null )", "pb (  ( varName    +     \"  . isAnnotation    =    true ;  \"  )  )  ;", "if    (  (  ( c . getFields (  )  )     !  =    null )     &  &     (  ( c . getFields (  )  . length )     >     0  )  )     {", "pb (  ( varName    +     \"  . fields    =    new   Field [  ]     {  \"  )  )  ;", "for    ( JField   f    :    c . getFields (  )  )     {", "String   enclosingType    =    getType ( c )  ;", "String   fieldType    =    getType ( f . getType (  )  )  ;", "int   setterGetter    =     ( nextSetterGetterId )  +  +  ;", "String   elementType    =    getElementTypes ( f )  ;", "String   annotations    =    getAnnotations ( f . getDeclaredAnnotations (  )  )  ;", "pb (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"             new   Field (  \\  \"  \"     +     ( f . getName (  )  )  )     +     \"  \\  \"  ,     \"  )     +    enclosingType )     +     \"  ,     \"  )     +    fieldType )     +     \"  ,     \"  )     +     ( f . isFinal (  )  )  )     +     \"  ,     \"  )     +     ( f . isDefaultAccess (  )  )  )     +     \"  ,     \"  )     +     ( f . isPrivate (  )  )  )     +     \"  ,     \"  )     +     ( f . isProtected (  )  )  )     +     \"  ,     \"  )     +     ( f . isPublic (  )  )  )     +     \"  ,     \"  )     +     ( f . isStatic (  )  )  )     +     \"  ,     \"  )     +     ( f . isTransient (  )  )  )     +     \"  ,     \"  )     +     ( f . isVolatile (  )  )  )     +     \"  ,     \"  )     +    setterGetter )     +     \"  ,     \"  )     +    setterGetter )     +     \"  ,     \"  )     +    elementType )     +     \"  ,     \"  )     +    annotations )     +     \"  )  ,     \"  )  )  ;", ". SetterGetterStub   stub    =    new    . SetterGetterStub (  )  ;", "stub . name    =    f . getName (  )  ;", "stub . enclosingType    =    enclosingType ;", "stub . type    =    fieldType ;", "stub . isStatic    =    f . isStatic (  )  ;", "stub . isFinal    =    f . isFinal (  )  ;", "if    (  ( enclosingType    !  =    null )     &  &     ( fieldType    !  =    null )  )     {", "stub . getter    =    setterGetter ;", "stub . setter    =    setterGetter ;", "}", "setterGetterStubs . add ( stub )  ;", "}", "pb (  \"  }  ;  \"  )  ;", "}", "createTypeInvokables ( c ,    varName ,     \" Method \"  ,    c . getMethods (  )  )  ;", "if    (  (  ( c . isPublic (  )  )     &  &     (  !  ( c . isAbstract (  )  )  )  )     &  &     (  (  ( c . getEnclosingType (  )  )     =  =    null )     |  |     ( c . isStatic (  )  )  )  )     {", "createTypeInvokables ( c ,    varName ,     \" Constructor \"  ,    c . getConstructors (  )  )  ;", "} else    {", "logger . log ( INFO ,     (  ( c . getName (  )  )     +     \"    can ' t   be   instantiated .    Constructors   not   generated \"  )  )  ;", "}", "if    (  ( c . isArray (  )  )     !  =    null )     {", "pb (  (  (  ( varName    +     \"  . componentType    =     \"  )     +     ( getType ( c . isArray (  )  . getComponentType (  )  )  )  )     +     \"  ;  \"  )  )  ;", "}", "if    (  ( c . isEnum (  )  )     !  =    null )     {", "JEnumConstant [  ]    enumConstants    =    c . isEnum (  )  . getEnumConstants (  )  ;", "if    ( enumConstants    !  =    null )     {", "pb (  (  (  ( varName    +     \"  . enumConstants    =    new   Object [  \"  )     +     ( enumConstants . length )  )     +     \"  ]  ;  \"  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( enumConstants . length )  ;    i +  +  )     {", "pb (  (  (  (  (  (  (  ( varName    +     \"  . enumConstants [  \"  )     +    i )     +     \"  ]     =     \"  )     +     ( c . getErasedType (  )  . getQualifiedSourceName (  )  )  )     +     \"  .  \"  )     +     ( enumConstants [ i ]  . getName (  )  )  )     +     \"  ;  \"  )  )  ;", "}", "}", "}", "Annotation [  ]    annotations    =    c . getDeclaredAnnotations (  )  ;", "if    (  ( annotations    !  =    null )     &  &     (  ( annotations . length )     >     0  )  )     {", "pb (  (  (  ( varName    +     \"  . annotations    =     \"  )     +     ( getAnnotations ( annotations )  )  )     +     \"  ;  \"  )  )  ;", "}", "} else    {", "pb (  ( varName    +     \"  . isAbstract    =    true ;  \"  )  )  ;", "pb (  ( varName    +     \"  . isPrimitive    =    true ;  \"  )  )  ;", "}", "pb (  (  (  \" return    \"     +    varName )     +     \"  ;  \"  )  )  ;", "pb (  \"  }  \"  )  ;", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createTypeGenerator"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( methodTypes    !  =    null )     &  &     (  ( methodTypes . length )     >     0  )  )     {", "pb (  (  (  (  (  ( varName    +     \"  .  \"  )     +     ( methodType . toLowerCase (  )  )  )     +     \" s    =    new    \"  )     +    methodType )     +     \"  [  ]     {  \"  )  )  ;", "for    ( JAbstractMethod   m    :    methodTypes )     {", ". MethodStub   stub    =    new    . MethodStub (  )  ;", "stub . isPublic    =    m . isPublic (  )  ;", "stub . enclosingType    =    getType ( c )  ;", "if    (  ( m . isMethod (  )  )     !  =    null )     {", "stub . isMethod    =    true ;", "stub . returnType    =    getType ( m . isMethod (  )  . getReturnType (  )  )  ;", "stub . isStatic    =    m . isMethod (  )  . isStatic (  )  ;", "stub . isAbstract    =    m . isMethod (  )  . isAbstract (  )  ;", "stub . isNative    =    m . isMethod (  )  . isAbstract (  )  ;", "stub . isFinal    =    m . isMethod (  )  . isFinal (  )  ;", "} else    {", "if    (  ( m . isPrivate (  )  )     |  |     ( m . isDefaultAccess (  )  )  )     {", "logger . log ( INFO ,     (  \" Skipping   non - visible   constructor   for   class    \"     +     ( c . getName (  )  )  )  )  ;", "continue ;", "}", "if    (  ( m . getEnclosingType (  )  . isFinal (  )  )     &  &     (  !  ( m . isPublic (  )  )  )  )     {", "logger . log ( INFO ,     (  \" Skipping   non - public   constructor   for   final   class \"     +     ( c . getName (  )  )  )  )  ;", "continue ;", "}", "stub . isConstructor    =    true ;", "stub . returnType    =    stub . enclosingType ;", "}", "stub . jnsi    =     \"  \"  ;", "stub . methodId    =     ( nextInvokableId )  +  +  ;", "stub . name    =    m . getName (  )  ;", "methodStubs . add ( stub )  ;", "pbn (  (  (  (  (  \"             new    \"     +    methodType )     +     \"  (  \\  \"  \"  )     +     ( m . getName (  )  )  )     +     \"  \\  \"  ,     \"  )  )  ;", "pbn (  (  ( stub . enclosingType )     +     \"  ,     \"  )  )  ;", "pbn (  (  ( stub . returnType )     +     \"  ,     \"  )  )  ;", "if    (  (  ( m . getParameters (  )  )     !  =    null )     &  &     (  ( m . getParameters (  )  . length )     >     0  )  )     {", "pbn (  \" new   Parameter [  ]     {  \"  )  ;", "for    ( JParameter   p    :    m . getParameters (  )  )     {", "stub . parameterTypes . add ( getType ( p . getType (  )  )  )  ;", "stub . jnsi    +  =    p . getType (  )  . getErasedType (  )  . getJNISignature (  )  ;", "String   paramName    =     (  (  ( p . getName (  )  )     +     \"  _  _  \"  )     +     ( p . getType (  )  . getErasedType (  )  . getJNISignature (  )  )  )  . replaceAll (  \"  [  /  ;  \\  \\  [  \\  \\  ]  ]  \"  ,     \"  _  \"  )  ;", "String   paramInstantiation    =     (  (  (  (  (  \" new   Parameter (  \\  \"  \"     +     ( p . getName (  )  )  )     +     \"  \\  \"  ,     \"  )     +     ( getType ( p . getType (  )  )  )  )     +     \"  ,     \\  \"  \"  )     +     ( p . getType (  )  . getJNISignature (  )  )  )     +     \"  \\  \"  )  \"  ;", "parameterName 2 ParameterInstantiation . put ( paramName ,    paramInstantiation )  ;", "pbn (  ( paramName    +     \"  (  )  ,     \"  )  )  ;", "}", "pbn (  \"  }  ,     \"  )  ;", "} else    {", "pbn (  \" EMPTY _ PARAMETERS ,  \"  )  ;", "}", "pb (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  ( stub . isAbstract )     +     \"  ,     \"  )     +     ( stub . isFinal )  )     +     \"  ,     \"  )     +     ( stub . isStatic )  )     +     \"  ,     \"  )     +     ( m . isDefaultAccess (  )  )  )     +     \"  ,     \"  )     +     ( m . isPrivate (  )  )  )     +     \"  ,     \"  )     +     ( m . isProtected (  )  )  )     +     \"  ,     \"  )     +     ( m . isPublic (  )  )  )     +     \"  ,     \"  )     +     ( stub . isNative )  )     +     \"  ,     \"  )     +     ( m . isVarArgs (  )  )  )     +     \"  ,     \"  )     +     ( stub . isMethod )  )     +     \"  ,     \"  )     +     ( stub . isConstructor )  )     +     \"  ,     \"  )     +     ( stub . methodId )  )     +     \"  ,  \"  )     +     ( getAnnotations ( m . getDeclaredAnnotations (  )  )  )  )     +     \"  )  ,  \"  )  )  ;", "}", "pb (  \"  }  ;  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["createTypeInvokables"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "p (  \" public   Type   forName ( String   name )     {  \"  )  ;", "p (  \"             int   hashCode    =    name . hashCode (  )  ;  \"  )  ;", "int   i    =     0  ;", ". SwitchedCodeBlockByString   cb    =    new    . SwitchedCodeBlockByString (  \" hashCode \"  ,     \" name \"  )  ;", "for    ( String   typeName    :    typeNames 2 typeIds . keySet (  )  )     {", "cb . add ( typeName ,     (  (  \" return   c \"     +     ( typeNames 2 typeIds . get ( typeName )  )  )     +     \"  (  )  ;  \"  )  )  ;", "i +  +  ;", "if    (  ( i    %     1  0  0  0  )     =  =     0  )     {", "cb . print (  )  ;", "cb    =    new    . SwitchedCodeBlockByString (  \" hashCode \"  ,     \" name \"  )  ;", "p (  (  (  \"             return   forName \"     +    i )     +     \"  ( name ,    hashCode )  ;  \"  )  )  ;", "p (  \"  }  \"  )  ;", "p (  (  (  \" private   Type   forName \"     +    i )     +     \"  ( String   name ,    int   hashCode )     {  \"  )  )  ;", "}", "}", "cb . print (  )  ;", "p (  \"             return   null ;  \"  )  ;", "p (  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["forNameC"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "( nesting )  +  +  ;", "if    ( type    =  =    null )     {", "( nesting )  -  -  ;", "return ;", "}", "if    ( type . getQualifiedName (  )  . contains (  \"  -  \"  )  )     {", "( nesting )  -  -  ;", "return ;", "}", "if    (  !  ( isVisible ( type )  )  )     {", "( nesting )  -  -  ;", "return ;", "}", "boolean   keep    =    false ;", "String   name    =    type . getQualifiedName (  )  ;", "try    {", "ConfigurationProperty   prop ;", "keep    |  =     !  ( name . contains (  \"  .  \"  )  )  ;", "prop    =    context . getPropertyOracle (  )  . getConfigurationProperty (  \" gdx . reflect . include \"  )  ;", "for    ( String   s    :    prop . getValues (  )  )", "keep    |  =    name . contains ( s )  ;", "prop    =    context . getPropertyOracle (  )  . getConfigurationProperty (  \" gdx . reflect . exclude \"  )  ;", "for    ( String   s    :    prop . getValues (  )  )", "keep    &  =     !  ( name . equals ( s )  )  ;", "}    catch    ( BadPropertyValueException   e )     {", "e . printStackTrace (  )  ;", "}", "if    (  ! keep )     {", "( nesting )  -  -  ;", "return ;", "}", "if    ( types . contains ( type . getErasedType (  )  )  )     {", "( nesting )  -  -  ;", "return ;", "}", "types . add ( type . getErasedType (  )  )  ;", "out ( type . getErasedType (  )  . getQualifiedName (  )  ,    nesting )  ;", "if    ( type   instanceof   JPrimitiveType )     {", "( nesting )  -  -  ;", "return ;", "} else    {", "JClassType   c    =     (  ( JClassType )     ( type )  )  ;", "JField [  ]    fields    =    c . getFields (  )  ;", "if    ( fields    !  =    null )     {", "for    ( JField   field    :    fields )     {", "gatherTypes ( field . getType (  )  . getErasedType (  )  ,    types )  ;", "}", "}", "gatherTypes ( c . getSuperclass (  )  ,    types )  ;", "JClassType [  ]    interfaces    =    c . getImplementedInterfaces (  )  ;", "if    ( interfaces    !  =    null )     {", "for    ( JClassType   i    :    interfaces )     {", "gatherTypes ( i . getErasedType (  )  ,    types )  ;", "}", "}", "JMethod [  ]    methods    =    c . getMethods (  )  ;", "if    ( methods    !  =    null )     {", "for    ( JMethod   m    :    methods )     {", "gatherTypes ( m . getReturnType (  )  . getErasedType (  )  ,    types )  ;", "if    (  ( m . getParameterTypes (  )  )     !  =    null )     {", "for    ( JType   p    :    m . getParameterTypes (  )  )     {", "gatherTypes ( p . getErasedType (  )  ,    types )  ;", "}", "}", "}", "}", "JClassType [  ]    inner    =    c . getNestedTypes (  )  ;", "if    ( inner    !  =    null )     {", "for    ( JClassType   i    :    inner )     {", "gatherTypes ( i . getErasedType (  )  ,    types )  ;", "}", "}", "}", "( nesting )  -  -  ;", "}", "METHOD_END"], "methodName": ["gatherTypes"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "TypeOracle   typeOracle    =    context . getTypeOracle (  )  ;", "JPackage [  ]    packages    =    typeOracle . getPackages (  )  ;", "for    ( JPackage   p    :    packages )     {", "for    ( JClassType   t    :    p . getTypes (  )  )     {", "gatherTypes ( t . getErasedType (  )  ,    types )  ;", "}", "}", "try    {", "ConfigurationProperty   prop    =    context . getPropertyOracle (  )  . getConfigurationProperty (  \" gdx . reflect . include \"  )  ;", "for    ( String   s    :    prop . getValues (  )  )     {", "JClassType   type    =    typeOracle . findType ( s )  ;", "if    ( type    !  =    null )", "gatherTypes ( type . getErasedType (  )  ,    types )  ;", "}", "}    catch    ( BadPropertyValueException   e )     {", "}", "gatherTypes ( typeOracle . findType (  \" List \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" ArrayList \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" HashMap \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Map \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" String \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Boolean \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Byte \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Long \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Character \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Short \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Integer \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Float \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" CharSequence \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Double \"  )  . getErasedType (  )  ,    types )  ;", "gatherTypes ( typeOracle . findType (  \" Object \"  )  . getErasedType (  )  ,    types )  ;", "Collections . sort ( types ,    new   Comparator < JType >  (  )     {", "public   int   compare ( JType   o 1  ,    JType   o 2  )     {", "return   o 1  . getQualifiedSourceName (  )  . compareTo ( o 2  . getQualifiedSourceName (  )  )  ;", "}", "}  )  ;", "for    ( JType   t    :    types )     {", "p ( createTypeGenerator ( t )  )  ;", "}", "parameterInitialization (  )  ;", "Collections . sort ( setterGetterStubs ,    new   Comparator <  . SetterGetterStub >  (  )     {", "@ Override", "public   int   compare (  . SetterGetterStub   o 1  ,     . SetterGetterStub   o 2  )     {", "return   new   Integer ( o 1  . setter )  . compareTo ( o 2  . setter )  ;", "}", "}  )  ;", "for    (  . SetterGetterStub   stub    :    setterGetterStubs )     {", "String   stubSource    =    generateSetterGetterStub ( stub )  ;", "if    ( stubSource . equals (  \"  \"  )  )", "stub . unused    =    true ;", "p ( stubSource )  ;", "}", "Collections . sort ( methodStubs ,    new   Comparator <  . MethodStub >  (  )     {", "@ Override", "public   int   compare (  . MethodStub   o 1  ,     . MethodStub   o 2  )     {", "return   new   Integer ( o 1  . methodId )  . compareTo ( o 2  . methodId )  ;", "}", "}  )  ;", "for    (  . MethodStub   stub    :    methodStubs )     {", "String   stubSource    =    generateMethodStub ( stub )  ;", "if    ( stubSource . equals (  \"  \"  )  )", "stub . unused    =    true ;", "p ( stubSource )  ;", "}", "logger . log ( INFO ,     (  ( types . size (  )  )     +     \"    types   reflected \"  )  )  ;", "}", "METHOD_END"], "methodName": ["generateLookups"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "buffer . setLength (  0  )  ;", "if    (  ( stub . enclosingType )     =  =    null )     {", "ger .  ( INFO ,     (  (  \" method    '  \"     +     ( stub . name )  )     +     \"  '    of   invisible   class   is   not   invokable \"  )  )  ;", "return    \"  \"  ;", "}", "if    (  (  ( stub . enclosingType . startsWith (  \" java \"  )  )     &  &     (  !  ( stub . enclosingType . startsWith (  \" util \"  )  )  )  )     |  |     ( stub . enclosingType . contains (  \" google \"  )  )  )     {", "ger .  ( INFO ,     (  (  (  (  \" not   emitting   code   for   accessing   method    \"     +     ( stub . name )  )     +     \"    in   class    '  \"  )     +     ( stub . enclosingType )  )     +     \"  ,    either   in   *    or   GWT   related   class \"  )  )  ;", "return    \"  \"  ;", "}", "if    ( stub . enclosingType . contains (  \"  [  ]  \"  )  )     {", "ger .  ( INFO ,     (  (  (  (  \" method    '  \"     +     ( stub . name )  )     +     \"  '    of   class    '  \"  )     +     ( stub . enclosingType )  )     +     \"  '    is   not   invokable   because   the   class   is   an   array   type \"  )  )  ;", "return    \"  \"  ;", "}", "for    ( int   i    =     0  ;    i    <     ( stub . parameterTypes . size (  )  )  ;    i +  +  )     {", "String   paramType    =    stub . parameterTypes . get ( i )  ;", "if    ( paramType    =  =    null )     {", "ger .  ( INFO ,     (  (  (  (  \" method    '  \"     +     ( stub . name )  )     +     \"  '    of   class    '  \"  )     +     ( stub . enclosingType )  )     +     \"  '    is   not   invokable   because   one   of   its   argument   types   is   not   visible \"  )  )  ;", "return    \"  \"  ;", "} else", "if    (  ( paramType . startsWith (  \" long \"  )  )     |  |     ( paramType . contains (  \" Long \"  )  )  )     {", "ger .  ( INFO ,     (  (  (  (  \" method    '  \"     +     ( stub . name )  )     +     \"  '    of   class    '  \"  )     +     ( stub . enclosingType )  )     +     \"    has   long   parameter ,    prohibited   in   JSNI \"  )  )  ;", "return    \"  \"  ;", "} else    {", "stub . parameterTypes . set ( i ,    paramType . replace (  \"  . class \"  ,     \"  \"  )  )  ;", "}", "}", "if    (  ( stub . returnType )     =  =    null )     {", "ger .  ( INFO ,     (  (  (  (  \" method    '  \"     +     ( stub . name )  )     +     \"  '    of   class    '  \"  )     +     ( stub . enclosingType )  )     +     \"  '    is   not   invokable   because   its   return   type   is   not   visible \"  )  )  ;", "return    \"  \"  ;", "}", "if    (  ( stub . returnType . startsWith (  \" long \"  )  )     |  |     ( stub . returnType . contains (  \" Long \"  )  )  )     {", "ger .  ( INFO ,     (  (  (  (  \" method    '  \"     +     ( stub . name )  )     +     \"  '    of   class    '  \"  )     +     ( stub . enclosingType )  )     +     \"    has   long   return   type ,    prohibited   in   JSNI \"  )  )  ;", "return    \"  \"  ;", "}", "stub . enclosingType    =    stub . enclosingType . replace (  \"  . class \"  ,     \"  \"  )  ;", "stub . returnType    =    stub . returnType . replace (  \"  . class \"  ,     \"  \"  )  ;", "if    ( stub . isMethod )     {", "boolean   isVoid    =    stub . returnType . equals (  \" void \"  )  ;", "pbn (  (  (  (  (  \" private   native    \"     +     ( isVoid    ?     \" Object \"     :    stub . returnType )  )     +     \"    m \"  )     +     ( stub . methodId )  )     +     \"  (  \"  )  )  ;", "if    (  !  ( stub . isStatic )  )", "pbn (  (  (  ( stub . enclosingType )     +     \"    obj \"  )     +     (  ( stub . parameterTypes . size (  )  )     >     0     ?     \"  ,     \"     :     \"  \"  )  )  )  ;", "int   i    =     0  ;", "for    ( String   paramType    :    stub . parameterTypes )     {", "pbn (  (  (  ( paramType    +     \"    p \"  )     +    i )     +     ( i    <     (  ( stub . parameterTypes . size (  )  )     -     1  )     ?     \"  ,  \"     :     \"  \"  )  )  )  ;", "i +  +  ;", "}", "pbn (  \"  )     /  *  -  {  \"  )  ;", "if    (  ! isVoid )", "pbn (  \" return    \"  )  ;", "if    ( stub . isStatic )", "pbn (  (  (  (  (  (  (  \"  @  \"     +     ( stub . enclosingType )  )     +     \"  :  :  \"  )     +     ( stub . name )  )     +     \"  (  \"  )     +     ( stub . jnsi )  )     +     \"  )  (  \"  )  )  ;", "else", "pbn (  (  (  (  (  (  (  \" obj .  @  \"     +     ( stub . enclosingType )  )     +     \"  :  :  \"  )     +     ( stub . name )  )     +     \"  (  \"  )     +     ( stub . jnsi )  )     +     \"  )  (  \"  )  )  ;", "for    ( i    =     0  ;    i    <     ( stub . parameterTypes . size (  )  )  ;    i +  +  )     {", "pbn (  (  (  \" p \"     +    i )     +     ( i    <     (  ( stub . parameterTypes . size (  )  )     -     1  )     ?     \"  ,     \"     :     \"  \"  )  )  )  ;", "}", "pbn (  \"  )  ;  \"  )  ;", "if    ( isVoid )", "pbn (  \" return   null ;  \"  )  ;", "pbn (  \"  }  -  *  /  ;  \"  )  ;", "} else    {", "pbn (  (  (  (  (  \" private   static    \"     +     ( stub . returnType )  )     +     \"    m \"  )     +     ( stub . methodId )  )     +     \"  (  \"  )  )  ;", "int   i    =     0  ;", "for    ( String   paramType    :    stub . parameterTypes )     {", "pbn (  (  (  ( paramType    +     \"    p \"  )     +    i )     +     ( i    <     (  ( stub . parameterTypes . size (  )  )     -     1  )     ?     \"  ,  \"     :     \"  \"  )  )  )  ;", "i +  +  ;", "}", "pbn (  \"  )     {  \"  )  ;", "pbn (  (  (  \" return   new    \"     +     ( stub . returnType )  )     +     \"  (  \"  )  )  ;", "for    ( i    =     0  ;    i    <     ( stub . parameterTypes . size (  )  )  ;    i +  +  )     {", "pbn (  (  (  \" p \"     +    i )     +     ( i    <     (  ( stub . parameterTypes . size (  )  )     -     1  )     ?     \"  ,     \"     :     \"  \"  )  )  )  ;", "}", "pbn (  \"  )  \"  )  ;", "if    (  !  ( stub . isPublic )  )     {", "pbn (  \"  {  }  \"  )  ;", "}", "pbn (  \"  ;  \"  )  ;", "pbn (  \"  }  \"  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateMethodStub"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "buffer . setLength (  0  )  ;", "if    (  (  ( stub . enclosingType )     =  =    null )     |  |     (  ( stub . type )     =  =    null )  )     {", "ger .  ( INFO ,     (  (  (  (  (  (  \" field    '  \"     +     ( stub . name )  )     +     \"  '    in   class    '  \"  )     +     ( stub . enclosingType )  )     +     \"  '    is   not   accessible   as   its   type    '  \"  )     +     ( stub . type )  )     +     \"  '    is   not   public \"  )  )  ;", "return    \"  \"  ;", "}", "if    (  ( stub . enclosingType . startsWith (  \" java \"  )  )     |  |     ( stub . enclosingType . contains (  \" google \"  )  )  )     {", "ger .  ( INFO ,     (  (  (  (  \" not   emitting   code   for   accessing   field    \"     +     ( stub . name )  )     +     \"    in   class    '  \"  )     +     ( stub . enclosingType )  )     +     \"  ,    either   in   *    or   GWT   related   class \"  )  )  ;", "return    \"  \"  ;", "}", "if    (  ( stub . type . startsWith (  \" long \"  )  )     |  |     ( stub . type . contains (  \" Long \"  )  )  )     {", "ger .  ( INFO ,     (  (  (  (  \" not   emitting   code   for   accessing   field    \"     +     ( stub . name )  )     +     \"    in   class    '  \"  )     +     ( stub . enclosingType )  )     +     \"    as   its   of   type   long   which   can ' t   be   used   with   JSNI \"  )  )  ;", "return    \"  \"  ;", "}", "stub . enclosingType    =    stub . enclosingType . replace (  \"  . class \"  ,     \"  \"  )  ;", "stub . type    =    stub . type . replace (  \"  . class \"  ,     \"  \"  )  ;", "pbn (  (  (  (  (  (  (  \" private   native    \"     +     ( stub . type )  )     +     \"    g \"  )     +     ( stub . getter )  )     +     \"  (  \"  )     +     ( stub . enclosingType )  )     +     \"    obj )     /  *  -  {  \"  )  )  ;", "if    ( stub . isStatic )", "pbn (  (  (  (  (  \" return    @  \"     +     ( stub . enclosingType )  )     +     \"  :  :  \"  )     +     ( stub . name )  )     +     \"  ;  \"  )  )  ;", "else", "pbn (  (  (  (  (  \" return   obj .  @  \"     +     ( stub . enclosingType )  )     +     \"  :  :  \"  )     +     ( stub . name )  )     +     \"  ;  \"  )  )  ;", "pb (  \"  }  -  *  /  ;  \"  )  ;", "if    (  !  ( stub . isFinal )  )     {", "pbn (  (  (  (  (  (  (  \" private   native   void   s \"     +     ( stub . setter )  )     +     \"  (  \"  )     +     ( stub . enclosingType )  )     +     \"    obj ,     \"  )     +     ( stub . type )  )     +     \"    value )        /  *  -  {  \"  )  )  ;", "if    ( stub . isStatic )", "pbn (  (  (  (  (  \"  @  \"     +     ( stub . enclosingType )  )     +     \"  :  :  \"  )     +     ( stub . name )  )     +     \"     =    value \"  )  )  ;", "else", "pbn (  (  (  (  (  \" obj .  @  \"     +     ( stub . enclosingType )  )     +     \"  :  :  \"  )     +     ( stub . name )  )     +     \"     =    value ;  \"  )  )  ;", "pb (  \"  }  -  *  /  ;  \"  )  ;", "}", "return   buffer . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateSetterGetterStub"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( annotations    !  =    null )     &  &     (  ( annotations . length )     >     0  )  )     {", "int   numValidAnnotations    =     0  ;", "final   Class <  ?  >  [  ]    ignoredAnnotations    =    new   Class <  ?  >  [  ]  {    Deprecated . class ,    Retention . class    }  ;", "StringBuilder   b    =    new   StringBuilder (  )  ;", "b . append (  \" new   Annotation [  ]     {  \"  )  ;", "for    ( Annotation   annotation    :    annotations )     {", "Class <  ?  >    type    =    annotation . annotationType (  )  ;", "boolean   ignoredType    =    false ;", "for    ( int   i    =     0  ;     (  ! ignoredType )     &  &     ( i    <     ( ignoredAnnotations . length )  )  ;    i +  +  )     {", "ignoredType    =    ignoredAnnotations [ i ]  . equals ( type )  ;", "}", "if    ( ignoredType )     {", "continue ;", "}", "Retention   retention    =    type . getAnnotation ( Retention . class )  ;", "if    (  ( retention    =  =    null )     |  |     (  ( retention . value (  )  )     !  =     ( RetentionPolicy . RUNTIME )  )  )     {", "continue ;", "}", "numValidAnnotations +  +  ;", "b . append (  \"    new    \"  )  . append ( type . getCanonicalName (  )  )  . append (  \"  (  )     {  \"  )  ;", "Method [  ]    methods    =    type . getDeclaredMethods (  )  ;", "for    ( Method   method    :    methods )     {", "Class <  ?  >    returnType    =    method . getReturnType (  )  ;", "b . append (  \"     @ Override   public \"  )  ;", "b . append (  \"     \"  )  . append ( returnType . getCanonicalName (  )  )  ;", "b . append (  \"     \"  )  . append ( method . getName (  )  )  . append (  \"  (  )     {    return \"  )  ;", "if    ( returnType . isArray (  )  )     {", "b . append (  \"    new    \"  )  . append ( returnType . getCanonicalName (  )  )  . append (  \"     {  \"  )  ;", "}", "Object   invokeResult    =    null ;", "try    {", "invokeResult    =    method . invoke ( annotation )  ;", "}    catch    ( IllegalAccessException   e )     {", "logger . log ( ERROR ,     \" Error   invoking   annotation   method .  \"  )  ;", "}    catch    ( InvocationTargetException   e )     {", "logger . log ( ERROR ,     \" Error   invoking   annotation   method .  \"  )  ;", "}", "if    ( invokeResult    !  =    null )     {", "if    ( returnType . equals ( String [  ]  . class )  )     {", "for    ( String   s    :     (  ( String [  ]  )     ( invokeResult )  )  )     {", "b . append (  \"     \\  \"  \"  )  . append ( s )  . append (  \"  \\  \"  ,  \"  )  ;", "}", "} else", "if    ( returnType . equals ( String . class )  )     {", "b . append (  \"     \\  \"  \"  )  . append (  (  ( String )     ( invokeResult )  )  )  . append (  \"  \\  \"  \"  )  ;", "} else", "if    ( returnType . equals ( Class [  ]  . class )  )     {", "for    ( Class   c    :     (  ( Class [  ]  )     ( invokeResult )  )  )     {", "b . append (  \"     \"  )  . append ( c . getCanonicalName (  )  )  . append (  \"  . class ,  \"  )  ;", "}", "} else", "if    ( returnType . equals ( Class . class )  )     {", "b . append (  \"     \"  )  . append (  (  ( Class )     ( invokeResult )  )  . getCanonicalName (  )  )  . append (  \"  . class \"  )  ;", "} else", "if    (  ( returnType . isArray (  )  )     &  &     ( returnType . getComponentType (  )  . isEnum (  )  )  )     {", "String   enumTypeName    =    returnType . getComponentType (  )  . getCanonicalName (  )  ;", "int   length    =    getLength ( invokeResult )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "Object   e    =    get ( invokeResult ,    i )  ;", "b . append (  \"     \"  )  . append ( enumTypeName )  . append (  \"  .  \"  )  . append ( e . toString (  )  )  . append (  \"  ,  \"  )  ;", "}", "} else", "if    ( returnType . isEnum (  )  )     {", "b . append (  \"     \"  )  . append ( returnType . getCanonicalName (  )  )  . append (  \"  .  \"  )  . append ( invokeResult . toString (  )  )  ;", "} else", "if    (  ( returnType . isArray (  )  )     &  &     ( returnType . getComponentType (  )  . isPrimitive (  )  )  )     {", "Class <  ?  >    primitiveType    =    returnType . getComponentType (  )  ;", "int   length    =    getLength ( invokeResult )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "Object   n    =    get ( invokeResult ,    i )  ;", "b . append (  \"     \"  )  . append ( n . toString (  )  )  ;", "if    ( primitiveType . equals ( float . class )  )     {", "b . append (  \" f \"  )  ;", "}", "b . append (  \"  ,  \"  )  ;", "}", "} else", "if    ( returnType . isPrimitive (  )  )     {", "b . append (  \"     \"  )  . append ( invokeResult . toString (  )  )  ;", "if    ( returnType . equals ( float . class )  )     {", "b . append (  \" f \"  )  ;", "}", "} else    {", "logger . log ( ERROR ,     \" Return   type   not   supported    ( or   not   yet   implemented )  .  \"  )  ;", "}", "}", "if    ( returnType . isArray (  )  )     {", "b . append (  \"     }  \"  )  ;", "}", "b . append (  \"  ;     \"  )  ;", "b . append (  \"  }  \"  )  ;", "}", "b . append (  \"     @ Override   public   Class <  ?    extends   Annotation >    annotationType (  )     {    return    \"  )  ;", "b . append ( type . getCanonicalName (  )  )  ;", "b . append (  \"  . class ;     }  \"  )  ;", "b . append (  \"  }  ,     \"  )  ;", "}", "b . append (  \"  }  \"  )  ;", "return   numValidAnnotations    >     0     ?    b . toString (  )     :     \" null \"  ;", "}", "return    \" null \"  ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "p (  \" public   Object   getArrayElement ( Type   type ,    Object   obj ,    int   i )     {  \"  )  ;", ". SwitchedCodeBlock   pc    =    new    . SwitchedCodeBlock (  \" type . id \"  )  ;", "for    ( String   s    :     . PRIMITIVE _ TYPES )     {", "if    (  !  ( typeNames 2 typeIds . containsKey (  ( s    +     \"  [  ]  \"  )  )  )  )", "continue ;", "pc . add ( typeNames 2 typeIds . get (  ( s    +     \"  [  ]  \"  )  )  ,     (  (  \" return    (  (  \"     +    s )     +     \"  [  ]  ) obj )  [ i ]  ;  \"  )  )  ;", "}", "pc . print (  )  ;", "p (  \"  \t return    (  ( Object [  ]  ) obj )  [ i ]  ;  \"  )  ;", "p (  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["getArrayElementT"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "p (  \" public   int   getArrayLength ( Type   type ,    Object   obj )     {  \"  )  ;", ". SwitchedCodeBlock   pc    =    new    . SwitchedCodeBlock (  \" type . id \"  )  ;", "for    ( String   s    :     . PRIMITIVE _ TYPES )     {", "if    (  !  ( typeNames 2 typeIds . containsKey (  ( s    +     \"  [  ]  \"  )  )  )  )", "continue ;", "pc . add ( typeNames 2 typeIds . get (  ( s    +     \"  [  ]  \"  )  )  ,     (  (  \" return    (  (  \"     +    s )     +     \"  [  ]  ) obj )  . length ;  \"  )  )  ;", "}", "pc . print (  )  ;", "p (  \"  \t return    (  ( Object [  ]  ) obj )  . length ;  \"  )  ;", "p (  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["getArrayLengthT"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   b    =    new   StringBuilder (  )  ;", "JParameterizedType   params    =    f . getType (  )  . isParameterized (  )  ;", "if    ( params    !  =    null )     {", "JClassType [  ]    typeArgs    =    params . getTypeArgs (  )  ;", "b . append (  \" new   Class [  ]     {  \"  )  ;", "for    ( JClassType   typeArg    :    typeArgs )     {", "if    (  ( typeArg . isWildcard (  )  )     !  =    null )", "b . append (  \" null \"  )  ;", "else", "if    (  !  ( isVisible ( typeArg )  )  )", "b . append (  \" null \"  )  ;", "else", "if    (  ( typeArg . isClassOrInterface (  )  )     !  =    null )", "b . append ( typeArg . isClassOrInterface (  )  . getQualifiedName (  )  )  . append (  \"  . class \"  )  ;", "else", "if    (  ( typeArg . isParameterized (  )  )     !  =    null )", "b . append ( typeArg . isParameterized (  )  . getQualifiedBinaryName (  )  )  . append (  \"  . class \"  )  ;", "else", "b . append (  \" null \"  )  ;", "b . append (  \"  ,     \"  )  ;", "}", "b . append (  \"  }  \"  )  ;", "return   b . toString (  )  ;", "}", "return    \" null \"  ;", "}", "METHOD_END"], "methodName": ["getElementTypes"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "p (  \" public   Object   get ( Field   field ,    Object   obj )    throws   IllegalAccessException    {  \"  )  ;", ". SwitchedCodeBlock   pc    =    new    . SwitchedCodeBlock (  \" field . getter \"  )  ;", "for    (  . SetterGetterStub   stub    :    setterGetterStubs )     {", "if    (  (  (  ( stub . enclosingType )     =  =    null )     |  |     (  ( stub . type )     =  =    null )  )     |  |     ( stub . unused )  )", "continue ;", "pc . add ( stub . getter ,     (  (  (  (  \" return   g \"     +     ( stub . getter )  )     +     \"  (  \"  )     +     ( cast ( stub . enclosingType ,     \" obj \"  )  )  )     +     \"  )  ;  \"  )  )  ;", "}", "pc . print (  )  ;", "p (  \"          throw   new   IllegalArgumentException (  \\  \" Missing   getter - stub    \\  \"     +    field . getter    +     \\  \"    for   field    \\  \"     +    field . name )  ;  \"  )  ;", "p (  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["getF"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isVisible ( type )  )  )", "return   null ;", "return    ( type . getErasedType (  )  . getQualifiedName (  )  )     +     \"  . class \"  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "composer . addImport (  \" AccessControlException \"  )  ;", "composer . addImport (  \" *  \"  )  ;", "composer . addImport (  \" client .  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["imports"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "p (  \" public   Object   invoke ( Method   m ,    Object   obj ,    Object [  ]    params )     {  \"  )  ;", ". SwitchedCodeBlock   pc    =    new    . SwitchedCodeBlock (  \" m . methodId \"  )  ;", "int   subN    =     0  ;", "int   nDispatch    =     0  ;", "for    (  . MethodStub   stub    :    methodStubs )     {", "if    (  ( stub . enclosingType )     =  =    null )", "continue ;", "if    ( stub . enclosingType . contains (  \"  [  ]  \"  )  )", "continue ;", "if    (  ( stub . returnType )     =  =    null )", "continue ;", "if    ( stub . unused )", "continue ;", "boolean   paramsOk    =    true ;", "for    ( String   paramType    :    stub . parameterTypes )     {", "if    ( paramType    =  =    null )     {", "paramsOk    =    false ;", "break ;", "}", "}", "if    (  ! paramsOk )", "continue ;", "buffer . setLength (  0  )  ;", "pbn (  (  (  \" return   m \"     +     ( stub . methodId )  )     +     \"  (  \"  )  )  ;", "addParameters ( stub )  ;", "pbn (  \"  )  ;  \"  )  ;", "pc . add ( stub . methodId ,    buffer . toString (  )  )  ;", "nDispatch +  +  ;", "if    ( nDispatch    >     1  0  0  0  )     {", "pc . print (  )  ;", "pc    =    new    . SwitchedCodeBlock (  \" m . methodId \"  )  ;", "subN +  +  ;", "p (  (  (  \"          return   invoke \"     +    subN )     +     \"  ( m ,    obj ,    params )  ;  \"  )  )  ;", "p (  \"  }  \"  )  ;", "p (  (  (  \" public   Object   invoke \"     +    subN )     +     \"  ( Method   m ,    Object   obj ,    Object [  ]    params )     {  \"  )  )  ;", "nDispatch    =     0  ;", "}", "}", "pc . print (  )  ;", "p (  \"          throw   new   IllegalArgumentException (  \\  \" Missing   method - stub    \\  \"     +    m . methodId    +     \\  \"    for   method    \\  \"     +    m . name )  ;  \"  )  ;", "p (  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeM"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( t . isDefaultInstantiable (  )  )  )     |  |     ( t   instanceof   JArrayType )  )     |  |     ( t   instanceof   JEnumType )  )", "return   false ;", "try    {", "JConstructor   constructor    =    t . getConstructor ( new   JType [  0  ]  )  ;", "return    ( constructor    !  =    null )     &  &     ( constructor . isPublic (  )  )  ;", "}    catch    ( NotFoundExcep   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isInstantiableWithNewOperator"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )", "return   false ;", "if    ( type   instanceof   JClassType )     {", "if    ( type   instanceof   JArrayType )     {", "JType   ponentType    =     (  ( JArrayType )     ( type )  )  . getComponentType (  )  ;", "while    ( ponentType   instanceof   JArrayType )     {", "ponentType    =     (  ( JArrayType )     ( ponentType )  )  . getComponentType (  )  ;", "}", "if    ( ponentType   instanceof   JClassType )     {", "return    (  ( JClassType )     ( ponentType )  )  . isPublic (  )  ;", "}", "} else    {", "return    (  ( JClassType )     ( type )  )  . isPublic (  )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "p (  \" public   Object   newArray    ( Type   t ,    int   size )     {  \"  )  ;", "p (  \"             if    ( t    !  =    null )     {  \"  )  ;", ". SwitchedCodeBlock   pc    =    new    . SwitchedCodeBlock (  \" t . id \"  )  ;", "for    ( JType   type    :    types )     {", "if    ( type . getQualifiedSourceName (  )  . equals (  \" void \"  )  )", "continue ;", "if    ( type . getQualifiedSourceName (  )  . endsWith (  \" Void \"  )  )", "continue ;", "String   arrayType    =     ( type . getErasedType (  )  . getQualifiedSourceName (  )  )     +     \"  [ size ]  \"  ;", "if    ( arrayType . contains (  \"  [  ]  \"  )  )     {", "arrayType    =    type . getErasedType (  )  . getQualifiedSourceName (  )  ;", "arrayType    =     ( arrayType . replaceFirst (  \"  \\  \\  [  \\  \\  ]  \"  ,     \"  [ size ]  \"  )  )     +     \"  [  ]  \"  ;", "}", "pc . add ( typeNames 2 typeIds . get ( type . getQualifiedSourceName (  )  )  ,     (  (  \" return   new    \"     +    arrayType )     +     \"  ;  \"  )  )  ;", "}", "pc . print (  )  ;", "p (  \"              }  \"  )  ;", "p (  \"             throw   new   RuntimeException (  \\  \" Couldn \\  ' t   create   array \\  \"  )  ;  \"  )  ;", "p (  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["newArrayC"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    nesting ;    i +  +  )", "System . out . print (  \"        \"  )  ;", "System . out . println ( message )  ;", "}", "METHOD_END"], "methodName": ["out"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "sw . println ( line )  ;", "s . append ( line )  ;", "s . append (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["p"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "p (  \" private   static   final   Parameter [  ]    EMPTY _ PARAMETERS    =    new   Parameter [  0  ]  ;  \"  )  ;", "for    ( Map . Entry < String ,    String >    e    :    parameterName 2 ParameterInstantia . entrySet (  )  )     {", "p (  (  (  \" private   static   Parameter    \"     +     ( e . getKey (  )  )  )     +     \"  ;  \"  )  )  ;", "p (  (  (  \" private   static   Parameter    \"     +     ( e . getKey (  )  )  )     +     \"  (  )     {  \"  )  )  ;", "p (  (  (  (  (  \"             if    (  \"     +     ( e . getKey (  )  )  )     +     \"     !  =    null )    return    \"  )     +     ( e . getKey (  )  )  )     +     \"  ;  \"  )  )  ;", "p (  (  (  (  (  \"             return    \"     +     ( e . getKey (  )  )  )     +     \"     =     \"  )     +     ( e . getValue (  )  )  )     +     \"  ;  \"  )  )  ;", "p (  \"  }  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["parameterInitialization"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "buffer . append ( line )  ;", "buffer . append (  \"  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["pb"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "buffer . append ( line )  ;", "}", "METHOD_END"], "methodName": ["pbn"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "sw . print ( line )  ;", "s . append ( line )  ;", "}", "METHOD_END"], "methodName": ["pn"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "p (  \" public   void   setArrayElement ( Type   type ,    Object   obj ,    int   i ,    Object   value )     {  \"  )  ;", ". SwitchedCodeBlock   pc    =    new    . SwitchedCodeBlock (  \" type . id \"  )  ;", "for    ( String   s    :     . PRIMITIVE _ TYPES )     {", "if    (  !  ( typeNames 2 typeIds . containsKey (  ( s    +     \"  [  ]  \"  )  )  )  )", "continue ;", "pc . add ( typeNames 2 typeIds . get (  ( s    +     \"  [  ]  \"  )  )  ,     (  (  (  (  \"  (  (  \"     +    s )     +     \"  [  ]  ) obj )  [ i ]     =     \"  )     +     ( cast ( s ,     \" value \"  )  )  )     +     \"  ;    return ;  \"  )  )  ;", "}", "pc . print (  )  ;", "p (  \"  \t  (  ( Object [  ]  ) obj )  [ i ]     =    value ;  \"  )  ;", "p (  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["setArrayElementT"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "p (  \" public   void   set ( Field   field ,    Object   obj ,    Object   value )    throws   IllegalAccessException    {  \"  )  ;", ". SwitchedCodeBlock   pc    =    new    . SwitchedCodeBlock (  \" field . setter \"  )  ;", "for    (  . SetterGetterStub   stub    :    setterGetterStubs )     {", "if    (  (  (  (  ( stub . enclosingType )     =  =    null )     |  |     (  ( stub . type )     =  =    null )  )     |  |     ( stub . isFinal )  )     |  |     ( stub . unused )  )", "continue ;", "pc . add ( stub . setter ,     (  (  (  (  (  (  \" s \"     +     ( stub . setter )  )     +     \"  (  \"  )     +     ( cast ( stub . enclosingType ,     \" obj \"  )  )  )     +     \"  ,     \"  )     +     ( cast ( stub . type ,     \" value \"  )  )  )     +     \"  )  ;    return ;  \"  )  )  ;", "}", "pc . print (  )  ;", "p (  \"          throw   new   IllegalArgumentException (  \\  \" Missing   setter - stub    \\  \"     +    field . setter    +     \\  \"    for   field    \\  \"     +    field . name )  ;  \"  )  ;", "p (  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["setF"], "fileName": "com.badlogic.gwtref.gen.ReflectionCacheSourceCreator"}, {"methodBody": ["METHOD_START", "{", "char [  ]    hex    =    new   char [ len    *     2  ]  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "int   di    =    data [ i ]  ;", "hex [  ( i    <  <     1  )  ]     =    Character . forDigit (  (  ( di    >  >     4  )     &     1  5  )  ,     1  6  )  ;", "hex [  (  ( i    <  <     1  )     +     1  )  ]     =    Character . forDigit (  ( di    &     1  5  )  ,     1  6  )  ;", "}", "return   new   String ( hex )  ;", "}", "METHOD_END"], "methodName": ["bytesToHex"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "char [  ]    chars    =    new   char [ len ]  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "chars [ i ]     =     (  ( char )     ( data [ i ]  )  )  ;", "}", "return   new   String ( chars )  ;", "}", "METHOD_END"], "methodName": ["bytesToString"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "return   Compatibility . impl . floatToIntBits ( f )  ;", "}", "METHOD_END"], "methodName": ["floatToIntBits"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "return   Compatibility . impl . getOriginatingServerAddress (  )  ;", "}", "METHOD_END"], "methodName": ["getOriginatingServerAddress"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "int   len    =    hex . length (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i    +  =     2  )     {", "data [  ( i    >  >     1  )  ]     =     (  ( byte )     (  (  ( Character . digit ( hex . charAt ( i )  ,     1  6  )  )     <  <     4  )     |     ( Character . digit ( hex . charAt (  ( i    +     1  )  )  ,     1  6  )  )  )  )  ;", "}", "return   len    /     2  ;", "}", "METHOD_END"], "methodName": ["hexToBytes"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "return   Compatibility . impl . intBitsToFloat ( i )  ;", "}", "METHOD_END"], "methodName": ["intBitsToFloat"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "return   Compatibility . impl . createString ( b ,     0  ,    b . length )  ;", "}", "METHOD_END"], "methodName": ["newString"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "return   Compatibility . impl . createString ( b ,    s ,    l )  ;", "}", "METHOD_END"], "methodName": ["newString"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "return   Compatibility . impl . createString ( b ,    encoding )  ;", "}", "METHOD_END"], "methodName": ["newString"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "Compatibility . impl . printStackTrace ( e )  ;", "}", "METHOD_END"], "methodName": ["printStackTrace"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "Compatibility . impl . sleep ( i )  ;", "}", "METHOD_END"], "methodName": ["sleep"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "int   len    =    s . length (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "data [ i ]     =     (  ( byte )     ( s . charAt ( i )  )  )  ;", "}", "return   len ;", "}", "METHOD_END"], "methodName": ["stringToBytes"], "fileName": "com.google.gwt.corp.compatibility.Compatibility"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . floatToIntBits ( f )  ;", "}", "METHOD_END"], "methodName": ["floatToIntBits"], "fileName": "com.google.gwt.corp.compatibility.CompatibilityImpl"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat ( i )  ;", "}", "METHOD_END"], "methodName": ["intBitsToFloat"], "fileName": "com.google.gwt.corp.compatibility.CompatibilityImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( c    =  =     '  \\ n '  )     {", "pln (  \"  \"  )  ;", "} else    {", "buf . append ( c )  ;", "}", "}", "METHOD_END"], "methodName": ["print"], "fileName": "com.google.gwt.corp.compatibility.ConsolePrintStream"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "int   cut    =    s . indexOf (  '  \\ n '  )  ;", "if    ( cut    =  =     (  -  1  )  )     {", "break ;", "}", "pln ( s . substring (  0  ,    cut )  )  ;", "s    =    s . substring (  ( cut    +     1  )  )  ;", "}", "buf . append ( s )  ;", "}", "METHOD_END"], "methodName": ["print"], "fileName": "com.google.gwt.corp.compatibility.ConsolePrintStream"}, {"methodBody": ["METHOD_START", "{", "println (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["println"], "fileName": "com.google.gwt.corp.compatibility.ConsolePrintStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" NYI \"  )  ;", "}", "METHOD_END"], "methodName": ["doubleToLongBits"], "fileName": "com.google.gwt.corp.compatibility.Numbers"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" NYI :    Numbers . doubleToRawLongBits \"  )  ;", "}", "METHOD_END"], "methodName": ["doubleToRawLongBits"], "fileName": "com.google.gwt.corp.compatibility.Numbers"}, {"methodBody": ["METHOD_START", "{", "Numbers . wfa . set (  0  ,    f )  ;", "return   Numbers . wia . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["floatToIntBits"], "fileName": "com.google.gwt.corp.compatibility.Numbers"}, {"methodBody": ["METHOD_START", "{", "Numbers . wia . set (  0  ,    i )  ;", "return   Numbers . wfa . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["intBitsToFloat"], "fileName": "com.google.gwt.corp.compatibility.Numbers"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" NYI \"  )  ;", "}", "METHOD_END"], "methodName": ["longBitsToDouble"], "fileName": "com.google.gwt.corp.compatibility.Numbers"}, {"methodBody": ["METHOD_START", "{", "return   WebGLRenderingContext . getContext ( canvas ,    WebGLContextAttributes . create (  )  )  ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "Float 3  2 Array   array    =    TypedArrays . createFloat 3  2 Array ( values . length )  ;", "array . set ( values )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["toJsArray"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "Int 3  2 Array   array    =    TypedArrays . createInt 3  2 Array ( values . length )  ;", "array . set ( values )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["toJsArray"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 1 fv ( location ,     (  ( JavaScriptObject )     ( v )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniform1fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 1 fv ( location ,    toJsArray ( v )  )  ;", "}", "METHOD_END"], "methodName": ["uniform1fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 1 iv ( location ,     (  ( JavaScriptObject )     ( v )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniform1iv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 1 iv ( location ,    toJsArray ( v )  )  ;", "}", "METHOD_END"], "methodName": ["uniform1iv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 2 fv ( location ,     (  ( JavaScriptObject )     ( v )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniform2fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 2 fv ( location ,    toJsArray ( v )  )  ;", "}", "METHOD_END"], "methodName": ["uniform2fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 2 iv ( location ,     (  ( JavaScriptObject )     ( v )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniform2iv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 2 iv ( location ,    toJsArray ( v )  )  ;", "}", "METHOD_END"], "methodName": ["uniform2iv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 3 fv ( location ,     (  ( JavaScriptObject )     ( v )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniform3fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 3 fv ( location ,    toJsArray ( v )  )  ;", "}", "METHOD_END"], "methodName": ["uniform3fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 3 iv ( location ,     (  ( JavaScriptObject )     ( v )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniform3iv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 3 iv ( location ,    toJsArray ( v )  )  ;", "}", "METHOD_END"], "methodName": ["uniform3iv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 4 fv ( location ,     (  ( JavaScriptObject )     ( v )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniform4fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 4 fv ( location ,    toJsArray ( v )  )  ;", "}", "METHOD_END"], "methodName": ["uniform4fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 4 iv ( location ,     (  ( JavaScriptObject )     ( v )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniform4iv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniform 4 iv ( location ,    toJsArray ( v )  )  ;", "}", "METHOD_END"], "methodName": ["uniform4iv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniformMatrix 2 fv ( location ,    transpose ,     (  ( JavaScriptObject )     ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniformMatrix2fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniformMatrix 2 fv ( location ,    transpose ,    toJsArray ( value )  )  ;", "}", "METHOD_END"], "methodName": ["uniformMatrix2fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniformMatrix 3 fv ( location ,    transpose ,     (  ( JavaScriptObject )     ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniformMatrix3fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniformMatrix 3 fv ( location ,    transpose ,    toJsArray ( value )  )  ;", "}", "METHOD_END"], "methodName": ["uniformMatrix3fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . uniformMatrix 4 fv ( location ,    transpose ,     (  ( JavaScriptObject )     ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["uniformMatrix4fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "uniformMatrix 4 fv ( location ,    transpose ,    toJsArray ( value )  )  ;", "}", "METHOD_END"], "methodName": ["uniformMatrix4fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . vertexAttrib 1 fv ( indx ,     (  ( JavaScriptObject )     ( values )  )  )  ;", "}", "METHOD_END"], "methodName": ["vertexAttrib1fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . vertexAttrib 1 fv ( indx ,    toJsArray ( values )  )  ;", "}", "METHOD_END"], "methodName": ["vertexAttrib1fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . vertexAttrib 2 fv ( indx ,     (  ( JavaScriptObject )     ( values )  )  )  ;", "}", "METHOD_END"], "methodName": ["vertexAttrib2fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . vertexAttrib 2 fv ( indx ,    toJsArray ( values )  )  ;", "}", "METHOD_END"], "methodName": ["vertexAttrib2fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . vertexAttrib 3 fv ( indx ,     (  ( JavaScriptObject )     ( values )  )  )  ;", "}", "METHOD_END"], "methodName": ["vertexAttrib3fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . vertexAttrib 3 fv ( indx ,    toJsArray ( values )  )  ;", "}", "METHOD_END"], "methodName": ["vertexAttrib3fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . vertexAttrib 4 fv ( indx ,     (  ( JavaScriptObject )     ( values )  )  )  ;", "}", "METHOD_END"], "methodName": ["vertexAttrib4fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "this . vertexAttrib 4 fv ( indx ,    toJsArray ( values )  )  ;", "}", "METHOD_END"], "methodName": ["vertexAttrib4fv"], "fileName": "com.google.gwt.webgl.client.WebGLRenderingContext"}, {"methodBody": ["METHOD_START", "{", "double   fieldOfViewInRad    =     ( fieldOfViewVertical    *     ( Math . PI )  )     /     1  8  0  .  0  ;", "return   new   float [  ]  {     (  ( float )     (  ( Math . tan ( fieldOfViewInRad )  )     /    aspectRatio )  )  ,     0  ,     0  ,     0  ,     0  ,     (  ( float )     (  1     /     ( Math . tan (  (  ( fieldOfViewVertical    *     ( Math . PI )  )     /     1  8  0  .  0  )  )  )  )  )  ,     0  ,     0  ,     0  ,     0  ,     ( minimumClearance    +    maximumClearance )     /     ( minimumClearance    -    maximumClearance )  ,     -  1  ,     0  ,     0  ,     (  (  2     *    minimumClearance )     *    maximumClearance )     /     ( minimumClearance    -    maximumClearance )  ,     0     }  ;", "}", "METHOD_END"], "methodName": ["createPerspectiveMatrix"], "fileName": "com.google.gwt.webgl.client.WebGLUtil"}, {"methodBody": ["METHOD_START", "{", "WebGLShader   vertexShader    =    WebGLUtil . getShader ( gl ,    WebGLRenderingContext . VERTEX _ SHADER ,    vertexSource )  ;", "WebGLShader   fragmentShader    =    WebGLUtil . getShader ( gl ,    WebGLRenderingContext . FRAGMENT _ SHADER ,    fragmentSource )  ;", "WebGLProgram   shaderProgram    =    gl . createProgram (  )  ;", "gl . attachShader ( shaderProgram ,    fragmentShader )  ;", "gl . attachShader ( shaderProgram ,    vertexShader )  ;", "gl . linkProgram ( shaderProgram )  ;", "if    (  !  ( gl . getProgramParameterb ( shaderProgram ,    WebGLRenderingContext . LINK _ STATUS )  )  )     {", "throw   new   RuntimeException (  \" Could   not   initialize   shaders \"  )  ;", "}", "return   shaderProgram ;", "}", "METHOD_END"], "methodName": ["createShaderProgram"], "fileName": "com.google.gwt.webgl.client.WebGLUtil"}, {"methodBody": ["METHOD_START", "{", "WebGLShader   shader    =    gl . createShader ( shaderType )  ;", "gl . shaderSource ( shader ,    source )  ;", "gl . compileShader ( shader )  ;", "if    (  !  ( gl . getShaderParameterb ( shader ,    WebGLRenderingContext . COMPILE _ STATUS )  )  )     {", "throw   new   RuntimeException ( gl . getShaderInfoLog ( shader )  )  ;", "}", "return   shader ;", "}", "METHOD_END"], "methodName": ["getShader"], "fileName": "com.google.gwt.webgl.client.WebGLUtil"}, {"methodBody": ["METHOD_START", "{", "in . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "java.io.BufferedReader"}, {"methodBody": ["METHOD_START", "{", "position    =     0  ;", "limit    =    in . read ( b )  ;", "}", "METHOD_END"], "methodName": ["fill"], "fileName": "java.io.BufferedReader"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "if    (  (  ( position )     >  =     ( limit )  )     &  &     ( length    <     ( b . length )  )  )     {", "fill (  )  ;", "}", "if    (  ( position )     <     ( limit )  )     {", "int   remaining    =     ( limit )     -     ( position )  ;", "if    ( remaining    >    length )     {", "remaining    =    length ;", "}", "System . arraycopy ( b ,    position ,    b ,    offset ,    remaining )  ;", "count    +  =    remaining ;", "position    +  =    remaining ;", "offset    +  =    remaining ;", "length    -  =    remaining ;", "}", "if    ( length    >     0  )     {", "int   c    =    in . read ( b ,    offset ,    length )  ;", "if    ( c    =  =     (  -  1  )  )     {", "if    ( count    =  =     0  )     {", "count    =     -  1  ;", "}", "} else    {", "count    +  =    c ;", "}", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.io.BufferedReader"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "while    ( true )     {", "if    (  ( position )     >  =     ( limit )  )     {", "fill (  )  ;", "}", "if    (  ( position )     >  =     ( limit )  )     {", "return    ( sb . length (  )  )     =  =     0     ?    null    :    sb . toString (  )  ;", "}", "for    ( int   i    =    position ;    i    <     ( limit )  ;     +  + i )     {", "if    (  ( b [ i ]  )     =  =     '  \\ r '  )     {", "sb . append ( b ,    position ,     ( i    -     ( position )  )  )  ;", "position    =    i    +     1  ;", "if    (  ( i    +     1  )     <     ( limit )  )     {", "if    (  ( b [  ( i    +     1  )  ]  )     =  =     '  \\ n '  )     {", "position    =    i    +     2  ;", "}", "} else    {", "fill (  )  ;", "if    (  ( b [ position ]  )     =  =     '  \\ n '  )     {", "position    +  =     1  ;", "}", "}", "return   sb . toString (  )  ;", "} else", "if    (  ( b [ i ]  )     =  =     '  \\ n '  )     {", "sb . append ( b ,    position ,     ( i    -     ( position )  )  )  ;", "position    =    i    +     1  ;", "return   sb . toString (  )  ;", "}", "}", "sb . append ( b ,    position ,     (  ( limit )     -     ( position )  )  )  ;", "position    =    limit ;", "}", "}", "METHOD_END"], "methodName": ["readLine"], "fileName": "java.io.BufferedReader"}, {"methodBody": ["METHOD_START", "{", "flush (  )  ;", "out . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "java.io.BufferedWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     >     0  )     {", "out . write ( b ,     0  ,    position )  ;", "position    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["drain"], "fileName": "java.io.BufferedWriter"}, {"methodBody": ["METHOD_START", "{", "drain (  )  ;", "out . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "java.io.BufferedWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( length    >     (  ( buffer . length )     -     ( position )  )  )     {", "drain (  )  ;", "out . write ( b ,    offset ,    length )  ;", "} else    {", "System . arraycopy ( b ,    offset ,    buffer ,    position ,    length )  ;", "position    +  =    length ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.BufferedWriter"}, {"methodBody": ["METHOD_START", "{", "return    ( readByte (  )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["readBoolean"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "int   i    =    read (  )  ;", "if    ( i    =  =     (  -  1  )  )     {", "throw   new   EOFException (  )  ;", "}", "return    (  ( byte )     ( i )  )  ;", "}", "METHOD_END"], "methodName": ["readByte"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "int   a    =    is . read (  )  ;", "int   b    =    readUnsignedByte (  )  ;", "return    (  ( char )     (  ( a    <  <     8  )     |    b )  )  ;", "}", "METHOD_END"], "methodName": ["readChar"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "return   Double . longBitsToDouble ( readLong (  )  )  ;", "}", "METHOD_END"], "methodName": ["readDouble"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat ( readInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["readFloat"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "readFully ( b ,     0  ,    b . length )  ;", "}", "METHOD_END"], "methodName": ["readFully"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "while    ( len    >     0  )     {", "int   count    =    is . d ( b ,    off ,    len )  ;", "if    ( count    <  =     0  )     {", "throw   new   EOFException (  )  ;", "}", "off    +  =    count ;", "len    -  =    count ;", "}", "}", "METHOD_END"], "methodName": ["readFully"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "int   a    =    is . read (  )  ;", "int   b    =    is . read (  )  ;", "int   c    =    is . read (  )  ;", "int   d    =    readUnsignedByte (  )  ;", "return    (  (  ( a    <  <     2  4  )     |     ( b    <  <     1  6  )  )     |     ( c    <  <     8  )  )     |    d ;", "}", "METHOD_END"], "methodName": ["readInt"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" readline   NYI \"  )  ;", "}", "METHOD_END"], "methodName": ["readLine"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "long   a    =    readInt (  )  ;", "long   b    =     ( readInt (  )  )     &     -  1  ;", "return    ( a    <  <     3  2  )     |    b ;", "}", "METHOD_END"], "methodName": ["readLong"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "int   a    =    is . read (  )  ;", "int   b    =    readUnsignedByte (  )  ;", "return    (  ( short )     (  ( a    <  <     8  )     |    b )  )  ;", "}", "METHOD_END"], "methodName": ["readShort"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "int   bytes    =    readUnsignedShort (  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "while    ( bytes    >     0  )     {", "bytes    -  =    readUtfChar ( sb )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["readUTF"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "int   i    =    read (  )  ;", "if    ( i    =  =     (  -  1  )  )     {", "throw   new   EOFException (  )  ;", "}", "return   i ;", "}", "METHOD_END"], "methodName": ["readUnsignedByte"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "int   a    =    is . read (  )  ;", "int   b    =    readUnsignedByte (  )  ;", "return    ( a    <  <     8  )     |    b ;", "}", "METHOD_END"], "methodName": ["readUnsignedShort"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "int   a    =    readUnsignedByte (  )  ;", "if    (  ( a    &     1  2  8  )     =  =     0  )     {", "sb . append (  (  ( char )     ( a )  )  )  ;", "return    1  ;", "}", "if    (  ( a    &     2  2  4  )     =  =     1  9  2  )     {", "int   b    =    readUnsignedByte (  )  ;", "sb . append (  (  ( char )     (  (  ( a    &     3  1  )     <  <     6  )     |     ( b    &     6  3  )  )  )  )  ;", "return    2  ;", "}", "if    (  ( a    &     2  4  0  )     =  =     2  2  4  )     {", "int   b    =    readUnsignedByte (  )  ;", "int   c    =    readUnsignedByte (  )  ;", "sb . append (  (  ( char )     (  (  (  ( a    &     1  5  )     <  <     1  2  )     |     (  ( b    &     6  3  )     <  <     6  )  )     |     ( c    &     6  3  )  )  )  )  ;", "return    3  ;", "}", "throw   new   UTFFormatException (  )  ;", "}", "METHOD_END"], "methodName": ["readUtfChar"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["skipBytes"], "fileName": "java.io.DataInputStream"}, {"methodBody": ["METHOD_START", "{", "os . write (  ( v    ?     1     :     0  )  )  ;", "}", "METHOD_END"], "methodName": ["writeBoolean"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "os . write ( v )  ;", "}", "METHOD_END"], "methodName": ["writeByte"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "int   len    =    s . length (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "os . write (  (  ( s . charAt ( i )  )     &     2  5  5  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "os . write (  ( v    >  >     8  )  )  ;", "os . write ( v )  ;", "}", "METHOD_END"], "methodName": ["writeChar"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" writeChars   NYI \"  )  ;", "}", "METHOD_END"], "methodName": ["writeChars"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "writeLong ( Double . doubleToLongBits ( v )  )  ;", "}", "METHOD_END"], "methodName": ["writeDouble"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "writeInt ( Numbers . floatToIntBits ( v )  )  ;", "}", "METHOD_END"], "methodName": ["writeFloat"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "os . write (  ( v    >  >     2  4  )  )  ;", "os . write (  ( v    >  >     1  6  )  )  ;", "os . write (  ( v    >  >     8  )  )  ;", "os . write ( v )  ;", "}", "METHOD_END"], "methodName": ["writeInt"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "writeInt (  (  ( int )     ( v    >  >     3  2 L )  )  )  ;", "writeInt (  (  ( int )     ( v )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeLong"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "os . write (  ( v    >  >     8  )  )  ;", "os . write ( v )  ;", "}", "METHOD_END"], "methodName": ["writeShort"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "for    ( int   i    =     0  ;    i    <     ( s . length (  )  )  ;    i +  +  )     {", "char   c    =    s . charAt ( i )  ;", "if    (  ( c    >     0  )     &  &     ( c    <     8  0  )  )     {", "baos . write ( c )  ;", "} else", "if    ( c    <     '  \\ u 0  8  0  0  '  )     {", "baos . write (  (  1  9  2     |     (  3  1     &     ( c    >  >     6  )  )  )  )  ;", "baos . write (  (  1  2  8     |     (  6  3     &    c )  )  )  ;", "} else    {", "baos . write (  (  2  2  4     |     (  1  5     &     ( c    >  >     1  2  )  )  )  )  ;", "baos . write (  (  1  2  8     |     (  6  3     &     ( c    >  >     6  )  )  )  )  ;", "baos . write (  (  1  2  8     |     (  6  3     &    c )  )  )  ;", "}", "}", "writeShort ( baos . count )  ;", "os . write ( baos . buf ,     0  ,    baos . count )  ;", "}", "METHOD_END"], "methodName": ["writeUTF"], "fileName": "java.io.DataOutputStream"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["canRead"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" NYI :    File . compareTo (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "if    ( exists (  )  )", "return   false ;", "if    (  !  ( parent . exists (  )  )  )", "return   false ;", ". LocalStorage . setItem ( getCanonicalPath (  )  ,    RandomAccess . btoa (  \"  \"  )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["createNewFile"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" NYI :    createTempFile \"  )  ;", "}", "METHOD_END"], "methodName": ["createTempFile"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" NYI :    createTempFile \"  )  ;", "}", "METHOD_END"], "methodName": ["createTempFile"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( exists (  )  )  )     {", "return   false ;", "}", ". LocalStorage . removeItem ( getCanonicalPath (  )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" NYI :    File . deleteOnExit (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["deleteOnExit"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( obj   instanceof   File )  )     {", "return   false ;", "}", "return   getPath (  )  . equals (  (  ( File )     ( obj )  )  . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return    ( File . LocalStorage . getItem ( getCanonicalPath (  )  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "if    ( isAbsolute (  )  )     {", "return   this ;", "}", "if    (  ( parent )     =  =    null )     {", "return   new    (  . ROOT ,    name )  ;", "}", "return   new    ( parent . getAbsolute (  )  ,    name )  ;", "}", "METHOD_END"], "methodName": ["getAbsoluteFile"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "String   path    =    getAbsoluteFile (  )  . getPath (  )  ;", "return    ( path . length (  )  )     =  =     0     ?     \"  /  \"     :    path ;", "}", "METHOD_END"], "methodName": ["getAbsolutePath"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "File   cParent    =     (  ( parent )     =  =    null )     ?    null    :    parent . getCanonicalFile (  )  ;", "if    ( name . equals (  \"  .  \"  )  )     {", "return   cParent    =  =    null    ?    File . ROOT    :    cParent ;", "}", "if    (  ( cParent    !  =    null )     &  &     ( cParent . name . equals (  \"  \"  )  )  )     {", "cParent    =    null ;", "}", "if    ( name . equals (  \"  .  .  \"  )  )     {", "if    ( cParent    =  =    null )     {", "return   File . ROOT ;", "}", "if    (  ( cParent . parent )     =  =    null )     {", "return   File . ROOT ;", "}", "return   cParent . parent ;", "}", "if    (  ( cParent    =  =    null )     &  &     (  !  ( name . equals (  \"  \"  )  )  )  )     {", "return   new   File ( File . ROOT ,    name )  ;", "}", "return   new   File ( cParent ,    name )  ;", "}", "METHOD_END"], "methodName": ["getCanonicalFile"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   getCanonicalFile (  )  . getAbsolutePath (  )  ;", "}", "METHOD_END"], "methodName": ["getCanonicalPath"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return    ( parent )     =  =    null    ?     \"  \"     :    parent . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParentFile"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return    ( parent )     =  =    null    ?    name    :     (  ( parent . getPath (  )  )     +     ( File . separatorChar )  )     +     ( name )  ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return    ( parent )     !  =    null    ?     ( parent . hashCode (  )  )     +     ( name . hashCode (  )  )     :    name . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "f   sRoot (  )  )     {", "return   true ;", "}", "f    (  ( parent )     =  =    null )     {", "return   false ;", "}", "return   parentsAbsolute (  )  ;", "}", "METHOD_END"], "methodName": ["isAbsolute"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "String   s    =    File . LocalStorage . getItem ( getCanonicalPath (  )  )  ;", "return    ( s    !  =    null )     &  &     ( s . startsWith (  \"  {  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "String   s    =    File . LocalStorage . getItem ( getCanonicalPath (  )  )  ;", "return    ( s    !  =    null )     &  &     (  !  ( s . startsWith (  \"  {  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isFile"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isHidden"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return    ( name . equals (  \"  \"  )  )     &  &     (  ( parent )     =  =    null )  ;", "}", "METHOD_END"], "methodName": ["isRoot"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  !  ( exists (  )  )  )     {", "return    0  ;", "}", "RandomAccess   raf    =    new   RandomAccess ( this ,     \" r \"  )  ;", "long   len    =    raf . length (  )  ;", "raf . close (  )  ;", "return   len ;", "}    catch    ( IOException   e )     {", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["length"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" NYI :    File . list (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   listFiles ( null )  ;", "}", "METHOD_END"], "methodName": ["listFiles"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "ArrayList < File >    files    =    new   ArrayList < File >  (  )  ;", "String   prefix    =    getCanonicalPath (  )  ;", "if    (  !  ( prefix . endsWith ( File . separator )  )  )     {", "prefix    +  =    File . separatorChar ;", "}", "int   cut    =    prefix . length (  )  ;", "int   cnt    =    File . LocalStorage . getLength (  )  ;", "for    ( int   i    =     0  ;    i    <    cnt ;    i +  +  )     {", "String   key    =    File . LocalStorage . key ( i )  ;", "if    (  ( key . startsWith ( prefix )  )     &  &     (  ( key . indexOf ( File . separatorChar ,    cut )  )     =  =     (  -  1  )  )  )     {", "String   name    =    key . substring ( cut )  ;", "if    (  ( filter    =  =    null )     |  |     ( filter . accept ( this ,    name )  )  )     {", "files . add ( new   File ( this ,    name )  )  ;", "}", "}", "}", "return   files . toArray ( new   File [ files . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["listFiles"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   new   File [  ]  {    File . ROOT    }  ;", "}", "METHOD_END"], "methodName": ["listRoots"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( parent )     !  =    null )     &  &     (  !  ( parent . exists (  )  )  )  )     {", "return   false ;", "}", "if    ( exists (  )  )     {", "return   false ;", "}", ". LocalStorage . setItem ( getCanonicalPath (  )  ,     \"  {  }  \"  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["mkdir"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent )     !  =    null )     {", "parent . mkdirs (  )  ;", "}", "return   mkdir (  )  ;", "}", "METHOD_END"], "methodName": ["mkdirs"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" renameTo (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["renameTo"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["setLastModified"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["setReadOnly"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.io.File"}, {"methodBody": ["METHOD_START", "{", "file . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "java.io.FileWriter"}, {"methodBody": ["METHOD_START", "{", "file . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "java.io.FileWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( s . length (  )  )  ;    i +  +  )     {", "file . w ( s . charAt ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.FileWriter"}, {"methodBody": ["METHOD_START", "{", "in . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "java.io.InputStreamReader"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buffer    =    new   byte [ length ]  ;", "int   c    =    in . d ( buffer )  ;", "return   c    <  =     0     ?    c    :    utf 8 Decoder . decode ( buffer ,     0  ,    c ,    b ,    offset )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.io.InputStreamReader"}, {"methodBody": ["METHOD_START", "{", "out . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "java.io.OutputStreamWriter"}, {"methodBody": ["METHOD_START", "{", "out . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "java.io.OutputStreamWriter"}, {"methodBody": ["METHOD_START", "{", "out . write ( Utf 8  . encode ( b ,    offset ,    length )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.OutputStreamWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( data )     !  =    null )     {", "flush (  )  ;", "data    =    null ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "if    (  ( newData )     =  =    null )     {", "return ;", "}", "if    (  ( data . length (  )  )     <     ( newDataPos )  )     {", "StringBuilder   filler    =    new   StringBuilder (  )  ;", "wh    (  (  ( data . length (  )  )     +     ( filler . length (  )  )  )     <     ( newDataPos )  )     {", "filler . append (  '  \\ u 0  0  0  0  '  )  ;", "}", "data    +  =    filler . toString (  )  ;", "}", "int   p 2     =     ( newDataPos )     +     ( newData . length (  )  )  ;", "data    =     (  ( data . substring (  0  ,    newDataPos )  )     +     ( newData . toString (  )  )  )     +     ( p 2     <     ( data . length (  )  )     ?    data . substring ( p 2  )     :     \"  \"  )  ;", "newData    =    null ;", "}", "METHOD_END"], "methodName": ["consolidate"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( dirty )  )     {", "return ;", "}", "consolidate (  )  ;", "File . LocalStorage . setItem ( name ,     . btoa ( data )  )  ;", "dirty    =    false ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   pos ;", "}", "METHOD_END"], "methodName": ["getFilePointer"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   len ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . read (  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . read ( b )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . read ( b ,    off ,    len )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readBoolean (  )  ;", "}", "METHOD_END"], "methodName": ["readBoolean"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readByte (  )  ;", "}", "METHOD_END"], "methodName": ["readByte"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readChar (  )  ;", "}", "METHOD_END"], "methodName": ["readChar"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readDouble (  )  ;", "}", "METHOD_END"], "methodName": ["readDouble"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readFloat (  )  ;", "}", "METHOD_END"], "methodName": ["readFloat"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dis . readFully ( b )  ;", "}", "METHOD_END"], "methodName": ["readFully"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dis . readFully ( b ,    off ,    len )  ;", "}", "METHOD_END"], "methodName": ["readFully"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readInt (  )  ;", "}", "METHOD_END"], "methodName": ["readInt"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readLine (  )  ;", "}", "METHOD_END"], "methodName": ["readLine"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readLong (  )  ;", "}", "METHOD_END"], "methodName": ["readLong"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readShort (  )  ;", "}", "METHOD_END"], "methodName": ["readShort"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readUTF (  )  ;", "}", "METHOD_END"], "methodName": ["readUTF"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readUnsignedByte (  )  ;", "}", "METHOD_END"], "methodName": ["readUnsignedByte"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . readUnsignedShort (  )  ;", "}", "METHOD_END"], "methodName": ["readUnsignedShort"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "if    ( pos    <     0  )     {", "throw   new   IllegalArgumentExceptn (  )  ;", "}", "this . pos    =     (  ( int )     ( pos )  )  ;", "}", "METHOD_END"], "methodName": ["seek"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "if    (  ( len )     !  =    newLength )     {", "consolidate (  )  ;", "if    (  ( data . length (  )  )     >    newLength )     {", "data    =    data . substring (  0  ,     (  ( int )     ( newLength )  )  )  ;", "len    =     (  ( int )     ( newLength )  )  ;", "} else    {", "wh    (  ( len )     <    newLength )     {", "write (  0  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["setLength"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "return   dis . skipBytes ( n )  ;", "}", "METHOD_END"], "methodName": ["skipBytes"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . write ( b )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . write ( b ,    off ,    len )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . write ( b )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeBoolean ( v )  ;", "}", "METHOD_END"], "methodName": ["writeBoolean"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeByte ( v )  ;", "}", "METHOD_END"], "methodName": ["writeByte"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeBytes ( s )  ;", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeChar ( v )  ;", "}", "METHOD_END"], "methodName": ["writeChar"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeChars ( s )  ;", "}", "METHOD_END"], "methodName": ["writeChars"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeDouble ( v )  ;", "}", "METHOD_END"], "methodName": ["writeDouble"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeFloat ( v )  ;", "}", "METHOD_END"], "methodName": ["writeFloat"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeInt ( v )  ;", "}", "METHOD_END"], "methodName": ["writeInt"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeLong ( v )  ;", "}", "METHOD_END"], "methodName": ["writeLong"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeShort ( v )  ;", "}", "METHOD_END"], "methodName": ["writeShort"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "dos . writeUTF ( str )  ;", "}", "METHOD_END"], "methodName": ["writeUTF"], "fileName": "java.io.RandomAccessFile"}, {"methodBody": ["METHOD_START", "{", "throw   new   IOException (  )  ;", "}", "METHOD_END"], "methodName": ["mark"], "fileName": "java.io.Reader"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["markSupported"], "fileName": "java.io.Reader"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "char [  ]    charArray    =    new   char [  1  ]  ;", "if    (  ( r ( charArray ,     0  ,     1  )  )     !  =     (  -  1  )  )     {", "return   charArray [  0  ]  ;", "}", "return    -  1  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.io.Reader"}, {"methodBody": ["METHOD_START", "{", "return   read ( buf ,     0  ,    buf . length )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.io.Reader"}, {"methodBody": ["METHOD_START", "{", "if    ( null    =  =    target )     {", "throw   new   NullPointerException (  )  ;", "}", "int   length    =    target . length (  )  ;", "char [  ]    buf    =    new   char [ length ]  ;", "length    =    Math . min ( length ,    r ( buf )  )  ;", "if    ( length    >     0  )     {", "target . put ( buf ,     0  ,    length )  ;", "}", "return   length ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.io.Reader"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["ready"], "fileName": "java.io.Reader"}, {"methodBody": ["METHOD_START", "{", "throw   new   IOException (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "java.io.Reader"}, {"methodBody": ["METHOD_START", "{", "if    ( count    <     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "synchronized ( lock )     {", "long   skipped    =     0  ;", "int   to    =     ( count    <     5  1  2  )     ?     (  ( int )     ( count )  )     :     5  1  2  ;", "char [  ]    charsSkipped    =    new   char [ to ]  ;", "while    ( skipped    <    count )     {", "int   read    =    read ( charsSkipped ,     0  ,    to )  ;", "if    ( read    =  =     (  -  1  )  )     {", "return   skipped ;", "}", "skipped    +  =    read ;", "if    ( read    <    to )     {", "return   skipped ;", "}", "if    (  ( count    -    skipped )     <    to )     {", "to    =     (  ( int )     ( count    -    skipped )  )  ;", "}", "}", "return   skipped ;", "}", "}", "METHOD_END"], "methodName": ["skip"], "fileName": "java.io.Reader"}, {"methodBody": ["METHOD_START", "{", "if    ( length    >     (  ( in . length (  )  )     -     ( position )  )  )     {", "length    =     ( in . length (  )  )     -     ( position )  ;", "if    ( length    <  =     0  )     {", "return    -  1  ;", "}", "}", "in . getChars ( position ,     (  ( position )     +    length )  ,    b ,    offset )  ;", "position    +  =    length ;", "return   length ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.io.StringReader"}, {"methodBody": ["METHOD_START", "{", "return   out . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.io.StringWriter"}, {"methodBody": ["METHOD_START", "{", "out . append ( b ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.StringWriter"}, {"methodBody": ["METHOD_START", "{", "write ( c )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "java.io.Writer"}, {"methodBody": ["METHOD_START", "{", "if    ( null    =  =    csq )     {", "write (  . TOKEN _ NULL )  ;", "} else    {", "write ( csq . toString (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "java.io.Writer"}, {"methodBody": ["METHOD_START", "{", "if    ( null    =  =    csq )     {", "write (  . TOKEN _ NULL . substring ( start ,    end )  )  ;", "} else    {", "write ( csq . subSequence ( start ,    end )  . toString (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "java.io.Writer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["checkError"], "fileName": "java.io.Writer"}, {"methodBody": ["METHOD_START", "{", "write ( buf ,     0  ,    buf . length )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.Writer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "char [  ]    oneCharArray    =    new   char [  1  ]  ;", "oneCharArray [  0  ]     =     (  ( char )     ( oneChar )  )  ;", "w ( oneCharArray )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.Writer"}, {"methodBody": ["METHOD_START", "{", "write ( str ,     0  ,    str . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.Writer"}, {"methodBody": ["METHOD_START", "{", "if    ( count    <     0  )     {", "throw   new   StringIndexOutOfBoundsException (  )  ;", "}", "char [  ]    buf    =    new   char [ count ]  ;", "str . getChars ( offset ,     ( offset    +    count )  ,    buf ,     0  )  ;", "synchronized ( lock )     {", "w ( buf ,     0  ,    buf . length )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "java.io.Writer"}, {"methodBody": ["METHOD_START", "{", "return   ex ;", "}", "METHOD_END"], "methodName": ["getCause"], "fileName": "java.lang.ClassNotFoundException"}, {"methodBody": ["METHOD_START", "{", "return   ex ;", "}", "METHOD_END"], "methodName": ["getException"], "fileName": "java.lang.ClassNotFoundException"}, {"methodBody": ["METHOD_START", "{", "GWT . setUncaughtExceptionHandler ( new   GWT . UncaughtExceptionHandler (  )     {", "@ Override", "public   void   onUncaughtException ( Throwable   e )     {", "final      th    =    new    (  )     {", "@ Override", "public   String   toString (  )     {", "return    \" The   only   thread \"  ;", "}", "}  ;", "uncaughtException ( th ,    e )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultUncaughtExceptionHandler"], "fileName": "java.lang.Thread"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    s . getBytes ( enc )  ;", "for    ( int   j    =     0  ;    j    <     ( bytes . length )  ;    j +  +  )     {", "buf . append (  '  %  '  )  ;", "buf . append (  . digits . charAt (  (  (  ( bytes [ j ]  )     &     2  4  0  )     >  >     4  )  )  )  ;", "buf . append (  . digits . charAt (  (  ( bytes [ j ]  )     &     1  5  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "java.net.URLEncoder"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  (  ( s . length (  )  )     +     1  6  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( s . length (  )  )  ;    i +  +  )     {", "char   ch    =    s . charAt ( i )  ;", "if    (  (  (  (  ( ch    >  =     ' a '  )     &  &     ( ch    <  =     ' z '  )  )     |  |     (  ( ch    >  =     ' A '  )     &  &     ( ch    <  =     ' Z '  )  )  )     |  |     (  ( ch    >  =     '  0  '  )     &  &     ( ch    <  =     '  9  '  )  )  )     |  |     (  (  \"  .  -  *  _  \"  . indexOf ( ch )  )     >     (  -  1  )  )  )     {", "buf . append ( ch )  ;", "} else", "if    ( ch    =  =     '     '  )     {", "buf . append (  '  +  '  )  ;", "} else    {", "byte [  ]    bytes    =    new   String ( new   char [  ]  {    ch    }  )  . getBytes (  )  ;", "for    ( int   j    =     0  ;    j    <     ( bytes . length )  ;    j +  +  )     {", "buf . append (  '  %  '  )  ;", "buf . append (  . digits . charAt (  (  (  ( bytes [ j ]  )     &     2  4  0  )     >  >     4  )  )  )  ;", "buf . append (  . digits . charAt (  (  ( bytes [ j ]  )     &     1  5  )  )  )  ;", "}", "}", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "java.net.URLEncoder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( s    =  =    null )     |  |     ( enc    =  =    null )  )     {", "throw   new   NullPointerException (  )  ;", "}", "\"  \"  . getBytes ( enc )  ;", "StringBuilder   buf    =    new   StringBuilder (  (  ( s . length (  )  )     +     1  6  )  )  ;", "int   start    =     -  1  ;", "for    ( int   i    =     0  ;    i    <     ( s . length (  )  )  ;    i +  +  )     {", "char   ch    =    s . charAt ( i )  ;", "if    (  (  (  (  ( ch    >  =     ' a '  )     &  &     ( ch    <  =     ' z '  )  )     |  |     (  ( ch    >  =     ' A '  )     &  &     ( ch    <  =     ' Z '  )  )  )     |  |     (  ( ch    >  =     '  0  '  )     &  &     ( ch    <  =     '  9  '  )  )  )     |  |     (  (  \"     .  -  *  _  \"  . indexOf ( ch )  )     >     (  -  1  )  )  )     {", "if    ( start    >  =     0  )     {", ". convert ( s . substring ( start ,    i )  ,    buf ,    enc )  ;", "start    =     -  1  ;", "}", "if    ( ch    !  =     '     '  )     {", "buf . append ( ch )  ;", "} else    {", "buf . append (  '  +  '  )  ;", "}", "} else    {", "if    ( start    <     0  )     {", "start    =    i ;", "}", "}", "}", "if    ( start    >  =     0  )     {", ". convert ( s . substring ( start ,    s . length (  )  )  ,    buf ,    enc )  ;", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "java.net.URLEncoder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( char )     ( getShort (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getChar"], "fileName": "java.nio.BaseByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    (  ( char )     ( getShort ( index )  )  )  ;", "}", "METHOD_END"], "methodName": ["getChar"], "fileName": "java.nio.BaseByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putShort (  (  ( short )     ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["putChar"], "fileName": "java.nio.BaseByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putShort ( index ,     (  ( short )     ( value )  )  )  ;", "}", "METHOD_END"], "methodName": ["putChar"], "fileName": "java.nio.BaseByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   capacity ;", "}", "METHOD_END"], "methodName": ["capacity"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "position    =     0  ;", "mark    =     . UNSET _ MARK ;", "limit    =    capacity ;", "return   this ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "limit    =    position ;", "position    =     0  ;", "mark    =     . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["flip"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "return    ( position )     <     ( limit )  ;", "}", "METHOD_END"], "methodName": ["hasRemaining"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "return   limit ;", "}", "METHOD_END"], "methodName": ["limit"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( newLimit    <     0  )     |  |     ( newLimit    >     ( capacity )  )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "limit    =    newLimit ;", "if    (  ( position )     >    newLimit )     {", "position    =    newLimit ;", "}", "if    (  (  ( mark )     !  =     (  . UNSET _ MARK )  )     &  &     (  ( mark )     >    newLimit )  )     {", "mark    =     . UNSET _ MARK ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["limit"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "mark    =    position ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mark"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "return   position ;", "}", "METHOD_END"], "methodName": ["position"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( newPosition    <     0  )     |  |     ( newPosition    >     ( limit )  )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "position    =    newPosition ;", "if    (  (  ( mark )     !  =     (  . UNSET _ MARK )  )     &  &     (  ( mark )     >     ( position )  )  )     {", "mark    =     . UNSET _ MARK ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["position"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "return    ( limit )     -     ( position )  ;", "}", "METHOD_END"], "methodName": ["remaining"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mark )     =  =     ( Buffer . UNSET _ MARK )  )     {", "throw   new   InvalidMarkException (  )  ;", "}", "position    =    mark ;", "return   this ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "position    =     0  ;", "mark    =     . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["rewind"], "fileName": "java.nio.Buffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteHeapByteBuffer ( array )  ;", "}", "METHOD_END"], "methodName": ["newByteBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteHeapByteBuffer ( capacity )  ;", "}", "METHOD_END"], "methodName": ["newByteBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteCharArrayBuffer ( array )  ;", "}", "METHOD_END"], "methodName": ["newCharBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteCharArrayBuffer ( capacity )  ;", "}", "METHOD_END"], "methodName": ["newCharBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   CharSequenceAdapter ( chseq )  ;", "}", "METHOD_END"], "methodName": ["newCharBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectReadWriteByteBuffer ( capacity )  ;", "}", "METHOD_END"], "methodName": ["newDirectByteBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteDoubleArrayBuffer ( array )  ;", "}", "METHOD_END"], "methodName": ["newDoubleBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteDoubleArrayBuffer ( capacity )  ;", "}", "METHOD_END"], "methodName": ["newDoubleBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteFloatArrayBuffer ( array )  ;", "}", "METHOD_END"], "methodName": ["newFloatBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteFloatArrayBuffer ( capacity )  ;", "}", "METHOD_END"], "methodName": ["newFloatBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteIntArrayBuffer ( capacity )  ;", "}", "METHOD_END"], "methodName": ["newIntBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteIntArrayBuffer ( array )  ;", "}", "METHOD_END"], "methodName": ["newIntBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteLongArrayBuffer ( capacity )  ;", "}", "METHOD_END"], "methodName": ["newLongBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteLongArrayBuffer ( array )  ;", "}", "METHOD_END"], "methodName": ["newLongBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteShortArrayBuffer ( capacity )  ;", "}", "METHOD_END"], "methodName": ["newShortBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteShortArrayBuffer ( array )  ;", "}", "METHOD_END"], "methodName": ["newShortBuffer"], "fileName": "java.nio.BufferFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( capacity    <     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "return   BufferFactory . new ( capacity )  ;", "}", "METHOD_END"], "methodName": ["allocate"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( capacity    <     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "return   BufferFactory . newDirect ( capacity )  ;", "}", "METHOD_END"], "methodName": ["allocateDirect"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArray (  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArrayOffset (  )  ;", "}", "METHOD_END"], "methodName": ["arrayOffset"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   compareRemaining    =     (  ( remaining (  )  )     <     ( otherBuffer . remaining (  )  )  )     ?    remaining (  )     :    otherBuffer . remaining (  )  ;", "int   thisPos    =    position ;", "int   otherPos    =    otherBuffer . position ;", "byte   thisByte ;", "byte   otherByte ;", "while    ( compareRemaining    >     0  )     {", "thisByte    =    get ( thisPos )  ;", "otherByte    =    otherBuffer . get ( otherPos )  ;", "if    ( thisByte    !  =    otherByte )     {", "return   thisByte    <    otherByte    ?     -  1     :     1  ;", "}", "thisPos +  +  ;", "otherPos +  +  ;", "compareRemaining -  -  ;", "}", "return    ( remaining (  )  )     -     ( otherBuffer . remaining (  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( other   instanceof   ByteBuffer )  )     {", "return   false ;", "}", "ByteBuffer   otherBuffer    =     (  ( ByteBuffer )     ( other )  )  ;", "if    (  ( remaining (  )  )     !  =     ( otherBuffer . remaining (  )  )  )     {", "return   false ;", "}", "int   myPosition    =    position ;", "int   otherPosition    =    otherBuffer . position ;", "boolean   equalSoFar    =    true ;", "while    ( equalSoFar    &  &     ( myPosition    <     ( limit )  )  )     {", "equalSoFar    =     ( get (  ( myPosition +  +  )  )  )     =  =     ( otherBuffer . get (  ( otherPosition +  +  )  )  )  ;", "}", "return   equalSoFar ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   get ( dest ,     0  ,    dest . length )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "dest [ i ]     =    get (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedHasArray (  )  ;", "}", "METHOD_END"], "methodName": ["hasArray"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   myPosition    =    position ;", "int   hash    =     0  ;", "while    ( myPosition    <     ( limit )  )     {", "hash    =    hash    +     ( get (  ( myPosition +  +  )  )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    ( order )     =  =     ( Endianness . BIG _ ENDIAN )     ?    ByteOrder . BIG _ ENDIAN    :    ByteOrder . LITTLE _ ENDIAN ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   orderImpl ( byteOrder )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "order    =     ( byteOrder    =  =     ( ByteOrder . BIG _ ENDIAN )  )     ?    Endianness . BIG _ ENDIAN    :    Endianness . LITTLE _ ENDIAN ;", "return   this ;", "}", "METHOD_END"], "methodName": ["orderImpl"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   put ( src ,     0  ,    src . length )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "put ( src [ i ]  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( src    =  =     ( this )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "if    (  ( src . remaining (  )  )     >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "byte [  ]    contents    =    new   byte [ src . remaining (  )  ]  ;", "src . get ( contents )  ;", "put ( contents )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   StringByteBuffer ( s )  ;", "}", "METHOD_END"], "methodName": ["stringToByteBuffer"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buf    =    new   StringBuffer (  )  ;", "buf . append ( getClass (  )  . getName (  )  )  ;", "buf . append (  \"  ,    status :    capacity =  \"  )  ;", "buf . append ( capacity (  )  )  ;", "buf . append (  \"    position =  \"  )  ;", "buf . append ( position (  )  )  ;", "buf . append (  \"    limit =  \"  )  ;", "buf . append ( limit (  )  )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   BufferFactory . newByteBuffer ( array )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    array . length ;", "if    (  (  ( start    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( start )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "buf    =    BufferFactory . new ( array )  ;", "buf . position    =    start ;", "buf . limit    =    start    +    len ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.ByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ByteOrder . NATIVE _ ORDER ;", "}", "METHOD_END"], "methodName": ["nativeOrder"], "fileName": "java.nio.ByteOrder"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.nio.ByteOrder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   UnderflowException (  )  ;", "}", "return   backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.CharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "System . arraycopy ( backingArray ,     (  ( offset )     +     ( position )  )  ,    dest ,    off ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.CharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "return   backing [  (  ( offset )     +    index )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.CharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirect"], "fileName": "java.nio.CharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ByteOrder . nativeOrder (  )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "java.nio.CharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( start    <     0  )     |  |     ( end    <    start )  )     |  |     ( end    >     ( remaining (  )  )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "Char   result    =    duplicate (  )  ;", "result . limit (  (  ( position )     +    end )  )  ;", "result . position (  (  ( position )     +    start )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["subSequence"], "fileName": "java.nio.CharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   String . copyValueOf ( backingArray ,     (  ( offset )     +     ( position )  )  ,    remaining (  )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.nio.CharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( capacity    <     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "return   BufferFactory . new ( capacity )  ;", "}", "METHOD_END"], "methodName": ["allocate"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   put ( c )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( csq    !  =    null )     {", "return   put ( csq . toString (  )  )  ;", "}", "return   put (  \" null \"  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( csq    =  =    null )     {", "csq    =     \" null \"  ;", "}", "Sequence   cs    =    csq . subSequence ( start ,    end )  ;", "if    (  ( cs . length (  )  )     >     0  )     {", "return   put ( cs . toString (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArray (  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArrayOffset (  )  ;", "}", "METHOD_END"], "methodName": ["arrayOffset"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( remaining (  )  )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "return   get (  (  ( position )     +    index )  )  ;", "}", "METHOD_END"], "methodName": ["charAt"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "int   compareRemaining    =     (  ( remaining (  )  )     <     ( otherBuffer . remaining (  )  )  )     ?    remaining (  )     :    otherBuffer . remaining (  )  ;", "int   thisPos    =    position ;", "int   otherPos    =    otherBuffer . position ;", "char   thisByte ;", "char   otherByte ;", "while    ( compareRemaining    >     0  )     {", "thisByte    =    get ( thisPos )  ;", "otherByte    =    otherBuffer . get ( otherPos )  ;", "if    ( thisByte    !  =    otherByte )     {", "return   thisByte    <    otherByte    ?     -  1     :     1  ;", "}", "thisPos +  +  ;", "otherPos +  +  ;", "compareRemaining -  -  ;", "}", "return    ( remaining (  )  )     -     ( otherBuffer . remaining (  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( other   instanceof   CharBuffer )  )     {", "return   false ;", "}", "CharBuffer   otherBuffer    =     (  ( CharBuffer )     ( other )  )  ;", "if    (  ( remaining (  )  )     !  =     ( otherBuffer . remaining (  )  )  )     {", "return   false ;", "}", "int   myPosition    =    position ;", "int   otherPosition    =    otherBuffer . position ;", "boolean   equalSoFar    =    true ;", "while    ( equalSoFar    &  &     ( myPosition    <     ( limit )  )  )     {", "equalSoFar    =     ( get (  ( myPosition +  +  )  )  )     =  =     ( otherBuffer . get (  ( otherPosition +  +  )  )  )  ;", "}", "return   equalSoFar ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   get ( dest ,     0  ,    dest . length )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "dest [ i ]     =    get (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedHasArray (  )  ;", "}", "METHOD_END"], "methodName": ["hasArray"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "int   myPosition    =    position ;", "int   hash    =     0  ;", "while    ( myPosition    <     ( limit )  )     {", "hash    =    hash    +     ( get (  ( myPosition +  +  )  )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   remaining (  )  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   put ( src ,     0  ,    src . length )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "put ( src [ i ]  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   put ( str ,     0  ,    str . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    str . length (  )  ;", "if    (  (  ( start    <     0  )     |  |     ( end    <    start )  )     |  |     ( end    >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    (  ( end    -    start )     >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "for    ( int   i    =    start ;    i    <    end ;    i +  +  )     {", "put ( str . charAt ( i )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( src    =  =     ( this )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "if    (  ( src . remaining (  )  )     >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "char [  ]    contents    =    new   char [ src . remaining (  )  ]  ;", "src . get ( contents )  ;", "put ( contents )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( target    =  =     ( this )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "if    (  ( remaining (  )  )     =  =     0  )     {", "return    ( target . remaining (  )  )     =  =     0     ?     0     :     -  1  ;", "}", "int   result    =    Math . min ( target . remaining (  )  ,    remaining (  )  )  ;", "c [  ]    cs    =    new   c [ result ]  ;", "get ( cs )  ;", "target . put ( cs )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   strbuf    =    new   StringBuffer (  )  ;", "for    ( int   i    =    position ;    i    <     ( limit )  ;    i +  +  )     {", "strbuf . append ( get ( i )  )  ;", "}", "return   strbuf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   CharBuffer . wrap ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    array . length ;", "if    (  (  ( start    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( start )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "buf    =    BufferFactory . new ( array )  ;", "buf . position    =    start ;", "buf . limit    =    start    +    len ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   BufferFactory . newCharBuffer ( chseq )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( chseq    =  =    null )     {", "throw   new   NullPointerException (  )  ;", "}", "if    (  (  ( start    <     0  )     |  |     ( end    <    start )  )     |  |     ( end    >     ( chseq . length (  )  )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "result    =    BufferFactory . new ( chseq )  ;", "result . position    =    start ;", "result . limit    =    end ;", "return   result ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.CharBuffer"}, {"methodBody": ["METHOD_START", "{", "return   duplicate (  )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "CharSequenceAdapter   buf    =    new   CharSequenceAdapter ( other . sequence )  ;", "buf . limit    =    other . limit ;", "buf . position    =    other . position ;", "buf . mark    =    other . mark ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   CharSequenceAdapter . copy ( this )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   BufferUnderflowException (  )  ;", "}", "return   s . charAt (  (  ( position )  +  +  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   BufferUnderflowException (  )  ;", "}", "int   newPosition    =     ( position )     +    len ;", "s . toString (  )  . getChars ( position ,    newPosition ,    dest ,    off )  ;", "position    =    newPosition ;", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "return   s . charAt ( index )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirect"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   ByteOrder . nativeOrder (  )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >     ( src . length )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   BufferOverflowException (  )  ;", "}", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( start    <     0  )     |  |     ( end    <     0  )  )     |  |     (  (  (  ( long )     ( start )  )     +     (  ( long )     ( end )  )  )     >     ( src . length (  )  )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   CharSequenceAdapter ( sequence . subSequence ( position ,    limit )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( end    <    start )     |  |     ( start    <     0  )  )     |  |     ( end    >     ( remaining (  )  )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "result    =     . copy ( this )  ;", "result . position    =     ( position )     +    start ;", "result . limit    =     ( position )     +    end ;", "return   result ;", "}", "METHOD_END"], "methodName": ["subSequence"], "fileName": "java.nio.CharSequenceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   CharToByteBufferAdapter ( byteBuffer . slice (  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.CharToByteBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( byte )     ( byteArray . get (  (  ( position )  +  +  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "dest [  ( i    +    off )  ]     =    get (  (  ( position )     +    i )  )  ;", "}", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    (  ( byte )     ( byteArray . get ( index )  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . longBitsToDouble ( getLong (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDouble"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . longBitsToDouble ( getLong ( index )  )  ;", "}", "METHOD_END"], "methodName": ["getDouble"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    1  ;", "}", "METHOD_END"], "methodName": ["getElementSize"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat ( getInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFloat"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat ( getInt ( index )  )  ;", "}", "METHOD_END"], "methodName": ["getFloat"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     4  ;", "int   result    =    loadInt ( position )  ;", "position    =    newPosition ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getInt"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   loadInt ( index )  ;", "}", "METHOD_END"], "methodName": ["getInt"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     8  ;", "long   result    =    loadLong ( position )  ;", "position    =    newPosition ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getLong"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   loadLong ( index )  ;", "}", "METHOD_END"], "methodName": ["getLong"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     2  ;", "short   result    =    loadShort ( position )  ;", "position    =    newPosition ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getShort"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   loadShort ( index )  ;", "}", "METHOD_END"], "methodName": ["getShort"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   byteArray ;", "}", "METHOD_END"], "methodName": ["getTypedArray"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirect"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   bytes    =     0  ;", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "for    ( int   i    =     0  ;    i    <     4  ;    i +  +  )     {", "bytes    =    bytes    <  <     8  ;", "bytes    =    bytes    |     (  ( byteArray . get (  ( baseOffset    +    i )  )  )     &     2  5  5  )  ;", "}", "} else    {", "for    ( int   i    =     3  ;    i    >  =     0  ;    i -  -  )     {", "bytes    =    bytes    <  <     8  ;", "bytes    =    bytes    |     (  ( byteArray . get (  ( baseOffset    +    i )  )  )     &     2  5  5  )  ;", "}", "}", "return   bytes ;", "}", "METHOD_END"], "methodName": ["loadInt"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "long   bytes    =     0  ;", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "for    ( int   i    =     0  ;    i    <     8  ;    i +  +  )     {", "bytes    =    bytes    <  <     8  ;", "bytes    =    bytes    |     (  ( byteArray . get (  ( baseOffset    +    i )  )  )     &     2  5  5  )  ;", "}", "} else    {", "for    ( int   i    =     7  ;    i    >  =     0  ;    i -  -  )     {", "bytes    =    bytes    <  <     8  ;", "bytes    =    bytes    |     (  ( byteArray . get (  ( baseOffset    +    i )  )  )     &     2  5  5  )  ;", "}", "}", "return   bytes ;", "}", "METHOD_END"], "methodName": ["loadLong"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "short   bytes    =     0  ;", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "bytes    =     (  ( short )     (  ( byteArray . get ( baseOffset )  )     <  <     8  )  )  ;", "bytes    |  =     ( byteArray . get (  ( baseOffset    +     1  )  )  )     &     2  5  5  ;", "} else    {", "bytes    =     (  ( short )     (  ( byteArray . get (  ( baseOffset    +     1  )  )  )     <  <     8  )  )  ;", "bytes    |  =     ( byteArray . get ( baseOffset )  )     &     2  5  5  ;", "}", "return   bytes ;", "}", "METHOD_END"], "methodName": ["loadShort"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "for    ( int   i    =     3  ;    i    >  =     0  ;    i -  -  )     {", "bArray . set (  ( baseOffset    +    i )  ,     (  ( b )     ( value    &     2  5  5  )  )  )  ;", "value    =    value    >  >     8  ;", "}", "} else    {", "for    ( int   i    =     0  ;    i    <  =     3  ;    i +  +  )     {", "bArray . set (  ( baseOffset    +    i )  ,     (  ( b )     ( value    &     2  5  5  )  )  )  ;", "value    =    value    >  >     8  ;", "}", "}", "}", "METHOD_END"], "methodName": ["store"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "for    ( int   i    =     7  ;    i    >  =     0  ;    i -  -  )     {", "bArray . set (  ( baseOffset    +    i )  ,     (  ( b )     ( value    &     2  5  5  )  )  )  ;", "value    =    value    >  >     8  ;", "}", "} else    {", "for    ( int   i    =     0  ;    i    <  =     7  ;    i +  +  )     {", "bArray . set (  ( baseOffset    +    i )  ,     (  ( b )     ( value    &     2  5  5  )  )  )  ;", "value    =    value    >  >     8  ;", "}", "}", "}", "METHOD_END"], "methodName": ["store"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "bArray . set ( baseOffset ,     (  ( b )     (  ( value    >  >     8  )     &     2  5  5  )  )  )  ;", "bArray . set (  ( baseOffset    +     1  )  ,     (  ( b )     ( value    &     2  5  5  )  )  )  ;", "} else    {", "bArray . set (  ( baseOffset    +     1  )  ,     (  ( b )     (  ( value    >  >     8  )     &     2  5  5  )  )  )  ;", "bArray . set ( baseOffset ,     (  ( b )     ( value    &     2  5  5  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["store"], "fileName": "java.nio.DirectByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   DirectReadOnlyFloatBufferAdapter . wrap ( this )  ;", "}", "METHOD_END"], "methodName": ["asFloatBuffer"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    ( order (  )  )     =  =     ( ByteOrder . nativeOrder (  )  )     ?    DirectReadOnlyIntBufferAdapter . wrap ( this )     :    super . asIntBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["asIntBuffer"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   DirectReadOnlyByteBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    ( order (  )  )     =  =     ( ByteOrder . nativeOrder (  )  )     ?    DirectReadOnlyShortBufferAdapter . wrap ( this )     :    super . asShortBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["asShortBuffer"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "DirectReadOnlyByteBuffer   buf    =    new   DirectReadOnlyByteBuffer ( other . byteArray . buffer (  )  ,    other . capacity (  )  ,    other . byteArray . byteOffset (  )  )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "buf . order ( other . order (  )  )  ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   DirectReadOnlyByteBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putDouble"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putDouble"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putFloat"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putFloat"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putInt"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putInt"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putLong"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putLong"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putShort"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putShort"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "DirectReadOnlyByteBuffer   slice    =    new   DirectReadOnlyByteBuffer ( byteArray . buffer (  )  ,    remaining (  )  ,     (  ( byteArray . byteOffset (  )  )     +     ( position )  )  )  ;", "slice . order    =    order ;", "return   slice ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.DirectReadOnlyByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    4  ;", "}", "METHOD_END"], "methodName": ["getElementSize"], "fileName": "java.nio.DirectReadOnlyFloatBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   floatArray ;", "}", "METHOD_END"], "methodName": ["getTypedArray"], "fileName": "java.nio.DirectReadOnlyFloatBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectReadOnlyFloatBufferAdapter (  (  ( DirectByteBuffer )     ( byteBuffer . slice (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.DirectReadOnlyFloatBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return    4  ;", "}", "METHOD_END"], "methodName": ["getElementSize"], "fileName": "java.nio.DirectReadOnlyIntBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   intArray ;", "}", "METHOD_END"], "methodName": ["getTypedArray"], "fileName": "java.nio.DirectReadOnlyIntBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectReadOnlyIntBufferAdapter (  (  ( DirectByteBuffer )     ( byteBuffer . slice (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.DirectReadOnlyIntBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return    2  ;", "}", "METHOD_END"], "methodName": ["getElementSize"], "fileName": "java.nio.DirectReadOnlyShortBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   shortArray ;", "}", "METHOD_END"], "methodName": ["getTypedArray"], "fileName": "java.nio.DirectReadOnlyShortBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectReadOnlyShortBufferAdapter (  (  ( DirectByteBuffer )     ( byteBuffer . slice (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.DirectReadOnlyShortBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   DirectReadWriteFloatBufferAdapter . wrap ( this )  ;", "}", "METHOD_END"], "methodName": ["asFloatBuffer"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    ( order (  )  )     =  =     ( ByteOrder . nativeOrder (  )  )     ?    DirectReadWriteIntBufferAdapter . wrap ( this )     :    super . asIntBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["asIntBuffer"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   DirectReadOnlyByteBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    ( order (  )  )     =  =     ( ByteOrder . nativeOrder (  )  )     ?    DirectReadWriteShortBufferAdapter . wrap ( this )     :    super . asShortBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["asShortBuffer"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   rem    =    remaining (  )  ;", "for    ( int   i    =     0  ;    i    <    rem ;    i +  +  )     {", "byteArray . set ( i ,    byteArray . get (  (  ( position )     +    i )  )  )  ;", "}", "position    =     ( limit )     -     ( position )  ;", "limit    =    capacity ;", "mark    =     . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "DirectReadWriteByteBuffer   buf    =    new   DirectReadWriteByteBuffer ( other . byteArray . buffer (  )  ,    other . capacity (  )  ,    other . byteArray . byteOffset (  )  )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "buf . order ( other . order (  )  )  ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   DirectReadWriteByteBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "byteArray . set (  (  ( position )  +  +  )  ,    b )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >     ( src . length )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "if    ( isReadOnly (  )  )     {", "throw   new   ReadOnlyException (  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "byteArray . set (  ( i    +     ( position )  )  ,    src [  ( off    +    i )  ]  )  ;", "}", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "byteArray . set ( index ,    b )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putLong ( Numbers . doubleToRawLongBits ( value )  )  ;", "}", "METHOD_END"], "methodName": ["putDouble"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putLong ( index ,    Numbers . doubleToRawLongBits ( value )  )  ;", "}", "METHOD_END"], "methodName": ["putDouble"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putInt ( Numbers . floatToIntBits ( value )  )  ;", "}", "METHOD_END"], "methodName": ["putFloat"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putInt ( index ,    Numbers . floatToIntBits ( value )  )  ;", "}", "METHOD_END"], "methodName": ["putFloat"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     4  ;", "store ( position ,    value )  ;", "position    =    newPosition ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putInt"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "store ( index ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putInt"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "store ( index ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putLong"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     8  ;", "store ( position ,    value )  ;", "position    =    newPosition ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putLong"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "store ( index ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putShort"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     2  ;", "store ( position ,    value )  ;", "position    =    newPosition ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putShort"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "DirectReadWriteByteBuffer   slice    =    new   DirectReadWriteByteBuffer ( byteArray . buffer (  )  ,    remaining (  )  ,     (  ( byteArray . byteOffset (  )  )     +     ( position )  )  )  ;", "slice . order    =    order ;", "return   slice ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.DirectReadWriteByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return    4  ;", "}", "METHOD_END"], "methodName": ["getElementSize"], "fileName": "java.nio.DirectReadWriteFloatBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   floatArray ;", "}", "METHOD_END"], "methodName": ["getTypedArray"], "fileName": "java.nio.DirectReadWriteFloatBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectReadWriteFloatBufferAdapter (  (  ( DirectReadWriteByteBuffer )     ( byteBuffer . slice (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.DirectReadWriteFloatBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return    4  ;", "}", "METHOD_END"], "methodName": ["getElementSize"], "fileName": "java.nio.DirectReadWriteIntBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   intArray ;", "}", "METHOD_END"], "methodName": ["getTypedArray"], "fileName": "java.nio.DirectReadWriteIntBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectReadWriteIntBufferAdapter (  (  ( DirectReadWriteByteBuffer )     ( byteBuffer . slice (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.DirectReadWriteIntBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return    2  ;", "}", "METHOD_END"], "methodName": ["getElementSize"], "fileName": "java.nio.DirectReadWriteShortBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   shortArray ;", "}", "METHOD_END"], "methodName": ["getTypedArray"], "fileName": "java.nio.DirectReadWriteShortBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectReadWriteShortBufferAdapter (  (  ( DirectReadWriteByteBuffer )     ( byteBuffer . slice (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.DirectReadWriteShortBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   UnderflowException (  )  ;", "}", "return   backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.DoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "System . arraycopy ( backingArray ,     (  ( offset )     +     ( position )  )  ,    dest ,    off ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.DoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "return   backing [  (  ( offset )     +    index )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.DoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirect"], "fileName": "java.nio.DoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ByteOrder . nativeOrder (  )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "java.nio.DoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( capacity    <     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "return   BufferFactory . new ( capacity )  ;", "}", "METHOD_END"], "methodName": ["allocate"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArray (  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArrayOffset (  )  ;", "}", "METHOD_END"], "methodName": ["arrayOffset"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "int   compareRemaining    =     (  ( remaining (  )  )     <     ( otherBuffer . remaining (  )  )  )     ?    remaining (  )     :    otherBuffer . remaining (  )  ;", "int   thisPos    =    position ;", "int   otherPos    =    otherBuffer . position ;", "double   thisDouble ;", "double   otherDouble ;", "while    ( compareRemaining    >     0  )     {", "thisDouble    =    get ( thisPos )  ;", "otherDouble    =    otherBuffer . get ( otherPos )  ;", "if    (  ( thisDouble    !  =    otherDouble )     &  &     (  ( thisDouble    =  =    thisDouble )     |  |     ( otherDouble    =  =    otherDouble )  )  )     {", "return   thisDouble    <    otherDouble    ?     -  1     :     1  ;", "}", "thisPos +  +  ;", "otherPos +  +  ;", "compareRemaining -  -  ;", "}", "return    ( remaining (  )  )     -     ( otherBuffer . remaining (  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( other   instanceof   DoubleBuffer )  )     {", "return   false ;", "}", "DoubleBuffer   otherBuffer    =     (  ( DoubleBuffer )     ( other )  )  ;", "if    (  ( remaining (  )  )     !  =     ( otherBuffer . remaining (  )  )  )     {", "return   false ;", "}", "int   myPosition    =    position ;", "int   otherPosition    =    otherBuffer . position ;", "boolean   equalSoFar    =    true ;", "while    ( equalSoFar    &  &     ( myPosition    <     ( limit )  )  )     {", "equalSoFar    =     ( get (  ( myPosition +  +  )  )  )     =  =     ( otherBuffer . get (  ( otherPosition +  +  )  )  )  ;", "}", "return   equalSoFar ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "return   get ( dest ,     0  ,    dest . length )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "dest [ i ]     =    get (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedHasArray (  )  ;", "}", "METHOD_END"], "methodName": ["hasArray"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "return   put ( src ,     0  ,    src . length )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "put ( src [ i ]  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( src    =  =     ( this )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "if    (  ( src . remaining (  )  )     >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "double [  ]    doubles    =    new   double [ src . remaining (  )  ]  ;", "src . get ( doubles )  ;", "put ( doubles )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buf    =    new   StringBuffer (  )  ;", "buf . append ( getClass (  )  . getName (  )  )  ;", "buf . append (  \"  ,    status :    capacity =  \"  )  ;", "buf . append ( capacity (  )  )  ;", "buf . append (  \"    position =  \"  )  ;", "buf . append ( position (  )  )  ;", "buf . append (  \"    limit =  \"  )  ;", "buf . append ( limit (  )  )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "return   DoubleBuffer . wrap ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    array . length ;", "if    (  (  ( start    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( start )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "buf    =    BufferFactory . new ( array )  ;", "buf . position    =    start ;", "buf . limit    =    start    +    len ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.DoubleBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   DoubleToByteBufferAdapter ( byteBuffer . slice (  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.DoubleToByteBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   UnderflowException (  )  ;", "}", "return   backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.FloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "System . arraycopy ( backingArray ,     (  ( offset )     +     ( position )  )  ,    dest ,    off ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.FloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "return   backing [  (  ( offset )     +    index )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.FloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirect"], "fileName": "java.nio.FloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ByteOrder . nativeOrder (  )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "java.nio.FloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( capacity    <     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "return   BufferFactory . new ( capacity )  ;", "}", "METHOD_END"], "methodName": ["allocate"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArray (  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArrayOffset (  )  ;", "}", "METHOD_END"], "methodName": ["arrayOffset"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "int   compareRemaining    =     (  ( remaining (  )  )     <     ( otherBuffer . remaining (  )  )  )     ?    remaining (  )     :    otherBuffer . remaining (  )  ;", "int   thisPos    =    position ;", "int   otherPos    =    otherBuffer . position ;", "float   thisFloat ;", "float   otherFloat ;", "while    ( compareRemaining    >     0  )     {", "thisFloat    =    get ( thisPos )  ;", "otherFloat    =    otherBuffer . get ( otherPos )  ;", "if    (  ( thisFloat    !  =    otherFloat )     &  &     (  ( thisFloat    =  =    thisFloat )     |  |     ( otherFloat    =  =    otherFloat )  )  )     {", "return   thisFloat    <    otherFloat    ?     -  1     :     1  ;", "}", "thisPos +  +  ;", "otherPos +  +  ;", "compareRemaining -  -  ;", "}", "return    ( remaining (  )  )     -     ( otherBuffer . remaining (  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( other   instanceof   FloatBuffer )  )     {", "return   false ;", "}", "FloatBuffer   otherBuffer    =     (  ( FloatBuffer )     ( other )  )  ;", "if    (  ( remaining (  )  )     !  =     ( otherBuffer . remaining (  )  )  )     {", "return   false ;", "}", "int   myPosition    =    position ;", "int   otherPosition    =    otherBuffer . position ;", "boolean   equalSoFar    =    true ;", "while    ( equalSoFar    &  &     ( myPosition    <     ( limit )  )  )     {", "equalSoFar    =     ( get (  ( myPosition +  +  )  )  )     =  =     ( otherBuffer . get (  ( otherPosition +  +  )  )  )  ;", "}", "return   equalSoFar ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "return   get ( dest ,     0  ,    dest . length )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "dest [ i ]     =    get (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedHasArray (  )  ;", "}", "METHOD_END"], "methodName": ["hasArray"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "return   put ( src ,     0  ,    src . length )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "put ( src [ i ]  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( src    =  =     ( this )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "if    (  ( src . remaining (  )  )     >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "float [  ]    contents    =    new   float [ src . remaining (  )  ]  ;", "src . get ( contents )  ;", "put ( contents )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buf    =    new   StringBuffer (  )  ;", "buf . append ( getClass (  )  . getName (  )  )  ;", "buf . append (  \"  ,    status :    capacity =  \"  )  ;", "buf . append ( capacity (  )  )  ;", "buf . append (  \"    position =  \"  )  ;", "buf . append ( position (  )  )  ;", "buf . append (  \"    limit =  \"  )  ;", "buf . append ( limit (  )  )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "return   FloatBuffer . wrap ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "throw   new   NullPointerException (  )  ;", "}", "if    (  (  ( start    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( start )  )     +     (  ( long )     ( len )  )  )     >     ( array . length )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "buf    =    BufferFactory . new ( array )  ;", "buf . position    =    start ;", "buf . limit    =    start    +    len ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.FloatBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   FloatToByteBufferAdapter ( byteBuffer . slice (  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.FloatToByteBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   UnderflowException (  )  ;", "}", "return   backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "System . arraycopy ( backingArray ,     (  ( offset )     +     ( position )  )  ,    dest ,    off ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsExceptn (  )  ;", "}", "return   backingArray [  (  ( offset )     +    index )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . longBitsToDouble ( getLong (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDouble"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . longBitsToDouble ( getLong ( index )  )  ;", "}", "METHOD_END"], "methodName": ["getDouble"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat ( getInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFloat"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat ( getInt ( index )  )  ;", "}", "METHOD_END"], "methodName": ["getFloat"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     4  ;", "if    ( newPosition    >     ( limit )  )     {", "throw   new   UnderflowException (  )  ;", "}", "int   result    =    loadInt ( position )  ;", "position    =    newPosition ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getInt"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     (  ( index    +     4  )     >     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsExceptn (  )  ;", "}", "return   loadInt ( index )  ;", "}", "METHOD_END"], "methodName": ["getInt"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     8  ;", "if    ( newPosition    >     ( limit )  )     {", "throw   new   UnderflowException (  )  ;", "}", "long   result    =    loadLong ( position )  ;", "position    =    newPosition ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getLong"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     (  ( index    +     8  )     >     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsExceptn (  )  ;", "}", "return   loadLong ( index )  ;", "}", "METHOD_END"], "methodName": ["getLong"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     2  ;", "if    ( newPosition    >     ( limit )  )     {", "throw   new   UnderflowException (  )  ;", "}", "short   result    =    loadShort ( position )  ;", "position    =    newPosition ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getShort"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     (  ( index    +     2  )     >     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsExceptn (  )  ;", "}", "return   loadShort ( index )  ;", "}", "METHOD_END"], "methodName": ["getShort"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirect"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   baseOffset    =     ( offset )     +    index ;", "int   bs    =     0  ;", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "for    ( int   i    =     0  ;    i    <     4  ;    i +  +  )     {", "bs    =    bs    <  <     8  ;", "bs    =    bs    |     (  ( backingArray [  ( baseOffset    +    i )  ]  )     &     2  5  5  )  ;", "}", "} else    {", "for    ( int   i    =     3  ;    i    >  =     0  ;    i -  -  )     {", "bs    =    bs    <  <     8  ;", "bs    =    bs    |     (  ( backingArray [  ( baseOffset    +    i )  ]  )     &     2  5  5  )  ;", "}", "}", "return   bs ;", "}", "METHOD_END"], "methodName": ["loadInt"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   baseOffset    =     ( offset )     +    index ;", "long   bs    =     0  ;", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "for    ( int   i    =     0  ;    i    <     8  ;    i +  +  )     {", "bs    =    bs    <  <     8  ;", "bs    =    bs    |     (  ( backingArray [  ( baseOffset    +    i )  ]  )     &     2  5  5  )  ;", "}", "} else    {", "for    ( int   i    =     7  ;    i    >  =     0  ;    i -  -  )     {", "bs    =    bs    <  <     8  ;", "bs    =    bs    |     (  ( backingArray [  ( baseOffset    +    i )  ]  )     &     2  5  5  )  ;", "}", "}", "return   bs ;", "}", "METHOD_END"], "methodName": ["loadLong"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   baseOffset    =     ( offset )     +    index ;", "short   bs    =     0  ;", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "bs    =     (  ( short )     (  ( backingArray [ baseOffset ]  )     <  <     8  )  )  ;", "bs    |  =     ( backingArray [  ( baseOffset    +     1  )  ]  )     &     2  5  5  ;", "} else    {", "bs    =     (  ( short )     (  ( backingArray [  ( baseOffset    +     1  )  ]  )     <  <     8  )  )  ;", "bs    |  =     ( backingArray [ baseOffset ]  )     &     2  5  5  ;", "}", "return   bs ;", "}", "METHOD_END"], "methodName": ["loadShort"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   baseOffset    =     ( offset )     +    index ;", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "for    ( int   i    =     3  ;    i    >  =     0  ;    i -  -  )     {", "backingArray [  ( baseOffset    +    i )  ]     =     (  ( b )     ( value    &     2  5  5  )  )  ;", "value    =    value    >  >     8  ;", "}", "} else    {", "for    ( int   i    =     0  ;    i    <  =     3  ;    i +  +  )     {", "backingArray [  ( baseOffset    +    i )  ]     =     (  ( b )     ( value    &     2  5  5  )  )  ;", "value    =    value    >  >     8  ;", "}", "}", "}", "METHOD_END"], "methodName": ["store"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   baseOffset    =     ( offset )     +    index ;", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "for    ( int   i    =     7  ;    i    >  =     0  ;    i -  -  )     {", "backingArray [  ( baseOffset    +    i )  ]     =     (  ( b )     ( value    &     2  5  5  )  )  ;", "value    =    value    >  >     8  ;", "}", "} else    {", "for    ( int   i    =     0  ;    i    <  =     7  ;    i +  +  )     {", "backingArray [  ( baseOffset    +    i )  ]     =     (  ( b )     ( value    &     2  5  5  )  )  ;", "value    =    value    >  >     8  ;", "}", "}", "}", "METHOD_END"], "methodName": ["store"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   baseOffset    =     ( offset )     +    index ;", "if    (  ( order )     =  =     ( Endianness . BIG _ ENDIAN )  )     {", "backingArray [ baseOffset ]     =     (  ( b )     (  ( value    >  >     8  )     &     2  5  5  )  )  ;", "backingArray [  ( baseOffset    +     1  )  ]     =     (  ( b )     ( value    &     2  5  5  )  )  ;", "} else    {", "backingArray [  ( baseOffset    +     1  )  ]     =     (  ( b )     (  ( value    >  >     8  )     &     2  5  5  )  )  ;", "backingArray [ baseOffset ]     =     (  ( b )     ( value    &     2  5  5  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["store"], "fileName": "java.nio.HeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   UnderflowException (  )  ;", "}", "return   backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.IntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "return   backing [  (  ( offset )     +    index )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.IntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( len )  )     +     (  ( long )     ( off )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "System . arraycopy ( backingArray ,     (  ( offset )     +     ( position )  )  ,    dest ,    off ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.IntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirect"], "fileName": "java.nio.IntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ByteOrder . nativeOrder (  )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "java.nio.IntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( capacity    <     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "return   BufferFactory . new ( capacity )  ;", "}", "METHOD_END"], "methodName": ["allocate"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArray (  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArrayOffset (  )  ;", "}", "METHOD_END"], "methodName": ["arrayOffset"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "int   compareRemaining    =     (  ( remaining (  )  )     <     ( otherBuffer . remaining (  )  )  )     ?    remaining (  )     :    otherBuffer . remaining (  )  ;", "int   thisPos    =    position ;", "int   otherPos    =    otherBuffer . position ;", "int   thisInt ;", "int   otherInt ;", "while    ( compareRemaining    >     0  )     {", "thisInt    =    get ( thisPos )  ;", "otherInt    =    otherBuffer . get ( otherPos )  ;", "if    ( thisInt    !  =    otherInt )     {", "return   thisInt    <    otherInt    ?     -  1     :     1  ;", "}", "thisPos +  +  ;", "otherPos +  +  ;", "compareRemaining -  -  ;", "}", "return    ( remaining (  )  )     -     ( otherBuffer . remaining (  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( other   instanceof   IntBuffer )  )     {", "return   false ;", "}", "IntBuffer   otherBuffer    =     (  ( IntBuffer )     ( other )  )  ;", "if    (  ( remaining (  )  )     !  =     ( otherBuffer . remaining (  )  )  )     {", "return   false ;", "}", "int   myPosition    =    position ;", "int   otherPosition    =    otherBuffer . position ;", "boolean   equalSoFar    =    true ;", "while    ( equalSoFar    &  &     ( myPosition    <     ( limit )  )  )     {", "equalSoFar    =     ( get (  ( myPosition +  +  )  )  )     =  =     ( otherBuffer . get (  ( otherPosition +  +  )  )  )  ;", "}", "return   equalSoFar ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "return   get ( dest ,     0  ,    dest . length )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( len )  )     +     (  ( long )     ( off )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "dest [ i ]     =    get (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedHasArray (  )  ;", "}", "METHOD_END"], "methodName": ["hasArray"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "int   myPosition    =    position ;", "int   hash    =     0  ;", "while    ( myPosition    <     ( limit )  )     {", "hash    =    hash    +     ( get (  ( myPosition +  +  )  )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "return   put ( src ,     0  ,    src . length )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( len )  )     +     (  ( long )     ( off )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "put ( src [ i ]  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( src    =  =     ( this )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "if    (  ( src . remaining (  )  )     >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "int [  ]    contents    =    new   int [ src . remaining (  )  ]  ;", "src . get ( contents )  ;", "put ( contents )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buf    =    new   StringBuffer (  )  ;", "buf . append ( getClass (  )  . getName (  )  )  ;", "buf . append (  \"  ,    status :    capacity =  \"  )  ;", "buf . append ( capacity (  )  )  ;", "buf . append (  \"    position =  \"  )  ;", "buf . append ( position (  )  )  ;", "buf . append (  \"    limit =  \"  )  ;", "buf . append ( limit (  )  )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "return   IntBuffer . wrap ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "throw   new   NullPointerException (  )  ;", "}", "if    (  (  ( start    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( len )  )     +     (  ( long )     ( start )  )  )     >     ( array . length )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "buf    =    BufferFactory . new ( array )  ;", "buf . position    =    start ;", "buf . limit    =    start    +    len ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.IntBuffer"}, {"methodBody": ["METHOD_START", "{", "return   byteBuffer ;", "}", "METHOD_END"], "methodName": ["getByteBuffer"], "fileName": "java.nio.IntToByteBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   IntToByteBufferAdapter ( byteBuffer . slice (  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.IntToByteBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   BufferUnderflowException (  )  ;", "}", "return   backi [  (  ( offset )     +     (  ( position )  +  +  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.LongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "return   backi [  (  ( offset )     +    index )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.LongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( len )  )     +     (  ( long )     ( off )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   BufferUnderflowException (  )  ;", "}", "System . arraycopy ( backi ,     (  ( offset )     +     ( position )  )  ,    dest ,    off ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.LongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirect"], "fileName": "java.nio.LongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ByteOrder . nativeOrder (  )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "java.nio.LongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( capacity    <     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "return   BufferFactory . new ( capacity )  ;", "}", "METHOD_END"], "methodName": ["allocate"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArray (  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArrayOffset (  )  ;", "}", "METHOD_END"], "methodName": ["arrayOffset"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "int   compareRemaining    =     (  ( remaining (  )  )     <     ( otherBuffer . remaining (  )  )  )     ?    remaining (  )     :    otherBuffer . remaining (  )  ;", "int   thisPos    =    position ;", "int   otherPos    =    otherBuffer . position ;", "long   thisLong ;", "long   otherLong ;", "while    ( compareRemaining    >     0  )     {", "thisLong    =    get ( thisPos )  ;", "otherLong    =    otherBuffer . get ( otherPos )  ;", "if    ( thisLong    !  =    otherLong )     {", "return   thisLong    <    otherLong    ?     -  1     :     1  ;", "}", "thisPos +  +  ;", "otherPos +  +  ;", "compareRemaining -  -  ;", "}", "return    ( remaining (  )  )     -     ( otherBuffer . remaining (  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( other   instanceof   LongBuffer )  )     {", "return   false ;", "}", "LongBuffer   otherBuffer    =     (  ( LongBuffer )     ( other )  )  ;", "if    (  ( remaining (  )  )     !  =     ( otherBuffer . remaining (  )  )  )     {", "return   false ;", "}", "int   myPosition    =    position ;", "int   otherPosition    =    otherBuffer . position ;", "boolean   equalSoFar    =    true ;", "while    ( equalSoFar    &  &     ( myPosition    <     ( limit )  )  )     {", "equalSoFar    =     ( get (  ( myPosition +  +  )  )  )     =  =     ( otherBuffer . get (  ( otherPosition +  +  )  )  )  ;", "}", "return   equalSoFar ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "return   get ( dest ,     0  ,    dest . length )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( len )  )     +     (  ( long )     ( off )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "dest [ i ]     =    get (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedHasArray (  )  ;", "}", "METHOD_END"], "methodName": ["hasArray"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "int   myPosition    =    position ;", "int   hash    =     0  ;", "l   l ;", "while    ( myPosition    <     ( limit )  )     {", "l    =    get (  ( myPosition +  +  )  )  ;", "hash    =     ( hash    +     (  ( int )     ( l )  )  )     ^     (  ( int )     ( l    >  >     3  2  )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( src    =  =     ( this )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "if    (  ( src . remaining (  )  )     >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "long [  ]    contents    =    new   long [ src . remaining (  )  ]  ;", "src . get ( contents )  ;", "put ( contents )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "return   put ( src ,     0  ,    src . length )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( len )  )     +     (  ( long )     ( off )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "put ( src [ i ]  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buf    =    new   StringBuffer (  )  ;", "buf . append ( getClass (  )  . getName (  )  )  ;", "buf . append (  \"  ,    status :    capacity =  \"  )  ;", "buf . append ( capacity (  )  )  ;", "buf . append (  \"    position =  \"  )  ;", "buf . append ( position (  )  )  ;", "buf . append (  \"    limit =  \"  )  ;", "buf . append ( limit (  )  )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "return   LongBuffer . wrap ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "throw   new   NullPointerException (  )  ;", "}", "if    (  (  ( start    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( len )  )     +     (  ( long )     ( start )  )  )     >     ( array . length )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "buf    =    BufferFactory . new ( array )  ;", "buf . position    =    start ;", "buf . limit    =    start    +    len ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.LongBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   LongToByteBufferAdapter ( byteBuffer . slice (  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.LongToByteBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   duplicate (  )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadOnlyCharArrayBuffer   buf    =    new   ReadOnlyCharArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyCharArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( start    <     0  )     |  |     ( end    <     0  )  )     |  |     (  (  (  ( long )     ( start )  )     +     (  ( long )     ( end )  )  )     >     ( src . length (  )  )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "throw   new   BufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadOnlyCharArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadOnlyCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   duplicate (  )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadOnlyDoubleArrayBuffer   buf    =    new   ReadOnlyDoubleArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyDoubleArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadOnlyDoubleArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadOnlyDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   duplicate (  )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadOnlyFloatArrayBuffer   buf    =    new   ReadOnlyFloatArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyFloatArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadOnlyFloatArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadOnlyFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyHeapByteBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadOnlyHeapByteBuffer   buf    =    new   ReadOnlyHeapByteBuffer ( other . backingArray ,    other . capacity (  )  ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "buf . order ( other . order (  )  )  ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyHeapByteBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putDouble"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putDouble"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putFloat"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putFloat"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putInt"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putInt"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putLong"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putLong"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putShort"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["putShort"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadOnlyHeapByteBuffer   slice    =    new   ReadOnlyHeapByteBuffer ( backingArray ,    remaining (  )  ,     (  ( offset )     +     ( position )  )  )  ;", "slice . order    =    order ;", "return   slice ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadOnlyHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   duplicate (  )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadOnlyIntArrayBuffer   buf    =    new   ReadOnlyIntArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyIntArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadOnlyIntArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadOnlyIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   duplicate (  )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadOnlyLongArrayBuffer   buf    =    new   ReadOnlyLongArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyLongArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadOnlyLongArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadOnlyLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   duplicate (  )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadOnlyShortArrayBuffer   buf    =    new   ReadOnlyShortArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyShortArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   ReadOnlyBufferException (  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadOnlyShortArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadOnlyShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyCharArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( backingArray ,     (  ( position )     +     ( offset )  )  ,    backingArray ,    offset ,    remaining (  )  )  ;", "position    =     ( limit )     -     ( position )  ;", "limit    =    capacity ;", "mark    =     . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadWriteCharArrayBuffer   buf    =    new   ReadWriteCharArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadWriteCharArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   backingArray ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   OverflowException (  )  ;", "}", "backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( len )  )     +     (  ( long )     ( off )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "System . arraycopy ( src ,    off ,    backingArray ,     (  ( offset )     +     ( position )  )  ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "backing [  (  ( offset )     +    index )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteCharArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadWriteCharArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyDoubleArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( backingArray ,     (  ( position )     +     ( offset )  )  ,    backingArray ,    offset ,    remaining (  )  )  ;", "position    =     ( limit )     -     ( position )  ;", "limit    =    capacity ;", "mark    =     . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadWriteDoubleArrayBuffer   buf    =    new   ReadWriteDoubleArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadWriteDoubleArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   backingArray ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   OverflowException (  )  ;", "}", "backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "System . arraycopy ( src ,    off ,    backingArray ,     (  ( offset )     +     ( position )  )  ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "backing [  (  ( offset )     +    index )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteDoubleArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadWriteDoubleArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyFloatArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( position )     +     ( offset )  ,    j    =    offset ,    k    =     0  ;    k    <     ( remaining (  )  )  ;    i +  +     ,    j +  +     ,    k +  +  )     {", "backingArray [ j ]     =    backingArray [ i ]  ;", "}", "position    =     ( limit )     -     ( position )  ;", "limit    =    capacity ;", "mark    =     . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadWriteFloatArrayBuffer   buf    =    new   ReadWriteFloatArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadWriteFloatArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   backingArray ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   OverflowException (  )  ;", "}", "backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "System . arraycopy ( src ,    off ,    backingArray ,     (  ( offset )     +     ( position )  )  ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "backing [  (  ( offset )     +    index )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteFloatArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadWriteFloatArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyHeapByteBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( backingArray ,     (  ( position )     +     ( offset )  )  ,    backingArray ,    offset ,    remaining (  )  )  ;", "position    =     ( limit )     -     ( position )  ;", "limit    =    capacity ;", "mark    =     . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadWriteHeapByteBuffer   buf    =    new   ReadWriteHeapByteBuffer ( other . backingArray ,    other . capacity (  )  ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "buf . order ( other . order (  )  )  ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadWriteHeapByteBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   backingArray ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   OverflowException (  )  ;", "}", "backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]     =    b ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >     ( src . length )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "if    ( isReadOnly (  )  )     {", "throw   new   ReadOnlyException (  )  ;", "}", "System . arraycopy ( src ,    off ,    backingArray ,     (  ( offset )     +     ( position )  )  ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "backingArray [  (  ( offset )     +    index )  ]     =    b ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putLong ( Numbers . doubleToRawLongBits ( value )  )  ;", "}", "METHOD_END"], "methodName": ["putDouble"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putLong ( index ,    Numbers . doubleToRawLongBits ( value )  )  ;", "}", "METHOD_END"], "methodName": ["putDouble"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putInt ( Numbers . floatToIntBits ( value )  )  ;", "}", "METHOD_END"], "methodName": ["putFloat"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   putInt ( index ,    Numbers . floatToIntBits ( value )  )  ;", "}", "METHOD_END"], "methodName": ["putFloat"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     4  ;", "if    ( newPosition    >     ( limit )  )     {", "throw   new   OverflowException (  )  ;", "}", "store ( position ,    value )  ;", "position    =    newPosition ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putInt"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     (  (  (  ( long )     ( index )  )     +     4  )     >     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "store ( index ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putInt"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     (  (  (  ( long )     ( index )  )     +     8  )     >     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "store ( index ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putLong"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     8  ;", "if    ( newPosition    >     ( limit )  )     {", "throw   new   OverflowException (  )  ;", "}", "store ( position ,    value )  ;", "position    =    newPosition ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putLong"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     (  (  (  ( long )     ( index )  )     +     2  )     >     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "store ( index ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putShort"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     2  ;", "if    ( newPosition    >     ( limit )  )     {", "throw   new   OverflowException (  )  ;", "}", "store ( position ,    value )  ;", "position    =    newPosition ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putShort"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadWriteHeapByteBuffer   slice    =    new   ReadWriteHeapByteBuffer ( backingArray ,    remaining (  )  ,     (  ( offset )     +     ( position )  )  )  ;", "slice . order    =    order ;", "return   slice ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadWriteHeapByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyIntArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( backingArray ,     (  ( position )     +     ( offset )  )  ,    backingArray ,    offset ,    remaining (  )  )  ;", "position    =     ( limit )     -     ( position )  ;", "limit    =    capacity ;", "mark    =     . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadWriteIntArrayBuffer   buf    =    new   ReadWriteIntArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadWriteIntArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   backingArray ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   OverflowException (  )  ;", "}", "backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "backing [  (  ( offset )     +    index )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "System . arraycopy ( src ,    off ,    backingArray ,     (  ( offset )     +     ( position )  )  ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteIntArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadWriteIntArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyLongArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( backingArray ,     (  ( position )     +     ( offset )  )  ,    backingArray ,    offset ,    remaining (  )  )  ;", "position    =     ( limit )     -     ( position )  ;", "limit    =    capacity ;", "mark    =    Buffer . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadWriteLongArrayBuffer   buf    =    new   ReadWriteLongArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadWriteLongArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   backingArray ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "backi [  (  ( offset )     +    index )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   BufferOverflowException (  )  ;", "}", "backi [  (  ( offset )     +     (  ( position )  +  +  )  )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   BufferOverflowException (  )  ;", "}", "System . arraycopy ( src ,    off ,    backi ,     (  ( offset )     +     ( position )  )  ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteLongArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadWriteLongArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadOnlyShortArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "System . arraycopy ( backingArray ,     (  ( position )     +     ( offset )  )  ,    backingArray ,    offset ,    remaining (  )  )  ;", "position    =     ( limit )     -     ( position )  ;", "limit    =    capacity ;", "mark    =     . UNSET _ MARK ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compact"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "ReadWriteShortArrayBuffer   buf    =    new   ReadWriteShortArrayBuffer ( other . capacity (  )  ,    other . backingArray ,    other . offset )  ;", "buf . limit    =    other . limit (  )  ;", "buf . position    =    other . position (  )  ;", "buf . mark    =    markOfOther ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ReadWriteShortArrayBuffer . copy ( this ,    mark )  ;", "}", "METHOD_END"], "methodName": ["duplicate"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   backingArray ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "backing [  (  ( offset )     +    index )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   OverflowException (  )  ;", "}", "backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]     =    c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "System . arraycopy ( src ,    off ,    backingArray ,     (  ( offset )     +     ( position )  )  ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   ReadWriteShortArrayBuffer ( remaining (  )  ,    backingArray ,     (  ( offset )     +     ( position )  )  )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "java.nio.ReadWriteShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( limit )  )     {", "throw   new   UnderflowException (  )  ;", "}", "return   backingArray [  (  ( offset )     +     (  ( position )  +  +  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.ShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( limit )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "return   backing [  (  ( offset )     +    index )  ]  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.ShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "System . arraycopy ( backingArray ,     (  ( offset )     +     ( position )  )  ,    dest ,    off ,    len )  ;", "position    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.ShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isDirect"], "fileName": "java.nio.ShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ByteOrder . nativeOrder (  )  ;", "}", "METHOD_END"], "methodName": ["order"], "fileName": "java.nio.ShortArrayBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( capacity    <     0  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "return   BufferFactory . new ( capacity )  ;", "}", "METHOD_END"], "methodName": ["allocate"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArray (  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedArrayOffset (  )  ;", "}", "METHOD_END"], "methodName": ["arrayOffset"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "int   compareRemaining    =     (  ( remaining (  )  )     <     ( otherBuffer . remaining (  )  )  )     ?    remaining (  )     :    otherBuffer . remaining (  )  ;", "int   thisPos    =    position ;", "int   otherPos    =    otherBuffer . position ;", "short   thisByte ;", "short   otherByte ;", "while    ( compareRemaining    >     0  )     {", "thisByte    =    get ( thisPos )  ;", "otherByte    =    otherBuffer . get ( otherPos )  ;", "if    ( thisByte    !  =    otherByte )     {", "return   thisByte    <    otherByte    ?     -  1     :     1  ;", "}", "thisPos +  +  ;", "otherPos +  +  ;", "compareRemaining -  -  ;", "}", "return    ( remaining (  )  )     -     ( otherBuffer . remaining (  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( other   instanceof   ShortBuffer )  )     {", "return   false ;", "}", "ShortBuffer   otherBuffer    =     (  ( ShortBuffer )     ( other )  )  ;", "if    (  ( remaining (  )  )     !  =     ( otherBuffer . remaining (  )  )  )     {", "return   false ;", "}", "int   myPosition    =    position ;", "int   otherPosition    =    otherBuffer . position ;", "boolean   equalSoFar    =    true ;", "while    ( equalSoFar    &  &     ( myPosition    <     ( limit )  )  )     {", "equalSoFar    =     ( get (  ( myPosition +  +  )  )  )     =  =     ( otherBuffer . get (  ( otherPosition +  +  )  )  )  ;", "}", "return   equalSoFar ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "return   get ( dest ,     0  ,    dest . length )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    dest . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   UnderflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "dest [ i ]     =    get (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "return   protectedHasArray (  )  ;", "}", "METHOD_END"], "methodName": ["hasArray"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "int   myPosition    =    position ;", "int   hash    =     0  ;", "while    ( myPosition    <     ( limit )  )     {", "hash    =    hash    +     ( get (  ( myPosition +  +  )  )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( src    =  =     ( this )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "if    (  ( src . remaining (  )  )     >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "short [  ]    contents    =    new   short [ src . remaining (  )  ]  ;", "src . get ( contents )  ;", "put ( contents )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "return   put ( src ,     0  ,    src . length )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    src . length ;", "if    (  (  ( off    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( off )  )     +     (  ( long )     ( len )  )  )     >    length )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "if    ( len    >     ( remaining (  )  )  )     {", "throw   new   OverflowException (  )  ;", "}", "for    ( int   i    =    off ;    i    <     ( off    +    len )  ;    i +  +  )     {", "put ( src [ i ]  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buf    =    new   StringBuffer (  )  ;", "buf . append ( getClass (  )  . getName (  )  )  ;", "buf . append (  \"  ,    status :    capacity =  \"  )  ;", "buf . append ( capacity (  )  )  ;", "buf . append (  \"    position =  \"  )  ;", "buf . append ( position (  )  )  ;", "buf . append (  \"    limit =  \"  )  ;", "buf . append ( limit (  )  )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "return   ShortBuffer . wrap ( array ,     0  ,    array . length )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "throw   new   NullPointerException (  )  ;", "}", "if    (  (  ( start    <     0  )     |  |     ( len    <     0  )  )     |  |     (  (  (  ( long )     ( start )  )     +     (  ( long )     ( len )  )  )     >     ( array . length )  )  )     {", "throw   new   IndexOutOfBoundsException (  )  ;", "}", "buf    =    BufferFactory . new ( array )  ;", "buf . position    =    start ;", "buf . limit    =    start    +    len ;", "return   buf ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.ShortBuffer"}, {"methodBody": ["METHOD_START", "{", "return   byteBuffer ;", "}", "METHOD_END"], "methodName": ["getByteBuffer"], "fileName": "java.nio.ShortToByteBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   ShortToByteBufferAdapter ( byteBuffer . slice (  )  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "java.nio.ShortToByteBufferAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["asReadOnlyBuffer"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . longBitsToDouble ( getLong (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDouble"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . longBitsToDouble ( getLong ( index )  )  ;", "}", "METHOD_END"], "methodName": ["getDouble"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat ( getInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFloat"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   Numbers . intBitsToFloat ( getInt ( index )  )  ;", "}", "METHOD_END"], "methodName": ["getFloat"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     4  ;", "int   result    =    loadInt ( position )  ;", "position    =    newPosition ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getInt"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   loadInt ( index )  ;", "}", "METHOD_END"], "methodName": ["getInt"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getLong"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getLong"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   newPosition    =     ( position )     +     2  ;", "short   result    =    loadShort ( position )  ;", "position    =    newPosition ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getShort"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   loadShort ( index )  ;", "}", "METHOD_END"], "methodName": ["getShort"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "int   bytes    =     0  ;", "for    ( int   i    =     3  ;    i    >  =     0  ;    i -  -  )     {", "bytes    =    bytes    <  <     8  ;", "bytes    =    bytes    |     (  ( get (  ( baseOffset    +    i )  )  )     &     2  5  5  )  ;", "}", "return   bytes ;", "}", "METHOD_END"], "methodName": ["loadInt"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "short   bytes    =     0  ;", "bytes    =     (  ( short )     (  ( get (  ( baseOffset    +     1  )  )  )     <  <     8  )  )  ;", "bytes    |  =     ( get ( baseOffset )  )     &     2  5  5  ;", "return   bytes ;", "}", "METHOD_END"], "methodName": ["loadShort"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArray"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedArrayOffset"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["protectedHasArray"], "fileName": "java.nio.StringByteBuffer"}, {"methodBody": ["METHOD_START", "{", "return   permission ;", "}", "METHOD_END"], "methodName": ["getPermission"], "fileName": "java.security.AccessControlException"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "java.security.Permission"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["newPermissionCollection"], "fileName": "java.security.Permission"}, {"methodBody": ["METHOD_START", "{", "return   countryCode ;", "}", "METHOD_END"], "methodName": ["getCountry"], "fileName": "java.util.Locale"}, {"methodBody": ["METHOD_START", "{", "return   Locale . defaultLocale ;", "}", "METHOD_END"], "methodName": ["getDefault"], "fileName": "java.util.Locale"}, {"methodBody": ["METHOD_START", "{", "return   languageCode ;", "}", "METHOD_END"], "methodName": ["getLanguage"], "fileName": "java.util.Locale"}, {"methodBody": ["METHOD_START", "{", "return   variantCode ;", "}", "METHOD_END"], "methodName": ["getVariant"], "fileName": "java.util.Locale"}, {"methodBody": ["METHOD_START", "{", "if    ( locale    =  =    null )     {", "throw   new   NullPointerException (  \" locale    =  =    null \"  )  ;", "}", ". default    =    locale ;", "}", "METHOD_END"], "methodName": ["setDefault"], "fileName": "java.util.Locale"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( languageCode . length (  )  )     =  =     0  )     &  &     (  ( countryCode . length (  )  )     =  =     0  )  )     {", "return    \"  \"  ;", "}", "StringBuilder   result    =    new   StringBuilder (  1  1  )  ;", "result . append ( languageCode )  ;", "if    (  (  ( countryCode . length (  )  )     >     0  )     |  |     (  ( variantCode . length (  )  )     >     0  )  )     {", "result . append (  '  _  '  )  ;", "}", "result . append ( countryCode )  ;", "if    (  ( variantCode . length (  )  )     >     0  )     {", "result . append (  '  _  '  )  ;", "}", "result . append ( variantCode )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toNewString"], "fileName": "java.util.Locale"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "boolean   in    =    false ;", "for    ( int   i    =    position ,    length    =    string . length (  )  ;    i    <    length ;    i +  +  )     {", "if    (  ( delimiters . indexOf ( string . charAt ( i )  ,     0  )  )     >  =     0  )     {", "if    ( returnDelimiters )", "count +  +  ;", "if    ( in )     {", "count +  +  ;", "in    =    false ;", "}", "} else    {", "in    =    true ;", "}", "}", "if    ( in )", "count +  +  ;", "return   count ;", "}", "METHOD_END"], "methodName": ["countTokens"], "fileName": "java.util.StringTokenizer"}, {"methodBody": ["METHOD_START", "{", "return   hasMoreTokens (  )  ;", "}", "METHOD_END"], "methodName": ["hasMoreElements"], "fileName": "java.util.StringTokenizer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( delimiters )     =  =    null )     {", "throw   new   NullPointerException (  \" delimiters    =  =    null \"  )  ;", "}", "int   length    =    s . length (  )  ;", "if    (  ( position )     <    length )     {", "if    ( returnDelimiters )", "return   true ;", "for    ( int   i    =    position ;    i    <    length ;    i +  +  )", "if    (  ( delimiters . indexOf ( s . charAt ( i )  ,     0  )  )     =  =     (  -  1  )  )", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasMoreTokens"], "fileName": "java.util.StringTokenizer"}, {"methodBody": ["METHOD_START", "{", "return   nextToken (  )  ;", "}", "METHOD_END"], "methodName": ["nextElement"], "fileName": "java.util.StringTokenizer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( delimiters )     =  =    null )     {", "throw   new   NullPointerException (  \" delimiters    =  =    null \"  )  ;", "}", "int   i    =    position ;", "int   length    =    string . length (  )  ;", "if    ( i    <    length )     {", "if    ( returnDelimiters )     {", "if    (  ( delimiters . indexOf ( string . charAt ( position )  ,     0  )  )     >  =     0  )", "return    . valueOf ( string . charAt (  (  ( position )  +  +  )  )  )  ;", "for    (  ( position )  +  +  ;     ( position )     <    length ;     ( position )  +  +  )", "if    (  ( delimiters . indexOf ( string . charAt ( position )  ,     0  )  )     >  =     0  )", "return   string . substring ( i ,    position )  ;", "return   string . substring ( i )  ;", "}", "while    (  ( i    <    length )     &  &     (  ( delimiters . indexOf ( string . charAt ( i )  ,     0  )  )     >  =     0  )  )", "i +  +  ;", "position    =    i ;", "if    ( i    <    length )     {", "for    (  ( position )  +  +  ;     ( position )     <    length ;     ( position )  +  +  )", "if    (  ( delimiters . indexOf ( string . charAt ( position )  ,     0  )  )     >  =     0  )", "return   string . substring ( i ,    position )  ;", "return   string . substring ( i )  ;", "}", "}", "throw   new   NoSuchElementException (  )  ;", "}", "METHOD_END"], "methodName": ["nextToken"], "fileName": "java.util.StringTokenizer"}, {"methodBody": ["METHOD_START", "{", "this . delimiters    =    delims ;", "return   next (  )  ;", "}", "METHOD_END"], "methodName": ["nextToken"], "fileName": "java.util.StringTokenizer"}, {"methodBody": ["METHOD_START", "{", "return   regExp . test ( input )  ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "java.util.regex.Matcher"}, {"methodBody": ["METHOD_START", "{", "return   matchResult . getGroup ( group )  ;", "}", "METHOD_END"], "methodName": ["group"], "fileName": "java.util.regex.Matcher"}, {"methodBody": ["METHOD_START", "{", "return   regExp . test ( input )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "java.util.regex.Matcher"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( s . indexOf (  '  \\  \\  '  )  )     =  =     (  -  1  )  )     &  &     (  ( s . indexOf (  '  $  '  )  )     =  =     (  -  1  )  )  )", "return   s ;", "StringBuilder   sb    =    new   StringBuilder ( s . length (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( s . length (  )  )  ;    i +  +  )     {", "char   c    =    s . charAt ( i )  ;", "if    (  ( c    =  =     '  \\  \\  '  )     |  |     ( c    =  =     '  $  '  )  )     {", "sb . append (  '  \\  \\  '  )  ;", "}", "sb . append ( c )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["quoteReplacement"], "fileName": "java.util.regex.Matcher"}, {"methodBody": ["METHOD_START", "{", "return   new   Pattern ( regExp )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "java.util.regex.Pattern"}, {"methodBody": ["METHOD_START", "{", "return   new   Matcher ( this ,    input )  ;", "}", "METHOD_END"], "methodName": ["matcher"], "fileName": "java.util.regex.Pattern"}]