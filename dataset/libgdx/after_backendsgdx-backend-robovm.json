[{"methodBody": ["METHOD_START", "{", "viewControllerListener    =    listener ;", "}", "METHOD_END"], "methodName": ["addViewControllerListener"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   new   IOSGraphics ( scale ,    this ,    config ,    input ,    config . useGL 3  0  )  ;", "}", "METHOD_END"], "methodName": ["createGraphics"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   new   IOSInput ( this )  ;", "}", "METHOD_END"], "methodName": ["createInput"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "app . debug (  \" IOSApplication \"  ,     \" resumed \"  )  ;", "OALAudioSession   audioSession    =    OALAudioSession . sharedInstance (  )  ;", "if    ( audioSession    !  =    null )     {", "audioSession . forceEndInterruption (  )  ;", "}", "if    ( config . allowIpod )     {", "OALSimpleAudio   audio    =    OALSimpleAudio . sharedInstance (  )  ;", "if    ( audio    !  =    null )     {", "audio . setUseHardwareIfAvailable ( false )  ;", "}", "}", "graphics . makeCurrent (  )  ;", "graphics . resume (  )  ;", "}", "METHOD_END"], "methodName": ["didBecomeActive"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "setApplicationLogger ( new   IOSApplicationLogger (  )  )  ;", "Gdx . app    =    this ;", "this . uiApp    =    uiApp ;", "UIApplication . getSharedApplication (  )  . setIdleTimerDisabled ( config . preventScreenDimming )  ;", "app . debug (  \" IOSApplication \"  ,     (  \" iOS   version :     \"     +     ( UIDevice . getCurrentDevice (  )  . getSystemVersion (  )  )  )  )  ;", "app . debug (  \" IOSApplication \"  ,     (  (  \" Running   in    \"     +     ( Bro . IS _  6  4 BIT    ?     \"  6  4  - bit \"     :     \"  3  2  - bit \"  )  )     +     \"    mode \"  )  )  ;", "float   scale    =     (  ( float )     (  (  ( getIosVersion (  )  )     >  =     8  )     ?    UIScreen . getMainScreen (  )  . getNativeScale (  )     :    UIScreen . getMainScreen (  )  . getScale (  )  )  )  ;", "if    ( scale    >  =     2  .  0 F )     {", "app . debug (  \" IOSApplication \"  ,     (  \" scale :     \"     +    scale )  )  ;", "if    (  ( UIDevice . getCurrentDevice (  )  . getUserInterfaceIdiom (  )  )     =  =     ( UIUserInterfaceIdiom . Pad )  )     {", "displayScaleFactor    =     ( config . displayScaleLargeScreenIfRetina )     *    scale ;", "} else    {", "displayScaleFactor    =     ( config . displayScaleSmallScreenIfRetina )     *    scale ;", "}", "} else    {", "if    (  ( UIDevice . getCurrentDevice (  )  . getUserInterfaceIdiom (  )  )     =  =     ( UIUserInterfaceIdiom . Pad )  )     {", "displayScaleFactor    =    config . displayScaleLargeScreenIfNonRetina ;", "} else    {", "displayScaleFactor    =    config . displayScaleSmallScreenIfNonRetina ;", "}", "}", "this . input    =    createInput (  )  ;", "this . graphics    =    createGraphics ( scale )  ;", "Gdx . gl    =    Gdx . gl 2  0     =    graphics . gl 2  0  ;", "Gdx . gl 3  0     =    graphics . gl 3  0  ;", "this . files    =    new   IOSFiles (  )  ;", "this . audio    =    new   IOSAudio ( config )  ;", "this . net    =    new   IOSNet ( this )  ;", "Gdx . files    =    this . files ;", "Gdx . graphics    =    this . graphics ;", "Gdx . audio    =    this . audio ;", "Gdx . input    =    this . input ;", "Gdx . net    =    this . net ;", "this . input . setupPeripherals (  )  ;", "this . uiWindow    =    new   UIWindow ( UIScreen . getMainScreen (  )  . getBounds (  )  )  ;", "this . uiWindow . setRootViewController ( this . graphics . viewController )  ;", "this . uiWindow . makeKeyAndVisible (  )  ;", "app . debug (  \" IOSApplication \"  ,     \" created \"  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["didFinishLaunching"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "final   CGRect   screenBounds    =    UIScreen . getMainScreen (  )  . getBounds (  )  ;", "final   CGRect   statusBarFrame    =    uiApp . getStatusBarFrame (  )  ;", "final   UIInterfaceOrientation   statusBarOrientation    =    uiApp . getStatusBarOrientation (  )  ;", "double   statusBarHeight    =    Math . min ( statusBarFrame . getWidth (  )  ,    statusBarFrame . getHeight (  )  )  ;", "double   screenWidth    =    screenBounds . getWidth (  )  ;", "double   screenHeight    =    screenBounds . getHeight (  )  ;", "switch    ( statusBarOrientation )     {", "case   LandscapeLeft    :", "case   LandscapeRight    :", "if    ( screenHeight    >    screenWidth )     {", "debug (  \"  \"  ,     (  (  (  (  \" Switching   reported   width   and   height    ( w =  \"     +    screenWidth )     +     \"    h =  \"  )     +    screenHeight )     +     \"  )  \"  )  )  ;", "double   tmp    =    screenHeight ;", "screenHeight    =    screenWidth ;", "screenWidth    =    tmp ;", "}", "}", "screenWidth    *  =    displayScaleFactor ;", "screenHeight    *  =    displayScaleFactor ;", "if    ( statusBarHeight    !  =     0  .  0  )     {", "debug (  \"  \"  ,     (  (  \" Status   bar   is   visible    ( height    =     \"     +    statusBarHeight )     +     \"  )  \"  )  )  ;", "statusBarHeight    *  =    displayScaleFactor ;", "screenHeight    -  =    statusBarHeight ;", "} else    {", "debug (  \"  \"  ,     \" Status   bar   is   not   visible \"  )  ;", "}", "debug (  \"  \"  ,     (  (  (  \" Total   computed   bounds   are   w =  \"     +    screenWidth )     +     \"    h =  \"  )     +    screenHeight )  )  ;", "return   lastScreenBounds    =    new   CGRect (  0  .  0  ,    statusBarHeight ,    screenWidth ,    screenHeight )  ;", "}", "METHOD_END"], "methodName": ["getBounds"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "if    (  ( lastScreenBounds )     =  =    null )", "return   getBounds (  )  ;", "else", "return   lastScreenBounds ;", "}", "METHOD_END"], "methodName": ["getCachedBounds"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "String   systemVersion    =    UIDevice . getCurrentDevice (  )  . getSystemVersion (  )  ;", "int   version    =    Integer . parseInt ( systemVersion . split (  \"  \\  \\  .  \"  )  [  0  ]  )  ;", "return   version ;", "}", "METHOD_END"], "methodName": ["getIosVersion"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   graphics . viewController ;", "}", "METHOD_END"], "methodName": ["getUIViewController"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "return   uiWindow ;", "}", "METHOD_END"], "methodName": ["getUIWindow"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "synchronized ( runnables )     {", "executedRunnables . clear (  )  ;", "executedRunnables . addAll ( runnables )  ;", "runnables . clear (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( executedRunnables . size )  ;    i +  +  )     {", "try    {", "executedRunnables . get ( i )  . run (  )  ;", "}    ch    ( Throwable   t )     {", "t . printStackTrace (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processRunnables"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "OALAudioSession   audioSession    =    OALAudioSession . sharedInstance (  )  ;", "if    ( audioSession    !  =    null )     {", "audioSession . forceEndInterrup (  )  ;", "}", "}", "METHOD_END"], "methodName": ["willEnterForeground"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "app . debug (  \" IOSApplication \"  ,     \" paused \"  )  ;", "graphics . makeCurrent (  )  ;", "graphics . pause (  )  ;", "gl . glFinish (  )  ;", "}", "METHOD_END"], "methodName": ["willResignActive"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "app . debug (  \" IOSApplication \"  ,     \" disposed \"  )  ;", "graphics . makeCurrent (  )  ;", "Array < LifecycleListener >    listeners    =    lifecycleListeners ;", "synchronized ( listeners )     {", "for    ( LifecycleListener   listener    :    listeners )     {", "listener . pause (  )  ;", "}", "}", "listener . dispose (  )  ;", "gl . glFinish (  )  ;", "}", "METHOD_END"], "methodName": ["willTerminate"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSApplication"}, {"methodBody": ["METHOD_START", "{", "for    ( IOSDevice   device    :    IOSDevice . values (  )  )     {", "if    ( device . machineString . equalsIgnoreCase ( machineString )  )", "return   device ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDevice"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSDevice"}, {"methodBody": ["METHOD_START", "{", "IOSGLES 2  0  . x    =    x ;", "IOSGLES 2  0  . y    =    y ;", "IOSGLES 2  0  . width    =    width ;", "IOSGLES 2  0  . height    =    height ;", "glViewportJni ( x ,    y ,    width ,    height )  ;", "}", "METHOD_END"], "methodName": ["glViewport"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSGLES20"}, {"methodBody": ["METHOD_START", "{", "EAGLContext . setCurrentContext ( context )  ;", "}", "METHOD_END"], "methodName": ["makeCurrent"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSGraphics"}, {"methodBody": ["METHOD_START", "{", "if    ( appPaused )", "return ;", "appPaused    =    true ;", "Array < LifecycleListener >    listeners    =    app . lifecycleListeners ;", "synchronized ( listeners )     {", "for    ( LifecycleListener   listener    :    listeners )     {", "listener . pause (  )  ;", "}", "}", "app . listener . pause (  )  ;", "}", "METHOD_END"], "methodName": ["pause"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSGraphics"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( appPaused )  )", "return ;", "appPaused    =    false ;", "Array < LifecycleListener >    listeners    =    app . lifecycleListeners ;", "synchronized ( listeners )     {", "for    ( LifecycleListener   listener    :    listeners )     {", "listener . resume (  )  ;", "}", "}", "app . listener . resume (  )  ;", "}", "METHOD_END"], "methodName": ["resume"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSGraphics"}, {"methodBody": ["METHOD_START", "{", "delegate    =    new   UIAlertViewDelegateAdapter (  )     {", "@ Override", "public   void   clicked ( UIAlertView   view ,    long   clicked )     {", "if    ( clicked    =  =     0  )     {", "listener . canceled (  )  ;", "} else", "if    ( clicked    =  =     1  )     {", "UITextField   textField    =    view . getTextField (  0  )  ;", "listener . input ( textField . getText (  )  )  ;", "}", "delegate    =    null ;", "}", "@ Override", "public   void   cancel ( UIAlertView   view )     {", "listener . canceled (  )  ;", "delegate    =    null ;", "}", "}  ;", "final   UIAlertView   uiAlertView    =    new   UIAlertView (  )  ;", "uiAlertView . setTitle ( title )  ;", "uiAlertView . addButton (  \" Cancel \"  )  ;", "uiAlertView . addButton (  \" Ok \"  )  ;", "uiAlertView . setAlertViewStyle ( PlainText )  ;", "uiAlertView . setDelegate ( delegate )  ;", "UITextField   textField    =    uiAlertView . getTextField (  0  )  ;", "textField . setPlaceholder ( placeholder )  ;", "textField . setText ( text )  ;", "return   uiAlertView ;", "}", "METHOD_END"], "methodName": ["buildUIAlertView"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "textfield    =    new   UITextField ( new   CGRect (  1  0  ,     1  0  ,     1  0  0  ,     5  0  )  )  ;", "textfield . setKeyboardType ( Default )  ;", "textfield . setReturnKeyType ( Done )  ;", "textfield . setAutocapitalizationType ( None )  ;", "textfield . setAutocorrectionType ( No )  ;", "textfield . setSpellCheckingType ( UITextSpellCheckingType . No )  ;", "textfield . setHidden ( true )  ;", "textfield . setText (  \" x \"  )  ;", "app . getUIViewController (  )  . getView (  )  . addSubview ( textfield )  ;", "}", "METHOD_END"], "methodName": ["createDefaultTextField"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "long   ptr    =    touch . getHandle (  )  ;", "for    ( int   i    =     0  ;    i    <     ( touchDown . length )  ;    i +  +  )     {", "if    (  ( touchDown [ i ]  )     =  =    ptr )", "return   i ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( touchDown . length )  ;    i +  +  )     {", "sb . append (  (  (  ( i    +     \"  :  \"  )     +     ( touchDown [ i ]  )  )     +     \"     \"  )  )  ;", "}", "app . error (  \"  \"  ,     (  (  (  \" Pointer   ID   lookup   failed :     \"     +    ptr )     +     \"  ,     \"  )     +     ( sb . toString (  )  )  )  )  ;", "return    . POINTER _ NOT _ FOUND ;", "}", "METHOD_END"], "methodName": ["findPointer"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( touchDown . length )  ;    i +  +  )     {", "if    (  ( touchDown [ i ]  )     =  =     0  )", "return   i ;", "}", "throw   new   GdxRuntimeException (  \" Couldn ' t   find   free   pointer   id !  \"  )  ;", "}", "METHOD_END"], "methodName": ["getFreePointer"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "if    (  ( textfield )     =  =    null )", "createDefaultTextField (  )  ;", "return   textfield ;", "}", "METHOD_END"], "methodName": ["getKeyboardTextField"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "toTouchEvents ( touches )  ;", "graphics . requestRering (  )  ;", "}", "METHOD_END"], "methodName": ["onTouch"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "synchronized ( touchEvents )     {", "justTouched    =    false ;", "for    (  . TouchEvent   event    :    touchEvents )     {", "currentEvent    =    event ;", "switch    ( event . phase )     {", "case   Began    :", "if    (  ( inputProcessor )     !  =    null )", "inputProcessor . touchDown ( event . x ,    event . y ,    event . pointer ,    Buttons . LEFT )  ;", "if    (  ( numTouched )     >  =     1  )", "justTouched    =    true ;", "break ;", "case   Cancelled    :", "case   Ended    :", "if    (  ( inputProcessor )     !  =    null )", "inputProcessor . touchUp ( event . x ,    event . y ,    event . pointer ,    Buttons . LEFT )  ;", "break ;", "case   Moved    :", "case   Stationary    :", "if    (  ( inputProcessor )     !  =    null )", "inputProcessor . touchDragged ( event . x ,    event . y ,    event . pointer )  ;", "break ;", "}", "}", "touchEventPool . freeAll ( touchEvents )  ;", "touchEvents . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processEvents"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "keyboardCloseOnReturn    =    shouldClose ;", "}", "METHOD_END"], "methodName": ["setKeyboardCloseOnReturnKey"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "if    ( config . useAccelerometer )     {", "accelerometerDelegate    =    new   UIAccelerometerDelegateAdapter (  )     {", "@ Method ( selector    =     \" accelerometer : didAccelerate :  \"  )", "public   void   didAccelerate ( UIAccelerometer   accelerometer ,     @ Pointer", "long   valuesPtr )     {", "UIAcceleration   values    =     . UI _ ACCELERATION _ WRAPPER . wrap ( valuesPtr )  ;", "float   x    =     (  ( float )     ( values . getX (  )  )  )     *     1  0  ;", "float   y    =     (  ( float )     ( values . getY (  )  )  )     *     1  0  ;", "float   z    =     (  ( float )     ( values . getZ (  )  )  )     *     1  0  ;", "acceleration [  0  ]     =     - x ;", "acceleration [  1  ]     =     - y ;", "acceleration [  2  ]     =     - z ;", "}", "}  ;", "UIAccelerometer . getSharedAccelerometer (  )  . setDelegate ( accelerometerDelegate )  ;", "UIAccelerometer . getSharedAccelerometer (  )  . setUpdateInterval ( config . accelerometerUpdate )  ;", "}", "}", "METHOD_END"], "methodName": ["setupAccelerometer"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "if    ( config . useCompass )     {", "}", "}", "METHOD_END"], "methodName": ["setupCompass"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "setupAccelerometer (  )  ;", "setupCompass (  )  ;", "UIDevice   device    =    UIDevice . getCurrentDevice (  )  ;", "if    ( device . getModel (  )  . equalsIgnoreCase (  \" iphone \"  )  )", "hasVibrator    =    true ;", "}", "METHOD_END"], "methodName": ["setupPeripherals"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "long   array    =    IOSInput . NSSetExtensions . allObjects ( touches )  ;", "int   length    =     (  ( int )     ( IOSInput . NSArrayExtensions . count ( array )  )  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "long   touchHandle    =    IOSInput . NSArrayExtensions . objectAtIndex $  ( array ,    i )  ;", "UITouch   touch    =    IOSInput . UI _ TOUCH _ WRAPPER . wrap ( touchHandle )  ;", "final   int   locX ;", "final   int   locY ;", "{", "CGPoint   loc    =    touch . getLocationInView ( touch . getWindow (  )  )  ;", "final   CGRect   bounds    =    app . getCachedBounds (  )  ;", "locX    =     (  ( int )     (  (  ( loc . getX (  )  )     *     ( app . displayScaleFactor )  )     -     ( bounds . getMinX (  )  )  )  )  ;", "locY    =     (  ( int )     (  (  ( loc . getY (  )  )     *     ( app . displayScaleFactor )  )     -     ( bounds . getMinY (  )  )  )  )  ;", "}", "synchronized ( touchEvents )     {", "UITouchPhase   phase    =    touch . getPhase (  )  ;", "IOSInput . TouchEvent   event    =    touchEventPool . obtain (  )  ;", "event . x    =    locX ;", "event . y    =    locY ;", "event . phase    =    phase ;", "event . timestamp    =     (  ( long )     (  ( touch . getTimestamp (  )  )     *     1  0  0  0  0  0  0  0  0  0  )  )  ;", "if    ( phase    =  =     ( UITouchPhase . Began )  )     {", "event . pointer    =    getFreePointer (  )  ;", "touchDown [ event . pointer ]     =    touch . getHandle (  )  ;", "touchX [ event . pointer ]     =    event . x ;", "touchY [ event . pointer ]     =    event . y ;", "deltaX [ event . pointer ]     =     0  ;", "deltaY [ event . pointer ]     =     0  ;", "( numTouched )  +  +  ;", "} else", "if    (  ( phase    =  =     ( UITouchPhase . Moved )  )     |  |     ( phase    =  =     ( UITouchPhase . Stationary )  )  )     {", "event . pointer    =    findPointer ( touch )  ;", "if    (  ( event . pointer )     !  =     ( IOSInput . POINTER _ NOT _ FOUND )  )     {", "deltaX [ event . pointer ]     =     ( event . x )     -     ( touchX [ event . pointer ]  )  ;", "deltaY [ event . pointer ]     =     ( event . y )     -     ( touchY [ event . pointer ]  )  ;", "touchX [ event . pointer ]     =    event . x ;", "touchY [ event . pointer ]     =    event . y ;", "}", "} else", "if    (  ( phase    =  =     ( UITouchPhase . Cancelled )  )     |  |     ( phase    =  =     ( UITouchPhase . Ended )  )  )     {", "event . pointer    =    findPointer ( touch )  ;", "if    (  ( event . pointer )     !  =     ( IOSInput . POINTER _ NOT _ FOUND )  )     {", "touchDown [ event . pointer ]     =     0  ;", "touchX [ event . pointer ]     =    event . x ;", "touchY [ event . pointer ]     =    event . y ;", "deltaX [ event . pointer ]     =     0  ;", "deltaY [ event . pointer ]     =     0  ;", "( numTouched )  -  -  ;", "}", "}", "if    (  ( event . pointer )     !  =     ( IOSInput . POINTER _ NOT _ FOUND )  )     {", "touchEvents . add ( event )  ;", "} else    {", "touchEventPool . free ( event )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["toTouchEvents"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSInput"}, {"methodBody": ["METHOD_START", "{", "return   new   NSString ( key )  ;", "}", "METHOD_END"], "methodName": ["convertKey"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSPreferences"}, {"methodBody": ["METHOD_START", "{", "for    ( ALSource   source    :    sourcePool )     {", "if    (  ( source . getSourceId (  )  )     =  =    sId )", "return   source ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSoundSource"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSSound"}, {"methodBody": ["METHOD_START", "{", "if    (  ( streamIds . size )     =  =     8  )", "streamIds . pop (  )  ;", "ALSource   sSource    =    OALSimpleAudio . sharedInstance (  )  . playBuffer ( sBuffer ,    volume ,    pitch ,    pan ,    loop )  ;", "if    ( sSource    =  =    null )", "return    -  1  ;", "if    (  ( sSource . getSourceId (  )  )     =  =     (  -  1  )  )", "return    -  1  ;", "streamIds . insert (  0  ,    sSource . getSourceId (  )  )  ;", "return   sSource . getSourceId (  )  ;", "}", "METHOD_END"], "methodName": ["play"], "fileName": "com.badlogic.gdx.backends.iosrobovm.IOSSound"}, {"methodBody": ["METHOD_START", "{", "BytePtr   name    =    BytePtr . toBytePtrAsciiZ (  \" hw . machine \"  )  ;", "MachineSizedUIntPtr   size    =    new   MachineSizedUIntPtr (  )  ;", ". sysctlbyname ( name ,    null ,    size ,    null ,     0  )  ;", "BytePtr   machine    =    Struct . allocate ( BytePtr . class ,     (  ( int )     ( size . get (  )  )  )  )  ;", ". sysctlbyname ( name ,    machine . as ( VoidPtr . class )  ,    size ,    null ,     0  )  ;", "return   machine . toStringAsciiZ (  )  ;", "}", "METHOD_END"], "methodName": ["getMachineString"], "fileName": "com.badlogic.gdx.backends.iosrobovm.custom.HWMachine"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["didAccelerate"], "fileName": "com.badlogic.gdx.backends.iosrobovm.custom.UIAccelerometerDelegateAdapter"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["didFinishPlaying"], "fileName": "com.badlogic.gdx.backends.iosrobovm.objectal.AVAudioPlayerDelegateAdapter"}]