[{"methodBody": ["METHOD_START", "{", "body . applyAngularImpulse ( impulse )  ;", "}", "METHOD_END"], "methodName": ["applyAngularImpulse"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( force . x ,    force . y )  ;", "tmp 2  . set ( point . x ,    point . y )  ;", "b . applyForce ( tmp ,    tmp 2  )  ;", "}", "METHOD_END"], "methodName": ["applyForce"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( forceX ,    forceY )  ;", "tmp 2  . set ( pointX ,    pointY )  ;", "b . applyForce ( tmp ,    tmp 2  )  ;", "}", "METHOD_END"], "methodName": ["applyForce"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( force . x ,    force . y )  ;", "b . applyForceToCenter ( tmp )  ;", "}", "METHOD_END"], "methodName": ["applyForceToCenter"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( forceX ,    forceY )  ;", "b . applyForceToCenter ( tmp )  ;", "}", "METHOD_END"], "methodName": ["applyForceToCenter"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( impulse . x ,    impulse . y )  ;", "tmp 2  . set ( point . x ,    point . y )  ;", "b . applyLinearImpulse ( tmp ,    tmp 2  ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyLinearImpulse"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( impulseX ,    impulseY )  ;", "tmp 2  . set ( pointX ,    pointY )  ;", "b . applyLinearImpulse ( tmp ,    tmp 2  ,    wake )  ;", "}", "METHOD_END"], "methodName": ["applyLinearImpulse"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . applyTorque ( torque )  ;", "}", "METHOD_END"], "methodName": ["applyTorque"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "FixtureDef   fd    =    def . toJBox 2 d (  )  ;", "Fixture   f    =    body . createFixture ( fd )  ;", "Fixture   fixture    =    new   Fixture ( this ,    f )  ;", "fixtures . add ( fixture )  ;", "world . fixtures . put ( f ,    fixture )  ;", "return   fixture ;", "}", "METHOD_END"], "methodName": ["createFixture"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "Fixture   f    =    body . createFixture ( shape . shape ,    density )  ;", "Fixture   fixture    =    new   Fixture ( this ,    f )  ;", "fixtures . add ( fixture )  ;", "world . fixtures . put ( f ,    fixture )  ;", "return   fixture ;", "}", "METHOD_END"], "methodName": ["createFixture"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . destroyFixture ( fixture . fixture )  ;", "fixtures . removeValue ( fixture ,    true )  ;", "world . fixtures . remove ( fixture . fixture )  ;", "}", "METHOD_END"], "methodName": ["destroyFixture"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . getAngle (  )  ;", "}", "METHOD_END"], "methodName": ["getAngle"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . getAngularDamping (  )  ;", "}", "METHOD_END"], "methodName": ["getAngularDamping"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . getAngularVelocity (  )  ;", "}", "METHOD_END"], "methodName": ["getAngularVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   fixtures ;", "}", "METHOD_END"], "methodName": ["getFixtureList"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . getGravityScale (  )  ;", "}", "METHOD_END"], "methodName": ["getGravityScale"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . getInertia (  )  ;", "}", "METHOD_END"], "methodName": ["getInertia"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "JointEdge   jointEdge    =    body . getJointList (  )  ;", "joints . clear (  )  ;", "while    ( jointEdge    !  =    null )     {", "JointEdge   edge    =    new   JointEdge ( world . bodies . get ( jointEdge . other )  ,    world . joints . get ( jointEdge . joint )  )  ;", "joints . add ( edge )  ;", "jointEdge    =    jointEdge . next ;", "}", "return   joints ;", "}", "METHOD_END"], "methodName": ["getJointList"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . getLinearDamping (  )  ;", "}", "METHOD_END"], "methodName": ["getLinearDamping"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    lv    =    body . getLinearVelocity (  )  ;", "linearVelocity . set ( lv . x ,    lv . y )  ;", "return   linearVelocity ;", "}", "METHOD_END"], "methodName": ["getLinearVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( localPoint . x ,    localPoint . y )  ;", "Vec 2    lv    =    b . getLinearVelocityFromLocalPoint ( tmp )  ;", "return   linVelLoc . set ( lv . x ,    lv . y )  ;", "}", "METHOD_END"], "methodName": ["getLinearVelocityFromLocalPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( worldPoint . x ,    worldPoint . y )  ;", "Vec 2    lv    =    b . getLinearVelocityFromWorldPoint ( tmp )  ;", "return   linVelWorld . set ( lv . x ,    lv . y )  ;", "}", "METHOD_END"], "methodName": ["getLinearVelocityFromWorldPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    lc    =    body . getLocalCenter (  )  ;", "localCenter . set ( lc . x ,    lc . y )  ;", "return   localCenter ;", "}", "METHOD_END"], "methodName": ["getLocalCenter"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( worldPoint . x ,    worldPoint . y )  ;", "Vec 2    lp    =    b . getLocalPoint ( tmp )  ;", "return   localPoint 2  . set ( lp . x ,    lp . y )  ;", "}", "METHOD_END"], "methodName": ["getLocalPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( worldVector . x ,    worldVector . y )  ;", "Vec 2    lv    =    b . getLocalVector ( tmp )  ;", "return   localVector . set ( lv . x ,    lv . y )  ;", "}", "METHOD_END"], "methodName": ["getLocalVector"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . getMass (  )  ;", "}", "METHOD_END"], "methodName": ["getMass"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . getMassData ( massData 2  )  ;", "massData . center . set ( massData 2  . center . x ,    massData 2  . center . y )  ;", "massData . I    =    massData 2  . I ;", "massData . mass    =    massData 2  . mass ;", "return   massData ;", "}", "METHOD_END"], "methodName": ["getMassData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    pos    =    body . getPosition (  )  ;", "position . set ( pos . x ,    pos . y )  ;", "return   position ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "Transform   trans    =    body . getTransform (  )  ;", "transform . vals [ Transform . POS _ X ]     =    trans . p . x ;", "transform . vals [ Transform . POS _ Y ]     =    trans . p . y ;", "transform . vals [ Transform . COS ]     =    trans . q . c ;", "transform . vals [ Transform . SIN ]     =    trans . q . s ;", "return   transform ;", "}", "METHOD_END"], "methodName": ["getTransform"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "Type   type    =    body . getType (  )  ;", "if    ( type    =  =    Type . DYNAMIC )  )", "returnDefType . Dynami ;", "if    ( type    =  =    Type . KINEMATIC )  )", "returnDefType . Kinemati ;", "if    ( type    =  =    Type . STATIC )  )", "returnDefType . Stati ;", "returnDefType . Dynami ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   world ;", "}", "METHOD_END"], "methodName": ["getWorld"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    wc    =    body . getWorldCenter (  )  ;", "return   worldCenter . set ( wc . x ,    wc . y )  ;", "}", "METHOD_END"], "methodName": ["getWorldCenter"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( localPoint . x ,    localPoint . y )  ;", "Vec 2    wp    =    b . getWorldPoint ( tmp )  ;", "return   worldPoint . set ( wp . x ,    wp . y )  ;", "}", "METHOD_END"], "methodName": ["getWorldPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( localVector . x ,    localVector . y )  ;", "Vec 2    wv    =    b . getWorldVector ( tmp )  ;", "return   worldVector . set ( wv . x ,    wv . y )  ;", "}", "METHOD_END"], "methodName": ["getWorldVector"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . isActive (  )  ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . isAwake (  )  ;", "}", "METHOD_END"], "methodName": ["isAwake"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . isBullet (  )  ;", "}", "METHOD_END"], "methodName": ["isBullet"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . isFixedRotation (  )  ;", "}", "METHOD_END"], "methodName": ["isFixedRotation"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "return   body . isSleepingAllowed (  )  ;", "}", "METHOD_END"], "methodName": ["isSleepingAllowed"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . resetMassData (  )  ;", "}", "METHOD_END"], "methodName": ["resetMassData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . setActive ( flag )  ;", "}", "METHOD_END"], "methodName": ["setActive"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . setAngularDamping ( angularDamping )  ;", "}", "METHOD_END"], "methodName": ["setAngularDamping"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . setAngularVelocity ( omega )  ;", "}", "METHOD_END"], "methodName": ["setAngularVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . setAwake ( flag )  ;", "}", "METHOD_END"], "methodName": ["setAwake"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . setBullet ( flag )  ;", "}", "METHOD_END"], "methodName": ["setBullet"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . setFixedRotation ( flag )  ;", "}", "METHOD_END"], "methodName": ["setFixedRotation"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . setGravityScale ( scale )  ;", "}", "METHOD_END"], "methodName": ["setGravityScale"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . setLinearDamping ( linearDamping )  ;", "}", "METHOD_END"], "methodName": ["setLinearDamping"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( v . x ,    v . y )  ;", "b . setLinearVelocity ( tmp )  ;", "}", "METHOD_END"], "methodName": ["setLinearVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( vX ,    vY )  ;", "b . setLinearVelocity ( tmp )  ;", "}", "METHOD_END"], "methodName": ["setLinearVelocity"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "massData 2  . center . set ( data . center . x ,    data . center . y )  ;", "massData 2  . I    =    data . I ;", "massData 2  . mass    =    data . mass ;", "b . setMassData ( massData 2  )  ;", "}", "METHOD_END"], "methodName": ["setMassData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "body . setSleepingAllowed ( flag )  ;", "}", "METHOD_END"], "methodName": ["setSleepingAllowed"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( position . x ,    position . y )  ;", "b . setTransform ( tmp ,    angle )  ;", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( x ,    y )  ;", "b . setTransform ( tmp ,    angle )  ;", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "Type   t    = Type . DYNAMIC ;", "if    ( type    =  =    DefType . Dynami )  )", "t    = Type . DYNAMIC ;", "if    ( type    =  =    DefType . Kinemati )  )", "t    = Type . KINEMATIC ;", "if    ( type    =  =    DefType . Stati )  )", "t    = Type . STATIC ;", "body . setType ( t )  ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "this . userData    =    userData ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Body"}, {"methodBody": ["METHOD_START", "{", "batch . dispose (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Circle )  )     {", "CircleShape   shape    =     (  ( CircleShape )     ( fixture . getShape (  )  )  )  ;", "float   radius    =    shape . getRadius (  )  ;", ". vertices [  0  ]  . set ( shape . getPosition (  )  )  ;", "transform . mul (  . vertices [  0  ]  )  ;", ". lower . set (  (  (  . vertices [  0  ]  . x )     -    radius )  ,     (  (  . vertices [  0  ]  . y )     -    radius )  )  ;", ". upper . set (  (  (  . vertices [  0  ]  . x )     +    radius )  ,     (  (  . vertices [  0  ]  . y )     +    radius )  )  ;", ". vertices [  0  ]  . set (  . lower . x ,     . lower . y )  ;", ". vertices [  1  ]  . set (  . upper . x ,     . lower . y )  ;", ". vertices [  2  ]  . set (  . upper . x ,     . upper . y )  ;", ". vertices [  3  ]  . set (  . lower . x ,     . upper . y )  ;", "drawSolidPolygon (  . vertices ,     4  ,    AABB _ COLOR ,    true )  ;", "} else", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Polygon )  )     {", "PolygonShape   shape    =     (  ( PolygonShape )     ( fixture . getShape (  )  )  )  ;", "int   vertexCount    =    shape . getVertexCount (  )  ;", "shape . getVertex (  0  ,     . vertices [  0  ]  )  ;", ". lower . set ( transform . mul (  . vertices [  0  ]  )  )  ;", ". upper . set (  . lower )  ;", "for    ( int   i    =     1  ;    i    <    vertexCount ;    i +  +  )     {", "shape . getVertex ( i ,     . vertices [ i ]  )  ;", "transform . mul (  . vertices [ i ]  )  ;", ". lower . x    =    Math . min (  . lower . x ,     . vertices [ i ]  . x )  ;", ". lower . y    =    Math . min (  . lower . y ,     . vertices [ i ]  . y )  ;", ". upper . x    =    Math . max (  . upper . x ,     . vertices [ i ]  . x )  ;", ". upper . y    =    Math . max (  . upper . y ,     . vertices [ i ]  . y )  ;", "}", ". vertices [  0  ]  . set (  . lower . x ,     . lower . y )  ;", ". vertices [  1  ]  . set (  . upper . x ,     . lower . y )  ;", ". vertices [  2  ]  . set (  . upper . x ,     . upper . y )  ;", ". vertices [  3  ]  . set (  . lower . x ,     . upper . y )  ;", "drawSolidPolygon (  . vertices ,     4  ,    AABB _ COLOR ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["drawAABB"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "WorldManifold   worldManifold    =    contact . getWorldManifold (  )  ;", "if    (  ( worldManifold . getNumberOfContactPoints (  )  )     =  =     0  )", "return ;", "Vector 2    point    =    worldManifold . getPoints (  )  [  0  ]  ;", "r . point ( point . x ,    point . y ,     0  )  ;", "}", "METHOD_END"], "methodName": ["drawContact"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "Body   bodyA    =    joint . getBodyA (  )  ;", "Body   bodyB    =    joint . getBodyB (  )  ;", "Transform   xf 1     =    bodyA . getTransform (  )  ;", "Transform   xf 2     =    bodyB . getTransform (  )  ;", "Vector 2    x 1     =    xf 1  . getPosition (  )  ;", "Vector 2    x 2     =    xf 2  . getPosition (  )  ;", "Vector 2    p 1     =    joint . getAnchorA (  )  ;", "Vector 2    p 2     =    joint . getAnchorB (  )  ;", "if    (  ( joint . getType (  )  )     =  =     ( JointDef . JointType . DistanceJoint )  )     {", "drawSegment ( p 1  ,    p 2  ,    JOINT _ COLOR )  ;", "} else", "if    (  ( joint . getType (  )  )     =  =     ( JointDef . JointType . PulleyJoint )  )     {", "joints . PulleyJoint   pulley    =     (  ( joints . PulleyJoint )     ( joint )  )  ;", "Vector 2    s 1     =    pulley . getGroundAnchorA (  )  ;", "Vector 2    s 2     =    pulley . getGroundAnchorB (  )  ;", "drawSegment ( s 1  ,    p 1  ,    JOINT _ COLOR )  ;", "drawSegment ( s 2  ,    p 2  ,    JOINT _ COLOR )  ;", "drawSegment ( s 1  ,    s 2  ,    JOINT _ COLOR )  ;", "} else", "if    (  ( joint . getType (  )  )     =  =     ( JointDef . JointType . MouseJoint )  )     {", "drawSegment ( joint . getAnchorA (  )  ,    joint . getAnchorB (  )  ,    JOINT _ COLOR )  ;", "} else    {", "drawSegment ( x 1  ,    p 1  ,    JOINT _ COLOR )  ;", "drawSegment ( p 1  ,    p 2  ,    JOINT _ COLOR )  ;", "drawSegment ( x 2  ,    p 2  ,    JOINT _ COLOR )  ;", "}", "}", "METHOD_END"], "methodName": ["drawJoint"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . setColor ( color )  ;", "renderer . line ( x 1  . x ,    x 1  . y ,    x 2  . x ,    x 2  . y )  ;", "}", "METHOD_END"], "methodName": ["drawSegment"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Circle )  )     {", "CircleShape   circle    =     (  ( CircleShape )     ( fixture . getShape (  )  )  )  ;", ". t . set ( circle . getPosition (  )  )  ;", "transform . mul (  . t )  ;", "drawSolidCircle (  . t ,    circle . getRadius (  )  ,     . axis . set ( transform . vals [ Transform . COS ]  ,    transform . vals [ Transform . SIN ]  )  ,    color )  ;", "}", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Edge )  )     {", "EdgeShape   edge    =     (  ( EdgeShape )     ( fixture . getShape (  )  )  )  ;", "edge . getVertex 1  (  . vertices [  0  ]  )  ;", "edge . getVertex 2  (  . vertices [  1  ]  )  ;", "transform . mul (  . vertices [  0  ]  )  ;", "transform . mul (  . vertices [  1  ]  )  ;", "drawSolidPolygon (  . vertices ,     2  ,    color ,    true )  ;", "}", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Polygon )  )     {", "PolygonShape   chain    =     (  ( PolygonShape )     ( fixture . getShape (  )  )  )  ;", "int   vertexCount    =    chain . getVertexCount (  )  ;", "for    ( int   i    =     0  ;    i    <    vertexCount ;    i +  +  )     {", "chain . getVertex ( i ,     . vertices [ i ]  )  ;", "transform . mul (  . vertices [ i ]  )  ;", "}", "drawSolidPolygon (  . vertices ,    vertexCount ,    color ,    true )  ;", "}", "if    (  ( fixture . getType (  )  )     =  =     ( Shape . Type . Chain )  )     {", "ChainShape   chain    =     (  ( ChainShape )     ( fixture . getShape (  )  )  )  ;", "int   vertexCount    =    chain . getVertexCount (  )  ;", "for    ( int   i    =     0  ;    i    <    vertexCount ;    i +  +  )     {", "chain . getVertex ( i ,     . vertices [ i ]  )  ;", "transform . mul (  . vertices [ i ]  )  ;", "}", "drawSolidPolygon (  . vertices ,    vertexCount ,    color ,    chain . isLooped (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["drawShape"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "float   angle    =     0  ;", "float   angleInc    =     (  2     *     (  ( float )     ( Math . PI )  )  )     /     2  0  ;", "r . setColor ( color . r ,    color . g ,    color . b ,    color . a )  ;", "for    ( int   i    =     0  ;    i    <     2  0  ;    i +  +     ,    angle    +  =    angleInc )     {", "v . set (  (  (  (  ( float )     ( Math . cos ( angle )  )  )     *    radius )     +     ( center . x )  )  ,     (  (  (  ( float )     ( Math . sin ( angle )  )  )     *    radius )     +     ( center . y )  )  )  ;", "if    ( i    =  =     0  )     {", "lv . set ( v )  ;", "f . set ( v )  ;", "continue ;", "}", "r . line ( lv . x ,    lv . y ,    v . x ,    v . y )  ;", "lv . set ( v )  ;", "}", "r . line ( f . x ,    f . y ,    lv . x ,    lv . y )  ;", "r . line ( center . x ,    center . y ,     0  ,     (  ( center . x )     +     (  ( axis . x )     *    radius )  )  ,     (  ( center . y )     +     (  ( axis . y )     *    radius )  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["drawSolidCircle"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . setColor ( color . r ,    color . g ,    color . b ,    color . a )  ;", "for    ( int   i    =     0  ;    i    <    vertexCount ;    i +  +  )     {", "Vector 2    v    =    vertices [ i ]  ;", "if    ( i    =  =     0  )     {", "lv . set ( v )  ;", "f . set ( v )  ;", "continue ;", "}", "renderer . line ( lv . x ,    lv . y ,    v . x ,    v . y )  ;", "lv . set ( v )  ;", "}", "if    ( closed )", "renderer . line ( f . x ,    f . y ,    lv . x ,    lv . y )  ;", "}", "METHOD_END"], "methodName": ["drawSolidPolygon"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   Box 2 DDebugRenderer . axis ;", "}", "METHOD_END"], "methodName": ["getAxis"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawAABBs ;", "}", "METHOD_END"], "methodName": ["isDrawAABBs"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawBodies ;", "}", "METHOD_END"], "methodName": ["isDrawBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawContacts ;", "}", "METHOD_END"], "methodName": ["isDrawContacts"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawInactiveBodies ;", "}", "METHOD_END"], "methodName": ["isDrawInactiveBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawJoints ;", "}", "METHOD_END"], "methodName": ["isDrawJoints"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "return   drawVelocities ;", "}", "METHOD_END"], "methodName": ["isDrawVelocities"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . setProjectionMatrix ( projMatrix )  ;", "renderBodies ( world )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . begin ( Line )  ;", "if    (  ( drawBodies )     |  |     ( drawAABBs )  )     {", "world . getBodies (  . bodies )  ;", "for    ( Iterator < Body >    iter    =     . bodies . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Body   body    =    iter . next (  )  ;", "if    (  ( body . isActive (  )  )     |  |     ( drawInactiveBodies )  )", "renderBody ( body )  ;", "}", "}", "if    ( drawJoints )     {", "world . getJoints (  . joints )  ;", "for    ( Iterator < Joint >    iter    =     . joints . iterator (  )  ;    iter . hasNext (  )  ;  )     {", "Joint   joint    =    iter . next (  )  ;", "drawJoint ( joint )  ;", "}", "}", "renderer . end (  )  ;", "if    ( drawContacts )     {", "renderer . begin ( Point )  ;", "for    ( Contact   contact    :    world . getContactList (  )  )", "drawContact ( contact )  ;", "renderer . end (  )  ;", "}", "}", "METHOD_END"], "methodName": ["renderBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "Transform   transform    =    body . getTransform (  )  ;", "int   len    =    body . getFixtureList (  )  . size ;", "Array < Fixture >    fixtures    =    body . getFixtureList (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "Fixture   fixture    =    fixtures . get ( i )  ;", "if    ( dradies )     {", "if    (  (  ( body . isActive (  )  )     =  =    false )     &  &     ( drawInactivdies )  )", "drawShape ( fixture ,    transform ,    SHAPE _ NOT _ ACTIVE )  ;", "else", "if    (  ( body . getType (  )  )     =  =    dyDefdyType . Statidy )  )", "drawShape ( fixture ,    transform ,    SHAPE _ STATIC )  ;", "else", "if    (  ( body . getType (  )  )     =  =    dyDefdyType . Kinematidy )  )", "drawShape ( fixture ,    transform ,    SHAPE _ KINEMATIC )  ;", "else", "if    (  ( body . isAwake (  )  )     =  =    false )", "drawShape ( fixture ,    transform ,    SHAPE _ NOT _ AWAKE )  ;", "else", "drawShape ( fixture ,    transform ,    SHAPE _ AWAKE )  ;", "}", "if    ( drawAABBs )     {", "drawAABB ( fixture ,    transform )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["renderBody"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "Box 2 DDebugRenderer . axis    =    axis ;", "}", "METHOD_END"], "methodName": ["setAxis"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawAABBs    =    drawAABBs ;", "}", "METHOD_END"], "methodName": ["setDrawAABBs"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawBodies    =    drawBodies ;", "}", "METHOD_END"], "methodName": ["setDrawBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawContacts    =    drawContacts ;", "}", "METHOD_END"], "methodName": ["setDrawContacts"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawInactiveBodies    =    drawInactiveBodies ;", "}", "METHOD_END"], "methodName": ["setDrawInactiveBodies"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawJoints    =    drawJoints ;", "}", "METHOD_END"], "methodName": ["setDrawJoints"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "this . drawVelocities    =    drawVelocities ;", "}", "METHOD_END"], "methodName": ["setDrawVelocities"], "fileName": "com.badlogic.gdx.physics.box2d.Box2DDebugRenderer"}, {"methodBody": ["METHOD_START", "{", "Vec 2  [  ]    v    =    new   Vec 2  [ vertices . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( vertices . length )  ;    i +  +  )     {", "v [ i ]     =    new   Vec 2  ( vertices [ i ]  . x ,    vertices [ i ]  . y )  ;", "}", "shape . create ( v ,    v . length )  ;", "isLooped    =    false ;", "}", "METHOD_END"], "methodName": ["createChain"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "Vec 2  [  ]    v    =    new   Vec 2  [  ( vertices . length )     /     2  ]  ;", "for    ( int   i    =     0  ,    vi    =     0  ;    i    <     ( vertices . length )  ;    i    +  =     2     ,    vi +  +  )     {", "v [ vi ]     =    new   Vec 2  ( vertices [ i ]  ,    vertices [  ( i    +     1  )  ]  )  ;", "}", "shape . create ( v ,    v . length )  ;", "isLooped    =    false ;", "}", "METHOD_END"], "methodName": ["createChain"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "final   int   vertexCount    =    length    /     2  ;", "Vec 2  [  ]    v    =    new   Vec 2  [ vertexCount ]  ;", "for    ( int   i    =    offset ,    vi    =     0  ;    vi    <    vertexCount ;    i    +  =     2     ,    vi +  +  )     {", "v [ vi ]     =    new   Vec 2  ( vertices [ i ]  ,    vertices [  ( i    +     1  )  ]  )  ;", "}", "shape . create ( v ,    vertexCount )  ;", "isLooped    =    false ;", "}", "METHOD_END"], "methodName": ["createChain"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "Vec 2  [  ]    v    =    new   Vec 2  [ vertices . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( vertices . length )  ;    i +  +  )     {", "v [ i ]     =    new   Vec 2  ( vertices [ i ]  . x ,    vertices [ i ]  . y )  ;", "}", "s . createLoop ( v ,    v . length )  ;", "isLooped    =    true ;", "}", "METHOD_END"], "methodName": ["createLoop"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "Vec 2  [  ]    v    =    new   Vec 2  [  ( vertices . length )     /     2  ]  ;", "for    ( int   i    =     0  ,    vi    =     0  ;    i    <     ( vertices . length )  ;    i    +  =     2     ,    vi +  +  )     {", "v [ vi ]     =    new   Vec 2  ( vertices [ i ]  ,    vertices [  ( i    +     1  )  ]  )  ;", "}", "s . createLoop ( v ,    v . length )  ;", "isLooped    =    true ;", "}", "METHOD_END"], "methodName": ["createLoop"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "final   int   vertexCount    =    length    /     2  ;", "Vec 2  [  ]    v    =    new   Vec 2  [ vertexCount ]  ;", "for    ( int   i    =    offset ,    vi    =     0  ;    vi    <    vertexCount ;    i    +  =     2     ,    vi +  +  )     {", "v [ vi ]     =    new   Vec 2  ( vertices [ i ]  ,    vertices [  ( i    +     1  )  ]  )  ;", "}", "s . createLoop ( v ,    vertexCount )  ;", "isLooped    =    true ;", "}", "METHOD_END"], "methodName": ["createLoop"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "Vec 2    v    =    shape . m _ vertices [ index ]  ;", "vertex . set ( v . x ,    v . y )  ;", "}", "METHOD_END"], "methodName": ["getVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "return   shape . m _ count ;", "}", "METHOD_END"], "methodName": ["getVertexCount"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "return   isLooped ;", "}", "METHOD_END"], "methodName": ["isLooped"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "shape . setNextVertex ( new   Vec 2  ( nextVertex . x ,    nextVertex . y )  )  ;", "}", "METHOD_END"], "methodName": ["setNextVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "shape . setNextVertex ( new   Vec 2  ( nextVertexX ,    nextVertexY )  )  ;", "}", "METHOD_END"], "methodName": ["setNextVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "shape . setPrevVertex ( new   Vec 2  ( prevVertex . x ,    prevVertex . y )  )  ;", "}", "METHOD_END"], "methodName": ["setPrevVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "shape . setPrevVertex ( new   Vec 2  ( prevVertexX ,    prevVertexY )  )  ;", "}", "METHOD_END"], "methodName": ["setPrevVertex"], "fileName": "com.badlogic.gdx.physics.box2d.ChainShape"}, {"methodBody": ["METHOD_START", "{", "return   position . set ( shape . m _ p . x ,    shape . m _ p . y )  ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.physics.box2d.CircleShape"}, {"methodBody": ["METHOD_START", "{", "shape . m _ p . set ( position . x ,    position . y )  ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.physics.box2d.CircleShape"}, {"methodBody": ["METHOD_START", "{", "contact . resetRestitution (  )  ;", "}", "METHOD_END"], "methodName": ["ResetRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   contact . getChildIndexA (  )  ;", "}", "METHOD_END"], "methodName": ["getChildIndexA"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   contact . getChildIndexB (  )  ;", "}", "METHOD_END"], "methodName": ["getChildIndexB"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   world . fixtures . get ( contact . m _ fixtureA )  ;", "}", "METHOD_END"], "methodName": ["getFixtureA"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   world . fixtures . get ( contact . m _ fixtureB )  ;", "}", "METHOD_END"], "methodName": ["getFixtureB"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   contact . getFriction (  )  ;", "}", "METHOD_END"], "methodName": ["getFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   contact . getRestitution (  )  ;", "}", "METHOD_END"], "methodName": ["getRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   contact . getTangentSpeed (  )  ;", "}", "METHOD_END"], "methodName": ["getTangentSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "contact . getWorldManifold ( worldManifold 2  )  ;", "int   numPoints    =    contact . getManifold (  )  . pointCount ;", "worldManifold . numPoints    =    numPoints ;", "worldManifold . normal . set ( worldManifold 2  . normal . x ,    worldManifold 2  . normal . y )  ;", "for    ( int   i    =     0  ;    i    <     ( worldManifold . points . length )  ;    i +  +  )     {", "worldManifold . points [ i ]     =    new   Vector 2  ( worldManifold 2  . points [ i ]  . x ,    worldManifold 2  . points [ i ]  . y )  ;", "}", "return   worldManifold ;", "}", "METHOD_END"], "methodName": ["getWorldManifold"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   contact . isEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   contact . isTouching (  )  ;", "}", "METHOD_END"], "methodName": ["isTouching"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "contact . resetFriction (  )  ;", "}", "METHOD_END"], "methodName": ["resetFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "contact . setEnabled ( flag )  ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "contact . setFriction ( friction )  ;", "}", "METHOD_END"], "methodName": ["setFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "contact . setRestitution ( restitution )  ;", "}", "METHOD_END"], "methodName": ["setRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "contact . setTangentSpeed ( speed )  ;", "}", "METHOD_END"], "methodName": ["setTangentSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.Contact"}, {"methodBody": ["METHOD_START", "{", "return   impulse . count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "com.badlogic.gdx.physics.box2d.ContactImpulse"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( impulse . count )  ;    i +  +  )     {", "normals [ i ]     =    impulse . normals [ i ]  ;", "}", "return   normals ;", "}", "METHOD_END"], "methodName": ["getNormalImpulses"], "fileName": "com.badlogic.gdx.physics.box2d.ContactImpulse"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( impulse . count )  ;    i +  +  )     {", "tangens [ i ]     =    impulse . tangens [ i ]  ;", "}", "return   tangens ;", "}", "METHOD_END"], "methodName": ["getTangentImpulses"], "fileName": "com.badlogic.gdx.physics.box2d.ContactImpulse"}, {"methodBody": ["METHOD_START", "{", "Vec 2    v 0     =    shape . m _ vertex 0  ;", "vec . set ( v 0  . x ,    v 0  . y )  ;", "}", "METHOD_END"], "methodName": ["getVertex0"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "Vec 2    v 1     =    shape . m _ vertex 1  ;", "vec . set ( v 1  . x ,    v 1  . y )  ;", "}", "METHOD_END"], "methodName": ["getVertex1"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "Vec 2    v 2     =    shape . m _ vertex 2  ;", "vec . set ( v 2  . x ,    v 2  . y )  ;", "}", "METHOD_END"], "methodName": ["getVertex2"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "Vec 2    v 3     =    shape . m _ vertex 3  ;", "vec . set ( v 3  . x ,    v 3  . y )  ;", "}", "METHOD_END"], "methodName": ["getVertex3"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "return   shape . m _ hasVertex 0  ;", "}", "METHOD_END"], "methodName": ["hasVertex0"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "return   shape . m _ hasVertex 3  ;", "}", "METHOD_END"], "methodName": ["hasVertex3"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "set ( v 1  . x ,    v 1  . y ,    v 2  . x ,    v 2  . y )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( v 1 X ,    v 1 Y )  ;", "tmp 2  . set ( v 2 X ,    v 2 Y )  ;", "s . set ( tmp ,    tmp 2  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "shape . m _ hasVertex 0     =    hasVertex 0  ;", "}", "METHOD_END"], "methodName": ["setHasVertex0"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "shape . m _ hasVertex 3     =    hasVertex 3  ;", "}", "METHOD_END"], "methodName": ["setHasVertex3"], "fileName": "com.badlogic.gdx.physics.box2d.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "return   body ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   fixture . getDensity (  )  ;", "}", "METHOD_END"], "methodName": ["getDensity"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "Filter   f    =    fixture . getFilterData (  )  ;", "filter . categoryBits    =     (  ( short )     ( f . categoryBits )  )  ;", "filter . maskBits    =     (  ( short )     ( f . maskBits )  )  ;", "filter . groupIndex    =     (  ( short )     ( f . groupIndex )  )  ;", "return   filter ;", "}", "METHOD_END"], "methodName": ["getFilterData"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   fixture . getFriction (  )  ;", "}", "METHOD_END"], "methodName": ["getFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   fixture . getRestitution (  )  ;", "}", "METHOD_END"], "methodName": ["getRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "if    (  ( shape )     =  =    null )     {", "Shape   shape 2     =    f . getShape (  )  ;", "ShapeType   type    =    shape 2  . getType (  )  ;", "if    ( type    =  =     ( ShapeType . CHAIN )  )", "shape    =    new   ChainShape (  (  ( ChainShape )     ( shape 2  )  )  )  ;", "if    ( type    =  =     ( ShapeType . CIRCLE )  )", "shape    =    new   CircleShape (  (  ( CircleShape )     ( shape 2  )  )  )  ;", "if    ( type    =  =     ( ShapeType . EDGE )  )", "shape    =    new   EdgeShape (  (  ( EdgeShape )     ( shape 2  )  )  )  ;", "if    ( type    =  =     ( ShapeType . POLYGON )  )", "shape    =    new   PolygonShape (  (  ( PolygonShape )     ( shape 2  )  )  )  ;", "}", "return   shape ;", "}", "METHOD_END"], "methodName": ["getShape"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "ShapeType   type    =    fixture . getType (  )  ;", "if    ( type    =  =     ( ShapeType . CIRCLE )  )", "return   Shape . Type . Circle ;", "if    ( type    =  =     ( ShapeType . EDGE )  )", "return   Shape . Type . Edge ;", "if    ( type    =  =     ( ShapeType . POLYGON )  )", "return   Shape . Type . Polygon ;", "if    ( type    =  =     ( ShapeType . CHAIN )  )", "return   Shape . Type . Chain ;", "return   Shape . Type . Circle ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   fixture . isSensor (  )  ;", "}", "METHOD_END"], "methodName": ["isSensor"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "fixture . refilter (  )  ;", "}", "METHOD_END"], "methodName": ["refilter"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "this . body    =    body ;", "this . f    =    f ;", "this . shape    =    null ;", "this . userData    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "fixture . setDensity ( density )  ;", "}", "METHOD_END"], "methodName": ["setDensity"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "Filter   f    =    new   Filter (  )  ;", "f . categoryBits    =    filter . categoryBits ;", "f . groupIndex    =    filter . groupIndex ;", "f . maskBits    =    filter . maskBits ;", "f . setFilterData ( f )  ;", "}", "METHOD_END"], "methodName": ["setFilterData"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "fixture . setFriction ( friction )  ;", "}", "METHOD_END"], "methodName": ["setFriction"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "fixture . setRestitution ( restitution )  ;", "}", "METHOD_END"], "methodName": ["setRestitution"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "fixture . setSensor ( sensor )  ;", "}", "METHOD_END"], "methodName": ["setSensor"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "this . userData    =    userData ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( p . x ,    p . y )  ;", "return   f . testPoint ( tmp )  ;", "}", "METHOD_END"], "methodName": ["testPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( x ,    y )  ;", "return   f . testPoint ( tmp )  ;", "}", "METHOD_END"], "methodName": ["testPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Fixture"}, {"methodBody": ["METHOD_START", "{", "FixtureDef   fd    =    new   FixtureDef (  )  ;", "fd . density    =    density ;", "fd . filter    =    new   Filter (  )  ;", "fd . filter . categoryBits    =    filter . categoryBits ;", "fd . filter . groupIndex    =    filter . groupIndex ;", "fd . filter . maskBits    =    filter . maskBits ;", "fd . friction    =    friction ;", "fd . isSensor    =    isSensor ;", "fd . restitution    =    restitution ;", "fd . shape    =    shape . shape ;", "return   fd ;", "}", "METHOD_END"], "methodName": ["toJBox2d"], "fileName": "com.badlogic.gdx.physics.box2d.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "joint . getAnchorA ( tmp )  ;", "return   anchorA . set ( tmp . x ,    tmp . y )  ;", "}", "METHOD_END"], "methodName": ["getAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "joint . getAnchorB ( tmp )  ;", "return   anchorB . set ( tmp . x ,    tmp . y )  ;", "}", "METHOD_END"], "methodName": ["getAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   world . bodies . get ( joint . getBodyA (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBodyA"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   world . bodies . get ( joint . getBodyB (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBodyB"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getCollideConnected (  )  ;", "}", "METHOD_END"], "methodName": ["getCollideConnected"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   joint ;", "}", "METHOD_END"], "methodName": ["getJBox2DJoint"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "joint . getReactionForce ( inv _ dt ,    tmp )  ;", "return   reactionForce . set ( tmp . x ,    tmp . y )  ;", "}", "METHOD_END"], "methodName": ["getReactionForce"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getReactionTorque ( inv _ dt )  ;", "}", "METHOD_END"], "methodName": ["getReactionTorque"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "Type   type 2     =    joint . getType (  )  ;", "if    ( type 2     =  =    Type . DISTANCE )  )", "returnDefType . Distanc ;", "if    ( type 2     =  =    Type . FRICTION )  )", "returnDefType . Frictio ;", "if    ( type 2     =  =    Type . GEAR )  )", "returnDefType . Gea ;", "if    ( type 2     =  =    Type . MOUSE )  )", "returnDefType . Mous ;", "if    ( type 2     =  =    Type . PRISMATIC )  )", "returnDefType . Prismati ;", "if    ( type 2     =  =    Type . PULLEY )  )", "returnDefType . Pulle ;", "if    ( type 2     =  =    Type . REVOLUTE )  )", "returnDefType . Revolut ;", "if    ( type 2     =  =    Type . ROPE )  )", "returnDefType . Rop ;", "if    ( type 2     =  =    Type . UNKNOWN )  )", "returnDefType . Unknown ;", "if    ( type 2     =  =    Type . WELD )  )", "returnDefType . Wel ;", "if    ( type 2     =  =    Type . WHEEL )  )", "returnDefType . Whee ;", "returnDefType . Unknown ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   joint . isActive (  )  ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "this . userData    =    userData ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "com.badlogic.gdx.physics.box2d.Joint"}, {"methodBody": ["METHOD_START", "{", "return   localNormal . set ( manifold . localNormal . x ,    manifold . localNormal . y )  ;", "}", "METHOD_END"], "methodName": ["getLocalNormal"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "return   localPoint . set ( manifold . localPoint . x ,    manifold . localPoint . y )  ;", "}", "METHOD_END"], "methodName": ["getLocalPoint"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "return   manifold . pointCount ;", "}", "METHOD_END"], "methodName": ["getPointCount"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( manifold . points . length )  ;    i +  +  )     {", "points [ i ]  . contactID    =    manifold . points [ i ]  . id . getKey (  )  ;", "points [ i ]  . localPoint . set ( manifold . points [ i ]  . localPoint . x ,    manifold . points [ i ]  . localPoint . y )  ;", "points [ i ]  . normalImpulse    =    manifold . points [ i ]  . normalImpulse ;", "points [ i ]  . tangentImpulse    =    manifold . points [ i ]  . tangentImpulse ;", "}", "return   points ;", "}", "METHOD_END"], "methodName": ["getPoints"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "ManifoldType   type    =    manifold . type ;", "if    ( type    =  =     ( CIRCLES )  )", "return   Manifold . ManifoldType . Circle ;", "if    ( type    =  =     ( FACE _ A )  )", "return   Manifold . ManifoldType . FaceA ;", "if    ( type    =  =     ( FACE _ B )  )", "return   Manifold . ManifoldType . FaceB ;", "return   Manifold . ManifoldType . Circle ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.badlogic.gdx.physics.box2d.Manifold"}, {"methodBody": ["METHOD_START", "{", "Vec 2    v    =    shape . m _ vertices [ index ]  ;", "vertex . set ( v . x ,    v . y )  ;", "}", "METHOD_END"], "methodName": ["getVertex"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "return   shape . m _ count ;", "}", "METHOD_END"], "methodName": ["getVertexCount"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "Vec 2  [  ]    v    =    new   Vec 2  [ vertices . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( v . length )  ;    i +  +  )     {", "v [ i ]     =    new   Vec 2  ( vertices [ i ]  . x ,    vertices [ i ]  . y )  ;", "}", "s . set ( v ,    v . length )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "set ( vertices ,     0  ,    vertices . length )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "Vec 2  [  ]    v    =    new   Vec 2  [ len    /     2  ]  ;", "for    ( int   i    =     0  ;    i    <     ( v . length )  ;    i +  +  )     {", "v [ i ]     =    new   Vec 2  ( vertices [  ( i    *     2  )  ]  ,    vertices [  (  ( i    *     2  )     +     1  )  ]  )  ;", "}", "s . set ( v ,    v . length )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "shape . setAsBox ( hx ,    hy )  ;", "}", "METHOD_END"], "methodName": ["setAsBox"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( center . x ,    center . y )  ;", "s . setAsBox ( hx ,    hy ,    tmp ,    angle )  ;", "}", "METHOD_END"], "methodName": ["setAsBox"], "fileName": "com.badlogic.gdx.physics.box2d.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "return   orientation . set ( vals [ Transform . COS ]  ,    vals [ Transform . SIN ]  )  ;", "}", "METHOD_END"], "methodName": ["getOrientation"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "return   position . set ( vals [  0  ]  ,    vals [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . atan 2  ( vals [ Transform . SIN ]  ,    vals [ Transform . COS ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRotation"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "float   x    =     (  ( vals [ Transform . POS _ X ]  )     +     (  ( vals [ Transform . COS ]  )     *     ( v . x )  )  )     +     (  (  -  ( vals [ Transform . SIN ]  )  )     *     ( v . y )  )  ;", "float   y    =     (  ( vals [ Transform . POS _ Y ]  )     +     (  ( vals [ Transform . SIN ]  )     *     ( v . x )  )  )     +     (  ( vals [ Transform . COS ]  )     *     ( v . y )  )  ;", "v . x    =    x ;", "v . y    =    y ;", "return   v ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "this . vals [ Transform . COS ]     =    orientation . x ;", "this . vals [ Transform . SIN ]     =    orientation . y ;", "}", "METHOD_END"], "methodName": ["setOrientation"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "this . vals [ Transform . POS _ X ]     =    pos . x ;", "this . vals [ Transform . POS _ Y ]     =    pos . y ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "float   c    =     (  ( float )     ( Math . cos ( angle )  )  )  ;", "float   s    =     (  ( float )     ( Math . sin ( angle )  )  )  ;", "vals [  . COS ]     =    c ;", "vals [  . SIN ]     =    s ;", "}", "METHOD_END"], "methodName": ["setRotation"], "fileName": "com.badlogic.gdx.physics.box2d.Transform"}, {"methodBody": ["METHOD_START", "{", "aabb . lowerBound . set ( lowerX ,    lowerY )  ;", "aabb . upperBound . set ( upperX ,    upperY )  ;", "w . queryAABB ( new   QueryCallback (  )     {", "@ Override", "public   boolean   reportFixture ( Fixture   f )     {", "Fixture   fixture    =    fixtures . get ( f )  ;", "return   callback . reportFixture ( fixture )  ;", "}", "}  ,    aabb )  ;", "}", "METHOD_END"], "methodName": ["QueryAABB"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "world . clearForces (  )  ;", "}", "METHOD_END"], "methodName": ["clearForces"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "BodyDef   bd    =    new   BodyDef (  )  ;", "bd . active    =    def . active ;", "bd . allowSleep    =    def . allowSleep ;", "bd . angle    =    def . angle ;", "bd . angularDamping    =    def . angularDamping ;", "bd . angularVelocity    =    def . angularVelocity ;", "bd . awake    =    def . awake ;", "bd . bullet    =    def . bullet ;", "bd . fixedRotation    =    def . fixedRotation ;", "bd . gravityScale    =    def . gravityScale ;", "bd . linearDamping    =    def . linearDamping ;", "bd . linearVelocity . set ( def . linearVelocity . x ,    def . linearVelocity . y )  ;", "bd . position . set ( def . position . x ,    def . position . y )  ;", "if    (  ( def . type )     =  =     ( BodyDef . BodyType . DynamicBody )  )", "bd . type    =    DYNAMIC ;", "if    (  ( def . type )     =  =     ( BodyDef . BodyType . StaticBody )  )", "bd . type    =    STATIC ;", "if    (  ( def . type )     =  =     ( BodyDef . BodyType . KinematicBody )  )", "bd . type    =    KINEMATIC ;", "Body   b    =    world . createBody ( bd )  ;", "Body   body    =    new   Body ( this ,    b )  ;", "bodies . put ( b ,    body )  ;", "return   body ;", "}", "METHOD_END"], "methodName": ["createBody"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "JointDef   jd    =    def . toJBox 2 d (  )  ;", "Joint   j    =    world . createJoint ( jd )  ;", "Joint   joint    =    null ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . DistanceJoint )  )", "joint    =    new   joints . DistanceJoint ( this ,     (  ( DistanceJoint )     ( j )  )  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . FrictionJoint )  )", "joint    =    new   joints . FrictionJoint ( this ,     (  ( FrictionJoint )     ( j )  )  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . GearJoint )  )", "joint    =    new   joints . GearJoint ( this ,     (  ( GearJoint )     ( j )  )  ,     (  ( joints . GearJointDef )     ( def )  )  . joint 1  ,     (  ( joints . GearJointDef )     ( def )  )  . joint 2  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . MotorJoint )  )", "joint    =    new   joints . MotorJoint ( this ,     (  ( MotorJoint )     ( j )  )  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . MouseJoint )  )", "joint    =    new   joints . MouseJoint ( this ,     (  ( MouseJoint )     ( j )  )  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . PrismaticJoint )  )", "joint    =    new   joints . PrismaticJoint ( this ,     (  ( PrismaticJoint )     ( j )  )  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . PulleyJoint )  )", "joint    =    new   joints . PulleyJoint ( this ,     (  ( PulleyJoint )     ( j )  )  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . RevoluteJoint )  )", "joint    =    new   joints . RevoluteJoint ( this ,     (  ( RevoluteJoint )     ( j )  )  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . RopeJoint )  )", "joint    =    new   joints . RopeJoint ( this ,     (  ( RopeJoint )     ( j )  )  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . WeldJoint )  )", "joint    =    new   joints . WeldJoint ( this ,     (  ( WeldJoint )     ( j )  )  )  ;", "if    (  ( def . type )     =  =     ( JointDef . JointType . WheelJoint )  )", "joint    =    new   joints . WheelJoint ( this ,     (  ( WheelJoint )     ( j )  )  )  ;", "if    ( joint    =  =    null )", "throw   new   com . badlogic . gdx . utils . GdxRuntimeException (  (  (  \" Joint   type    '  \"     +     ( def . type )  )     +     \"  '    not   yet   supported   by   GWT   backend \"  )  )  ;", "joints . put ( j ,    joint )  ;", "return   joint ;", "}", "METHOD_END"], "methodName": ["createJoint"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "JointEdge   jointEdge    =    body . body . getJointList (  )  ;", "while    ( jointEdge    !  =    null )     {", "JointEdge   next    =    jointEdge . next ;", "w . destroyJoint ( jointEdge . joint )  ;", "joints . remove ( jointEdge . joint )  ;", "jointEdge    =    next ;", "}", "w . destroyBody ( body . body )  ;", "bodies . remove ( body . body )  ;", "for    ( Fixture   fixture    :    body . fixtures )     {", "fixtures . remove ( fixture . fixture )  ;", "}", "}", "METHOD_END"], "methodName": ["destroyBody"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "joint . setUserData ( null )  ;", "w . destroyJoint ( joint . joint )  ;", "joints . remove ( joint . joint )  ;", "}", "METHOD_END"], "methodName": ["destroyJoint"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   world . getAutoClearForces (  )  ;", "}", "METHOD_END"], "methodName": ["getAutoClearForces"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "bodies . clear (  )  ;", "bodies . ensureCapacity ( thidies . size )  ;", "for    ( Iterator < Body >    iter    =    thidies . values (  )  ;    iter . hasNext (  )  ;  )     {", "bodies . add ( iter . next (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getBodies"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   world . getBodyCount (  )  ;", "}", "METHOD_END"], "methodName": ["getBodyCount"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   world . getContactCount (  )  ;", "}", "METHOD_END"], "methodName": ["getContactCount"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "Contact   contactList    =    world . getContactList (  )  ;", "contacts . clear (  )  ;", "while    ( contactList    !  =    null )     {", "Contact   contact    =    new   Contact ( this ,    contactList )  ;", "contacts . add ( contact )  ;", "contactList    =    contactList . m _ next ;", "}", "return   contacts ;", "}", "METHOD_END"], "methodName": ["getContactList"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "Vec 2    gravity    =    world . getGravity (  )  ;", "return   tmp 2  . set ( gravity . x ,    gravity . y )  ;", "}", "METHOD_END"], "methodName": ["getGravity"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   world . getJointCount (  )  ;", "}", "METHOD_END"], "methodName": ["getJointCount"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "joints . clear (  )  ;", "joints . ensureCapacity ( this . joints . size )  ;", "for    ( Iterator < Joint >    iter    =    this . joints . values (  )  ;    iter . hasNext (  )  ;  )     {", "joints . add ( iter . next (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getJoints"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   world . getProxyCount (  )  ;", "}", "METHOD_END"], "methodName": ["getProxyCount"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   Settings . velocityThreshold ;", "}", "METHOD_END"], "methodName": ["getVelocityThreshold"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   world . isLocked (  )  ;", "}", "METHOD_END"], "methodName": ["isLocked"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "rayCast ( callback ,    point 1  . x ,    point 1  . y ,    point 2  . x ,    point 2  . y )  ;", "}", "METHOD_END"], "methodName": ["rayCast"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "world . raycast ( new   RayCastCallback (  )     {", "@ Override", "public   float   reportFixture ( Fixture   f ,    Vec 2    p ,    Vec 2    n ,    float   fraction )     {", "return   callback . reportRayFixture ( fixtures . get ( f )  ,    point . set ( p . x ,    p . y )  ,    normal . set ( n . x ,    n . y )  ,    fraction )  ;", "}", "}  ,    this . point 1  . set ( point 1 X ,    point 1 Y )  ,    this . point 2  . set ( point 2 X ,    point 2 Y )  )  ;", "}", "METHOD_END"], "methodName": ["rayCast"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "world . setAutoClearForces ( flag )  ;", "}", "METHOD_END"], "methodName": ["setAutoClearForces"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "if    ( filter    !  =    null )     {", "world . setContactFilter ( new   ContactFilter (  )     {", "@ Override", "public   boolean   shouldCollide ( Fixture   fixtureA ,    Fixture   fixtureB )     {", "return   filter . shouldCollide ( fixtures . get ( fixtureA )  ,    fixtures . get ( fixtureB )  )  ;", "}", "}  )  ;", "} else    {", "world . setContactFilter ( new   ContactFilter (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setContactFilter"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "if    ( listener    !  =    null )     {", "world . setContactListener ( new   ContactListener (  )     {", "@ Override", "public   void   beginContact ( Contact   contact )     {", "tmpContact . contact    =    contact ;", "listener . beginContact ( tmpContact )  ;", "}", "@ Override", "public   void   endContact ( Contact   contact )     {", "tmpContact . contact    =    contact ;", "listener . endContact ( tmpContact )  ;", "}", "@ Override", "public   void   preSolve ( Contact   contact ,    Manifold   oldManifold )     {", "tmpContact . contact    =    contact ;", "tmpManifold . manifold    =    oldManifold ;", "listener . preSolve ( tmpContact ,    tmpManifold )  ;", "}", "@ Override", "public   void   postSolve ( Contact   contact ,    ContactImpulse   impulse )     {", "tmpContact . contact    =    contact ;", "tmpImpulse . impulse    =    impulse ;", "listener . postSolve ( tmpContact ,    tmpImpulse )  ;", "}", "}  )  ;", "} else    {", "world . setContactListener ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["setContactListener"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "world . setContinuousPhysics ( flag )  ;", "}", "METHOD_END"], "methodName": ["setContinuousPhysics"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "world . setGravity ( tmp . set ( gravity . x ,    gravity . y )  )  ;", "}", "METHOD_END"], "methodName": ["setGravity"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "Settings . velocityThreshold    =    threshold ;", "}", "METHOD_END"], "methodName": ["setVelocityThreshold"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "world . setWarmStarting ( flag )  ;", "}", "METHOD_END"], "methodName": ["setWarmStarting"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "world . step ( timeStep ,    velocityIterations ,    positionIterations )  ;", "}", "METHOD_END"], "methodName": ["step"], "fileName": "com.badlogic.gdx.physics.box2d.World"}, {"methodBody": ["METHOD_START", "{", "return   normal ;", "}", "METHOD_END"], "methodName": ["getNormal"], "fileName": "com.badlogic.gdx.physics.box2d.WorldManifold"}, {"methodBody": ["METHOD_START", "{", "return   numContactPoints ;", "}", "METHOD_END"], "methodName": ["getNumberOfContactPoints"], "fileName": "com.badlogic.gdx.physics.box2d.WorldManifold"}, {"methodBody": ["METHOD_START", "{", "return   points ;", "}", "METHOD_END"], "methodName": ["getPoints"], "fileName": "com.badlogic.gdx.physics.box2d.WorldManifold"}, {"methodBody": ["METHOD_START", "{", "return   separations ;", "}", "METHOD_END"], "methodName": ["getSeparations"], "fileName": "com.badlogic.gdx.physics.box2d.WorldManifold"}, {"methodBody": ["METHOD_START", "{", "return   joint . getDampingRatio (  )  ;", "}", "METHOD_END"], "methodName": ["getDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getFrequency (  )  ;", "}", "METHOD_END"], "methodName": ["getFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getLength (  )  ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorA (  )  ;", "localAnchorA . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorB (  )  ;", "localAnchorB . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setDampingRatio ( ratio )  ;", "}", "METHOD_END"], "methodName": ["setDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setFrequency ( hz )  ;", "}", "METHOD_END"], "methodName": ["setFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setLength ( length )  ;", "}", "METHOD_END"], "methodName": ["setLength"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "this . localAnchorA . set ( bodyA . getLocalPoint ( anchorA )  )  ;", "this . localAnchorB . set ( bodyB . getLocalPoint ( anchorB )  )  ;", "this . length    =    anchorA . dst ( anchorB )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJointDef"}, {"methodBody": ["METHOD_START", "{", "DistanceJointDef   fd    =    new   DistanceJointDef (  )  ;", "fd . bodyA    =    bodyA . body ;", "fd . bodyB    =    bodyB . body ;", "fd . collideConnected    =    collideConnected ;", "fd . dampingRatio    =    dampingRatio ;", "fd . frequencyHz    =    frequencyHz ;", "fd . length    =    length ;", "fd . localAnchorA . set ( localAnchorA . x ,    localAnchorA . y )  ;", "fd . localAnchorB . set ( localAnchorB . x ,    localAnchorB . y )  ;", "fd . type    =    JointType . DISTANCE ;", "return   fd ;", "}", "METHOD_END"], "methodName": ["toJBox2d"], "fileName": "com.badlogic.gdx.physics.box2d.joints.DistanceJointDef"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorA (  )  ;", "localAnchorA . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorB (  )  ;", "localAnchorB . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMaxForce (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMaxTorque (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMaxForce ( force )  ;", "}", "METHOD_END"], "methodName": ["setMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMaxTorque ( torque )  ;", "}", "METHOD_END"], "methodName": ["setMaxTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "localAnchorA . set ( bodyA . getLocalPoint ( anchor )  )  ;", "localAnchorB . set ( bodyB . getLocalPoint ( anchor )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.FrictionJointDef"}, {"methodBody": ["METHOD_START", "{", "return   joint 1  ;", "}", "METHOD_END"], "methodName": ["getJoint1"], "fileName": "com.badlogic.gdx.physics.box2d.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint 2  ;", "}", "METHOD_END"], "methodName": ["getJoint2"], "fileName": "com.badlogic.gdx.physics.box2d.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getRatio (  )  ;", "}", "METHOD_END"], "methodName": ["getRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setRatio ( ratio )  ;", "}", "METHOD_END"], "methodName": ["setRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getAngularOffset (  )  ;", "}", "METHOD_END"], "methodName": ["getAngularOffset"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getCorrectionFactor (  )  ;", "}", "METHOD_END"], "methodName": ["getCorrectionFactor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "joint . getLinearOffset ( tmp )  ;", "return   linearOffset . set ( tmp . x ,    tmp . y )  ;", "}", "METHOD_END"], "methodName": ["getLinearOffset"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMaxForce (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMaxTorque (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setAngularOffset ( angularOffset )  ;", "}", "METHOD_END"], "methodName": ["setAngularOffset"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setCorrectionFactor ( correctionFactor )  ;", "}", "METHOD_END"], "methodName": ["setCorrectionFactor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setLinearOffset ( tmp . set ( linearOffset . x ,    linearOffset . y )  )  ;", "}", "METHOD_END"], "methodName": ["setLinearOffset"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMaxForce ( maxForce )  ;", "}", "METHOD_END"], "methodName": ["setMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMaxTorque ( maxTorque )  ;", "}", "METHOD_END"], "methodName": ["setMaxTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    body 1  ;", "this . bodyB    =    body 2  ;", "this . linearOffset . set ( bodyA . getLocalPoint ( bodyB . getPosition (  )  )  )  ;", "this . angularOffset    =     ( bodyB . getAngle (  )  )     -     ( bodyA . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MotorJointDef"}, {"methodBody": ["METHOD_START", "{", "return   joint . getDampingRatio (  )  ;", "}", "METHOD_END"], "methodName": ["getDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getFrequency (  )  ;", "}", "METHOD_END"], "methodName": ["getFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMaxForce (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    t    =    joint . getTarget (  )  ;", "return   target . set ( t . x ,    t . y )  ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setDampingRatio ( ratio )  ;", "}", "METHOD_END"], "methodName": ["setDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setFrequency ( hz )  ;", "}", "METHOD_END"], "methodName": ["setFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMaxForce ( force )  ;", "}", "METHOD_END"], "methodName": ["setMaxForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "tmp . set ( target . x ,    target . y )  ;", ". setTarget ( tmp )  ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "com.badlogic.gdx.physics.box2d.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "joint . enableLimit ( flag )  ;", "}", "METHOD_END"], "methodName": ["enableLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "joint . enableMotor ( flag )  ;", "}", "METHOD_END"], "methodName": ["enableMotor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getJointSpeed (  )  ;", "}", "METHOD_END"], "methodName": ["getJointSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getJointTranslation (  )  ;", "}", "METHOD_END"], "methodName": ["getJointTranslation"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorA (  )  ;", "localAnchorA . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorB (  )  ;", "localAnchorB . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAxis    =    joint . getLocalAxisA (  )  ;", "localAxisA . set ( localAxis . x ,    localAxis . y )  ;", "return   localAxisA ;", "}", "METHOD_END"], "methodName": ["getLocalAxisA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getLowerLimit (  )  ;", "}", "METHOD_END"], "methodName": ["getLowerLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMaxMotorForce (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxMotorForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMotorForce ( invDt )  ;", "}", "METHOD_END"], "methodName": ["getMotorForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMotorSpeed (  )  ;", "}", "METHOD_END"], "methodName": ["getMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getReferenceAngle (  )  ;", "}", "METHOD_END"], "methodName": ["getReferenceAngle"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getUpperLimit (  )  ;", "}", "METHOD_END"], "methodName": ["getUpperLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . isLimitEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isLimitEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . isMotorEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isMotorEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setLimits ( lower ,    upper )  ;", "}", "METHOD_END"], "methodName": ["setLimits"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMaxMotorForce ( force )  ;", "}", "METHOD_END"], "methodName": ["setMaxMotorForce"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMotorSpeed ( speed )  ;", "}", "METHOD_END"], "methodName": ["setMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "localAnchorA . set ( bodyA . getLocalPoint ( anchor )  )  ;", "localAnchorB . set ( bodyB . getLocalPoint ( anchor )  )  ;", "localAxisA . set ( bodyA . getLocalVector ( axis )  )  ;", "referenceAngle    =     ( bodyB . getAngle (  )  )     -     ( bodyA . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PrismaticJointDef"}, {"methodBody": ["METHOD_START", "{", "Vec 2    g    =    joint . getGroundAnchorA (  )  ;", "return   groundAnchorA . set ( g . x ,    g . y )  ;", "}", "METHOD_END"], "methodName": ["getGroundAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    g    =    joint . getGroundAnchorB (  )  ;", "return   groundAnchorB . set ( g . x ,    g . y )  ;", "}", "METHOD_END"], "methodName": ["getGroundAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getLength 1  (  )  ;", "}", "METHOD_END"], "methodName": ["getLength1"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getLength 2  (  )  ;", "}", "METHOD_END"], "methodName": ["getLength2"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getRatio (  )  ;", "}", "METHOD_END"], "methodName": ["getRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "this . groundAnchorA . set ( groundAnchorA )  ;", "this . groundAnchorB . set ( groundAnchorB )  ;", "this . localAnchorA . set ( bodyA . getLocalPoint ( anchorA )  )  ;", "this . localAnchorB . set ( bodyB . getLocalPoint ( anchorB )  )  ;", "lengthA    =    anchorA . dst ( groundAnchorA )  ;", "lengthB    =    anchorB . dst ( groundAnchorB )  ;", "this . ratio    =    ratio ;", "float   C    =     ( lengthA )     +     ( ratio    *     ( lengthB )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.PulleyJointDef"}, {"methodBody": ["METHOD_START", "{", "joint . enableLimit ( flag )  ;", "}", "METHOD_END"], "methodName": ["enableLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "joint . enableMotor ( flag )  ;", "}", "METHOD_END"], "methodName": ["enableMotor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getJointAngle (  )  ;", "}", "METHOD_END"], "methodName": ["getJointAngle"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getJointSpeed (  )  ;", "}", "METHOD_END"], "methodName": ["getJointSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   localAnchorA . set ( joint . getLocalAnchorA (  )  . x ,    joint . getLocalAnchorA (  )  . y )  ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   localAnchorB . set ( joint . getLocalAnchorB (  )  . x ,    joint . getLocalAnchorB (  )  . y )  ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getLowerLimit (  )  ;", "}", "METHOD_END"], "methodName": ["getLowerLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMaxMotorTorque (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   motorSpeed ;", "}", "METHOD_END"], "methodName": ["getMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMotorTorque ( invDt )  ;", "}", "METHOD_END"], "methodName": ["getMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getReferenceAngle (  )  ;", "}", "METHOD_END"], "methodName": ["getReferenceAngle"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getUpperLimit (  )  ;", "}", "METHOD_END"], "methodName": ["getUpperLimit"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . isLimitEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isLimitEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . isMotorEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isMotorEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setLimits ( lower ,    upper )  ;", "}", "METHOD_END"], "methodName": ["setLimits"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMaxMotorTorque ( torque )  ;", "}", "METHOD_END"], "methodName": ["setMaxMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "motorSpeed    =    speed ;", ". setMotorSpeed ( speed )  ;", "}", "METHOD_END"], "methodName": ["setMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "localAnchorA . set ( bodyA . getLocalPoint ( anchor )  )  ;", "localAnchorB . set ( bodyB . getLocalPoint ( anchor )  )  ;", "referenceAngle    =     ( bodyB . getAngle (  )  )     -     ( bodyA . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RevoluteJointDef"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorA (  )  ;", "localAnchorA . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorB (  )  ;", "localAnchorB . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMaxLength (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxLength"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMaxLength ( maxLength )  ;", "}", "METHOD_END"], "methodName": ["setMaxLength"], "fileName": "com.badlogic.gdx.physics.box2d.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getDampingRatio (  )  ;", "}", "METHOD_END"], "methodName": ["getDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getFrequency (  )  ;", "}", "METHOD_END"], "methodName": ["getFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorA (  )  ;", "localAnchorA . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorB (  )  ;", "localAnchorB . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getReferenceAngle (  )  ;", "}", "METHOD_END"], "methodName": ["getReferenceAngle"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setDampingRatio ( dampingRatio )  ;", "}", "METHOD_END"], "methodName": ["setDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setFrequency ( frequencyHz )  ;", "}", "METHOD_END"], "methodName": ["setFrequency"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    body 1  ;", "this . bodyB    =    body 2  ;", "this . localAnchorA . set ( body 1  . getLocalPoint ( anchor )  )  ;", "this . localAnchorB . set ( body 2  . getLocalPoint ( anchor )  )  ;", "referenceAngle    =     ( body 2  . getAngle (  )  )     -     ( body 1  . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WeldJointDef"}, {"methodBody": ["METHOD_START", "{", "joint . enableMotor ( flag )  ;", "}", "METHOD_END"], "methodName": ["enableMotor"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getJointSpeed (  )  ;", "}", "METHOD_END"], "methodName": ["getJointSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getJointTranslation (  )  ;", "}", "METHOD_END"], "methodName": ["getJointTranslation"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorA (  )  ;", "localAnchorA . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAnchor    =    joint . getLocalAnchorB (  )  ;", "localAnchorB . set ( localAnchor . x ,    localAnchor . y )  ;", "return   localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    localAxis    =    joint . getLocalAxisA (  )  ;", "localAxisA . set ( localAxis . x ,    localAxis . y )  ;", "return   localAxisA ;", "}", "METHOD_END"], "methodName": ["getLocalAxisA"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMaxMotorTorque (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMotorSpeed (  )  ;", "}", "METHOD_END"], "methodName": ["getMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getMotorTorque ( invDt )  ;", "}", "METHOD_END"], "methodName": ["getMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getSpringDampingRatio (  )  ;", "}", "METHOD_END"], "methodName": ["getSpringDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . getSpringFrequencyHz (  )  ;", "}", "METHOD_END"], "methodName": ["getSpringFrequencyHz"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   joint . isMotorEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isMotorEnabled"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMaxMotorTorque ( torque )  ;", "}", "METHOD_END"], "methodName": ["setMaxMotorTorque"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setMotorSpeed ( speed )  ;", "}", "METHOD_END"], "methodName": ["setMotorSpeed"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setSpringDampingRatio ( ratio )  ;", "}", "METHOD_END"], "methodName": ["setSpringDampingRatio"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "joint . setSpringFrequencyHz ( hz )  ;", "}", "METHOD_END"], "methodName": ["setSpringFrequencyHz"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "this . bodyA    =    bodyA ;", "this . bodyB    =    bodyB ;", "localAnchorA . set ( bodyA . getLocalPoint ( anchor )  )  ;", "localAnchorB . set ( bodyB . getLocalPoint ( anchor )  )  ;", "localAxisA . set ( bodyA . getLocalVector ( axis )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "com.badlogic.gdx.physics.box2d.joints.WheelJointDef"}, {"methodBody": ["METHOD_START", "{", "return   Math . abs ( a )  ;", "}", "METHOD_END"], "methodName": ["abs"], "fileName": "java.lang.StrictMath"}, {"methodBody": ["METHOD_START", "{", "return   Math . atan 2  ( y ,    x )  ;", "}", "METHOD_END"], "methodName": ["atan2"], "fileName": "java.lang.StrictMath"}, {"methodBody": ["METHOD_START", "{", "return   Math . ceil ( a )  ;", "}", "METHOD_END"], "methodName": ["ceil"], "fileName": "java.lang.StrictMath"}, {"methodBody": ["METHOD_START", "{", "return   Math . cos ( a )  ;", "}", "METHOD_END"], "methodName": ["cos"], "fileName": "java.lang.StrictMath"}, {"methodBody": ["METHOD_START", "{", "return   Math . floor ( a )  ;", "}", "METHOD_END"], "methodName": ["floor"], "fileName": "java.lang.StrictMath"}, {"methodBody": ["METHOD_START", "{", "return   Math . pow ( a ,    b )  ;", "}", "METHOD_END"], "methodName": ["pow"], "fileName": "java.lang.StrictMath"}, {"methodBody": ["METHOD_START", "{", "return   Math . round ( a )  ;", "}", "METHOD_END"], "methodName": ["round"], "fileName": "java.lang.StrictMath"}, {"methodBody": ["METHOD_START", "{", "return   Math . sin ( a )  ;", "}", "METHOD_END"], "methodName": ["sin"], "fileName": "java.lang.StrictMath"}, {"methodBody": ["METHOD_START", "{", "return   Math . sqrt ( a )  ;", "}", "METHOD_END"], "methodName": ["sqrt"], "fileName": "java.lang.StrictMath"}, {"methodBody": ["METHOD_START", "{", "Filter   filterA    =    fixtureA . getFilterData (  )  ;", "Filter   filterB    =    fixtureB . getFilterData (  )  ;", "if    (  (  ( filterA . groupIndex )     =  =     ( filterB . groupIndex )  )     &  &     (  ( filterA . groupIndex )     !  =     0  )  )     {", "return    ( filterA . groupIndex )     >     0  ;", "}", "boolean   collide    =     (  (  ( filterA . maskBits )     &     ( filterB . categoryBits )  )     !  =     0  )     &  &     (  (  ( filterA . categoryBits )     &     ( filterB . maskBits )  )     !  =     0  )  ;", "return   collide ;", "}", "METHOD_END"], "methodName": ["shouldCollide"], "fileName": "org.jbox2d.callbacks.ContactFilter"}, {"methodBody": ["METHOD_START", "{", "m _ drawFlags    |  =    flags ;", "}", "METHOD_END"], "methodName": ["appendFlags"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "m _ drawFlags    &  =     ~ flags ;", "}", "METHOD_END"], "methodName": ["clearFlags"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "drawCircle ( center ,    radius ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawCircle"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "if    ( vertexCount    =  =     1  )     {", "dSegment ( vertices [  0  ]  ,    vertices [  0  ]  ,    color )  ;", "return ;", "}", "for    ( int   i    =     0  ;    i    <     ( vertexCount    -     1  )  ;    i    +  =     1  )     {", "dSegment ( vertices [ i ]  ,    vertices [  ( i    +     1  )  ]  ,    color )  ;", "}", "if    ( vertexCount    >     2  )     {", "dSegment ( vertices [  ( vertexCount    -     1  )  ]  ,    vertices [  0  ]  ,    color )  ;", "}", "}", "METHOD_END"], "methodName": ["drawPolygon"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "drawString ( pos . x ,    pos . y ,    s ,    color )  ;", "}", "METHOD_END"], "methodName": ["drawString"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "return   m _ drawFlags ;", "}", "METHOD_END"], "methodName": ["getFlags"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "Vec 2    screen    =    new   Vec 2  ( screenX ,    screenY )  ;", "viewptTransfm . getScreenToWld ( screen ,    screen )  ;", "return   screen ;", "}", "METHOD_END"], "methodName": ["getScreenToWorld"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "Vec 2    world    =    new   Vec 2  (  )  ;", "viewportTransform . getScreenToWorld ( argScreen ,    world )  ;", "return   world ;", "}", "METHOD_END"], "methodName": ["getScreenToWorld"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "argWorld . set ( screenX ,    screenY )  ;", "viewportTransform . getScreenToWorld ( argWorld ,    argWorld )  ;", "}", "METHOD_END"], "methodName": ["getScreenToWorldToOut"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "viewportTransform . getScreenToWorld ( argScreen ,    argWorld )  ;", "}", "METHOD_END"], "methodName": ["getScreenToWorldToOut"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "return   viewportTransform ;", "}", "METHOD_END"], "methodName": ["getViewportTranform"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "Vec 2    argScreen    =    new   Vec 2  ( worldX ,    worldY )  ;", "viewportTransform . getWorldToScreen ( argScreen ,    argScreen )  ;", "return   argScreen ;", "}", "METHOD_END"], "methodName": ["getWorldToScreen"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "Vec 2    screen    =    new   Vec 2  (  )  ;", "viewptTransfm . getWldToScreen ( argWld ,    screen )  ;", "return   screen ;", "}", "METHOD_END"], "methodName": ["getWorldToScreen"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "argScreen . set ( worldX ,    worldY )  ;", "viewportTransform . getWorldToScreen ( argScreen ,    argScreen )  ;", "}", "METHOD_END"], "methodName": ["getWorldToScreenToOut"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "viewportTransform . getWorldToScreen ( argWorld ,    argScreen )  ;", "}", "METHOD_END"], "methodName": ["getWorldToScreenToOut"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "viewportTransform . setCamera ( x ,    y ,    scale )  ;", "}", "METHOD_END"], "methodName": ["setCamera"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "m _ drawFlags    =    flags ;", "}", "METHOD_END"], "methodName": ["setFlags"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "this . viewportTransform    =    viewportTransform ;", "}", "METHOD_END"], "methodName": ["setViewportTransform"], "fileName": "org.jbox2d.callbacks.DebugDraw"}, {"methodBody": ["METHOD_START", "{", "lowerBound . x    =     (  ( lowerBound . x )     <     ( aabb . lowerBound . x )  )     ?    lowerBound . x    :    aabb . lowerBound . x ;", "lowerBound . y    =     (  ( lowerBound . y )     <     ( aabb . lowerBound . y )  )     ?    lowerBound . y    :    aabb . lowerBound . y ;", "upperBound . x    =     (  ( upperBound . x )     >     ( aabb . upperBound . x )  )     ?    upperBound . x    :    aabb . upperBound . x ;", "upperBound . y    =     (  ( upperBound . y )     >     ( aabb . upperBound . y )  )     ?    upperBound . y    :    aabb . upperBound . y ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "lowerBound . x    =     (  ( aabb 1  . lowerBound . x )     <     ( aab . lowerBound . x )  )     ?    aabb 1  . lowerBound . x    :    aab . lowerBound . x ;", "lowerBound . y    =     (  ( aabb 1  . lowerBound . y )     <     ( aab . lowerBound . y )  )     ?    aabb 1  . lowerBound . y    :    aab . lowerBound . y ;", "upperBound . x    =     (  ( aabb 1  . upperBound . x )     >     ( aab . upperBound . x )  )     ?    aabb 1  . upperBound . x    :    aab . upperBound . x ;", "upperBound . y    =     (  ( aabb 1  . upperBound . y )     >     ( aab . upperBound . y )  )     ?    aabb 1  . upperBound . y    :    aab . upperBound . y ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( lowerBound . x )     <  =     ( aabb . lowerBound . x )  )     &  &     (  ( lowerBound . y )     <  =     ( aabb . lowerBound . y )  )  )     &  &     (  ( aabb . upperBound . x )     <  =     ( upperBound . x )  )  )     &  &     (  ( aabb . upperBound . y )     <  =     ( upperBound . y )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "final   Vec 2    center    =    new   Vec 2  ( lowerBound )  ;", "center . addLocal ( upperBound )  ;", "center . mulLocal (  0  .  5 F )  ;", "return   center ;", "}", "METHOD_END"], "methodName": ["getCenter"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "out . x    =     (  ( lowerBound . x )     +     ( upperBound . x )  )     *     0  .  5 F ;", "out . y    =     (  ( lowerBound . y )     +     ( upperBound . y )  )     *     0  .  5 F ;", "}", "METHOD_END"], "methodName": ["getCenterToOut"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "final   Vec 2    center    =    new   Vec 2  ( upperBound )  ;", "center . subLocal ( lowerBound )  ;", "center . mulLocal (  0  .  5 F )  ;", "return   center ;", "}", "METHOD_END"], "methodName": ["getExtents"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "out . x    =     (  ( upperBound . x )     -     ( lowerBound . x )  )     *     0  .  5 F ;", "out . y    =     (  ( upperBound . y )     -     ( lowerBound . y )  )     *     0  .  5 F ;", "}", "METHOD_END"], "methodName": ["getExtentsToOut"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "return    2  .  0 F    *     (  (  (  ( upperBound . x )     -     ( lowerBound . x )  )     +     ( upperBound . y )  )     -     ( lowerBound . y )  )  ;", "}", "METHOD_END"], "methodName": ["getPerimeter"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "argRay [  0  ]  . set ( lowerBound )  ;", "argRay [  1  ]  . set ( lowerBound )  ;", "argRay [  1  ]  . x    +  =     ( upperBound . x )     -     ( lowerBound . x )  ;", "argRay [  2  ]  . set ( upperBound )  ;", "argRay [  3  ]  . set ( upperBound )  ;", "argRay [  3  ]  . x    -  =     ( upperBound . x )     -     ( lowerBound . x )  ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "final   float   dx    =     ( upperBound . x )     -     ( lowerBound . x )  ;", "if    ( dx    <     0  .  0 F )     {", "return   false ;", "}", "final   float   dy    =     ( upperBound . y )     -     ( lowerBound . y )  ;", "if    ( dy    <     0  )     {", "return   false ;", "}", "return    ( lowerBound . isValid (  )  )     &  &     ( upperBound . isValid (  )  )  ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "return   raycast ( output ,    input ,    new   DefaultWorldPool (  4  ,     4  )  )  ;", "}", "METHOD_END"], "methodName": ["raycast"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "float   tmin    =     -  ( Float . MAX _ VALUE )  ;", "float   tmax    =    Float . MAX _ VALUE ;", "final   Vec 2    p    =    argPool . popVec 2  (  )  ;", "final   Vec 2    d    =    argPool . popVec 2  (  )  ;", "final   Vec 2    absD    =    argPool . popVec 2  (  )  ;", "final   Vec 2    normal    =    argPool . popVec 2  (  )  ;", "p . set ( input . p 1  )  ;", "d . set ( input . p 2  )  . subLocal ( input . p 1  )  ;", "Vec 2  . absToOut ( d ,    absD )  ;", "if    (  ( absD . x )     <     ( Settings . EPSILON )  )     {", "if    (  (  ( p . x )     <     ( lowerBound . x )  )     |  |     (  ( upperBound . x )     <     ( p . x )  )  )     {", "argPool . pushVec 2  (  4  )  ;", "return   false ;", "}", "} else    {", "final   float   inv _ d    =     1  .  0 F    /     ( d . x )  ;", "float   t 1     =     (  ( lowerBound . x )     -     ( p . x )  )     *    inv _ d ;", "float   t 2     =     (  ( upperBound . x )     -     ( p . x )  )     *    inv _ d ;", "float   s    =     -  1  .  0 F ;", "if    ( t 1     >    t 2  )     {", "final   float   temp    =    t 1  ;", "t 1     =    t 2  ;", "t 2     =    temp ;", "s    =     1  .  0 F ;", "}", "if    ( t 1     >    tmin )     {", "normal . setZero (  )  ;", "normal . x    =    s ;", "tmin    =    t 1  ;", "}", "tmax    =    MathUtils . min ( tmax ,    t 2  )  ;", "if    ( tmin    >    tmax )     {", "argPool . pushVec 2  (  4  )  ;", "return   false ;", "}", "}", "if    (  ( absD . y )     <     ( Settings . EPSILON )  )     {", "if    (  (  ( p . y )     <     ( lowerBound . y )  )     |  |     (  ( upperBound . y )     <     ( p . y )  )  )     {", "argPool . pushVec 2  (  4  )  ;", "return   false ;", "}", "} else    {", "final   float   inv _ d    =     1  .  0 F    /     ( d . y )  ;", "float   t 1     =     (  ( lowerBound . y )     -     ( p . y )  )     *    inv _ d ;", "float   t 2     =     (  ( upperBound . y )     -     ( p . y )  )     *    inv _ d ;", "float   s    =     -  1  .  0 F ;", "if    ( t 1     >    t 2  )     {", "final   float   temp    =    t 1  ;", "t 1     =    t 2  ;", "t 2     =    temp ;", "s    =     1  .  0 F ;", "}", "if    ( t 1     >    tmin )     {", "normal . setZero (  )  ;", "normal . y    =    s ;", "tmin    =    t 1  ;", "}", "tmax    =    MathUtils . min ( tmax ,    t 2  )  ;", "if    ( tmin    >    tmax )     {", "argPool . pushVec 2  (  4  )  ;", "return   false ;", "}", "}", "if    (  ( tmin    <     0  .  0 F )     |  |     (  ( input . maxFract )     <    tmin )  )     {", "argPool . pushVec 2  (  4  )  ;", "return   false ;", "}", "output . fract    =    tmin ;", "output . normal . x    =    normal . x ;", "output . normal . y    =    normal . y ;", "argPool . pushVec 2  (  4  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["raycast"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "Vec 2    v    =    aabb . lowerBoun", "lowerBounx    =    v . x ;", "lowerBouny    =    v . y ;", "Vec 2    v 1     =    aabb . upperBoun", "upperBounx    =    v 1  . x ;", "upperBouny    =    v 1  . y ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( b . lowerBound . x )     -     ( a . upperBound . x )  )     >     0  .  0 F )     |  |     (  (  ( b . lowerBound . y )     -     ( a . upperBound . y )  )     >     0  .  0 F )  )     {", "return   false ;", "}", "if    (  (  (  ( a . lowerBound . x )     -     ( b . upperBound . x )  )     >     0  .  0 F )     |  |     (  (  ( a . lowerBound . y )     -     ( b . upperBound . y )  )     >     0  .  0 F )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["testOverlap"], "fileName": "org.jbox2d.collision.AABB"}, {"methodBody": ["METHOD_START", "{", "int   numOut    =     0  ;", "final   ClipVertex   vIn 0     =    vIn [  0  ]  ;", "final   ClipVertex   vIn 1     =    vIn [  1  ]  ;", "final   Vec 2    vIn 0 v    =    vIn 0  . v ;", "final   Vec 2    vIn 1 v    =    vIn 1  . v ;", "float   distance 0     =     ( Vec 2  . dot ( normal ,    vIn 0 v )  )     -    offset ;", "float   distance 1     =     ( Vec 2  . dot ( normal ,    vIn 1 v )  )     -    offset ;", "if    ( distance 0     <  =     0  .  0 F )     {", "vOut [  ( numOut +  +  )  ]  . set ( vIn 0  )  ;", "}", "if    ( distance 1     <  =     0  .  0 F )     {", "vOut [  ( numOut +  +  )  ]  . set ( vIn 1  )  ;", "}", "if    (  ( distance 0     *    distance 1  )     <     0  .  0 F )     {", "float   interp    =    distance 0     /     ( distance 0     -    distance 1  )  ;", "ClipVertex   vOutNO    =    vOut [ numOut ]  ;", "vOutNO . v . x    =     ( vIn 0 v . x )     +     ( interp    *     (  ( vIn 1 v . x )     -     ( vIn 0 v . x )  )  )  ;", "vOutNO . v . y    =     ( vIn 0 v . y )     +     ( interp    *     (  ( vIn 1 v . y )     -     ( vIn 0 v . y )  )  )  ;", "vOutNO . id . indexA    =     (  ( byte )     ( vertexIndexA )  )  ;", "vOutNO . id . indexB    =    vIn 0  . id . indexB ;", "vOutNO . id . typeA    =     (  ( byte )     ( ContactID . Type . VERTEX . ordinal (  )  )  )  ;", "vOutNO . id . typeB    =     (  ( byte )     ( ContactID . Type . FACE . ordinal (  )  )  )  ;", "+  + numOut ;", "}", "return   numOut ;", "}", "METHOD_END"], "methodName": ["clipSegmentToLine"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "manifold . pointCount    =     0  ;", "Vec 2    circle 1 p    =    circle 1  . m _ p ;", "Vec 2    circle 2 p    =    circle 2  . m _ p ;", "float   pAx    =     (  (  ( xfA . q . c )     *     ( circle 1 p . x )  )     -     (  ( xfA . q . s )     *     ( circle 1 p . y )  )  )     +     ( xfA . p . x )  ;", "float   pAy    =     (  (  ( xfA . q . s )     *     ( circle 1 p . x )  )     +     (  ( xfA . q . c )     *     ( circle 1 p . y )  )  )     +     ( xfA . p . y )  ;", "float   pBx    =     (  (  ( xfB . q . c )     *     ( circle 2 p . x )  )     -     (  ( xfB . q . s )     *     ( circle 2 p . y )  )  )     +     ( xfB . p . x )  ;", "float   pBy    =     (  (  ( xfB . q . s )     *     ( circle 2 p . x )  )     +     (  ( xfB . q . c )     *     ( circle 2 p . y )  )  )     +     ( xfB . p . y )  ;", "float   dx    =    pBx    -    pAx ;", "float   dy    =    pBy    -    pAy ;", "float   distSqr    =     ( dx    *    dx )     +     ( dy    *    dy )  ;", "final   float   radius    =     ( circle 1  . m _ radius )     +     ( circle 2  . m _ radius )  ;", "if    ( distSqr    >     ( radius    *    radius )  )     {", "return ;", "}", "manifold . type    =    Manifold . ManifoldType . CIRCLES ;", "manifold . localPoint . set ( circle 1 p )  ;", "manifold . localNormal . setZero (  )  ;", "manifold . pointCount    =     1  ;", "manifold . points [  0  ]  . localPoint . set ( circle 2 p )  ;", "manifold . points [  0  ]  . id . zero (  )  ;", "}", "METHOD_END"], "methodName": ["collideCircles"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "manifold . pointCount    =     0  ;", "Transform . mulToOutUnsafe ( xfB ,    circleB . m _ p ,    temp )  ;", "Transform . mulTransToOutUnsafe ( xfA ,    temp ,    Q )  ;", "final   Vec 2    A    =    edgeA . m _ vertex 1  ;", "final   Vec 2    B    =    edgeA . m _ vertex 2  ;", "e . set ( B )  . subLocal ( A )  ;", "float   u    =    Vec 2  . dot ( e ,    temp . set ( B )  . subLocal ( Q )  )  ;", "float   v    =    Vec 2  . dot ( e ,    temp . set ( Q )  . subLocal ( A )  )  ;", "float   radius    =     ( edgeA . m _ radius )     +     ( circleB . m _ radius )  ;", "cf . indexB    =     0  ;", "cf . typeB    =     (  ( byte )     ( ContactID . Type . VERTEX . ordinal (  )  )  )  ;", "if    ( v    <  =     0  .  0 F )     {", "final   Vec 2    P    =    A ;", "Cd . set ( Q )  . subLocal ( P )  ;", "float   dd    =    Vec 2  . dot ( Cd ,    Cd )  ;", "if    ( dd    >     ( radius    *    radius )  )     {", "return ;", "}", "if    ( edgeA . m _ hasVertex 0  )     {", "final   Vec 2    A 1     =    edgeA . m _ vertex 0  ;", "final   Vec 2    B 1     =    A ;", "e 1  . set ( B 1  )  . subLocal ( A 1  )  ;", "float   u 1     =    Vec 2  . dot ( e 1  ,    temp . set ( B 1  )  . subLocal ( Q )  )  ;", "if    ( u 1     >     0  .  0 F )     {", "return ;", "}", "}", "cf . indexA    =     0  ;", "cf . typeA    =     (  ( byte )     ( ContactID . Type . VERTEX . ordinal (  )  )  )  ;", "manifold . pointCount    =     1  ;", "manifold . type    =    Manifold . ManifoldType . CIRCLES ;", "manifold . localNormal . setZero (  )  ;", "manifold . localPoint . set ( P )  ;", "manifold . points [  0  ]  . id . set ( cf )  ;", "manifold . points [  0  ]  . localPoint . set ( circleB . m _ p )  ;", "return ;", "}", "if    ( u    <  =     0  .  0 F )     {", "Vec 2    P    =    B ;", "Cd . set ( Q )  . subLocal ( P )  ;", "float   dd    =    Vec 2  . dot ( Cd ,    Cd )  ;", "if    ( dd    >     ( radius    *    radius )  )     {", "return ;", "}", "if    ( edgeA . m _ hasVertex 3  )     {", "final   Vec 2    B 2     =    edgeA . m _ vertex 3  ;", "final   Vec 2    A 2     =    B ;", "final   Vec 2    e 2     =    e 1  ;", "e 2  . set ( B 2  )  . subLocal ( A 2  )  ;", "float   v 2     =    Vec 2  . dot ( e 2  ,    temp . set ( Q )  . subLocal ( A 2  )  )  ;", "if    ( v 2     >     0  .  0 F )     {", "return ;", "}", "}", "cf . indexA    =     1  ;", "cf . typeA    =     (  ( byte )     ( ContactID . Type . VERTEX . ordinal (  )  )  )  ;", "manifold . pointCount    =     1  ;", "manifold . type    =    Manifold . ManifoldType . CIRCLES ;", "manifold . localNormal . setZero (  )  ;", "manifold . localPoint . set ( P )  ;", "manifold . points [  0  ]  . id . set ( cf )  ;", "manifold . points [  0  ]  . localPoint . set ( circleB . m _ p )  ;", "return ;", "}", "float   den    =    Vec 2  . dot ( e ,    e )  ;", "assert   den    >     0  .  0 F ;", "P . set ( A )  . mulLocal ( u )  . addLocal ( temp . set ( B )  . mulLocal ( v )  )  ;", "P . mulLocal (  (  1  .  0 F    /    den )  )  ;", "Cd . set ( Q )  . subLocal ( P )  ;", "float   dd    =    Vec 2  . dot ( Cd ,    Cd )  ;", "if    ( dd    >     ( radius    *    radius )  )     {", "return ;", "}", "n . x    =     -  ( e . y )  ;", "n . y    =    e . x ;", "if    (  ( Vec 2  . dot ( n ,    temp . set ( Q )  . subLocal ( A )  )  )     <     0  .  0 F )     {", "n . set (  (  -  ( n . x )  )  ,     (  -  ( n . y )  )  )  ;", "}", "n . normalize (  )  ;", "cf . indexA    =     0  ;", "cf . typeA    =     (  ( byte )     ( ContactID . Type . FACE . ordinal (  )  )  )  ;", "manifold . pointCount    =     1  ;", "manifold . type    =    Manifold . ManifoldType . FACE _ A ;", "manifold . localNormal . set ( n )  ;", "manifold . localPoint . set ( A )  ;", "manifold . points [  0  ]  . id . set ( cf )  ;", "manifold . points [  0  ]  . localPoint . set ( circleB . m _ p )  ;", "}", "METHOD_END"], "methodName": ["collideEdgeAndCircle"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "collider . collide ( manifold ,    edgeA ,    xfA ,    polygonB ,    xfB )  ;", "}", "METHOD_END"], "methodName": ["collideEdgeAndPolygon"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "manifold . pointCount    =     0  ;", "final   Vec 2    circlep    =    circle . m _ p ;", "final   Rot   xfBq    =    xfB . q ;", "final   Rot   xfAq    =    xfA . q ;", "final   float   cx    =     (  (  ( xfBq . c )     *     ( circlep . x )  )     -     (  ( xfBq . s )     *     ( circlep . y )  )  )     +     ( xfB . p . x )  ;", "final   float   cy    =     (  (  ( xfBq . s )     *     ( circlep . x )  )     +     (  ( xfBq . c )     *     ( circlep . y )  )  )     +     ( xfB . p . y )  ;", "final   float   px    =    cx    -     ( xfA . p . x )  ;", "final   float   py    =    cy    -     ( xfA . p . y )  ;", "final   float   cLocalx    =     (  ( xfAq . c )     *    px )     +     (  ( xfAq . s )     *    py )  ;", "final   float   cLocaly    =     (  (  -  ( xfAq . s )  )     *    px )     +     (  ( xfAq . c )     *    py )  ;", "int   normalIndex    =     0  ;", "float   separat    =     -  ( Float . MAX _ VALUE )  ;", "final   float   radius    =     ( polygon . m _ radius )     +     ( circle . m _ radius )  ;", "final   int   vertexCount    =    polygon . m _ count ;", "float   s ;", "final   Vec 2  [  ]    vertices    =    polygon . m _ vertices ;", "final   Vec 2  [  ]    normals    =    polygon . m _ normals ;", "for    ( int   i    =     0  ;    i    <    vertexCount ;    i +  +  )     {", "final   Vec 2    vertex    =    vertices [ i ]  ;", "final   float   tempx    =    cLocalx    -     ( vertex . x )  ;", "final   float   tempy    =    cLocaly    -     ( vertex . y )  ;", "s    =     (  ( normals [ i ]  . x )     *    tempx )     +     (  ( normals [ i ]  . y )     *    tempy )  ;", "if    ( s    >    radius )     {", "return ;", "}", "if    ( s    >    separat )     {", "separat    =    s ;", "normalIndex    =    i ;", "}", "}", "final   int   vertIndex 1     =    normalIndex ;", "final   int   vertIndex 2     =     (  ( vertIndex 1     +     1  )     <    vertexCount )     ?    vertIndex 1     +     1     :     0  ;", "final   Vec 2    v 1     =    vertices [ vertIndex 1  ]  ;", "final   Vec 2    v 2     =    vertices [ vertIndex 2  ]  ;", "if    ( separat    <     ( Settings . EPSILON )  )     {", "manifold . pointCount    =     1  ;", "manifold . type    =    Manifold . ManifoldType . FACE _ A ;", "final   Vec 2    normal    =    normals [ normalIndex ]  ;", "manifold . localNormal . x    =    normal . x ;", "manifold . localNormal . y    =    normal . y ;", "manifold . localPoint . x    =     (  ( v 1  . x )     +     ( v 2  . x )  )     *     0  .  5 F ;", "manifold . localPoint . y    =     (  ( v 1  . y )     +     ( v 2  . y )  )     *     0  .  5 F ;", "final   ManifoldPoint   mpoint    =    manifold . points [  0  ]  ;", "mpoint . localPoint . x    =    circlep . x ;", "mpoint . localPoint . y    =    circlep . y ;", "mpoint . id . zero (  )  ;", "return ;", "}", "final   float   tempX    =    cLocalx    -     ( v 1  . x )  ;", "final   float   tempY    =    cLocaly    -     ( v 1  . y )  ;", "final   float   temp 2 X    =     ( v 2  . x )     -     ( v 1  . x )  ;", "final   float   temp 2 Y    =     ( v 2  . y )     -     ( v 1  . y )  ;", "final   float   u 1     =     ( tempX    *    temp 2 X )     +     ( tempY    *    temp 2 Y )  ;", "final   float   temp 3 X    =    cLocalx    -     ( v 2  . x )  ;", "final   float   temp 3 Y    =    cLocaly    -     ( v 2  . y )  ;", "final   float   temp 4 X    =     ( v 1  . x )     -     ( v 2  . x )  ;", "final   float   temp 4 Y    =     ( v 1  . y )     -     ( v 2  . y )  ;", "final   float   u 2     =     ( temp 3 X    *    temp 4 X )     +     ( temp 3 Y    *    temp 4 Y )  ;", "if    ( u 1     <  =     0  .  0 F )     {", "final   float   dx    =    cLocalx    -     ( v 1  . x )  ;", "final   float   dy    =    cLocaly    -     ( v 1  . y )  ;", "if    (  (  ( dx    *    dx )     +     ( dy    *    dy )  )     >     ( radius    *    radius )  )     {", "return ;", "}", "manifold . pointCount    =     1  ;", "manifold . type    =    Manifold . ManifoldType . FACE _ A ;", "manifold . localNormal . x    =    cLocalx    -     ( v 1  . x )  ;", "manifold . localNormal . y    =    cLocaly    -     ( v 1  . y )  ;", "manifold . localNormal . normalize (  )  ;", "manifold . localPoint . set ( v 1  )  ;", "manifold . points [  0  ]  . localPoint . set ( circlep )  ;", "manifold . points [  0  ]  . id . zero (  )  ;", "} else", "if    ( u 2     <  =     0  .  0 F )     {", "final   float   dx    =    cLocalx    -     ( v 2  . x )  ;", "final   float   dy    =    cLocaly    -     ( v 2  . y )  ;", "if    (  (  ( dx    *    dx )     +     ( dy    *    dy )  )     >     ( radius    *    radius )  )     {", "return ;", "}", "manifold . pointCount    =     1  ;", "manifold . type    =    Manifold . ManifoldType . FACE _ A ;", "manifold . localNormal . x    =    cLocalx    -     ( v 2  . x )  ;", "manifold . localNormal . y    =    cLocaly    -     ( v 2  . y )  ;", "manifold . localNormal . normalize (  )  ;", "manifold . localPoint . set ( v 2  )  ;", "manifold . points [  0  ]  . localPoint . set ( circlep )  ;", "manifold . points [  0  ]  . id . zero (  )  ;", "} else    {", "final   float   fcx    =     (  ( v 1  . x )     +     ( v 2  . x )  )     *     0  .  5 F ;", "final   float   fcy    =     (  ( v 1  . y )     +     ( v 2  . y )  )     *     0  .  5 F ;", "final   float   tx    =    cLocalx    -    fcx ;", "final   float   ty    =    cLocaly    -    fcy ;", "final   Vec 2    normal    =    normals [ vertIndex 1  ]  ;", "separat    =     ( tx    *     ( normal . x )  )     +     ( ty    *     ( normal . y )  )  ;", "if    ( separat    >    radius )     {", "return ;", "}", "manifold . pointCount    =     1  ;", "manifold . type    =    Manifold . ManifoldType . FACE _ A ;", "manifold . localNormal . set ( normals [ vertIndex 1  ]  )  ;", "manifold . localPoint . x    =    fcx ;", "manifold . localPoint . y    =    fcy ;", "manifold . points [  0  ]  . localPoint . set ( circlep )  ;", "manifold . points [  0  ]  . id . zero (  )  ;", "}", "}", "METHOD_END"], "methodName": ["collidePolygonAndCircle"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "manifold . pointCount    =     0  ;", "float   totalRadius    =     ( polyA . m _ radius )     +     ( polyB . m _ radius )  ;", "findMaxSeparation ( results 1  ,    polyA ,    xfA ,    polyB ,    xfB )  ;", "if    (  ( results 1  . separation )     >    totalRadius )     {", "return ;", "}", "findMaxSeparation ( results 2  ,    polyB ,    xfB ,    polyA ,    xfA )  ;", "if    (  ( results 2  . separation )     >    totalRadius )     {", "return ;", "}", "final   PolygonShape   poly 1  ;", "final   PolygonShape   poly 2  ;", "Transform   xf 1  ;", "Transform   xf 2  ;", "int   edge 1  ;", "boolean   flip ;", "final   float   k _ tol    =     0  .  1 F    *     ( Settings . linearSlop )  ;", "if    (  ( results 2  . separation )     >     (  ( results 1  . separation )     +    k _ tol )  )     {", "poly 1     =    polyB ;", "poly 2     =    polyA ;", "xf 1     =    xfB ;", "xf 2     =    xfA ;", "edge 1     =    results 2  . edgeIndex ;", "manifold . type    =    Manifold . ManifoldType . FACE _ B ;", "flip    =    true ;", "} else    {", "poly 1     =    polyA ;", "poly 2     =    polyB ;", "xf 1     =    xfA ;", "xf 2     =    xfB ;", "edge 1     =    results 1  . edgeIndex ;", "manifold . type    =    Manifold . ManifoldType . FACE _ A ;", "flip    =    false ;", "}", "final   Rot   xf 1 q    =    xf 1  . q ;", "findIncidentEdge ( incidentEdge ,    poly 1  ,    xf 1  ,    edge 1  ,    poly 2  ,    xf 2  )  ;", "int   count 1     =    poly 1  . m _ count ;", "final   Vec 2  [  ]    vertices 1     =    poly 1  . m _ vertices ;", "final   int   iv 1     =    edge 1  ;", "final   int   iv 2     =     (  ( edge 1     +     1  )     <    count 1  )     ?    edge 1     +     1     :     0  ;", "v 1  1  . set ( vertices 1  [ iv 1  ]  )  ;", "v 1  2  . set ( vertices 1  [ iv 2  ]  )  ;", "localTangent . x    =     ( v 1  2  . x )     -     ( v 1  1  . x )  ;", "localTangent . y    =     ( v 1  2  . y )     -     ( v 1  1  . y )  ;", "localTangent . normalize (  )  ;", "localNormal . x    =     1  .  0 F    *     ( localTangent . y )  ;", "localNormal . y    =     (  -  1  .  0 F )     *     ( localTangent . x )  ;", "planePoint . x    =     (  ( v 1  1  . x )     +     ( v 1  2  . x )  )     *     0  .  5 F ;", "planePoint . y    =     (  ( v 1  1  . y )     +     ( v 1  2  . y )  )     *     0  .  5 F ;", "tangent . x    =     (  ( xf 1 q . c )     *     ( localTangent . x )  )     -     (  ( xf 1 q . s )     *     ( localTangent . y )  )  ;", "tangent . y    =     (  ( xf 1 q . s )     *     ( localTangent . x )  )     +     (  ( xf 1 q . c )     *     ( localTangent . y )  )  ;", "final   float   normalx    =     1  .  0 F    *     ( tangent . y )  ;", "final   float   normaly    =     (  -  1  .  0 F )     *     ( tangent . x )  ;", "Transform . mulToOut ( xf 1  ,    v 1  1  ,    v 1  1  )  ;", "Transform . mulToOut ( xf 1  ,    v 1  2  ,    v 1  2  )  ;", "float   frontOffset    =     ( normalx    *     ( v 1  1  . x )  )     +     ( normaly    *     ( v 1  1  . y )  )  ;", "float   sideOffset 1     =     (  -  (  (  ( tangent . x )     *     ( v 1  1  . x )  )     +     (  ( tangent . y )     *     ( v 1  1  . y )  )  )  )     +    totalRadius ;", "float   sideOffset 2     =     (  (  ( tangent . x )     *     ( v 1  2  . x )  )     +     (  ( tangent . y )     *     ( v 1  2  . y )  )  )     +    totalRadius ;", "int   np ;", "tangent . negateLocal (  )  ;", "np    =    CclipSegmentToLine ( clipPoints 1  ,    incidentEdge ,    tangent ,    sideOffset 1  ,    iv 1  )  ;", "tangent . negateLocal (  )  ;", "if    ( np    <     2  )     {", "return ;", "}", "np    =    CclipSegmentToLine ( clipPoints 2  ,    clipPoints 1  ,    tangent ,    sideOffset 2  ,    iv 2  )  ;", "if    ( np    <     2  )     {", "return ;", "}", "manifold . localNormal . set ( localNormal )  ;", "manifold . localPoint . set ( planePoint )  ;", "int   pointCount    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( Settings . maxManifoldPoints )  ;     +  + i )     {", "float   separation    =     (  ( normalx    *     ( clipPoints 2  [ i ]  . v . x )  )     +     ( normaly    *     ( clipPoints 2  [ i ]  . v . y )  )  )     -    frontOffset ;", "if    ( separation    <  =    totalRadius )     {", "ManifoldPoint   cp    =    manifold . points [ pointCount ]  ;", "Vec 2    out    =    cp . localPoint ;", "final   float   px    =     ( clipPoints 2  [ i ]  . v . x )     -     ( xf 2  . p . x )  ;", "final   float   py    =     ( clipPoints 2  [ i ]  . v . y )     -     ( xf 2  . p . y )  ;", "out . x    =     (  ( xf 2  . q . c )     *    px )     +     (  ( xf 2  . q . s )     *    py )  ;", "out . y    =     (  (  -  ( xf 2  . q . s )  )     *    px )     +     (  ( xf 2  . q . c )     *    py )  ;", "cp . id . set ( clipPoints 2  [ i ]  . id )  ;", "if    ( flip )     {", "cp . id . flip (  )  ;", "}", "+  + pointCount ;", "}", "}", "manifold . pointCount    =    pointCount ;", "}", "METHOD_END"], "methodName": ["collidePolygons"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "int   count 1     =    poly 1  . m _ count ;", "final   Vec 2  [  ]    normals 1     =    poly 1  . m _ normals ;", "int   count 2     =    poly 2  . m _ count ;", "final   Vec 2  [  ]    vertices 2     =    poly 2  . m _ vertices ;", "final   Vec 2  [  ]    normals 2     =    poly 2  . m _ normals ;", "assert    (  0     <  =    edge 1  )     &  &     ( edge 1     <    count 1  )  ;", "final   ClipVertex   c 0     =    c [  0  ]  ;", "final   ClipVertex   c 1     =    c [  1  ]  ;", "final   Rot   xf 1 q    =    xf 1  . q ;", "final   Rot   xf 2 q    =    xf 2  . q ;", "final   Vec 2    v    =    normals 1  [ edge 1  ]  ;", "final   float   tempx    =     (  ( xf 1 q . c )     *     ( v . x )  )     -     (  ( xf 1 q . s )     *     ( v . y )  )  ;", "final   float   tempy    =     (  ( xf 1 q . s )     *     ( v . x )  )     +     (  ( xf 1 q . c )     *     ( v . y )  )  ;", "final   float   normal 1 x    =     (  ( xf 2 q . c )     *    tempx )     +     (  ( xf 2 q . s )     *    tempy )  ;", "final   float   normal 1 y    =     (  (  -  ( xf 2 q . s )  )     *    tempx )     +     (  ( xf 2 q . c )     *    tempy )  ;", "int   index    =     0  ;", "float   minDot    =    Float . MAX _ VALUE ;", "for    ( int   i    =     0  ;    i    <    count 2  ;     +  + i )     {", "Vec 2    b    =    normals 2  [ i ]  ;", "float   dot    =     ( normal 1 x    *     ( b . x )  )     +     ( normal 1 y    *     ( b . y )  )  ;", "if    ( dot    <    minDot )     {", "minDot    =    dot ;", "index    =    i ;", "}", "}", "int   i 1     =    index ;", "int   i 2     =     (  ( i 1     +     1  )     <    count 2  )     ?    i 1     +     1     :     0  ;", "Vec 2    v 1     =    vertices 2  [ i 1  ]  ;", "Vec 2    out    =    c 0  . v ;", "out . x    =     (  (  ( xf 2 q . c )     *     ( v 1  . x )  )     -     (  ( xf 2 q . s )     *     ( v 1  . y )  )  )     +     ( xf 2  . p . x )  ;", "out . y    =     (  (  ( xf 2 q . s )     *     ( v 1  . x )  )     +     (  ( xf 2 q . c )     *     ( v 1  . y )  )  )     +     ( xf 2  . p . y )  ;", "c 0  . id . indexA    =     (  ( byte )     ( edge 1  )  )  ;", "c 0  . id . indexB    =     (  ( byte )     ( i 1  )  )  ;", "c 0  . id . typeA    =     (  ( byte )     ( ContactID . Type . FACE . ordinal (  )  )  )  ;", "c 0  . id . typeB    =     (  ( byte )     ( ContactID . Type . VERTEX . ordinal (  )  )  )  ;", "Vec 2    v 2     =    vertices 2  [ i 2  ]  ;", "Vec 2    out 1     =    c 1  . v ;", "out 1  . x    =     (  (  ( xf 2 q . c )     *     ( v 2  . x )  )     -     (  ( xf 2 q . s )     *     ( v 2  . y )  )  )     +     ( xf 2  . p . x )  ;", "out 1  . y    =     (  (  ( xf 2 q . s )     *     ( v 2  . x )  )     +     (  ( xf 2 q . c )     *     ( v 2  . y )  )  )     +     ( xf 2  . p . y )  ;", "c 1  . id . indexA    =     (  ( byte )     ( edge 1  )  )  ;", "c 1  . id . indexB    =     (  ( byte )     ( i 2  )  )  ;", "c 1  . id . typeA    =     (  ( byte )     ( ContactID . Type . FACE . ordinal (  )  )  )  ;", "c 1  . id . typeB    =     (  ( byte )     ( ContactID . Type . VERTEX . ordinal (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["findIncidentEdge"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "int   count 1     =    poly 1  . m _ count ;", "int   count 2     =    poly 2  . m _ count ;", "Vec 2  [  ]    n 1 s    =    poly 1  . m _ normals ;", "Vec 2  [  ]    v 1 s    =    poly 1  . m _ vertices ;", "Vec 2  [  ]    v 2 s    =    poly 2  . m _ vertices ;", "Transform . mulTransToOutUnsafe ( xf 2  ,    xf 1  ,    xf )  ;", "final   Rot   xfq    =    xf . q ;", "int   bestIndex    =     0  ;", "float   maxSeparat    =     -  ( Float . MAX _ VALUE )  ;", "for    ( int   i    =     0  ;    i    <    count 1  ;    i +  +  )     {", "Rot . mulToOutUnsafe ( xfq ,    n 1 s [ i ]  ,    n )  ;", "Transform . mulToOutUnsafe ( xf ,    v 1 s [ i ]  ,    v 1  )  ;", "float   si    =    Float . MAX _ VALUE ;", "for    ( int   j    =     0  ;    j    <    count 2  ;     +  + j )     {", "Vec 2    v 2 sj    =    v 2 s [ j ]  ;", "float   sij    =     (  ( n . x )     *     (  ( v 2 sj . x )     -     ( v 1  . x )  )  )     +     (  ( n . y )     *     (  ( v 2 sj . y )     -     ( v 1  . y )  )  )  ;", "if    ( sij    <    si )     {", "si    =    sij ;", "}", "}", "if    ( si    >    maxSeparat )     {", "maxSeparat    =    si ;", "bestIndex    =    i ;", "}", "}", "results . edgeIndex    =    bestIndex ;", "results . separat    =    maxSeparat ;", "}", "METHOD_END"], "methodName": ["findMaxSeparation"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( Settings . maxManifoldPoints )  ;    i +  +  )     {", "state 1  [ i ]     =    CPointState . NULL _ STATE ;", "state 2  [ i ]     =    CPointState . NULL _ STATE ;", "}", "for    ( int   i    =     0  ;    i    <     ( manifold 1  . pointCount )  ;    i +  +  )     {", "ContactID   id    =    manifold 1  . points [ i ]  . id ;", "state 1  [ i ]     =    CPointState . REMOVE _ STATE ;", "for    ( int   j    =     0  ;    j    <     ( manifold 2  . pointCount )  ;    j +  +  )     {", "if    ( manifold 2  . points [ j ]  . id . isEqual ( id )  )     {", "state 1  [ i ]     =    CPointState . PERSIST _ STATE ;", "break ;", "}", "}", "}", "for    ( int   i    =     0  ;    i    <     ( manifold 2  . pointCount )  ;    i +  +  )     {", "ContactID   id    =    manifold 2  . points [ i ]  . id ;", "state 2  [ i ]     =    CPointState . ADD _ STATE ;", "for    ( int   j    =     0  ;    j    <     ( manifold 1  . pointCount )  ;    j +  +  )     {", "if    ( manifold 1  . points [ j ]  . id . isEqual ( id )  )     {", "state 2  [ i ]     =    CPointState . PERSIST _ STATE ;", "break ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["getPointStates"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "input . proxyA . set ( shapeA ,    indexA )  ;", "input . proxyB . set ( shapeB ,    indexB )  ;", "input . transformA . set ( xfA )  ;", "input . transformB . set ( xfB )  ;", "input . useRadii    =    true ;", "cacheunt    =     0  ;", "pool . getDistance (  )  . distance ( output ,    cache ,    input )  ;", "return    ( output . distance )     <     (  1  0  .  0 F    *     ( Settings . EPSILON )  )  ;", "}", "METHOD_END"], "methodName": ["testOverlap"], "fileName": "org.jbox2d.collision.Collision"}, {"methodBody": ["METHOD_START", "{", "byte   tempA    =    indexA ;", "indexA    =    indexB ;", "indexB    =    tempA ;", "tempA    =    typeA ;", "typeA    =    typeB ;", "typeB    =    tempA ;", "}", "METHOD_END"], "methodName": ["flip"], "fileName": "org.jbox2d.collision.ContactID"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( int )     ( indexA )  )     <  <     2  4  )     |     (  (  ( int )     ( indexB )  )     <  <     1  6  )  )     |     (  (  ( int )     ( typeA )  )     <  <     8  )  )     |     (  ( int )     ( typeB )  )  ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "org.jbox2d.collision.ContactID"}, {"methodBody": ["METHOD_START", "{", "return    ( getKey (  )  )     =  =     ( cid . getKey (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEqual"], "fileName": "org.jbox2d.collision.ContactID"}, {"methodBody": ["METHOD_START", "{", "indexA    =    c . indexA ;", "indexB    =    c . indexB ;", "typeA    =    c . typeA ;", "typeB    =    c . typeB ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.ContactID"}, {"methodBody": ["METHOD_START", "{", "indexA    =     0  ;", "indexB    =     0  ;", "typeA    =     0  ;", "typeB    =     0  ;", "}", "METHOD_END"], "methodName": ["zero"], "fileName": "org.jbox2d.collision.ContactID"}, {"methodBody": ["METHOD_START", "{", ". GJK _ CALLS )  +  +  ;", "finalProxy   proxyA    =    input . proxyA ;", "finalProxy   proxyB    =    input . proxyB ;", "Transform   transformA    =    input . transformA ;", "Transform   transformB    =    input . transformB ;", "simplex . readCache ( cache ,    proxyA ,    transformA ,    proxyB ,    transformB )  ;", ". SimplexVertex [  ]    vertices    =    simplex . vertices ;", "int   saveCount    =     0  ;", "simplex . getClosestPoint ( closestPoint )  ;", "float   distanceSqr 1     =    closestPoint . lengthSquared (  )  ;", "float   distanceSqr 2     =    distanceSqr 1  ;", "int   iter    =     0  ;", "while    ( iter    <     . MAX _ ITERS )  )     {", "saveCount    =    simplex . m _ count ;", "for    ( int   i    =     0  ;    i    <    saveCount ;    i +  +  )     {", "saveA [ i ]     =    vertices [ i ]  . indexA ;", "saveB [ i ]     =    vertices [ i ]  . indexB ;", "}", "switch    ( simplex . m _ count )     {", "case    1     :", "break ;", "case    2     :", "simplex . solve 2  (  )  ;", "break ;", "case    3     :", "simplex . solve 3  (  )  ;", "break ;", "default    :", "assert   false ;", "}", "if    (  ( simplex . m _ count )     =  =     3  )     {", "break ;", "}", "simplex . getClosestPoint ( closestPoint )  ;", "distanceSqr 2     =    closestPoint . lengthSquared (  )  ;", "if    ( distanceSqr 2     >  =    distanceSqr 1  )     {", "}", "distanceSqr 1     =    distanceSqr 2  ;", "simplex . getSearchDirection ( d )  ;", "if    (  ( d . lengthSquared (  )  )     <     (  ( Settings . EPSILON )     *     ( Settings . EPSILON )  )  )     {", "break ;", "}", ". SimplexVertex   vertex    =    vertices [ simplex . m _ count ]  ;", "Rot . mulTransUnsafe ( transformA . q ,    d . negateLocal (  )  ,    temp )  ;", "vertex . indexA    =    proxyA . getSupport ( temp )  ;", "Transform . mulToOutUnsafe ( transformA ,    proxyA . getVertex ( vertex . indexA )  ,    vertex . wA )  ;", "Rot . mulTransUnsafe ( transformB . q ,    d . negateLocal (  )  ,    temp )  ;", "vertex . indexB    =    proxyB . getSupport ( temp )  ;", "Transform . mulToOutUnsafe ( transformB ,    proxyB . getVertex ( vertex . indexB )  ,    vertex . wB )  ;", "vertex . w . set ( vertex . wB )  . subLocal ( vertex . wA )  ;", "+  + iter ;", "+  +  . GJK _ ITERS )  ;", "boolean   duplicate    =    false ;", "for    ( int   i    =     0  ;    i    <    saveCount ;     +  + i )     {", "if    (  (  ( vertex . indexA )     =  =     ( saveA [ i ]  )  )     &  &     (  ( vertex . indexB )     =  =     ( saveB [ i ]  )  )  )     {", "duplicate    =    true ;", "break ;", "}", "}", "if    ( duplicate )     {", "break ;", "}", "+  +  ( simplex . m _ count )  ;", "}", ". GJK _ MAX _ ITERS    =    MathUtils . max . GJK _ MAX _ ITERS ,    iter )  ;", "simplex . getWitnessPoints ( output . pointA ,    output . pointB )  ;", "output . distance    =    MathUtils . distance ( output . pointA ,    output . pointB )  ;", "output . iterations    =    iter ;", "simplex . writeCache ( cache )  ;", "if    ( input . useRadii )     {", "float   rA    =    proxyA . m _ radius ;", "float   rB    =    proxyB . m _ radius ;", "if    (  (  ( output . distance )     >     ( rA    +    rB )  )     &  &     (  ( output . distance )     >     ( Settings . EPSILON )  )  )     {", "output . distance    -  =    rA    +    rB ;", "normal . set ( output . pointB )  . subLocal ( output . pointA )  ;", "normal . normalize (  )  ;", "temp . set ( normal )  . mulLocal ( rA )  ;", "output . pointA . addLocal ( temp )  ;", "temp . set ( normal )  . mulLocal ( rB )  ;", "output . pointB . subLocal ( temp )  ;", "} else    {", "output . pointA . addLocal ( output . pointB )  . mulLocal (  0  .  5 F )  ;", "output . pointB . set ( output . pointA )  ;", "output . distance    =     0  .  0 F ;", "}", "}", "}", "METHOD_END"], "methodName": ["distance"], "fileName": "org.jbox2d.collision.Distance"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( cp . pointCount )  ;    i +  +  )     {", "points [ i ]  . set ( cp . points [ i ]  )  ;", "}", "type    =    cp . type ;", "localNormal . set ( cp . localNormal )  ;", "localPoint . set ( cp . localPoint )  ;", "pointCount    =    cp . pointCount ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.Manifold"}, {"methodBody": ["METHOD_START", "{", "localPoint . set ( cp . localPoint )  ;", "normalImpulse    =    cp . normalImpulse ;", "tangentImpulse    =    cp . tangentImpulse ;", "id . set ( cp . id )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.ManifoldPoint"}, {"methodBody": ["METHOD_START", "{", "p 1  . set ( rci . p 1  )  ;", "p 2  . set ( rci . p 2  )  ;", "maxFract    =    rci . maxFract ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.RayCastInput"}, {"methodBody": ["METHOD_START", "{", "normal . set ( rco . normal )  ;", "fract    =    rco . fract ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.RayCastOutput"}, {"methodBody": ["METHOD_START", "{", "m _ sweepA . getTransform ( xfa ,    t )  ;", "m _ sweepB . getTransform ( xfb ,    t )  ;", "switch    ( m _ type )     {", "case   POINTS    :", "{", "Rot . mulTransUnsafe ( xfa . q ,    m _ axis ,    axisA )  ;", "Rot . mulTransUnsafe ( xfb . q ,    m _ axis . negateLocal (  )  ,    axisB )  ;", "m _ axis . negateLocal (  )  ;", "localPointA . set ( m _ proxyA . getVertex ( indexA )  )  ;", "localPointB . set ( m _ proxyB . getVertex ( indexB )  )  ;", "Transform . mulToOutUnsafe ( xfa ,    localPointA ,    pointA )  ;", "Transform . mulToOutUnsafe ( xfb ,    localPointB ,    pointB )  ;", "float   s    =    Vec 2  . dot ( pointB . subLocal ( pointA )  ,    m _ axis )  ;", "return   s ;", "}", "case   FACE _ A    :", "{", "Rot . mulToOutUnsafe ( xfa . q ,    m _ axis ,    normal )  ;", "Transform . mulToOutUnsafe ( xfa ,    m _ localPoint ,    pointA )  ;", "Rot . mulTransUnsafe ( xfb . q ,    normal . negateLocal (  )  ,    axisB )  ;", "normal . negateLocal (  )  ;", "localPointB . set ( m _ proxyB . getVertex ( indexB )  )  ;", "Transform . mulToOutUnsafe ( xfb ,    localPointB ,    pointB )  ;", "float   s    =    Vec 2  . dot ( pointB . subLocal ( pointA )  ,    normal )  ;", "return   s ;", "}", "case   FACE _ B    :", "{", "Rot . mulToOutUnsafe ( xfb . q ,    m _ axis ,    normal )  ;", "Transform . mulToOutUnsafe ( xfb ,    m _ localPoint ,    pointB )  ;", "Rot . mulTransUnsafe ( xfa . q ,    normal . negateLocal (  )  ,    axisA )  ;", "normal . negateLocal (  )  ;", "localPointA . set ( m _ proxyA . getVertex ( indexA )  )  ;", "Transform . mulToOutUnsafe ( xfa ,    localPointA ,    pointA )  ;", "float   s    =    Vec 2  . dot ( pointA . subLocal ( pointB )  ,    normal )  ;", "return   s ;", "}", "default    :", "assert   false ;", "return    0  .  0 F ;", "}", "}", "METHOD_END"], "methodName": ["evaluate"], "fileName": "org.jbox2d.collision.SeparationFunction"}, {"methodBody": ["METHOD_START", "{", "m _ sweepA . getTransform ( xfa ,    t )  ;", "m _ sweepB . getTransform ( xfb ,    t )  ;", "switch    ( m _ type )     {", "case   POINTS    :", "{", "Rot . mulTransUnsafe ( xfa . q ,    m _ axis ,    axisA )  ;", "Rot . mulTransUnsafe ( xfb . q ,    m _ axis . negateLocal (  )  ,    axisB )  ;", "m _ axis . negateLocal (  )  ;", "indexes [  0  ]     =    m _ proxyA . getSupport ( axisA )  ;", "indexes [  1  ]     =    m _ proxyB . getSupport ( axisB )  ;", "localPointA . set ( m _ proxyA . getVertex ( indexes [  0  ]  )  )  ;", "localPointB . set ( m _ proxyB . getVertex ( indexes [  1  ]  )  )  ;", "Transform . mulToOutUnsafe ( xfa ,    localPointA ,    pointA )  ;", "Transform . mulToOutUnsafe ( xfb ,    localPointB ,    pointB )  ;", "float   s    =    Vec 2  . dot ( pointB . subLocal ( pointA )  ,    m _ axis )  ;", "return   s ;", "}", "case   FACE _ A    :", "{", "Rot . mulToOutUnsafe ( xfa . q ,    m _ axis ,    normal )  ;", "Transform . mulToOutUnsafe ( xfa ,    m _ localPoint ,    pointA )  ;", "Rot . mulTransUnsafe ( xfb . q ,    normal . negateLocal (  )  ,    axisB )  ;", "normal . negateLocal (  )  ;", "indexes [  0  ]     =     -  1  ;", "indexes [  1  ]     =    m _ proxyB . getSupport ( axisB )  ;", "localPointB . set ( m _ proxyB . getVertex ( indexes [  1  ]  )  )  ;", "Transform . mulToOutUnsafe ( xfb ,    localPointB ,    pointB )  ;", "float   s    =    Vec 2  . dot ( pointB . subLocal ( pointA )  ,    normal )  ;", "return   s ;", "}", "case   FACE _ B    :", "{", "Rot . mulToOutUnsafe ( xfb . q ,    m _ axis ,    normal )  ;", "Transform . mulToOutUnsafe ( xfb ,    m _ localPoint ,    pointB )  ;", "Rot . mulTransUnsafe ( xfa . q ,    normal . negateLocal (  )  ,    axisA )  ;", "normal . negateLocal (  )  ;", "indexes [  1  ]     =     -  1  ;", "indexes [  0  ]     =    m _ proxyA . getSupport ( axisA )  ;", "localPointA . set ( m _ proxyA . getVertex ( indexes [  0  ]  )  )  ;", "Transform . mulToOutUnsafe ( xfa ,    localPointA ,    pointA )  ;", "float   s    =    Vec 2  . dot ( pointA . subLocal ( pointB )  ,    normal )  ;", "return   s ;", "}", "default    :", "assert   false ;", "indexes [  0  ]     =     -  1  ;", "indexes [  1  ]     =     -  1  ;", "return    0  .  0 F ;", "}", "}", "METHOD_END"], "methodName": ["findMinSeparation"], "fileName": "org.jbox2d.collision.SeparationFunction"}, {"methodBody": ["METHOD_START", "{", "m _ proxyA    =    proxyA ;", "m _ proxyB    =    proxyB ;", "int   count    =    cache . count ;", "assert    (  0     <    count )     &  &     ( count    <     3  )  ;", "m _ sweepA    =    sweepA ;", "m _ sweepB    =    sweepB ;", "m _ sweepA . getTransform ( xfa ,    t 1  )  ;", "m _ sweepB . getTransform ( xfb ,    t 1  )  ;", "if    ( count    =  =     1  )     {", "m _ type    =    Type . POINTS ;", "localPointA . set ( m _ proxyA . getVertex ( cache . indexA [  0  ]  )  )  ;", "localPointB . set ( m _ proxyB . getVertex ( cache . indexB [  0  ]  )  )  ;", "Transform . mulToOutUnsafe ( xfa ,    localPointA ,    pointA )  ;", "Transform . mulToOutUnsafe ( xfb ,    localPointB ,    pointB )  ;", "m _ axis . set ( pointB )  . subLocal ( pointA )  ;", "float   s    =    m _ axis . normalize (  )  ;", "return   s ;", "} else", "if    (  ( cache . indexA [  0  ]  )     =  =     ( cache . indexA [  1  ]  )  )     {", "m _ type    =    Type . FACE _ B ;", "localPointB 1  . set ( m _ proxyB . getVertex ( cache . indexB [  0  ]  )  )  ;", "localPointB 2  . set ( m _ proxyB . getVertex ( cache . indexB [  1  ]  )  )  ;", "temp . set ( localPointB 2  )  . subLocal ( localPointB 1  )  ;", "mmon . Vec 2  . crossToOutUnsafe ( temp ,     1  .  0 F ,    m _ axis )  ;", "m _ axis . normalize (  )  ;", "mmon . Rot . mulToOutUnsafe ( xfb . q ,    m _ axis ,    normal )  ;", "m _ localPoint . set ( localPointB 1  )  . addLocal ( localPointB 2  )  . mulLocal (  0  .  5 F )  ;", "Transform . mulToOutUnsafe ( xfb ,    m _ localPoint ,    pointB )  ;", "localPointA . set ( proxyA . getVertex ( cache . indexA [  0  ]  )  )  ;", "Transform . mulToOutUnsafe ( xfa ,    localPointA ,    pointA )  ;", "temp . set ( pointA )  . subLocal ( pointB )  ;", "float   s    =    mmon . Vec 2  . dot ( temp ,    normal )  ;", "if    ( s    <     0  .  0 F )     {", "m _ axis . negateLocal (  )  ;", "s    =     - s ;", "}", "return   s ;", "} else    {", "m _ type    =    Type . FACE _ A ;", "localPointA 1  . set ( m _ proxyA . getVertex ( cache . indexA [  0  ]  )  )  ;", "localPointA 2  . set ( m _ proxyA . getVertex ( cache . indexA [  1  ]  )  )  ;", "temp . set ( localPointA 2  )  . subLocal ( localPointA 1  )  ;", "mmon . Vec 2  . crossToOutUnsafe ( temp ,     1  .  0 F ,    m _ axis )  ;", "m _ axis . normalize (  )  ;", "mmon . Rot . mulToOutUnsafe ( xfa . q ,    m _ axis ,    normal )  ;", "m _ localPoint . set ( localPointA 1  )  . addLocal ( localPointA 2  )  . mulLocal (  0  .  5 F )  ;", "Transform . mulToOutUnsafe ( xfa ,    m _ localPoint ,    pointA )  ;", "localPointB . set ( m _ proxyB . getVertex ( cache . indexB [  0  ]  )  )  ;", "Transform . mulToOutUnsafe ( xfb ,    localPointB ,    pointB )  ;", "temp . set ( pointB )  . subLocal ( pointA )  ;", "float   s    =    mmon . Vec 2  . dot ( temp ,    normal )  ;", "if    ( s    <     0  .  0 F )     {", "m _ axis . negateLocal (  )  ;", "s    =     - s ;", "}", "return   s ;", "}", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.collision.SeparationFunction"}, {"methodBody": ["METHOD_START", "{", "+  +  ( TimeOfImpact . toiCalls )  ;", "output . state    =    TimeOfImpact . TOIOutputState . UNKNOWN ;", "output . t    =    input . tMax ;", "final   Distance . DistanceProxy   proxyA    =    input . proxyA ;", "final   Distance . DistanceProxy   proxyB    =    input . proxyB ;", "sweepA . set ( input . sweepA )  ;", "sweepB . set ( input . sweepB )  ;", "sweepA . normalize (  )  ;", "sweepB . normalize (  )  ;", "float   tMax    =    input . tMax ;", "float   totalRadius    =     ( proxyA . m _ radius )     +     ( proxyB . m _ radius )  ;", "float   target    =    MathUtils . max ( Settings . linearSlop ,     ( totalRadius    -     (  3  .  0 F    *     ( Settings . linearSlop )  )  )  )  ;", "float   tolerance    =     0  .  2  5 F    *     ( Settings . linearSlop )  ;", "assert   target    >    tolerance ;", "float   t 1     =     0  .  0 F ;", "int   iter    =     0  ;", "cache . count    =     0  ;", "distanceInput . proxyA    =    input . proxyA ;", "distanceInput . proxyB    =    input . proxyB ;", "distanceInput . useRadii    =    false ;", "for    (  ;     ;  )     {", "sweepA . getTransform ( xfA ,    t 1  )  ;", "sweepB . getTransform ( xfB ,    t 1  )  ;", "distanceInput . transformA    =    xfA ;", "distanceInput . transformB    =    xfB ;", "pool . getDistance (  )  . distance ( distanceOutput ,    cache ,    distanceInput )  ;", "if    (  ( distanceOutput . distance )     <  =     0  .  0 F )     {", "output . state    =    TimeOfImpact . TOIOutputState . OVERLAPPED ;", "output . t    =     0  .  0 F ;", "break ;", "}", "if    (  ( distanceOutput . distance )     <     ( target    +    tolerance )  )     {", "output . state    =    TimeOfImpact . TOIOutputState . TOUCHING ;", "output . t    =    t 1  ;", "break ;", "}", "fcn . initialize ( cache ,    proxyA ,    sweepA ,    proxyB ,    sweepB ,    t 1  )  ;", "boolean   done    =    false ;", "float   t 2     =    tMax ;", "int   pushBackIter    =     0  ;", "for    (  ;     ;  )     {", "float   s 2     =    fcn . findMinSeparation ( indexes ,    t 2  )  ;", "if    ( s 2     >     ( target    +    tolerance )  )     {", "output . state    =    TimeOfImpact . TOIOutputState . SEPARATED ;", "output . t    =    tMax ;", "done    =    true ;", "break ;", "}", "if    ( s 2     >     ( target    -    tolerance )  )     {", "t 1     =    t 2  ;", "break ;", "}", "float   s 1     =    fcn . evaluate ( indexes [  0  ]  ,    indexes [  1  ]  ,    t 1  )  ;", "if    ( s 1     <     ( target    -    tolerance )  )     {", "output . state    =    TimeOfImpact . TOIOutputState . FAILED ;", "output . t    =    t 1  ;", "done    =    true ;", "break ;", "}", "if    ( s 1     <  =     ( target    +    tolerance )  )     {", "output . state    =    TimeOfImpact . TOIOutputState . TOUCHING ;", "output . t    =    t 1  ;", "done    =    true ;", "break ;", "}", "int   rootIterCount    =     0  ;", "float   a 1     =    t 1  ;", "float   a 2     =    t 2  ;", "for    (  ;     ;  )     {", "float   t ;", "if    (  ( rootIterCount    &     1  )     =  =     1  )     {", "t    =    a 1     +     (  (  ( target    -    s 1  )     *     ( a 2     -    a 1  )  )     /     ( s 2     -    s 1  )  )  ;", "} else    {", "t    =     0  .  5 F    *     ( a 1     +    a 2  )  ;", "}", "float   s    =    fcn . evaluate ( indexes [  0  ]  ,    indexes [  1  ]  ,    t )  ;", "if    (  ( MathUtils . abs (  ( s    -    target )  )  )     <    tolerance )     {", "t 2     =    t ;", "break ;", "}", "if    ( s    >    target )     {", "a 1     =    t ;", "s 1     =    s ;", "} else    {", "a 2     =    t ;", "s 2     =    s ;", "}", "+  + rootIterCount ;", "+  +  ( TimeOfImpact . toiRootIters )  ;", "if    ( rootIterCount    =  =     5  0  )     {", "break ;", "}", "}", "TimeOfImpact . toiMaxRootIters    =    MathUtils . max ( TimeOfImpact . toiMaxRootIters ,    rootIterCount )  ;", "+  + pushBackIter ;", "if    ( pushBackIter    =  =     ( Settings . maxPolygonVertices )  )     {", "break ;", "}", "}", "+  + iter ;", "+  +  ( TimeOfImpact . toiIters )  ;", "if    ( done )     {", "break ;", "}", "if    ( iter    =  =     ( TimeOfImpact . MAX _ ITERATIONS )  )     {", "output . state    =    TimeOfImpact . TOIOutputState . FAILED ;", "output . t    =    t 1  ;", "break ;", "}", "}", "TimeOfImpact . toiMaxIters    =    MathUtils . max ( TimeOfImpact . toiMaxIters ,    iter )  ;", "}", "METHOD_END"], "methodName": ["timeOfImpact"], "fileName": "org.jbox2d.collision.TimeOfImpact"}, {"methodBody": ["METHOD_START", "{", "if    (  ( manifold . pointCount )     =  =     0  )     {", "return ;", "}", "switch    ( manifold . type )     {", "case   CIRCLES    :", "{", "final   Vec 2    pointA    =    pool 3  ;", "final   Vec 2    pointB    =    pool 4  ;", "normal . x    =     1  ;", "normal . y    =     0  ;", "Vec 2    v    =    manifold . localPoint ;", "pointA . x    =     (  (  ( xfA . q . c )     *     ( v . x )  )     -     (  ( xfA . q . s )     *     ( v . y )  )  )     +     ( xfA . p . x )  ;", "pointA . y    =     (  (  ( xfA . q . s )     *     ( v . x )  )     +     (  ( xfA . q . c )     *     ( v . y )  )  )     +     ( xfA . p . y )  ;", "Vec 2    mp 0 p    =    manifold . points [  0  ]  . localPoint ;", "pointB . x    =     (  (  ( xfB . q . c )     *     ( mp 0 p . x )  )     -     (  ( xfB . q . s )     *     ( mp 0 p . y )  )  )     +     ( xfB . p . x )  ;", "pointB . y    =     (  (  ( xfB . q . s )     *     ( mp 0 p . x )  )     +     (  ( xfB . q . c )     *     ( mp 0 p . y )  )  )     +     ( xfB . p . y )  ;", "if    (  ( MathUtils . distanceSquared ( pointA ,    pointB )  )     >     (  ( Settings . EPSILON )     *     ( Settings . EPSILON )  )  )     {", "normal . x    =     ( pointB . x )     -     ( pointA . x )  ;", "normal . y    =     ( pointB . y )     -     ( pointA . y )  ;", "normal . normalize (  )  ;", "}", "final   float   cAx    =     (  ( normal . x )     *    radiusA )     +     ( pointA . x )  ;", "final   float   cAy    =     (  ( normal . y )     *    radiusA )     +     ( pointA . y )  ;", "final   float   cBx    =     (  (  -  ( normal . x )  )     *    radiusB )     +     ( pointB . x )  ;", "final   float   cBy    =     (  (  -  ( normal . y )  )     *    radiusB )     +     ( pointB . y )  ;", "points [  0  ]  . x    =     ( cAx    +    cBx )     *     0  .  5 F ;", "points [  0  ]  . y    =     ( cAy    +    cBy )     *     0  .  5 F ;", "separations [  0  ]     =     (  ( cBx    -    cAx )     *     ( normal . x )  )     +     (  ( cBy    -    cAy )     *     ( normal . y )  )  ;", "}", "break ;", "case   FACE _ A    :", "{", "final   Vec 2    planePoint    =    pool 3  ;", "Rot . mulToOutUnsafe ( xfA . q ,    manifold . localNormal ,    normal )  ;", "Transform . mulToOut ( xfA ,    manifold . localPoint ,    planePoint )  ;", "final   Vec 2    clipPoint    =    pool 4  ;", "for    ( int   i    =     0  ;    i    <     ( manifold . pointCount )  ;    i +  +  )     {", "Transform . mulToOut ( xfB ,    manifold . points [ i ]  . localPoint ,    clipPoint )  ;", "final   float   scalar    =    radiusA    -     (  (  (  ( clipPoint . x )     -     ( planePoint . x )  )     *     ( normal . x )  )     +     (  (  ( clipPoint . y )     -     ( planePoint . y )  )     *     ( normal . y )  )  )  ;", "final   float   cAx    =     (  ( normal . x )     *    scalar )     +     ( clipPoint . x )  ;", "final   float   cAy    =     (  ( normal . y )     *    scalar )     +     ( clipPoint . y )  ;", "final   float   cBx    =     (  (  -  ( normal . x )  )     *    radiusB )     +     ( clipPoint . x )  ;", "final   float   cBy    =     (  (  -  ( normal . y )  )     *    radiusB )     +     ( clipPoint . y )  ;", "points [ i ]  . x    =     ( cAx    +    cBx )     *     0  .  5 F ;", "points [ i ]  . y    =     ( cAy    +    cBy )     *     0  .  5 F ;", "separations [ i ]     =     (  ( cBx    -    cAx )     *     ( normal . x )  )     +     (  ( cBy    -    cAy )     *     ( normal . y )  )  ;", "}", "}", "break ;", "case   FACE _ B    :", "final   Vec 2    planePoint    =    pool 3  ;", "Rot . mulToOutUnsafe ( xfB . q ,    manifold . localNormal ,    normal )  ;", "Transform . mulToOut ( xfB ,    manifold . localPoint ,    planePoint )  ;", "final   Vec 2    clipPoint    =    pool 4  ;", "for    ( int   i    =     0  ;    i    <     ( manifold . pointCount )  ;    i +  +  )     {", "Transform . mulToOut ( xfA ,    manifold . points [ i ]  . localPoint ,    clipPoint )  ;", "final   float   scalar    =    radiusB    -     (  (  (  ( clipPoint . x )     -     ( planePoint . x )  )     *     ( normal . x )  )     +     (  (  ( clipPoint . y )     -     ( planePoint . y )  )     *     ( normal . y )  )  )  ;", "final   float   cBx    =     (  ( normal . x )     *    scalar )     +     ( clipPoint . x )  ;", "final   float   cBy    =     (  ( normal . y )     *    scalar )     +     ( clipPoint . y )  ;", "final   float   cAx    =     (  (  -  ( normal . x )  )     *    radiusA )     +     ( clipPoint . x )  ;", "final   float   cAy    =     (  (  -  ( normal . y )  )     *    radiusA )     +     ( clipPoint . y )  ;", "points [ i ]  . x    =     ( cAx    +    cBx )     *     0  .  5 F ;", "points [ i ]  . y    =     ( cAy    +    cBy )     *     0  .  5 F ;", "separations [ i ]     =     (  ( cAx    -    cBx )     *     ( normal . x )  )     +     (  ( cAy    -    cBy )     *     ( normal . y )  )  ;", "}", "normal . x    =     -  ( normal . x )  ;", "normal . y    =     -  ( normal . y )  ;", "break ;", "}", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.collision.WorldManifold"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ moveCount )     =  =     ( m _ moveCapacity )  )     {", "int [  ]    old    =    m _ mov ;", "m _ moveCapacity    *  =     2  ;", "m _ mov    =    new   int [ m _ moveCapacity ]  ;", "System . arraycopy ( old ,     0  ,    m _ mov ,     0  ,    old . length )  ;", "}", "m _ mov [ m _ moveCount ]     =    proxyId ;", "+  +  ( m _ moveCount )  ;", "}", "METHOD_END"], "methodName": ["bufferMove"], "fileName": "org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( proxyId    =  =     ( m _ queryProxyId )  )     {", "return   true ;", "}", "if    (  ( m _ pairCount )     =  =     ( m _ pairCapacity )  )     {", "Pair [  ]    old    =    m _ pair ;", "m _ pairCapacity    *  =     2  ;", "m _ pair    =    new   Pair [ m _ pairCapacity ]  ;", "System . arraycopy ( old ,     0  ,    m _ pair ,     0  ,    old . length )  ;", "for    ( int   i    =    old . length ;    i    <     ( m _ pairCapacity )  ;    i +  +  )     {", "m _ pair [ i ]     =    new   Pair (  )  ;", "}", "}", "if    ( proxyId    <     ( m _ queryProxyId )  )     {", "m _ pair [ m _ pairCount ]  . proxyIdA    =    proxyId ;", "m _ pair [ m _ pairCount ]  . proxyIdB    =    m _ queryProxyId ;", "} else    {", "m _ pair [ m _ pairCount ]  . proxyIdA    =    m _ queryProxyId ;", "m _ pair [ m _ pairCount ]  . proxyIdB    =    proxyId ;", "}", "+  +  ( m _ pairCount )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["treeCallback"], "fileName": "org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( m _ moveCount )  ;    i +  +  )     {", "if    (  ( m _ moveBuffer [ i ]  )     =  =    proxyId )     {", "m _ moveBuffer [ i ]     =     . NULL _ PROXY ;", "}", "}", "}", "METHOD_END"], "methodName": ["unbufferMove"], "fileName": "org.jbox2d.collision.broadphase.DefaultBroadPhaseBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ freeList )     =  =     ( DynamicTree . NULL _ NODE )  )     {", "assert    ( m _ nodeCount )     =  =     ( m _ nodeCapacity )  ;", "DynamicTreeNode [  ]    old    =    m _ nodes ;", "m _ nodeCapacity    *  =     2  ;", "m _ nodes    =    new   DynamicTreeNode [ m _ nodeCapacity ]  ;", "System . arraycopy ( old ,     0  ,    m _ nodes ,     0  ,    old . length )  ;", "for    ( int   i    =     ( m _ nodeCapacity )     -     1  ;    i    >  =     ( m _ nodeCount )  ;    i -  -  )     {", "m _ nodes [ i ]     =    new   DynamicTreeNode ( i )  ;", "m _ nodes [ i ]  . parent    =     ( i    =  =     (  ( m _ nodeCapacity )     -     1  )  )     ?    null    :    m _ nodes [  ( i    +     1  )  ]  ;", "m _ nodes [ i ]  . height    =     -  1  ;", "}", "m _ freeList    =    m _ nodeCount ;", "}", "int   nodeId    =    m _ freeList ;", "final   DynamicTreeNode   treeNode    =    m _ nodes [ nodeId ]  ;", "m _ freeList    =     (  ( treeNode . parent )     !  =    null )     ?    treeNode . parent . id    :    DynamicTree . NULL _ NODE ;", "treeNode . parent    =    null ;", "treeNode . child 1     =    null ;", "treeNode . child 2     =    null ;", "treeNode . height    =     0  ;", "treeNode . userData    =    null ;", "+  +  ( m _ nodeCount )  ;", "return   treeNode ;", "}", "METHOD_END"], "methodName": ["allocateNode"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "assert   iA    !  =    null ;", "Node   A    =    iA ;", "if    (  (  ( A . child 1  )     =  =    null )     |  |     (  ( A . height )     <     2  )  )     {", "return   iA ;", "}", "Node   iB    =    A . child 1  ;", "Node   iC    =    A . child 2  ;", "assert    (  0     <  =     ( iB . id )  )     &  &     (  ( iB . id )     <     ( m _ nodeCapacity )  )  ;", "assert    (  0     <  =     ( iC . id )  )     &  &     (  ( iC . id )     <     ( m _ nodeCapacity )  )  ;", "Node   B    =    iB ;", "Node   C    =    iC ;", "int   balance    =     ( C . height )     -     ( B . height )  ;", "if    ( balance    >     1  )     {", "Node   iF    =    C . child 1  ;", "Node   iG    =    C . child 2  ;", "Node   F    =    iF ;", "Node   G    =    iG ;", "assert   F    !  =    null ;", "assert   G    !  =    null ;", "assert    (  0     <  =     ( iF . id )  )     &  &     (  ( iF . id )     <     ( m _ nodeCapacity )  )  ;", "assert    (  0     <  =     ( iG . id )  )     &  &     (  ( iG . id )     <     ( m _ nodeCapacity )  )  ;", "C . child 1     =    iA ;", "C . parent    =    A . parent ;", "A . parent    =    iC ;", "if    (  ( C . parent )     !  =    null )     {", "if    (  ( C . parent . child 1  )     =  =    iA )     {", "C . parent . child 1     =    iC ;", "} else    {", "assert    ( C . parent . child 2  )     =  =    iA ;", "C . parent . child 2     =    iC ;", "}", "} else    {", "m _ root    =    iC ;", "}", "if    (  ( F . height )     >     ( G . height )  )     {", "C . child 2     =    iF ;", "A . child 2     =    iG ;", "G . parent    =    iA ;", "A . aabb . combine ( B . aabb ,    G . aabb )  ;", "C . aabb . combine ( A . aabb ,    F . aabb )  ;", "A . height    =     1     +     ( MathUtils . max ( B . height ,    G . height )  )  ;", "C . height    =     1     +     ( MathUtils . max ( A . height ,    F . height )  )  ;", "} else    {", "C . child 2     =    iG ;", "A . child 2     =    iF ;", "F . parent    =    iA ;", "A . aabb . combine ( B . aabb ,    F . aabb )  ;", "C . aabb . combine ( A . aabb ,    G . aabb )  ;", "A . height    =     1     +     ( MathUtils . max ( B . height ,    F . height )  )  ;", "C . height    =     1     +     ( MathUtils . max ( A . height ,    G . height )  )  ;", "}", "return   iC ;", "}", "if    ( balance    <     (  -  1  )  )     {", "Node   iD    =    B . child 1  ;", "Node   iE    =    B . child 2  ;", "Node   D    =    iD ;", "Node   E    =    iE ;", "assert    (  0     <  =     ( iD . id )  )     &  &     (  ( iD . id )     <     ( m _ nodeCapacity )  )  ;", "assert    (  0     <  =     ( iE . id )  )     &  &     (  ( iE . id )     <     ( m _ nodeCapacity )  )  ;", "B . child 1     =    iA ;", "B . parent    =    A . parent ;", "A . parent    =    iB ;", "if    (  ( B . parent )     !  =    null )     {", "if    (  ( B . parent . child 1  )     =  =    iA )     {", "B . parent . child 1     =    iB ;", "} else    {", "assert    ( B . parent . child 2  )     =  =    iA ;", "B . parent . child 2     =    iB ;", "}", "} else    {", "m _ root    =    iB ;", "}", "if    (  ( D . height )     >     ( E . height )  )     {", "B . child 2     =    iD ;", "A . child 1     =    iE ;", "E . parent    =    iA ;", "A . aabb . combine ( C . aabb ,    E . aabb )  ;", "B . aabb . combine ( A . aabb ,    D . aabb )  ;", "A . height    =     1     +     ( MathUtils . max ( C . height ,    E . height )  )  ;", "B . height    =     1     +     ( MathUtils . max ( A . height ,    D . height )  )  ;", "} else    {", "B . child 2     =    iE ;", "A . child 1     =    iD ;", "D . parent    =    iA ;", "A . aabb . combine ( C . aabb ,    D . aabb )  ;", "B . aabb . combine ( A . aabb ,    E . aabb )  ;", "A . height    =     1     +     ( MathUtils . max ( C . height ,    D . height )  )  ;", "B . height    =     1     +     ( MathUtils . max ( A . height ,    E . height )  )  ;", "}", "return   iB ;", "}", "return   iA ;", "}", "METHOD_END"], "methodName": ["balance"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "assert    (  0     <  =     ( node . id )  )     &  &     (  ( node . id )     <     ( m _ nodeCapacity )  )  ;", "if    (  ( node . child 1  )     =  =    null )     {", "return    0  ;", "}", "int   height 1     =    computeHeight ( node . child 1  )  ;", "int   height 2     =    computeHeight ( node . child 2  )  ;", "return    1     +     ( MathUtils . max ( height 1  ,    height 2  )  )  ;", "}", "METHOD_END"], "methodName": ["computeHeight"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "node . aabb . getVertices ( drawVecs )  ;", "color . set (  1  ,     (  (  ( height    -    spot )     *     1  .  0 F )     /    height )  ,     (  (  ( height    -    spot )     *     1  .  0 F )     /    height )  )  ;", "argDraw . drawPolygon ( drawVecs ,     4  ,    color )  ;", "argDraw . getViewportTranform (  )  . getWorldToScreen ( node . aabb . upperBound ,    textVec )  ;", "argDraw . drawString ( textVec . x ,    textVec . y ,     (  (  (  (  ( node . id )     +     \"  -  \"  )     +     ( spot    +     1  )  )     +     \"  /  \"  )     +    height )  ,    color )  ;", "if    (  ( node . child 1  )     !  =    null )     {", "draw ( argDraw ,    node . child 1  ,     ( spot    +     1  )  ,    height )  ;", "}", "if    (  ( node . child 2  )     !  =    null )     {", "draw ( argDraw ,    node . child 2  ,     ( spot    +     1  )  ,    height )  ;", "}", "}", "METHOD_END"], "methodName": ["drawTree"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "assert   node    !  =    null ;", "assert    0     <     ( m _ nodeCount )  ;", "node . parent    =     (  ( m _ freeList )     !  =     (  . NULL _ NODE )  )     ?    m _ nodes [ m _ freeList ]     :    null ;", "node . height    =     -  1  ;", "m _ freeList    =    node . id ;", "( m _ nodeCount )  -  -  ;", "}", "METHOD_END"], "methodName": ["freeNode"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "DynamicTreeNode   leaf    =    m _ nodes [ leaf _ index ]  ;", "if    (  ( m _ root )     =  =    null )     {", "m _ root    =    leaf ;", "m _ root . parent    =    null ;", "return ;", "}", "AABB   leafAABB    =    leaf . aabb ;", "DynamicTreeNode   index    =    m _ root ;", "while    (  ( index . child 1  )     !  =    null )     {", "final   DynamicTreeNode   node    =    index ;", "DynamicTreeNode   child 1     =    node . child 1  ;", "DynamicTreeNode   child 2     =    node . child 2  ;", "float   area    =    node . aabb . getPerimeter (  )  ;", "combinedAABB . combine ( node . aabb ,    leafAABB )  ;", "float   combinedArea    =    combinedAABB . getPerimeter (  )  ;", "float   cost    =     2  .  0 F    *    combinedArea ;", "float   inheritanceCost    =     2  .  0 F    *     ( combinedArea    -    area )  ;", "float   cost 1  ;", "if    (  ( child 1  . child 1  )     =  =    null )     {", "combinedAABB . combine ( leafAABB ,    child 1  . aabb )  ;", "cost 1     =     ( combinedAABB . getPerimeter (  )  )     +    inheritanceCost ;", "} else    {", "combinedAABB . combine ( leafAABB ,    child 1  . aabb )  ;", "float   oldArea    =    child 1  . aabb . getPerimeter (  )  ;", "float   newArea    =    combinedAABB . getPerimeter (  )  ;", "cost 1     =     ( newArea    -    oldArea )     +    inheritanceCost ;", "}", "float   cost 2  ;", "if    (  ( child 2  . child 1  )     =  =    null )     {", "combinedAABB . combine ( leafAABB ,    child 2  . aabb )  ;", "cost 2     =     ( combinedAABB . getPerimeter (  )  )     +    inheritanceCost ;", "} else    {", "combinedAABB . combine ( leafAABB ,    child 2  . aabb )  ;", "float   oldArea    =    child 2  . aabb . getPerimeter (  )  ;", "float   newArea    =    combinedAABB . getPerimeter (  )  ;", "cost 2     =     ( newArea    -    oldArea )     +    inheritanceCost ;", "}", "if    (  ( cost    <    cost 1  )     &  &     ( cost    <    cost 2  )  )     {", "break ;", "}", "if    ( cost 1     <    cost 2  )     {", "index    =    child 1  ;", "} else    {", "index    =    child 2  ;", "}", "}", "DynamicTreeNode   sibling    =    index ;", "DynamicTreeNode   oldParent    =    m _ nodes [ sibling . id ]  . parent ;", "final   DynamicTreeNode   newParent    =    allocateNode (  )  ;", "newParent . parent    =    oldParent ;", "newParent . userData    =    null ;", "newParent . aabb . combine ( leafAABB ,    sibling . aabb )  ;", "newParent . height    =     ( sibling . height )     +     1  ;", "if    ( oldParent    !  =    null )     {", "if    (  ( oldParent . child 1  )     =  =    sibling )     {", "oldParent . child 1     =    newParent ;", "} else    {", "oldParent . child 2     =    newParent ;", "}", "newParent . child 1     =    sibling ;", "newParent . child 2     =    leaf ;", "sibling . parent    =    newParent ;", "leaf . parent    =    newParent ;", "} else    {", "newParent . child 1     =    sibling ;", "newParent . child 2     =    leaf ;", "sibling . parent    =    newParent ;", "leaf . parent    =    newParent ;", "m _ root    =    newParent ;", "}", "index    =    leaf . parent ;", "while    ( index    !  =    null )     {", "index    =    balance ( index )  ;", "DynamicTreeNode   child 1     =    index . child 1  ;", "DynamicTreeNode   child 2     =    index . child 2  ;", "assert   child 1     !  =    null ;", "assert   child 2     !  =    null ;", "index . height    =     1     +     ( MathUtils . max ( child 1  . height ,    child 2  . height )  )  ;", "index . aabb . combine ( child 1  . aabb ,    child 2  . aabb )  ;", "index    =    index . parent ;", "}", "}", "METHOD_END"], "methodName": ["insertLeaf"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "int [  ]    nodes    =    new   int [ m _ nodeCount ]  ;", "int   count    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( m _ nodeCapacity )  ;     +  + i )     {", "if    (  ( m _ nodes [ i ]  . height )     <     0  )     {", "continue ;", "}", "Node   node    =    m _ nodes [ i ]  ;", "if    (  ( node . child 1  )     =  =    null )     {", "node . parent    =    null ;", "nodes [ count ]     =    i ;", "+  + count ;", "} else    {", "freeNode ( node )  ;", "}", "}", "AABB   b    =    new   AABB (  )  ;", "while    ( count    >     1  )     {", "float   minCost    =    Float . MAX _ VALUE ;", "int   iMin    =     -  1  ;", "int   jMin    =     -  1  ;", "for    ( int   i    =     0  ;    i    <    count ;     +  + i )     {", "AABB   aabbi    =    m _ nodes [ nodes [ i ]  ]  . aabb ;", "for    ( int   j    =    i    +     1  ;    j    <    count ;     +  + j )     {", "AABB   aabbj    =    m _ nodes [ nodes [ j ]  ]  . aabb ;", "b . combine ( aabbi ,    aabbj )  ;", "float   cost    =    b . getPerimeter (  )  ;", "if    ( cost    <    minCost )     {", "iMin    =    i ;", "jMin    =    j ;", "minCost    =    cost ;", "}", "}", "}", "int   index 1     =    nodes [ iMin ]  ;", "int   index 2     =    nodes [ jMin ]  ;", "Node   child 1     =    m _ nodes [ index 1  ]  ;", "Node   child 2     =    m _ nodes [ index 2  ]  ;", "Node   parent    =    allocateNode (  )  ;", "parent . child 1     =    child 1  ;", "parent . child 2     =    child 2  ;", "parent . height    =     1     +     ( MathUtils . max ( child 1  . height ,    child 2  . height )  )  ;", "parent . aabb . combine ( child 1  . aabb ,    child 2  . aabb )  ;", "parent . parent    =    null ;", "child 1  . parent    =    parent ;", "child 2  . parent    =    parent ;", "nodes [ jMin ]     =    nodes [  ( count    -     1  )  ]  ;", "nodes [ iMin ]     =    parent . id ;", "-  - count ;", "}", "m _ root    =    m _ nodes [ nodes [  0  ]  ]  ;", "validate (  )  ;", "}", "METHOD_END"], "methodName": ["rebuildBottomUp"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "if    ( leaf    =  =     ( m _ root )  )     {", "m _ root    =    null ;", "return ;", "}", "Node   parent    =    leaf . parent ;", "Node   grandParent    =    parent . parent ;", "Node   sibling ;", "if    (  ( parent . child 1  )     =  =    leaf )     {", "sibling    =    parent . child 2  ;", "} else    {", "sibling    =    parent . child 1  ;", "}", "if    ( grandParent    !  =    null )     {", "if    (  ( grandParent . child 1  )     =  =    parent )     {", "grandParent . child 1     =    sibling ;", "} else    {", "grandParent . child 2     =    sibling ;", "}", "sibling . parent    =    grandParent ;", "freeNode ( parent )  ;", "Node   index    =    grandParent ;", "while    ( index    !  =    null )     {", "index    =    balance ( index )  ;", "Node   child 1     =    index . child 1  ;", "Node   child 2     =    index . child 2  ;", "index . aabb . combine ( child 1  . aabb ,    child 2  . aabb )  ;", "index . height    =     1     +     ( MathUtils . max ( child 1  . height ,    child 2  . height )  )  ;", "index    =    index . parent ;", "}", "} else    {", "m _ root    =    sibling ;", "sibling . parent    =    null ;", "freeNode ( parent )  ;", "}", "}", "METHOD_END"], "methodName": ["removeLeaf"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "validateStructure ( m _ root )  ;", "validateMetrics ( m _ root )  ;", "int   freeCount    =     0  ;", "Node   freeNode    =     (  ( m _ freeList )     !  =     (  . NULL _ NODE )  )     ?    m _ nodes [ m _ freeList ]     :    null ;", "while    ( freeNode    !  =    null )     {", "assert    (  0     <  =     ( freeNode . id )  )     &  &     (  ( freeNode . id )     <     ( m _ nodeCapacity )  )  ;", "assert   freeNode    =  =     ( m _ nodes [ freeNode . id ]  )  ;", "freeNode    =    freeNode . parent ;", "+  + freeCount ;", "}", "assert    ( getHeight (  )  )     =  =     ( computeHeight (  )  )  ;", "assert    (  ( m _ nodeCount )     +    freeCount )     =  =     ( m _ nodeCapacity )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "if    ( node    =  =    null )     {", "return ;", "}", "Node   child 1     =    node . child 1  ;", "Node   child 2     =    node . child 2  ;", "if    (  ( node . child 1  )     =  =    null )     {", "assert   child 1     =  =    null ;", "assert   child 2     =  =    null ;", "assert    ( node . height )     =  =     0  ;", "return ;", "}", "assert    (  ( child 1     !  =    null )     &  &     (  0     <  =     ( child 1  . id )  )  )     &  &     (  ( child 1  . id )     <     ( m _ nodeCapacity )  )  ;", "assert    (  ( child 2     !  =    null )     &  &     (  0     <  =     ( child 2  . id )  )  )     &  &     (  ( child 2  . id )     <     ( m _ nodeCapacity )  )  ;", "int   height 1     =    child 1  . height ;", "int   height 2     =    child 2  . height ;", "int   height ;", "height    =     1     +     ( MathUtils . max ( height 1  ,    height 2  )  )  ;", "assert    ( node . height )     =  =    height ;", "AABB   aabb    =    new   AABB (  )  ;", "aabb . combine ( child 1  . aabb ,    child 2  . aabb )  ;", "assert   aabb . lowerBound . equals ( node . aabb . lowerBound )  ;", "assert   aabb . upperBound . equals ( node . aabb . upperBound )  ;", "validateMetrics ( child 1  )  ;", "validateMetrics ( child 2  )  ;", "}", "METHOD_END"], "methodName": ["validateMetrics"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "if    ( node    =  =    null )     {", "return ;", "}", "assert   node    =  =     ( m _ nodes [ node . id ]  )  ;", "if    ( node    =  =     ( m _ root )  )     {", "assert    ( node . parent )     =  =    null ;", "}", "Node   child 1     =    node . child 1  ;", "Node   child 2     =    node . child 2  ;", "if    (  ( node . child 1  )     =  =    null )     {", "assert   child 1     =  =    null ;", "assert   child 2     =  =    null ;", "assert    ( node . height )     =  =     0  ;", "return ;", "}", "assert    (  ( child 1     !  =    null )     &  &     (  0     <  =     ( child 1  . id )  )  )     &  &     (  ( child 1  . id )     <     ( m _ nodeCapacity )  )  ;", "assert    (  ( child 2     !  =    null )     &  &     (  0     <  =     ( child 2  . id )  )  )     &  &     (  ( child 2  . id )     <     ( m _ nodeCapacity )  )  ;", "assert    ( child 1  . parent )     =  =    node ;", "assert    ( child 2  . parent )     =  =    node ;", "validateStructure ( child 1  )  ;", "validateStructure ( child 2  )  ;", "}", "METHOD_END"], "methodName": ["validateStructure"], "fileName": "org.jbox2d.collision.broadphase.DynamicTree"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ freeList )     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "assert    ( m _ nodeCount )     =  =     ( m _ nodeCapacity )  ;", "m _ nodeCapacity    *  =     2  ;", "expandBuffers ( m _ nodeCount ,    m _ nodeCapacity )  ;", "}", "assert    ( m _ freeList )     !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "int   node    =    m _ freeList ;", "m _ freeList    =    m _ parent [ node ]  ;", "m _ parent [ node ]     =    DynamicTreeFlatNodes . NULL _ NODE ;", "m _ child 1  [ node ]     =    DynamicTreeFlatNodes . NULL _ NODE ;", "m _ height [ node ]     =     0  ;", "+  +  ( m _ nodeCount )  ;", "return   node ;", "}", "METHOD_END"], "methodName": ["allocateNode"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "assert   iA    !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "int   A    =    iA ;", "if    (  (  ( m _ child 1  [ A ]  )     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     |  |     (  ( m _ height [ A ]  )     <     2  )  )     {", "return   iA ;", "}", "int   iB    =    m _ child 1  [ A ]  ;", "int   iC    =    m _ child 2  [ A ]  ;", "assert    (  0     <  =    iB )     &  &     ( iB    <     ( m _ nodeCapacity )  )  ;", "assert    (  0     <  =    iC )     &  &     ( iC    <     ( m _ nodeCapacity )  )  ;", "int   B    =    iB ;", "int   C    =    iC ;", "int   balance    =     ( m _ height [ C ]  )     -     ( m _ height [ B ]  )  ;", "if    ( balance    >     1  )     {", "int   iF    =    m _ child 1  [ C ]  ;", "int   iG    =    m _ child 2  [ C ]  ;", "int   F    =    iF ;", "int   G    =    iG ;", "assert    (  0     <  =    iF )     &  &     ( iF    <     ( m _ nodeCapacity )  )  ;", "assert    (  0     <  =    iG )     &  &     ( iG    <     ( m _ nodeCapacity )  )  ;", "m _ child 1  [ C ]     =    iA ;", "int   cParent    =    m _ parent [ C ]     =    m _ parent [ A ]  ;", "m _ parent [ A ]     =    iC ;", "if    ( cParent    !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "if    (  ( m _ child 1  [ cParent ]  )     =  =    iA )     {", "m _ child 1  [ cParent ]     =    iC ;", "} else    {", "assert    ( m _ child 2  [ cParent ]  )     =  =    iA ;", "m _ child 2  [ cParent ]     =    iC ;", "}", "} else    {", "m _ root    =    iC ;", "}", "if    (  ( m _ height [ F ]  )     >     ( m _ height [ G ]  )  )     {", "m _ child 2  [ C ]     =    iF ;", "m _ child 2  [ A ]     =    iG ;", "m _ parent [ G ]     =    iA ;", "m _ aabb [ A ]  . combine ( m _ aabb [ B ]  ,    m _ aabb [ G ]  )  ;", "m _ aabb [ C ]  . combine ( m _ aabb [ A ]  ,    m _ aabb [ F ]  )  ;", "m _ height [ A ]     =     1     +     ( MathUtils . max ( m _ height [ B ]  ,    m _ height [ G ]  )  )  ;", "m _ height [ C ]     =     1     +     ( MathUtils . max ( m _ height [ A ]  ,    m _ height [ F ]  )  )  ;", "} else    {", "m _ child 2  [ C ]     =    iG ;", "m _ child 2  [ A ]     =    iF ;", "m _ parent [ F ]     =    iA ;", "m _ aabb [ A ]  . combine ( m _ aabb [ B ]  ,    m _ aabb [ F ]  )  ;", "m _ aabb [ C ]  . combine ( m _ aabb [ A ]  ,    m _ aabb [ G ]  )  ;", "m _ height [ A ]     =     1     +     ( MathUtils . max ( m _ height [ B ]  ,    m _ height [ F ]  )  )  ;", "m _ height [ C ]     =     1     +     ( MathUtils . max ( m _ height [ A ]  ,    m _ height [ G ]  )  )  ;", "}", "return   iC ;", "}", "if    ( balance    <     (  -  1  )  )     {", "int   iD    =    m _ child 1  [ B ]  ;", "int   iE    =    m _ child 2  [ B ]  ;", "int   D    =    iD ;", "int   E    =    iE ;", "assert    (  0     <  =    iD )     &  &     ( iD    <     ( m _ nodeCapacity )  )  ;", "assert    (  0     <  =    iE )     &  &     ( iE    <     ( m _ nodeCapacity )  )  ;", "m _ child 1  [ B ]     =    iA ;", "int   Bparent    =    m _ parent [ B ]     =    m _ parent [ A ]  ;", "m _ parent [ A ]     =    iB ;", "if    ( Bparent    !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "if    (  ( m _ child 1  [ Bparent ]  )     =  =    iA )     {", "m _ child 1  [ Bparent ]     =    iB ;", "} else    {", "assert    ( m _ child 2  [ Bparent ]  )     =  =    iA ;", "m _ child 2  [ Bparent ]     =    iB ;", "}", "} else    {", "m _ root    =    iB ;", "}", "if    (  ( m _ height [ D ]  )     >     ( m _ height [ E ]  )  )     {", "m _ child 2  [ B ]     =    iD ;", "m _ child 1  [ A ]     =    iE ;", "m _ parent [ E ]     =    iA ;", "m _ aabb [ A ]  . combine ( m _ aabb [ C ]  ,    m _ aabb [ E ]  )  ;", "m _ aabb [ B ]  . combine ( m _ aabb [ A ]  ,    m _ aabb [ D ]  )  ;", "m _ height [ A ]     =     1     +     ( MathUtils . max ( m _ height [ C ]  ,    m _ height [ E ]  )  )  ;", "m _ height [ B ]     =     1     +     ( MathUtils . max ( m _ height [ A ]  ,    m _ height [ D ]  )  )  ;", "} else    {", "m _ child 2  [ B ]     =    iE ;", "m _ child 1  [ A ]     =    iD ;", "m _ parent [ D ]     =    iA ;", "m _ aabb [ A ]  . combine ( m _ aabb [ C ]  ,    m _ aabb [ D ]  )  ;", "m _ aabb [ B ]  . combine ( m _ aabb [ A ]  ,    m _ aabb [ E ]  )  ;", "m _ height [ A ]     =     1     +     ( MathUtils . max ( m _ height [ C ]  ,    m _ height [ D ]  )  )  ;", "m _ height [ B ]     =     1     +     ( MathUtils . max ( m _ height [ A ]  ,    m _ height [ E ]  )  )  ;", "}", "return   iB ;", "}", "return   iA ;", "}", "METHOD_END"], "methodName": ["balance"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "assert    (  0     <  =    node )     &  &     ( node    <     ( m _ nodeCapacity )  )  ;", "if    (  ( m _ child 1  [ node ]  )     =  =     (  . NULL _ NODE )  )     {", "return    0  ;", "}", "int   height 1     =    computeHeight ( m _ child 1  [ node ]  )  ;", "int   height 2     =    computeHeight ( m _ child 2  [ node ]  )  ;", "return    1     +     ( MathUtils . max ( height 1  ,    height 2  )  )  ;", "}", "METHOD_END"], "methodName": ["computeHeight"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "AABB   a    =    m _ aabb [ node ]  ;", "a . getVertices ( drawVecs )  ;", "color . set (  1  ,     (  (  ( height    -    spot )     *     1  .  0 F )     /    height )  ,     (  (  ( height    -    spot )     *     1  .  0 F )     /    height )  )  ;", "argDraw . drawPolygon ( drawVecs ,     4  ,    color )  ;", "argDraw . getViewportTranform (  )  . getWorldToScreen ( a . upperBound ,    textVec )  ;", "argDraw . drawString ( textVec . x ,    textVec . y ,     (  (  (  ( node    +     \"  -  \"  )     +     ( spot    +     1  )  )     +     \"  /  \"  )     +    height )  ,    color )  ;", "int   c 1     =    m _ child 1  [ node ]  ;", "int   c 2     =    m _ child 2  [ node ]  ;", "if    ( c 1     !  =     (  . NULL _ NODE )  )     {", "drawTree ( argDraw ,    c 1  ,     ( spot    +     1  )  ,    height )  ;", "}", "if    ( c 2     !  =     (  . NULL _ NODE )  )     {", "drawTree ( argDraw ,    c 2  ,     ( spot    +     1  )  ,    height )  ;", "}", "}", "METHOD_END"], "methodName": ["drawTree"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "m _ aabb    =    BufferUtils . reallocateBuffer ( AABB . class ,    m _ aabb ,    oldSize ,    newSize )  ;", "m _ userData    =    BufferUtils . reallocateBuffer ( Object . class ,    m _ userData ,    oldSize ,    newSize )  ;", "m _ parent    =    BufferUtils . reallocateBuffer ( m _ parent ,    oldSize ,    newSize )  ;", "m _ child 1     =    BufferUtils . reallocateBuffer ( m _ child 1  ,    oldSize ,    newSize )  ;", "m _ child 2     =    BufferUtils . reallocateBuffer ( m _ child 2  ,    oldSize ,    newSize )  ;", "m _ height    =    BufferUtils . reallocateBuffer ( m _ height ,    oldSize ,    newSize )  ;", "for    ( int   i    =    oldSize ;    i    <    newSize ;    i +  +  )     {", "m _ aabb [ i ]     =    new   AABB (  )  ;", "m _ parent [ i ]     =     ( i    =  =     ( newSize    -     1  )  )     ?     . NULL _ NODE    :    i    +     1  ;", "m _ height [ i ]     =     -  1  ;", "m _ child 1  [ i ]     =     -  1  ;", "m _ child 2  [ i ]     =     -  1  ;", "}", "m _ freeList    =    oldSize ;", "}", "METHOD_END"], "methodName": ["expandBuffers"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "assert   node    !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "assert    0     <     ( m _ nodeCount )  ;", "m _ parent [ node ]     =     (  ( m _ freeList )     !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     ?    m _ freeList    :    DynamicTreeFlatNodes . NULL _ NODE ;", "m _ height [ node ]     =     -  1  ;", "m _ freeList    =    node ;", "( m _ nodeCount )  -  -  ;", "}", "METHOD_END"], "methodName": ["freeNode"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ root )     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "m _ root    =    leaf ;", "m _ parent [ m _ root ]     =    DynamicTreeFlatNodes . NULL _ NODE ;", "return ;", "}", "AABB   leafAABB    =    m _ aabb [ leaf ]  ;", "int   index    =    m _ root ;", "while    (  ( m _ child 1  [ index ]  )     !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "final   int   node    =    index ;", "int   child 1     =    m _ child 1  [ node ]  ;", "int   child 2     =    m _ child 2  [ node ]  ;", "final   AABB   nodeAABB    =    m _ aabb [ node ]  ;", "float   area    =    nodeAABB . getPerimeter (  )  ;", "combinedAABB . combine ( nodeAABB ,    leafAABB )  ;", "float   combinedArea    =    combinedAABB . getPerimeter (  )  ;", "float   cost    =     2  .  0 F    *    combinedArea ;", "float   inheritanceCost    =     2  .  0 F    *     ( combinedArea    -    area )  ;", "float   cost 1  ;", "AABB   child 1 AABB    =    m _ aabb [ child 1  ]  ;", "if    (  ( m _ child 1  [ child 1  ]  )     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "combinedAABB . combine ( leafAABB ,    child 1 AABB )  ;", "cost 1     =     ( combinedAABB . getPerimeter (  )  )     +    inheritanceCost ;", "} else    {", "combinedAABB . combine ( leafAABB ,    child 1 AABB )  ;", "float   oldArea    =    child 1 AABB . getPerimeter (  )  ;", "float   newArea    =    combinedAABB . getPerimeter (  )  ;", "cost 1     =     ( newArea    -    oldArea )     +    inheritanceCost ;", "}", "float   cost 2  ;", "AABB   child 2 AABB    =    m _ aabb [ child 2  ]  ;", "if    (  ( m _ child 1  [ child 2  ]  )     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "combinedAABB . combine ( leafAABB ,    child 2 AABB )  ;", "cost 2     =     ( combinedAABB . getPerimeter (  )  )     +    inheritanceCost ;", "} else    {", "combinedAABB . combine ( leafAABB ,    child 2 AABB )  ;", "float   oldArea    =    child 2 AABB . getPerimeter (  )  ;", "float   newArea    =    combinedAABB . getPerimeter (  )  ;", "cost 2     =     ( newArea    -    oldArea )     +    inheritanceCost ;", "}", "if    (  ( cost    <    cost 1  )     &  &     ( cost    <    cost 2  )  )     {", "break ;", "}", "if    ( cost 1     <    cost 2  )     {", "index    =    child 1  ;", "} else    {", "index    =    child 2  ;", "}", "}", "int   sibling    =    index ;", "int   oldParent    =    m _ parent [ sibling ]  ;", "final   int   newParent    =    allocateNode (  )  ;", "m _ parent [ newParent ]     =    oldParent ;", "m _ userData [ newParent ]     =    null ;", "m _ aabb [ newParent ]  . combine ( leafAABB ,    m _ aabb [ sibling ]  )  ;", "m _ height [ newParent ]     =     ( m _ height [ sibling ]  )     +     1  ;", "if    ( oldParent    !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "if    (  ( m _ child 1  [ oldParent ]  )     =  =    sibling )     {", "m _ child 1  [ oldParent ]     =    newParent ;", "} else    {", "m _ child 2  [ oldParent ]     =    newParent ;", "}", "m _ child 1  [ newParent ]     =    sibling ;", "m _ child 2  [ newParent ]     =    leaf ;", "m _ parent [ sibling ]     =    newParent ;", "m _ parent [ leaf ]     =    newParent ;", "} else    {", "m _ child 1  [ newParent ]     =    sibling ;", "m _ child 2  [ newParent ]     =    leaf ;", "m _ parent [ sibling ]     =    newParent ;", "m _ parent [ leaf ]     =    newParent ;", "m _ root    =    newParent ;", "}", "index    =    m _ parent [ leaf ]  ;", "while    ( index    !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "index    =    balance ( index )  ;", "int   child 1     =    m _ child 1  [ index ]  ;", "int   child 2     =    m _ child 2  [ index ]  ;", "assert   child 1     !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "assert   child 2     !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "m _ height [ index ]     =     1     +     ( MathUtils . max ( m _ height [ child 1  ]  ,    m _ height [ child 2  ]  )  )  ;", "m _ aabb [ index ]  . combine ( m _ aabb [ child 1  ]  ,    m _ aabb [ child 2  ]  )  ;", "index    =    m _ parent [ index ]  ;", "}", "}", "METHOD_END"], "methodName": ["insertLeaf"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "if    ( leaf    =  =     ( m _ root )  )     {", "m _ root    =     . NULL _ NODE ;", "return ;", "}", "int   parent    =    m _ parent [ leaf ]  ;", "int   grandParent    =    m _ parent [ parent ]  ;", "int   parentChild 1     =    m _ child 1  [ parent ]  ;", "int   parentChild 2     =    m _ child 2  [ parent ]  ;", "int   sibling ;", "if    ( parentChild 1     =  =    leaf )     {", "sibling    =    parentChild 2  ;", "} else    {", "sibling    =    parentChild 1  ;", "}", "if    ( grandParent    !  =     (  . NULL _ NODE )  )     {", "if    (  ( m _ child 1  [ grandParent ]  )     =  =    parent )     {", "m _ child 1  [ grandParent ]     =    sibling ;", "} else    {", "m _ child 2  [ grandParent ]     =    sibling ;", "}", "m _ parent [ sibling ]     =    grandParent ;", "freeNode ( parent )  ;", "int   index    =    grandParent ;", "while    ( index    !  =     (  . NULL _ NODE )  )     {", "index    =    balance ( index )  ;", "int   child 1     =    m _ child 1  [ index ]  ;", "int   child 2     =    m _ child 2  [ index ]  ;", "m _ aabb [ index ]  . combine ( m _ aabb [ child 1  ]  ,    m _ aabb [ child 2  ]  )  ;", "m _ height [ index ]     =     1     +     ( MathUtils . max ( m _ height [ child 1  ]  ,    m _ height [ child 2  ]  )  )  ;", "index    =    m _ parent [ index ]  ;", "}", "} else    {", "m _ root    =    sibling ;", "m _ parent [ sibling ]     =     . NULL _ NODE ;", "freeNode ( parent )  ;", "}", "}", "METHOD_END"], "methodName": ["removeLeaf"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "validateStructure ( m _ root )  ;", "validateMetrics ( m _ root )  ;", "int   freeCount    =     0  ;", "int   freeNode    =    m _ freeList ;", "while    ( freeNode    !  =     (  . NULL _ NODE )  )     {", "assert    (  0     <  =    freeNode )     &  &     ( freeNode    <     ( m _ nodeCapacity )  )  ;", "freeNode    =    m _ parent [ freeNode ]  ;", "+  + freeCount ;", "}", "assert    ( getHeight (  )  )     =  =     ( computeHeight (  )  )  ;", "assert    (  ( m _ nodeCount )     +    freeCount )     =  =     ( m _ nodeCapacity )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "if    ( node    =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "return ;", "}", "int   child 1     =    m _ child 1  [ node ]  ;", "int   child 2     =    m _ child 2  [ node ]  ;", "if    ( child 1     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "assert   child 1     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "assert   child 2     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "assert    ( m _ height [ node ]  )     =  =     0  ;", "return ;", "}", "assert    (  ( child 1     !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     &  &     (  0     <  =    child 1  )  )     &  &     ( child 1     <     ( m _ nodeCapacity )  )  ;", "assert    (  ( child 2     !  =    child 1  )     &  &     (  0     <  =    child 2  )  )     &  &     ( child 2     <     ( m _ nodeCapacity )  )  ;", "int   height 1     =    m _ height [ child 1  ]  ;", "int   height 2     =    m _ height [ child 2  ]  ;", "int   height ;", "height    =     1     +     ( MathUtils . max ( height 1  ,    height 2  )  )  ;", "assert    ( m _ height [ node ]  )     =  =    height ;", "AABB   aabb    =    new   AABB (  )  ;", "aabb . combine ( m _ aabb [ child 1  ]  ,    m _ aabb [ child 2  ]  )  ;", "assert   aabb . lowerBound . equals ( m _ aabb [ node ]  . lowerBound )  ;", "assert   aabb . upperBound . equals ( m _ aabb [ node ]  . upperBound )  ;", "validateMetrics ( child 1  )  ;", "validateMetrics ( child 2  )  ;", "}", "METHOD_END"], "methodName": ["validateMetrics"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "if    ( node    =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "return ;", "}", "if    ( node    =  =     ( m _ root )  )     {", "assert    ( m _ parent [ node ]  )     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "}", "int   child 1     =    m _ child 1  [ node ]  ;", "int   child 2     =    m _ child 2  [ node ]  ;", "if    ( child 1     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     {", "assert   child 1     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "assert   child 2     =  =     ( DynamicTreeFlatNodes . NULL _ NODE )  ;", "assert    ( m _ height [ node ]  )     =  =     0  ;", "return ;", "}", "assert    (  ( child 1     !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     &  &     (  0     <  =    child 1  )  )     &  &     ( child 1     <     ( m _ nodeCapacity )  )  ;", "assert    (  ( child 2     !  =     ( DynamicTreeFlatNodes . NULL _ NODE )  )     &  &     (  0     <  =    child 2  )  )     &  &     ( child 2     <     ( m _ nodeCapacity )  )  ;", "assert    ( m _ parent [ child 1  ]  )     =  =    node ;", "assert    ( m _ parent [ child 2  ]  )     =  =    node ;", "validateStructure ( child 1  )  ;", "validateStructure ( child 2  )  ;", "}", "METHOD_END"], "methodName": ["validateStructure"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeFlatNodes"}, {"methodBody": ["METHOD_START", "{", "return   userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeNode"}, {"methodBody": ["METHOD_START", "{", "userData    =    argData ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "org.jbox2d.collision.broadphase.DynamicTreeNode"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . proxyIdA )     <     ( pair 2  . proxyIdA )  )     {", "return    -  1  ;", "}", "if    (  ( this . proxyIdA )     =  =     ( pair 2  . proxyIdA )  )     {", "return    ( proxyIdB )     <     ( pair 2  . proxyIdB )     ?     -  1     :     ( proxyIdB )     =  =     ( pair 2  . proxyIdB )     ?     0     :     1  ;", "}", "return    1  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.jbox2d.collision.broadphase.Pair"}, {"methodBody": ["METHOD_START", "{", "assert    (  ( m _ vertices )     =  =    null )     &  &     (  ( m _ count )     =  =     0  )  ;", "assert   count    >  =     2  ;", "m _ count    =    count ;", "m _ vertices    =    new   Vec 2  [ m _ count ]  ;", "for    ( int   i    =     1  ;    i    <     ( m _ count )  ;    i +  +  )     {", "Vec 2    v 1     =    vertices [  ( i    -     1  )  ]  ;", "Vec 2    v 2     =    vertices [ i ]  ;", "if    (  ( MathUtils . distanceSquared ( v 1  ,    v 2  )  )     <     (  ( Settings . linearSlop )     *     ( Settings . linearSlop )  )  )     {", "throw   new   RuntimeException (  \" Vertices   of   chain      are   too   close   together \"  )  ;", "}", "}", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "m _ vertices [ i ]     =    new   Vec 2  ( vertices [ i ]  )  ;", "}", "m _ hasPrevVertex    =    false ;", "m _ hasNextVertex    =    false ;", "m _ prevVertex . setZero (  )  ;", "m _ nextVertex . setZero (  )  ;", "}", "METHOD_END"], "methodName": ["createChain"], "fileName": "org.jbox2d.collision.shapes.ChainShape"}, {"methodBody": ["METHOD_START", "{", "assert    (  ( m _ vertices )     =  =    null )     &  &     (  ( m _ count )     =  =     0  )  ;", "assert   count    >  =     3  ;", "m _ count    =    count    +     1  ;", "m _ vertices    =    new   Vec 2  [ m _ count ]  ;", "for    ( int   i    =     1  ;    i    <    count ;    i +  +  )     {", "Vec 2    v 1     =    vertices [  ( i    -     1  )  ]  ;", "Vec 2    v 2     =    vertices [ i ]  ;", "if    (  ( MathUtils . distanceSquared ( v 1  ,    v 2  )  )     <     (  ( Settings . linearSlop )     *     ( Settings . linearSlop )  )  )     {", "throw   new   RuntimeException (  \" Vertices   of   chain      are   too   close   together \"  )  ;", "}", "}", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "m _ vertices [ i ]     =    new   Vec 2  ( vertices [ i ]  )  ;", "}", "m _ vertices [ count ]     =    new   Vec 2  ( m _ vertices [  0  ]  )  ;", "m _ prevVertex . set ( m _ vertices [  (  ( m _ count )     -     2  )  ]  )  ;", "m _ nextVertex . set ( m _ vertices [  1  ]  )  ;", "m _ hasPrevVertex    =    true ;", "m _ hasNextVertex    =    true ;", "}", "METHOD_END"], "methodName": ["createLoop"], "fileName": "org.jbox2d.collision.shapes.ChainShape"}, {"methodBody": ["METHOD_START", "{", "assert    (  0     <  =    index )     &  &     ( index    <     (  ( m _ count )     -     1  )  )  ;", "edge . m _ radius    =    m _ radius ;", "final   Vec 2    v 0     =    m _ vertices [  ( index    +     0  )  ]  ;", "final   Vec 2    v 1     =    m _ vertices [  ( index    +     1  )  ]  ;", "edge . m _ vertex 1  . x    =    v 0  . x ;", "edge . m _ vertex 1  . y    =    v 0  . y ;", "edge . m _ vertex 2  . x    =    v 1  . x ;", "edge . m _ vertex 2  . y    =    v 1  . y ;", "if    ( index    >     0  )     {", "Vec 2    v    =    m _ vertices [  ( index    -     1  )  ]  ;", "edge . m _ vertex 0  . x    =    v . x ;", "edge . m _ vertex 0  . y    =    v . y ;", "edge . m _ hasVertex 0     =    true ;", "} else    {", "edge . m _ vertex 0  . x    =    m _ prevVertex . x ;", "edge . m _ vertex 0  . y    =    m _ prevVertex . y ;", "edge . m _ hasVertex 0     =    m _ hasPrevVertex ;", "}", "if    ( index    <     (  ( m _ count )     -     2  )  )     {", "Vec 2    v    =    m _ vertices [  ( index    +     2  )  ]  ;", "edge . m _ vertex 3  . x    =    v . x ;", "edge . m _ vertex 3  . y    =    v . y ;", "edge . m _ hasVertex 3     =    true ;", "} else    {", "edge . m _ vertex 3  . x    =    m _ nextVertex . x ;", "edge . m _ vertex 3  . y    =    m _ nextVertex . y ;", "edge . m _ hasVertex 3     =    m _ hasNextVertex ;", "}", "}", "METHOD_END"], "methodName": ["getChildEdge"], "fileName": "org.jbox2d.collision.shapes.ChainShape"}, {"methodBody": ["METHOD_START", "{", "m _ nextVertex . set ( nextVertex )  ;", "m _ hasNextVertex    =    true ;", "}", "METHOD_END"], "methodName": ["setNextVertex"], "fileName": "org.jbox2d.collision.shapes.ChainShape"}, {"methodBody": ["METHOD_START", "{", "m _ prevVertex . set ( prevVertex )  ;", "m _ hasPrevVertex    =    true ;", "}", "METHOD_END"], "methodName": ["setPrevVertex"], "fileName": "org.jbox2d.collision.shapes.ChainShape"}, {"methodBody": ["METHOD_START", "{", "CircleShape   shape    =    new   CircleShape (  )  ;", "shape . m _ p . x    =    m _ p . x ;", "shape . m _ p . y    =    m _ p . y ;", "shape . m _ radius    =    m _ radius ;", "return   shape ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jbox2d.collision.shapes.CircleShape"}, {"methodBody": ["METHOD_START", "{", "return    1  ;", "}", "METHOD_END"], "methodName": ["getChildCount"], "fileName": "org.jbox2d.collision.shapes.CircleShape"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getSupport"], "fileName": "org.jbox2d.collision.shapes.CircleShape"}, {"methodBody": ["METHOD_START", "{", "return   m _ p ;", "}", "METHOD_END"], "methodName": ["getSupportVertex"], "fileName": "org.jbox2d.collision.shapes.CircleShape"}, {"methodBody": ["METHOD_START", "{", "assert   index    =  =     0  ;", "return   m _ p ;", "}", "METHOD_END"], "methodName": ["getVertex"], "fileName": "org.jbox2d.collision.shapes.CircleShape"}, {"methodBody": ["METHOD_START", "{", "return    1  ;", "}", "METHOD_END"], "methodName": ["getVertexCount"], "fileName": "org.jbox2d.collision.shapes.CircleShape"}, {"methodBody": ["METHOD_START", "{", "m _ vertex 1  . set ( v 1  )  ;", "m _ vertex 2  . set ( v 2  )  ;", "m _ hasVertex 0     =    m _ hasVertex 3     =    false ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.shapes.EdgeShape"}, {"methodBody": ["METHOD_START", "{", "return   new   MassData ( this )  ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jbox2d.collision.shapes.MassData"}, {"methodBody": ["METHOD_START", "{", "mass    =    md . mass ;", "I    =    md . I ;", "center . set ( md . center )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.shapes.MassData"}, {"methodBody": ["METHOD_START", "{", "return   Transform . mul ( xf ,    m _ centroid )  ;", "}", "METHOD_END"], "methodName": ["centroid"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "Transform . mulToOutUnsafe ( xf ,    m _ centroid ,    out )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["centroidToOut"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "PolygonShape   shape    =    new   PolygonShape (  )  ;", "shape . m _ centroid . set ( this . m _ centroid )  ;", "for    ( int   i    =     0  ;    i    <     ( shape . m _ normals . length )  ;    i +  +  )     {", "shape . m _ normals [ i ]  . set ( m _ normals [ i ]  )  ;", "shape . m _ vertices [ i ]  . set ( m _ vertices [ i ]  )  ;", "}", "shape . setRadius ( this . getRadius (  )  )  ;", "shape . m _ count    =    this . m _ count ;", "return   shape ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "assert   count    >  =     3  ;", "out . set (  0  .  0 F ,     0  .  0 F )  ;", "float   area    =     0  .  0 F ;", "final   Vec 2    pRef    =    pool 1  ;", "pRef . setZero (  )  ;", "final   Vec 2    e 1     =    pool 2  ;", "final   Vec 2    e 2     =    pool 3  ;", "final   float   inv 3     =     1  .  0 F    /     3  .  0 F ;", "for    ( int   i    =     0  ;    i    <    count ;     +  + i )     {", "final   Vec 2    p 1     =    pRef ;", "final   Vec 2    p 2     =    vs [ i ]  ;", "final   Vec 2    p 3     =     (  ( i    +     1  )     <    count )     ?    vs [  ( i    +     1  )  ]     :    vs [  0  ]  ;", "e 1  . set ( p 2  )  . subLocal ( p 1  )  ;", "e 2  . set ( p 3  )  . subLocal ( p 1  )  ;", "final   float   D    =    Vec 2  . cross ( e 1  ,    e 2  )  ;", "final   float   triangleArea    =     0  .  5 F    *    D ;", "area    +  =    triangleArea ;", "e 1  . set ( p 1  )  . addLocal ( p 2  )  . addLocal ( p 3  )  . mulLocal (  ( triangleArea    *    inv 3  )  )  ;", "out . addLocal ( e 1  )  ;", "}", "assert   area    >     ( Settings . EPSILON )  ;", "out . mulLocal (  (  1  .  0 F    /    area )  )  ;", "}", "METHOD_END"], "methodName": ["computeCentroidToOut"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ count )     >  =     3  ;", "final   Vec 2    center    =    pool 1  ;", "center . setZero (  )  ;", "float   area    =     0  .  0 F ;", "float   I    =     0  .  0 F ;", "final   Vec 2    s    =    pool 2  ;", "s . setZero (  )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "s . addLocal ( m _ vertices [ i ]  )  ;", "}", "s . mulLocal (  (  1  .  0 F    /     ( m _ count )  )  )  ;", "final   float   k _ inv 3     =     1  .  0 F    /     3  .  0 F ;", "final   Vec 2    e 1     =    pool 3  ;", "final   Vec 2    e 2     =    pool 4  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "e 1  . set ( m _ vertices [ i ]  )  . subLocal ( s )  ;", "e 2  . set ( s )  . negateLocal (  )  . addLocal (  (  ( i    +     1  )     <     ( m _ count )     ?    m _ vertices [  ( i    +     1  )  ]     :    m _ vertices [  0  ]  )  )  ;", "final   float   D    =    Vec 2  . cross ( e 1  ,    e 2  )  ;", "final   float   triangleArea    =     0  .  5 F    *    D ;", "area    +  =    triangleArea ;", "center . x    +  =     ( triangleArea    *    k _ inv 3  )     *     (  ( e 1  . x )     +     ( e 2  . x )  )  ;", "center . y    +  =     ( triangleArea    *    k _ inv 3  )     *     (  ( e 1  . y )     +     ( e 2  . y )  )  ;", "final   float   ex 1     =    e 1  . x ;", "final   float   ey 1     =    e 1  . y ;", "final   float   ex 2     =    e 2  . x ;", "final   float   ey 2     =    e 2  . y ;", "float   intx 2     =     (  ( ex 1     *    ex 1  )     +     ( ex 2     *    ex 1  )  )     +     ( ex 2     *    ex 2  )  ;", "float   inty 2     =     (  ( ey 1     *    ey 1  )     +     ( ey 2     *    ey 1  )  )     +     ( ey 2     *    ey 2  )  ;", "I    +  =     (  (  0  .  2  5 F    *    k _ inv 3  )     *    D )     *     ( intx 2     +    inty 2  )  ;", "}", "massData . mass    =    density    *    area ;", "assert   area    >     ( Settings . EPSILON )  ;", "center . mulLocal (  (  1  .  0 F    /    area )  )  ;", "massData . center . set ( center )  . addLocal ( s )  ;", "massData . I    =    I    *    density ;", "massData . I    +  =     ( massData . mass )     *     ( Vec 2  . dot ( massData . center ,    massData . center )  )  ;", "}", "METHOD_END"], "methodName": ["computeMass"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "return    1  ;", "}", "METHOD_END"], "methodName": ["getChildCount"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "return   m _ normals ;", "}", "METHOD_END"], "methodName": ["getNormals"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "assert    (  0     <  =    index )     &  &     ( index    <     ( m _ count )  )  ;", "return   m _ vertices [ index ]  ;", "}", "METHOD_END"], "methodName": ["getVertex"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "return   m _ count ;", "}", "METHOD_END"], "methodName": ["getVertexCount"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "return   m _ vertices ;", "}", "METHOD_END"], "methodName": ["getVertices"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "set ( vertices ,    count ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "assert    (  3     <  =    num )     &  &     ( num    <  =     ( Settings . maxPolygonVertices )  )  ;", "if    ( num    <     3  )     {", "setAsBox (  1  .  0 F ,     1  .  0 F )  ;", "return ;", "}", "int   n    =    MathUtils . min ( num ,    Settings . maxPolygonVertices )  ;", "Vec 2  [  ]    ps    =     ( vecPool    !  =    null )     ?    vecPool . get ( Settings . maxPolygonVertices )     :    new   Vec 2  [ Settings . maxPolygonVertices ]  ;", "int   tempCount    =     0  ;", "for    ( int   i    =     0  ;    i    <    n ;     +  + i )     {", "Vec 2    v    =    verts [ i ]  ;", "boolean   unique    =    true ;", "for    ( int   j    =     0  ;    j    <    tempCount ;     +  + j )     {", "if    (  ( MathUtils . distanceSquared ( v ,    ps [ j ]  )  )     <     (  0  .  5 F    *     ( Settings . linearSlop )  )  )     {", "unique    =    false ;", "break ;", "}", "}", "if    ( unique )     {", "ps [  ( tempCount +  +  )  ]     =    v ;", "}", "}", "n    =    tempCount ;", "if    ( n    <     3  )     {", "assert   false ;", "setAsBox (  1  .  0 F ,     1  .  0 F )  ;", "return ;", "}", "int   i 0     =     0  ;", "float   x 0     =    ps [  0  ]  . x ;", "for    ( int   i    =     1  ;    i    <    n ;     +  + i )     {", "float   x    =    ps [ i ]  . x ;", "if    (  ( x    >    x 0  )     |  |     (  ( x    =  =    x 0  )     &  &     (  ( ps [ i ]  . y )     <     ( ps [ i 0  ]  . y )  )  )  )     {", "i 0     =    i ;", "x 0     =    x ;", "}", "}", "int [  ]    hull    =     ( intPool    !  =    null )     ?    intPool . get ( Settings . maxPolygonVertices )     :    new   int [ Settings . maxPolygonVertices ]  ;", "int   m    =     0  ;", "int   ih    =    i 0  ;", "while    ( true )     {", "hull [ m ]     =    ih ;", "int   ie    =     0  ;", "for    ( int   j    =     1  ;    j    <    n ;     +  + j )     {", "if    ( ie    =  =    ih )     {", "ie    =    j ;", "continue ;", "}", "Vec 2    r    =    pool 1  . set ( ps [ ie ]  )  . subLocal ( ps [ hull [ m ]  ]  )  ;", "Vec 2    v    =    pool 2  . set ( ps [ j ]  )  . subLocal ( ps [ hull [ m ]  ]  )  ;", "float   c    =    Vec 2  . cross ( r ,    v )  ;", "if    ( c    <     0  .  0 F )     {", "ie    =    j ;", "}", "if    (  ( c    =  =     0  .  0 F )     &  &     (  ( v . lengthSquared (  )  )     >     ( r . lengthSquared (  )  )  )  )     {", "ie    =    j ;", "}", "}", "+  + m ;", "ih    =    ie ;", "if    ( ie    =  =    i 0  )     {", "break ;", "}", "}", "this . m _ count    =    m ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "if    (  ( m _ vertices [ i ]  )     =  =    null )     {", "m _ vertices [ i ]     =    new   Vec 2  (  )  ;", "}", "m _ vertices [ i ]  . set ( ps [ hull [ i ]  ]  )  ;", "}", "final   Vec 2    edge    =    pool 1  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "final   int   i 1     =    i ;", "final   int   i 2     =     (  ( i    +     1  )     <     ( m _ count )  )     ?    i    +     1     :     0  ;", "edge . set ( m _ vertices [ i 2  ]  )  . subLocal ( m _ vertices [ i 1  ]  )  ;", "assert    ( edge . lengthSquared (  )  )     >     (  ( Settings . EPSILON )     *     ( Settings . EPSILON )  )  ;", "Vec 2  . crossToOutUnsafe ( edge ,     1  .  0 F ,    m _ normals [ i ]  )  ;", "m _ normals [ i ]  . normalize (  )  ;", "}", "computeCentroidToOut ( m _ vertices ,    m _ count ,    m _ centroid )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "m _ count    =     4  ;", "m _ vertices [  0  ]  . set (  (  - hx )  ,     (  - hy )  )  ;", "m _ vertices [  1  ]  . set ( hx ,     (  - hy )  )  ;", "m _ vertices [  2  ]  . set ( hx ,    hy )  ;", "m _ vertices [  3  ]  . set (  (  - hx )  ,    hy )  ;", "m _ normals [  0  ]  . set (  0  .  0 F ,     (  -  1  .  0 F )  )  ;", "m _ normals [  1  ]  . set (  1  .  0 F ,     0  .  0 F )  ;", "m _ normals [  2  ]  . set (  0  .  0 F ,     1  .  0 F )  ;", "m _ normals [  3  ]  . set (  (  -  1  .  0 F )  ,     0  .  0 F )  ;", "m _ centroid . setZero (  )  ;", "}", "METHOD_END"], "methodName": ["setAsBox"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "m _ count    =     4  ;", "m _ vertices [  0  ]  . set (  (  - hx )  ,     (  - hy )  )  ;", "m _ vertices [  1  ]  . set ( hx ,     (  - hy )  )  ;", "m _ vertices [  2  ]  . set ( hx ,    hy )  ;", "m _ vertices [  3  ]  . set (  (  - hx )  ,    hy )  ;", "m _ normals [  0  ]  . set (  0  .  0 F ,     (  -  1  .  0 F )  )  ;", "m _ normals [  1  ]  . set (  1  .  0 F ,     0  .  0 F )  ;", "m _ normals [  2  ]  . set (  0  .  0 F ,     1  .  0 F )  ;", "m _ normals [  3  ]  . set (  (  -  1  .  0 F )  ,     0  .  0 F )  ;", "m _ centroid . set ( center )  ;", "final   Transform   xf    =    poolt 1  ;", "xf . p . set ( center )  ;", "xf . q . set ( angle )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "Transform . mulToOut ( xf ,    m _ vertices [ i ]  ,    m _ vertices [ i ]  )  ;", "Rot . mulToOut ( xf . q ,    m _ normals [ i ]  ,    m _ normals [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAsBox"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "int   i 1     =    i ;", "int   i 2     =     ( i    <     (  ( m _ count )     -     1  )  )     ?    i 1     +     1     :     0  ;", "Vec 2    p    =    m _ vertices [ i 1  ]  ;", "Vec 2    e    =    pool 1  . set ( m _ vertices [ i 2  ]  )  . subLocal ( p )  ;", "for    ( int   j    =     0  ;    j    <     ( m _ count )  ;     +  + j )     {", "if    (  ( j    =  =    i 1  )     |  |     ( j    =  =    i 2  )  )     {", "continue ;", "}", "Vec 2    v    =    pool 2  . set ( m _ vertices [ j ]  )  . subLocal ( p )  ;", "float   c    =    Vec 2  . cross ( e ,    v )  ;", "if    ( c    <     0  .  0 F )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.jbox2d.collision.shapes.PolygonShape"}, {"methodBody": ["METHOD_START", "{", "return   m _ radius ;", "}", "METHOD_END"], "methodName": ["getRadius"], "fileName": "org.jbox2d.collision.shapes.Shape"}, {"methodBody": ["METHOD_START", "{", "return   m _ type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.jbox2d.collision.shapes.Shape"}, {"methodBody": ["METHOD_START", "{", "this . m _ radius    =    radius ;", "}", "METHOD_END"], "methodName": ["setRadius"], "fileName": "org.jbox2d.collision.shapes.Shape"}, {"methodBody": ["METHOD_START", "{", "assert   newCapacity    >    oldCapacity ;", "float [  ]    new    =    new   float [ newCapacity ]  ;", "if    ( old    !  =    null )     {", "System . arraycopy ( old ,     0  ,    new ,     0  ,    oldCapacity )  ;", "}", "return   new ;", "}", "METHOD_END"], "methodName": ["reallocateBuffer"], "fileName": "org.jbox2d.common.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "assert   newCapacity    >    oldCapacity ;", "assert    ( userSuppliedCapacity    =  =     0  )     |  |     ( newCapacity    <  =    userSuppliedCapacity )  ;", "if    (  (  (  ! deferred )     |  |     ( buffer    !  =    null )  )     &  &     ( userSuppliedCapacity    =  =     0  )  )     {", "buffer    =     . reallocateBuffer ( buffer ,    oldCapacity ,    newCapacity )  ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["reallocateBuffer"], "fileName": "org.jbox2d.common.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "assert   newCapacity    >    oldCapacity ;", "int [  ]    new    =    new   int [ newCapacity ]  ;", "if    ( old    !  =    null )     {", "System . arraycopy ( old ,     0  ,    new ,     0  ,    oldCapacity )  ;", "}", "return   new ;", "}", "METHOD_END"], "methodName": ["reallocateBuffer"], "fileName": "org.jbox2d.common.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "assert   newCapacity    >    oldCapacity ;", "assert    ( userSuppliedCapacity    =  =     0  )     |  |     ( newCapacity    <  =    userSuppliedCapacity )  ;", "if    (  (  (  ! deferred )     |  |     ( buffer    !  =    null )  )     &  &     ( userSuppliedCapacity    =  =     0  )  )     {", "buffer    =     . reallocateBuffer ( buffer ,    oldCapacity ,    newCapacity )  ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["reallocateBuffer"], "fileName": "org.jbox2d.common.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "assert   newCapacity    >    oldCapacity ;", "@ SuppressWarnings (  \" unchecked \"  )", "T [  ]    new    =     (  ( T [  ]  )     ( ArrayReflection . newInstance ( klass ,    newCapacity )  )  )  ;", "if    ( old    !  =    null )     {", "System . arraycopy ( old ,     0  ,    new ,     0  ,    oldCapacity )  ;", "}", "for    ( int   i    =    oldCapacity ;    i    <    newCapacity ;    i +  +  )     {", "try    {", "new [ i ]     =    ClassReflection . newInstance ( klass )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "return   new ;", "}", "METHOD_END"], "methodName": ["reallocateBuffer"], "fileName": "org.jbox2d.common.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "assert   newCapacity    >    oldCapacity ;", "assert    ( userSuppliedCapacity    =  =     0  )     |  |     ( newCapacity    <  =    userSuppliedCapacity )  ;", "if    (  (  (  ! deferred )     |  |     ( buffer    !  =    null )  )     &  &     ( userSuppliedCapacity    =  =     0  )  )     {", "buffer    =     . reallocateBuffer ( klass ,    buffer ,    oldCapacity ,    newCapacity )  ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["reallocateBuffer"], "fileName": "org.jbox2d.common.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "int   next    =    new _ first ;", "whe    ( next    !  =    first )     {", "T   temp    =    ray [ first ]  ;", "ray [ first ]     =    ray [ next ]  ;", "ray [ next ]     =    temp ;", "first +  +  ;", "next +  +  ;", "if    ( next    =  =    last )     {", "next    =    new _ first ;", "} else", "if    ( first    =  =    new _ first )     {", "new _ first    =    next ;", "}", "}", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "org.jbox2d.common.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "int   next    =    new _ first ;", "whe    ( next    !  =    first )     {", "float   temp    =    ray [ first ]  ;", "ray [ first ]     =    ray [ next ]  ;", "ray [ next ]     =    temp ;", "first +  +  ;", "next +  +  ;", "if    ( next    =  =    last )     {", "next    =    new _ first ;", "} else", "if    ( first    =  =    new _ first )     {", "new _ first    =    next ;", "}", "}", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "org.jbox2d.common.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "int   next    =    new _ first ;", "whe    ( next    !  =    first )     {", "int   temp    =    ray [ first ]  ;", "ray [ first ]     =    ray [ next ]  ;", "ray [ next ]     =    temp ;", "first +  +  ;", "next +  +  ;", "if    ( next    =  =    last )     {", "next    =    new _ first ;", "} else", "if    ( first    =  =    new _ first )     {", "new _ first    =    next ;", "}", "}", "}", "METHOD_END"], "methodName": ["rotate"], "fileName": "org.jbox2d.common.BufferUtils"}, {"methodBody": ["METHOD_START", "{", "x    =    r ;", "y    =    g ;", "z    =    b ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Color3f"}, {"methodBody": ["METHOD_START", "{", "x    =    argColor . x ;", "y    =    argColor . y ;", "z    =    argColor . z ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Color3f"}, {"methodBody": ["METHOD_START", "{", "return   new   Mat 2  2  ( MathUtils . abs ( ex . x )  ,    MathUtils . abs ( ey . x )  ,    MathUtils . abs ( ex . y )  ,    MathUtils . abs ( ey . y )  )  ;", "}", "METHOD_END"], "methodName": ["abs"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "return   R . abs (  )  ;", "}", "METHOD_END"], "methodName": ["abs"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "ex . absLocal (  )  ;", "ey . absLocal (  )  ;", "}", "METHOD_END"], "methodName": ["absLocal"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "out . ex . x    =    MathUtils . abs ( R . ex . x )  ;", "out . ex . y    =    MathUtils . abs ( R . ex . y )  ;", "out . ey . x    =    MathUtils . abs ( R . ey . x )  ;", "out . ey . y    =    MathUtils . abs ( R . ey . y )  ;", "}", "METHOD_END"], "methodName": ["absToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "Mat 2  2    m    =    new   Mat 2  2  (  )  ;", "m . ex . x    =     ( ex . x )     +     ( B . ex . x )  ;", "m . ex . y    =     ( ex . y )     +     ( B . ex . y )  ;", "m . ey . x    =     ( ey . x )     +     ( B . ey . x )  ;", "m . ey . y    =     ( ey . y )     +     ( B . ey . y )  ;", "return   m ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "ex . x    +  =    B . ex . x ;", "ex . y    +  =    B . ex . y ;", "ey . x    +  =    B . ey . x ;", "ey . y    +  =    B . ey . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addLocal"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "return   new   Mat 2  2  ( ex ,    ey )  ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "Mat 2  2    mat    =    new   Mat 2  2  (  )  ;", "final   float   c    =    MathUtils . cos ( angle )  ;", "final   float   s    =    MathUtils . sin ( angle )  ;", "mat . ex . x    =    c ;", "mat . ey . x    =     - s ;", "mat . ex . y    =    s ;", "mat . ey . y    =    c ;", "return   mat ;", "}", "METHOD_END"], "methodName": ["createRotationalTransform"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   c    =    MathUtils . cos ( angle )  ;", "final   float   s    =    MathUtils . sin ( angle )  ;", "out . ex . x    =    c ;", "out . ey . x    =     - s ;", "out . ex . y    =    s ;", "out . ey . y    =    c ;", "}", "METHOD_END"], "methodName": ["createRotationalTransform"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "Mat 2  2    mat    =    new   Mat 2  2  (  )  ;", "mat . ex . x    =    scale ;", "mat . ey . y    =    scale ;", "return   mat ;", "}", "METHOD_END"], "methodName": ["createScaleTransform"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "out . ex . x    =    scale ;", "out . ey . y    =    scale ;", "}", "METHOD_END"], "methodName": ["createScaleTransform"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . atan 2  ( ex . y ,    ex . x )  ;", "}", "METHOD_END"], "methodName": ["getAngle"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   a    =    ex . x ;", "final   float   b    =    ey . x ;", "final   float   c    =    ex . y ;", "final   float   d    =    ey . y ;", "final      B    =    new    (  )  ;", "float   det    =     ( a    *    d )     -     ( b    *    c )  ;", "if    ( det    !  =     0  )     {", "det    =     1  .  0 F    /    det ;", "}", "B . ex . x    =    det    *    d ;", "B . ey . x    =     (  - det )     *    b ;", "B . ex . y    =     (  - det )     *    c ;", "B . ey . y    =    det    *    a ;", "return   B ;", "}", "METHOD_END"], "methodName": ["invert"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   a    =    ex . x ;", "final   float   b    =    ey . x ;", "final   float   c    =    ex . y ;", "final   float   d    =    ey . y ;", "float   det    =     ( a    *    d )     -     ( b    *    c )  ;", "if    ( det    !  =     0  )     {", "det    =     1  .  0 F    /    det ;", "}", "ex . x    =    det    *    d ;", "ey . x    =     (  - det )     *    b ;", "ex . y    =     (  - det )     *    c ;", "ey . y    =    det    *    a ;", "return   this ;", "}", "METHOD_END"], "methodName": ["invertLocal"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   a    =    ex . x ;", "final   float   b    =    ey . x ;", "final   float   c    =    ex . y ;", "final   float   d    =    ey . y ;", "float   det    =     ( a    *    d )     -     ( b    *    c )  ;", "det    =     1  .  0 F    /    det ;", "out . ex . x    =    det    *    d ;", "out . ey . x    =     (  - det )     *    b ;", "out . ex . y    =     (  - det )     *    c ;", "out . ey . y    =    det    *    a ;", "}", "METHOD_END"], "methodName": ["invertToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   Mat 2  2    C    =    new   Mat 2  2  (  )  ;", "C . ex . x    =     (  ( ex . x )     *     ( R . ex . x )  )     +     (  ( ey . x )     *     ( R . ex . y )  )  ;", "C . ex . y    =     (  ( ex . y )     *     ( R . ex . x )  )     +     (  ( ey . y )     *     ( R . ex . y )  )  ;", "C . ey . x    =     (  ( ex . x )     *     ( R . ey . x )  )     +     (  ( ey . x )     *     ( R . ey . y )  )  ;", "C . ey . y    =     (  ( ex . y )     *     ( R . ey . x )  )     +     (  ( ey . y )     *     ( R . ey . y )  )  ;", "return   C ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   Mat 2  2    C    =    new   Mat 2  2  (  )  ;", "C . ex . x    =     (  ( A . ex . x )     *     ( B . ex . x )  )     +     (  ( A . ey . x )     *     ( B . ex . y )  )  ;", "C . ex . y    =     (  ( A . ex . y )     *     ( B . ex . x )  )     +     (  ( A . ey . y )     *     ( B . ex . y )  )  ;", "C . ey . x    =     (  ( A . ex . x )     *     ( B . ey . x )  )     +     (  ( A . ey . x )     *     ( B . ey . y )  )  ;", "C . ey . y    =     (  ( A . ex . y )     *     ( B . ey . x )  )     +     (  ( A . ey . y )     *     ( B . ey . y )  )  ;", "return   C ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  (  ( R . ex . x )     *     ( v . x )  )     +     (  ( R . ey . x )     *     ( v . y )  )  )  ,     (  (  ( R . ex . y )     *     ( v . x )  )     +     (  ( R . ey . y )     *     ( v . y )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  (  ( ex . x )     *     ( v . x )  )     +     (  ( ey . x )     *     ( v . y )  )  )  ,     (  (  ( ex . y )     *     ( v . x )  )     +     (  ( ey . y )     *     ( v . y )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "mulToOut ( R ,    this )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mulLocal"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   tempy 1     =     (  ( this . ex . y )     *     ( R . ex . x )  )     +     (  ( this . ey . y )     *     ( R . ex . y )  )  ;", "final   float   tempx 1     =     (  ( this . ex . x )     *     ( R . ex . x )  )     +     (  ( this . ey . x )     *     ( R . ex . y )  )  ;", "out . ex . x    =    tempx 1  ;", "out . ex . y    =    tempy 1  ;", "final   float   tempy 2     =     (  ( this . ex . y )     *     ( R . ey . x )  )     +     (  ( this . ey . y )     *     ( R . ey . y )  )  ;", "final   float   tempx 2     =     (  ( this . ex . x )     *     ( R . ey . x )  )     +     (  ( this . ey . x )     *     ( R . ey . y )  )  ;", "out . ey . x    =    tempx 2  ;", "out . ey . y    =    tempy 2  ;", "}", "METHOD_END"], "methodName": ["mulToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   tempy 1     =     (  ( A . ex . y )     *     ( B . ex . x )  )     +     (  ( A . ey . y )     *     ( B . ex . y )  )  ;", "final   float   tempx 1     =     (  ( A . ex . x )     *     ( B . ex . x )  )     +     (  ( A . ey . x )     *     ( B . ex . y )  )  ;", "final   float   tempy 2     =     (  ( A . ex . y )     *     ( B . ey . x )  )     +     (  ( A . ey . y )     *     ( B . ey . y )  )  ;", "final   float   tempx 2     =     (  ( A . ex . x )     *     ( B . ey . x )  )     +     (  ( A . ey . x )     *     ( B . ey . y )  )  ;", "out . ex . x    =    tempx 1  ;", "out . ex . y    =    tempy 1  ;", "out . ey . x    =    tempx 2  ;", "out . ey . y    =    tempy 2  ;", "}", "METHOD_END"], "methodName": ["mulToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   tempy    =     (  ( R . ex . y )     *     ( v . x )  )     +     (  ( R . ey . y )     *     ( v . y )  )  ;", "out . x    =     (  ( R . ex . x )     *     ( v . x )  )     +     (  ( R . ey . x )     *     ( v . y )  )  ;", "out . y    =    tempy ;", "}", "METHOD_END"], "methodName": ["mulToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   tempy    =     (  ( ex . y )     *     ( v . x )  )     +     (  ( ey . y )     *     ( v . y )  )  ;", "out . x    =     (  ( ex . x )     *     ( v . x )  )     +     (  ( ey . x )     *     ( v . y )  )  ;", "out . y    =    tempy ;", "}", "METHOD_END"], "methodName": ["mulToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    R ;", "assert   out    !  =     ( this )  ;", "out . ex . x    =     (  ( this . ex . x )     *     ( R . ex . x )  )     +     (  ( this . ey . x )     *     ( R . ex . y )  )  ;", "out . ex . y    =     (  ( this . ex . y )     *     ( R . ex . x )  )     +     (  ( this . ey . y )     *     ( R . ex . y )  )  ;", "out . ey . x    =     (  ( this . ex . x )     *     ( R . ey . x )  )     +     (  ( this . ey . x )     *     ( R . ey . y )  )  ;", "out . ey . y    =     (  ( this . ex . y )     *     ( R . ey . x )  )     +     (  ( this . ey . y )     *     ( R . ey . y )  )  ;", "}", "METHOD_END"], "methodName": ["mulToOutUnsafe"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    A ;", "assert   out    !  =    B ;", "out . ex . x    =     (  ( A . ex . x )     *     ( B . ex . x )  )     +     (  ( A . ey . x )     *     ( B . ex . y )  )  ;", "out . ex . y    =     (  ( A . ex . y )     *     ( B . ex . x )  )     +     (  ( A . ey . y )     *     ( B . ex . y )  )  ;", "out . ey . x    =     (  ( A . ex . x )     *     ( B . ey . x )  )     +     (  ( A . ey . x )     *     ( B . ey . y )  )  ;", "out . ey . y    =     (  ( A . ex . y )     *     ( B . ey . x )  )     +     (  ( A . ey . y )     *     ( B . ey . y )  )  ;", "}", "METHOD_END"], "methodName": ["mulToOutUnsafe"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "assert   v    !  =    out ;", "out . x    =     (  ( R . ex . x )     *     ( v . x )  )     +     (  ( R . ey . x )     *     ( v . y )  )  ;", "out . y    =     (  ( R . ex . y )     *     ( v . x )  )     +     (  ( R . ey . y )     *     ( v . y )  )  ;", "}", "METHOD_END"], "methodName": ["mulToOutUnsafe"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "assert   v    !  =    out ;", "out . x    =     (  ( ex . x )     *     ( v . x )  )     +     (  ( ey . x )     *     ( v . y )  )  ;", "out . y    =     (  ( ex . y )     *     ( v . x )  )     +     (  ( ey . y )     *     ( v . y )  )  ;", "}", "METHOD_END"], "methodName": ["mulToOutUnsafe"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   Mat 2  2    C    =    new   Mat 2  2  (  )  ;", "C . ex . x    =    Vec 2  . dot ( this . ex ,    B . ex )  ;", "C . ex . y    =    Vec 2  . dot ( this . ey ,    B . ex )  ;", "C . ey . x    =    Vec 2  . dot ( this . ex ,    B . ey )  ;", "C . ey . y    =    Vec 2  . dot ( this . ey ,    B . ey )  ;", "return   C ;", "}", "METHOD_END"], "methodName": ["mulTrans"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   Mat 2  2    C    =    new   Mat 2  2  (  )  ;", "C . ex . x    =     (  ( A . ex . x )     *     ( B . ex . x )  )     +     (  ( A . ex . y )     *     ( B . ex . y )  )  ;", "C . ex . y    =     (  ( A . ey . x )     *     ( B . ex . x )  )     +     (  ( A . ey . y )     *     ( B . ex . y )  )  ;", "C . ey . x    =     (  ( A . ex . x )     *     ( B . ey . x )  )     +     (  ( A . ex . y )     *     ( B . ey . y )  )  ;", "C . ey . y    =     (  ( A . ey . x )     *     ( B . ey . x )  )     +     (  ( A . ey . y )     *     ( B . ey . y )  )  ;", "return   C ;", "}", "METHOD_END"], "methodName": ["mulTrans"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  (  ( v . x )     *     ( R . ex . x )  )     +     (  ( v . y )     *     ( R . ex . y )  )  )  ,     (  (  ( v . x )     *     ( R . ey . x )  )     +     (  ( v . y )     *     ( R . ey . y )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mulTrans"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  (  ( v . x )     *     ( ex . x )  )     +     (  ( v . y )     *     ( ex . y )  )  )  ,     (  (  ( v . x )     *     ( ey . x )  )     +     (  ( v . y )     *     ( ey . y )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mulTrans"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "mulTransToOut ( B ,    this )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mulTransLocal"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   x 1     =     (  ( this . ex . x )     *     ( B . ex . x )  )     +     (  ( this . ex . y )     *     ( B . ex . y )  )  ;", "final   float   y 1     =     (  ( this . ey . x )     *     ( B . ex . x )  )     +     (  ( this . ey . y )     *     ( B . ex . y )  )  ;", "final   float   x 2     =     (  ( this . ex . x )     *     ( B . ey . x )  )     +     (  ( this . ex . y )     *     ( B . ey . y )  )  ;", "final   float   y 2     =     (  ( this . ey . x )     *     ( B . ey . x )  )     +     (  ( this . ey . y )     *     ( B . ey . y )  )  ;", "out . ex . x    =    x 1  ;", "out . ey . x    =    x 2  ;", "out . ex . y    =    y 1  ;", "out . ey . y    =    y 2  ;", "}", "METHOD_END"], "methodName": ["mulTransToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   x 1     =     (  ( A . ex . x )     *     ( B . ex . x )  )     +     (  ( A . ex . y )     *     ( B . ex . y )  )  ;", "final   float   y 1     =     (  ( A . ey . x )     *     ( B . ex . x )  )     +     (  ( A . ey . y )     *     ( B . ex . y )  )  ;", "final   float   x 2     =     (  ( A . ex . x )     *     ( B . ey . x )  )     +     (  ( A . ex . y )     *     ( B . ey . y )  )  ;", "final   float   y 2     =     (  ( A . ey . x )     *     ( B . ey . x )  )     +     (  ( A . ey . y )     *     ( B . ey . y )  )  ;", "out . ex . x    =    x 1  ;", "out . ex . y    =    y 1  ;", "out . ey . x    =    x 2  ;", "out . ey . y    =    y 2  ;", "}", "METHOD_END"], "methodName": ["mulTransToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "float   outx    =     (  ( v . x )     *     ( R . ex . x )  )     +     (  ( v . y )     *     ( R . ex . y )  )  ;", "out . y    =     (  ( v . x )     *     ( R . ey . x )  )     +     (  ( v . y )     *     ( R . ey . y )  )  ;", "out . x    =    outx ;", "}", "METHOD_END"], "methodName": ["mulTransToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   tempx    =     (  ( v . x )     *     ( ex . x )  )     +     (  ( v . y )     *     ( ex . y )  )  ;", "out . y    =     (  ( v . x )     *     ( ey . x )  )     +     (  ( v . y )     *     ( ey . y )  )  ;", "out . x    =    tempx ;", "}", "METHOD_END"], "methodName": ["mulTransToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "assert   B    !  =    out ;", "assert    ( this )     !  =    out ;", "out . ex . x    =     (  ( this . ex . x )     *     ( B . ex . x )  )     +     (  ( this . ex . y )     *     ( B . ex . y )  )  ;", "out . ey . x    =     (  ( this . ex . x )     *     ( B . ey . x )  )     +     (  ( this . ex . y )     *     ( B . ey . y )  )  ;", "out . ex . y    =     (  ( this . ey . x )     *     ( B . ex . x )  )     +     (  ( this . ey . y )     *     ( B . ex . y )  )  ;", "out . ey . y    =     (  ( this . ey . x )     *     ( B . ey . x )  )     +     (  ( this . ey . y )     *     ( B . ey . y )  )  ;", "}", "METHOD_END"], "methodName": ["mulTransToOutUnsafe"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "assert   A    !  =    out ;", "assert   B    !  =    out ;", "out . ex . x    =     (  ( A . ex . x )     *     ( B . ex . x )  )     +     (  ( A . ex . y )     *     ( B . ex . y )  )  ;", "out . ex . y    =     (  ( A . ey . x )     *     ( B . ex . x )  )     +     (  ( A . ey . y )     *     ( B . ex . y )  )  ;", "out . ey . x    =     (  ( A . ex . x )     *     ( B . ey . x )  )     +     (  ( A . ex . y )     *     ( B . ey . y )  )  ;", "out . ey . y    =     (  ( A . ey . x )     *     ( B . ey . x )  )     +     (  ( A . ey . y )     *     ( B . ey . y )  )  ;", "}", "METHOD_END"], "methodName": ["mulTransToOutUnsafe"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    v ;", "out . y    =     (  ( v . x )     *     ( R . ey . x )  )     +     (  ( v . y )     *     ( R . ey . y )  )  ;", "out . x    =     (  ( v . x )     *     ( R . ex . x )  )     +     (  ( v . y )     *     ( R . ex . y )  )  ;", "}", "METHOD_END"], "methodName": ["mulTransToOutUnsafe"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   c    =    MathUtils . cos ( angle )  ;", "final   float   s    =    MathUtils . sin ( angle )  ;", "ex . x    =    c ;", "ey . x    =     - s ;", "ex . y    =    s ;", "ey . y    =    c ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "ex . x    =    exx ;", "ex . y    =    exy ;", "ey . x    =    l 2 x ;", "ey . y    =    l 2 y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "ex . x    =    m . ex . x ;", "ex . y    =    m . ex . y ;", "ey . x    =    m . ey . x ;", "ey . y    =    m . ey . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "ex . x    =    c 1  . x ;", "ey . x    =    c 2  . x ;", "ex . y    =    c 1  . y ;", "ey . y    =    c 2  . y ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "ex . x    =     1  .  0 F ;", "ey . x    =     0  .  0 F ;", "ex . y    =     0  .  0 F ;", "ey . y    =     1  .  0 F ;", "}", "METHOD_END"], "methodName": ["setIdentity"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "ex . x    =     0  .  0 F ;", "ey . x    =     0  .  0 F ;", "ex . y    =     0  .  0 F ;", "ey . y    =     0  .  0 F ;", "}", "METHOD_END"], "methodName": ["setZero"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   a 1  1     =    ex . x ;", "final   float   a 1  2     =    ey . x ;", "final   float   a 2  1     =    ex . y ;", "final   float   a 2  2     =    ey . y ;", "float   det    =     ( a 1  1     *    a 2  2  )     -     ( a 1  2     *    a 2  1  )  ;", "if    ( det    !  =     0  .  0 F )     {", "det    =     1  .  0 F    /    det ;", "}", "final   Vec 2    x    =    new   Vec 2  (  ( det    *     (  ( a 2  2     *     ( b . x )  )     -     ( a 1  2     *     ( b . y )  )  )  )  ,     ( det    *     (  ( a 1  1     *     ( b . y )  )     -     ( a 2  1     *     ( b . x )  )  )  )  )  ;", "return   x ;", "}", "METHOD_END"], "methodName": ["solve"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "final   float   a 1  1     =    ex . x ;", "final   float   a 1  2     =    ey . x ;", "final   float   a 2  1     =    ex . y ;", "final   float   a 2  2     =    ey . y ;", "float   det    =     ( a 1  1     *    a 2  2  )     -     ( a 1  2     *    a 2  1  )  ;", "if    ( det    !  =     0  .  0 F )     {", "det    =     1  .  0 F    /    det ;", "}", "final   float   tempy    =    det    *     (  ( a 1  1     *     ( b . y )  )     -     ( a 2  1     *     ( b . x )  )  )  ;", "out . x    =    det    *     (  ( a 2  2     *     ( b . x )  )     -     ( a 1  2     *     ( b . y )  )  )  ;", "out . y    =    tempy ;", "}", "METHOD_END"], "methodName": ["solveToOut"], "fileName": "org.jbox2d.common.Mat22"}, {"methodBody": ["METHOD_START", "{", "float   a    =    ex . x ;", "float   b    =    ey . x ;", "float   c    =    ex . y ;", "float   d    =    ey . y ;", "float   det    =     ( a    *    d )     -     ( b    *    c )  ;", "if    ( det    !  =     0  .  0 F )     {", "det    =     1  .  0 F    /    det ;", "}", "M . ex . x    =    det    *    d ;", "M . ey . x    =     (  - det )     *    b ;", "M . ex . z    =     0  .  0 F ;", "M . ex . y    =     (  - det )     *    c ;", "M . ey . y    =    det    *    a ;", "M . ey . z    =     0  .  0 F ;", "M . ez . x    =     0  .  0 F ;", "M . ez . y    =     0  .  0 F ;", "M . ez . z    =     0  .  0 F ;", "}", "METHOD_END"], "methodName": ["getInverse22"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "float   bx    =     (  ( ey . y )     *     ( ez . z )  )     -     (  ( ey . z )     *     ( ez . y )  )  ;", "float   by    =     (  ( ey . z )     *     ( ez . x )  )     -     (  ( ey . x )     *     ( ez . z )  )  ;", "float   bz    =     (  ( ey . x )     *     ( ez . y )  )     -     (  ( ey . y )     *     ( ez . x )  )  ;", "float   det    =     (  (  ( ex . x )     *    bx )     +     (  ( ex . y )     *    by )  )     +     (  ( ex . z )     *    bz )  ;", "if    ( det    !  =     0  .  0 F )     {", "det    =     1  .  0 F    /    det ;", "}", "float   a 1  1     =    ex . x ;", "float   a 1  2     =    ey . x ;", "float   a 1  3     =    ez . x ;", "float   a 2  2     =    ey . y ;", "float   a 2  3     =    ez . y ;", "float   a 3  3     =    ez . z ;", "M . ex . x    =    det    *     (  ( a 2  2     *    a 3  3  )     -     ( a 2  3     *    a 2  3  )  )  ;", "M . ex . y    =    det    *     (  ( a 1  3     *    a 2  3  )     -     ( a 1  2     *    a 3  3  )  )  ;", "M . ex . z    =    det    *     (  ( a 1  2     *    a 2  3  )     -     ( a 1  3     *    a 2  2  )  )  ;", "M . ey . x    =    M . ex . y ;", "M . ey . y    =    det    *     (  ( a 1  1     *    a 3  3  )     -     ( a 1  3     *    a 1  3  )  )  ;", "M . ey . z    =    det    *     (  ( a 1  3     *    a 1  2  )     -     ( a 1  1     *    a 2  3  )  )  ;", "M . ez . x    =    M . ex . z ;", "M . ez . y    =    M . ey . z ;", "M . ez . z    =    det    *     (  ( a 1  1     *    a 2  2  )     -     ( a 1  2     *    a 1  2  )  )  ;", "}", "METHOD_END"], "methodName": ["getSymInverse33"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 3  (  (  (  (  (  ( v . x )     *     ( A . ex . x )  )     +     (  ( v . y )     *     ( A . ey . x )  )  )     +     ( v . z )  )     +     ( A . ez . x )  )  ,     (  (  (  ( v . x )     *     ( A . ex . y )  )     +     (  ( v . y )     *     ( A . ey . y )  )  )     +     (  ( v . z )     *     ( A . ez . y )  )  )  ,     (  (  (  ( v . x )     *     ( A . ex . z )  )     +     (  ( v . y )     *     ( A . ey . z )  )  )     +     (  ( v . z )     *     ( A . ez . z )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  (  ( A . ex . x )     *     ( v . x )  )     +     (  ( A . ey . x )     *     ( v . y )  )  )  ,     (  (  ( A . ex . y )     *     ( v . x )  )     +     (  ( A . ey . y )     *     ( v . y )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mul22"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "final   float   tempx    =     (  ( A . ex . x )     *     ( v . x )  )     +     (  ( A . ey . x )     *     ( v . y )  )  ;", "out . y    =     (  ( A . ex . y )     *     ( v . x )  )     +     (  ( A . ey . y )     *     ( v . y )  )  ;", "out . x    =    tempx ;", "}", "METHOD_END"], "methodName": ["mul22ToOut"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "assert   v    !  =    out ;", "out . y    =     (  ( A . ex . y )     *     ( v . x )  )     +     (  ( A . ey . y )     *     ( v . y )  )  ;", "out . x    =     (  ( A . ex . x )     *     ( v . x )  )     +     (  ( A . ey . x )     *     ( v . y )  )  ;", "}", "METHOD_END"], "methodName": ["mul22ToOutUnsafe"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "final   float   tempy    =     (  (  ( v . x )     *     ( A . ex . y )  )     +     (  ( v . y )     *     ( A . ey . y )  )  )     +     (  ( v . z )     *     ( A . ez . y )  )  ;", "final   float   tempz    =     (  (  ( v . x )     *     ( A . ex . z )  )     +     (  ( v . y )     *     ( A . ey . z )  )  )     +     (  ( v . z )     *     ( A . ez . z )  )  ;", "out . x    =     (  (  ( v . x )     *     ( A . ex . x )  )     +     (  ( v . y )     *     ( A . ey . x )  )  )     +     (  ( v . z )     *     ( A . ez . x )  )  ;", "out . y    =    tempy ;", "out . z    =    tempz ;", "}", "METHOD_END"], "methodName": ["mulToOut"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    v ;", "out . x    =     (  (  ( v . x )     *     ( A . ex . x )  )     +     (  ( v . y )     *     ( A . ey . x )  )  )     +     (  ( v . z )     *     ( A . ez . x )  )  ;", "out . y    =     (  (  ( v . x )     *     ( A . ex . y )  )     +     (  ( v . y )     *     ( A . ey . y )  )  )     +     (  ( v . z )     *     ( A . ez . y )  )  ;", "out . z    =     (  (  ( v . x )     *     ( A . ex . z )  )     +     (  ( v . y )     *     ( A . ey . z )  )  )     +     (  ( v . z )     *     ( A . ez . z )  )  ;", "}", "METHOD_END"], "methodName": ["mulToOutUnsafe"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "ex . x    =    exx ;", "ex . y    =    exy ;", "ex . z    =    exz ;", "ey . x    =    eyx ;", "ey . y    =    eyy ;", "ey . z    =    eyz ;", "ez . x    =    eyx ;", "ez . y    =    eyy ;", "ez . z    =    eyz ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "Vec 3    vec    =    mat . ex ;", "ex . x    =    vec . x ;", "ex . y    =    vec . y ;", "ex . z    =    vec . z ;", "Vec 3    vec 1     =    mat . ey ;", "ey . x    =    vec 1  . x ;", "ey . y    =    vec 1  . y ;", "ey . z    =    vec 1  . z ;", "Vec 3    vec 2     =    mat . ez ;", "ez . x    =    vec 2  . x ;", "ez . y    =    vec 2  . y ;", "ez . z    =    vec 2  . z ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "ex . x    =     (  ( float )     (  1  )  )  ;", "ex . y    =     (  ( float )     (  0  )  )  ;", "ex . z    =     (  ( float )     (  0  )  )  ;", "ey . x    =     (  ( float )     (  0  )  )  ;", "ey . y    =     (  ( float )     (  1  )  )  ;", "ey . z    =     (  ( float )     (  0  )  )  ;", "ez . x    =     (  ( float )     (  0  )  )  ;", "ez . y    =     (  ( float )     (  0  )  )  ;", "ez . z    =     (  ( float )     (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setIdentity"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "out . ex . x    =    scale ;", "out . ey . y    =    scale ;", "}", "METHOD_END"], "methodName": ["setScaleTransform"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "ex . setZero (  )  ;", "ey . setZero (  )  ;", "ez . setZero (  )  ;", "}", "METHOD_END"], "methodName": ["setZero"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "Vec 2    x    =    new   Vec 2  (  )  ;", "solve 2  2 ToOut ( b ,    x )  ;", "return   x ;", "}", "METHOD_END"], "methodName": ["solve22"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "final   float   a 1  1     =    ex . x ;", "final   float   a 1  2     =    ey . x ;", "final   float   a 2  1     =    ex . y ;", "final   float   a 2  2     =    ey . y ;", "float   det    =     ( a 1  1     *    a 2  2  )     -     ( a 1  2     *    a 2  1  )  ;", "if    ( det    !  =     0  .  0 F )     {", "det    =     1  .  0 F    /    det ;", "}", "out . x    =    det    *     (  ( a 2  2     *     ( b . x )  )     -     ( a 1  2     *     ( b . y )  )  )  ;", "out . y    =    det    *     (  ( a 1  1     *     ( b . y )  )     -     ( a 2  1     *     ( b . x )  )  )  ;", "}", "METHOD_END"], "methodName": ["solve22ToOut"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "Vec 3    x    =    new   Vec 3  (  )  ;", "solveToOut ( b ,    x )  ;", "return   x ;", "}", "METHOD_END"], "methodName": ["solve33"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "assert   b    !  =    out ;", "V 3 rossToOutUnsafe ( ey ,    ez ,    out )  ;", "float   det    =    V 3  . dot ( ex ,    out )  ;", "if    ( det    !  =     0  .  0 F )     {", "det    =     1  .  0 F    /    det ;", "}", "V 3 rossToOutUnsafe ( ey ,    ez ,    out )  ;", "final   float   x    =    det    *     ( V 3  . dot ( b ,    out )  )  ;", "V 3 rossToOutUnsafe ( b ,    ez ,    out )  ;", "final   float   y    =    det    *     ( V 3  . dot ( ex ,    out )  )  ;", "V 3 rossToOutUnsafe ( ey ,    b ,    out )  ;", "float   z    =    det    *     ( V 3  . dot ( ex ,    out )  )  ;", "out . x    =    x ;", "out . y    =    y ;", "out . z    =    z ;", "}", "METHOD_END"], "methodName": ["solve33ToOut"], "fileName": "org.jbox2d.common.Mat33"}, {"methodBody": ["METHOD_START", "{", "if    ( Settings . FAST _ ABS )     {", "return   x    >     0     ?    x    :     - x ;", "} else    {", "return   Strict . abs ( x )  ;", "}", "}", "METHOD_END"], "methodName": ["abs"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "int   y    =    x    >  >     3  1  ;", "return    ( x    ^    y )     -    y ;", "}", "METHOD_END"], "methodName": ["abs"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( Settings . FAST _ ATAN 2  )     {", "return    . fastAtan 2  ( y ,    x )  ;", "} else    {", "return    (  ( float )     ( StrictMath . atan 2  ( y ,    x )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["atan2"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( Settings . FAST _ CEIL )     {", "return    . fastCeil ( x )  ;", "} else    {", "return    (  ( int )     ( StrictMath . ceil ( x )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["ceil"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "int   pow 2     =     1  ;", "whe    ( pow 2     <    x )     {", "pow 2     <  <  =     1  ;", "}", "return   pow 2  ;", "}", "METHOD_END"], "methodName": ["ceilPowerOf2"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . max ( low ,    MathUtils . min ( a ,    high )  )  ;", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "fil   Vec 2    mi =    w   Vec 2  (  )  ;", "mix    =     (  ( a . x )     <     ( high . x )  )     ?    a . x    :    high . x ;", "miy    =     (  ( a . y )     <     ( high . y )  )     ?    a . y    :    high . y ;", "mix    =     (  ( low . x )     >     ( mix )  )     ?    low . x    :    mix ;", "miy    =     (  ( low . y )     >     ( miy )  )     ?    low . y    :    miy ;", "returmi", "}", "METHOD_END"], "methodName": ["clamp"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "dest . x    =     (  ( a . x )     <     ( high . x )  )     ?    a . x    :    high . x ;", "dest . y    =     (  ( a . y )     <     ( high . y )  )     ?    a . y    :    high . y ;", "dest . x    =     (  ( low . x )     >     ( dest . x )  )     ?    low . x    :    dest . x ;", "dest . y    =     (  ( low . y )     >     ( dest . y )  )     ?    low . y    :    dest . y ;", "}", "METHOD_END"], "methodName": ["clampToOut"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( Settings . SINCOS _ LUT _ ENABLED )     {", "return    . sinLUT (  (  (  . HALF _ PI )     -    x )  )  ;", "} else    {", "return    (  ( float )     ( StrictMath . cos ( x )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cos"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . sqrt ( MathUtils . distanceSquared ( v 1  ,    v 2  )  )  ;", "}", "METHOD_END"], "methodName": ["distance"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "float   dx    =     ( v 1  . x )     -     ( v 2  . x )  ;", "float   dy    =     ( v 1  . y )     -     ( v 2  . y )  ;", "return    ( dx    *    dx )     +     ( dy    *    dy )  ;", "}", "METHOD_END"], "methodName": ["distanceSquared"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   x    >     0     ?    x    :     - x ;", "}", "METHOD_END"], "methodName": ["fastAbs"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( x    =  =     0  .  0 F )     {", "if    ( y    >     0  .  0 F )", "return    . HALF _ PI ;", "if    ( y    =  =     0  .  0 F )", "return    0  .  0 F ;", "return    -  (  . HALF _ PI )  ;", "}", "float   atan ;", "final   float   z    =    y    /    x ;", "if    (  (  . abs ( z )  )     <     1  .  0 F )     {", "atan    =    z    /     (  1  .  0 F    +     (  (  0  .  2  8 F    *    z )     *    z )  )  ;", "if    ( x    <     0  .  0 F )     {", "if    ( y    <     0  .  0 F )", "return   atan    -     (  . PI )  ;", "return   atan    +     (  . PI )  ;", "}", "} else    {", "atan    =     (  . HALF _ PI )     -     ( z    /     (  ( z    *    z )     +     0  .  2  8 F )  )  ;", "if    ( y    <     0  .  0 F )", "return   atan    -     (  . PI )  ;", "}", "return   atan ;", "}", "METHOD_END"], "methodName": ["fastAtan2"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "int   y    =     (  ( int )     ( x )  )  ;", "if    ( x    >    y )     {", "return   y    +     1  ;", "}", "return   y ;", "}", "METHOD_END"], "methodName": ["fastCeil"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "int   y    =     (  ( int )     ( x )  )  ;", "if    ( x    <    y )     {", "return   y    -     1  ;", "}", "return   y ;", "}", "METHOD_END"], "methodName": ["fastFloor"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( Settings . FAST _ FLOOR )     {", "return    . fastFloor ( x )  ;", "} else    {", "return    (  ( int )     ( StrictMath . floor ( x )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["floor"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( x    >     0  )     &  &     (  ( x    &     ( x    -     1  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isPowerOfTwo"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "final   float   mult    =     ( val    -    fromMin )     /     ( fromMax    -    fromMin )  ;", "final   float   res    =    toMin    +     ( mult    *     ( toMax    -    toMin )  )  ;", "return   res ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   a    >    b    ?    a    :    b ;", "}", "METHOD_END"], "methodName": ["max"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   a    >    b    ?    a    :    b ;", "}", "METHOD_END"], "methodName": ["max"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   a    <    b    ?    a    :    b ;", "}", "METHOD_END"], "methodName": ["min"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   a    <    b    ?    a    :    b ;", "}", "METHOD_END"], "methodName": ["min"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "x    |  =    x    >  >     1  ;", "x    |  =    x    >  >     2  ;", "x    |  =    x    >  >     4  ;", "x    |  =    x    >  >     8  ;", "x    |  =    x    >  >     1  6  ;", "return   x    +     1  ;", "}", "METHOD_END"], "methodName": ["nextPowerOfTwo"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( Settings . FAST _ POW )     {", "return   Platform . fastPow ( a ,    b )  ;", "} else    {", "return    (  ( float )     ( StrictMath . pow ( a ,    b )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pow"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( float )     ( Math . random (  )  )  )     *     ( argHigh    -    argLow )  )     +    argLow ;", "}", "METHOD_END"], "methodName": ["randomFloat"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( r . nextFloat (  )  )     *     ( argHigh    -    argLow )  )     +    argLow ;", "}", "METHOD_END"], "methodName": ["randomFloat"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "theta    %  =    MathUtils . TWOPI ;", "if    (  ( MathUtils . abs ( theta )  )     >     ( MathUtils . PI )  )     {", "theta    =    theta    -     ( MathUtils . TWOPI )  ;", "}", "if    (  ( MathUtils . abs ( theta )  )     >     ( MathUtils . HALF _ PI )  )     {", "theta    =     ( MathUtils . PI )     -    theta ;", "}", "return   theta ;", "}", "METHOD_END"], "methodName": ["reduceAngle"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( Settings . FAST _ ROUND )     {", "return    . floor (  ( x    +     0  .  5 F )  )  ;", "} else    {", "return   StrictMath . round ( x )  ;", "}", "}", "METHOD_END"], "methodName": ["round"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( Settings . SINCOS _ LUT _ ENABLED )     {", "return    . sinLUT ( x )  ;", "} else    {", "return    (  ( float )     ( StrictMath . sin ( x )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sin"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "x    %  =    MathUtils . TWOPI ;", "if    ( x    <     0  )     {", "x    +  =    MathUtils . TWOPI ;", "}", "if    ( Settings . SINCOS _ LUT _ LERP )     {", "x    /  =    Settings . SINCOS _ LUT _ PRECISION ;", "final   int   index    =     (  ( int )     ( x )  )  ;", "if    ( index    !  =     0  )     {", "x    %  =    index ;", "}", "if    ( index    =  =     (  ( Settings . SINCOS _ LUT _ LENGTH )     -     1  )  )     {", "return    (  (  1     -    x )     *     ( MathUtils . sinLUT [ index ]  )  )     +     ( x    *     ( MathUtils . sinLUT [  0  ]  )  )  ;", "} else    {", "return    (  (  1     -    x )     *     ( MathUtils . sinLUT [ index ]  )  )     +     ( x    *     ( MathUtils . sinLUT [  ( index    +     1  )  ]  )  )  ;", "}", "} else    {", "return   MathUtils . sinLUT [  (  ( MathUtils . round (  ( x    /     ( Settings . SINCOS _ LUT _ PRECISION )  )  )  )     %     ( Settings . SINCOS _ LUT _ LENGTH )  )  ]  ;", "}", "}", "METHOD_END"], "methodName": ["sinLUT"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( StrictMath . sqrt ( x )  )  )  ;", "}", "METHOD_END"], "methodName": ["sqrt"], "fileName": "org.jbox2d.common.MathUtils"}, {"methodBody": ["METHOD_START", "{", "return   box . center ;", "}", "METHOD_END"], "methodName": ["getCenter"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "return   box . extents ;", "}", "METHOD_END"], "methodName": ["getExtents"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "world . x    =     ( screen . x )     -     ( box . extents . x )  ;", "world . y    =     ( screen . y )     -     ( box . extents . y )  ;", "if    ( yFlip )     {", "yFlipMat . mulToOut ( world ,    world )  ;", "}", "box . R . invertToOut ( inv 2  )  ;", "inv 2  . mulToOut ( world ,    world )  ;", "world . x    +  =    box . center . x ;", "world . y    +  =    box . center . y ;", "}", "METHOD_END"], "methodName": ["getScreenToWorld"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "box . R . invertToOut ( inv )  ;", "inv . mulToOut ( screen ,    world )  ;", "if    ( yFlip )     {", "yFlipMat . mulToOut ( world ,    world )  ;", "}", "}", "METHOD_END"], "methodName": ["getScreenVectorToWorld"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "return   box . R ;", "}", "METHOD_END"], "methodName": ["getTransform"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "screen . x    =     ( world . x )     -     ( box . center . x )  ;", "screen . y    =     ( world . y )     -     ( box . center . y )  ;", "box . R . mulToOut ( screen ,    screen )  ;", "if    ( yFlip )     {", "yFlipMat . mulToOut ( screen ,    screen )  ;", "}", "screen . x    +  =    box . extents . x ;", "screen . y    +  =    box . extents . y ;", "}", "METHOD_END"], "methodName": ["getWorldToScreen"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "box . R . mulToOut ( world ,    screen )  ;", "if    ( yFlip )     {", "yFlipMat . mulToOut ( screen ,    screen )  ;", "}", "}", "METHOD_END"], "methodName": ["getWorldVectorToScreen"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "return   yFlip ;", "}", "METHOD_END"], "methodName": ["isYFlip"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "box . center . set ( vpt . box . center )  ;", "box . extents . set ( vpt . box . extents )  ;", "box . R . set ( vpt . box . R )  ;", "yFlip    =    vpt . yFlip ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "box . center . set ( x ,    y )  ;", "Mat 2  2  . createScale ( scale ,    box . R )  ;", "}", "METHOD_END"], "methodName": ["setCamera"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "box . center . set ( x ,    y )  ;", "}", "METHOD_END"], "methodName": ["setCenter"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "box . center . set ( argPos )  ;", "}", "METHOD_END"], "methodName": ["setCenter"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "box . extents . set ( halfWidth ,    halfHeight )  ;", "}", "METHOD_END"], "methodName": ["setExtents"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "box . extents . set ( argExtents )  ;", "}", "METHOD_END"], "methodName": ["setExtents"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "box . R . set ( transform )  ;", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "this . yFlip    =    yFlip ;", "}", "METHOD_END"], "methodName": ["setYFlip"], "fileName": "org.jbox2d.common.OBBViewportTransform"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( Math . pow ( a ,    b )  )  )  ;", "}", "METHOD_END"], "methodName": ["fastPow"], "fileName": "org.jbox2d.common.PlatformMathUtils"}, {"methodBody": ["METHOD_START", "{", "lambda    =    argOther . lambda ;", "normal . set ( argOther . normal )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.RaycastResult"}, {"methodBody": ["METHOD_START", "{", "Rot   copy    =    new   Rot (  )  ;", "copy . s    =    s ;", "copy . c    =    c ;", "return   copy ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . atan 2  ( s ,    c )  ;", "}", "METHOD_END"], "methodName": ["getAngle"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "return   c ;", "}", "METHOD_END"], "methodName": ["getCos"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "return   s ;", "}", "METHOD_END"], "methodName": ["getSin"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "xAxis . set ( c ,    s )  ;", "}", "METHOD_END"], "methodName": ["getXAxis"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "yAxis . set (  (  -  ( s )  )  ,    c )  ;", "}", "METHOD_END"], "methodName": ["getYAxis"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "float   tempc    =     (  ( q . c )     *     ( r . c )  )     -     (  ( q . s )     *     ( r . s )  )  ;", "out . s    =     (  ( q . s )     *     ( r . c )  )     +     (  ( q . c )     *     ( r . s )  )  ;", "out . c    =    tempc ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "float   tempy    =     (  ( q . s )     *     ( v . x )  )     +     (  ( q . c )     *     ( v . y )  )  ;", "out . x    =     (  ( q . c )     *     ( v . x )  )     -     (  ( q . s )     *     ( v . y )  )  ;", "out . y    =    tempy ;", "}", "METHOD_END"], "methodName": ["mulToOut"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "out . x    =     (  ( q . c )     *     ( v . x )  )     -     (  ( q . s )     *     ( v . y )  )  ;", "out . y    =     (  ( q . s )     *     ( v . x )  )     +     (  ( q . c )     *     ( v . y )  )  ;", "}", "METHOD_END"], "methodName": ["mulToOutUnsafe"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "final   float   tempc    =     (  ( q . c )     *     ( r . c )  )     +     (  ( q . s )     *     ( r . s )  )  ;", "out . s    =     (  ( q . c )     *     ( r . s )  )     -     (  ( q . s )     *     ( r . c )  )  ;", "out . c    =    tempc ;", "}", "METHOD_END"], "methodName": ["mulTrans"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "final   float   tempy    =     (  (  -  ( q . s )  )     *     ( v . x )  )     +     (  ( q . c )     *     ( v . y )  )  ;", "out . x    =     (  ( q . c )     *     ( v . x )  )     +     (  ( q . s )     *     ( v . y )  )  ;", "out . y    =    tempy ;", "}", "METHOD_END"], "methodName": ["mulTrans"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "out . s    =     (  ( q . c )     *     ( r . s )  )     -     (  ( q . s )     *     ( r . c )  )  ;", "out . c    =     (  ( q . c )     *     ( r . c )  )     +     (  ( q . s )     *     ( r . s )  )  ;", "}", "METHOD_END"], "methodName": ["mulTransUnsafe"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "out . x    =     (  ( q . c )     *     ( v . x )  )     +     (  ( q . s )     *     ( v . y )  )  ;", "out . y    =     (  (  -  ( q . s )  )     *     ( v . x )  )     +     (  ( q . c )     *     ( v . y )  )  ;", "}", "METHOD_END"], "methodName": ["mulTransUnsafe"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "assert   r    !  =    out ;", "assert   q    !  =    out ;", "out . s    =     (  ( q . s )     *     ( r )  )     +     (  ( q )     *     ( r . s )  )  ;", "out    =     (  ( q )     *     ( r )  )     -     (  ( q . s )     *     ( r . s )  )  ;", "}", "METHOD_END"], "methodName": ["mulUnsafe"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "s    =    MathUtils . sin ( angle )  ;", "c    =    MathUtilss ( angle )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "s    =    other . s ;", "c    =    other . c ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "s    =     0  ;", "c    =     1  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIdentity"], "fileName": "org.jbox2d.common.Rot"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . sqrt (  ( friction 1     *    friction 2  )  )  ;", "}", "METHOD_END"], "methodName": ["mixFriction"], "fileName": "org.jbox2d.common.Settings"}, {"methodBody": ["METHOD_START", "{", "return   restitution 1     >    restitution 2     ?    restitution 1     :    restitution 2  ;", "}", "METHOD_END"], "methodName": ["mixRestitution"], "fileName": "org.jbox2d.common.Settings"}, {"methodBody": ["METHOD_START", "{", "assert    ( alpha 0  )     <     1  .  0 F ;", "float   beta    =     ( alpha    -     ( alpha 0  )  )     /     (  1  .  0 F    -     ( alpha 0  )  )  ;", "c 0  . x    +  =    beta    *     (  ( c . x )     -     ( c 0  . x )  )  ;", "c 0  . y    +  =    beta    *     (  ( c . y )     -     ( c 0  . y )  )  ;", "a 0     +  =    beta    *     (  ( a )     -     ( a 0  )  )  ;", "alpha 0     =    alpha ;", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "org.jbox2d.common.Sweep"}, {"methodBody": ["METHOD_START", "{", "assert   xf    !  =    null ;", "xf . p . x    =     (  (  1  .  0 F    -    beta )     *     0  . x )  )     +     ( beta    *     . x )  )  ;", "xf . p . y    =     (  (  1  .  0 F    -    beta )     *     0  . y )  )     +     ( beta    *     . y )  )  ;", "float   angle    =     (  (  1  .  0 F    -    beta )     *     ( a 0  )  )     +     ( beta    *     ( a )  )  ;", "xf . q . set ( angle )  ;", "final   Rot   q    =    xf . q ;", "xf . p . x    -  =     (  ( q )     *     ( lalCenter . x )  )     -     (  ( q . s )     *     ( lalCenter . y )  )  ;", "xf . p . y    -  =     (  ( q . s )     *     ( lalCenter . x )  )     +     (  ( q )     *     ( lalCenter . y )  )  ;", "}", "METHOD_END"], "methodName": ["getTransform"], "fileName": "org.jbox2d.common.Sweep"}, {"methodBody": ["METHOD_START", "{", "float   d    =     ( MathUtils . TWOPI )     *     ( MathUtils . floor (  (  ( a 0  )     /     ( MathUtils . TWOPI )  )  )  )  ;", "a 0     -  =    d ;", "a    -  =    d ;", "}", "METHOD_END"], "methodName": ["normalize"], "fileName": "org.jbox2d.common.Sweep"}, {"methodBody": ["METHOD_START", "{", "lalCenter . set ( other . lalCenter )  ;", "0  . set ( other 0  )  ;", ". set ( other )  ;", "a 0     =    other . a 0  ;", "a    =    other . a ;", "alpha 0     =    other . alpha 0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Sweep"}, {"methodBody": ["METHOD_START", "{", "String   s    =     (  \" Sweep :  \\ nlocalCenter :     \"     +     ( localCenter )  )     +     \"  \\ n \"  ;", "s    +  =     (  (  (  \" c 0  :     \"     +     ( c 0  )  )     +     \"  ,    c :     \"  )     +     ( c )  )     +     \"  \\ n \"  ;", "s    +  =     (  (  (  \" a 0  :     \"     +     ( a 0  )  )     +     \"  ,    a :     \"  )     +     ( a )  )     +     \"  \\ n \"  ;", "s    +  =     \" alpha 0  :     \"     +     ( alpha 0  )  ;", "return   s ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jbox2d.common.Sweep"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     (  ( Timer . now (  )  )     -     ( resetMillis )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMilliseconds"], "fileName": "org.jbox2d.common.Timer"}, {"methodBody": ["METHOD_START", "{", "resetMillis    =    Timer . now (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.jbox2d.common.Timer"}, {"methodBody": ["METHOD_START", "{", "Transform   C    =    new   Transform (  )  ;", "Rot . mulUnsafe ( A . q ,    B . q ,    C . q )  ;", "Rot . mulToOutUnsafe ( A . q ,    B . p ,    C . p )  ;", "C . p . addLocal ( A . p )  ;", "return   C ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  (  (  ( T . q . c )     *     ( v . x )  )     -     (  ( T . q . s )     *     ( v . y )  )  )     +     ( T . p . x )  )  ,     (  (  (  ( T . q . s )     *     ( v . x )  )     +     (  ( T . q . c )     *     ( v . y )  )  )     +     ( T . p . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    A ;", "Rot . mul ( A . q ,    B . q ,    out . q )  ;", "Rot . mulToOut ( A . q ,    B . p ,    out . p )  ;", "out . p . addLocal ( A . p )  ;", "}", "METHOD_END"], "methodName": ["mulToOut"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "final   float   tempy    =     (  (  ( T . q . s )     *     ( v . x )  )     +     (  ( T . q . c )     *     ( v . y )  )  )     +     ( T . p . y )  ;", "out . x    =     (  (  ( T . q . c )     *     ( v . x )  )     -     (  ( T . q . s )     *     ( v . y )  )  )     +     ( T . p . x )  ;", "out . y    =    tempy ;", "}", "METHOD_END"], "methodName": ["mulToOut"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    B ;", "assert   out    !  =    A ;", "Rot . mulUafe ( A . q ,    B . q ,    out . q )  ;", "Rot . mulToOutUafe ( A . q ,    B . p ,    out . p )  ;", "out . p . addLocal ( A . p )  ;", "}", "METHOD_END"], "methodName": ["mulToOutUnsafe"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "assert   v    !  =    out ;", "out . x    =     (  (  ( T . q )     *     ( v . x )  )     -     (  ( T . q . s )     *     ( v . y )  )  )     +     ( T . p . x )  ;", "out . y    =     (  (  ( T . q . s )     *     ( v . x )  )     +     (  ( T . q )     *     ( v . y )  )  )     +     ( T . p . y )  ;", "}", "METHOD_END"], "methodName": ["mulToOutUnsafe"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "Transform   C    =    new   Transform (  )  ;", "Rot . mulTransUnsafe ( A . q ,    B . q ,    C . q )  ;", "Transform . pool . set ( B . p )  . subLocal ( A . p )  ;", "Rot . mulTransUnsafe ( A . q ,    Transform . pool ,    C . p )  ;", "return   C ;", "}", "METHOD_END"], "methodName": ["mulTrans"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "final   float   px    =     ( v . x )     -     ( T . p . x )  ;", "final   float   py    =     ( v . y )     -     ( T . p . y )  ;", "return   new   V 2  (  (  (  ( T . q )     *    px )     +     (  ( T . q . s )     *    py )  )  ,     (  (  (  -  ( T . q . s )  )     *    px )     +     (  ( T . q )     *    py )  )  )  ;", "}", "METHOD_END"], "methodName": ["mulTrans"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    A ;", "Rot . mulTrans ( A . q ,    B . q ,    out . q )  ;", ". pool . set ( B . p )  . subLocal ( A . p )  ;", "Rot . mulTrans ( A . q ,     . pool ,    out . p )  ;", "}", "METHOD_END"], "methodName": ["mulTransToOut"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "final   float   px    =     ( v . x )     -     ( T . p . x )  ;", "final   float   py    =     ( v . y )     -     ( T . p . y )  ;", "final   float   tempy    =     (  (  -  ( T . q . s )  )     *    px )     +     (  ( T . q )     *    py )  ;", "out . x    =     (  ( T . q )     *    px )     +     (  ( T . q . s )     *    py )  ;", "out . y    =    tempy ;", "}", "METHOD_END"], "methodName": ["mulTransToOut"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    A ;", "assert   out    !  =    B ;", "Rot . mulTransUnsafe ( A . q ,    B . q ,    out . q )  ;", ". pool . set ( B . p )  . subLocal ( A . p )  ;", "Rot . mulTransUnsafe ( A . q ,     . pool ,    out . p )  ;", "}", "METHOD_END"], "methodName": ["mulTransToOutUnsafe"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "assert   v    !  =    out ;", "final   float   px    =     ( v . x )     -     ( T . p . x )  ;", "final   float   py    =     ( v . y )     -     ( T . p . y )  ;", "out . x    =     (  ( T . q )     *    px )     +     (  ( T . q . s )     *    py )  ;", "out . y    =     (  (  -  ( T . q . s )  )     *    px )     +     (  ( T . q )     *    py )  ;", "}", "METHOD_END"], "methodName": ["mulTransToOutUnsafe"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "p . set ( xf . p )  ;", "q . set ( xf . q )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "this . p . set ( p )  ;", "q . set ( gle )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "p . setZero (  )  ;", "q . setIdentity (  )  ;", "}", "METHOD_END"], "methodName": ["setIdentity"], "fileName": "org.jbox2d.common.Transform"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  ( MathUtils . abs ( x )  ,    MathUtils . abs ( y )  )  ;", "}", "METHOD_END"], "methodName": ["abs"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  ( MathUtils . abs ( a . x )  ,    MathUtils . abs ( a . y )  )  ;", "}", "METHOD_END"], "methodName": ["abs"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "x    =    MathUtils . abs ( x )  ;", "y    =    MathUtils . abs ( y )  ;", "}", "METHOD_END"], "methodName": ["absLocal"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "out . x    =    MathUtils . abs ( a . x )  ;", "out . y    =    MathUtils . abs ( a . y )  ;", "}", "METHOD_END"], "methodName": ["absToOut"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  ( x )     +     ( v . x )  )  ,     (  ( y )     +     ( v . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "this . x    +  =    x ;", "this . y    +  =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addLocal"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "x    +  =    v . x ;", "y    +  =    v . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addLocal"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  ( x ,    y )  ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  (  - s )     *     ( a . y )  )  ,     ( s    *     ( a . x )  )  )  ;", "}", "METHOD_END"], "methodName": ["cross"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  ( s    *     ( a . y )  )  ,     (  (  - s )     *     ( a . x )  )  )  ;", "}", "METHOD_END"], "methodName": ["cross"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( a . x )     *     ( b . y )  )     -     (  ( a . y )     *     ( b . x )  )  ;", "}", "METHOD_END"], "methodName": ["cross"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "final   float   tempY    =    s    *     ( a . x )  ;", "out . x    =     (  - s )     *     ( a . y )  ;", "out . y    =    tempY ;", "}", "METHOD_END"], "methodName": ["crossToOut"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "final   float   tempy    =     (  - s )     *     ( a . x )  ;", "out . x    =    s    *     ( a . y )  ;", "out . y    =    tempy ;", "}", "METHOD_END"], "methodName": ["crossToOut"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    a ;", "out . x    =     (  - s )     *     ( a . y )  ;", "out . y    =    s    *     ( a . x )  ;", "}", "METHOD_END"], "methodName": ["crossToOutUnsafe"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    a ;", "out . x    =    s    *     ( a . y )  ;", "out . y    =     (  - s )     *     ( a . x )  ;", "}", "METHOD_END"], "methodName": ["crossToOutUnsafe"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( a . x )     *     ( b . x )  )     +     (  ( a . y )     *     ( b . y )  )  ;", "}", "METHOD_END"], "methodName": ["dot"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  !  ( Float . isNaN ( x )  )  )     &  &     (  !  ( Float . isInfinite ( x )  )  )  )     &  &     (  !  ( Float . isNaN ( y )  )  )  )     &  &     (  !  ( Float . isInfinite ( y )  )  )  ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . sqrt (  (  (  ( x )     *     ( x )  )     +     (  ( y )     *     ( y )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["length"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return    (  ( x )     *     ( x )  )     +     (  ( y )     *     ( y )  )  ;", "}", "METHOD_END"], "methodName": ["lengthSquared"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  ( a . x )     >     ( b . x )     ?    a . x    :    b . x )  ,     (  ( a . y )     >     ( b . y )     ?    a . y    :    b . y )  )  ;", "}", "METHOD_END"], "methodName": ["max"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "out . x    =     (  ( a . x )     >     ( b . x )  )     ?    a . x    :    b . x ;", "out . y    =     (  ( a . y )     >     ( b . y )  )     ?    a . y    :    b . y ;", "}", "METHOD_END"], "methodName": ["maxToOut"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  ( a . x )     <     ( b . x )     ?    a . x    :    b . x )  ,     (  ( a . y )     <     ( b . y )     ?    a . y    :    b . y )  )  ;", "}", "METHOD_END"], "methodName": ["min"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "out . x    =     (  ( a . x )     <     ( b . x )  )     ?    a . x    :    b . x ;", "out . y    =     (  ( a . y )     <     ( b . y )  )     ?    a . y    :    b . y ;", "}", "METHOD_END"], "methodName": ["minToOut"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  ( x )     *    a )  ,     (  ( y )     *    a )  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "x    *  =    a ;", "y    *  =    a ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mulLocal"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  -  ( x )  )  ,     (  -  ( y )  )  )  ;", "}", "METHOD_END"], "methodName": ["negate"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "x    =     -  ( x )  ;", "y    =     -  ( y )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["negateLocal"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "out . x    =     -  ( a . x )  ;", "out . y    =     -  ( a . y )  ;", "}", "METHOD_END"], "methodName": ["negateToOut"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "float   length    =    length (  )  ;", "if    ( length    <     ( Settings . EPSILON )  )     {", "return    0  .  0 F ;", "}", "float   invLength    =     1  .  0 F    /    length ;", "x    *  =    invLength ;", "y    *  =    invLength ;", "return   length ;", "}", "METHOD_END"], "methodName": ["normalize"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "this . x    =    x ;", "this . y    =    y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "this . x    =    v . x ;", "this . y    =    v . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "x    =     0  .  0 F ;", "y    =     0  .  0 F ;", "}", "METHOD_END"], "methodName": ["setZero"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  -  ( y )  )  ,    x )  ;", "}", "METHOD_END"], "methodName": ["skew"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "out . x    =     -  ( y )  ;", "out . y    =    x ;", "}", "METHOD_END"], "methodName": ["skew"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 2  (  (  ( x )     -     ( v . x )  )  ,     (  ( y )     -     ( v . y )  )  )  ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "x    -  =    v . x ;", "y    -  =    v . y ;", "return   this ;", "}", "METHOD_END"], "methodName": ["subLocal"], "fileName": "org.jbox2d.common.Vec2"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 3  (  (  ( x )     +     ( argVec . x )  )  ,     (  ( y )     +     ( argVec . y )  )  ,     (  ( z )     +     ( argVec . z )  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "x    +  =    argVec . x ;", "y    +  =    argVec . y ;", "z    +  =    argVec . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addLocal"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 3  ( this )  ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 3  (  (  (  ( a . y )     *     ( b . z )  )     -     (  ( a . z )     *     ( b . y )  )  )  ,     (  (  ( a . z )     *     ( b . x )  )     -     (  ( a . x )     *     ( b . z )  )  )  ,     (  (  ( a . x )     *     ( b . y )  )     -     (  ( a . y )     *     ( b . x )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["cross"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "final   float   tempy    =     (  ( a . z )     *     ( b . x )  )     -     (  ( a . x )     *     ( b . z )  )  ;", "final   float   tempz    =     (  ( a . x )     *     ( b . y )  )     -     (  ( a . y )     *     ( b . x )  )  ;", "out . x    =     (  ( a . y )     *     ( b . z )  )     -     (  ( a . z )     *     ( b . y )  )  ;", "out . y    =    tempy ;", "out . z    =    tempz ;", "}", "METHOD_END"], "methodName": ["crossToOut"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "assert   out    !  =    b ;", "assert   out    !  =    a ;", "out . x    =     (  ( a . y )     *     ( b . z )  )     -     (  ( a . z )     *     ( b . y )  )  ;", "out . y    =     (  ( a . z )     *     ( b . x )  )     -     (  ( a . x )     *     ( b . z )  )  ;", "out . z    =     (  ( a . x )     *     ( b . y )  )     -     (  ( a . y )     *     ( b . x )  )  ;", "}", "METHOD_END"], "methodName": ["crossToOutUnsafe"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( a . x )     *     ( b . x )  )     +     (  ( a . y )     *     ( b . y )  )  )     +     (  ( a . z )     *     ( b . z )  )  ;", "}", "METHOD_END"], "methodName": ["dot"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 3  (  (  ( x )     *    argScalar )  ,     (  ( y )     *    argScalar )  ,     (  ( z )     *    argScalar )  )  ;", "}", "METHOD_END"], "methodName": ["mul"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "x    *  =    argScalar ;", "y    *  =    argScalar ;", "z    *  =    argScalar ;", "return   this ;", "}", "METHOD_END"], "methodName": ["mulLocal"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 3  (  (  -  ( x )  )  ,     (  -  ( y )  )  ,     (  -  ( z )  )  )  ;", "}", "METHOD_END"], "methodName": ["negate"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "x    =     -  ( x )  ;", "y    =     -  ( y )  ;", "z    =     -  ( z )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["negateLocal"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "x    =    argX ;", "y    =    argY ;", "z    =    argZ ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "x    =    vec . x ;", "y    =    vec . y ;", "z    =    vec . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "x    =     0  ;", "y    =     0  ;", "z    =     0  ;", "}", "METHOD_END"], "methodName": ["setZero"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "return   new   Vec 3  (  (  ( x )     -     ( argVec . x )  )  ,     (  ( y )     -     ( argVec . y )  )  ,     (  ( z )     -     ( argVec . z )  )  )  ;", "}", "METHOD_END"], "methodName": ["sub"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "x    -  =    argVec . x ;", "y    -  =    argVec . y ;", "z    -  =    argVec . z ;", "return   this ;", "}", "METHOD_END"], "methodName": ["subLocal"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  \"  (  \"     +     ( x )  )     +     \"  ,  \"  )     +     ( y )  )     +     \"  ,  \"  )     +     ( z )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.jbox2d.common.Vec3"}, {"methodBody": ["METHOD_START", "{", "m _ sweep . advance ( t )  ;", "m _ sweep . c . set ( m _ sweep . c 0  )  ;", "m _ sweep . a    =    m _ sweep . a 0  ;", "m _ xf . q . set ( m _ sweep . a )  ;", "Rot . mulToOutUnsafe ( m _ xf . q ,    m _ sweep . localCenter ,    m _ xf . p )  ;", "m _ xf . p . mulLocal (  (  -  1  )  )  . addLocal ( m _ sweep . c )  ;", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ type )     !  =     ( BodyType . DYNAMIC )  )     {", "return ;", "}", "if    (  ( isAwake (  )  )     =  =    false )     {", "setAwake ( true )  ;", "}", "m _ angularVelocity    +  =     ( m _ invI )     *    impulse ;", "}", "METHOD_END"], "methodName": ["applyAngularImpulse"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ type )     !  =     ( BodyType . DYNAMIC )  )     {", "return ;", "}", "if    (  ( isAwake (  )  )     =  =    false )     {", "setAwake ( true )  ;", "}", "m _ force . x    +  =    force . x ;", "m _ force . y    +  =    force . y ;", "m _ torque    +  =     (  (  ( point . x )     -     ( m _ sweep . c . x )  )     *     ( force . y )  )     -     (  (  ( point . y )     -     ( m _ sweep . c . y )  )     *     ( force . x )  )  ;", "}", "METHOD_END"], "methodName": ["applyForce"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ type )     !  =     ( BodyType . DYNAMIC )  )     {", "return ;", "}", "if    (  ( isAwake (  )  )     =  =    false )     {", "setAwake ( true )  ;", "}", "m _ force . x    +  =    force . x ;", "m _ force . y    +  =    force . y ;", "}", "METHOD_END"], "methodName": ["applyForceToCenter"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ type )     !  =     ( BodyType . DYNAMIC )  )     {", "return ;", "}", "if    (  !  ( isAwake (  )  )  )     {", "if    ( wake )     {", "setAwake ( true )  ;", "} else    {", "return ;", "}", "}", "m _ linearVelocity . x    +  =     ( impulse . x )     *     ( m _ invMass )  ;", "m _ linearVelocity . y    +  =     ( impulse . y )     *     ( m _ invMass )  ;", "m _ angularVelocity    +  =     ( m _ invI )     *     (  (  (  ( point . x )     -     ( m _ sweep . c . x )  )     *     ( impulse . y )  )     -     (  (  ( point . y )     -     ( m _ sweep . c . y )  )     *     ( impulse . x )  )  )  ;", "}", "METHOD_END"], "methodName": ["applyLinearImpulse"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ type )     !  =     ( BodyType . DYNAMIC )  )     {", "return ;", "}", "if    (  ( isAwake (  )  )     =  =    false )     {", "setAwake ( true )  ;", "}", "m _ torque    +  =    torque ;", "}", "METHOD_END"], "methodName": ["applyTorque"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "fixDef . shape    =    shape ;", "fixDefensity    = ensity ;", "return   createFixture ( fixDef )  ;", "}", "METHOD_END"], "methodName": ["createFixture"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ world . isLocked (  )  )     =  =    false ;", "if    (  ( m _ world . isLocked (  )  )     =  =    true )     {", "return   null ;", "}", "Fixture   fixture    =    new   Fixture (  )  ;", "fixture . create ( this ,    def )  ;", "if    (  (  ( m _ flags )     &     (  . e _ activeFlag )  )     =  =     (  . e _ activeFlag )  )     {", "BroadPhase   broadPhase    =    m _ world . m _ contactManager . m _ broadPhase ;", "fixture . createProxies ( broadPhase ,    m _ xf )  ;", "}", "fixture . m _ next    =    m _ fixtureList ;", "m _ fixtureList    =    fixture ;", "+  +  ( m _ fixtureCount )  ;", "fixture . m _ body    =    this ;", "if    (  ( fixture . m _ density )     >     0  .  0 F )     {", "resetMassData (  )  ;", "}", "m _ world . m _ flags    |  =    World . NEW _ FIXTURE ;", "return   fixture ;", "}", "METHOD_END"], "methodName": ["createFixture"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ world . isLocked (  )  )     =  =    false ;", "if    (  ( m _ world . isLocked (  )  )     =  =    true )     {", "return ;", "}", "assert    ( fixture . m _ body )     =  =     ( this )  ;", "assert    ( m _ fixtureCount )     >     0  ;", "Fixture   node    =    m _ fixtureList ;", "Fixture   last    =    null ;", "boolean   found    =    false ;", "while    ( node    !  =    null )     {", "if    ( node    =  =    fixture )     {", "node    =    fixture . m _ next ;", "found    =    true ;", "break ;", "}", "last    =    node ;", "node    =    node . m _ next ;", "}", "assert   found ;", "if    ( last    =  =    null )     {", "m _ fixtureList    =    fixture . m _ next ;", "} else    {", "last . m _ next    =    fixture . m _ next ;", "}", "ContactEdge   edge    =    m _ contactList ;", "while    ( edge    !  =    null )     {", "Contact   c    =    edge . contact ;", "edge    =    edge . next ;", "Fixture   fixtureA    =    c . getFixtureA (  )  ;", "Fixture   fixtureB    =    c . getFixtureB (  )  ;", "if    (  ( fixture    =  =    fixtureA )     |  |     ( fixture    =  =    fixtureB )  )     {", "m _ world . m _ contactManager . destroy ( c )  ;", "}", "}", "if    (  (  ( m _ flags )     &     (  . e _ activeFlag )  )     =  =     (  . e _ activeFlag )  )     {", "BroadPhase   broadPhase    =    m _ world . m _ contactManager . m _ broadPhase ;", "fixture . destroyProxies ( broadPhase )  ;", "}", "fixture . destroy (  )  ;", "fixture . m _ body    =    null ;", "fixture . m _ next    =    null ;", "fixture    =    null ;", "-  -  ( m _ fixtureCount )  ;", "resetMassData (  )  ;", "}", "METHOD_END"], "methodName": ["destroyFixture"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ sweep . a ;", "}", "METHOD_END"], "methodName": ["getAngle"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ angularDamping ;", "}", "METHOD_END"], "methodName": ["getAngularDamping"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ angularVelocity ;", "}", "METHOD_END"], "methodName": ["getAngularVelocity"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ contactList ;", "}", "METHOD_END"], "methodName": ["getContactList"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ fixtureList ;", "}", "METHOD_END"], "methodName": ["getFixtureList"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ gravityScale ;", "}", "METHOD_END"], "methodName": ["getGravityScale"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ I )     +     (  ( m _ mass )     *     (  (  ( m _ sweep . localCenter . x )     *     ( m _ sweep . localCenter . x )  )     +     (  ( m _ sweep . localCenter . y )     *     ( m _ sweep . localCenter . y )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getInertia"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ jointList ;", "}", "METHOD_END"], "methodName": ["getJointList"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ linearDamping ;", "}", "METHOD_END"], "methodName": ["getLinearDamping"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ linearVelocity ;", "}", "METHOD_END"], "methodName": ["getLinearVelocity"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    out    =    new   Vec 2  (  )  ;", "getLinearVelocityFromLocalPointToOut ( localPoint ,    out )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getLinearVelocityFromLocalPoint"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "getWorldPointToOut ( localPoint ,    out )  ;", "getLinearVelocityFromWorldPointToOut ( out ,    out )  ;", "}", "METHOD_END"], "methodName": ["getLinearVelocityFromLocalPointToOut"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    out    =    new   Vec 2  (  )  ;", "getLinearVelocityFromWldPointToOut ( wldPoint ,    out )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getLinearVelocityFromWorldPoint"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "final   float   tempX    =     ( worldPoint . x )     -     ( m _ sweep . c . x )  ;", "final   float   tempY    =     ( worldPoint . y )     -     ( m _ sweep . c . y )  ;", "out . x    =     (  (  -  ( m _ angularVelocity )  )     *    tempY )     +     ( m _ linearVelocity . x )  ;", "out . y    =     (  ( m _ angularVelocity )     *    tempX )     +     ( m _ linearVelocity . y )  ;", "}", "METHOD_END"], "methodName": ["getLinearVelocityFromWorldPointToOut"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ sweep . localCenter ;", "}", "METHOD_END"], "methodName": ["getLocalCenter"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    out    =    new   Vec 2  (  )  ;", "getLocalPointToOut ( wldPoint ,    out )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getLocalPoint"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Transform . mulTransToOut ( m _ xf ,    worldPoint ,    out )  ;", "}", "METHOD_END"], "methodName": ["getLocalPointToOut"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    out    =    new   Vec 2  (  )  ;", "getLocalVectToOut ( wldVect ,    out )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getLocalVector"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Rot . mulTrans ( m _ xf . q ,    worldVector ,    out )  ;", "}", "METHOD_END"], "methodName": ["getLocalVectorToOut"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Rot . mulTransUnsafe ( m _ xf . q ,    worldVector ,    out )  ;", "}", "METHOD_END"], "methodName": ["getLocalVectorToOutUnsafe"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ mass ;", "}", "METHOD_END"], "methodName": ["getMass"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "data . mass    =    m _ mass ;", "data . I    =     ( m _ I )     +     (  ( m _ mass )     *     (  (  ( m _ sweep . localCenter . x )     *     ( m _ sweep . localCenter . x )  )     +     (  ( m _ sweep . localCenter . y )     *     ( m _ sweep . localCenter . y )  )  )  )  ;", "data . center . x    =    m _ sweep . localCenter . x ;", "data . center . y    =    m _ sweep . localCenter . y ;", "}", "METHOD_END"], "methodName": ["getMassData"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ next ;", "}", "METHOD_END"], "methodName": ["getNext"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ xf . p ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ xf ;", "}", "METHOD_END"], "methodName": ["getTransform"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ world ;", "}", "METHOD_END"], "methodName": ["getWorld"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   m _ sweep . c ;", "}", "METHOD_END"], "methodName": ["getWorldCenter"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    v    =    new   Vec 2  (  )  ;", "getWldPointToOut ( localPoint ,    v )  ;", "return   v ;", "}", "METHOD_END"], "methodName": ["getWorldPoint"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Transform . mulToOut ( m _ xf ,    localPoint ,    out )  ;", "}", "METHOD_END"], "methodName": ["getWorldPointToOut"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Vec 2    out    =    new   Vec 2  (  )  ;", "getWldVectToOut ( localVect ,    out )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["getWorldVector"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Rot . mulToOut ( m _ xf . q ,    localVector ,    out )  ;", "}", "METHOD_END"], "methodName": ["getWorldVectorToOut"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "Rot . mulToOutUnsafe ( m _ xf . q ,    localVector ,    out )  ;", "}", "METHOD_END"], "methodName": ["getWorldVectorToOutUnsafe"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m _ flags )     &     ( Body . e _ activeFlag )  )     =  =     ( Body . e _ activeFlag )  ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m _ flags )     &     ( Body . e _ awakeFlag )  )     =  =     ( Body . e _ awakeFlag )  ;", "}", "METHOD_END"], "methodName": ["isAwake"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m _ flags )     &     ( Body . e _ bulletFlag )  )     =  =     ( Body . e _ bulletFlag )  ;", "}", "METHOD_END"], "methodName": ["isBullet"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m _ flags )     &     ( Body . e _ fixedRotationFlag )  )     =  =     ( Body . e _ fixedRotationFlag )  ;", "}", "METHOD_END"], "methodName": ["isFixedRotation"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m _ flags )     &     ( Body . e _ autoSleepFlag )  )     =  =     ( Body . e _ autoSleepFlag )  ;", "}", "METHOD_END"], "methodName": ["isSleepingAllowed"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "m _ mass    =     0  .  0 F ;", "m _ invMass    =     0  .  0 F ;", "m _ I    =     0  .  0 F ;", "m _ invI    =     0  .  0 F ;", "m _ sweep . localCenter . setZero (  )  ;", "if    (  (  ( m _ type )     =  =     ( Type . STATIC )  )     |  |     (  ( m _ type )     =  =     ( Type . KINEMATIC )  )  )     {", "m _ sweep . c 0  . set ( m _ xf . p )  ;", "m _ sweep . c . set ( m _ xf . p )  ;", "m _ sweep . a 0     =    m _ sweep . a ;", "return ;", "}", "assert    ( m _ type )     =  =     ( Type . DYNAMIC )  ;", "final   Vec 2    localCenter    =    m _ world . getPool (  )  . popVec 2  (  )  ;", "localCenter . setZero (  )  ;", "final   Vec 2    temp    =    m _ world . getPool (  )  . popVec 2  (  )  ;", "final   MassData   massData    =    pmd ;", "for    ( Fixture   f    =    m _ fixtureList ;    f    !  =    null ;    f    =    f . m _ next )     {", "if    (  ( f . m _ density )     =  =     0  .  0 F )     {", "continue ;", "}", "f . getMassData ( massData )  ;", "m _ mass    +  =    massData . mass ;", "temp . set ( massData . center )  . mulLocal ( massData . mass )  ;", "localCenter . addLocal ( temp )  ;", "m _ I    +  =    massData . I ;", "}", "if    (  ( m _ mass )     >     0  .  0 F )     {", "m _ invMass    =     1  .  0 F    /     ( m _ mass )  ;", "localCenter . mulLocal ( m _ invMass )  ;", "} else    {", "m _ mass    =     1  .  0 F ;", "m _ invMass    =     1  .  0 F ;", "}", "if    (  (  ( m _ I )     >     0  .  0 F )     &  &     (  (  ( m _ flags )     &     (  . e _ fixedRotationFlag )  )     =  =     0  )  )     {", "m _ I    -  =     ( m _ mass )     *     ( Vec 2  . dot ( localCenter ,    localCenter )  )  ;", "assert    ( m _ I )     >     0  .  0 F ;", "m _ invI    =     1  .  0 F    /     ( m _ I )  ;", "} else    {", "m _ I    =     0  .  0 F ;", "m _ invI    =     0  .  0 F ;", "}", "Vec 2    oldCenter    =    m _ world . getPool (  )  . popVec 2  (  )  ;", "oldCenter . set ( m _ sweep . c )  ;", "m _ sweep . localCenter . set ( localCenter )  ;", "Transform . mulToOutUnsafe ( m _ xf ,    m _ sweep . localCenter ,    m _ sweep . c 0  )  ;", "m _ sweep . c . set ( m _ sweep . c 0  )  ;", "temp . set ( m _ sweep . c )  . subLocal ( oldCenter )  ;", "final   Vec 2    temp 2     =    oldCenter ;", "Vec 2  . crossToOutUnsafe ( m _ angularVelocity ,    temp ,    temp 2  )  ;", "m _ linearVelocity . addLocal ( temp 2  )  ;", "m _ world . getPool (  )  . pushVec 2  (  3  )  ;", "}", "METHOD_END"], "methodName": ["resetMassData"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ world . isLocked (  )  )     =  =    false ;", "if    ( flag    =  =     ( isActive (  )  )  )     {", "return ;", "}", "if    ( flag )     {", "m _ flags    |  =     . e _ activeFlag ;", "BroadPhase   broadPhase    =    m _ world . m _ contactManager . m _ broadPhase ;", "for    ( Fixture   f    =    m _ fixtureList ;    f    !  =    null ;    f    =    f . m _ next )     {", "f . createProxies ( broadPhase ,    m _ xf )  ;", "}", "} else    {", "m _ flags    &  =     ~  (  . e _ activeFlag )  ;", "BroadPhase   broadPhase    =    m _ world . m _ contactManager . m _ broadPhase ;", "for    ( Fixture   f    =    m _ fixtureList ;    f    !  =    null ;    f    =    f . m _ next )     {", "f . destroyProxies ( broadPhase )  ;", "}", "ContactEdge   ce    =    m _ contactList ;", "while    ( ce    !  =    null )     {", "ContactEdge   ce 0     =    ce ;", "ce    =    ce . next ;", "m _ world . m _ contactManager . destroy ( ce 0  . contact )  ;", "}", "m _ contactList    =    null ;", "}", "}", "METHOD_END"], "methodName": ["setActive"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "m _ angularDamping    =    angularDamping ;", "}", "METHOD_END"], "methodName": ["setAngularDamping"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ type )     =  =     ( BodyType . STATIC )  )     {", "return ;", "}", "if    (  ( w    *    w )     >     0  .  0 F )     {", "setAwake ( true )  ;", "}", "m _ angularVelocity    =    w ;", "}", "METHOD_END"], "methodName": ["setAngularVelocity"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    ( flag )     {", "if    (  (  ( m _ flags )     &     (  . e _ awakeFlag )  )     =  =     0  )     {", "m _ flags    |  =     . e _ awakeFlag ;", "m _ sleepTime    =     0  .  0 F ;", "}", "} else    {", "m _ flags    &  =     ~  (  . e _ awakeFlag )  ;", "m _ sleepTime    =     0  .  0 F ;", "m _ linearVelocity . setZero (  )  ;", "m _ angularVelocity    =     0  .  0 F ;", "m _ force . setZero (  )  ;", "m _ torque    =     0  .  0 F ;", "}", "}", "METHOD_END"], "methodName": ["setAwake"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    ( flag )     {", "m _ flags    |  =     . e _ bulletFlag ;", "} else    {", "m _ flags    &  =     ~  (  . e _ bulletFlag )  ;", "}", "}", "METHOD_END"], "methodName": ["setBullet"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    ( flag )     {", "m _ flags    |  =     . e _ fixedRotationFlag ;", "} else    {", "m _ flags    &  =     ~  (  . e _ fixedRotationFlag )  ;", "}", "resetMassData (  )  ;", "}", "METHOD_END"], "methodName": ["setFixedRotation"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "this . m _ gravityScale    =    gravityScale ;", "}", "METHOD_END"], "methodName": ["setGravityScale"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "m _ linearDamping    =    linearDamping ;", "}", "METHOD_END"], "methodName": ["setLinearDamping"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ type )     =  =     ( BodyType . STATIC )  )     {", "return ;", "}", "if    (  ( Vec 2  . dot ( v ,    v )  )     >     0  .  0 F )     {", "setAwake ( true )  ;", "}", "m _ linearVelocity . set ( v )  ;", "}", "METHOD_END"], "methodName": ["setLinearVelocity"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ world . isLocked (  )  )     =  =    false ;", "if    (  ( m _ world . isLocked (  )  )     =  =    true )     {", "return ;", "}", "if    (  ( m _ type )     !  =     ( Type . DYNAMIC )  )     {", "return ;", "}", "m _ invMass    =     0  .  0 F ;", "m _ I    =     0  .  0 F ;", "m _ invI    =     0  .  0 F ;", "m _ mass    =    massData . mass ;", "if    (  ( m _ mass )     <  =     0  .  0 F )     {", "m _ mass    =     1  .  0 F ;", "}", "m _ invMass    =     1  .  0 F    /     ( m _ mass )  ;", "if    (  (  ( massData . I )     >     0  .  0 F )     &  &     (  (  ( m _ flags )     &     (  . e _ fixedRotationFlag )  )     =  =     0  )  )     {", "m _ I    =     ( massData . I )     -     (  ( m _ mass )     *     ( Vec 2  . dot ( massData . center ,    massData . center )  )  )  ;", "assert    ( m _ I )     >     0  .  0 F ;", "m _ invI    =     1  .  0 F    /     ( m _ I )  ;", "}", "final   Vec 2    oldCenter    =    m _ world . getPool (  )  . popVec 2  (  )  ;", "oldCenter . set ( m _ sweep . c )  ;", "m _ sweep . localCenter . set ( massData . center )  ;", "Transform . mulToOutUnsafe ( m _ xf ,    m _ sweep . localCenter ,    m _ sweep . c 0  )  ;", "m _ sweep . c . set ( m _ sweep . c 0  )  ;", "final   Vec 2    temp    =    m _ world . getPool (  )  . popVec 2  (  )  ;", "temp . set ( m _ sweep . c )  . subLocal ( oldCenter )  ;", "Vec 2  . crossToOut ( m _ angularVelocity ,    temp ,    temp )  ;", "m _ linearVelocity . addLocal ( temp )  ;", "m _ world . getPool (  )  . pushVec 2  (  2  )  ;", "}", "METHOD_END"], "methodName": ["setMassData"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    ( flag )     {", "m _ flags    |  =     . e _ autoSleepFlag ;", "} else    {", "m _ flags    &  =     ~  (  . e _ autoSleepFlag )  ;", "setAwake ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["setSleepingAllowed"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ world . isLocked (  )  )     =  =    false ;", "if    (  ( m _ world . isLocked (  )  )     =  =    true )     {", "return ;", "}", "m _ xf . q . set ( angle )  ;", "m _ xf . p . set ( position )  ;", "Transform . mulToOutUnsafe ( m _ xf ,    m _ sweep . localCenter ,    m _ sweep . c )  ;", "m _ sweep . a    =    angle ;", "m _ sweep . c 0  . set ( m _ sweep . c )  ;", "m _ sweep . a 0     =    m _ sweep . a ;", "BroadPhase   broadPhase    =    m _ world . m _ contactManager . m _ broadPhase ;", "for    ( Fixture   f    =    m _ fixtureList ;    f    !  =    null ;    f    =    f . m _ next )     {", "f . synchronize ( broadPhase ,    m _ xf ,    m _ xf )  ;", "}", "}", "METHOD_END"], "methodName": ["setTransform"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ world . isLocked (  )  )     =  =    false ;", "if    (  ( m _ world . isLocked (  )  )     =  =    true )     {", "return ;", "}", "if    (  ( m _ type )     =  =    type )     {", "return ;", "}", "m _ type    =    type ;", "resetMassData (  )  ;", "if    (  ( m _ type )     =  =     ( Type . STATIC )  )     {", "m _ linearVelocity . setZero (  )  ;", "m _ angularVelocity    =     0  .  0 F ;", "m _ sweep . a 0     =    m _ sweep . a ;", "m _ sweep . c 0  . set ( m _ sweep . c )  ;", "synchronizeFixtures (  )  ;", "}", "setAwake ( true )  ;", "m _ force . setZero (  )  ;", "m _ torque    =     0  .  0 F ;", "ContactEdge   ce    =    m _ contactList ;", "while    ( ce    !  =    null )     {", "ContactEdge   ce 0     =    ce ;", "ce    =    ce . next ;", "m _ world . m _ contactManager . destroy ( ce 0  . contact )  ;", "}", "m _ contactList    =    null ;", "BroadPhase   broadPhase    =    m _ world . m _ contactManager . m _ broadPhase ;", "for    ( Fixture   f    =    m _ fixtureList ;    f    !  =    null ;    f    =    f . m _ next )     {", "int   proxyCount    =    f . m _ proxyCount ;", "for    ( int   i    =     0  ;    i    <    proxyCount ;     +  + i )     {", "broadPhase . touchProxy ( f . m _ proxies [ i ]  . proxyId )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "m _ userData    =    data ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( m _ type )     !  =     ( BodyType . DYNAMIC )  )     &  &     (  ( other . m _ type )     !  =     ( BodyType . DYNAMIC )  )  )     {", "return   false ;", "}", "for    ( JointEdge   jn    =    m _ jointList ;    jn    !  =    null ;    jn    =    jn . next )     {", "if    (  ( jn . other )     =  =    other )     {", "if    (  ( jn . joint . getCollideConnected (  )  )     =  =    false )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldCollide"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "final   Transform   xf 1     =    pxf ;", "xf 1  . q . s    =    MathUtils . sin ( m _ sweep . a 0  )  ;", "xf 1  . q . c    =    MathUtils . cos ( m _ sweep . a 0  )  ;", "xf 1  . p . x    =     (  ( m _ sweep . c 0  . x )     -     (  ( xf 1  . q . c )     *     ( m _ sweep . localCenter . x )  )  )     +     (  ( xf 1  . q . s )     *     ( m _ sweep . localCenter . y )  )  ;", "xf 1  . p . y    =     (  ( m _ sweep . c 0  . y )     -     (  ( xf 1  . q . s )     *     ( m _ sweep . localCenter . x )  )  )     -     (  ( xf 1  . q . c )     *     ( m _ sweep . localCenter . y )  )  ;", "for    ( Fixture   f    =    m _ fixtureList ;    f    !  =    null ;    f    =    f . m _ next )     {", "f . synchronize ( m _ world . m _ contactManager . m _ broadPhase ,    xf 1  ,    m _ xf )  ;", "}", "}", "METHOD_END"], "methodName": ["synchronizeFixtures"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "m _ xf . q . s    =    MathUtils . sin ( m _ sweep . a )  ;", "m _ xf . q . c    =    MathUtils . cos ( m _ sweep . a )  ;", "Rot   q    =    m _ xf . q ;", "Vec 2    v    =    m _ sweep . localCenter ;", "m _ xf . p . x    =     (  ( m _ sweep . c . x )     -     (  ( q . c )     *     ( v . x )  )  )     +     (  ( q . s )     *     ( v . y )  )  ;", "m _ xf . p . y    =     (  ( m _ sweep . c . y )     -     (  ( q . s )     *     ( v . x )  )  )     -     (  ( q . c )     *     ( v . y )  )  ;", "}", "METHOD_END"], "methodName": ["synchronizeTransform"], "fileName": "org.jbox2d.dynamics.Body"}, {"methodBody": ["METHOD_START", "{", "return   angle ;", "}", "METHOD_END"], "methodName": ["getAngle"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   angularDamping ;", "}", "METHOD_END"], "methodName": ["getAngularDamping"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   angularVelocity ;", "}", "METHOD_END"], "methodName": ["getAngularVelocity"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   gravityScale ;", "}", "METHOD_END"], "methodName": ["getGravityScale"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   linearDamping ;", "}", "METHOD_END"], "methodName": ["getLinearDamping"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   linearVelocity ;", "}", "METHOD_END"], "methodName": ["getLinearVelocity"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   position ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   active ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   allowSleep ;", "}", "METHOD_END"], "methodName": ["isAllowSleep"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   awake ;", "}", "METHOD_END"], "methodName": ["isAwake"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   bullet ;", "}", "METHOD_END"], "methodName": ["isBullet"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "return   fixedRotation ;", "}", "METHOD_END"], "methodName": ["isFixedRotation"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . active    =    active ;", "}", "METHOD_END"], "methodName": ["setActive"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . allowSleep    =    allowSleep ;", "}", "METHOD_END"], "methodName": ["setAllowSleep"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . angle    =    angle ;", "}", "METHOD_END"], "methodName": ["setAngle"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . angularDamping    =    angularDamping ;", "}", "METHOD_END"], "methodName": ["setAngularDamping"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . angularVelocity    =    angularVelocity ;", "}", "METHOD_END"], "methodName": ["setAngularVelocity"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . awake    =    awake ;", "}", "METHOD_END"], "methodName": ["setAwake"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . bullet    =    bullet ;", "}", "METHOD_END"], "methodName": ["setBullet"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . fixedRotation    =    fixedRotation ;", "}", "METHOD_END"], "methodName": ["setFixedRotation"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . gravityScale    =    gravityScale ;", "}", "METHOD_END"], "methodName": ["setGravityScale"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . linearDamping    =    linearDamping ;", "}", "METHOD_END"], "methodName": ["setLinearDamping"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . linearVelocity    =    linearVelocity ;", "}", "METHOD_END"], "methodName": ["setLinearVelocity"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . position    =    position ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "this . userData    =    userData ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "org.jbox2d.dynamics.BodyDef"}, {"methodBody": ["METHOD_START", "{", "FixtureProxy   proxyA    =     (  ( FixtureProxy )     ( proxyUserDataA )  )  ;", "FixtureProxy   proxyB    =     (  ( FixtureProxy )     ( proxyUserDataB )  )  ;", "Fixture   fixtureA    =    proxyA . fixture ;", "Fixture   fixtureB    =    proxyB . fixture ;", "int   indexA    =    proxyA . childIndex ;", "int   indexB    =    proxyB . childIndex ;", "Body   bodyA    =    fixtureA . getBody (  )  ;", "Body   bodyB    =    fixtureB . getBody (  )  ;", "if    ( bodyA    =  =    bodyB )     {", "return ;", "}", "Edge   edge    =    bodyB . getList (  )  ;", "while    ( edge    !  =    null )     {", "if    (  ( edge . other )     =  =    bodyA )     {", "Fixture   fA    =    edge . contact . getFixtureA (  )  ;", "Fixture   fB    =    edge . contact . getFixtureB (  )  ;", "int   iA    =    edge . contact . getChildIndexA (  )  ;", "int   iB    =    edge . contact . getChildIndexB (  )  ;", "if    (  (  (  ( fA    =  =    fixtureA )     &  &     ( iA    =  =    indexA )  )     &  &     ( fB    =  =    fixtureB )  )     &  &     ( iB    =  =    indexB )  )     {", "return ;", "}", "if    (  (  (  ( fA    =  =    fixtureB )     &  &     ( iA    =  =    indexB )  )     &  &     ( fB    =  =    fixtureA )  )     &  &     ( iB    =  =    indexA )  )     {", "return ;", "}", "}", "edge    =    edge . next ;", "}", "if    (  ( bodyB . shouldCollide ( bodyA )  )     =  =    false )     {", "return ;", "}", "if    (  (  ( m _ contactFilter )     !  =    null )     &  &     (  ( m _ contactFilter . shouldCollide ( fixtureA ,    fixtureB )  )     =  =    false )  )     {", "return ;", "}", "c    =    pool . pop ( fixtureA ,    indexA ,    fixtureB ,    indexB )  ;", "if    ( c    =  =    null )     {", "return ;", "}", "fixtureA    =    c . getFixtureA (  )  ;", "fixtureB    =    c . getFixtureB (  )  ;", "indexA    =    c . getChildIndexA (  )  ;", "indexB    =    c . getChildIndexB (  )  ;", "bodyA    =    fixtureA . getBody (  )  ;", "bodyB    =    fixtureB . getBody (  )  ;", "c . m _ prev    =    null ;", "c . m _ next    =    m _ contactList ;", "if    (  ( m _ contactList )     !  =    null )     {", "m _ contactList . m _ prev    =    c ;", "}", "m _ contactList    =    c ;", "c . m _ nodeA . contact    =    c ;", "c . m _ nodeA . other    =    bodyB ;", "c . m _ nodeA . prev    =    null ;", "c . m _ nodeA . next    =    bodyA . m _ contactList ;", "if    (  ( bodyA . m _ contactList )     !  =    null )     {", "bodyA . m _ contactList . prev    =    c . m _ nodeA ;", "}", "bodyA . m _ contactList    =    c . m _ nodeA ;", "c . m _ nodeB . contact    =    c ;", "c . m _ nodeB . other    =    bodyA ;", "c . m _ nodeB . prev    =    null ;", "c . m _ nodeB . next    =    bodyB . m _ contactList ;", "if    (  ( bodyB . m _ contactList )     !  =    null )     {", "bodyB . m _ contactList . prev    =    c . m _ nodeB ;", "}", "bodyB . m _ contactList    =    c . m _ nodeB ;", "if    (  (  !  ( fixtureA . isSensor (  )  )  )     &  &     (  !  ( fixtureB . isSensor (  )  )  )  )     {", "bodyA . setAwake ( true )  ;", "bodyB . setAwake ( true )  ;", "}", "+  +  ( m _ contactCount )  ;", "}", "METHOD_END"], "methodName": ["addPair"], "fileName": "org.jbox2d.dynamics.ContactManager"}, {"methodBody": ["METHOD_START", "{", "Contact   c    =    m _ contactList ;", "while    ( c    !  =    null )     {", "Fixture   fixtureA    =    c . getFixtureA (  )  ;", "Fixture   fixtureB    =    c . getFixtureB (  )  ;", "int   indexA    =    c . getChildIndexA (  )  ;", "int   indexB    =    c . getChildIndexB (  )  ;", "Body   bodyA    =    fixtureA . getBody (  )  ;", "Body   bodyB    =    fixtureB . getBody (  )  ;", "if    (  (  ( c . m _ flags )     &     ( Contact . FILTER _ FLAG )  )     =  =     ( Contact . FILTER _ FLAG )  )     {", "if    (  ( bodyB . shouldCollide ( bodyA )  )     =  =    false )     {", "Contact   cNuke    =    c ;", "c    =    cNuke . getNext (  )  ;", "destroy ( cNuke )  ;", "continue ;", "}", "if    (  (  ( m _ contactFilter )     !  =    null )     &  &     (  ( m _ contactFilter . shouldCollide ( fixtureA ,    fixtureB )  )     =  =    false )  )     {", "Contact   cNuke    =    c ;", "c    =    cNuke . getNext (  )  ;", "destroy ( cNuke )  ;", "continue ;", "}", "c . m _ flags    &  =     ~  ( Contact . FILTER _ FLAG )  ;", "}", "boolean   activeA    =     ( bodyA . isAwake (  )  )     &  &     (  ( bodyA . m _ type )     !  =     ( BodyType . STATIC )  )  ;", "boolean   activeB    =     ( bodyB . isAwake (  )  )     &  &     (  ( bodyB . m _ type )     !  =     ( BodyType . STATIC )  )  ;", "if    (  ( activeA    =  =    false )     &  &     ( activeB    =  =    false )  )     {", "c    =    c . getNext (  )  ;", "continue ;", "}", "int   proxyIdA    =    fixtureA . m _ proxies [ indexA ]  . proxyId ;", "int   proxyIdB    =    fixtureB . m _ proxies [ indexB ]  . proxyId ;", "boolean   overlap    =    m _ broadPhase . testOverlap ( proxyIdA ,    proxyIdB )  ;", "if    ( overlap    =  =    false )     {", "Contact   cNuke    =    c ;", "c    =    cNuke . getNext (  )  ;", "destroy ( cNuke )  ;", "continue ;", "}", "c . update ( m _ contactListener )  ;", "c    =    c . getNext (  )  ;", "}", "}", "METHOD_END"], "methodName": ["collide"], "fileName": "org.jbox2d.dynamics.ContactManager"}, {"methodBody": ["METHOD_START", "{", "Fixture   fixtureA    =    c . getFixtureA (  )  ;", "Fixture   fixtureB    =    c . getFixtureB (  )  ;", "Body   bodyA    =    fixtureA . getBody (  )  ;", "Body   bodyB    =    fixtureB . getBody (  )  ;", "if    (  (  ( m _ contactListener )     !  =    null )     &  &     ( c . isTouching (  )  )  )     {", "m _ contactListener . end ( c )  ;", "}", "if    (  ( c . m _ prev )     !  =    null )     {", "c . m _ prev . m _ next    =    c . m _ next ;", "}", "if    (  ( c . m _ next )     !  =    null )     {", "c . m _ next . m _ prev    =    c . m _ prev ;", "}", "if    ( c    =  =     ( m _ contactList )  )     {", "m _ contactList    =    c . m _ next ;", "}", "if    (  ( c . m _ nodeA . prev )     !  =    null )     {", "c . m _ nodeA . prev . next    =    c . m _ nodeA . next ;", "}", "if    (  ( c . m _ nodeA . next )     !  =    null )     {", "c . m _ nodeA . next . prev    =    c . m _ nodeA . prev ;", "}", "if    (  ( c . m _ nodeA )     =  =     ( bodyA . m _ contactList )  )     {", "bodyA . m _ contactList    =    c . m _ nodeA . next ;", "}", "if    (  ( c . m _ nodeB . prev )     !  =    null )     {", "c . m _ nodeB . prev . next    =    c . m _ nodeB . next ;", "}", "if    (  ( c . m _ nodeB . next )     !  =    null )     {", "c . m _ nodeB . next . prev    =    c . m _ nodeB . prev ;", "}", "if    (  ( c . m _ nodeB )     =  =     ( bodyB . m _ contactList )  )     {", "bodyB . m _ contactList    =    c . m _ nodeB . next ;", "}", "pool . push ( c )  ;", "-  -  ( m _ contactCount )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.jbox2d.dynamics.ContactManager"}, {"methodBody": ["METHOD_START", "{", "m _ broadPhase . updatePairs ( this )  ;", "}", "METHOD_END"], "methodName": ["findNewContacts"], "fileName": "org.jbox2d.dynamics.ContactManager"}, {"methodBody": ["METHOD_START", "{", "categoryBits    =    argOther . categoryBits ;", "maskBits    =    argOther . maskBits ;", "groupIndex    =    argOther . groupIndex ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.dynamics.Filter"}, {"methodBody": ["METHOD_START", "{", "return   m _ shape . computeDistanceToOut ( m _ body . getTransform (  )  ,    p ,    childIndex ,    normalOut )  ;", "}", "METHOD_END"], "methodName": ["computeDistance"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "m _ userData    =    def . userData ;", "m _ friction    =    def . friction ;", "m _ restitution    =    def . restitution ;", "m _ body    =    body ;", "m _ next    =    null ;", "m _ filter . set ( def . filter )  ;", "m _ isSensor    =    def . isSensor ;", "m _ shape    =    def . shape . clone (  )  ;", "int   childCount    =    m _ shape . getChildCount (  )  ;", "if    (  ( m _ proxies )     =  =    null )     {", "m _ proxies    =    new   Proxy [ childCount ]  ;", "for    ( int   i    =     0  ;    i    <    childCount ;    i +  +  )     {", "m _ proxies [ i ]     =    new   Proxy (  )  ;", "m _ proxies [ i ]  . fixture    =    null ;", "m _ proxies [ i ]  . proxyId    =    BroadPhase . NULL _ PROXY ;", "}", "}", "if    (  ( m _ proxies . length )     <    childCount )     {", "Proxy [  ]    old    =    m _ proxies ;", "int   newLen    =    MathUtils . max (  (  ( old . length )     *     2  )  ,    childCount )  ;", "m _ proxies    =    new   Proxy [ newLen ]  ;", "System . arraycopy ( old ,     0  ,    m _ proxies ,     0  ,    old . length )  ;", "for    ( int   i    =     0  ;    i    <    newLen ;    i +  +  )     {", "if    ( i    >  =     ( old . length )  )     {", "m _ proxies [ i ]     =    new   Proxy (  )  ;", "}", "m _ proxies [ i ]  . fixture    =    null ;", "m _ proxies [ i ]  . proxyId    =    BroadPhase . NULL _ PROXY ;", "}", "}", "m _ proxyCount    =     0  ;", "m _ density    =    def . density ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ proxyCount )     =  =     0  ;", "m _ proxyCount    =    m _ shape . getChildCount (  )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ proxyCount )  ;     +  + i )     {", "Proxy   proxy    =    m _ proxies [ i ]  ;", "m _ shape . computeAABB ( proxy . aabb ,    xf ,    i )  ;", "proxy . proxyId    =    broadPhase . createProxy ( proxy . aabb ,    proxy )  ;", "proxy . fixture    =    this ;", "proxy . childIndex    =    i ;", "}", "}", "METHOD_END"], "methodName": ["createProxies"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ proxyCount )     =  =     0  ;", "m _ shape    =    null ;", "m _ proxies    =    null ;", "m _ next    =    null ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( m _ proxyCount )  ;     +  + i )     {", "Proxy   proxy    =    m _ proxies [ i ]  ;", "broadPhase . destroyProxy ( proxy . proxyId )  ;", "proxy . proxyId    =    BroadPhase . NULL _ PROXY ;", "}", "m _ proxyCount    =     0  ;", "}", "METHOD_END"], "methodName": ["destroyProxies"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "assert    ( childIndex    >  =     0  )     &  &     ( childIndex    <     ( m _ proxyCount )  )  ;", "ren   m _ proxies [ childIndex ]  . aabb ;", "}", "METHOD_END"], "methodName": ["getAABB"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ body ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ density ;", "}", "METHOD_END"], "methodName": ["getDensity"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ filter ;", "}", "METHOD_END"], "methodName": ["getFilterData"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ friction ;", "}", "METHOD_END"], "methodName": ["getFriction"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "m _ shape . computeMass ( massData ,    m _ density )  ;", "}", "METHOD_END"], "methodName": ["getMassData"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ next ;", "}", "METHOD_END"], "methodName": ["getNext"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ restitution ;", "}", "METHOD_END"], "methodName": ["getRestitution"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ shape ;", "}", "METHOD_END"], "methodName": ["getShape"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ shape . getType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ isSensor ;", "}", "METHOD_END"], "methodName": ["isSensor"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ shape . raycast ( output ,    input ,    m _ body . m _ xf ,    childIndex )  ;", "}", "METHOD_END"], "methodName": ["raycast"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ body )     =  =    null )     {", "return ;", "}", "ContactEdge   edge    =    m _ body . getContactList (  )  ;", "while    ( edge    !  =    null )     {", "Contact   contact    =    edge . contact ;", "fixtureA    =    contact . getA (  )  ;", "fixtureB    =    contact . getB (  )  ;", "if    (  ( fixtureA    =  =     ( this )  )     |  |     ( fixtureB    =  =     ( this )  )  )     {", "contact . flagForFiltering (  )  ;", "}", "edge    =    edge . next ;", "}", "World   world    =    m _ body . getWorld (  )  ;", "if    ( world    =  =    null )     {", "return ;", "}", "BroadPhase   broadPhase    =    world . m _ contactManager . m _ broadPhase ;", "for    ( int   i    =     0  ;    i    <     ( m _ proxyCount )  ;     +  + i )     {", "broadPhase . touchProxy ( m _ proxies [ i ]  . proxyId )  ;", "}", "}", "METHOD_END"], "methodName": ["refilter"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "assert   density    >  =     0  .  0 F ;", "m _ density    =    density ;", "}", "METHOD_END"], "methodName": ["setDensity"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "m _ filter . set ( filter )  ;", "filter (  )  ;", "}", "METHOD_END"], "methodName": ["setFilterData"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "m _ friction    =    friction ;", "}", "METHOD_END"], "methodName": ["setFriction"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "m _ restitution    =    restitution ;", "}", "METHOD_END"], "methodName": ["setRestitution"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "if    ( sensor    !  =     ( m _ isSensor )  )     {", "m _ body . setAwake ( true )  ;", "m _ isSensor    =    sensor ;", "}", "}", "METHOD_END"], "methodName": ["setSensor"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "m _ userData    =    data ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ proxyCount )     =  =     0  )     {", "return ;", "}", "for    ( int   i    =     0  ;    i    <     ( m _ proxyCount )  ;     +  + i )     {", "Proxy   proxy    =    m _ proxies [ i ]  ;", "final   AABB   aabb 1     =    pool 1  ;", "final   AABB   aab    =    pool 2  ;", "m _ shape . computeAABB ( aabb 1  ,    transform 1  ,    proxy . childIndex )  ;", "m _ shape . computeAABB ( aab ,    transform 2  ,    proxy . childIndex )  ;", "proxy . aabb . lowerBound . x    =     (  ( aabb 1  . lowerBound . x )     <     ( aab . lowerBound . x )  )     ?    aabb 1  . lowerBound . x    :    aab . lowerBound . x ;", "proxy . aabb . lowerBound . y    =     (  ( aabb 1  . lowerBound . y )     <     ( aab . lowerBound . y )  )     ?    aabb 1  . lowerBound . y    :    aab . lowerBound . y ;", "proxy . aabb . upperBound . x    =     (  ( aabb 1  . upperBound . x )     >     ( aab . upperBound . x )  )     ?    aabb 1  . upperBound . x    :    aab . upperBound . x ;", "proxy . aabb . upperBound . y    =     (  ( aabb 1  . upperBound . y )     >     ( aab . upperBound . y )  )     ?    aabb 1  . upperBound . y    :    aab . upperBound . y ;", "displacement . x    =     ( transform 2  . p . x )     -     ( transform 1  . p . x )  ;", "displacement . y    =     ( transform 2  . p . y )     -     ( transform 1  . p . y )  ;", "broadPhase . moveProxy ( proxy . proxyId ,    proxy . aabb ,    displacement )  ;", "}", "}", "METHOD_END"], "methodName": ["synchronize"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   m _ shape . testPoint ( m _ body . m _ xf ,    p )  ;", "}", "METHOD_END"], "methodName": ["testPoint"], "fileName": "org.jbox2d.dynamics.Fixture"}, {"methodBody": ["METHOD_START", "{", "return   density ;", "}", "METHOD_END"], "methodName": ["getDensity"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "return   filter ;", "}", "METHOD_END"], "methodName": ["getFilter"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "return   friction ;", "}", "METHOD_END"], "methodName": ["getFriction"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "return   restitution ;", "}", "METHOD_END"], "methodName": ["getRestitution"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "return   shape ;", "}", "METHOD_END"], "methodName": ["getShape"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "return   userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "return   isSensor ;", "}", "METHOD_END"], "methodName": ["isSensor"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "this . density    =    density ;", "}", "METHOD_END"], "methodName": ["setDensity"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "this . filter    =    filter ;", "}", "METHOD_END"], "methodName": ["setFilter"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "this . friction    =    friction ;", "}", "METHOD_END"], "methodName": ["setFriction"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "this . restitution    =    restitution ;", "}", "METHOD_END"], "methodName": ["setRestitution"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "this . isSensor    =    isSensor ;", "}", "METHOD_END"], "methodName": ["setSensor"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "this . shape    =    shape ;", "}", "METHOD_END"], "methodName": ["setShape"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "this . userData    =    userData ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "org.jbox2d.dynamics.FixtureDef"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ bodyCount )     <     ( m _ bodyCapacity )  ;", "body . m _ iIndex    =    m _ bodyCount ;", "m _ bodies [ m _ bodyCount ]     =    body ;", "+  +  ( m _ bodyCount )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jbox2d.dynamics.Island"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ contactCount )     <     ( m _ contactCapacity )  ;", "m _ contacts [  (  ( m _ contactCount )  +  +  )  ]     =    contact ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jbox2d.dynamics.Island"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ jointCount )     <     ( m _ jointCapacity )  ;", "m _ joints [  (  ( m _ jointCount )  +  +  )  ]     =    joint ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.jbox2d.dynamics.Island"}, {"methodBody": ["METHOD_START", "{", "m _ bodyCount    =     0  ;", "m _ contactCount    =     0  ;", "m _ jointCount    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.jbox2d.dynamics.Island"}, {"methodBody": ["METHOD_START", "{", "m _ bodyCapacity    =    bodyCapacity ;", "m _ contactCapacity    =    contactCapacity ;", "m _ jointCapacity    =    jointCapacity ;", "m _ bodyCount    =     0  ;", "m _ contactCount    =     0  ;", "m _ jointCount    =     0  ;", "m _ listener    =    listener ;", "if    (  (  ( m _ bodies )     =  =    null )     |  |     (  ( m _ bodyCapacity )     >     ( m _ bodies . length )  )  )     {", "m _ bodies    =    new   Body [ m _ bodyCapacity ]  ;", "}", "if    (  (  ( m _ joints )     =  =    null )     |  |     (  ( m _ jointCapacity )     >     ( m _ joints . length )  )  )     {", "m _ joints    =    new   Joint [ m _ jointCapacity ]  ;", "}", "if    (  (  ( m _ contacts )     =  =    null )     |  |     (  ( m _ contactCapacity )     >     ( m _ contacts . length )  )  )     {", "m _ contacts    =    new   Contact [ m _ contactCapacity ]  ;", "}", "if    (  (  ( m _ velocities )     =  =    null )     |  |     (  ( m _ bodyCapacity )     >     ( m _ velocities . length )  )  )     {", "final   Velocity [  ]    old    =     (  ( m _ velocities )     =  =    null )     ?    new   Velocity [  0  ]     :    m _ velocities ;", "m _ velocities    =    new   Velocity [ m _ bodyCapacity ]  ;", "System . arraycopy ( old ,     0  ,    m _ velocities ,     0  ,    old . length )  ;", "for    ( int   i    =    old . length ;    i    <     ( m _ velocities . length )  ;    i +  +  )     {", "m _ velocities [ i ]     =    new   Velocity (  )  ;", "}", "}", "if    (  (  ( m _ positions )     =  =    null )     |  |     (  ( m _ bodyCapacity )     >     ( m _ positions . length )  )  )     {", "final   Position [  ]    old    =     (  ( m _ positions )     =  =    null )     ?    new   Position [  0  ]     :    m _ positions ;", "m _ positions    =    new   Position [ m _ bodyCapacity ]  ;", "System . arraycopy ( old ,     0  ,    m _ positions ,     0  ,    old . length )  ;", "for    ( int   i    =    old . length ;    i    <     ( m _ positions . length )  ;    i +  +  )     {", "m _ positions [ i ]     =    new   Position (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jbox2d.dynamics.Island"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ listener )     =  =    null )     {", "return ;", "}", "f    ( int   i    =     0  ;    i    <     ( m _ contactCount )  ;     +  + i )     {", "Contact   c    =    m _ contacts [ i ]  ;", "ContactVelocityConstraint   vc    =    constraints [ i ]  ;", "impulse . count    =    vc . pointCount ;", "f    ( int   j    =     0  ;    j    <     ( vc . pointCount )  ;     +  + j )     {", "impulse . nmalImpulses [ j ]     =    vc . points [ j ]  . nmalImpulse ;", "impulse . tangentImpulses [ j ]     =    vc . points [ j ]  . tangentImpulse ;", "}", "m _ listener . postSolve ( c ,    impulse )  ;", "}", "}", "METHOD_END"], "methodName": ["report"], "fileName": "org.jbox2d.dynamics.Island"}, {"methodBody": ["METHOD_START", "{", "float   h    =    step . dt ;", "for    ( int   i    =     0  ;    i    <     ( m _ bodyCount )  ;     +  + i )     {", "final   Body   b    =    m _ bodies [ i ]  ;", "final   Sweep   bm _ sweep    =    b . m _ sweep ;", "final   Vec 2    c    =    bm _ sweep . c ;", "float   a    =    bm _ sweep . a ;", "final   Vec 2    v    =    b . m _ linearVelocity ;", "float   w    =    b . m _ angularVelocity ;", "bm _ sweep . c 0  . set ( bm _ sweep . c )  ;", "bm _ sweep . a 0     =    bm _ sweep . a ;", "if    (  ( b . m _ type )     =  =     ( BodyType . DYNAMIC )  )     {", "v . x    +  =    h    *     (  (  ( b . m _ gravityScale )     *     ( gravity . x )  )     +     (  ( b . m _ invMass )     *     ( b . m _ force . x )  )  )  ;", "v . y    +  =    h    *     (  (  ( b . m _ gravityScale )     *     ( gravity . y )  )     +     (  ( b . m _ invMass )     *     ( b . m _ force . y )  )  )  ;", "w    +  =     ( h    *     ( b . m _ invI )  )     *     ( b . m _ torque )  ;", "v . x    *  =     1  .  0 F    /     (  1  .  0 F    +     ( h    *     ( b . m _ linearDamping )  )  )  ;", "v . y    *  =     1  .  0 F    /     (  1  .  0 F    +     ( h    *     ( b . m _ linearDamping )  )  )  ;", "w    *  =     1  .  0 F    /     (  1  .  0 F    +     ( h    *     ( b . m _ angularDamping )  )  )  ;", "}", "m _ positions [ i ]  . c . x    =    c . x ;", "m _ positions [ i ]  . c . y    =    c . y ;", "m _ positions [ i ]  . a    =    a ;", "m _ velocities [ i ]  . v . x    =    v . x ;", "m _ velocities [ i ]  . v . y    =    v . y ;", "m _ velocities [ i ]  . w    =    w ;", "}", "timer . reset (  )  ;", "solverData . step    =    step ;", "solverData . positions    =    m _ positions ;", "solverData . velocities    =    m _ velocities ;", "solverDef . step    =    step ;", "solverDef . contacts    =    m _ contacts ;", "solverDef . count    =    m _ contactCount ;", "solverDef . positions    =    m _ positions ;", "solverDef . velocities    =    m _ velocities ;", "contactSolver . init ( solverDef )  ;", "contactSolver . initializeVelocityConstraints (  )  ;", "if    ( step . warmStarting )     {", "contactSolver . warmStart (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( m _ jointCount )  ;     +  + i )     {", "m _ joints [ i ]  . initVelocityConstraints ( solverData )  ;", "}", "profile . solveInit . accum ( timer . getMilliseconds (  )  )  ;", "timer . reset (  )  ;", "for    ( int   i    =     0  ;    i    <     ( step . velocityIterations )  ;     +  + i )     {", "for    ( int   j    =     0  ;    j    <     ( m _ jointCount )  ;     +  + j )     {", "m _ joints [ j ]  . solveVelocityConstraints ( solverData )  ;", "}", "contactSolver . solveVelocityConstraints (  )  ;", "}", "contactSolver . storeImpulses (  )  ;", "profile . solveVelocity . accum ( timer . getMilliseconds (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ bodyCount )  ;     +  + i )     {", "final   Vec 2    c    =    m _ positions [ i ]  . c ;", "float   a    =    m _ positions [ i ]  . a ;", "final   Vec 2    v    =    m _ velocities [ i ]  . v ;", "float   w    =    m _ velocities [ i ]  . w ;", "float   trantionx    =     ( v . x )     *    h ;", "float   trantiony    =     ( v . y )     *    h ;", "if    (  (  ( trantionx    *    trantionx )     +     ( trantiony    *    trantiony )  )     >     ( Settings . maxTrantionSquared )  )     {", "float   ratio    =     ( Settings . maxTrantion )     /     ( MathUtils . sqrt (  (  ( trantionx    *    trantionx )     +     ( trantiony    *    trantiony )  )  )  )  ;", "v . x    *  =    ratio ;", "v . y    *  =    ratio ;", "}", "float   rotation    =    h    *    w ;", "if    (  ( rotation    *    rotation )     >     ( Settings . maxRotationSquared )  )     {", "float   ratio    =     ( Settings . maxRotation )     /     ( MathUtils . abs ( rotation )  )  ;", "w    *  =    ratio ;", "}", "c . x    +  =    h    *     ( v . x )  ;", "c . y    +  =    h    *     ( v . y )  ;", "a    +  =    h    *    w ;", "m _ positions [ i ]  . a    =    a ;", "m _ velocities [ i ]  . w    =    w ;", "}", "timer . reset (  )  ;", "boolean   positionSolved    =    false ;", "for    ( int   i    =     0  ;    i    <     ( step . positionIterations )  ;     +  + i )     {", "boolean   contactsOkay    =    contactSolver . solvePositionConstraints (  )  ;", "boolean   jointsOkay    =    true ;", "for    ( int   j    =     0  ;    j    <     ( m _ jointCount )  ;     +  + j )     {", "boolean   jointOkay    =    m _ joints [ j ]  . solvePositionConstraints ( solverData )  ;", "jointsOkay    =    jointsOkay    &  &    jointOkay ;", "}", "if    ( contactsOkay    &  &    jointsOkay )     {", "positionSolved    =    true ;", "break ;", "}", "}", "for    ( int   i    =     0  ;    i    <     ( m _ bodyCount )  ;     +  + i )     {", "Body   body    =    m _ bodies [ i ]  ;", "body . m _ sweep . c . x    =    m _ positions [ i ]  . c . x ;", "body . m _ sweep . c . y    =    m _ positions [ i ]  . c . y ;", "body . m _ sweep . a    =    m _ positions [ i ]  . a ;", "body . m _ linearVelocity . x    =    m _ velocities [ i ]  . v . x ;", "body . m _ linearVelocity . y    =    m _ velocities [ i ]  . v . y ;", "body . m _ angularVelocity    =    m _ velocities [ i ]  . w ;", "body . synchronizeTransform (  )  ;", "}", "profile . solvePosition . accum ( timer . getMilliseconds (  )  )  ;", "report ( contactSolver . m _ velocityConstraints )  ;", "if    ( allowSleep )     {", "float   minSleepTime    =    Float . MAX _ VALUE ;", "final   float   linTolSqr    =     ( Settings . linearSleepTolerance )     *     ( Settings . linearSleepTolerance )  ;", "final   float   angTolSqr    =     ( Settings . angularSleepTolerance )     *     ( Settings . angularSleepTolerance )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ bodyCount )  ;     +  + i )     {", "Body   b    =    m _ bodies [ i ]  ;", "if    (  ( b . getType (  )  )     =  =     ( BodyType . STATIC )  )     {", "continue ;", "}", "if    (  (  (  (  ( b . m _ flags )     &     ( Body . e _ autoSleepFlag )  )     =  =     0  )     |  |     (  (  ( b . m _ angularVelocity )     *     ( b . m _ angularVelocity )  )     >    angTolSqr )  )     |  |     (  ( Vec 2  . dot ( b . m _ linearVelocity ,    b . m _ linearVelocity )  )     >    linTolSqr )  )     {", "b . m _ sleepTime    =     0  .  0 F ;", "minSleepTime    =     0  .  0 F ;", "} else    {", "b . m _ sleepTime    +  =    h ;", "minSleepTime    =    MathUtils . min ( minSleepTime ,    b . m _ sleepTime )  ;", "}", "}", "if    (  ( minSleepTime    >  =     ( Settings . timeToSleep )  )     &  &    positionSolved )     {", "for    ( int   i    =     0  ;    i    <     ( m _ bodyCount )  ;     +  + i )     {", "Body   b    =    m _ bodies [ i ]  ;", "b . setAwake ( false )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["solve"], "fileName": "org.jbox2d.dynamics.Island"}, {"methodBody": ["METHOD_START", "{", "assert   toiIndexA    <     ( m _ bodyCount )  ;", "assert   toiIndexB    <     ( m _ bodyCount )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ bodyCount )  ;     +  + i )     {", "m _ positions [ i ]  . c . x    =    m _ bodies [ i ]  . m _ sweep . c . x ;", "m _ positions [ i ]  . c . y    =    m _ bodies [ i ]  . m _ sweep . c . y ;", "m _ positions [ i ]  . a    =    m _ bodies [ i ]  . m _ sweep . a ;", "m _ velocities [ i ]  . v . x    =    m _ bodies [ i ]  . m _ linearVelocity . x ;", "m _ velocities [ i ]  . v . y    =    m _ bodies [ i ]  . m _ linearVelocity . y ;", "m _ velocities [ i ]  . w    =    m _ bodies [ i ]  . m _ angularVelocity ;", "}", "toiSolverDef . contacts    =    m _ contacts ;", "toiSolverDef . count    =    m _ contactCount ;", "toiSolverDef . step    =    subStep ;", "toiSolverDef . positions    =    m _ positions ;", "toiSolverDef . velocities    =    m _ velocities ;", "toiContactSolver . init ( toiSolverDef )  ;", "for    ( int   i    =     0  ;    i    <     ( subStep . positionIterations )  ;     +  + i )     {", "boolean   contactsOkay    =    toiContactSolver . solveTOIPositionConstraints ( toiIndexA ,    toiIndexB )  ;", "if    ( contactsOkay )     {", "break ;", "}", "}", "m _ bodies [ toiIndexA ]  . m _ sweep . c 0  . x    =    m _ positions [ toiIndexA ]  . c . x ;", "m _ bodies [ toiIndexA ]  . m _ sweep . c 0  . y    =    m _ positions [ toiIndexA ]  . c . y ;", "m _ bodies [ toiIndexA ]  . m _ sweep . a 0     =    m _ positions [ toiIndexA ]  . a ;", "m _ bodies [ toiIndexB ]  . m _ sweep . c 0  . set ( m _ positions [ toiIndexB ]  . c )  ;", "m _ bodies [ toiIndexB ]  . m _ sweep . a 0     =    m _ positions [ toiIndexB ]  . a ;", "toiContactSolver . initializeVelocityConstraints (  )  ;", "for    ( int   i    =     0  ;    i    <     ( subStep . velocityIterations )  ;     +  + i )     {", "toiContactSolver . solveVelocityConstraints (  )  ;", "}", "float   h    =    subStep . dt ;", "for    ( int   i    =     0  ;    i    <     ( m _ bodyCount )  ;     +  + i )     {", "Vec 2    c    =    m _ positions [ i ]  . c ;", "float   a    =    m _ positions [ i ]  . a ;", "Vec 2    v    =    m _ velocities [ i ]  . v ;", "float   w    =    m _ velocities [ i ]  . w ;", "float   trantionx    =     ( v . x )     *    h ;", "float   trantiony    =     ( v . y )     *    h ;", "if    (  (  ( trantionx    *    trantionx )     +     ( trantiony    *    trantiony )  )     >     ( Settings . maxTrantionSquared )  )     {", "float   ratio    =     ( Settings . maxTrantion )     /     ( MathUtils . sqrt (  (  ( trantionx    *    trantionx )     +     ( trantiony    *    trantiony )  )  )  )  ;", "v . mulLocal ( ratio )  ;", "}", "float   rotation    =    h    *    w ;", "if    (  ( rotation    *    rotation )     >     ( Settings . maxRotationSquared )  )     {", "float   ratio    =     ( Settings . maxRotation )     /     ( MathUtils . abs ( rotation )  )  ;", "w    *  =    ratio ;", "}", "c . x    +  =     ( v . x )     *    h ;", "c . y    +  =     ( v . y )     *    h ;", "a    +  =    h    *    w ;", "m _ positions [ i ]  . c . x    =    c . x ;", "m _ positions [ i ]  . c . y    =    c . y ;", "m _ positions [ i ]  . a    =    a ;", "m _ velocities [ i ]  . v . x    =    v . x ;", "m _ velocities [ i ]  . v . y    =    v . y ;", "m _ velocities [ i ]  . w    =    w ;", "Body   body    =    m _ bodies [ i ]  ;", "body . m _ sweep . c . x    =    c . x ;", "body . m _ sweep . c . y    =    c . y ;", "body . m _ sweep . a    =    a ;", "body . m _ linearVelocity . x    =    v . x ;", "body . m _ linearVelocity . y    =    v . y ;", "body . m _ angularVelocity    =    w ;", "body . synchronizeTransform (  )  ;", "}", "report ( toiContactSolver . m _ velocityConstraints )  ;", "}", "METHOD_END"], "methodName": ["solveTOI"], "fileName": "org.jbox2d.dynamics.Island"}, {"methodBody": ["METHOD_START", "{", "strings . add (  \" Profile :  \"  )  ;", "strings . add (  (  \"    step :     \"     +     ( step )  )  )  ;", "strings . add (  (  \"       init :     \"     +     ( stepInit )  )  )  ;", "strings . add (  (  \"       collide :     \"     +     ( collide )  )  )  ;", "strings . add (  (  \"       particles :     \"     +     ( solveParticleSystem )  )  )  ;", "strings . add (  (  \"       solve :     \"     +     ( solve )  )  )  ;", "strings . add (  (  \"          solveInit :     \"     +     ( solveInit )  )  )  ;", "strings . add (  (  \"          solveVelocity :     \"     +     ( solveVelocity )  )  )  ;", "strings . add (  (  \"          solvePosition :     \"     +     ( solvePosition )  )  )  ;", "strings . add (  (  \"          broadphase :     \"     +     ( broadphase )  )  )  ;", "strings . add (  (  \"       solveTOI :     \"     +     ( solveTOI )  )  )  ;", "}", "METHOD_END"], "methodName": ["toDebugStrings"], "fileName": "org.jbox2d.dynamics.Profile"}, {"methodBody": ["METHOD_START", "{", "ContactRegister   register    =    new   ContactRegister (  )  ;", "register . creat    =    creat ;", "register . primary    =    true ;", "contactStacks [ type 1  . dinal (  )  ]  [ type 2  . dinal (  )  ]     =    register ;", "if    ( type 1     !  =    type 2  )     {", "ContactRegister   register 2     =    new   ContactRegister (  )  ;", "register 2  . creat    =    creat ;", "register 2  . primary    =    false ;", "contactStacks [ type 2  . dinal (  )  ]  [ type 1  . dinal (  )  ]     =    register 2  ;", "}", "}", "METHOD_END"], "methodName": ["addType"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "for    ( Body   body    =    m _ bodyList ;    body    !  =    null ;    body    =    body . getNext (  )  )     {", "body . m _ force . setZero (  )  ;", "body . m _ torque    =     0  .  0 F ;", "}", "}", "METHOD_END"], "methodName": ["clearForces"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . computeParticleCollisionEnergy (  )  ;", "}", "METHOD_END"], "methodName": ["computeParticleCollisionEnergy"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "assert    ( isLocked (  )  )     =  =    false ;", "if    ( isLocked (  )  )     {", "return   null ;", "}", "Bo   b    =    new   Bo ( def ,    this )  ;", "b . m _ prev    =    null ;", "b . m _ next    =    m _ boList ;", "if    (  ( m _ boList )     !  =    null )     {", "m _ boList . m _ prev    =    b ;", "}", "m _ boList    =    b ;", "+  +  ( m _ boCount )  ;", "return   b ;", "}", "METHOD_END"], "methodName": ["createBody"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "assert    ( isLocked (  )  )     =  =    false ;", "if    ( isLocked (  )  )     {", "return   null ;", "}", "Joint    =    Joint . create ( this ,    def )  ;", ". m _ prev    =    null ;", ". m _ next    =    mointList ;", "if    (  ( mointList )     !  =    null )     {", "mointList . m _ prev    =  ;", "}", "mointList    =  ;", "+  +  ( mointCount )  ;", ". m _ edgeAoint    =  ;", ". m _ edgeA . other    =  . getBodyB (  )  ;", ". m _ edgeA . prev    =    null ;", ". m _ edgeA . next    =  . getBodyA (  )  . mointList ;", "if    (  . getBodyA (  )  . mointList )     !  =    null )     {", ". getBodyA (  )  . mointList . prev    =  . m _ edgeA ;", "}", ". getBodyA (  )  . mointList    =  . m _ edgeA ;", ". m _ edgeBoint    =  ;", ". m _ edgeB . other    =  . getBodyA (  )  ;", ". m _ edgeB . prev    =    null ;", ". m _ edgeB . next    =  . getBodyB (  )  . mointList ;", "if    (  . getBodyB (  )  . mointList )     !  =    null )     {", ". getBodyB (  )  . mointList . prev    =  . m _ edgeB ;", "}", ". getBodyB (  )  . mointList    =  . m _ edgeB ;", "Body   bodyA    =    def . bodyA ;", "Body   bodyB    =    def . bodyB ;", "if    (  ( def . collideConnected )     =  =    false )     {", "ContactEdge   edge    =    bodyB . getContactList (  )  ;", "while    ( edge    !  =    null )     {", "if    (  ( edge . other )     =  =    bodyA )     {", "edge . contact . flagForFiltering (  )  ;", "}", "edge    =    edge . next ;", "}", "}", "return ;", "}", "METHOD_END"], "methodName": ["createJoint"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "assert    ( isLocked (  )  )     =  =    false ;", "if    ( isLocked (  )  )     {", "return    0  ;", "}", "int   p    =    m _ partleSystem . createPartle ( def )  ;", "return   p ;", "}", "METHOD_END"], "methodName": ["createParticle"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "assert    ( isLocked (  )  )     =  =    false ;", "if    ( isLocked (  )  )     {", "return   null ;", "}", "PartleGroup   g    =    m _ partleSystem . createPartleGroup ( def )  ;", "return   g ;", "}", "METHOD_END"], "methodName": ["createParticleGroup"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ bodyCount )     >     0  ;", "assert    ( isLocked (  )  )     =  =    false ;", "if    ( isLocked (  )  )     {", "return ;", "}", "JointEdge   je    =    body . m _ jointList ;", "while    ( je    !  =    null )     {", "JointEdge   je 0     =    je ;", "je    =    je . next ;", "if    (  ( m _ destructionListener )     !  =    null )     {", "m _ destructionListener . sayGoodbye ( je 0  . joint )  ;", "}", "destroyJoint ( je 0  . joint )  ;", "body . m _ jointList    =    je ;", "}", "body . m _ jointList    =    null ;", "ContactEdge   ce    =    body . m _ contactList ;", "while    ( ce    !  =    null )     {", "ContactEdge   ce 0     =    ce ;", "ce    =    ce . next ;", "m _ contactManager . destroy ( ce 0  . contact )  ;", "}", "body . m _ contactList    =    null ;", "Fixture   f    =    body . m _ fixtureList ;", "while    ( f    !  =    null )     {", "Fixture   f 0     =    f ;", "f    =    f . m _ next ;", "if    (  ( m _ destructionListener )     !  =    null )     {", "m _ destructionListener . sayGoodbye ( f 0  )  ;", "}", "f 0  . destroyProxies ( m _ contactManager . m _ broadPhase )  ;", "f 0  . destroy (  )  ;", "body . m _ fixtureList    =    f ;", "body . m _ fixtureCount    -  =     1  ;", "}", "body . m _ fixtureList    =    null ;", "body . m _ fixtureCount    =     0  ;", "if    (  ( body . m _ prev )     !  =    null )     {", "body . m _ prev . m _ next    =    body . m _ next ;", "}", "if    (  ( body . m _ next )     !  =    null )     {", "body . m _ next . m _ prev    =    body . m _ prev ;", "}", "if    ( body    =  =     ( m _ bodyList )  )     {", "m _ bodyList    =    body . m _ next ;", "}", "-  -  ( m _ bodyCount )  ;", "}", "METHOD_END"], "methodName": ["destroyBody"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "assert    ( isLocked (  )  )     =  =    false ;", "if    ( isLocked (  )  )     {", "return ;", "}", "olean   collideConnected    =    j . getCollideConnected (  )  ;", "if    (  ( j . m _ prev )     !  =    null )     {", "j . m _ prev . m _ next    =    j . m _ next ;", "}", "if    (  ( j . m _ next )     !  =    null )     {", "j . m _ next . m _ prev    =    j . m _ prev ;", "}", "if    ( j    =  =     ( m _ jointList )  )     {", "m _ jointList    =    j . m _ next ;", "}", "Body   dyA    =    j . getBodyA (  )  ;", "Body   dyB    =    j . getBodyB (  )  ;", "dyA . setAwake ( true )  ;", "dyB . setAwake ( true )  ;", "if    (  ( j . m _ edgeA . prev )     !  =    null )     {", "j . m _ edgeA . prev . next    =    j . m _ edgeA . next ;", "}", "if    (  ( j . m _ edgeA . next )     !  =    null )     {", "j . m _ edgeA . next . prev    =    j . m _ edgeA . prev ;", "}", "if    (  ( j . m _ edgeA )     =  =     ( dyA . m _ jointList )  )     {", "dyA . m _ jointList    =    j . m _ edgeA . next ;", "}", "j . m _ edgeA . prev    =    null ;", "j . m _ edgeA . next    =    null ;", "if    (  ( j . m _ edgeB . prev )     !  =    null )     {", "j . m _ edgeB . prev . next    =    j . m _ edgeB . next ;", "}", "if    (  ( j . m _ edgeB . next )     !  =    null )     {", "j . m _ edgeB . next . prev    =    j . m _ edgeB . prev ;", "}", "if    (  ( j . m _ edgeB )     =  =     ( dyB . m _ jointList )  )     {", "dyB . m _ jointList    =    j . m _ edgeB . next ;", "}", "j . m _ edgeB . prev    =    null ;", "j . m _ edgeB . next    =    null ;", "Joint . destroy ( j )  ;", "assert    ( m _ jointCount )     >     0  ;", "-  -  ( m _ jointCount )  ;", "if    ( collideConnected    =  =    false )     {", "ContactEdge   edge    =    dyB . getContactList (  )  ;", "while    ( edge    !  =    null )     {", "if    (  ( edge . other )     =  =    dyA )     {", "edge . contact . flagForFiltering (  )  ;", "}", "edge    =    edge . next ;", "}", "}", "}", "METHOD_END"], "methodName": ["destroyJoint"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "destroyParticle ( index ,    false )  ;", "}", "METHOD_END"], "methodName": ["destroyParticle"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . destroyParticle ( index ,    callDestructionListener )  ;", "}", "METHOD_END"], "methodName": ["destroyParticle"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "destroyParticlesInGroup ( group ,    false )  ;", "}", "METHOD_END"], "methodName": ["destroyParticlesInGroup"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "assert    ( isLock (  )  )     =  =    false ;", "if    ( isLock (  )  )     {", "return ;", "}", "m _ particleSystemestroyParticlesInGroup ( group ,    callDestructionListener )  ;", "}", "METHOD_END"], "methodName": ["destroyParticlesInGroup"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   destroyParticlesInShape ( shape ,    xf ,    false )  ;", "}", "METHOD_END"], "methodName": ["destroyParticlesInShape"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "assert    ( isLock (  )  )     =  =    false ;", "if    ( isLock (  )  )     {", "return    0  ;", "}", "return   m _ particleSystemestroyParticlesInShape ( shape ,    xf ,    callDestructionListener )  ;", "}", "METHOD_END"], "methodName": ["destroyParticlesInShape"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ debugDraw )     =  =    null )     {", "return ;", "}", "int   flags    =    m _ debugDraw . getFlags (  )  ;", "boolean   wireframe    =     ( flags    &     ( DebugDraw . e _ wireframeDrawingBit )  )     !  =     0  ;", "if    (  ( flags    &     ( DebugDraw . e _ shapeBit )  )     !  =     0  )     {", "for    ( Body   b    =    m _ bodyList ;    b    !  =    null ;    b    =    b . getNext (  )  )     {", "xf . set ( b . getTransform (  )  )  ;", "for    ( Fixture   f    =    b . getFixtureList (  )  ;    f    !  =    null ;    f    =    f . getNext (  )  )     {", "if    (  ( b . isActive (  )  )     =  =    false )     {", "color . set (  0  .  5 F ,     0  .  5 F ,     0  .  3 F )  ;", "drawShape ( f ,    xf ,    color ,    wireframe )  ;", "} else", "if    (  ( b . getType (  )  )     =  =     ( BodyType . STATIC )  )     {", "color . set (  0  .  5 F ,     0  .  9 F ,     0  .  3 F )  ;", "drawShape ( f ,    xf ,    color ,    wireframe )  ;", "} else", "if    (  ( b . getType (  )  )     =  =     ( BodyType . KINEMATIC )  )     {", "color . set (  0  .  5 F ,     0  .  5 F ,     0  .  9 F )  ;", "drawShape ( f ,    xf ,    color ,    wireframe )  ;", "} else", "if    (  ( b . isAwake (  )  )     =  =    false )     {", "color . set (  0  .  5 F ,     0  .  5 F ,     0  .  5 F )  ;", "drawShape ( f ,    xf ,    color ,    wireframe )  ;", "} else    {", "color . set (  0  .  9 F ,     0  .  7 F ,     0  .  7 F )  ;", "drawShape ( f ,    xf ,    color ,    wireframe )  ;", "}", "}", "}", "drawParticleSystem ( m _ particleSystem )  ;", "}", "if    (  ( flags    &     ( DebugDraw . e _ jointBit )  )     !  =     0  )     {", "for    ( Joint   j    =    m _ jointList ;    j    !  =    null ;    j    =    j . getNext (  )  )     {", "drawJoint ( j )  ;", "}", "}", "if    (  ( flags    &     ( DebugDraw . e _ pairBit )  )     !  =     0  )     {", "color . set (  0  .  3 F ,     0  .  9 F ,     0  .  9 F )  ;", "for    ( Contact   c    =    m _ contactManager . m _ contactList ;    c    !  =    null ;    c    =    c . getNext (  )  )     {", "Fixture   fixtureA    =    c . getFixtureA (  )  ;", "Fixture   fixtureB    =    c . getFixtureB (  )  ;", "fixtureA . getAABB ( c . getChildIndexA (  )  )  . getCenterToOut ( cA )  ;", "fixtureB . getAABB ( c . getChildIndexB (  )  )  . getCenterToOut ( cB )  ;", "m _ debugDraw . drawSegment ( cA ,    cB ,    color )  ;", "}", "}", "if    (  ( flags    &     ( DebugDraw . e _ aabbBit )  )     !  =     0  )     {", "color . set (  0  .  9 F ,     0  .  3 F ,     0  .  9 F )  ;", "for    ( Body   b    =    m _ bodyList ;    b    !  =    null ;    b    =    b . getNext (  )  )     {", "if    (  ( b . isActive (  )  )     =  =    false )     {", "continue ;", "}", "for    ( Fixture   f    =    b . getFixtureList (  )  ;    f    !  =    null ;    f    =    f . getNext (  )  )     {", "for    ( int   i    =     0  ;    i    <     ( f . m _ proxyCount )  ;     +  + i )     {", "FixtureProxy   proxy    =    f . m _ proxies [ i ]  ;", "AABB   aabb    =    m _ contactManager . m _ broadPhase . getFatAABB ( proxy . proxyId )  ;", "if    ( aabb    !  =    null )     {", "Vec 2  [  ]    vs    =    avs . get (  4  )  ;", "vs [  0  ]  . set ( aabb . lowerBound . x ,    aabb . lowerBound . y )  ;", "vs [  1  ]  . set ( aabb . upperBound . x ,    aabb . lowerBound . y )  ;", "vs [  2  ]  . set ( aabb . upperBound . x ,    aabb . upperBound . y )  ;", "vs [  3  ]  . set ( aabb . lowerBound . x ,    aabb . upperBound . y )  ;", "m _ debugDraw . drawPolygon ( vs ,     4  ,    color )  ;", "}", "}", "}", "}", "}", "if    (  ( flags    &     ( DebugDraw . e _ centerOfMassBit )  )     !  =     0  )     {", "for    ( Body   b    =    m _ bodyList ;    b    !  =    null ;    b    =    b . getNext (  )  )     {", "xf . set ( b . getTransform (  )  )  ;", "xf . p . set ( b . getWorldCenter (  )  )  ;", "m _ debugDraw . drawTransform ( xf )  ;", "}", "}", "if    (  ( flags    &     ( DebugDraw . e _ TreeBit )  )     !  =     0  )     {", "m _ contactManager . m _ broadPhase . drawTree ( m _ debugDraw )  ;", "}", "m _ debugDraw . flush (  )  ;", "}", "METHOD_END"], "methodName": ["drawDebugData"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "Body   bodyA    =    joint . getBodyA (  )  ;", "Body   bodyB    =    joint . getBodyB (  )  ;", "Transform   xf 1     =    bodyA . getTransform (  )  ;", "Transform   xf 2     =    bodyB . getTransform (  )  ;", "Vec 2    x 1     =    xf 1  . p ;", "Vec 2    x 2     =    xf 2  . p ;", "Vec 2    p 1     =    pool . popVec 2  (  )  ;", "Vec 2    p 2     =    pool . popVec 2  (  )  ;", "joint . getAnchorA ( p 1  )  ;", "joint . getAnchorB ( p 2  )  ;", "color . set (  0  .  5 F ,     0  .  8 F ,     0  .  8 F )  ;", "switch    ( joint . getType (  )  )     {", "case   DISTANCE    :", "m _ debugDraw . drawSegment ( p 1  ,    p 2  ,    color )  ;", "break ;", "case   PULLEY    :", "{", "PulleyJoint   pulley    =     (  ( PulleyJoint )     ( joint )  )  ;", "Vec 2    s 1     =    pulley . getGroundAnchorA (  )  ;", "Vec 2    s 2     =    pulley . getGroundAnchorB (  )  ;", "m _ debugDraw . drawSegment ( s 1  ,    p 1  ,    color )  ;", "m _ debugDraw . drawSegment ( s 2  ,    p 2  ,    color )  ;", "m _ debugDraw . drawSegment ( s 1  ,    s 2  ,    color )  ;", "}", "break ;", "case   CONSTANT _ VOLUME    :", "case   MOUSE    :", "break ;", "default    :", "m _ debugDraw . drawSegment ( x 1  ,    p 1  ,    color )  ;", "m _ debugDraw . drawSegment ( p 1  ,    p 2  ,    color )  ;", "m _ debugDraw . drawSegment ( x 2  ,    p 2  ,    color )  ;", "}", "pool . pushVec 2  (  2  )  ;", "}", "METHOD_END"], "methodName": ["drawJoint"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "boolean   wireframe    =     (  ( m _ debugDraw . getFlags (  )  )     &     ( DebugDraw . e _ wireframeDrawingBit )  )     !  =     0  ;", "int   particleCount    =    system . getParticleCount (  )  ;", "if    ( particleCount    !  =     0  )     {", "float   particleRadius    =    system . getParticleRadius (  )  ;", "Vec 2  [  ]    positionBuffer    =    system . getParticlePositionBuffer (  )  ;", "ParticleColor [  ]    colorBuffer    =    null ;", "if    (  ( system . m _ colorBuffer . data )     !  =    null )     {", "colorBuffer    =    system . getParticleColorBuffer (  )  ;", "}", "if    ( wireframe )     {", "m _ debugDraw . drawParticlesWireframe ( positionBuffer ,    particleRadius ,    colorBuffer ,    particleCount )  ;", "} else    {", "m _ debugDraw . drawParticles ( positionBuffer ,    particleRadius ,    colorBuffer ,    particleCount )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["drawParticleSystem"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "switch    ( fixture . getType (  )  )     {", "case   CIRCLE    :", "{", "CircleShape   circle    =     (  ( CircleShape )     ( fixture . getShape (  )  )  )  ;", "Transform . mulToOutUnsafe ( xf ,    circle . m _ p ,    center )  ;", "float   radius    =    circle . m _ radius ;", "xf . q . getXAxis ( axis )  ;", "if    (  (  ( fixture . getUserData (  )  )     !  =    null )     &  &     ( fixture . getUserData (  )  . equals (  . LIQUID _ INT )  )  )     {", "Body   b    =    fixture . getBody (  )  ;", "liquidOffset . set ( b . m _ linearVelocity )  ;", "float   linVelLength    =    b . m _ linearVelocity . length (  )  ;", "if    (  ( averageLinearVel )     =  =     (  -  1  )  )     {", "averageLinearVel    =    linVelLength ;", "} else    {", "averageLinearVel    =     (  0  .  9  8 F    *     ( averageLinearVel )  )     +     (  0  .  0  2 F    *    linVelLength )  ;", "}", "liquidOffset . mulLocal (  (  (  ( liquidLength )     /     ( averageLinearVel )  )     /     2  )  )  ;", "circCenterMoved . set ( center )  . addLocal ( liquidOffset )  ;", "center . subLocal ( liquidOffset )  ;", "m _ debugDraw . drawSegment ( center ,    circCenterMoved ,    liquidColor )  ;", "return ;", "}", "if    ( wireframe )     {", "m _ debugDraw . drawCircle ( center ,    radius ,    axis ,    color )  ;", "} else    {", "m _ debugDraw . drawSolidCircle ( center ,    radius ,    axis ,    color )  ;", "}", "}", "break ;", "case   POLYGON    :", "{", "PolygonShape   poly    =     (  ( PolygonShape )     ( fixture . getShape (  )  )  )  ;", "int   vertexCount    =    poly . m _ count ;", "assert   vertexCount    <  =     ( Settings . maxPolygonVertices )  ;", "Vec 2  [  ]    vertices    =    tlvertices . get ( Settings . maxPolygonVertices )  ;", "for    ( int   i    =     0  ;    i    <    vertexCount ;     +  + i )     {", "Transform . mulToOutUnsafe ( xf ,    poly . m _ vertices [ i ]  ,    vertices [ i ]  )  ;", "}", "if    ( wireframe )     {", "m _ debugDraw . drawPolygon ( vertices ,    vertexCount ,    color )  ;", "} else    {", "m _ debugDraw . drawSolidPolygon ( vertices ,    vertexCount ,    color )  ;", "}", "}", "break ;", "case   EDGE    :", "{", "EdgeShape   edge    =     (  ( EdgeShape )     ( fixture . getShape (  )  )  )  ;", "Transform . mulToOutUnsafe ( xf ,    edge . m _ vertex 1  ,    v 1  )  ;", "Transform . mulToOutUnsafe ( xf ,    edge . m _ vertex 2  ,    v 2  )  ;", "m _ debugDraw . drawSegment ( v 1  ,    v 2  ,    color )  ;", "}", "break ;", "case   CHAIN    :", "{", "ChainShape   chain    =     (  ( ChainShape )     ( fixture . getShape (  )  )  )  ;", "int   count    =    chain . m _ count ;", "Vec 2  [  ]    vertices    =    chain . m _ vertices ;", "Transform . mulToOutUnsafe ( xf ,    vertices [  0  ]  ,    v 1  )  ;", "for    ( int   i    =     1  ;    i    <    count ;     +  + i )     {", "Transform . mulToOutUnsafe ( xf ,    vertices [ i ]  ,    v 2  )  ;", "m _ debugDraw . drawSegment ( v 1  ,    v 2  ,    color )  ;", "m _ debugDraw . drawCircle ( v 1  ,     0  .  0  5 F ,    color )  ;", "v 1  . set ( v 2  )  ;", "}", "}", "break ;", "default    :", "break ;", "}", "}", "METHOD_END"], "methodName": ["drawShape"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m _ flags )     &     ( World . CLEAR _ FORCES )  )     =  =     ( World . CLEAR _ FORCES )  ;", "}", "METHOD_END"], "methodName": ["getAutoClearForces"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ bodyCount ;", "}", "METHOD_END"], "methodName": ["getBodyCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ bodyList ;", "}", "METHOD_END"], "methodName": ["getBodyList"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ contactManager . m _ contactCount ;", "}", "METHOD_END"], "methodName": ["getContactCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ contactManager . m _ contactList ;", "}", "METHOD_END"], "methodName": ["getContactList"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ contactManager ;", "}", "METHOD_END"], "methodName": ["getContactManager"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ destructionListener ;", "}", "METHOD_END"], "methodName": ["getDestructionListener"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ gravity ;", "}", "METHOD_END"], "methodName": ["getGravity"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ jointCount ;", "}", "METHOD_END"], "methodName": ["getJointCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ jointList ;", "}", "METHOD_END"], "methodName": ["getJointList"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . m _ bodyContactCount ;", "}", "METHOD_END"], "methodName": ["getParticleBodyContactCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . m _ bodyContactBuffer ;", "}", "METHOD_END"], "methodName": ["getParticleBodyContacts"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleColorBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleColorBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . m _ contactCount ;", "}", "METHOD_END"], "methodName": ["getParticleContactCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . m _ contactBuffer ;", "}", "METHOD_END"], "methodName": ["getParticleContacts"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleCount (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleDamping (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleDamping"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleDensity (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleDensity"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleDestructionListener ;", "}", "METHOD_END"], "methodName": ["getParticleDestructionListener"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleFlagsBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleFlagsBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleGravityScale (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleGravityScale"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleGroupBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleGroupBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleGroupCount (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleGroupCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleGroupList (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleGroupList"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleMaxCount (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleMaxCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticlePositionBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["getParticlePositionBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleRadius (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleRadius"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleUserDataBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleUserDataBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ particleSystem . getParticleVelocityBuffer (  )  ;", "}", "METHOD_END"], "methodName": ["getParticleVelocityBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   pool ;", "}", "METHOD_END"], "methodName": ["getPool"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ profile ;", "}", "METHOD_END"], "methodName": ["getProfile"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ contactManager . m _ broadPhase . getProxyCount (  )  ;", "}", "METHOD_END"], "methodName": ["getProxyCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ contactManager . m _ broadPhase . getTreeBalance (  )  ;", "}", "METHOD_END"], "methodName": ["getTreeBalance"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ contactManager . m _ broadPhase . getTreeHeight (  )  ;", "}", "METHOD_END"], "methodName": ["getTreeHeight"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ contactManager . m _ broadPhase . getTreeQuality (  )  ;", "}", "METHOD_END"], "methodName": ["getTreeQuality"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "addType ( pool . getCircleContactStack (  )  ,    ShapeType . CIRCLE ,    ShapeType . CIRCLE )  ;", "addType ( pool . getPolyCircleContactStack (  )  ,    ShapeType . POLYGON ,    ShapeType . CIRCLE )  ;", "addType ( pool . getPolyContactStack (  )  ,    ShapeType . POLYGON ,    ShapeType . POLYGON )  ;", "addType ( pool . getEdgeCircleContactStack (  )  ,    ShapeType . EDGE ,    ShapeType . CIRCLE )  ;", "addType ( pool . getEdgePolyContactStack (  )  ,    ShapeType . EDGE ,    ShapeType . POLYGON )  ;", "addType ( pool . getChainCircleContactStack (  )  ,    ShapeType . CHAIN ,    ShapeType . CIRCLE )  ;", "addType ( pool . getChainPolyContactStack (  )  ,    ShapeType . CHAIN ,    ShapeType . POLYGON )  ;", "}", "METHOD_END"], "methodName": ["initializeRegisters"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ allowSleep ;", "}", "METHOD_END"], "methodName": ["isAllowSleep"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ continuousPhysics ;", "}", "METHOD_END"], "methodName": ["isContinuousPhysics"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m _ flags )     &     ( World . LOCKED )  )     =  =     ( World . LOCKED )  ;", "}", "METHOD_END"], "methodName": ["isLocked"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ allowSleep ;", "}", "METHOD_END"], "methodName": ["isSleepingAllowed"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ subStepping ;", "}", "METHOD_END"], "methodName": ["isSubStepping"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "return   m _ warmStarting ;", "}", "METHOD_END"], "methodName": ["isWarmStarting"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "assert    ( isLocked (  )  )     =  =    false ;", "if    ( isLocked (  )  )     {", "return ;", "}", "m _ particleSystemoinParticleGroups ( groupA ,    groupB )  ;", "}", "METHOD_END"], "methodName": ["joinParticleGroups"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "final   ShapeType   type 1     =    fixtureA . getType (  )  ;", "final   ShapeType   type 2     =    fixtureB . getType (  )  ;", "final   ContactRegister   reg    =    contactStacks [ type 1  . ordinal (  )  ]  [ type 2  . ordinal (  )  ]  ;", "if    ( reg    !  =    null )     {", "if    ( reg . primary )     {", "Contact   c    =    reg . creator . pop (  )  ;", "c . init ( fixtureA ,    indexA ,    fixtureB ,    indexB )  ;", "return   c ;", "} else    {", "Contact   c    =    reg . creator . pop (  )  ;", "c . init ( fixtureB ,    indexB ,    fixtureA ,    indexA )  ;", "return   c ;", "}", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["popContact"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "Fixture   fixtureA    =    contact . getFixtureA (  )  ;", "Fixture   fixtureB    =    contact . getFixtureB (  )  ;", "if    (  (  (  ( contact . m _ manifold . pointCount )     >     0  )     &  &     (  !  ( fixtureA . isSensor (  )  )  )  )     &  &     (  !  ( fixtureB . isSensor (  )  )  )  )     {", "fixtureA . getBody (  )  . setAwake ( true )  ;", "fixtureB . getBody (  )  . setAwake ( true )  ;", "}", "ShapeType   type 1     =    fixtureA . getType (  )  ;", "ShapeType   type 2     =    fixtureB . getType (  )  ;", "IDStack < Contact >    creator    =    contactStacks [ type 1  . ordinal (  )  ]  [ type 2  . ordinal (  )  ]  . creator ;", "creator . push ( contact )  ;", "}", "METHOD_END"], "methodName": ["pushContact"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . queryAABB ( particleCallback ,    aabb )  ;", "}", "METHOD_END"], "methodName": ["queryAABB"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "wqwrapper . broadPhase    =    m _ contactManager . m _ broadPhase ;", "wqwrapper . callback    =    callback ;", "m _ contactManager . m _ broadPhase . query ( wqwrapper ,    aabb )  ;", "m _ particleSystem . queryAABB ( particleCallback ,    aabb )  ;", "}", "METHOD_END"], "methodName": ["queryAABB"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "wqwrapper . broadPhase    =    m _ contactManager . m _ broadPhase ;", "wqwrapper . callback    =    callback ;", "m _ contactManager . m _ broadPhase . query ( wqwrapper ,    aabb )  ;", "}", "METHOD_END"], "methodName": ["queryAABB"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . raycast ( particleCallback ,    point 1  ,    point 2  )  ;", "}", "METHOD_END"], "methodName": ["raycast"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "wrcwrapper . broadPhase    =    m _ contactManager . m _ broadPhase ;", "wrcwrapper . callback    =    callback ;", "input . maxFraction    =     1  .  0 F ;", "input . p 1  . set ( point 1  )  ;", "input . p 2  . set ( point 2  )  ;", "m _ contactManager . m _ broadPhase . raycast ( wrcwrapper ,    input )  ;", "m _ particleSystem . raycast ( particleCallback ,    point 1  ,    point 2  )  ;", "}", "METHOD_END"], "methodName": ["raycast"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "wrcwrapper . broadPhase    =    m _ contactManager . m _ broadPhase ;", "wrcwrapper . callback    =    callback ;", "input . maxFraction    =     1  .  0 F ;", "input . p 1  . set ( point 1  )  ;", "input . p 2  . set ( point 2  )  ;", "m _ contactManager . m _ broadPhase . raycast ( wrcwrapper ,    input )  ;", "}", "METHOD_END"], "methodName": ["raycast"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "if    ( flag    =  =     ( m _ allowSleep )  )     {", "return ;", "}", "m _ allowSleep    =    flag ;", "if    (  ( m _ allowSleep )     =  =    false )     {", "f    ( Body   b    =    m _ bodyList ;    b    !  =    null ;    b    =    b . m _ next )     {", "b . setAwake ( true )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setAllowSleep"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "if    ( flag )     {", "m _ flags    |  =     . CLEAR _ FORCES ;", "} else    {", "m _ flags    &  =     ~  (  . CLEAR _ FORCES )  ;", "}", "}", "METHOD_END"], "methodName": ["setAutoClearForces"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ contactManager . m _ contactFilter    =    filter ;", "}", "METHOD_END"], "methodName": ["setContactFilter"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ contactManager . m _ contactListener    =    listener ;", "}", "METHOD_END"], "methodName": ["setContactListener"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ continuousPhysics    =    flag ;", "}", "METHOD_END"], "methodName": ["setContinuousPhysics"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ debugDraw    =    debugDraw ;", "}", "METHOD_END"], "methodName": ["setDebugDraw"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ destructionListener    =    listener ;", "}", "METHOD_END"], "methodName": ["setDestructionListener"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ gravity . set ( gravity )  ;", "}", "METHOD_END"], "methodName": ["setGravity"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticleColorBuffer ( buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticleColorBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticleDamping ( damping )  ;", "}", "METHOD_END"], "methodName": ["setParticleDamping"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticleDensity ( density )  ;", "}", "METHOD_END"], "methodName": ["setParticleDensity"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleDestructionListener    =    listener ;", "}", "METHOD_END"], "methodName": ["setParticleDestructionListener"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticleFlagsBuffer ( buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticleFlagsBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticleGravityScale ( gravityScale )  ;", "}", "METHOD_END"], "methodName": ["setParticleGravityScale"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticleMaxCount ( count )  ;", "}", "METHOD_END"], "methodName": ["setParticleMaxCount"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticlePositionBuffer ( buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticlePositionBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticleRadius ( radius )  ;", "}", "METHOD_END"], "methodName": ["setParticleRadius"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticleUserDataBuffer ( buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticleUserDataBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ particleSystem . setParticleVelocityBuffer ( buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticleVelocityBuffer"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ allowSleep    =    sleepingAllowed ;", "}", "METHOD_END"], "methodName": ["setSleepingAllowed"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "this . m _ subStepping    =    subStepping ;", "}", "METHOD_END"], "methodName": ["setSubStepping"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ warmStarting    =    flag ;", "}", "METHOD_END"], "methodName": ["setWarmStarting"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "m _ profile . solveInit . startAccum (  )  ;", "m _ profile . solveVelocity . startAccum (  )  ;", "m _ profile . solvePosition . startAccum (  )  ;", "f    ( Body   b    =    m _ bodyList ;    b    !  =    null ;    b    =    b . m _ next )     {", "b . m _ xf 0  . set ( b . m _ xf )  ;", "}", "island . init ( m _ bodyCount ,    m _ contactManager . m _ contactCount ,    m _ jointCount ,    m _ contactManager . m _ contactListener )  ;", "f    ( Body   b    =    m _ bodyList ;    b    !  =    null ;    b    =    b . m _ next )     {", "b . m _ flags    &  =     ~  ( Body . e _ islandFlag )  ;", "}", "f    ( Contact   c    =    m _ contactManager . m _ contactList ;    c    !  =    null ;    c    =    c . m _ next )     {", "c . m _ flags    &  =     ~  ( Contact . ISLAND _ FLAG )  ;", "}", "f    ( Joint   j    =    m _ jointList ;    j    !  =    null ;    j    =    j . m _ next )     {", "j . m _ islandFlag    =    false ;", "}", "int   stackSize    =    m _ bodyCount ;", "if    (  ( stack . length )     <    stackSize )     {", "stack    =    new   Body [ stackSize ]  ;", "}", "f    ( Body   seed    =    m _ bodyList ;    seed    !  =    null ;    seed    =    seed . m _ next )     {", "if    (  (  ( seed . m _ flags )     &     ( Body . e _ islandFlag )  )     =  =     ( Body . e _ islandFlag )  )     {", "continue ;", "}", "if    (  (  ( seed . isAwake (  )  )     =  =    false )     |  |     (  ( seed . isActive (  )  )     =  =    false )  )     {", "continue ;", "}", "if    (  ( seed . getType (  )  )     =  =     ( BodyType . STATIC )  )     {", "continue ;", "}", "island . clear (  )  ;", "int   stackCount    =     0  ;", "stack [  ( stackCount +  +  )  ]     =    seed ;", "seed . m _ flags    |  =    Body . e _ islandFlag ;", "while    ( stackCount    >     0  )     {", "Body   b    =    stack [  (  -  - stackCount )  ]  ;", "assert    ( b . isActive (  )  )     =  =    true ;", "island . add ( b )  ;", "b . setAwake ( true )  ;", "if    (  ( b . getType (  )  )     =  =     ( BodyType . STATIC )  )     {", "continue ;", "}", "f    ( ContactEdge   ce    =    b . m _ contactList ;    ce    !  =    null ;    ce    =    ce . next )     {", "Contact   contact    =    ce . contact ;", "if    (  (  ( contact . m _ flags )     &     ( Contact . ISLAND _ FLAG )  )     =  =     ( Contact . ISLAND _ FLAG )  )     {", "continue ;", "}", "if    (  (  ( contact . isEnabled (  )  )     =  =    false )     |  |     (  ( contact . isTouching (  )  )     =  =    false )  )     {", "continue ;", "}", "boolean   sensA    =    contact . m _ fixtureA . m _ isSens ;", "boolean   sensB    =    contact . m _ fixtureB . m _ isSens ;", "if    ( sensA    |  |    sensB )     {", "continue ;", "}", "island . add ( contact )  ;", "contact . m _ flags    |  =    Contact . ISLAND _ FLAG ;", "Body   other    =    ce . other ;", "if    (  (  ( other . m _ flags )     &     ( Body . e _ islandFlag )  )     =  =     ( Body . e _ islandFlag )  )     {", "continue ;", "}", "assert   stackCount    <    stackSize ;", "stack [  ( stackCount +  +  )  ]     =    other ;", "other . m _ flags    |  =    Body . e _ islandFlag ;", "}", "f    ( JointEdge   je    =    b . m _ jointList ;    je    !  =    null ;    je    =    je . next )     {", "if    (  ( je . joint . m _ islandFlag )     =  =    true )     {", "continue ;", "}", "Body   other    =    je . other ;", "if    (  ( other . isActive (  )  )     =  =    false )     {", "continue ;", "}", "island . add ( je . joint )  ;", "je . joint . m _ islandFlag    =    true ;", "if    (  (  ( other . m _ flags )     &     ( Body . e _ islandFlag )  )     =  =     ( Body . e _ islandFlag )  )     {", "continue ;", "}", "assert   stackCount    <    stackSize ;", "stack [  ( stackCount +  +  )  ]     =    other ;", "other . m _ flags    |  =    Body . e _ islandFlag ;", "}", "}", "island . solve ( m _ profile ,    step ,    m _ gravity ,    m _ allowSleep )  ;", "f    ( int   i    =     0  ;    i    <     ( island . m _ bodyCount )  ;     +  + i )     {", "Body   b    =    island . m _ bodies [ i ]  ;", "if    (  ( b . getType (  )  )     =  =     ( BodyType . STATIC )  )     {", "b . m _ flags    &  =     ~  ( Body . e _ islandFlag )  ;", "}", "}", "}", "m _ profile . solveInit . endAccum (  )  ;", "m _ profile . solveVelocity . endAccum (  )  ;", "m _ profile . solvePosition . endAccum (  )  ;", "broadphaseTimer . reset (  )  ;", "f    ( Body   b    =    m _ bodyList ;    b    !  =    null ;    b    =    b . getNext (  )  )     {", "if    (  (  ( b . m _ flags )     &     ( Body . e _ islandFlag )  )     =  =     0  )     {", "continue ;", "}", "if    (  ( b . getType (  )  )     =  =     ( BodyType . STATIC )  )     {", "continue ;", "}", "b . synchronizeFixtures (  )  ;", "}", "m _ contactManager . findNewContacts (  )  ;", "m _ profile . broadphase . recd ( broadphaseTimer . getMilliseconds (  )  )  ;", "}", "METHOD_END"], "methodName": ["solve"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "final   Island   island    =    toiIsland ;", "island . init (  (  2     *     ( Settings . maxTOIContacts )  )  ,    Settings . maxTOIContacts ,     0  ,    m _ contactManager . m _ contactListener )  ;", "if    ( m _ stepComplete )     {", "for    ( Body   b    =    m _ bodyList ;    b    !  =    null ;    b    =    b . m _ next )     {", "b . m _ flags    &  =     ~  ( Body . e _ islandFlag )  ;", "b . m _ sweep . alpha 0     =     0  .  0 F ;", "}", "for    ( Contact   c    =    m _ contactManager . m _ contactList ;    c    !  =    null ;    c    =    c . m _ next )     {", "c . m _ flags    &  =     ~  (  ( Contact . TOI _ FLAG )     |     ( Contact . ISLAND _ FLAG )  )  ;", "c . m _ toiCount    =     0  ;", "c . m _ toi    =     1  .  0 F ;", "}", "}", "for    (  ;     ;  )     {", "Contact   minContact    =    null ;", "float   minAlpha    =     1  .  0 F ;", "for    ( Contact   c    =    m _ contactManager . m _ contactList ;    c    !  =    null ;    c    =    c . m _ next )     {", "if    (  ( c . isEnabled (  )  )     =  =    false )     {", "continue ;", "}", "if    (  ( c . m _ toiCount )     >     ( Settings . maxSubSteps )  )     {", "continue ;", "}", "float   alpha    =     1  .  0 F ;", "if    (  (  ( c . m _ flags )     &     ( Contact . TOI _ FLAG )  )     !  =     0  )     {", "alpha    =    c . m _ toi ;", "} else    {", "Fixture   fA    =    c . getFixtureA (  )  ;", "Fixture   fB    =    c . getFixtureB (  )  ;", "if    (  ( fA . isSensor (  )  )     |  |     ( fB . isSensor (  )  )  )     {", "continue ;", "}", "Body   bA    =    fA . getBody (  )  ;", "Body   bB    =    fB . getBody (  )  ;", "BodyType   typeA    =    bA . m _ type ;", "BodyType   typeB    =    bB . m _ type ;", "assert    ( typeA    =  =     ( BodyType . DYNAMIC )  )     |  |     ( typeB    =  =     ( BodyType . DYNAMIC )  )  ;", "boolean   activeA    =     ( bA . isAwake (  )  )     &  &     ( typeA    !  =     ( BodyType . STATIC )  )  ;", "boolean   activeB    =     ( bB . isAwake (  )  )     &  &     ( typeB    !  =     ( BodyType . STATIC )  )  ;", "if    (  ( activeA    =  =    false )     &  &     ( activeB    =  =    false )  )     {", "continue ;", "}", "boolean   collideA    =     ( bA . isBullet (  )  )     |  |     ( typeA    !  =     ( BodyType . DYNAMIC )  )  ;", "boolean   collideB    =     ( bB . isBullet (  )  )     |  |     ( typeB    !  =     ( BodyType . DYNAMIC )  )  ;", "if    (  ( collideA    =  =    false )     &  &     ( collideB    =  =    false )  )     {", "continue ;", "}", "float   alpha 0     =    bA . m _ sweep . alpha 0  ;", "if    (  ( bA . m _ sweep . alpha 0  )     <     ( bB . m _ sweep . alpha 0  )  )     {", "alpha 0     =    bB . m _ sweep . alpha 0  ;", "bA . m _ sweep . advance ( alpha 0  )  ;", "} else", "if    (  ( bB . m _ sweep . alpha 0  )     <     ( bA . m _ sweep . alpha 0  )  )     {", "alpha 0     =    bA . m _ sweep . alpha 0  ;", "bB . m _ sweep . advance ( alpha 0  )  ;", "}", "assert   alpha 0     <     1  .  0 F ;", "int   indexA    =    c . getChildIndexA (  )  ;", "int   indexB    =    c . getChildIndexB (  )  ;", "final   TimeOfImpact . TOIInput   input    =    toiInput ;", "input . proxyA . set ( fA . getShape (  )  ,    indexA )  ;", "input . proxyB . set ( fB . getShape (  )  ,    indexB )  ;", "input . sweepA . set ( bA . m _ sweep )  ;", "input . sweepB . set ( bB . m _ sweep )  ;", "input . tMax    =     1  .  0 F ;", "pool . getTimeOfImpact (  )  . timeOfImpact ( toiOutput ,    input )  ;", "float   beta    =    toiOutput . t ;", "if    (  ( toiOutput . state )     =  =     ( TimeOfImpact . TOIOutputState . TOUCHING )  )     {", "alpha    =    MathUtils . min (  ( alpha 0     +     (  (  1  .  0 F    -    alpha 0  )     *    beta )  )  ,     1  .  0 F )  ;", "} else    {", "alpha    =     1  .  0 F ;", "}", "c . m _ toi    =    alpha ;", "c . m _ flags    |  =    Contact . TOI _ FLAG ;", "}", "if    ( alpha    <    minAlpha )     {", "minContact    =    c ;", "minAlpha    =    alpha ;", "}", "}", "if    (  ( minContact    =  =    null )     |  |     (  (  1  .  0 F    -     (  1  0  .  0 F    *     ( Settings . EPSILON )  )  )     <    minAlpha )  )     {", "m _ stepComplete    =    true ;", "break ;", "}", "Fixture   fA    =    minContact . getFixtureA (  )  ;", "Fixture   fB    =    minContact . getFixtureB (  )  ;", "Body   bA    =    fA . getBody (  )  ;", "Body   bB    =    fB . getBody (  )  ;", "backup 1  . set ( bA . m _ sweep )  ;", "backup 2  . set ( bB . m _ sweep )  ;", "bA . advance ( minAlpha )  ;", "bB . advance ( minAlpha )  ;", "minContact . update ( m _ contactManager . m _ contactListener )  ;", "minContact . m _ flags    &  =     ~  ( Contact . TOI _ FLAG )  ;", "+  +  ( minContact . m _ toiCount )  ;", "if    (  (  ( minContact . isEnabled (  )  )     =  =    false )     |  |     (  ( minContact . isTouching (  )  )     =  =    false )  )     {", "minContact . setEnabled ( false )  ;", "bA . m _ sweep . set ( backup 1  )  ;", "bB . m _ sweep . set ( backup 2  )  ;", "bA . synchronizeTransform (  )  ;", "bB . synchronizeTransform (  )  ;", "continue ;", "}", "bA . setAwake ( true )  ;", "bB . setAwake ( true )  ;", "island . clear (  )  ;", "island . add ( bA )  ;", "island . add ( bB )  ;", "island . add ( minContact )  ;", "bA . m _ flags    |  =    Body . e _ islandFlag ;", "bB . m _ flags    |  =    Body . e _ islandFlag ;", "minContact . m _ flags    |  =    Contact . ISLAND _ FLAG ;", "tempBodies [  0  ]     =    bA ;", "tempBodies [  1  ]     =    bB ;", "for    ( int   i    =     0  ;    i    <     2  ;     +  + i )     {", "Body   body    =    tempBodies [ i ]  ;", "if    (  ( body . m _ type )     =  =     ( BodyType . DYNAMIC )  )     {", "for    ( ContactEdge   ce    =    body . m _ contactList ;    ce    !  =    null ;    ce    =    ce . next )     {", "if    (  ( island . m _ bodyCount )     =  =     ( island . m _ bodyCapacity )  )     {", "break ;", "}", "if    (  ( island . m _ contactCount )     =  =     ( island . m _ contactCapacity )  )     {", "break ;", "}", "Contact   contact    =    ce . contact ;", "if    (  (  ( contact . m _ flags )     &     ( Contact . ISLAND _ FLAG )  )     !  =     0  )     {", "continue ;", "}", "Body   other    =    ce . other ;", "if    (  (  (  ( other . m _ type )     =  =     ( BodyType . DYNAMIC )  )     &  &     (  ( body . isBullet (  )  )     =  =    false )  )     &  &     (  ( other . isBullet (  )  )     =  =    false )  )     {", "continue ;", "}", "boolean   sensorA    =    contact . m _ fixtureA . m _ isSensor ;", "boolean   sensorB    =    contact . m _ fixtureB . m _ isSensor ;", "if    ( sensorA    |  |    sensorB )     {", "continue ;", "}", "backup 1  . set ( other . m _ sweep )  ;", "if    (  (  ( other . m _ flags )     &     ( Body . e _ islandFlag )  )     =  =     0  )     {", "other . advance ( minAlpha )  ;", "}", "contact . update ( m _ contactManager . m _ contactListener )  ;", "if    (  ( contact . isEnabled (  )  )     =  =    false )     {", "other . m _ sweep . set ( backup 1  )  ;", "other . synchronizeTransform (  )  ;", "continue ;", "}", "if    (  ( contact . isTouching (  )  )     =  =    false )     {", "other . m _ sweep . set ( backup 1  )  ;", "other . synchronizeTransform (  )  ;", "continue ;", "}", "contact . m _ flags    |  =    Contact . ISLAND _ FLAG ;", "island . add ( contact )  ;", "if    (  (  ( other . m _ flags )     &     ( Body . e _ islandFlag )  )     !  =     0  )     {", "continue ;", "}", "other . m _ flags    |  =    Body . e _ islandFlag ;", "if    (  ( other . m _ type )     !  =     ( BodyType . STATIC )  )     {", "other . setAwake ( true )  ;", "}", "island . add ( other )  ;", "}", "}", "}", "subStep . dt    =     (  1  .  0 F    -    minAlpha )     *     ( step . dt )  ;", "subStep . inv _ dt    =     1  .  0 F    /     ( subStep . dt )  ;", "subStep . dtRatio    =     1  .  0 F ;", "subStep . positionIterations    =     2  0  ;", "subStep . velocityIterations    =    step . velocityIterations ;", "subStep . warmStarting    =    false ;", "island . solveTOI ( subStep ,    bA . m _ islandIndex ,    bB . m _ islandIndex )  ;", "for    ( int   i    =     0  ;    i    <     ( island . m _ bodyCount )  ;     +  + i )     {", "Body   body    =    island . m _ bodies [ i ]  ;", "body . m _ flags    &  =     ~  ( Body . e _ islandFlag )  ;", "if    (  ( body . m _ type )     !  =     ( BodyType . DYNAMIC )  )     {", "continue ;", "}", "body . synchronizeFixtures (  )  ;", "for    ( ContactEdge   ce    =    body . m _ contactList ;    ce    !  =    null ;    ce    =    ce . next )     {", "ce . contact . m _ flags    &  =     ~  (  ( Contact . TOI _ FLAG )     |     ( Contact . ISLAND _ FLAG )  )  ;", "}", "}", "m _ contactManager . findNewContacts (  )  ;", "if    ( m _ subStepping )     {", "m _ stepComplete    =    false ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["solveTOI"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "stepTimer . reset (  )  ;", "tempTimer . reset (  )  ;", "if    (  (  ( m _ flags )     &     (  . NEW _ FIXTURE )  )     =  =     (  . NEW _ FIXTURE )  )     {", "m _ contactManager . findNewContacts (  )  ;", "m _ flags    &  =     ~  (  . NEW _ FIXTURE )  ;", "}", "m _ flags    |  =     . LOCKED ;", "step . dt    =    dt ;", "step . velocityIterations    =    velocityIterations ;", "step . positionIterations    =    positionIterations ;", "if    ( dt    >     0  .  0 F )     {", "step . inv _ dt    =     1  .  0 F    /    dt ;", "} else    {", "step . inv _ dt    =     0  .  0 F ;", "}", "step . dtRatio    =     ( m _ inv _ dt 0  )     *    dt ;", "step . warmStarting    =    m _ warmStarting ;", "m _ profile . stepInit . record ( tempTimer . getMilliseconds (  )  )  ;", "tempTimer . reset (  )  ;", "m _ contactManager . collide (  )  ;", "m _ profile . collide . record ( tempTimer . getMilliseconds (  )  )  ;", "if    (  ( m _ stepComplete )     &  &     (  ( step . dt )     >     0  .  0 F )  )     {", "tempTimer . reset (  )  ;", "m _ particleSystem . solve ( step )  ;", "m _ profile . solveParticleSystem . record ( tempTimer . getMilliseconds (  )  )  ;", "tempTimer . reset (  )  ;", "solve ( step )  ;", "m _ profile . solve . record ( tempTimer . getMilliseconds (  )  )  ;", "}", "if    (  ( m _ continuousPhysics )     &  &     (  ( step . dt )     >     0  .  0 F )  )     {", "tempTimer . reset (  )  ;", "solveTOI ( step )  ;", "m _ profile . solveTOI . record ( tempTimer . getMilliseconds (  )  )  ;", "}", "if    (  ( step . dt )     >     0  .  0 F )     {", "m _ inv _ dt 0     =    step . inv _ dt ;", "}", "if    (  (  ( m _ flags )     &     (  . CLEAR _ FORCES )  )     =  =     (  . CLEAR _ FORCES )  )     {", "clearForces (  )  ;", "}", "m _ flags    &  =     ~  (  . LOCKED )  ;", "m _ profile . step . record ( stepTimer . getMilliseconds (  )  )  ;", "}", "METHOD_END"], "methodName": ["step"], "fileName": "org.jbox2d.dynamics.World"}, {"methodBody": ["METHOD_START", "{", "FixtureProxy   proxy    =     (  ( FixtureProxy )     ( broadPhase . getUserData ( nodeId )  )  )  ;", "return   callback . reportFixture ( proxy . fixture )  ;", "}", "METHOD_END"], "methodName": ["treeCallback"], "fileName": "org.jbox2d.dynamics.WorldQueryWrapper"}, {"methodBody": ["METHOD_START", "{", "Object   userData    =    broadPhase . getUserData ( nodeId )  ;", "FixtureProxy   proxy    =     (  ( FixtureProxy )     ( userData )  )  ;", "Fixture   fixture    =    proxy . fixture ;", "int   index    =    proxy . childIndex ;", "boolean   hit    =    fixture . rayc ( output ,    input ,    index )  ;", "if    ( hit )     {", "float   fraction    =    output . fraction ;", "temp . set ( input . p 2  )  . mulLocal ( fraction )  ;", "point . set ( input . p 1  )  . mulLocal (  (  1     -    fraction )  )  . addLocal ( temp )  ;", "return   callback . reportFixture ( fixture ,    point ,    output . normal ,    fraction )  ;", "}", "return   input . maxFraction ;", "}", "METHOD_END"], "methodName": ["raycastCallback"], "fileName": "org.jbox2d.dynamics.WorldRayCastWrapper"}, {"methodBody": ["METHOD_START", "{", "super . init ( fixtureA ,     0  ,    fixtureB ,     0  )  ;", "assert    ( m _ fixtureA . getType (  )  )     =  =     ( ShapeTypeILE )  ;", "assert    ( m _ fixtureB . getType (  )  )     =  =     ( ShapeTypeILE )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jbox2d.dynamics.contacts.CircleContact"}, {"methodBody": ["METHOD_START", "{", "m _ flags    |  =    Contact . FILTER _ FLAG ;", "}", "METHOD_END"], "methodName": ["flagForFiltering"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   m _ indexA ;", "}", "METHOD_END"], "methodName": ["getChildIndexA"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   m _ indexB ;", "}", "METHOD_END"], "methodName": ["getChildIndexB"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   m _ fixtureA ;", "}", "METHOD_END"], "methodName": ["getFixtureA"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   m _ fixtureB ;", "}", "METHOD_END"], "methodName": ["getFixtureB"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   m _ friction ;", "}", "METHOD_END"], "methodName": ["getFriction"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   m _ manifold ;", "}", "METHOD_END"], "methodName": ["getManifold"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   m _ next ;", "}", "METHOD_END"], "methodName": ["getNext"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   m _ restitution ;", "}", "METHOD_END"], "methodName": ["getRestitution"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   m _ tangentSpeed ;", "}", "METHOD_END"], "methodName": ["getTangentSpeed"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "final   Body   bodyA    =    m _ fixtureA . getBody (  )  ;", "final   Body   bodyB    =    m _ fixtureB . getBody (  )  ;", "final   Shape   shapeA    =    m _ fixtureA . getShape (  )  ;", "final   Shape   shapeB    =    m _ fixtureB . getShape (  )  ;", "worldManifold . initialize ( m _ manifold ,    bodyA . getTransform (  )  ,    shapeA . m _ radius ,    bodyB . getTransform (  )  ,    shapeB . m _ radius )  ;", "}", "METHOD_END"], "methodName": ["getWorldManifold"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "m _ flags    =    Contact . ENABLED _ FLAG ;", "m _ fixtureA    =    fA ;", "m _ fixtureB    =    fB ;", "m _ indexA    =    indexA ;", "m _ indexB    =    indexB ;", "m _ manifold . pointCount    =     0  ;", "m _ prev    =    null ;", "m _ next    =    null ;", "m _ nodeA    =    null ;", "m _ nodeA . prev    =    null ;", "m _ nodeA . next    =    null ;", "m _ nodeA . other    =    null ;", "m _ nodeB    =    null ;", "m _ nodeB . prev    =    null ;", "m _ nodeB . next    =    null ;", "m _ nodeB . other    =    null ;", "m _ toiCount    =     0  ;", "m _ friction    =    Contact . mixFriction ( fA . m _ friction ,    fB . m _ friction )  ;", "m _ restitution    =    Contact . mixRestitution ( fA . m _ restitution ,    fB . m _ restitution )  ;", "m _ tangentSpeed    =     0  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m _ flags )     &     ( Contact . ENABLED _ FLAG )  )     =  =     ( Contact . ENABLED _ FLAG )  ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return    (  ( m _ flags )     &     ( Contact . TOUCHING _ FLAG )  )     =  =     ( Contact . TOUCHING _ FLAG )  ;", "}", "METHOD_END"], "methodName": ["isTouching"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   MathUtils . sqrt (  ( friction 1     *    friction 2  )  )  ;", "}", "METHOD_END"], "methodName": ["mixFriction"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "return   restitution 1     >    restitution 2     ?    restitution 1     :    restitution 2  ;", "}", "METHOD_END"], "methodName": ["mixRestitution"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "m _ friction    =    Contact . mixFriction ( m _ fixtureA . m _ friction ,    m _ fixtureB . m _ friction )  ;", "}", "METHOD_END"], "methodName": ["resetFriction"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "m _ restitution    =    Contact . mixRestitution ( m _ fixtureA . m _ restitution ,    m _ fixtureB . m _ restitution )  ;", "}", "METHOD_END"], "methodName": ["resetRestitution"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "if    ( flag )     {", "m _ flags    |  =     . ENABLED _ FLAG ;", "} else    {", "m _ flags    &  =     ~  (  . ENABLED _ FLAG )  ;", "}", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "m _ friction    =    friction ;", "}", "METHOD_END"], "methodName": ["setFriction"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "m _ restitution    =    restitution ;", "}", "METHOD_END"], "methodName": ["setRestitution"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "m _ tangentSpeed    =    speed ;", "}", "METHOD_END"], "methodName": ["setTangentSpeed"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "oldManifold . set ( m _ manifold )  ;", "m _ flags    |  =     . ENABLED _ FLAG ;", "boolean   touching    =    false ;", "boolean   wasTouching    =     (  ( m _ flags )     &     (  . TOUCHING _ FLAG )  )     =  =     (  . TOUCHING _ FLAG )  ;", "boolean   sensorA    =    m _ fixtureA . isSensor (  )  ;", "boolean   sensorB    =    m _ fixtureB . isSensor (  )  ;", "boolean   sensor    =    sensorA    |  |    sensorB ;", "Body   bodyA    =    m _ fixtureA . getBody (  )  ;", "Body   bodyB    =    m _ fixtureB . getBody (  )  ;", "Transform   xfA    =    bodyA . getTransform (  )  ;", "Transform   xfB    =    bodyB . getTransform (  )  ;", "if    ( sensor )     {", "Shape   shapeA    =    m _ fixtureA . getShape (  )  ;", "Shape   shapeB    =    m _ fixtureB . getShape (  )  ;", "touching    =    pool . getCollision (  )  . testOverlap ( shapeA ,    m _ indexA ,    shapeB ,    m _ indexB ,    xfA ,    xfB )  ;", "m _ manifold . pointCount    =     0  ;", "} else    {", "evaluate ( m _ manifold ,    xfA ,    xfB )  ;", "touching    =     ( m _ manifold . pointCount )     >     0  ;", "for    ( int   i    =     0  ;    i    <     ( m _ manifold . pointCount )  ;     +  + i )     {", "ManifoldPoint   mp 2     =    m _ manifold . points [ i ]  ;", "mp 2  . normalImpulse    =     0  .  0 F ;", "mp 2  . tangentImpulse    =     0  .  0 F ;", "ID   id 2     =    mp 2  . id ;", "for    ( int   j    =     0  ;    j    <     ( oldManifold . pointCount )  ;     +  + j )     {", "ManifoldPoint   mp 1     =    oldManifold . points [ j ]  ;", "if    ( mp 1  . id . isEqual ( id 2  )  )     {", "mp 2  . normalImpulse    =    mp 1  . normalImpulse ;", "mp 2  . tangentImpulse    =    mp 1  . tangentImpulse ;", "break ;", "}", "}", "}", "if    ( touching    !  =    wasTouching )     {", "bodyA . setAwake ( true )  ;", "bodyB . setAwake ( true )  ;", "}", "}", "if    ( touching )     {", "m _ flags    |  =     . TOUCHING _ FLAG ;", "} else    {", "m _ flags    &  =     ~  (  . TOUCHING _ FLAG )  ;", "}", "if    ( listener    =  =    null )     {", "return ;", "}", "if    (  ( wasTouching    =  =    false )     &  &     ( touching    =  =    true )  )     {", "listener . begin ( this )  ;", "}", "if    (  ( wasTouching    =  =    true )     &  &     ( touching    =  =    false )  )     {", "listener . end ( this )  ;", "}", "if    (  ( sensor    =  =    false )     &  &    touching )     {", "listener . preSolve ( this ,    oldManifold )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.jbox2d.dynamics.contacts.Contact"}, {"methodBody": ["METHOD_START", "{", "m _ step    =    def . step ;", "m _ count    =    def . count ;", "if    (  ( m _ positionConstraints . length )     <     ( m _ count )  )     {", "ContactPositionConstraint [  ]    old    =    m _ positionConstraints ;", "m _ positionConstraints    =    new   ContactPositionConstraint [ MathUtils . max (  (  ( old . length )     *     2  )  ,    m _ count )  ]  ;", "System . arraycopy ( old ,     0  ,    m _ positionConstraints ,     0  ,    old . length )  ;", "for    ( int   i    =    old . length ;    i    <     ( m _ positionConstraints . length )  ;    i +  +  )     {", "m _ positionConstraints [ i ]     =    new   ContactPositionConstraint (  )  ;", "}", "}", "if    (  ( m _ velocityConstraints . length )     <     ( m _ count )  )     {", "ContactVelocityConstraint [  ]    old    =    m _ velocityConstraints ;", "m _ velocityConstraints    =    new   ContactVelocityConstraint [ MathUtils . max (  (  ( old . length )     *     2  )  ,    m _ count )  ]  ;", "System . arraycopy ( old ,     0  ,    m _ velocityConstraints ,     0  ,    old . length )  ;", "for    ( int   i    =    old . length ;    i    <     ( m _ velocityConstraints . length )  ;    i +  +  )     {", "m _ velocityConstraints [ i ]     =    new   ContactVelocityConstraint (  )  ;", "}", "}", "m _ positions    =    def . positions ;", "m _ velocities    =    def . velocities ;", "m    =    def ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "final   Contact   contact    =    m [ i ]  ;", "final   Fixture   fixtureA    =    contact . m _ fixtureA ;", "final   Fixture   fixtureB    =    contact . m _ fixtureB ;", "final   Shape   shapeA    =    fixtureA . getShape (  )  ;", "final   Shape   shapeB    =    fixtureB . getShape (  )  ;", "final   float   radiusA    =    shapeA . m _ radius ;", "final   float   radiusB    =    shapeB . m _ radius ;", "final   Body   bodyA    =    fixtureA . getBody (  )  ;", "final   Body   bodyB    =    fixtureB . getBody (  )  ;", "final   Manifold   manifold    =    contact . getManifold (  )  ;", "int   pointCount    =    manifold . pointCount ;", "assert   pointCount    >     0  ;", "ContactVelocityConstraint   vc    =    m _ velocityConstraints [ i ]  ;", "vc . friction    =    contact . m _ friction ;", "vc . restitution    =    contact . m _ restitution ;", "vc . tangentSpeed    =    contact . m _ tangentSpeed ;", "vc . indexA    =    bodyA . m _ islandIndex ;", "vc . indexB    =    bodyB . m _ islandIndex ;", "vc . invMassA    =    bodyA . m _ invMass ;", "vc . invMassB    =    bodyB . m _ invMass ;", "vc . invIA    =    bodyA . m _ invI ;", "vc . invIB    =    bodyB . m _ invI ;", "vc . contactIndex    =    i ;", "vc . pointCount    =    pointCount ;", "vc . K . setZero (  )  ;", "vc . normalMass . setZero (  )  ;", "ContactPositionConstraint   pc    =    m _ positionConstraints [ i ]  ;", "pc . indexA    =    bodyA . m _ islandIndex ;", "pc . indexB    =    bodyB . m _ islandIndex ;", "pc . invMassA    =    bodyA . m _ invMass ;", "pc . invMassB    =    bodyB . m _ invMass ;", "pc . localCenterA . set ( bodyA . m _ sweep . localCenter )  ;", "pc . localCenterB . set ( bodyB . m _ sweep . localCenter )  ;", "pc . invIA    =    bodyA . m _ invI ;", "pc . invIB    =    bodyB . m _ invI ;", "pc . localNormal . set ( manifold . localNormal )  ;", "pc . localPoint . set ( manifold . localPoint )  ;", "pc . pointCount    =    pointCount ;", "pc . radiusA    =    radiusA ;", "pc . radiusB    =    radiusB ;", "pc . type    =    manifold . type ;", "for    ( int   j    =     0  ;    j    <    pointCount ;    j +  +  )     {", "ManifoldPoint   cp    =    manifold . points [ j ]  ;", "ContactVelocityConstraint . VelocityConstraintPoint   vcp    =    vc . points [ j ]  ;", "if    ( m _ step . warmStarting )     {", "vcp . normalImpulse    =     ( m _ step . dtRatio )     *     ( cp . normalImpulse )  ;", "vcp . tangentImpulse    =     ( m _ step . dtRatio )     *     ( cp . tangentImpulse )  ;", "} else    {", "vcp . normalImpulse    =     0  ;", "vcp . tangentImpulse    =     0  ;", "}", "vcp . rA . setZero (  )  ;", "vcp . rB . setZero (  )  ;", "vcp . normalMass    =     0  ;", "vcp . tangentMass    =     0  ;", "vcp . velocityBias    =     0  ;", "pc . localPoints [ j ]  . x    =    cp . localPoint . x ;", "pc . localPoints [ j ]  . y    =    cp . localPoint . y ;", "}", "}", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jbox2d.dynamics.contacts.ContactSolver"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "ContactVelocityConstraint   vc    =    m _ velocityConstraints [ i ]  ;", "ContactPositionConstraint   pc    =    m _ positionConstraints [ i ]  ;", "float   radiusA    =    pc . radiusA ;", "float   radiusB    =    pc . radiusB ;", "Manifold   manifold    =    m _ contacts [ vc . contactIndex ]  . getManifold (  )  ;", "int   indexA    =    vc . indexA ;", "int   indexB    =    vc . indexB ;", "float   mA    =    vc . invMassA ;", "float   mB    =    vc . invMassB ;", "float   iA    =    vc . invIA ;", "float   iB    =    vc . invIB ;", "Vec 2    localCenterA    =    pc . localCenterA ;", "Vec 2    localCenterB    =    pc . localCenterB ;", "Vec 2    cA    =    m _ positions [ indexA ]  . c ;", "float   aA    =    m _ positions [ indexA ]  . a ;", "Vec 2    vA    =    m _ velocities [ indexA ]  . v ;", "float   wA    =    m _ velocities [ indexA ]  . w ;", "Vec 2    cB    =    m _ positions [ indexB ]  . c ;", "float   aB    =    m _ positions [ indexB ]  . a ;", "Vec 2    vB    =    m _ velocities [ indexB ]  . v ;", "float   wB    =    m _ velocities [ indexB ]  . w ;", "assert    ( manifold . pointCount )     >     0  ;", "final   Rot   xfAq    =    xfA . q ;", "final   Rot   xfBq    =    xfB . q ;", "xfAq . set ( aA )  ;", "xfBq . set ( aB )  ;", "xfA . p . x    =     ( cA . x )     -     (  (  ( xfAq . c )     *     ( localCenterA . x )  )     -     (  ( xfAq . s )     *     ( localCenterA . y )  )  )  ;", "xfA . p . y    =     ( cA . y )     -     (  (  ( xfAq . s )     *     ( localCenterA . x )  )     +     (  ( xfAq . c )     *     ( localCenterA . y )  )  )  ;", "xfB . p . x    =     ( cB . x )     -     (  (  ( xfBq . c )     *     ( localCenterB . x )  )     -     (  ( xfBq . s )     *     ( localCenterB . y )  )  )  ;", "xfB . p . y    =     ( cB . y )     -     (  (  ( xfBq . s )     *     ( localCenterB . x )  )     +     (  ( xfBq . c )     *     ( localCenterB . y )  )  )  ;", "worldManifold . initialize ( manifold ,    xfA ,    radiusA ,    xfB ,    radiusB )  ;", "final   Vec 2    vcnormal    =    vc . normal ;", "vcnormal . x    =    worldManifold . normal . x ;", "vcnormal . y    =    worldManifold . normal . y ;", "int   pointCount    =    vc . pointCount ;", "for    ( int   j    =     0  ;    j    <    pointCount ;     +  + j )     {", "ContactVelocityConstraint . VelocityConstraintPoint   vcp    =    vc . points [ j ]  ;", "Vec 2    wmPj    =    worldManifold . points [ j ]  ;", "final   Vec 2    vcprA    =    vcp . rA ;", "final   Vec 2    vcprB    =    vcp . rB ;", "vcprA . x    =     ( wmPj . x )     -     ( cA . x )  ;", "vcprA . y    =     ( wmPj . y )     -     ( cA . y )  ;", "vcprB . x    =     ( wmPj . x )     -     ( cB . x )  ;", "vcprB . y    =     ( wmPj . y )     -     ( cB . y )  ;", "float   rnA    =     (  ( vcprA . x )     *     ( vcnormal . y )  )     -     (  ( vcprA . y )     *     ( vcnormal . x )  )  ;", "float   rnB    =     (  ( vcprB . x )     *     ( vcnormal . y )  )     -     (  ( vcprB . y )     *     ( vcnormal . x )  )  ;", "float   kNormal    =     (  ( mA    +    mB )     +     (  ( iA    *    rnA )     *    rnA )  )     +     (  ( iB    *    rnB )     *    rnB )  ;", "vcp . normalMass    =     ( kNormal    >     0  .  0 F )     ?     1  .  0 F    /    kNormal    :     0  .  0 F ;", "float   tangentx    =     1  .  0 F    *     ( vcnormal . y )  ;", "float   tangenty    =     (  -  1  .  0 F )     *     ( vcnormal . x )  ;", "float   rtA    =     (  ( vcprA . x )     *    tangenty )     -     (  ( vcprA . y )     *    tangentx )  ;", "float   rtB    =     (  ( vcprB . x )     *    tangenty )     -     (  ( vcprB . y )     *    tangentx )  ;", "float   kTangent    =     (  ( mA    +    mB )     +     (  ( iA    *    rtA )     *    rtA )  )     +     (  ( iB    *    rtB )     *    rtB )  ;", "vcp . tangentMass    =     ( kTangent    >     0  .  0 F )     ?     1  .  0 F    /    kTangent    :     0  .  0 F ;", "vcp . velocityBias    =     0  .  0 F ;", "float   tempx    =     (  (  ( vB . x )     +     (  (  - wB )     *     ( vcprB . y )  )  )     -     ( vA . x )  )     -     (  (  - wA )     *     ( vcprA . y )  )  ;", "float   tempy    =     (  (  ( vB . y )     +     ( wB    *     ( vcprB . x )  )  )     -     ( vA . y )  )     -     ( wA    *     ( vcprA . x )  )  ;", "float   vRel    =     (  ( vcnormal . x )     *    tempx )     +     (  ( vcnormal . y )     *    tempy )  ;", "if    ( vRel    <     (  -  ( Settings . velocityThreshold )  )  )     {", "vcp . velocityBias    =     (  -  ( vc . restitution )  )     *    vRel ;", "}", "}", "if    (  ( vc . pointCount )     =  =     2  )     {", "ContactVelocityConstraint . VelocityConstraintPoint   vcp 1     =    vc . points [  0  ]  ;", "ContactVelocityConstraint . VelocityConstraintPoint   vcp 2     =    vc . points [  1  ]  ;", "float   rn 1 A    =     (  ( vcp 1  . rA . x )     *     ( vcnormal . y )  )     -     (  ( vcp 1  . rA . y )     *     ( vcnormal . x )  )  ;", "float   rn 1 B    =     (  ( vcp 1  . rB . x )     *     ( vcnormal . y )  )     -     (  ( vcp 1  . rB . y )     *     ( vcnormal . x )  )  ;", "float   rn 2 A    =     (  ( vcp 2  . rA . x )     *     ( vcnormal . y )  )     -     (  ( vcp 2  . rA . y )     *     ( vcnormal . x )  )  ;", "float   rn 2 B    =     (  ( vcp 2  . rB . x )     *     ( vcnormal . y )  )     -     (  ( vcp 2  . rB . y )     *     ( vcnormal . x )  )  ;", "float   k 1  1     =     (  ( mA    +    mB )     +     (  ( iA    *    rn 1 A )     *    rn 1 A )  )     +     (  ( iB    *    rn 1 B )     *    rn 1 B )  ;", "float   k 2  2     =     (  ( mA    +    mB )     +     (  ( iA    *    rn 2 A )     *    rn 2 A )  )     +     (  ( iB    *    rn 2 B )     *    rn 2 B )  ;", "float   k 1  2     =     (  ( mA    +    mB )     +     (  ( iA    *    rn 1 A )     *    rn 2 A )  )     +     (  ( iB    *    rn 1 B )     *    rn 2 B )  ;", "if    (  ( k 1  1     *    k 1  1  )     <     (  (  . k _ maxConditionNumber )     *     (  ( k 1  1     *    k 2  2  )     -     ( k 1  2     *    k 1  2  )  )  )  )     {", "vc . K . ex . x    =    k 1  1  ;", "vc . K . ex . y    =    k 1  2  ;", "vc . K . ey . x    =    k 1  2  ;", "vc . K . ey . y    =    k 2  2  ;", "vc . K . invertToOut ( vc . normalMass )  ;", "} else    {", "vc . pointCount    =     1  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["initializeVelocityConstraints"], "fileName": "org.jbox2d.dynamics.contacts.ContactSolver"}, {"methodBody": ["METHOD_START", "{", "float   minSeparation    =     0  .  0 F ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "PositionConstraint   pc    =    m _ positionConstraints [ i ]  ;", "int   indexA    =    pc . indexA ;", "int   indexB    =    pc . indexB ;", "float   mA    =    pc . invMassA ;", "float   iA    =    pc . invIA ;", "Vec 2    localCenterA    =    pc . localCenterA ;", "final   float   localCenterAx    =    localCenterA . x ;", "final   float   localCenterAy    =    localCenterA . y ;", "float   mB    =    pc . invMassB ;", "float   iB    =    pc . invIB ;", "Vec 2    localCenterB    =    pc . localCenterB ;", "final   float   localCenterBx    =    localCenterB . x ;", "final   float   localCenterBy    =    localCenterB . y ;", "int   pointCount    =    pc . pointCount ;", "Vec 2    cA    =    m _ positions [ indexA ]  . c ;", "float   aA    =    m _ positions [ indexA ]  . a ;", "Vec 2    cB    =    m _ positions [ indexB ]  . c ;", "float   aB    =    m _ positions [ indexB ]  . a ;", "for    ( int   j    =     0  ;    j    <    pointCount ;     +  + j )     {", "final   Rot   xfAq    =    xfA . q ;", "final   Rot   xfBq    =    xfB . q ;", "xfAq . set ( aA )  ;", "xfBq . set ( aB )  ;", "xfA . p . x    =     (  ( cA . x )     -     (  ( xfAq . c )     *    localCenterAx )  )     +     (  ( xfAq . s )     *    localCenterAy )  ;", "xfA . p . y    =     (  ( cA . y )     -     (  ( xfAq . s )     *    localCenterAx )  )     -     (  ( xfAq . c )     *    localCenterAy )  ;", "xfB . p . x    =     (  ( cB . x )     -     (  ( xfBq . c )     *    localCenterBx )  )     +     (  ( xfBq . s )     *    localCenterBy )  ;", "xfB . p . y    =     (  ( cB . y )     -     (  ( xfBq . s )     *    localCenterBx )  )     -     (  ( xfBq . c )     *    localCenterBy )  ;", "final   PositionSolverManifold   psm    =    psolver ;", "psm . initialize ( pc ,    xfA ,    xfB ,    j )  ;", "final   Vec 2    normal    =    psm . normal ;", "final   Vec 2    point    =    psm . point ;", "final   float   separation    =    psm . separation ;", "float   rAx    =     ( point . x )     -     ( cA . x )  ;", "float   rAy    =     ( point . y )     -     ( cA . y )  ;", "float   rBx    =     ( point . x )     -     ( cB . x )  ;", "float   rBy    =     ( point . y )     -     ( cB . y )  ;", "minSeparation    =    MathUtils . min ( minSeparation ,    separation )  ;", "final   float   C    =    MathUtils . clamp (  (  ( Settings . baumgarte )     *     ( separation    +     ( Settings . linearSlop )  )  )  ,     (  -  ( Settings . maxLinearCorrection )  )  ,     0  .  0 F )  ;", "final   float   rnA    =     ( rAx    *     ( normal . y )  )     -     ( rAy    *     ( normal . x )  )  ;", "final   float   rnB    =     ( rBx    *     ( normal . y )  )     -     ( rBy    *     ( normal . x )  )  ;", "final   float   K    =     (  ( mA    +    mB )     +     (  ( iA    *    rnA )     *    rnA )  )     +     (  ( iB    *    rnB )     *    rnB )  ;", "final   float   impulse    =     ( K    >     0  .  0 F )     ?     (  - C )     /    K    :     0  .  0 F ;", "float   Px    =     ( normal . x )     *    impulse ;", "float   Py    =     ( normal . y )     *    impulse ;", "cA . x    -  =    Px    *    mA ;", "cA . y    -  =    Py    *    mA ;", "aA    -  =    iA    *     (  ( rAx    *    Py )     -     ( rAy    *    Px )  )  ;", "cB . x    +  =    Px    *    mB ;", "cB . y    +  =    Py    *    mB ;", "aB    +  =    iB    *     (  ( rBx    *    Py )     -     ( rBy    *    Px )  )  ;", "}", "m _ positions [ indexA ]  . a    =    aA ;", "m _ positions [ indexB ]  . a    =    aB ;", "}", "return   minSeparation    >  =     (  (  -  3  .  0 F )     *     ( Settings . linearSlop )  )  ;", "}", "METHOD_END"], "methodName": ["solvePositionConstraints"], "fileName": "org.jbox2d.dynamics.contacts.ContactSolver"}, {"methodBody": ["METHOD_START", "{", "float   minSeparation    =     0  .  0 F ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "PositionConstraint   pc    =    m _ positionConstraints [ i ]  ;", "int   indexA    =    pc . indexA ;", "int   indexB    =    pc . indexB ;", "Vec 2    localCenterA    =    pc . localCenterA ;", "Vec 2    localCenterB    =    pc . localCenterB ;", "final   float   localCenterAx    =    localCenterA . x ;", "final   float   localCenterAy    =    localCenterA . y ;", "final   float   localCenterBx    =    localCenterB . x ;", "final   float   localCenterBy    =    localCenterB . y ;", "int   pointCount    =    pc . pointCount ;", "float   mA    =     0  .  0 F ;", "float   iA    =     0  .  0 F ;", "if    (  ( indexA    =  =    toiIndexA )     |  |     ( indexA    =  =    toiIndexB )  )     {", "mA    =    pc . invMassA ;", "iA    =    pc . invIA ;", "}", "float   mB    =     0  .  0 F ;", "float   iB    =     0  .  0 F ;", "if    (  ( indexB    =  =    toiIndexA )     |  |     ( indexB    =  =    toiIndexB )  )     {", "mB    =    pc . invMassB ;", "iB    =    pc . invIB ;", "}", "Vec 2    cA    =    m _ positions [ indexA ]  . c ;", "float   aA    =    m _ positions [ indexA ]  . a ;", "Vec 2    cB    =    m _ positions [ indexB ]  . c ;", "float   aB    =    m _ positions [ indexB ]  . a ;", "for    ( int   j    =     0  ;    j    <    pointCount ;     +  + j )     {", "final   Rot   xfAq    =    xfA . q ;", "final   Rot   xfBq    =    xfB . q ;", "xfAq . set ( aA )  ;", "xfBq . set ( aB )  ;", "xfA . p . x    =     (  ( cA . x )     -     (  ( xfAq . c )     *    localCenterAx )  )     +     (  ( xfAq . s )     *    localCenterAy )  ;", "xfA . p . y    =     (  ( cA . y )     -     (  ( xfAq . s )     *    localCenterAx )  )     -     (  ( xfAq . c )     *    localCenterAy )  ;", "xfB . p . x    =     (  ( cB . x )     -     (  ( xfBq . c )     *    localCenterBx )  )     +     (  ( xfBq . s )     *    localCenterBy )  ;", "xfB . p . y    =     (  ( cB . y )     -     (  ( xfBq . s )     *    localCenterBx )  )     -     (  ( xfBq . c )     *    localCenterBy )  ;", "final   PositionSolverManifold   psm    =    psolver ;", "psm . initialize ( pc ,    xfA ,    xfB ,    j )  ;", "Vec 2    normal    =    psm . normal ;", "Vec 2    point    =    psm . point ;", "float   separation    =    psm . separation ;", "float   rAx    =     ( point . x )     -     ( cA . x )  ;", "float   rAy    =     ( point . y )     -     ( cA . y )  ;", "float   rBx    =     ( point . x )     -     ( cB . x )  ;", "float   rBy    =     ( point . y )     -     ( cB . y )  ;", "minSeparation    =    MathUtils . min ( minSeparation ,    separation )  ;", "float   C    =    MathUtils . clamp (  (  ( Settings . toiBaugarte )     *     ( separation    +     ( Settings . linearSlop )  )  )  ,     (  -  ( Settings . maxLinearCorrection )  )  ,     0  .  0 F )  ;", "float   rnA    =     ( rAx    *     ( normal . y )  )     -     ( rAy    *     ( normal . x )  )  ;", "float   rnB    =     ( rBx    *     ( normal . y )  )     -     ( rBy    *     ( normal . x )  )  ;", "float   K    =     (  ( mA    +    mB )     +     (  ( iA    *    rnA )     *    rnA )  )     +     (  ( iB    *    rnB )     *    rnB )  ;", "float   impulse    =     ( K    >     0  .  0 F )     ?     (  - C )     /    K    :     0  .  0 F ;", "float   Px    =     ( normal . x )     *    impulse ;", "float   Py    =     ( normal . y )     *    impulse ;", "cA . x    -  =    Px    *    mA ;", "cA . y    -  =    Py    *    mA ;", "aA    -  =    iA    *     (  ( rAx    *    Py )     -     ( rAy    *    Px )  )  ;", "cB . x    +  =    Px    *    mB ;", "cB . y    +  =    Py    *    mB ;", "aB    +  =    iB    *     (  ( rBx    *    Py )     -     ( rBy    *    Px )  )  ;", "}", "m _ positions [ indexA ]  . a    =    aA ;", "m _ positions [ indexB ]  . a    =    aB ;", "}", "return   minSeparation    >  =     (  (  -  1  .  5 F )     *     ( Settings . linearSlop )  )  ;", "}", "METHOD_END"], "methodName": ["solveTOIPositionConstraints"], "fileName": "org.jbox2d.dynamics.contacts.ContactSolver"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "final   ContactVelocityConstraint   vc    =    m _ velocityConstraints [ i ]  ;", "int   indexA    =    vc . indexA ;", "int   indexB    =    vc . indexB ;", "float   mA    =    vc . invMassA ;", "float   mB    =    vc . invMassB ;", "float   iA    =    vc . invIA ;", "float   iB    =    vc . invIB ;", "int   pointCount    =    vc . pointCount ;", "Vec 2    vA    =    m _ velocities [ indexA ]  . v ;", "float   wA    =    m _ velocities [ indexA ]  . w ;", "Vec 2    vB    =    m _ velocities [ indexB ]  . v ;", "float   wB    =    m _ velocities [ indexB ]  . w ;", "Vec 2    normal    =    vc . normal ;", "final   float   normalx    =    normal . x ;", "final   float   normaly    =    normal . y ;", "float   tangentx    =     1  .  0 F    *     ( vc . normal . y )  ;", "float   tangenty    =     (  -  1  .  0 F )     *     ( vc . normal . x )  ;", "final   float   friction    =    vc . friction ;", "assert    ( pointCount    =  =     1  )     |  |     ( pointCount    =  =     2  )  ;", "for    ( int   j    =     0  ;    j    <    pointCount ;     +  + j )     {", "final   ContactVelocityConstraint . VelocityConstraintPoint   vcp    =    vc . points [ j ]  ;", "final   Vec 2    a    =    vcp . rA ;", "float   dvx    =     (  (  (  (  - wB )     *     ( vcp . rB . y )  )     +     ( vB . x )  )     -     ( vA . x )  )     +     ( wA    *     ( a . y )  )  ;", "float   dvy    =     (  (  ( wB    *     ( vcp . rB . x )  )     +     ( vB . y )  )     -     ( vA . y )  )     -     ( wA    *     ( a . x )  )  ;", "final   float   vt    =     (  ( dvx    *    tangentx )     +     ( dvy    *    tangenty )  )     -     ( vc . tangentSpeed )  ;", "float   lambda    =     ( vcp . tangentMass )     *     (  - vt )  ;", "final   float   maxFriction    =    friction    *     ( vcp . normalImpulse )  ;", "final   float   newImpulse    =    MathUtils . clamp (  (  ( vcp . tangentImpulse )     +    lambda )  ,     (  - maxFriction )  ,    maxFriction )  ;", "lambda    =    newImpulse    -     ( vcp . tangentImpulse )  ;", "vcp . tangentImpulse    =    newImpulse ;", "final   float   Px    =    tangentx    *    lambda ;", "final   float   Py    =    tangenty    *    lambda ;", "vA . x    -  =    Px    *    mA ;", "vA . y    -  =    Py    *    mA ;", "wA    -  =    iA    *     (  (  ( vcp . rA . x )     *    Py )     -     (  ( vcp . rA . y )     *    Px )  )  ;", "vB . x    +  =    Px    *    mB ;", "vB . y    +  =    Py    *    mB ;", "wB    +  =    iB    *     (  (  ( vcp . rB . x )     *    Py )     -     (  ( vcp . rB . y )     *    Px )  )  ;", "}", "if    (  ( vc . pointCount )     =  =     1  )     {", "final   ContactVelocityConstraint . VelocityConstraintPoint   vcp    =    vc . points [  0  ]  ;", "float   dvx    =     (  (  (  (  - wB )     *     ( vcp . rB . y )  )     +     ( vB . x )  )     -     ( vA . x )  )     +     ( wA    *     ( vcp . rA . y )  )  ;", "float   dvy    =     (  (  ( wB    *     ( vcp . rB . x )  )     +     ( vB . y )  )     -     ( vA . y )  )     -     ( wA    *     ( vcp . rA . x )  )  ;", "final   float   vn    =     ( dvx    *    normalx )     +     ( dvy    *    normaly )  ;", "float   lambda    =     (  -  ( vcp . normalMass )  )     *     ( vn    -     ( vcp . velocityBias )  )  ;", "float   a    =     ( vcp . normalImpulse )     +    lambda ;", "final   float   newImpulse    =     ( a    >     0  .  0 F )     ?    a    :     0  .  0 F ;", "lambda    =    newImpulse    -     ( vcp . normalImpulse )  ;", "vcp . normalImpulse    =    newImpulse ;", "float   Px    =    normalx    *    lambda ;", "float   Py    =    normaly    *    lambda ;", "vA . x    -  =    Px    *    mA ;", "vA . y    -  =    Py    *    mA ;", "wA    -  =    iA    *     (  (  ( vcp . rA . x )     *    Py )     -     (  ( vcp . rA . y )     *    Px )  )  ;", "vB . x    +  =    Px    *    mB ;", "vB . y    +  =    Py    *    mB ;", "wB    +  =    iB    *     (  (  ( vcp . rB . x )     *    Py )     -     (  ( vcp . rB . y )     *    Px )  )  ;", "} else    {", "final   ContactVelocityConstraint . VelocityConstraintPoint   cp 1     =    vc . points [  0  ]  ;", "final   ContactVelocityConstraint . VelocityConstraintPoint   cp 2     =    vc . points [  1  ]  ;", "final   Vec 2    cp 1 rA    =    cp 1  . rA ;", "final   Vec 2    cp 1 rB    =    cp 1  . rB ;", "final   Vec 2    cp 2 rA    =    cp 2  . rA ;", "final   Vec 2    cp 2 rB    =    cp 2  . rB ;", "float   ax    =    cp 1  . normalImpulse ;", "float   ay    =    cp 2  . normalImpulse ;", "assert    ( ax    >  =     0  .  0 F )     &  &     ( ay    >  =     0  .  0 F )  ;", "float   dv 1 x    =     (  (  (  (  - wB )     *     ( cp 1 rB . y )  )     +     ( vB . x )  )     -     ( vA . x )  )     +     ( wA    *     ( cp 1 rA . y )  )  ;", "float   dv 1 y    =     (  (  ( wB    *     ( cp 1 rB . x )  )     +     ( vB . y )  )     -     ( vA . y )  )     -     ( wA    *     ( cp 1 rA . x )  )  ;", "float   dv 2 x    =     (  (  (  (  - wB )     *     ( cp 2 rB . y )  )     +     ( vB . x )  )     -     ( vA . x )  )     +     ( wA    *     ( cp 2 rA . y )  )  ;", "float   dv 2 y    =     (  (  ( wB    *     ( cp 2 rB . x )  )     +     ( vB . y )  )     -     ( vA . y )  )     -     ( wA    *     ( cp 2 rA . x )  )  ;", "float   vn 1     =     ( dv 1 x    *    normalx )     +     ( dv 1 y    *    normaly )  ;", "float   vn 2     =     ( dv 2 x    *    normalx )     +     ( dv 2 y    *    normaly )  ;", "float   bx    =    vn 1     -     ( cp 1  . velocityBias )  ;", "float   by    =    vn 2     -     ( cp 2  . velocityBias )  ;", "Mat 2  2    R    =    vc . K ;", "bx    -  =     (  ( R . ex . x )     *    ax )     +     (  ( R . ey . x )     *    ay )  ;", "by    -  =     (  ( R . ex . y )     *    ax )     +     (  ( R . ey . y )     *    ay )  ;", "for    (  ;     ;  )     {", "Mat 2  2    R 1     =    vc . normalMass ;", "float   xx    =     (  ( R 1  . ex . x )     *    bx )     +     (  ( R 1  . ey . x )     *    by )  ;", "float   xy    =     (  ( R 1  . ex . y )     *    bx )     +     (  ( R 1  . ey . y )     *    by )  ;", "xx    *  =     -  1  ;", "xy    *  =     -  1  ;", "if    (  ( xx    >  =     0  .  0 F )     &  &     ( xy    >  =     0  .  0 F )  )     {", "float   dx    =    xx    -    ax ;", "float   dy    =    xy    -    ay ;", "float   P 1 x    =    dx    *    normalx ;", "float   P 1 y    =    dx    *    normaly ;", "float   P 2 x    =    dy    *    normalx ;", "float   P 2 y    =    dy    *    normaly ;", "vA . x    -  =    mA    *     ( P 1 x    +    P 2 x )  ;", "vA . y    -  =    mA    *     ( P 1 y    +    P 2 y )  ;", "vB . x    +  =    mB    *     ( P 1 x    +    P 2 x )  ;", "vB . y    +  =    mB    *     ( P 1 y    +    P 2 y )  ;", "wA    -  =    iA    *     (  (  (  ( cp 1 rA . x )     *    P 1 y )     -     (  ( cp 1 rA . y )     *    P 1 x )  )     +     (  (  ( cp 2 rA . x )     *    P 2 y )     -     (  ( cp 2 rA . y )     *    P 2 x )  )  )  ;", "wB    +  =    iB    *     (  (  (  ( cp 1 rB . x )     *    P 1 y )     -     (  ( cp 1 rB . y )     *    P 1 x )  )     +     (  (  ( cp 2 rB . x )     *    P 2 y )     -     (  ( cp 2 rB . y )     *    P 2 x )  )  )  ;", "cp 1  . normalImpulse    =    xx ;", "cp 2  . normalImpulse    =    xy ;", "if    (  . DEBUG _ SOLVER )     {", "Vec 2    dv 1     =    vB . add ( Vec 2  . cross ( wB ,    cp 1 rB )  . subLocal ( vA )  . subLocal ( Vec 2  . cross ( wA ,    cp 1 rA )  )  )  ;", "Vec 2    dv 2     =    vB . add ( Vec 2  . cross ( wB ,    cp 2 rB )  . subLocal ( vA )  . subLocal ( Vec 2  . cross ( wA ,    cp 2 rA )  )  )  ;", "vn 1     =    Vec 2  . dot ( dv 1  ,    normal )  ;", "vn 2     =    Vec 2  . dot ( dv 2  ,    normal )  ;", "assert    ( MathUtils . abs (  ( vn 1     -     ( cp 1  . velocityBias )  )  )  )     <     (  . k _ errorTol )  ;", "assert    ( MathUtils . abs (  ( vn 2     -     ( cp 2  . velocityBias )  )  )  )     <     (  . k _ errorTol )  ;", "}", "break ;", "}", "xx    =     (  -  ( cp 1  . normalMass )  )     *    bx ;", "xy    =     0  .  0 F ;", "vn 1     =     0  .  0 F ;", "vn 2     =     (  ( vc . K . ex . y )     *    xx )     +    by ;", "if    (  ( xx    >  =     0  .  0 F )     &  &     ( vn 2     >  =     0  .  0 F )  )     {", "float   dx    =    xx    -    ax ;", "float   dy    =    xy    -    ay ;", "float   P 1 x    =    normalx    *    dx ;", "float   P 1 y    =    normaly    *    dx ;", "float   P 2 x    =    normalx    *    dy ;", "float   P 2 y    =    normaly    *    dy ;", "vA . x    -  =    mA    *     ( P 1 x    +    P 2 x )  ;", "vA . y    -  =    mA    *     ( P 1 y    +    P 2 y )  ;", "vB . x    +  =    mB    *     ( P 1 x    +    P 2 x )  ;", "vB . y    +  =    mB    *     ( P 1 y    +    P 2 y )  ;", "wA    -  =    iA    *     (  (  (  ( cp 1 rA . x )     *    P 1 y )     -     (  ( cp 1 rA . y )     *    P 1 x )  )     +     (  (  ( cp 2 rA . x )     *    P 2 y )     -     (  ( cp 2 rA . y )     *    P 2 x )  )  )  ;", "wB    +  =    iB    *     (  (  (  ( cp 1 rB . x )     *    P 1 y )     -     (  ( cp 1 rB . y )     *    P 1 x )  )     +     (  (  ( cp 2 rB . x )     *    P 2 y )     -     (  ( cp 2 rB . y )     *    P 2 x )  )  )  ;", "cp 1  . normalImpulse    =    xx ;", "cp 2  . normalImpulse    =    xy ;", "if    (  . DEBUG _ SOLVER )     {", "Vec 2    dv 1     =    vB . add ( Vec 2  . cross ( wB ,    cp 1 rB )  . subLocal ( vA )  . subLocal ( Vec 2  . cross ( wA ,    cp 1 rA )  )  )  ;", "vn 1     =    Vec 2  . dot ( dv 1  ,    normal )  ;", "assert    ( MathUtils . abs (  ( vn 1     -     ( cp 1  . velocityBias )  )  )  )     <     (  . k _ errorTol )  ;", "}", "break ;", "}", "xx    =     0  .  0 F ;", "xy    =     (  -  ( cp 2  . normalMass )  )     *    by ;", "vn 1     =     (  ( vc . K . ey . x )     *    xy )     +    bx ;", "vn 2     =     0  .  0 F ;", "if    (  ( xy    >  =     0  .  0 F )     &  &     ( vn 1     >  =     0  .  0 F )  )     {", "float   dx    =    xx    -    ax ;", "float   dy    =    xy    -    ay ;", "float   P 1 x    =    normalx    *    dx ;", "float   P 1 y    =    normaly    *    dx ;", "float   P 2 x    =    normalx    *    dy ;", "float   P 2 y    =    normaly    *    dy ;", "vA . x    -  =    mA    *     ( P 1 x    +    P 2 x )  ;", "vA . y    -  =    mA    *     ( P 1 y    +    P 2 y )  ;", "vB . x    +  =    mB    *     ( P 1 x    +    P 2 x )  ;", "vB . y    +  =    mB    *     ( P 1 y    +    P 2 y )  ;", "wA    -  =    iA    *     (  (  (  ( cp 1 rA . x )     *    P 1 y )     -     (  ( cp 1 rA . y )     *    P 1 x )  )     +     (  (  ( cp 2 rA . x )     *    P 2 y )     -     (  ( cp 2 rA . y )     *    P 2 x )  )  )  ;", "wB    +  =    iB    *     (  (  (  ( cp 1 rB . x )     *    P 1 y )     -     (  ( cp 1 rB . y )     *    P 1 x )  )     +     (  (  ( cp 2 rB . x )     *    P 2 y )     -     (  ( cp 2 rB . y )     *    P 2 x )  )  )  ;", "cp 1  . normalImpulse    =    xx ;", "cp 2  . normalImpulse    =    xy ;", "if    (  . DEBUG _ SOLVER )     {", "Vec 2    dv 2     =    vB . add ( Vec 2  . cross ( wB ,    cp 2 rB )  . subLocal ( vA )  . subLocal ( Vec 2  . cross ( wA ,    cp 2 rA )  )  )  ;", "vn 2     =    Vec 2  . dot ( dv 2  ,    normal )  ;", "assert    ( MathUtils . abs (  ( vn 2     -     ( cp 2  . velocityBias )  )  )  )     <     (  . k _ errorTol )  ;", "}", "break ;", "}", "xx    =     0  .  0 F ;", "xy    =     0  .  0 F ;", "vn 1     =    bx ;", "vn 2     =    by ;", "if    (  ( vn 1     >  =     0  .  0 F )     &  &     ( vn 2     >  =     0  .  0 F )  )     {", "float   dx    =    xx    -    ax ;", "float   dy    =    xy    -    ay ;", "float   P 1 x    =    normalx    *    dx ;", "float   P 1 y    =    normaly    *    dx ;", "float   P 2 x    =    normalx    *    dy ;", "float   P 2 y    =    normaly    *    dy ;", "vA . x    -  =    mA    *     ( P 1 x    +    P 2 x )  ;", "vA . y    -  =    mA    *     ( P 1 y    +    P 2 y )  ;", "vB . x    +  =    mB    *     ( P 1 x    +    P 2 x )  ;", "vB . y    +  =    mB    *     ( P 1 y    +    P 2 y )  ;", "wA    -  =    iA    *     (  (  (  ( cp 1 rA . x )     *    P 1 y )     -     (  ( cp 1 rA . y )     *    P 1 x )  )     +     (  (  ( cp 2 rA . x )     *    P 2 y )     -     (  ( cp 2 rA . y )     *    P 2 x )  )  )  ;", "wB    +  =    iB    *     (  (  (  ( cp 1 rB . x )     *    P 1 y )     -     (  ( cp 1 rB . y )     *    P 1 x )  )     +     (  (  ( cp 2 rB . x )     *    P 2 y )     -     (  ( cp 2 rB . y )     *    P 2 x )  )  )  ;", "cp 1  . normalImpulse    =    xx ;", "cp 2  . normalImpulse    =    xy ;", "break ;", "}", "break ;", "}", "}", "m _ velocities [ indexA ]  . w    =    wA ;", "m _ velocities [ indexB ]  . w    =    wB ;", "}", "}", "METHOD_END"], "methodName": ["solveVelocityConstraints"], "fileName": "org.jbox2d.dynamics.contacts.ContactSolver"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "final   ContactVelocityConstraint   vc    =    m _ velocityConstraints [ i ]  ;", "final   Manifold   manifold    =    ms [ vcIndex ]  . getManifold (  )  ;", "for    ( int   j    =     0  ;    j    <     ( vc . pointCount )  ;    j +  +  )     {", "manifold . points [ j ]  . normalImpulse    =    vc . points [ j ]  . normalImpulse ;", "manifold . points [ j ]  . tangentImpulse    =    vc . points [ j ]  . tangentImpulse ;", "}", "}", "}", "METHOD_END"], "methodName": ["storeImpulses"], "fileName": "org.jbox2d.dynamics.contacts.ContactSolver"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;     +  + i )     {", "final   VelocityConstraint   vc    =    m _ velocityConstraints [ i ]  ;", "int   indexA    =    vc . indexA ;", "int   indexB    =    vc . indexB ;", "float   mA    =    vc . invMassA ;", "float   iA    =    vc . invIA ;", "float   mB    =    vc . invMassB ;", "float   iB    =    vc . invIB ;", "int   pointCount    =    vc . pointCount ;", "Vec 2    vA    =    m _ velocities [ indexA ]  . v ;", "float   wA    =    m _ velocities [ indexA ]  . w ;", "Vec 2    vB    =    m _ velocities [ indexB ]  . v ;", "float   wB    =    m _ velocities [ indexB ]  . w ;", "Vec 2    normal    =    vc . normal ;", "float   tangentx    =     1  .  0 F    *     ( normal . y )  ;", "float   tangenty    =     (  -  1  .  0 F )     *     ( normal . x )  ;", "for    ( int   j    =     0  ;    j    <    pointCount ;     +  + j )     {", "VelocityConstraint . VelocityConstraintPoint   vcp    =    vc . points [ j ]  ;", "float   Px    =     ( tangentx    *     ( vcp . tangentImpulse )  )     +     (  ( normal . x )     *     ( vcp . normalImpulse )  )  ;", "float   Py    =     ( tangenty    *     ( vcp . tangentImpulse )  )     +     (  ( normal . y )     *     ( vcp . normalImpulse )  )  ;", "wA    -  =    iA    *     (  (  ( vcp . rA . x )     *    Py )     -     (  ( vcp . rA . y )     *    Px )  )  ;", "vA . x    -  =    Px    *    mA ;", "vA . y    -  =    Py    *    mA ;", "wB    +  =    iB    *     (  (  ( vcp . rB . x )     *    Py )     -     (  ( vcp . rB . y )     *    Px )  )  ;", "vB . x    +  =    Px    *    mB ;", "vB . y    +  =    Py    *    mB ;", "}", "m _ velocities [ indexA ]  . w    =    wA ;", "m _ velocities [ indexB ]  . w    =    wB ;", "}", "}", "METHOD_END"], "methodName": ["warmStart"], "fileName": "org.jbox2d.dynamics.contacts.ContactSolver"}, {"methodBody": ["METHOD_START", "{", "super . init ( fixtureA ,     0  ,    fixtureB ,     0  )  ;", "assert    ( m _ fixtureA . getType (  )  )     =  =     ( ShapeTypeOLYGON )  ;", "assert    ( m _ fixtureB . getType (  )  )     =  =     ( ShapeType . CIRCLE )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jbox2d.dynamics.contacts.PolygonAndCircleContact"}, {"methodBody": ["METHOD_START", "{", "super . init ( fixtureA ,     0  ,    fixtureB ,     0  )  ;", "assert    ( m _ fixtureA . getType (  )  )     =  =     ( ShapeTypeOLYGON )  ;", "assert    ( m _ fixtureB . getType (  )  )     =  =     ( ShapeTypeOLYGON )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.jbox2d.dynamics.contacts.PolygonContact"}, {"methodBody": ["METHOD_START", "{", "assert    ( pc . pointCount )     >     0  ;", "final   Rot   xfAq    =    xfA . q ;", "final   Rot   xfBq    =    xfB . q ;", "final   Vec 2    pcLocalPointsI    =    pc . localPoints [ index ]  ;", "switch    ( pc . type )     {", "case   CIRCLES    :", "{", "final   Vec 2    plocalPoint    =    pc . localPoint ;", "final   Vec 2    pLocalPoints 0     =    pc . localPoints [  0  ]  ;", "final   float   pointAx    =     (  (  ( xfAq . c )     *     ( plocalPoint . x )  )     -     (  ( xfAq . s )     *     ( plocalPoint . y )  )  )     +     ( xfA . p . x )  ;", "final   float   pointAy    =     (  (  ( xfAq . s )     *     ( plocalPoint . x )  )     +     (  ( xfAq . c )     *     ( plocalPoint . y )  )  )     +     ( xfA . p . y )  ;", "final   float   pointBx    =     (  (  ( xfBq . c )     *     ( pLocalPoints 0  . x )  )     -     (  ( xfBq . s )     *     ( pLocalPoints 0  . y )  )  )     +     ( xfB . p . x )  ;", "final   float   pointBy    =     (  (  ( xfBq . s )     *     ( pLocalPoints 0  . x )  )     +     (  ( xfBq . c )     *     ( pLocalPoints 0  . y )  )  )     +     ( xfB . p . y )  ;", "normal . x    =    pointBx    -    pointAx ;", "normal . y    =    pointBy    -    pointAy ;", "normal . normalize (  )  ;", "point . x    =     ( pointAx    +    pointBx )     *     0  .  5 F ;", "point . y    =     ( pointAy    +    pointBy )     *     0  .  5 F ;", "final   float   tempx    =    pointBx    -    pointAx ;", "final   float   tempy    =    pointBy    -    pointAy ;", "separa    =     (  (  ( tempx    *     ( normal . x )  )     +     ( tempy    *     ( normal . y )  )  )     -     ( pc . radiusA )  )     -     ( pc . radiusB )  ;", "break ;", "}", "case   FACE _ A    :", "{", "final   Vec 2    pcLocalNormal    =    pc . localNormal ;", "final   Vec 2    pcLocalPoint    =    pc . localPoint ;", "normal . x    =     (  ( xfAq . c )     *     ( pcLocalNormal . x )  )     -     (  ( xfAq . s )     *     ( pcLocalNormal . y )  )  ;", "normal . y    =     (  ( xfAq . s )     *     ( pcLocalNormal . x )  )     +     (  ( xfAq . c )     *     ( pcLocalNormal . y )  )  ;", "final   float   planePointx    =     (  (  ( xfAq . c )     *     ( pcLocalPoint . x )  )     -     (  ( xfAq . s )     *     ( pcLocalPoint . y )  )  )     +     ( xfA . p . x )  ;", "final   float   planePointy    =     (  (  ( xfAq . s )     *     ( pcLocalPoint . x )  )     +     (  ( xfAq . c )     *     ( pcLocalPoint . y )  )  )     +     ( xfA . p . y )  ;", "final   float   clipPointx    =     (  (  ( xfBq . c )     *     ( pcLocalPointsI . x )  )     -     (  ( xfBq . s )     *     ( pcLocalPointsI . y )  )  )     +     ( xfB . p . x )  ;", "final   float   clipPointy    =     (  (  ( xfBq . s )     *     ( pcLocalPointsI . x )  )     +     (  ( xfBq . c )     *     ( pcLocalPointsI . y )  )  )     +     ( xfB . p . y )  ;", "final   float   tempx    =    clipPointx    -    planePointx ;", "final   float   tempy    =    clipPointy    -    planePointy ;", "separa    =     (  (  ( tempx    *     ( normal . x )  )     +     ( tempy    *     ( normal . y )  )  )     -     ( pc . radiusA )  )     -     ( pc . radiusB )  ;", "point . x    =    clipPointx ;", "point . y    =    clipPointy ;", "break ;", "}", "case   FACE _ B    :", "{", "final   Vec 2    pcLocalNormal    =    pc . localNormal ;", "final   Vec 2    pcLocalPoint    =    pc . localPoint ;", "normal . x    =     (  ( xfBq . c )     *     ( pcLocalNormal . x )  )     -     (  ( xfBq . s )     *     ( pcLocalNormal . y )  )  ;", "normal . y    =     (  ( xfBq . s )     *     ( pcLocalNormal . x )  )     +     (  ( xfBq . c )     *     ( pcLocalNormal . y )  )  ;", "final   float   planePointx    =     (  (  ( xfBq . c )     *     ( pcLocalPoint . x )  )     -     (  ( xfBq . s )     *     ( pcLocalPoint . y )  )  )     +     ( xfB . p . x )  ;", "final   float   planePointy    =     (  (  ( xfBq . s )     *     ( pcLocalPoint . x )  )     +     (  ( xfBq . c )     *     ( pcLocalPoint . y )  )  )     +     ( xfB . p . y )  ;", "final   float   clipPointx    =     (  (  ( xfAq . c )     *     ( pcLocalPointsI . x )  )     -     (  ( xfAq . s )     *     ( pcLocalPointsI . y )  )  )     +     ( xfA . p . x )  ;", "final   float   clipPointy    =     (  (  ( xfAq . s )     *     ( pcLocalPointsI . x )  )     +     (  ( xfAq . c )     *     ( pcLocalPointsI . y )  )  )     +     ( xfA . p . y )  ;", "final   float   tempx    =    clipPointx    -    planePointx ;", "final   float   tempy    =    clipPointy    -    planePointy ;", "separa    =     (  (  ( tempx    *     ( normal . x )  )     +     ( tempy    *     ( normal . y )  )  )     -     ( pc . radiusA )  )     -     ( pc . radiusB )  ;", "point . x    =    clipPointx ;", "point . y    =    clipPointy ;", "normal . x    *  =     -  1  ;", "normal . y    *  =     -  1  ;", "}", "break ;", "}", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.dynamics.contacts.PositionSolverManifold"}, {"methodBody": ["METHOD_START", "{", "float   perimeter    =     0  .  0 F ;", "for    ( int   i    =     0  ;    i    <     ( bodies . length )  ;     +  + i )     {", "final   int   next    =     ( i    =  =     (  ( bodies . length )     -     1  )  )     ?     0     :    i    +     1  ;", "float   dx    =     ( positions [ bodies [ next ]  . m _ islandIndex ]  . c . x )     -     ( positions [ bodies [ i ]  . m _ islandIndex ]  . c . x )  ;", "float   dy    =     ( positions [ bodies [ next ]  . m _ islandIndex ]  . c . y )     -     ( positions [ bodies [ i ]  . m _ islandIndex ]  . c . y )  ;", "float   dist    =    MathUtils . sqrt (  (  ( dx    *    dx )     +     ( dy    *    dy )  )  )  ;", "if    ( dist    <     ( Settings . EPSILON )  )     {", "dist    =     1  .  0 F ;", "}", "normals [ i ]  . x    =    dy    /    dist ;", "normals [ i ]  . y    =     (  - dx )     /    dist ;", "perimeter    +  =    dist ;", "}", "final   Vec 2    delta    =    pool . popVec 2  (  )  ;", "float   deltaArea    =     ( targe )     -     ( getSolverArea ( positions )  )  ;", "float   toExtrude    =     (  0  .  5 F    *    deltaArea )     /    perimeter ;", "boolean   done    =    true ;", "for    ( int   i    =     0  ;    i    <     ( bodies . length )  ;     +  + i )     {", "final   int   next    =     ( i    =  =     (  ( bodies . length )     -     1  )  )     ?     0     :    i    +     1  ;", "delta . set (  ( toExtrude    *     (  ( normals [ i ]  . x )     +     ( normals [ next ]  . x )  )  )  ,     ( toExtrude    *     (  ( normals [ i ]  . y )     +     ( normals [ next ]  . y )  )  )  )  ;", "float   normSqrd    =    delta . lengthSquared (  )  ;", "if    ( normSqrd    >     (  ( Settings . maxLinearCorrection )     *     ( Settings . maxLinearCorrection )  )  )     {", "delta . mulLocal (  (  ( Settings . maxLinearCorrection )     /     ( MathUtils . sqrt ( normSqrd )  )  )  )  ;", "}", "if    ( normSqrd    >     (  ( Settings . linearSlop )     *     ( Settings . linearSlop )  )  )     {", "done    =    false ;", "}", "positions [ bodies [ next ]  . m _ islandIndex ]  . c . x    +  =    delta . x ;", "positions [ bodies [ next ]  . m _ islandIndex ]  . c . y    +  =    delta . y ;", "}", "pool . pushVec 2  (  1  )  ;", "return   done ;", "}", "METHOD_END"], "methodName": ["constrainEdges"], "fileName": "org.jbox2d.dynamics.joints.ConstantVolumeJoint"}, {"methodBody": ["METHOD_START", "{", "return   bodies ;", "}", "METHOD_END"], "methodName": ["getBodies"], "fileName": "org.jbox2d.dynamics.joints.ConstantVolumeJoint"}, {"methodBody": ["METHOD_START", "{", "float   area    =     0  .  0 F ;", "for    (    i    =     0  ;    i    <     ( bodies . length )  ;     +  + i )     {", "final      next    =     ( i    =  =     (  ( bodies . length )     -     1  )  )     ?     0     :    i    +     1  ;", "area    +  =     (  ( bodies [ i ]  . getWorldCenter (  )  . x )     *     ( bodies [ next ]  . getWorldCenter (  )  . y )  )     -     (  ( bodies [ next ]  . getWorldCenter (  )  . x )     *     ( bodies [ i ]  . getWorldCenter (  )  . y )  )  ;", "}", "area    *  =     0  .  5 F ;", "return   area ;", "}", "METHOD_END"], "methodName": ["getBodyArea"], "fileName": "org.jbox2d.dynamics.joints.ConstantVolumeJoint"}, {"methodBody": ["METHOD_START", "{", "return   distanceJoints ;", "}", "METHOD_END"], "methodName": ["getJoints"], "fileName": "org.jbox2d.dynamics.joints.ConstantVolumeJoint"}, {"methodBody": ["METHOD_START", "{", "float   area    =     0  .  0 F ;", "for    (    i    =     0  ;    i    <     ( bodies . length )  ;     +  + i )     {", "final      next    =     ( i    =  =     (  ( bodies . length )     -     1  )  )     ?     0     :    i    +     1  ;", "area    +  =     (  ( positions [ bodies [ i ]  . m _ islandIndex ]  . c . x )     *     ( positions [ bodies [ next ]  . m _ islandIndex ]  . c . y )  )     -     (  ( positions [ bodies [ next ]  . m _ islandIndex ]  . c . x )     *     ( positions [ bodies [ i ]  . m _ islandIndex ]  . c . y )  )  ;", "}", "area    *  =     0  .  5 F ;", "return   area ;", "}", "METHOD_END"], "methodName": ["getSolverArea"], "fileName": "org.jbox2d.dynamics.joints.ConstantVolumeJoint"}, {"methodBody": ["METHOD_START", "{", "targetVolume    *  =    factor ;", "}", "METHOD_END"], "methodName": ["inflate"], "fileName": "org.jbox2d.dynamics.joints.ConstantVolumeJoint"}, {"methodBody": ["METHOD_START", "{", "bodies . add ( argBody )  ;", "if    (  ( bodies . size (  )  )     =  =     1  )     {", "bodyA    =    argBody ;", "}", "if    (  ( bodies . size (  )  )     =  =     2  )     {", "bodyB    =    argBody ;", "}", "}", "METHOD_END"], "methodName": ["addBody"], "fileName": "org.jbox2d.dynamics.joints.ConstantVolumeJointDef"}, {"methodBody": ["METHOD_START", "{", "addBody ( argBody )  ;", "if    (  (     =  =    null )     {", "=    new   ArrayList < DistanceJoint >  (  )  ;", "}", "add ( argJoint )  ;", "}", "METHOD_END"], "methodName": ["addBodyAndJoint"], "fileName": "org.jbox2d.dynamics.joints.ConstantVolumeJointDef"}, {"methodBody": ["METHOD_START", "{", "return   m _ dampingRatio ;", "}", "METHOD_END"], "methodName": ["getDampingRatio"], "fileName": "org.jbox2d.dynamics.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ frequencyHz ;", "}", "METHOD_END"], "methodName": ["getFrequency"], "fileName": "org.jbox2d.dynamics.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "org.jbox2d.dynamics.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "org.jbox2d.dynamics.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "org.jbox2d.dynamics.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "m _ dampingRatio    =    damp ;", "}", "METHOD_END"], "methodName": ["setDampingRatio"], "fileName": "org.jbox2d.dynamics.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "m _ frequencyHz    =    hz ;", "}", "METHOD_END"], "methodName": ["setFrequency"], "fileName": "org.jbox2d.dynamics.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "m _ length    =    argLength ;", "}", "METHOD_END"], "methodName": ["setLength"], "fileName": "org.jbox2d.dynamics.joints.DistanceJoint"}, {"methodBody": ["METHOD_START", "{", "bodyA    =    b 1  ;", "bodyB    =    b 2  ;", "localAnchorA . set ( bodyA . getLocalP ( anchor 1  )  )  ;", "localAnchorB . set ( bodyB . getLocalP ( anchor 2  )  )  ;", "Vec 2    d    =    anchor 2  . sub ( anchor 1  )  ;", "length    =    d . length (  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.dynamics.joints.DistanceJointDef"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "org.jbox2d.dynamics.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "org.jbox2d.dynamics.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxForce ;", "}", "METHOD_END"], "methodName": ["getMaxForce"], "fileName": "org.jbox2d.dynamics.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxTorque ;", "}", "METHOD_END"], "methodName": ["getMaxTorque"], "fileName": "org.jbox2d.dynamics.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "assert   force    >  =     0  .  0 F ;", "m _ maxForce    =    force ;", "}", "METHOD_END"], "methodName": ["setMaxForce"], "fileName": "org.jbox2d.dynamics.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "assert   torque    >  =     0  .  0 F ;", "m _ maxTorque    =    torque ;", "}", "METHOD_END"], "methodName": ["setMaxTorque"], "fileName": "org.jbox2d.dynamics.joints.FrictionJoint"}, {"methodBody": ["METHOD_START", "{", "bodyA    =    bA ;", "bodyB    =    bB ;", "bA . getLocalPToOut ( anchor ,    localAnchorA )  ;", "bB . getLocalPToOut ( anchor ,    localAnchorB )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.dynamics.joints.FrictionJointDef"}, {"methodBody": ["METHOD_START", "{", "return   m _ joint 1  ;", "}", "METHOD_END"], "methodName": ["getJoint1"], "fileName": "org.jbox2d.dynamics.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ joint 2  ;", "}", "METHOD_END"], "methodName": ["getJoint2"], "fileName": "org.jbox2d.dynamics.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ ratio ;", "}", "METHOD_END"], "methodName": ["getRatio"], "fileName": "org.jbox2d.dynamics.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "m _ ratio    =    argRatio ;", "}", "METHOD_END"], "methodName": ["setRatio"], "fileName": "org.jbox2d.dynamics.joints.GearJoint"}, {"methodBody": ["METHOD_START", "{", "switch    ( def . type )     {", "case   MOUSE    :", "return   new   Mouse ( world . getPool (  )  ,     (  ( MouseDef )     ( def )  )  )  ;", "case   DISTANCE    :", "return   new   Distance ( world . getPool (  )  ,     (  ( DistanceDef )     ( def )  )  )  ;", "case   PRISMATIC    :", "return   new   Prismatic ( world . getPool (  )  ,     (  ( PrismaticDef )     ( def )  )  )  ;", "case   REVOLUTE    :", "return   new   Revolute ( world . getPool (  )  ,     (  ( RevoluteDef )     ( def )  )  )  ;", "case   WELD    :", "return   new   Weld ( world . getPool (  )  ,     (  ( WeldDef )     ( def )  )  )  ;", "case   FRICTION    :", "return   new   Friction ( world . getPool (  )  ,     (  ( FrictionDef )     ( def )  )  )  ;", "case   WHEEL    :", "return   new   Wheel ( world . getPool (  )  ,     (  ( WheelDef )     ( def )  )  )  ;", "case   GEAR    :", "return   new   Gear ( world . getPool (  )  ,     (  ( GearDef )     ( def )  )  )  ;", "case   PULLEY    :", "return   new   Pulley ( world . getPool (  )  ,     (  ( PulleyDef )     ( def )  )  )  ;", "case   CONSTANT _ VOLUME    :", "return   new   ConstantVolume ( world ,     (  ( ConstantVolumeDef )     ( def )  )  )  ;", "case   ROPE    :", "return   new   Rope ( world . getPool (  )  ,     (  ( RopeDef )     ( def )  )  )  ;", "case   MOTOR    :", "return   new   Motor ( world . getPool (  )  ,     (  ( MotorDef )     ( def )  )  )  ;", "case   UNKNOWN    :", "default    :", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "joint . destructor (  )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "return   m _ bodyA ;", "}", "METHOD_END"], "methodName": ["getBodyA"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "return   m _ bodyB ;", "}", "METHOD_END"], "methodName": ["getBodyB"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "return   m _ collideConnected ;", "}", "METHOD_END"], "methodName": ["getCollideConnected"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "return   m _ next ;", "}", "METHOD_END"], "methodName": ["getNext"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "return   m _ type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "return   m _ userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ bodyA . isActive (  )  )     &  &     ( m _ bodyB . isActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "m _ userData    =    data ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "org.jbox2d.dynamics.joints.Joint"}, {"methodBody": ["METHOD_START", "{", "return   m _ angularOffset ;", "}", "METHOD_END"], "methodName": ["getAngularOffset"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ correctionFactor ;", "}", "METHOD_END"], "methodName": ["getCorrectionFactor"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ linearOffset ;", "}", "METHOD_END"], "methodName": ["getLinearOffset"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "out . set ( m _ linearOffset )  ;", "}", "METHOD_END"], "methodName": ["getLinearOffset"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxForce ;", "}", "METHOD_END"], "methodName": ["getMaxForce"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxTorque ;", "}", "METHOD_END"], "methodName": ["getMaxTorque"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "out . set ( m _ linearImpulse )  . mulLocal ( inv _ dt )  ;", "}", "METHOD_END"], "methodName": ["getReactionForce"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ angularImpulse )     *    inv _ dt ;", "}", "METHOD_END"], "methodName": ["getReactionTorque"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "if    ( angularOffset    !  =     ( m _ angularOffset )  )     {", "m _ dyA . setAwake ( true )  ;", "m _ dyB . setAwake ( true )  ;", "m _ angularOffset    =    angularOffset ;", "}", "}", "METHOD_END"], "methodName": ["setAngularOffset"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "this . m _ correctionFactor    =    correctionFactor ;", "}", "METHOD_END"], "methodName": ["setCorrectionFactor"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( linearOffset . x )     !  =     ( m _ linearOffset . x )  )     |  |     (  ( linearOffset . y )     !  =     ( m _ linearOffset . y )  )  )     {", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ linearOffset . set ( linearOffset )  ;", "}", "}", "METHOD_END"], "methodName": ["setLinearOffset"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "assert   force    >  =     0  .  0 F ;", "m _ maxForce    =    force ;", "}", "METHOD_END"], "methodName": ["setMaxForce"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "assert   torque    >  =     0  .  0 F ;", "m _ maxTorque    =    torque ;", "}", "METHOD_END"], "methodName": ["setMaxTorque"], "fileName": "org.jbox2d.dynamics.joints.MotorJoint"}, {"methodBody": ["METHOD_START", "{", "bodyA    =    bA ;", "bodyB    =    bB ;", "Vec 2    xB    =    bodyB . getPosition (  )  ;", "bodyA . getLocalPToOut ( xB ,    linearOffset )  ;", "float   angleA    =    bodyA . getAngle (  )  ;", "float   angleB    =    bodyB . getAngle (  )  ;", "angularOffset    =    angleB    -    angleA ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.dynamics.joints.MotorJointDef"}, {"methodBody": ["METHOD_START", "{", "return   m _ dampingRatio ;", "}", "METHOD_END"], "methodName": ["getDampingRatio"], "fileName": "org.jbox2d.dynamics.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ frequencyHz ;", "}", "METHOD_END"], "methodName": ["getFrequency"], "fileName": "org.jbox2d.dynamics.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxForce ;", "}", "METHOD_END"], "methodName": ["getMaxForce"], "fileName": "org.jbox2d.dynamics.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ targetA ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.jbox2d.dynamics.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "m _ dampingRatio    =    ratio ;", "}", "METHOD_END"], "methodName": ["setDampingRatio"], "fileName": "org.jbox2d.dynamics.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "m _ frequencyHz    =    hz ;", "}", "METHOD_END"], "methodName": ["setFrequency"], "fileName": "org.jbox2d.dynamics.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "m _ maxForce    =    force ;", "}", "METHOD_END"], "methodName": ["setMaxForce"], "fileName": "org.jbox2d.dynamics.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ bodyB . isAwake (  )  )     =  =    false )     {", "m _ bodyB . setAwake ( true )  ;", "}", "m _ targetA . set ( target )  ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "org.jbox2d.dynamics.joints.MouseJoint"}, {"methodBody": ["METHOD_START", "{", "if    ( flag    !  =     ( m _ enableLimit )  )     {", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ enableLimit    =    flag ;", "m _ impulse . z    =     0  .  0 F ;", "}", "}", "METHOD_END"], "methodName": ["enableLimit"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ enableMotor    =    flag ;", "}", "METHOD_END"], "methodName": ["enableMotor"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "Body   bA    =    m _ bodyA ;", "Body   bB    =    m _ bodyB ;", "Vec 2    temp    =    pool . popVec 2  (  )  ;", "Vec 2    rA    =    pool . popVec 2  (  )  ;", "Vec 2    rB    =    pool . popVec 2  (  )  ;", "Vec 2    p 1     =    pool . popVec 2  (  )  ;", "Vec 2    p 2     =    pool . popVec 2  (  )  ;", "Vec 2    d    =    pool . popVec 2  (  )  ;", "Vec 2    axis    =    pool . popVec 2  (  )  ;", "Vec 2    temp 2     =    pool . popVec 2  (  )  ;", "Vec 2    temp 3     =    pool . popVec 2  (  )  ;", "temp . set ( m _ localAnchorA )  . subLocal ( bA . m _ sweep . localCenter )  ;", "Rot . mulToOutUnsafe ( bA . m _ xf . q ,    temp ,    rA )  ;", "temp . set ( m _ localAnchorB )  . subLocal ( bB . m _ sweep . localCenter )  ;", "Rot . mulToOutUnsafe ( bB . m _ xf . q ,    temp ,    rB )  ;", "p 1  . set ( bA . m _ sweep . c )  . addLocal ( rA )  ;", "p 2  . set ( bB . m _ sweep . c )  . addLocal ( rB )  ;", "d . set ( p 2  )  . subLocal ( p 1  )  ;", "Rot . mulToOutUnsafe ( bA . m _ xf . q ,    m _ localXAxisA ,    axis )  ;", "Vec 2    vA    =    bA . m _ linearVelocity ;", "Vec 2    vB    =    bB . m _ linearVelocity ;", "float   wA    =    bA . m _ angularVelocity ;", "float   wB    =    bB . m _ angularVelocity ;", "Vec 2  . crossToOutUnsafe ( wA ,    axis ,    temp )  ;", "Vec 2  . crossToOutUnsafe ( wB ,    rB ,    temp 2  )  ;", "Vec 2  . crossToOutUnsafe ( wA ,    rA ,    temp 3  )  ;", "temp 2  . addLocal ( vB )  . subLocal ( vA )  . subLocal ( temp 3  )  ;", "float   speed    =     ( Vec 2  . dot ( d ,    temp )  )     +     ( Vec 2  . dot ( axis ,    temp 2  )  )  ;", "pool . pushVec 2  (  9  )  ;", "return   speed ;", "}", "METHOD_END"], "methodName": ["getJointSpeed"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "Vec 2    pA    =    pool . popVec 2  (  )  ;", "Vec 2    pB    =    pool . popVec 2  (  )  ;", "Vec 2    axis    =    pool . popVec 2  (  )  ;", "m _ bodyA . getWorldPToOut ( m _ localAnchorA ,    pA )  ;", "m _ bodyB . getWorldPToOut ( m _ localAnchorB ,    pB )  ;", "m _ bodyA . getWorldVectorToOutUnsafe ( m _ localXAxisA ,    axis )  ;", "pB . subLocal ( pA )  ;", "float   translation    =    Vec 2  . dot ( pB ,    axis )  ;", "pool . pushVec 2  (  3  )  ;", "return   translation ;", "}", "METHOD_END"], "methodName": ["getJointTranslation"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localXAxisA ;", "}", "METHOD_END"], "methodName": ["getLocalAxisA"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ lowerTranslation ;", "}", "METHOD_END"], "methodName": ["getLowerLimit"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxMotorForce ;", "}", "METHOD_END"], "methodName": ["getMaxMotorForce"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ motorImpulse )     *    inv _ dt ;", "}", "METHOD_END"], "methodName": ["getMotorForce"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ motorSpeed ;", "}", "METHOD_END"], "methodName": ["getMotorSpeed"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ referenceAngle ;", "}", "METHOD_END"], "methodName": ["getReferenceAngle"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ upperTranslation ;", "}", "METHOD_END"], "methodName": ["getUpperLimit"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ enableLimit ;", "}", "METHOD_END"], "methodName": ["isLimitEnabled"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ enableMotor ;", "}", "METHOD_END"], "methodName": ["isMotorEnabled"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "assert   lower    <  =    upper ;", "if    (  ( lower    !  =     ( m _ lowerTranslon )  )     |  |     ( upper    !  =     ( m _ upperTranslon )  )  )     {", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ lowerTranslon    =    lower ;", "m _ upperTranslon    =    upper ;", "m _ impulse . z    =     0  .  0 F ;", "}", "}", "METHOD_END"], "methodName": ["setLimits"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ maxMotorForce    =    force ;", "}", "METHOD_END"], "methodName": ["setMaxMotorForce"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ motorSpeed    =    speed ;", "}", "METHOD_END"], "methodName": ["setMotorSpeed"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJoint"}, {"methodBody": ["METHOD_START", "{", "bodyA    =    b 1  ;", "bodyB    =    b 2  ;", "bodyA . getLocalPToOut ( anchor ,    localAnchorA )  ;", "bodyB . getLocalPToOut ( anchor ,    localAnchorB )  ;", "bodyA . getLocalVectorToOut ( axis ,    localAxisA )  ;", "referenceAngle    =     ( bodyB . getAngle (  )  )     -     ( bodyA . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.dynamics.joints.PrismaticJointDef"}, {"methodBody": ["METHOD_START", "{", "final   Vec 2    p    =    pool . popVec 2  (  )  ;", "m _ bodyA . getWorldPToOut ( m _ localAnchorA ,    p )  ;", "p . subLocal ( m _ groundAnchorA )  ;", "float   length    =    p . length (  )  ;", "pool . pushVec 2  (  1  )  ;", "return   length ;", "}", "METHOD_END"], "methodName": ["getCurrentLengthA"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "final   Vec 2    p    =    pool . popVec 2  (  )  ;", "m _ bodyB . getWorldPToOut ( m _ localAnchorB ,    p )  ;", "p . subLocal ( m _ groundAnchorB )  ;", "float   length    =    p . length (  )  ;", "pool . pushVec 2  (  1  )  ;", "return   length ;", "}", "METHOD_END"], "methodName": ["getCurrentLengthB"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ groundAnchorA ;", "}", "METHOD_END"], "methodName": ["getGroundAnchorA"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ groundAnchorB ;", "}", "METHOD_END"], "methodName": ["getGroundAnchorB"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "final   Vec 2    p    =    pool . popVec 2  (  )  ;", "m _ bodyA . getWorldPToOut ( m _ localAnchorA ,    p )  ;", "p . subLocal ( m _ groundAnchorA )  ;", "float   len    =    p . length (  )  ;", "pool . pushVec 2  (  1  )  ;", "return   len ;", "}", "METHOD_END"], "methodName": ["getLength1"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "final   Vec 2    p    =    pool . popVec 2  (  )  ;", "m _ bodyB . getWorldPToOut ( m _ localAnchorB ,    p )  ;", "p . subLocal ( m _ groundAnchorB )  ;", "float   len    =    p . length (  )  ;", "pool . pushVec 2  (  1  )  ;", "return   len ;", "}", "METHOD_END"], "methodName": ["getLength2"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ lengthA ;", "}", "METHOD_END"], "methodName": ["getLengthA"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ lengthB ;", "}", "METHOD_END"], "methodName": ["getLengthB"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ ratio ;", "}", "METHOD_END"], "methodName": ["getRatio"], "fileName": "org.jbox2d.dynamics.joints.PulleyJoint"}, {"methodBody": ["METHOD_START", "{", "bodyA    =    b 1  ;", "bodyB    =    b 2  ;", "groundAnchorA    =    ga 1  ;", "groundAnchorB    =    ga 2  ;", "localAnchorA    =    bodyA . getLocalP ( anchor 1  )  ;", "localAnchorB    =    bodyB . getLocalP ( anchor 2  )  ;", "Vec 2    d 1     =    anchor 1  . sub ( ga 1  )  ;", "lengthA    =    d 1  . length (  )  ;", "Vec 2    d 2     =    anchor 2  . sub ( ga 2  )  ;", "lengthB    =    d 2  . length (  )  ;", "ratio    =    r ;", "assert    ( ratio )     >     ( Settings . EPSILON )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.dynamics.joints.PulleyJointDef"}, {"methodBody": ["METHOD_START", "{", "if    ( flag    !  =     ( m _ enableLimit )  )     {", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ enableLimit    =    flag ;", "m _ impulse . z    =     0  .  0 F ;", "}", "}", "METHOD_END"], "methodName": ["enableLimit"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ enableMotor    =    flag ;", "}", "METHOD_END"], "methodName": ["enableMotor"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "final   Body   b 1     =    m _ bodyA ;", "final   Body   b 2     =    m _ bodyB ;", "return    (  ( b 2  . m _ sweep . a )     -     ( b 1  . m _ sweep . a )  )     -     ( m _ referenceAngle )  ;", "}", "METHOD_END"], "methodName": ["getJointAngle"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "final   Body   b 1     =    m _ bodyA ;", "final   Body   b 2     =    m _ bodyB ;", "return    ( b 2  . m _ angularVelocity )     -     ( b 1  . m _ angularVelocity )  ;", "}", "METHOD_END"], "methodName": ["getJointSpeed"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ lowerAngle ;", "}", "METHOD_END"], "methodName": ["getLowerLimit"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxMotorTorque ;", "}", "METHOD_END"], "methodName": ["getMaxMotorTorque"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ motorSpeed ;", "}", "METHOD_END"], "methodName": ["getMotorSpeed"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ motorImpulse )     *    inv _ dt ;", "}", "METHOD_END"], "methodName": ["getMotorTorque"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ referenceAngle ;", "}", "METHOD_END"], "methodName": ["getReferenceAngle"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ upperAngle ;", "}", "METHOD_END"], "methodName": ["getUpperLimit"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ enableLimit ;", "}", "METHOD_END"], "methodName": ["isLimitEnabled"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ enableMotor ;", "}", "METHOD_END"], "methodName": ["isMotorEnabled"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "assert   lower    <  =    upper ;", "if    (  ( lower    !  =     ( m _ lowerAngle )  )     |  |     ( upper    !  =     ( m _ upperAngle )  )  )     {", "m _ dyA . setAwake ( true )  ;", "m _ dyB . setAwake ( true )  ;", "m _ impulse . z    =     0  .  0 F ;", "m _ lowerAngle    =    lower ;", "m _ upperAngle    =    upper ;", "}", "}", "METHOD_END"], "methodName": ["setLimits"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ maxMotorTorque    =    torque ;", "}", "METHOD_END"], "methodName": ["setMaxMotorTorque"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ motorSpeed    =    speed ;", "}", "METHOD_END"], "methodName": ["setMotorSpeed"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJoint"}, {"methodBody": ["METHOD_START", "{", "bodyA    =    b 1  ;", "bodyB    =    b 2  ;", "bodyA . getLocalPToOut ( anchor ,    localAnchorA )  ;", "bodyB . getLocalPToOut ( anchor ,    localAnchorB )  ;", "referenceAngle    =     ( bodyB . getAngle (  )  )     -     ( bodyA . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.dynamics.joints.RevoluteJointDef"}, {"methodBody": ["METHOD_START", "{", "return   m _ state ;", "}", "METHOD_END"], "methodName": ["getLimitState"], "fileName": "org.jbox2d.dynamics.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "org.jbox2d.dynamics.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "org.jbox2d.dynamics.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxLength ;", "}", "METHOD_END"], "methodName": ["getMaxLength"], "fileName": "org.jbox2d.dynamics.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "this . m _ maxLength    =    maxLength ;", "}", "METHOD_END"], "methodName": ["setMaxLength"], "fileName": "org.jbox2d.dynamics.joints.RopeJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ dampingRatio ;", "}", "METHOD_END"], "methodName": ["getDampingRatio"], "fileName": "org.jbox2d.dynamics.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ frequencyHz ;", "}", "METHOD_END"], "methodName": ["getFrequency"], "fileName": "org.jbox2d.dynamics.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "org.jbox2d.dynamics.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "org.jbox2d.dynamics.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ referenceAngle ;", "}", "METHOD_END"], "methodName": ["getReferenceAngle"], "fileName": "org.jbox2d.dynamics.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "this . m _ dampingRatio    =    dampingRatio ;", "}", "METHOD_END"], "methodName": ["setDampingRatio"], "fileName": "org.jbox2d.dynamics.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "this . m _ frequencyHz    =    frequencyHz ;", "}", "METHOD_END"], "methodName": ["setFrequency"], "fileName": "org.jbox2d.dynamics.joints.WeldJoint"}, {"methodBody": ["METHOD_START", "{", "bodyA    =    bA ;", "bodyB    =    bB ;", "bodyA . getLocalPToOut ( anchor ,    localAnchorA )  ;", "bodyB . getLocalPToOut ( anchor ,    localAnchorB )  ;", "referenceAngle    =     ( bodyB . getAngle (  )  )     -     ( bodyA . getAngle (  )  )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.dynamics.joints.WeldJointDef"}, {"methodBody": ["METHOD_START", "{", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ enableMotor    =    flag ;", "}", "METHOD_END"], "methodName": ["enableMotor"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ bodyA . m _ angularVelocity )     -     ( m _ bodyB . m _ angularVelocity )  ;", "}", "METHOD_END"], "methodName": ["getJointSpeed"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "Body   b 1     =    m _ bodyA ;", "Body   b 2     =    m _ bodyB ;", "Vec 2    p 1     =    pool . popVec 2  (  )  ;", "Vec 2    p 2     =    pool . popVec 2  (  )  ;", "Vec 2    axis    =    pool . popVec 2  (  )  ;", "b 1  . getWorldPToOut ( m _ localAnchorA ,    p 1  )  ;", "b 2  . getWorldPToOut ( m _ localAnchorA ,    p 2  )  ;", "p 2  . subLocal ( p 1  )  ;", "b 1  . getWorldVectorToOut ( m _ localXAxisA ,    axis )  ;", "float   translation    =    Vec 2  . dot ( p 2  ,    axis )  ;", "pool . pushVec 2  (  3  )  ;", "return   translation ;", "}", "METHOD_END"], "methodName": ["getJointTranslation"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorA ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorA"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localAnchorB ;", "}", "METHOD_END"], "methodName": ["getLocalAnchorB"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ localXAxisA ;", "}", "METHOD_END"], "methodName": ["getLocalAxisA"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxMotorTorque ;", "}", "METHOD_END"], "methodName": ["getMaxMotorTorque"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ motorSpeed ;", "}", "METHOD_END"], "methodName": ["getMotorSpeed"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ motorImpulse )     *    inv _ dt ;", "}", "METHOD_END"], "methodName": ["getMotorTorque"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ dampingRatio ;", "}", "METHOD_END"], "methodName": ["getSpringDampingRatio"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ frequencyHz ;", "}", "METHOD_END"], "methodName": ["getSpringFrequencyHz"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "return   m _ enableMotor ;", "}", "METHOD_END"], "methodName": ["isMotorEnabled"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ maxMotorTorque    =    torque ;", "}", "METHOD_END"], "methodName": ["setMaxMotorTorque"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "m _ bodyA . setAwake ( true )  ;", "m _ bodyB . setAwake ( true )  ;", "m _ motorSpeed    =    speed ;", "}", "METHOD_END"], "methodName": ["setMotorSpeed"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "m _ dampingRatio    =    ratio ;", "}", "METHOD_END"], "methodName": ["setSpringDampingRatio"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "m _ frequencyHz    =    hz ;", "}", "METHOD_END"], "methodName": ["setSpringFrequencyHz"], "fileName": "org.jbox2d.dynamics.joints.WheelJoint"}, {"methodBody": ["METHOD_START", "{", "bodyA    =    b 1  ;", "bodyB    =    b 2  ;", "b 1  . getLocalPToOut ( anchor ,    localAnchorA )  ;", "b 2  . getLocalPToOut ( anchor ,    localAnchorB )  ;", "bodyA . getLocalVectorToOut ( axis ,    localAxisA )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.jbox2d.dynamics.joints.WheelJointDef"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( r )     =  =     0  )     &  &     (  ( g )     =  =     0  )  )     &  &     (  ( b )     =  =     0  )  )     &  &     (  ( a )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isZero"], "fileName": "org.jbox2d.particle.ParticleColor"}, {"methodBody": ["METHOD_START", "{", "this . r    =    r ;", "this . g    =    g ;", "this . b    =    b ;", "this . a    =    a ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.particle.ParticleColor"}, {"methodBody": ["METHOD_START", "{", "r    =     (  ( byte )     (  2  5  5     *     ( color . x )  )  )  ;", "g    =     (  ( byte )     (  2  5  5     *     ( color . y )  )  )  ;", "b    =     (  ( byte )     (  2  5  5     *     ( color . z )  )  )  ;", "a    =     (  ( byte )     (  2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.particle.ParticleColor"}, {"methodBody": ["METHOD_START", "{", "r    =    color . r ;", "g    =    color . g ;", "b    =    color . b ;", "a    =    color . a ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.jbox2d.particle.ParticleColor"}, {"methodBody": ["METHOD_START", "{", "return   m _ transform . q . getAngle (  )  ;", "}", "METHOD_END"], "methodName": ["getAngle"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "updateStatistics (  )  ;", "return   m _ angularVelocity ;", "}", "METHOD_END"], "methodName": ["getAngularVelocity"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "return   m _ firstIndex ;", "}", "METHOD_END"], "methodName": ["getBufferIndex"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "updateStatistics (  )  ;", "return   m _ center ;", "}", "METHOD_END"], "methodName": ["getCenter"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "return   m _ groupFlags ;", "}", "METHOD_END"], "methodName": ["getGroupFlags"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "updateStatistics (  )  ;", "return   m _ inertia ;", "}", "METHOD_END"], "methodName": ["getInertia"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "updateStatistics (  )  ;", "return   m _ linearVelocity ;", "}", "METHOD_END"], "methodName": ["getLinearVelocity"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "updateStatistics (  )  ;", "return   m _ mass ;", "}", "METHOD_END"], "methodName": ["getMass"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "return   m _ next ;", "}", "METHOD_END"], "methodName": ["getNext"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ lastIndex )     -     ( m _ firstIndex )  ;", "}", "METHOD_END"], "methodName": ["getParticleCount"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "return   m _ transform . p ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "return   m _ transform ;", "}", "METHOD_END"], "methodName": ["getTransform"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "return   m _ userData ;", "}", "METHOD_END"], "methodName": ["getUserData"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "m _ groupFlags    =    flags ;", "}", "METHOD_END"], "methodName": ["setGroupFlags"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "m _ userData    =    data ;", "}", "METHOD_END"], "methodName": ["setUserData"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ timestamp )     !  =     ( m _ system . m _ timestamp )  )     {", "float   m    =    m _ system . getMass (  )  ;", "m _ mass    =     0  ;", "m _ center . setZero (  )  ;", "m _ linearVelocity . setZero (  )  ;", "for    ( int   i    =    m _ firstIndex ;    i    <     ( m _ lastIndex )  ;    i +  +  )     {", "m _ mass    +  =    m ;", "Vec 2    pos    =    m _ system . m _ positionBuffer . data [ i ]  ;", "m _ center . x    +  =    m    *     ( pos . x )  ;", "m _ center . y    +  =    m    *     ( pos . y )  ;", "Vec 2    vel    =    m _ system . m _ velocityBuffer . data [ i ]  ;", "m _ linearVelocity . x    +  =    m    *     ( vel . x )  ;", "m _ linearVelocity . y    +  =    m    *     ( vel . y )  ;", "}", "if    (  ( m _ mass )     >     0  )     {", "m _ center . x    *  =     1     /     ( m _ mass )  ;", "m _ center . y    *  =     1     /     ( m _ mass )  ;", "m _ linearVelocity . x    *  =     1     /     ( m _ mass )  ;", "m _ linearVelocity . y    *  =     1     /     ( m _ mass )  ;", "}", "m _ inertia    =     0  ;", "m _ angularVelocity    =     0  ;", "for    ( int   i    =    m _ firstIndex ;    i    <     ( m _ lastIndex )  ;    i +  +  )     {", "Vec 2    pos    =    m _ system . m _ positionBuffer . data [ i ]  ;", "Vec 2    vel    =    m _ system . m _ velocityBuffer . data [ i ]  ;", "float   px    =     ( pos . x )     -     ( m _ center . x )  ;", "float   py    =     ( pos . y )     -     ( m _ center . y )  ;", "float   vx    =     ( vel . x )     -     ( m _ linearVelocity . x )  ;", "float   vy    =     ( vel . y )     -     ( m _ linearVelocity . y )  ;", "m _ inertia    +  =    m    *     (  ( px    *    px )     +     ( py    *    py )  )  ;", "m _ angularVelocity    +  =    m    *     (  ( px    *    vy )     -     ( py    *    vx )  )  ;", "}", "if    (  ( m _ inertia )     >     0  )     {", "m _ angularVelocity    *  =     1     /     ( m _ inertia )  ;", "}", "m _ timestamp    =    m _ system . m _ timestamp ;", "}", "}", "METHOD_END"], "methodName": ["updateStatistics"], "fileName": "org.jbox2d.particle.ParticleGroup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( start    =  =    mid )     |  |     ( mid    =  =    end )  )     {", "return ;", "}", "newIndices . start    =    start ;", "newIndices . mid    =    mid ;", "newIndices . end    =    end ;", "BufferUtils . rotate ( m _ flagsBuffer . data ,    start ,    mid ,    end )  ;", "BufferUtils . rotate ( m _ positionBuffer . data ,    start ,    mid ,    end )  ;", "BufferUtils . rotate ( m _ velocityBuffer . data ,    start ,    mid ,    end )  ;", "BufferUtils . rotate ( m _ groupBuffer ,    start ,    mid ,    end )  ;", "if    (  ( m _ depthBuffer )     !  =    null )     {", "BufferUtils . rotate ( m _ depthBuffer ,    start ,    mid ,    end )  ;", "}", "if    (  ( m _ colorBuffer . data )     !  =    null )     {", "BufferUtils . rotate ( m _ colorBuffer . data ,    start ,    mid ,    end )  ;", "}", "if    (  ( m _ userDataBuffer . data )     !  =    null )     {", "BufferUtils . rotate ( m _ userDataBuffer . data ,    start ,    mid ,    end )  ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ proxyCount )  ;    k +  +  )     {", ". Proxy   proxy    =    m _ proxyBuffer [ k ]  ;", "proxy . index    =    newIndices . getIndex ( proxy . index )  ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "contact . indexA    =    newIndices . getIndex ( contact . indexA )  ;", "contact . indexB    =    newIndices . getIndex ( contact . indexB )  ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ bodyContactCount )  ;    k +  +  )     {", "ParticleBodyContact   contact    =    m _ bodyContactBuffer [ k ]  ;", "contact . index    =    newIndices . getIndex ( contact . index )  ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ pairCount )  ;    k +  +  )     {", ". Pair   pair    =    m _ pairBuffer [ k ]  ;", "pair . indexA    =    newIndices . getIndex ( pair . indexA )  ;", "pair . indexB    =    newIndices . getIndex ( pair . indexB )  ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ triadCount )  ;    k +  +  )     {", ". Triad   triad    =    m _ triadBuffer [ k ]  ;", "triad . indexA    =    newIndices . getIndex ( triad . indexA )  ;", "triad . indexB    =    newIndices . getIndex ( triad . indexB )  ;", "triad . indexC    =    newIndices . getIndex ( triad . indexC )  ;", "}", "for    ( ParticleGroup   group    =    m _ groupList ;    group    !  =    null ;    group    =    group . getNext (  )  )     {", "group . m _ firstIndex    =    newIndices . getIndex ( group . m _ firstIndex )  ;", "group . m _ lastIndex    =     ( newIndices . getIndex (  (  ( group . m _ lastIndex )     -     1  )  )  )     +     1  ;", "}", "}", "METHOD_END"], "methodName": ["RotateBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "assert   a    !  =    b ;", "Vec 2    pa    =    m _ positionBuffer . data [ a ]  ;", "Vec 2    pb    =    m _ positionBuffer . data [ b ]  ;", "float   dx    =     ( pb . x )     -     ( pa . x )  ;", "float   dy    =     ( pb . y )     -     ( pa . y )  ;", "float   d 2     =     ( dx    *    dx )     +     ( dy    *    dy )  ;", "if    ( d 2     <     ( m _ squaredDiameter )  )     {", "if    (  ( m _ contactCount )     >  =     ( m _ contactCapacity )  )     {", "int   oldCapacity    =    m _ contactCapacity ;", "int   newCapacity    =     (  ( m _ contactCount )     !  =     0  )     ?     2     *     ( m _ contactCount )     :    Settings . minBufferCapacity ;", "m _ contactBuffer    =    BufferUtils . reallocateBuffer ( Contact . class ,    m _ contactBuffer ,    oldCapacity ,    newCapacity )  ;", "m _ contactCapacity    =    newCapacity ;", "}", "float   invD    =     ( d 2     !  =     0  )     ?    MathUtils . sqrt (  (  1     /    d 2  )  )     :    Float . MAX _ VALUE ;", "Contact   contact    =    m _ contactBuffer [ m _ contactCount ]  ;", "contact . indexA    =    a ;", "contact . indexB    =    b ;", "contact . flags    =     ( m _ flagsBuffer . data [ a ]  )     |     ( m _ flagsBuffer . data [ b ]  )  ;", "contact . weight    =     1     -     (  ( d 2     *    invD )     *     ( m _ inverseDiameter )  )  ;", "contact . normal . x    =    invD    *    dx ;", "contact . normal . y    =    invD    *    dy ;", "( m _ contactCount )  +  +  ;", "}", "}", "METHOD_END"], "methodName": ["addContact"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    group . m _ firstIndex ;    i    <     ( group . m _ lastIndex )  ;    i +  +  )     {", "m _ accumulationBuffer [ i ]     =     0  ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   Contact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "if    (  (  (  ( a    >  =     ( group . m _ firstIndex )  )     &  &     ( a    <     ( group . m _ lastIndex )  )  )     &  &     ( b    >  =     ( group . m _ firstIndex )  )  )     &  &     ( b    <     ( group . m _ lastIndex )  )  )     {", "float   w    =    contact . weight ;", "m _ accumulationBuffer [ a ]     +  =    w ;", "m _ accumulationBuffer [ b ]     +  =    w ;", "}", "}", "m _ depthBuffer    =    requestBuffer ( m _ depthBuffer )  ;", "for    ( int   i    =    group . m _ firstIndex ;    i    <     ( group . m _ lastIndex )  ;    i +  +  )     {", "float   w    =    m _ accumulationBuffer [ i ]  ;", "m _ depthBuffer [ i ]     =     ( w    <     0  .  8 F )     ?     0     :    Float . MAX _ VALUE ;", "}", "int   interationCount    =    group . getCount (  )  ;", "for    ( int   t    =     0  ;    t    <    interationCount ;    t +  +  )     {", "boolean   updated    =    false ;", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   Contact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "if    (  (  (  ( a    >  =     ( group . m _ firstIndex )  )     &  &     ( a    <     ( group . m _ lastIndex )  )  )     &  &     ( b    >  =     ( group . m _ firstIndex )  )  )     &  &     ( b    <     ( group . m _ lastIndex )  )  )     {", "float   r    =     1     -     ( contact . weight )  ;", "float   ap 0     =    m _ depthBuffer [ a ]  ;", "float   bp 0     =    m _ depthBuffer [ b ]  ;", "float   ap 1     =    bp 0     +    r ;", "float   bp 1     =    ap 0     +    r ;", "if    ( ap 0     >    ap 1  )     {", "m _ depthBuffer [ a ]     =    ap 1  ;", "updated    =    true ;", "}", "if    ( bp 0     >    bp 1  )     {", "m _ depthBuffer [ b ]     =    bp 1  ;", "updated    =    true ;", "}", "}", "}", "if    (  ! updated )     {", "break ;", "}", "}", "for    ( int   i    =    group . m _ firstIndex ;    i    <     ( group . m _ lastIndex )  ;    i +  +  )     {", "float   p    =    m _ depthBuffer [ i ]  ;", "if    ( p    <     ( Float . MAX _ VALUE )  )     {", "m _ depthBuffer [ i ]     *  =    m _ particleDiameter ;", "} else    {", "m _ depthBuffer [ i ]     =     0  ;", "}", "}", "}", "METHOD_END"], "methodName": ["computeDepthForGroup"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "float   sum _ v 2     =     0  ;", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   Contact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "Vec 2    n    =    contact . normal ;", "final   Vec 2    va    =    m _ velocityBuffer . data [ a ]  ;", "final   Vec 2    vb    =    m _ velocityBuffer . data [ b ]  ;", "final   float   vx    =     ( vb . x )     -     ( va . x )  ;", "final   float   vy    =     ( vb . y )     -     ( va . y )  ;", "float   vn    =     ( vx    *     ( n . x )  )     +     ( vy    *     ( n . y )  )  ;", "if    ( vn    <     0  )     {", "sum _ v 2     +  =    vn    *    vn ;", "}", "}", "return    (  0  .  5 F    *     ( getMass (  )  )  )     *    sum _ v 2  ;", "}", "METHOD_END"], "methodName": ["computeParticleCollisionEnergy"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return    ( tag    +     ( y    <  <     ( ParticleSystem . yShift )  )  )     +     ( x    <  <     ( ParticleSystem . xShift )  )  ;", "}", "METHOD_END"], "methodName": ["computeRelativeTag"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( long )     ( y    +     ( ParticleSystem . yOffset )  )  )     <  <     ( ParticleSystem . yShift )  )     +     (  (  ( long )     (  ( ParticleSystem . xScale )     *    x )  )     +     ( ParticleSystem . xOffset )  )  ;", "}", "METHOD_END"], "methodName": ["computeTag"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ count )     >  =     ( m _ internalAllocatedCapacity )  )     {", "int   capacity    =     (  ( m _ count )     !  =     0  )     ?     2     *     ( m _ count )     :    Settings . minParticleBufferCapacity ;", "capacity    =     . limitCapacity ( capacity ,    m _ maxCount )  ;", "capacity    =     . limitCapacity ( capacity ,    m _ flagsBuffer . userSuppliedCapacity )  ;", "capacity    =     . limitCapacity ( capacity ,    m _ positionBuffer . userSuppliedCapacity )  ;", "capacity    =     . limitCapacity ( capacity ,    m _ velocityBuffer . userSuppliedCapacity )  ;", "capacity    =     . limitCapacity ( capacity ,    m _ colorBuffer . userSuppliedCapacity )  ;", "capacity    =     . limitCapacity ( capacity ,    m _ userDataBuffer . userSuppliedCapacity )  ;", "if    (  ( m _ internalAllocatedCapacity )     <    capacity )     {", "m _ flagsBuffer . data    =     . reallocateBuffer ( m _ flagsBuffer ,    m _ internalAllocatedCapacity ,    capacity ,    false )  ;", "m _ positionBuffer . data    =     . reallocateBuffer ( m _ positionBuffer ,    m _ internalAllocatedCapacity ,    capacity ,    false )  ;", "m _ velocityBuffer . data    =     . reallocateBuffer ( m _ velocityBuffer ,    m _ internalAllocatedCapacity ,    capacity ,    false )  ;", "m _ accumulationBuffer    =    BufferUtils . reallocateBuffer ( m _ accumulationBuffer ,     0  ,    m _ internalAllocatedCapacity ,    capacity ,    false )  ;", "m _ accumulation 2 Buffer    =    BufferUtils . reallocateBuffer ( Vec 2  . class ,    m _ accumulation 2 Buffer ,     0  ,    m _ internalAllocatedCapacity ,    capacity ,    true )  ;", "m _ depthBuffer    =    BufferUtils . reallocateBuffer ( m _ depthBuffer ,     0  ,    m _ internalAllocatedCapacity ,    capacity ,    true )  ;", "m _ colorBuffer . data    =     . reallocateBuffer ( m _ colorBuffer ,    m _ internalAllocatedCapacity ,    capacity ,    true )  ;", "m _ groupBuffer    =    BufferUtils . reallocateBuffer ( ParticleGroup . class ,    m _ groupBuffer ,     0  ,    m _ internalAllocatedCapacity ,    capacity ,    false )  ;", "m _ userDataBuffer . data    =     . reallocateBuffer ( m _ userDataBuffer ,    m _ internalAllocatedCapacity ,    capacity ,    true )  ;", "m _ internalAllocatedCapacity    =    capacity ;", "}", "}", "if    (  ( m _ count )     >  =     ( m _ internalAllocatedCapacity )  )     {", "return   Settings . invalidParticleIndex ;", "}", "int   index    =     ( m _ count )  +  +  ;", "m _ flagsBuffer . data [ index ]     =    def . flags ;", "m _ positionBuffer . data [ index ]  . set ( def . position )  ;", "m _ velocityBuffer . data [ index ]  . set ( def . velocity )  ;", "m _ groupBuffer [ index ]     =    null ;", "if    (  ( m _ depthBuffer )     !  =    null )     {", "m _ depthBuffer [ index ]     =     0  ;", "}", "if    (  (  ( m _ colorBuffer . data )     !  =    null )     |  |     (  ( def . color )     !  =    null )  )     {", "m _ colorBuffer . data    =    requestParticleBuffer ( m _ colorBuffer . dataClass ,    m _ colorBuffer . data )  ;", "m _ colorBuffer . data [ index ]  . set ( def . color )  ;", "}", "if    (  (  ( m _ userDataBuffer . data )     !  =    null )     |  |     (  ( def . userData )     !  =    null )  )     {", "m _ userDataBuffer . data    =    requestParticleBuffer ( m _ userDataBuffer . dataClass ,    m _ userDataBuffer . data )  ;", "m _ userDataBuffer . data [ index ]     =    def . userData ;", "}", "if    (  ( m _ proxyCount )     >  =     ( m _ proxyCapacity )  )     {", "int   oldCapacity    =    m _ proxyCapacity ;", "int   newCapacity    =     (  ( m _ proxyCount )     !  =     0  )     ?     2     *     ( m _ proxyCount )     :    Settings . minParticleBufferCapacity ;", "m _ proxyBuffer    =    BufferUtils . reallocateBuffer (  . Proxy . class ,    m _ proxyBuffer ,    oldCapacity ,    newCapacity )  ;", "m _ proxyCapacity    =    newCapacity ;", "}", "m _ proxyBuffer [  (  ( m _ proxyCount )  +  +  )  ]  . index    =    index ;", "return   index ;", "}", "METHOD_END"], "methodName": ["createParticle"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "float   stride    =    getParticleStride (  )  ;", "final   Transform   identity    =    tempTransform ;", "identity . setIdentity (  )  ;", "Transform   transform    =    tempTransform 2  ;", "transform . setIdentity (  )  ;", "int   firstIndex    =    m _ count ;", "if    (  ( groupDef . shape )     !  =    null )     {", "final   ParticleDef   particleDef    =    tempParticleDef ;", "particleDef . flags    =    groupDef . flags ;", "particleDef . color    =    groupDef . color ;", "particleDef . userData    =    groupDef . userData ;", "Shape   shape    =    groupDef . shape ;", "transform . set ( groupDef . position ,    groupDef . angle )  ;", "AABB   aabb    =    temp ;", "int   childCount    =    shape . getChildCount (  )  ;", "for    ( int   childIndex    =     0  ;    childIndex    <    childCount ;    childIndex +  +  )     {", "if    ( childIndex    =  =     0  )     {", "shape . computeAABB ( aabb ,    identity ,    childIndex )  ;", "} else    {", "AABB   childAABB    =    temp 2  ;", "shape . computeAABB ( childAABB ,    identity ,    childIndex )  ;", "aabb . combine ( childAABB )  ;", "}", "}", "final   float   upperBoundY    =    aabb . upperBound . y ;", "final   float   upperBoundX    =    aabb . upperBound . x ;", "for    ( float   y    =     ( MathUtils . floor (  (  ( aabb . lowerBound . y )     /    stride )  )  )     *    stride ;    y    <    upperBoundY ;    y    +  =    stride )     {", "for    ( float   x    =     ( MathUtils . floor (  (  ( aabb . lowerBound . x )     /    stride )  )  )     *    stride ;    x    <    upperBoundX ;    x    +  =    stride )     {", "Vec 2    p    =    tempVec ;", "p . x    =    x ;", "p . y    =    y ;", "if    ( shape . testPoint ( identity ,    p )  )     {", "Transform . mulToOut ( transform ,    p ,    p )  ;", "particleDef . position . x    =    p . x ;", "particleDef . position . y    =    p . y ;", "p . subLocal ( groupDef . position )  ;", "Vec 2  . crossToOutUnsafe ( groupDef . angularVelocity ,    p ,    particleDef . velocity )  ;", "particleDef . velocity . addLocal ( groupDef . linearVelocity )  ;", "createParticle ( particleDef )  ;", "}", "}", "}", "}", "int   lastIndex    =    m _ count ;", "ParticleGroup   group    =    new   ParticleGroup (  )  ;", "group . m _ system    =    this ;", "group . m _ firstIndex    =    firstIndex ;", "group . m _ lastIndex    =    lastIndex ;", "group . m _ groupFlags    =    groupDef . groupFlags ;", "group . m _ strength    =    groupDef . strength ;", "group . m _ userData    =    groupDef . userData ;", "group . m _ transform . set ( transform )  ;", "group . m _ destroyAutomatically    =    groupDef . destroyAutomatically ;", "group . m _ prev    =    null ;", "group . m _ next    =    m _ groupList ;", "if    (  ( m _ groupList )     !  =    null )     {", "m _ groupList . m _ prev    =    group ;", "}", "m _ groupList    =    group ;", "+  +  ( m _ groupCount )  ;", "for    ( int   i    =    firstIndex ;    i    <    lastIndex ;    i +  +  )     {", "m _ groupBuffer [ i ]     =    group ;", "}", "updateContacts ( true )  ;", "if    (  (  ( groupDef . flags )     &     (  . k _ pairFlags )  )     !  =     0  )     {", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "if    ( a    >    b )     {", "int   temp    =    a ;", "a    =    b ;", "b    =    temp ;", "}", "if    (  ( firstIndex    <  =    a )     &  &     ( b    <    lastIndex )  )     {", "if    (  ( m _ pairCount )     >  =     ( m _ pairCapacity )  )     {", "int   oldCapacity    =    m _ pairCapacity ;", "int   newCapacity    =     (  ( m _ pairCount )     !  =     0  )     ?     2     *     ( m _ pairCount )     :    Settings . minParticleBufferCapacity ;", "m _ pairBuffer    =    BufferUtils . reallocateBuffer (  . Pair . class ,    m _ pairBuffer ,    oldCapacity ,    newCapacity )  ;", "m _ pairCapacity    =    newCapacity ;", "}", ". Pair   pair    =    m _ pairBuffer [ m _ pairCount ]  ;", "pair . indexA    =    a ;", "pair . indexB    =    b ;", "pair . flags    =    contact . flags ;", "pair . strength    =    groupDef . strength ;", "pair . distance    =    MathUtils . distance ( m _ positionBuffer . data [ a ]  ,    m _ positionBuffer . data [ b ]  )  ;", "( m _ pairCount )  +  +  ;", "}", "}", "}", "if    (  (  ( groupDef . flags )     &     (  . k _ triadFlags )  )     !  =     0  )     {", "VoronoiDiagram   diagram    =    new   VoronoiDiagram (  ( lastIndex    -    firstIndex )  )  ;", "for    ( int   i    =    firstIndex ;    i    <    lastIndex ;    i +  +  )     {", "diagram . addGenerator ( m _ positionBuffer . data [ i ]  ,    i )  ;", "}", "diagram . generate (  ( stride    /     2  )  )  ;", "createParticleGroupCallback . system    =    this ;", "createParticleGroupCallback . def    =    groupDef ;", "createParticleGroupCallback . firstIndex    =    firstIndex ;", "diagram . getNodes ( createParticleGroupCallback )  ;", "}", "if    (  (  ( groupDef . groupFlags )     &     ( ParticleGroupType . b 2  _ solidParticleGroup )  )     !  =     0  )     {", "computeDepthForGroup ( group )  ;", "}", "return   group ;", "}", "METHOD_END"], "methodName": ["createParticleGroup"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "int   flags    =    ParticleType . b 2  _ zombieParticle ;", "if    ( callDestructionListener )     {", "flags    |  =    ParticleType . b 2  _ destructionListener ;", "}", "m _ flagsBuffer . data [ index ]     |  =    flags ;", "}", "METHOD_END"], "methodName": ["destroyParticle"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ groupCount )     >     0  ;", "assert   group    !  =    null ;", "if    (  ( m _ world . getDestructionListener (  )  )     !  =    null )     {", "m _ world . getDestructionListener (  )  . sayGoodbye ( group )  ;", "}", "for    ( int   i    =    group . m _ firstIndex ;    i    <     ( group . m _ lastIndex )  ;    i +  +  )     {", "m _ groupBuffer [ i ]     =    null ;", "}", "if    (  ( group . m _ prev )     !  =    null )     {", "group . m _ prev . m _ next    =    group . m _ next ;", "}", "if    (  ( group . m _ next )     !  =    null )     {", "group . m _ next . m _ prev    =    group . m _ prev ;", "}", "if    ( group    =  =     ( m _ groupList )  )     {", "m _ groupList    =    group . m _ next ;", "}", "-  -  ( m _ groupCount )  ;", "}", "METHOD_END"], "methodName": ["destroyParticleGroup"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    group . m _ firstIndex ;    i    <     ( group . m _ lastIndex )  ;    i +  +  )     {", "destroy ( i ,    callDestructionListener )  ;", "}", "}", "METHOD_END"], "methodName": ["destroyParticlesInGroup"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "dpcallback . init ( this ,    shape ,    xf ,    callDestructionListener )  ;", "shape . computeAABB ( temp ,    xf ,     0  )  ;", "m _ world . queryAABB ( dpcallback ,    temp )  ;", "return   dpcallback . destroyed ;", "}", "METHOD_END"], "methodName": ["destroyParticlesInShape"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ density )     *     ( getCriticalVelocitySquared ( step )  )  ;", "}", "METHOD_END"], "methodName": ["getCriticalPressure"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ particleDiameter )     *     ( step . inv _ dt )  ;", "}", "METHOD_END"], "methodName": ["getCriticalVelocity"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "float   velocity    =    getCriticalVelocity ( step )  ;", "return   velocity    *    velocity ;", "}", "METHOD_END"], "methodName": ["getCriticalVelocitySquared"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "m _ colorBuffer . data    =    requestParticleBuffer ( ParticleColor . class ,    m _ colorBuffer . data )  ;", "return   m _ colorBuffer . data ;", "}", "METHOD_END"], "methodName": ["getParticleColorBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ count ;", "}", "METHOD_END"], "methodName": ["getParticleCount"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ dampingStrength ;", "}", "METHOD_END"], "methodName": ["getParticleDamping"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ density ;", "}", "METHOD_END"], "methodName": ["getParticleDensity"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ flagsBuffer . data ;", "}", "METHOD_END"], "methodName": ["getParticleFlagsBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ gravityScale ;", "}", "METHOD_END"], "methodName": ["getParticleGravityScale"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ groupBuffer ;", "}", "METHOD_END"], "methodName": ["getParticleGroupBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ groupCount ;", "}", "METHOD_END"], "methodName": ["getParticleGroupCount"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ groupBuffer ;", "}", "METHOD_END"], "methodName": ["getParticleGroupList"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return    (  (  1  .  7  7  7  7  7  7 F    *     ( m _ inverseDensity )  )     *     ( m _ inverseDiameter )  )     *     ( m _ inverseDiameter )  ;", "}", "METHOD_END"], "methodName": ["getParticleInvMass"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "float   stride    =    getParticleStride (  )  ;", "return    (  ( m _ density )     *    stride )     *    stride ;", "}", "METHOD_END"], "methodName": ["getParticleMass"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ maxCount ;", "}", "METHOD_END"], "methodName": ["getParticleMaxCount"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ positionBuffer . data ;", "}", "METHOD_END"], "methodName": ["getParticlePositionBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ particleDiameter )     /     2  ;", "}", "METHOD_END"], "methodName": ["getParticleRadius"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return    ( Settings . particleStride )     *     ( m _ particleDiameter )  ;", "}", "METHOD_END"], "methodName": ["getParticleStride"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "m _ userDataBuffer . data    =    requestParticleBuffer ( Object . class ,    m _ userDataBuffer . data )  ;", "return   m _ userDataBuffer . data ;", "}", "METHOD_END"], "methodName": ["getParticleUserDataBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return   m _ velocityBuffer . data ;", "}", "METHOD_END"], "methodName": ["getParticleVelocityBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "assert   groupA    !  =    groupB ;", "RotateBuffer ( groupB . m _ firstIndex ,    groupB . m _ lastIndex ,    m _ count )  ;", "assert    ( groupB . m _ lastIndex )     =  =     ( m _ count )  ;", "RotateBuffer ( groupA . m _ firstIndex ,    groupA . m _ lastIndex ,    groupB . m _ firstIndex )  ;", "assert    ( groupA . m _ lastIndex )     =  =     ( groupB . m _ firstIndex )  ;", "int   particleFlags    =     0  ;", "for    ( int   i    =    groupA . m _ firstIndex ;    i    <     ( groupB . m _ lastIndex )  ;    i +  +  )     {", "particleFlags    |  =    m _ flagsBuffer . data [ i ]  ;", "}", "updateContacts ( true )  ;", "if    (  ( particleFlags    &     (  . k _ pairFlags )  )     !  =     0  )     {", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "if    ( a    >    b )     {", "int   temp    =    a ;", "a    =    b ;", "b    =    temp ;", "}", "if    (  (  (  (  ( groupA . m _ firstIndex )     <  =    a )     &  &     ( a    <     ( groupA . m _ lastIndex )  )  )     &  &     (  ( groupB . m _ firstIndex )     <  =    b )  )     &  &     ( b    <     ( groupB . m _ lastIndex )  )  )     {", "if    (  ( m _ pairCount )     >  =     ( m _ pairCapacity )  )     {", "int   oldCapacity    =    m _ pairCapacity ;", "int   newCapacity    =     (  ( m _ pairCount )     !  =     0  )     ?     2     *     ( m _ pairCount )     :    Settings . minParticleBufferCapacity ;", "m _ pairBuffer    =    BufferUtils . reallocateBuffer (  . Pair . class ,    m _ pairBuffer ,    oldCapacity ,    newCapacity )  ;", "m _ pairCapacity    =    newCapacity ;", "}", ". Pair   pair    =    m _ pairBuffer [ m _ pairCount ]  ;", "pair . indexA    =    a ;", "pair . indexB    =    b ;", "pair . flags    =    contact . flags ;", "pair . strength    =    MathUtils . min ( groupA . m _ strength ,    groupB . m _ strength )  ;", "pair . distance    =    MathUtils . distance ( m _ positionBuffer . data [ a ]  ,    m _ positionBuffer . data [ b ]  )  ;", "( m _ pairCount )  +  +  ;", "}", "}", "}", "if    (  ( particleFlags    &     (  . k _ triadFlags )  )     !  =     0  )     {", "VoronoiDiagram   diagram    =    new   VoronoiDiagram (  (  ( groupB . m _ lastIndex )     -     ( groupA . m _ firstIndex )  )  )  ;", "for    ( int   i    =    groupA . m _ firstIndex ;    i    <     ( groupB . m _ lastIndex )  ;    i +  +  )     {", "if    (  (  ( m _ flagsBuffer . data [ i ]  )     &     ( ParticleType . b 2  _ zombieParticle )  )     =  =     0  )     {", "diagram . addGenerator ( m _ positionBuffer . data [ i ]  ,    i )  ;", "}", "}", "diagram . generate (  (  ( getParticleStride (  )  )     /     2  )  )  ;", ". JoinParticleGroupsCallback   callback    =    new    . JoinParticleGroupsCallback (  )  ;", "callback . system    =    this ;", "callback . groupA    =    groupA ;", "callback . groupB    =    groupB ;", "diagram . getNodes ( callback )  ;", "}", "for    ( int   i    =    groupB . m _ firstIndex ;    i    <     ( groupB . m _ lastIndex )  ;    i +  +  )     {", "m _ groupBuffer [ i ]     =    groupA ;", "}", "int   groupFlags    =     ( groupA . m _ groupFlags )     |     ( groupB . m _ groupFlags )  ;", "groupA . m _ groupFlags    =    groupFlags ;", "groupA . m _ lastIndex    =    groupB . m _ lastIndex ;", "groupB . m _ firstIndex    =    groupB . m _ lastIndex ;", "destroyParticleGroup ( groupB )  ;", "if    (  ( groupFlags    &     ( ParticleGroupType . b 2  _ solidParticleGroup )  )     !  =     0  )     {", "computeDepthForGroup ( groupA )  ;", "}", "}", "METHOD_END"], "methodName": ["joinParticleGroups"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return    ( maxCount    !  =     0  )     &  &     ( capacity    >    maxCount )     ?    maxCount    :    capacity ;", "}", "METHOD_END"], "methodName": ["limitCapacity"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "int   left    =     0  ;", "int   p ;", "int   curr ;", "while    ( length    >     0  )     {", "p    =    length    /     2  ;", "curr    =    left    +    p ;", "if    (  ( ray [ curr ]  . tag )     <    tag )     {", "left    =    curr    +     1  ;", "length    -  =    p    +     1  ;", "} else    {", "length    =    p ;", "}", "}", "return   left ;", "}", "METHOD_END"], "methodName": ["lowerBound"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ proxyCount )     =  =     0  )     {", "return ;", "}", "final   float   lowerBoundX    =    aabb . lowerBound . x ;", "final   float   lowerBoundY    =    aabb . lowerBound . y ;", "final   float   upperBoundX    =    aabb . upperBound . x ;", "final   float   upperBoundY    =    aabb . upperBound . y ;", "int   firstProxy    =     . lowerBound ( m _ proxyBuffer ,    m _ proxyCount ,     . computeTag (  (  ( m _ inverseDiameter )     *    lowerBoundX )  ,     (  ( m _ inverseDiameter )     *    lowerBoundY )  )  )  ;", "int   lastProxy    =     . upperBound ( m _ proxyBuffer ,    m _ proxyCount ,     . computeTag (  (  ( m _ inverseDiameter )     *    upperBoundX )  ,     (  ( m _ inverseDiameter )     *    upperBoundY )  )  )  ;", "for    ( int   proxy    =    firstProxy ;    proxy    <    lastProxy ;     +  + proxy )     {", "int   i    =    m _ proxyBuffer [ proxy ]  . index ;", "final   Vec 2    p    =    m _ positionBuffer . data [ i ]  ;", "if    (  (  (  ( lowerBoundX    <     ( p . x )  )     &  &     (  ( p . x )     <    upperBoundX )  )     &  &     ( lowerBoundY    <     ( p . y )  )  )     &  &     (  ( p . y )     <    upperBoundY )  )     {", "if    (  !  ( callback . reportParticle ( i )  )  )     {", "break ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["queryAABB"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ proxyCount )     =  =     0  )     {", "return ;", "}", "int   firstProxy    =     . lowerBound ( m _ proxyBuffer ,    m _ proxyCount ,     . computeTag (  (  (  ( m _ inverseDiameter )     *     ( MathUtils . min ( point 1  . x ,    point 2  . x )  )  )     -     1  )  ,     (  (  ( m _ inverseDiameter )     *     ( MathUtils . min ( point 1  . y ,    point 2  . y )  )  )     -     1  )  )  )  ;", "int   lastProxy    =     . upperBound ( m _ proxyBuffer ,    m _ proxyCount ,     . computeTag (  (  (  ( m _ inverseDiameter )     *     ( MathUtils . max ( point 1  . x ,    point 2  . x )  )  )     +     1  )  ,     (  (  ( m _ inverseDiameter )     *     ( MathUtils . max ( point 1  . y ,    point 2  . y )  )  )     +     1  )  )  )  ;", "float   fraction    =     1  ;", "final   float   vx    =     ( point 2  . x )     -     ( point 1  . x )  ;", "final   float   vy    =     ( point 2  . y )     -     ( point 1  . y )  ;", "float   v 2     =     ( vx    *    vx )     +     ( vy    *    vy )  ;", "if    ( v 2     =  =     0  )", "v 2     =    Float . MAX _ VALUE ;", "for    ( int   proxy    =    firstProxy ;    proxy    <    lastProxy ;     +  + proxy )     {", "int   i    =    m _ proxyBuffer [ proxy ]  . index ;", "final   Vec 2    posI    =    m _ positionBuffer . data [ i ]  ;", "final   float   px    =     ( point 1  . x )     -     ( posI . x )  ;", "final   float   py    =     ( point 1  . y )     -     ( posI . y )  ;", "float   pv    =     ( px    *    vx )     +     ( py    *    vy )  ;", "float   p 2     =     ( px    *    px )     +     ( py    *    py )  ;", "float   determinant    =     ( pv    *    pv )     -     ( v 2     *     ( p 2     -     ( m _ squaredDiameter )  )  )  ;", "if    ( determinant    >  =     0  )     {", "float   sqrtDeterminant    =    MathUtils . sqrt ( determinant )  ;", "float   t    =     (  (  - pv )     -    sqrtDeterminant )     /    v 2  ;", "if    ( t    >    fraction )     {", "continue ;", "}", "if    ( t    <     0  )     {", "t    =     (  (  - pv )     +    sqrtDeterminant )     /    v 2  ;", "if    (  ( t    <     0  )     |  |     ( t    >    fraction )  )     {", "continue ;", "}", "}", "final   Vec 2    n    =    tempVec ;", "tempVec . x    =    px    +     ( t    *    vx )  ;", "tempVec . y    =    py    +     ( t    *    vy )  ;", "n . normalize (  )  ;", "final   Vec 2    point    =    tempVec 2  ;", "point . x    =     ( point 1  . x )     +     ( t    *    vx )  ;", "point . y    =     ( point 1  . y )     +     ( t    *    vy )  ;", "float   f    =    callback . reportParticle ( i ,    point ,    n ,    t )  ;", "fraction    =    MathUtils . min ( fraction ,    f )  ;", "if    ( fraction    <  =     0  )     {", "break ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["raycast"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "assert   newCapacity    >    oldCapacity ;", "return   BufferUtils . reallocateBuffer ( buffer . dataClass ,    buffer . data ,    buffer . userSuppliedCapacity ,    oldCapacity ,    newCapacity ,    deferred )  ;", "}", "METHOD_END"], "methodName": ["reallocateBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "assert   newCapacity    >    oldCapacity ;", "return   BufferUtils . reallocateBuffer ( buffer . data ,    buffer . userSuppliedCapacity ,    oldCapacity ,    newCapacity ,    deferred )  ;", "}", "METHOD_END"], "methodName": ["reallocateBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "if    ( buffer    =  =    null )     {", "buffer    =    new   float [ m _ internalAllocatedCacity ]  ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["requestParticleBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "if    ( buffer    =  =    null )     {", "buffer    =     (  ( T [  ]  )     ( ArrayReflection . newInstance ( klass ,    m _ internalAllocatedCacity )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ internalAllocatedCacity )  ;    i +  +  )     {", "try    {", "buffer [ i ]     =    ClassReflection . newInstance ( klass )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["requestParticleBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "assert    (  ( newData    !  =    null )     &  &     ( newCapacity    !  =     0  )  )     |  |     (  ( newData    =  =    null )     &  &     ( newCapacity    =  =     0  )  )  ;", "if    (  ( buffer . userSuppliedCapacity )     !  =     0  )     {", "}", "buffer . data    =    newData ;", "buffer . userSuppliedCapacity    =    newCapacity ;", "}", "METHOD_END"], "methodName": ["setParticleBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "assert    (  ( newData    !  =    null )     &  &     ( newCapacity    !  =     0  )  )     |  |     (  ( newData    =  =    null )     &  &     ( newCapacity    =  =     0  )  )  ;", "if    (  ( buffer . userSuppliedCapacity )     !  =     0  )     {", "}", "buffer . data    =    newData ;", "buffer . userSuppliedCapacity    =    newCapacity ;", "}", "METHOD_END"], "methodName": ["setParticleBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "setParticleBuffer ( m _ colorBuffer ,    buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticleColorBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "m _ dampingStrength    =    damping ;", "}", "METHOD_END"], "methodName": ["setParticleDamping"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "m _ density    =    density ;", "m _ inverseDensity    =     1     /     ( m _ density )  ;", "}", "METHOD_END"], "methodName": ["setParticleDensity"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "setParticleBuffer ( m _ flagsBuffer ,    buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticleFlagsBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "m _ gravityScale    =    gravityScale ;", "}", "METHOD_END"], "methodName": ["setParticleGravityScale"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ count )     <  =    count ;", "m _ maxCount    =    count ;", "}", "METHOD_END"], "methodName": ["setParticleMaxCount"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "setParticleBuffer ( m _ positionBuffer ,    buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticlePositionBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "m _ particleDiameter    =     2     *    radius ;", "m _ squaredDiameter    =     ( m _ particleDiameter )     *     ( m _ particleDiameter )  ;", "m _ inverseDiameter    =     1     /     ( m _ particleDiameter )  ;", "}", "METHOD_END"], "methodName": ["setParticleRadius"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "setParticleBuffer ( m _ userDataBuffer ,    buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticleUserDataBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "setParticleBuffer ( m _ velocityBuffer ,    buffer ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["setParticleVelocityBuffer"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "+  +  ( m _ timestamp )  ;", "if    (  ( m _ count )     =  =     0  )     {", "return ;", "}", "m _ allFlags    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "m _ allFlags    |  =    m _ flagsBuffer . data [ i ]  ;", "}", "if    (  (  ( m _ allFlags )     &     ( Type . b 2  _ zombie )  )     !  =     0  )     {", "solveZombie (  )  ;", "}", "if    (  ( m _ count )     =  =     0  )     {", "return ;", "}", "m _ allGroupFlags    =     0  ;", "for    ( Group   group    =    m _ groupList ;    group    !  =    null ;    group    =    group . getNext (  )  )     {", "m _ allGroupFlags    |  =    group . m _ groupFlags ;", "}", "final   float   gravityx    =     (  ( step . dt )     *     ( m _ gravityScale )  )     *     ( m _ world . getGravity (  )  . x )  ;", "final   float   gravityy    =     (  ( step . dt )     *     ( m _ gravityScale )  )     *     ( m _ world . getGravity (  )  . y )  ;", "float   criticalVelocytySquared    =    getCriticalVelocitySquared ( step )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "Vec 2    v    =    m _ velocityBuffer . data [ i ]  ;", "v . x    +  =    gravityx ;", "v . y    +  =    gravityy ;", "float   v 2     =     (  ( v . x )     *     ( v . x )  )     +     (  ( v . y )     *     ( v . y )  )  ;", "if    ( v 2     >    criticalVelocytySquared )     {", "float   a    =     ( v 2     =  =     0  )     ?    Float . MAX _ VALUE    :    MathUtils . sqrt (  ( criticalVelocytySquared    /    v 2  )  )  ;", "v . x    *  =    a ;", "v . y    *  =    a ;", "}", "}", "solveCollision ( step )  ;", "if    (  (  ( m _ allGroupFlags )     &     ( GroupType . b 2  _ rigidGroup )  )     !  =     0  )     {", "solveRigid ( step )  ;", "}", "if    (  (  ( m _ allFlags )     &     ( Type . b 2  _ wall )  )     !  =     0  )     {", "solveWall ( step )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "Vec 2    pos    =    m _ positionBuffer . data [ i ]  ;", "Vec 2    vel    =    m _ velocityBuffer . data [ i ]  ;", "pos . x    +  =     ( step . dt )     *     ( vel . x )  ;", "pos . y    +  =     ( step . dt )     *     ( vel . y )  ;", "}", "updateBodyContacts (  )  ;", "updateContacts ( false )  ;", "if    (  (  ( m _ allFlags )     &     ( Type . b 2  _ viscous )  )     !  =     0  )     {", "solveViscous ( step )  ;", "}", "if    (  (  ( m _ allFlags )     &     ( Type . b 2  _ powder )  )     !  =     0  )     {", "solvePowder ( step )  ;", "}", "if    (  (  ( m _ allFlags )     &     ( Type . b 2  _ tensile )  )     !  =     0  )     {", "solveTensile ( step )  ;", "}", "if    (  (  ( m _ allFlags )     &     ( Type . b 2  _ elastic )  )     !  =     0  )     {", "solveElastic ( step )  ;", "}", "if    (  (  ( m _ allFlags )     &     ( Type . b 2  _ spring )  )     !  =     0  )     {", "solveSpring ( step )  ;", "}", "if    (  (  ( m _ allGroupFlags )     &     ( GroupType . b 2  _ solidGroup )  )     !  =     0  )     {", "solveSolid ( step )  ;", "}", "if    (  (  ( m _ allFlags )     &     ( Type . b 2  _ colorMixing )  )     !  =     0  )     {", "solveColorMixing ( step )  ;", "}", "solvePressure ( step )  ;", "solveDamping ( step )  ;", "}", "METHOD_END"], "methodName": ["solve"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "final   AABB   aabb    =    temp ;", "final   Vec 2    lowerBound    =    aabb . lowerBound ;", "final   Vec 2    upperBound    =    aabb . upperBound ;", "lowerBound . x    =    Float . MAX _ VALUE ;", "lowerBound . y    =    Float . MAX _ VALUE ;", "upperBound . x    =     -  ( Float . MAX _ VALUE )  ;", "upperBound . y    =     -  ( Float . MAX _ VALUE )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "final   Vec 2    v    =    m _ velocityBuffer . data [ i ]  ;", "final   Vec 2    p 1     =    m _ positionBuffer . data [ i ]  ;", "final   float   p 1 x    =    p 1  . x ;", "final   float   p 1 y    =    p 1  . y ;", "final   float   p 2 x    =    p 1 x    +     (  ( step . dt )     *     ( v . x )  )  ;", "final   float   p 2 y    =    p 1 y    +     (  ( step . dt )     *     ( v . y )  )  ;", "final   float   bx    =     ( p 1 x    <    p 2 x )     ?    p 1 x    :    p 2 x ;", "final   float   by    =     ( p 1 y    <    p 2 y )     ?    p 1 y    :    p 2 y ;", "lowerBound . x    =     (  ( lowerBound . x )     <    bx )     ?    lowerBound . x    :    bx ;", "lowerBound . y    =     (  ( lowerBound . y )     <    by )     ?    lowerBound . y    :    by ;", "final   float   b 1 x    =     ( p 1 x    >    p 2 x )     ?    p 1 x    :    p 2 x ;", "final   float   b 1 y    =     ( p 1 y    >    p 2 y )     ?    p 1 y    :    p 2 y ;", "upperBound . x    =     (  ( upperBound . x )     >    b 1 x )     ?    upperBound . x    :    b 1 x ;", "upperBound . y    =     (  ( upperBound . y )     >    b 1 y )     ?    upperBound . y    :    b 1 y ;", "}", "sccallback . step    =    step ;", "sccallback . s    =    this ;", "m _ world . queryAABB ( sccallback ,    aabb )  ;", "}", "METHOD_END"], "methodName": ["solveCollision"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "m _ colorBuffer . data    =    requestParticleBuffer ( ParticleColor . class ,    m _ colorBuffer . data )  ;", "int   colorMixing 2  5  6     =     (  ( int )     (  2  5  6     *     ( m _ colorMixingStrength )  )  )  ;", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "if    (  (  (  ( m _ flagsBuffer . data [ a ]  )     &     ( m _ flagsBuffer . data [ b ]  )  )     &     ( ParticleType . b 2  _ colorMixingParticle )  )     !  =     0  )     {", "ParticleColor   colorA    =    m _ colorBuffer . data [ a ]  ;", "ParticleColor   colorB    =    m _ colorBuffer . data [ b ]  ;", "int   dr    =     ( colorMixing 2  5  6     *     (  ( colorB . r )     -     ( colorA . r )  )  )     >  >     8  ;", "int   dg    =     ( colorMixing 2  5  6     *     (  ( colorB . g )     -     ( colorA . g )  )  )     >  >     8  ;", "int   db    =     ( colorMixing 2  5  6     *     (  ( colorB . b )     -     ( colorA . b )  )  )     >  >     8  ;", "int   da    =     ( colorMixing 2  5  6     *     (  ( colorB . a )     -     ( colorA . a )  )  )     >  >     8  ;", "colorA . r    +  =    dr ;", "colorA . g    +  =    dg ;", "colorA . b    +  =    db ;", "colorA . a    +  =    da ;", "colorB . r    -  =    dr ;", "colorB . g    -  =    dg ;", "colorB . b    -  =    db ;", "colorB . a    -  =    da ;", "}", "}", "}", "METHOD_END"], "methodName": ["solveColorMixing"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "float   damping    =    m _ dampingStrength ;", "for    ( int   k    =     0  ;    k    <     ( m _ bodyContactCount )  ;    k +  +  )     {", "final   BodyContact   contact    =    m _ bodyContactBuffer [ k ]  ;", "int   a    =    contact . index ;", "Body   b    =    contact . body ;", "float   w    =    contact . weight ;", "float   m    =    contact . mass ;", "Vec 2    n    =    contact . normal ;", "Vec 2    p    =    m _ positionBuffer . data [ a ]  ;", "final   float   tempX    =     ( p . x )     -     ( b . m _ sweep . c . x )  ;", "final   float   tempY    =     ( p . y )     -     ( b . m _ sweep . c . y )  ;", "final   Vec 2    velA    =    m _ velocityBuffer . data [ a ]  ;", "float   vx    =     (  (  (  -  ( b . m _ angularVelocity )  )     *    tempY )     +     ( b . m _ linearVelocity . x )  )     -     ( velA . x )  ;", "float   vy    =     (  (  ( b . m _ angularVelocity )     *    tempX )     +     ( b . m _ linearVelocity . y )  )     -     ( velA . y )  ;", "float   vn    =     ( vx    *     ( n . x )  )     +     ( vy    *     ( n . y )  )  ;", "if    ( vn    <     0  )     {", "final   Vec 2    f    =    tempVec ;", "f . x    =     (  (  ( damping    *    w )     *    m )     *    vn )     *     ( n . x )  ;", "f . y    =     (  (  ( damping    *    w )     *    m )     *    vn )     *     ( n . y )  ;", "final   float   invMass    =    getInvMass (  )  ;", "velA . x    +  =    invMass    *     ( f . x )  ;", "velA . y    +  =    invMass    *     ( f . y )  ;", "f . x    =     -  ( f . x )  ;", "f . y    =     -  ( f . y )  ;", "b . applyLinearImpulse ( f ,    p ,    true )  ;", "}", "}", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   Contact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "float   w    =    contact . weight ;", "Vec 2    n    =    contact . normal ;", "final   Vec 2    velA    =    m _ velocityBuffer . data [ a ]  ;", "final   Vec 2    velB    =    m _ velocityBuffer . data [ b ]  ;", "final   float   vx    =     ( velB . x )     -     ( velA . x )  ;", "final   float   vy    =     ( velB . y )     -     ( velA . y )  ;", "float   vn    =     ( vx    *     ( n . x )  )     +     ( vy    *     ( n . y )  )  ;", "if    ( vn    <     0  )     {", "float   fx    =     (  ( damping    *    w )     *    vn )     *     ( n . x )  ;", "float   fy    =     (  ( damping    *    w )     *    vn )     *     ( n . y )  ;", "velA . x    +  =    fx ;", "velA . y    +  =    fy ;", "velB . x    -  =    fx ;", "velB . y    -  =    fy ;", "}", "}", "}", "METHOD_END"], "methodName": ["solveDamping"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "float   elasticStrength    =     ( step . inv _ dt )     *     ( m _ elasticStrength )  ;", "for    ( int   k    =     0  ;    k    <     ( m _ triadCount )  ;    k +  +  )     {", "final    . Triad   triad    =    m _ triadBuffer [ k ]  ;", "if    (  (  ( triad . flags )     &     ( ParticleType . b 2  _ elasticParticle )  )     !  =     0  )     {", "int   a    =    triad . indexA ;", "int   b    =    triad . indexB ;", "int   c    =    triad . indexC ;", "final   Vec 2    oa    =    triad . pa ;", "final   Vec 2    ob    =    triad . pb ;", "final   Vec 2    oc    =    triad . pc ;", "final   Vec 2    pa    =    m _ positionBuffer . data [ a ]  ;", "final   Vec 2    pb    =    m _ positionBuffer . data [ b ]  ;", "final   Vec 2    pc    =    m _ positionBuffer . data [ c ]  ;", "final   float   px    =     (  1  .  0 F    /     3  )     *     (  (  ( pa . x )     +     ( pb . x )  )     +     ( pc . x )  )  ;", "final   float   py    =     (  1  .  0 F    /     3  )     *     (  (  ( pa . y )     +     ( pb . y )  )     +     ( pc . y )  )  ;", "float   rs    =     (  ( Vec 2  . cross ( oa ,    pa )  )     +     ( Vec 2  . cross ( ob ,    pb )  )  )     +     ( Vec 2  . cross ( oc ,    pc )  )  ;", "float   rc    =     (  ( Vec 2  . dot ( oa ,    pa )  )     +     ( Vec 2  . dot ( ob ,    pb )  )  )     +     ( Vec 2  . dot ( oc ,    pc )  )  ;", "float   r 2     =     ( rs    *    rs )     +     ( rc    *    rc )  ;", "float   invR    =     ( r 2     =  =     0  )     ?    Float . MAX _ VALUE    :    MathUtils . sqrt (  (  1  .  0 F    /    r 2  )  )  ;", "rs    *  =    invR ;", "rc    *  =    invR ;", "final   float   strength    =    elasticStrength    *     ( triad . strength )  ;", "final   float   roax    =     ( rc    *     ( oa . x )  )     -     ( rs    *     ( oa . y )  )  ;", "final   float   roay    =     ( rs    *     ( oa . x )  )     +     ( rc    *     ( oa . y )  )  ;", "final   float   robx    =     ( rc    *     ( ob . x )  )     -     ( rs    *     ( ob . y )  )  ;", "final   float   roby    =     ( rs    *     ( ob . x )  )     +     ( rc    *     ( ob . y )  )  ;", "final   float   rocx    =     ( rc    *     ( oc . x )  )     -     ( rs    *     ( oc . y )  )  ;", "final   float   rocy    =     ( rs    *     ( oc . x )  )     +     ( rc    *     ( oc . y )  )  ;", "final   Vec 2    va    =    m _ velocityBuffer . data [ a ]  ;", "final   Vec 2    vb    =    m _ velocityBuffer . data [ b ]  ;", "final   Vec 2    vc    =    m _ velocityBuffer . data [ c ]  ;", "va . x    +  =    strength    *     ( roax    -     (  ( pa . x )     -    px )  )  ;", "va . y    +  =    strength    *     ( roay    -     (  ( pa . y )     -    py )  )  ;", "vb . x    +  =    strength    *     ( robx    -     (  ( pb . x )     -    px )  )  ;", "vb . y    +  =    strength    *     ( roby    -     (  ( pb . y )     -    py )  )  ;", "vc . x    +  =    strength    *     ( rocx    -     (  ( pc . x )     -    px )  )  ;", "vc . y    +  =    strength    *     ( rocy    -     (  ( pc . y )     -    py )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["solveElastic"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "float   powderStrength    =     ( m _ powderStrength )     *     ( getCriticalVelocity ( step )  )  ;", "float   minWeight    =     1  .  0 F    -     ( SettingsStride )  ;", "for    ( int   k    =     0  ;    k    <     ( m _ bodyContactCount )  ;    k +  +  )     {", "final   ParticleBodyContact   contact    =    m _ bodyContactBuffer [ k ]  ;", "int   a    =    contact . index ;", "if    (  (  ( m _ flagsBuffer . data [ a ]  )     &     ( ParticleType . b 2  _ powderParticle )  )     !  =     0  )     {", "float   w    =    contact . weight ;", "if    ( w    >    minWeight )     {", "Body   b    =    contact . body ;", "float   m    =    contact . mass ;", "Vec 2    p    =    m _ positionBuffer . data [ a ]  ;", "Vec 2    n    =    contact . normal ;", "final   Vec 2    f    =    tempVec ;", "final   Vec 2    va    =    m _ velocityBuffer . data [ a ]  ;", "final   float   inter    =     ( powderStrength    *    m )     *     ( w    -    minWeight )  ;", "final   float   pInvMass    =    getParticleInvMass (  )  ;", "f . x    =    inter    *     ( n . x )  ;", "f . y    =    inter    *     ( n . y )  ;", "va . x    -  =    pInvMass    *     ( f . x )  ;", "va . y    -  =    pInvMass    *     ( f . y )  ;", "b . applyLinearImpulse ( f ,    p ,    true )  ;", "}", "}", "}", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "if    (  (  ( contact . flags )     &     ( ParticleType . b 2  _ powderParticle )  )     !  =     0  )     {", "float   w    =    contact . weight ;", "if    ( w    >    minWeight )     {", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "Vec 2    n    =    contact . normal ;", "final   Vec 2    va    =    m _ velocityBuffer . data [ a ]  ;", "final   Vec 2    vb    =    m _ velocityBuffer . data [ b ]  ;", "final   float   inter    =    powderStrength    *     ( w    -    minWeight )  ;", "final   float   fx    =    inter    *     ( n . x )  ;", "final   float   fy    =    inter    *     ( n . y )  ;", "va . x    -  =    fx ;", "va . y    -  =    fy ;", "vb . x    +  =    fx ;", "vb . y    +  =    fy ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["solvePowder"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "m _ accumulationBuffer [ i ]     =     0  ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ bodyContactCount )  ;    k +  +  )     {", "ParticleBodyContact   contact    =    m _ bodyContactBuffer [ k ]  ;", "int   a    =    contact . index ;", "float   w    =    contact . weight ;", "m _ accumulationBuffer [ a ]     +  =    w ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "float   w    =    contact . weight ;", "m _ accumulationBuffer [ a ]     +  =    w ;", "m _ accumulationBuffer [ b ]     +  =    w ;", "}", "if    (  (  ( m _ allParticleFlags )     &     (  . k _ noPressureFlags )  )     !  =     0  )     {", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "if    (  (  ( m _ flagsBuffer . data [ i ]  )     &     (  . k _ noPressureFlags )  )     !  =     0  )     {", "m _ accumulationBuffer [ i ]     =     0  ;", "}", "}", "}", "float   pressurePerWeight    =     ( m _ pressureStrength )     *     ( getCriticalPressure ( step )  )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "float   w    =    m _ accumulationBuffer [ i ]  ;", "float   h    =    pressurePerWeight    *     ( MathUtils . max (  0  .  0 F ,     (  ( MathUtils . min ( w ,    Settings . maxParticleWeight )  )     -     ( Settings . minParticleWeight )  )  )  )  ;", "m _ accumulationBuffer [ i ]     =    h ;", "}", "float   velocityPerPressure    =     ( step . dt )     /     (  ( m _ density )     *     ( m _ particleDiameter )  )  ;", "for    ( int   k    =     0  ;    k    <     ( m _ bodyContactCount )  ;    k +  +  )     {", "ParticleBodyContact   contact    =    m _ bodyContactBuffer [ k ]  ;", "int   a    =    contact . index ;", "Body   b    =    contact . body ;", "float   w    =    contact . weight ;", "float   m    =    contact . mass ;", "Vec 2    n    =    contact . normal ;", "Vec 2    p    =    m _ positionBuffer . data [ a ]  ;", "float   h    =     ( m _ accumulationBuffer [ a ]  )     +     ( pressurePerWeight    *    w )  ;", "final   Vec 2    f    =    tempVec ;", "final   float   coef    =     (  ( velocityPerPressure    *    w )     *    m )     *    h ;", "f . x    =    coef    *     ( n . x )  ;", "f . y    =    coef    *     ( n . y )  ;", "final   Vec 2    velData    =    m _ velocityBuffer . data [ a ]  ;", "final   float   particleInvMass    =    getParticleInvMass (  )  ;", "velData . x    -  =    particleInvMass    *     ( f . x )  ;", "velData . y    -  =    particleInvMass    *     ( f . y )  ;", "b . applyLinearImpulse ( f ,    p ,    true )  ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "float   w    =    contact . weight ;", "Vec 2    n    =    contact . normal ;", "float   h    =     ( m _ accumulationBuffer [ a ]  )     +     ( m _ accumulationBuffer [ b ]  )  ;", "final   float   fx    =     (  ( velocityPerPressure    *    w )     *    h )     *     ( n . x )  ;", "final   float   fy    =     (  ( velocityPerPressure    *    w )     *    h )     *     ( n . y )  ;", "final   Vec 2    velDataA    =    m _ velocityBuffer . data [ a ]  ;", "final   Vec 2    velDataB    =    m _ velocityBuffer . data [ b ]  ;", "velDataA . x    -  =    fx ;", "velDataA . y    -  =    fy ;", "velDataB . x    +  =    fx ;", "velDataB . y    +  =    fy ;", "}", "}", "METHOD_END"], "methodName": ["solvePressure"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( ParticleGroup   group    =    m _ groupList ;    group    !  =    null ;    group    =    group . getNext (  )  )     {", "if    (  (  ( group . m _ groupFlags )     &     ( ParticleGroupType . b 2  _ rigidParticleGroup )  )     !  =     0  )     {", "group . updateStatistics (  )  ;", "Vec 2    temp    =    tempVec ;", "Vec 2    cross    =    tempVec 2  ;", "Rot   rotation    =    tempRot ;", "rotation . set (  (  ( step . dt )     *     ( group . m _ angularVelocity )  )  )  ;", "Rot . mulToOutUnsafe ( rotation ,    group . m _ center ,    cross )  ;", "temp . set ( group . m _ linearVelocity )  . mulLocal ( step . dt )  . addLocal ( group . m _ center )  . subLocal ( cross )  ;", "tempXf . p . set ( temp )  ;", "tempXf . q . set ( rotation )  ;", "Transform . mulToOut ( tempXf ,    group . m _ transform ,    group . m _ transform )  ;", "final   Transform   velocityTransform    =    tempXf 2  ;", "velocityTransform . p . x    =     ( step . inv _ dt )     *     ( tempXf . p . x )  ;", "velocityTransform . p . y    =     ( step . inv _ dt )     *     ( tempXf . p . y )  ;", "velocityTransform . q . s    =     ( step . inv _ dt )     *     ( tempXf . q . s )  ;", "velocityTransform . q . c    =     ( step . inv _ dt )     *     (  ( tempXf . q . c )     -     1  )  ;", "for    ( int   i    =    group . m _ firstIndex ;    i    <     ( group . m _ lastIndex )  ;    i +  +  )     {", "Transform . mulToOutUnsafe ( velocityTransform ,    m _ positionBuffer . data [ i ]  ,    m _ velocityBuffer . data [ i ]  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["solveRigid"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "m _ depthBuffer    =    requestParticleBuffer ( m _ depthBuffer )  ;", "float   ejectionStrength    =     ( step . inv _ dt )     *     ( m _ ejectionStrength )  ;", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "if    (  ( m _ groupBuffer [ a ]  )     !  =     ( m _ groupBuffer [ b ]  )  )     {", "float   w    =    contact . weight ;", "Vec 2    n    =    contact . normal ;", "float   h    =     ( m _ depthBuffer [ a ]  )     +     ( m _ depthBuffer [ b ]  )  ;", "final   Vec 2    va    =    m _ velocityBuffer . data [ a ]  ;", "final   Vec 2    vb    =    m _ velocityBuffer . data [ b ]  ;", "final   float   inter    =     ( ejectionStrength    *    h )     *    w ;", "final   float   fx    =    inter    *     ( n . x )  ;", "final   float   fy    =    inter    *     ( n . y )  ;", "va . x    -  =    fx ;", "va . y    -  =    fy ;", "vb . x    +  =    fx ;", "vb . y    +  =    fy ;", "}", "}", "}", "METHOD_END"], "methodName": ["solveSolid"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "float   springStrength    =     ( step . inv _ dt )     *     ( m _ springStrength )  ;", "for    ( int   k    =     0  ;    k    <     ( m _ pairCount )  ;    k +  +  )     {", "final    . Pair   pair    =    m _ pairBuffer [ k ]  ;", "if    (  (  ( pair . flags )     &     ( ParticleType . b 2  _ springParticle )  )     !  =     0  )     {", "int   a    =    pair . indexA ;", "int   b    =    pair . indexB ;", "final   Vec 2    pa    =    m _ positionBuffer . data [ a ]  ;", "final   Vec 2    pb    =    m _ positionBuffer . data [ b ]  ;", "final   float   dx    =     ( pb . x )     -     ( pa . x )  ;", "final   float   dy    =     ( pb . y )     -     ( pa . y )  ;", "float   r 0     =    pair . distance ;", "float   r 1     =    MathUtils . sqrt (  (  ( dx    *    dx )     +     ( dy    *    dy )  )  )  ;", "if    ( r 1     =  =     0  )", "r 1     =    Float . MAX _ VALUE ;", "float   strength    =    springStrength    *     ( pair . strength )  ;", "final   float   fx    =     (  ( strength    *     ( r 0     -    r 1  )  )     /    r 1  )     *    dx ;", "final   float   fy    =     (  ( strength    *     ( r 0     -    r 1  )  )     /    r 1  )     *    dy ;", "final   Vec 2    va    =    m _ velocityBuffer . data [ a ]  ;", "final   Vec 2    vb    =    m _ velocityBuffer . data [ b ]  ;", "va . x    -  =    fx ;", "va . y    -  =    fy ;", "vb . x    +  =    fx ;", "vb . y    +  =    fy ;", "}", "}", "}", "METHOD_END"], "methodName": ["solveSpring"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "m _ accumulation 2 Buffer    =    requestParticleBuffer ( Vec 2  . class ,    m _ accumulation 2 Buffer )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "m _ accumulationBuffer [ i ]     =     0  ;", "m _ accumulation 2 Buffer [ i ]  . setZero (  )  ;", "}", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "if    (  (  ( contact . flags )     &     ( ParticleType . b 2  _ tensileParticle )  )     !  =     0  )     {", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "float   w    =    contact . weight ;", "Vec 2    n    =    contact . normal ;", "m _ accumulationBuffer [ a ]     +  =    w ;", "m _ accumulationBuffer [ b ]     +  =    w ;", "final   Vec 2    a 2 A    =    m _ accumulation 2 Buffer [ a ]  ;", "final   Vec 2    a 2 B    =    m _ accumulation 2 Buffer [ b ]  ;", "final   float   inter    =     (  1     -    w )     *    w ;", "a 2 A . x    -  =    inter    *     ( n . x )  ;", "a 2 A . y    -  =    inter    *     ( n . y )  ;", "a 2 B . x    +  =    inter    *     ( n . x )  ;", "a 2 B . y    +  =    inter    *     ( n . y )  ;", "}", "}", "float   strengthA    =     ( m _ surfaceTensionStrengthA )     *     ( getCriticalVelocity ( step )  )  ;", "float   strengthB    =     ( m _ surfaceTensionStrengthB )     *     ( getCriticalVelocity ( step )  )  ;", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "if    (  (  ( contact . flags )     &     ( ParticleType . b 2  _ tensileParticle )  )     !  =     0  )     {", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "float   w    =    contact . weight ;", "Vec 2    n    =    contact . normal ;", "final   Vec 2    a 2 A    =    m _ accumulation 2 Buffer [ a ]  ;", "final   Vec 2    a 2 B    =    m _ accumulation 2 Buffer [ b ]  ;", "float   h    =     ( m _ accumulationBuffer [ a ]  )     +     ( m _ accumulationBuffer [ b ]  )  ;", "final   float   sx    =     ( a 2 B . x )     -     ( a 2 A . x )  ;", "final   float   sy    =     ( a 2 B . y )     -     ( a 2 A . y )  ;", "float   fn    =     (  ( strengthA    *     ( h    -     2  )  )     +     ( strengthB    *     (  ( sx    *     ( n . x )  )     +     ( sy    *     ( n . y )  )  )  )  )     *    w ;", "final   float   fx    =    fn    *     ( n . x )  ;", "final   float   fy    =    fn    *     ( n . y )  ;", "final   Vec 2    va    =    m _ velocityBuffer . data [ a ]  ;", "final   Vec 2    vb    =    m _ velocityBuffer . data [ b ]  ;", "va . x    -  =    fx ;", "va . y    -  =    fy ;", "vb . x    +  =    fx ;", "vb . y    +  =    fy ;", "}", "}", "}", "METHOD_END"], "methodName": ["solveTensile"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "float   viscousStrength    =    m _ viscousStrength ;", "for    ( int   k    =     0  ;    k    <     ( m _ bodyContactCount )  ;    k +  +  )     {", "final   BodyContact   contact    =    m _ bodyContactBuffer [ k ]  ;", "int   a    =    contact . index ;", "if    (  (  ( m _ flagsBuffer . data [ a ]  )     &     ( Type . b 2  _ viscous )  )     !  =     0  )     {", "Body   b    =    contact . body ;", "float   w    =    contact . weight ;", "float   m    =    contact . mass ;", "Vec 2    p    =    m _ positionBuffer . data [ a ]  ;", "final   Vec 2    va    =    m _ velocityBuffer . data [ a ]  ;", "final   float   tempX    =     ( p . x )     -     ( b . m _ sweep . c . x )  ;", "final   float   tempY    =     ( p . y )     -     ( b . m _ sweep . c . y )  ;", "final   float   vx    =     (  (  (  -  ( b . m _ angularVelocity )  )     *    tempY )     +     ( b . m _ linearVelocity . x )  )     -     ( va . x )  ;", "final   float   vy    =     (  (  ( b . m _ angularVelocity )     *    tempX )     +     ( b . m _ linearVelocity . y )  )     -     ( va . y )  ;", "final   Vec 2    f    =    tempVec ;", "final   float   pInvMass    =    getInvMass (  )  ;", "f . x    =     (  ( viscousStrength    *    m )     *    w )     *    vx ;", "f . y    =     (  ( viscousStrength    *    m )     *    w )     *    vy ;", "va . x    +  =    pInvMass    *     ( f . x )  ;", "va . y    +  =    pInvMass    *     ( f . y )  ;", "f . x    =     -  ( f . x )  ;", "f . y    =     -  ( f . y )  ;", "b . applyLinearImpulse ( f ,    p ,    true )  ;", "}", "}", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "final   Contact   contact    =    m _ contactBuffer [ k ]  ;", "if    (  (  ( contact . flags )     &     ( Type . b 2  _ viscous )  )     !  =     0  )     {", "int   a    =    contact . indexA ;", "int   b    =    contact . indexB ;", "float   w    =    contact . weight ;", "final   Vec 2    va    =    m _ velocityBuffer . data [ a ]  ;", "final   Vec 2    vb    =    m _ velocityBuffer . data [ b ]  ;", "final   float   vx    =     ( vb . x )     -     ( va . x )  ;", "final   float   vy    =     ( vb . y )     -     ( va . y )  ;", "final   float   fx    =     ( viscousStrength    *    w )     *    vx ;", "final   float   fy    =     ( viscousStrength    *    w )     *    vy ;", "va . x    +  =    fx ;", "va . y    +  =    fy ;", "vb . x    -  =    fx ;", "vb . y    -  =    fy ;", "}", "}", "}", "METHOD_END"], "methodName": ["solveViscous"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "if    (  (  ( m _ flagsBuffer . data [ i ]  )     &     ( Type . b 2  _ wall )  )     !  =     0  )     {", "final   Vec 2    r    =    m _ velocityBuffer . data [ i ]  ;", "r . x    =     0  .  0 F ;", "r . y    =     0  .  0 F ;", "}", "}", "}", "METHOD_END"], "methodName": ["solveWall"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "int   newCount    =     0  ;", "int [  ]    newIndices    =    new   int [ m _ count ]  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "int   flags    =    m _ flagsBuffer . data [ i ]  ;", "if    (  ( flags    &     ( ParticleType . b 2  _ zombieParticle )  )     !  =     0  )     {", "ParticleDestructionListener   destructionListener    =    m _ world . getParticleDestructionListener (  )  ;", "if    (  (  ( flags    &     ( ParticleType . b 2  _ destructionListener )  )     !  =     0  )     &  &     ( destructionListener    !  =    null )  )     {", "destructionListener . sayGoodbye ( i )  ;", "}", "newIndices [ i ]     =    Settings . invalidParticleIndex ;", "} else    {", "newIndices [ i ]     =    newCount ;", "if    ( i    !  =    newCount )     {", "m _ flagsBuffer . data [ newCount ]     =    m _ flagsBuffer . data [ i ]  ;", "m _ positionBuffer . data [ newCount ]  . set ( m _ positionBuffer . data [ i ]  )  ;", "m _ velocityBuffer . data [ newCount ]  . set ( m _ velocityBuffer . data [ i ]  )  ;", "m _ groupBuffer [ newCount ]     =    m _ groupBuffer [ i ]  ;", "if    (  ( m _ depthBuffer )     !  =    null )     {", "m _ depthBuffer [ newCount ]     =    m _ depthBuffer [ i ]  ;", "}", "if    (  ( m _ colorBuffer . data )     !  =    null )     {", "m _ colorBuffer . data [ newCount ]  . set ( m _ colorBuffer . data [ i ]  )  ;", "}", "if    (  ( m _ userDataBuffer . data )     !  =    null )     {", "m _ userDataBuffer . data [ newCount ]     =    m _ userDataBuffer . data [ i ]  ;", "}", "}", "newCount +  +  ;", "}", "}", "for    ( int   k    =     0  ;    k    <     ( m _ proxyCount )  ;    k +  +  )     {", ". Proxy   proxy    =    m _ proxyBuffer [ k ]  ;", "proxy . index    =    newIndices [ proxy . index ]  ;", "}", "int   j    =    m _ proxyCount ;", "for    ( int   i    =     0  ;    i    <    j ;    i +  +  )     {", "if    (  . Test . IsProxyInvalid ( m _ proxyBuffer [ i ]  )  )     {", "-  - j ;", ". Proxy   temp    =    m _ proxyBuffer [ j ]  ;", "m _ proxyBuffer [ j ]     =    m _ proxyBuffer [ i ]  ;", "m _ proxyBuffer [ i ]     =    temp ;", "-  - i ;", "}", "}", "m _ proxyCount    =    j ;", "for    ( int   k    =     0  ;    k    <     ( m _ contactCount )  ;    k +  +  )     {", "ParticleContact   contact    =    m _ contactBuffer [ k ]  ;", "contact . indexA    =    newIndices [ contact . indexA ]  ;", "contact . indexB    =    newIndices [ contact . indexB ]  ;", "}", "j    =    m _ contactCount ;", "for    ( int   i    =     0  ;    i    <    j ;    i +  +  )     {", "if    (  . Test . IsContactInvalid ( m _ contactBuffer [ i ]  )  )     {", "-  - j ;", "ParticleContact   temp    =    m _ contactBuffer [ j ]  ;", "m _ contactBuffer [ j ]     =    m _ contactBuffer [ i ]  ;", "m _ contactBuffer [ i ]     =    temp ;", "-  - i ;", "}", "}", "m _ contactCount    =    j ;", "for    ( int   k    =     0  ;    k    <     ( m _ bodyContactCount )  ;    k +  +  )     {", "ParticleBodyContact   contact    =    m _ bodyContactBuffer [ k ]  ;", "contact . index    =    newIndices [ contact . index ]  ;", "}", "j    =    m _ bodyContactCount ;", "for    ( int   i    =     0  ;    i    <    j ;    i +  +  )     {", "if    (  . Test . IsBodyContactInvalid ( m _ bodyContactBuffer [ i ]  )  )     {", "-  - j ;", "ParticleBodyContact   temp    =    m _ bodyContactBuffer [ j ]  ;", "m _ bodyContactBuffer [ j ]     =    m _ bodyContactBuffer [ i ]  ;", "m _ bodyContactBuffer [ i ]     =    temp ;", "-  - i ;", "}", "}", "m _ bodyContactCount    =    j ;", "for    ( int   k    =     0  ;    k    <     ( m _ pairCount )  ;    k +  +  )     {", ". Pair   pair    =    m _ pairBuffer [ k ]  ;", "pair . indexA    =    newIndices [ pair . indexA ]  ;", "pair . indexB    =    newIndices [ pair . indexB ]  ;", "}", "j    =    m _ pairCount ;", "for    ( int   i    =     0  ;    i    <    j ;    i +  +  )     {", "if    (  . Test . IsPairInvalid ( m _ pairBuffer [ i ]  )  )     {", "-  - j ;", ". Pair   temp    =    m _ pairBuffer [ j ]  ;", "m _ pairBuffer [ j ]     =    m _ pairBuffer [ i ]  ;", "m _ pairBuffer [ i ]     =    temp ;", "-  - i ;", "}", "}", "m _ pairCount    =    j ;", "for    ( int   k    =     0  ;    k    <     ( m _ triadCount )  ;    k +  +  )     {", ". Triad   triad    =    m _ triadBuffer [ k ]  ;", "triad . indexA    =    newIndices [ triad . indexA ]  ;", "triad . indexB    =    newIndices [ triad . indexB ]  ;", "triad . indexC    =    newIndices [ triad . indexC ]  ;", "}", "j    =    m _ triadCount ;", "for    ( int   i    =     0  ;    i    <    j ;    i +  +  )     {", "if    (  . Test . IsTriadInvalid ( m _ triadBuffer [ i ]  )  )     {", "-  - j ;", ". Triad   temp    =    m _ triadBuffer [ j ]  ;", "m _ triadBuffer [ j ]     =    m _ triadBuffer [ i ]  ;", "m _ triadBuffer [ i ]     =    temp ;", "-  - i ;", "}", "}", "m _ triadCount    =    j ;", "for    ( ParticleGroup   group    =    m _ groupList ;    group    !  =    null ;    group    =    group . getNext (  )  )     {", "int   firstIndex    =    newCount ;", "int   lastIndex    =     0  ;", "boolean   modified    =    false ;", "for    ( int   i    =    group . m _ firstIndex ;    i    <     ( group . m _ lastIndex )  ;    i +  +  )     {", "j    =    newIndices [ i ]  ;", "if    ( j    >  =     0  )     {", "firstIndex    =    MathUtils . min ( firstIndex ,    j )  ;", "lastIndex    =    MathUtils . max ( lastIndex ,     ( j    +     1  )  )  ;", "} else    {", "modified    =    true ;", "}", "}", "if    ( firstIndex    <    lastIndex )     {", "group . m _ firstIndex    =    firstIndex ;", "group . m _ lastIndex    =    lastIndex ;", "if    ( modified )     {", "if    (  (  ( group . m _ groupFlags )     &     ( ParticleGroupType . b 2  _ rigidParticleGroup )  )     !  =     0  )     {", "group . m _ toBeSplit    =    true ;", "}", "}", "} else    {", "group . m _ firstIndex    =     0  ;", "group . m _ lastIndex    =     0  ;", "if    ( group . m _ destroyAutomatically )     {", "group . m _ toBeDestroyed    =    true ;", "}", "}", "}", "m _ count    =    newCount ;", "for    ( ParticleGroup   group    =    m _ groupList ;    group    !  =    null ;  )     {", "ParticleGroup   next    =    group . getNext (  )  ;", "if    ( group . m _ toBeDestroyed )     {", "destroyParticleGroup ( group )  ;", "} else", "if    ( group . m _ toBeSplit )     {", "}", "group    =    next ;", "}", "}", "METHOD_END"], "methodName": ["solveZombie"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "final   AABB   aabb    =    temp ;", "aabb . lowerBound . x    =    Float . MAX _ VALUE ;", "aabb . lowerBound . y    =    Float . MAX _ VALUE ;", "aabb . upperBound . x    =     -  ( Float . MAX _ VALUE )  ;", "aabb . upperBound . y    =     -  ( Float . MAX _ VALUE )  ;", "for    ( int   i    =     0  ;    i    <     ( m _ count )  ;    i +  +  )     {", "Vec 2    p    =    m _ positionBuffer . data [ i ]  ;", "Vec 2  . minToOut ( aabb . lowerBound ,    p ,    aabb . lowerBound )  ;", "Vec 2  . maxToOut ( aabb . upperBound ,    p ,    aabb . upperBound )  ;", "}", "aabb . lowerBound . x    -  =    m _ Diameter ;", "aabb . lowerBound . y    -  =    m _ Diameter ;", "aabb . upperBound . x    +  =    m _ Diameter ;", "aabb . upperBound . y    +  =    m _ Diameter ;", "m _ bodyContactCount    =     0  ;", "ubccallback . system    =    this ;", "m _ world . queryAABB ( ubccallback ,    aabb )  ;", "}", "METHOD_END"], "methodName": ["updateBodyContacts"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "for    ( int   p    =     0  ;    p    <     ( m _ proxyCount )  ;    p +  +  )     {", ". Proxy   proxy    =    m _ proxyBuffer [ p ]  ;", "int   i    =    proxy . index ;", "Vec 2    pos    =    m _ positionBuffer . data [ i ]  ;", "proxy . tag    =     . computeTag (  (  ( m _ inverseDiameter )     *     ( pos . x )  )  ,     (  ( m _ inverseDiameter )     *     ( pos . y )  )  )  ;", "}", "Arrays . sort ( m _ proxyBuffer ,     0  ,    m _ proxyCount )  ;", "m _ contactCount    =     0  ;", "int   c _ index    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( m _ proxyCount )  ;    i +  +  )     {", ". Proxy   a    =    m _ proxyBuffer [ i ]  ;", "long   rightTag    =     . computeRelativeTag ( a . tag ,     1  ,     0  )  ;", "for    ( int   j    =    i    +     1  ;    j    <     ( m _ proxyCount )  ;    j +  +  )     {", ". Proxy   b    =    m _ proxyBuffer [ j ]  ;", "if    ( rightTag    <     ( b . tag )  )     {", "break ;", "}", "addContact ( a . index ,    b . index )  ;", "}", "long   bottomLeftTag    =     . computeRelativeTag ( a . tag ,     (  -  1  )  ,     1  )  ;", "for    (  ;    c _ index    <     ( m _ proxyCount )  ;    c _ index +  +  )     {", ". Proxy   c    =    m _ proxyBuffer [ c _ index ]  ;", "if    ( bottomLeftTag    <  =     ( c . tag )  )     {", "break ;", "}", "}", "long   bottomRightTag    =     . computeRelativeTag ( a . tag ,     1  ,     1  )  ;", "for    ( int   b _ index    =    c _ index ;    b _ index    <     ( m _ proxyCount )  ;    b _ index +  +  )     {", ". Proxy   b    =    m _ proxyBuffer [ b _ index ]  ;", "if    ( bottomRightTag    <     ( b . tag )  )     {", "break ;", "}", "addContact ( a . index ,    b . index )  ;", "}", "}", "if    ( exceptZombie )     {", "int   j    =    m _ contactCount ;", "for    ( int   i    =     0  ;    i    <    j ;    i +  +  )     {", "if    (  (  ( m _ contactBuffer [ i ]  . flags )     &     ( ParticleType . b 2  _ zombieParticle )  )     !  =     0  )     {", "-  - j ;", "ParticleContact   temp    =    m _ contactBuffer [ j ]  ;", "m _ contactBuffer [ j ]     =    m _ contactBuffer [ i ]  ;", "m _ contactBuffer [ i ]     =    temp ;", "-  - i ;", "}", "}", "m _ contactCount    =    j ;", "}", "}", "METHOD_END"], "methodName": ["updateContacts"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "int   left    =     0  ;", "int   p ;", "int   curr ;", "while    ( length    >     0  )     {", "p    =    length    /     2  ;", "curr    =    left    +    p ;", "if    (  ( ray [ curr ]  . tag )     <  =    tag )     {", "left    =    curr    +     1  ;", "length    -  =    p    +     1  ;", "} else    {", "length    =    p ;", "}", "}", "return   left ;", "}", "METHOD_END"], "methodName": ["upperBound"], "fileName": "org.jbox2d.particle.ParticleSystem"}, {"methodBody": ["METHOD_START", "{", "return    ( m _ front )     >  =     ( m _ back )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.jbox2d.particle.StackQueue"}, {"methodBody": ["METHOD_START", "{", "return   m _ buffer [ m _ front ]  ;", "}", "METHOD_END"], "methodName": ["front"], "fileName": "org.jbox2d.particle.StackQueue"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ front )     <     ( m _ back )  ;", "return   m _ buffer [  (  ( m _ front )  +  +  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jbox2d.particle.StackQueue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( m _ back )     >  =     ( m _ end )  )     {", "System . arraycopy ( m _ buffer ,    m _ front ,    m _ buffer ,     0  ,     (  ( m _ back )     -     ( m _ front )  )  )  ;", "m _ back    -  =    m _ front ;", "m _ front    =     0  ;", "if    (  ( m _ back )     >  =     ( m _ end )  )     {", "return ;", "}", "}", "m _ buffer [  (  ( m _ back )  +  +  )  ]     =    task ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jbox2d.particle.StackQueue"}, {"methodBody": ["METHOD_START", "{", "m _ buffer    =    buffer ;", "m _ front    =     0  ;", "m _ b    =     0  ;", "m _ end    =    buffer . length ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.jbox2d.particle.StackQueue"}, {"methodBody": ["METHOD_START", "{", "VoronoiDiagram . Generator   g    =    m _ generatorBuffer [  (  ( m _ generatorCount )  +  +  )  ]  ;", "g . center . x    =    center . x ;", "g . center . y    =    center . y ;", "g . tag    =    tag ;", "}", "METHOD_END"], "methodName": ["addGenerator"], "fileName": "org.jbox2d.particle.VoronoiDiagram"}, {"methodBody": ["METHOD_START", "{", "assert    ( m _ diagram )     =  =    null ;", "float   inverseRadius    =     1     /    radius ;", "lower . x    =    Float . MAX _ VALUE ;", "lower . y    =    Float . MAX _ VALUE ;", "upper . x    =     -  ( Float . MAX _ VALUE )  ;", "upper . y    =     -  ( Float . MAX _ VALUE )  ;", "for    ( int   k    =     0  ;    k    <     ( m _ generatorCount )  ;    k +  +  )     {", ". Generator   g    =    m _ generatorBuffer [ k ]  ;", "Vec 2  . minToOut ( lower ,    g . center ,    lower )  ;", "Vec 2  . maxToOut ( upper ,    g . center ,    upper )  ;", "}", "m _ countX    =     1     +     (  ( int )     ( inverseRadius    *     (  ( upper . x )     -     ( lower . x )  )  )  )  ;", "m _ countY    =     1     +     (  ( int )     ( inverseRadius    *     (  ( upper . y )     -     ( lower . y )  )  )  )  ;", "m _ diagram    =    new . Generator [  ( m _ countX )     *     ( m _ countY )  ]  ;", "queue . reset ( newTask [  (  4     *     ( m _ countX )  )     *     ( m _ countX )  ]  )  ;", "for    ( int   k    =     0  ;    k    <     ( m _ generatorCount )  ;    k +  +  )     {", ". Generator   g    =    m _ generatorBuffer [ k ]  ;", "g . center . x    =    inverseRadius    *     (  ( g . center . x )     -     ( lower . x )  )  ;", "g . center . y    =    inverseRadius    *     (  ( g . center . y )     -     ( lower . y )  )  ;", "int   x    =    MathUtils . max (  0  ,    MathUtils . min (  (  ( int )     ( g . center . x )  )  ,     (  ( m _ countX )     -     1  )  )  )  ;", "int   y    =    MathUtils . max (  0  ,    MathUtils . min (  (  ( int )     ( g . center . y )  )  ,     (  ( m _ countY )     -     1  )  )  )  ;", "queue . push ( taskPool . pop (  )  . set ( x ,    y ,     ( x    +     ( y    *     ( m _ countX )  )  )  ,    g )  )  ;", "}", "while    (  !  ( queue . empty (  )  )  )     {", "Task   front    =    queue . pop (  )  ;", "int   x    =    front . m _ x ;", "int   y    =    front . m _ y ;", "int   i    =    front . m _ i ;", ". Generator   g    =    front . m _ generator ;", "if    (  ( m _ diagram [ i ]  )     =  =    null )     {", "m _ diagram [ i ]     =    g ;", "if    ( x    >     0  )     {", "queue . push ( taskPool . pop (  )  . set (  ( x    -     1  )  ,    y ,     ( i    -     1  )  ,    g )  )  ;", "}", "if    ( y    >     0  )     {", "queue . push ( taskPool . pop (  )  . set ( x ,     ( y    -     1  )  ,     ( i    -     ( m _ countX )  )  ,    g )  )  ;", "}", "if    ( x    <     (  ( m _ countX )     -     1  )  )     {", "queue . push ( taskPool . pop (  )  . set (  ( x    +     1  )  ,    y ,     ( i    +     1  )  ,    g )  )  ;", "}", "if    ( y    <     (  ( m _ countY )     -     1  )  )     {", "queue . push ( taskPool . pop (  )  . set ( x ,     ( y    +     1  )  ,     ( i    +     ( m _ countX )  )  ,    g )  )  ;", "}", "}", "taskPool . push ( front )  ;", "}", "int   maxIteration    =     ( m _ countX )     +     ( m _ countY )  ;", "for    ( int   iteration    =     0  ;    iteration    <    maxIteration ;    iteration +  +  )     {", "for    ( int   y    =     0  ;    y    <     ( m _ countY )  ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <     (  ( m _ countX )     -     1  )  ;    x +  +  )     {", "int   i    =    x    +     ( y    *     ( m _ countX )  )  ;", ". Generator   a    =    m _ diagram [ i ]  ;", ". Generator   b    =    m _ diagram [  ( i    +     1  )  ]  ;", "if    ( a    !  =    b )     {", "queue . push ( taskPool . pop (  )  . set ( x ,    y ,    i ,    b )  )  ;", "queue . push ( taskPool . pop (  )  . set (  ( x    +     1  )  ,    y ,     ( i    +     1  )  ,    a )  )  ;", "}", "}", "}", "for    ( int   y    =     0  ;    y    <     (  ( m _ countY )     -     1  )  ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <     ( m _ countX )  ;    x +  +  )     {", "int   i    =    x    +     ( y    *     ( m _ countX )  )  ;", ". Generator   a    =    m _ diagram [ i ]  ;", ". Generator   b    =    m _ diagram [  ( i    +     ( m _ countX )  )  ]  ;", "if    ( a    !  =    b )     {", "queue . push ( taskPool . pop (  )  . set ( x ,    y ,    i ,    b )  )  ;", "queue . push ( taskPool . pop (  )  . set ( x ,     ( y    +     1  )  ,     ( i    +     ( m _ countX )  )  ,    a )  )  ;", "}", "}", "}", "boolean   updated    =    false ;", "while    (  !  ( queue . empty (  )  )  )     {", "Task   front    =    queue . pop (  )  ;", "int   x    =    front . m _ x ;", "int   y    =    front . m _ y ;", "int   i    =    front . m _ i ;", ". Generator   k    =    front . m _ generator ;", ". Generator   a    =    m _ diagram [ i ]  ;", ". Generator   b    =    k ;", "if    ( a    !  =    b )     {", "float   ax    =     ( a . center . x )     -    x ;", "float   ay    =     ( a . center . y )     -    y ;", "float   bx    =     ( b . center . x )     -    x ;", "float   by    =     ( b . center . y )     -    y ;", "float   a 2     =     ( ax    *    ax )     +     ( ay    *    ay )  ;", "float   b 2     =     ( bx    *    bx )     +     ( by    *    by )  ;", "if    ( a 2     >    b 2  )     {", "m _ diagram [ i ]     =    b ;", "if    ( x    >     0  )     {", "queue . push ( taskPool . pop (  )  . set (  ( x    -     1  )  ,    y ,     ( i    -     1  )  ,    b )  )  ;", "}", "if    ( y    >     0  )     {", "queue . push ( taskPool . pop (  )  . set ( x ,     ( y    -     1  )  ,     ( i    -     ( m _ countX )  )  ,    b )  )  ;", "}", "if    ( x    <     (  ( m _ countX )     -     1  )  )     {", "queue . push ( taskPool . pop (  )  . set (  ( x    +     1  )  ,    y ,     ( i    +     1  )  ,    b )  )  ;", "}", "if    ( y    <     (  ( m _ countY )     -     1  )  )     {", "queue . push ( taskPool . pop (  )  . set ( x ,     ( y    +     1  )  ,     ( i    +     ( m _ countX )  )  ,    b )  )  ;", "}", "updated    =    true ;", "}", "}", "taskPool . push ( front )  ;", "}", "if    (  ! updated )     {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.jbox2d.particle.VoronoiDiagram"}, {"methodBody": ["METHOD_START", "{", "for    ( int   y    =     0  ;    y    <     (  ( m _ countY )     -     1  )  ;    y +  +  )     {", "for    ( int   x    =     0  ;    x    <     (  ( m _ countX )     -     1  )  ;    x +  +  )     {", "int   i    =    x    +     ( y    *     ( m _ countX )  )  ;", ". Generator   a    =    m _ diagram [ i ]  ;", ". Generator   b    =    m _ diagram [  ( i    +     1  )  ]  ;", ". Generator   c    =    m _ diagram [  ( i    +     ( m _ countX )  )  ]  ;", ". Generator   d    =    m _ diagram [  (  ( i    +     1  )     +     ( m _ countX )  )  ]  ;", "if    ( b    !  =    c )     {", "if    (  ( a    !  =    b )     &  &     ( a    !  =    c )  )     {", "callback . callback ( a . tag ,    b . tag ,    c . tag )  ;", "}", "if    (  ( d    !  =    b )     &  &     ( d    !  =    c )  )     {", "callback . callback ( b . tag ,    d . tag ,    c . tag )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["getNodes"], "fileName": "org.jbox2d.particle.VoronoiDiagram"}, {"methodBody": ["METHOD_START", "{", "assert   argLength    >     0  ;", "if    (  !  ( map . containsKey ( argLength )  )  )     {", "map . put ( argLength ,    getInitialized ( argLength )  )  ;", "}", "assert    ( map . get ( argLength )  . length )     =  =    argLength    :     \"    not   built   of   correct   length \"  ;", "return   map . get ( argLength )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jbox2d.pooling.arrays.FloatArray"}, {"methodBody": ["METHOD_START", "{", "return   new   float [ argLength ]  ;", "}", "METHOD_END"], "methodName": ["getInitializedArray"], "fileName": "org.jbox2d.pooling.arrays.FloatArray"}, {"methodBody": ["METHOD_START", "{", "assert   length    >     0  ;", "if    (  !  ( map . containsKey ( length )  )  )     {", "map . put ( length ,    getInitialized ( length )  )  ;", "}", "assert    ( map . get ( length )  . length )     =  =    length    :     \"    not   built   of   correct   length \"  ;", "return   map . get ( length )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jbox2d.pooling.arrays.GeneratorArray"}, {"methodBody": ["METHOD_START", "{", "final   VoronoiDiagram . Generator [  ]    ray    =    new   VoronoiDiagram . Generator [ length ]  ;", "for    ( int   i    =     0  ;    i    <     ( ray . length )  ;    i +  +  )     {", "ray [ i ]     =    new   VoronoiDiagram . Generator (  )  ;", "}", "return   ray ;", "}", "METHOD_END"], "methodName": ["getInitializedArray"], "fileName": "org.jbox2d.pooling.arrays.GeneratorArray"}, {"methodBody": ["METHOD_START", "{", "assert   argLength    >     0  ;", "if    (  !  ( map . containsKey ( argLength )  )  )     {", "map . put ( argLength ,    getInitialized ( argLength )  )  ;", "}", "assert    ( map . get ( argLength )  . length )     =  =    argLength    :     \"    not   built   of   correct   length \"  ;", "return   map . get ( argLength )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jbox2d.pooling.arrays.IntArray"}, {"methodBody": ["METHOD_START", "{", "return   new   int [ argLength ]  ;", "}", "METHOD_END"], "methodName": ["getInitializedArray"], "fileName": "org.jbox2d.pooling.arrays.IntArray"}, {"methodBody": ["METHOD_START", "{", "assert   argLength    >     0  ;", "if    (  !  ( map . containsKey ( argLength )  )  )     {", "map . put ( argLength ,    getInitialized ( argLength )  )  ;", "}", "assert    ( map . get ( argLength )  . length )     =  =    argLength    :     \"    not   built   of   correct   length \"  ;", "return   map . get ( argLength )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.jbox2d.pooling.arrays.Vec2Array"}, {"methodBody": ["METHOD_START", "{", "final   Vec 2  [  ]    ray    =    new   Vec 2  [ argLength ]  ;", "for    ( int   i    =     0  ;    i    <     ( ray . length )  ;    i +  +  )     {", "ray [ i ]     =    new   Vec 2  (  )  ;", "}", "return   ray ;", "}", "METHOD_END"], "methodName": ["getInitializedArray"], "fileName": "org.jbox2d.pooling.arrays.Vec2Array"}, {"methodBody": ["METHOD_START", "{", "( index )  +  +  ;", "if    (  ( index )     >  =     ( size )  )     {", "index    =     0  ;", "}", "return    (  ( E )     (  [ index ]  )  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jbox2d.pooling.normal.CircleStack"}, {"methodBody": ["METHOD_START", "{", "assert   argNum    <  =     ( container . length )     :     \" Container   array   is   too   small \"  ;", "if    (  (  ( index )     +    argNum )     <     ( size )  )     {", "System . arraycopy (  ,    index ,    container ,     0  ,    argNum )  ;", "index    +  =    argNum ;", "} else    {", "int   overlap    =     (  ( index )     +    argNum )     -     ( size )  ;", "System . arraycopy (  ,    index ,    container ,     0  ,     ( argNum    -    overlap )  )  ;", "System . arraycopy (  ,     0  ,    container ,     ( argNum    -    overlap )  ,    overlap )  ;", "index    =    overlap ;", "}", "return    (  ( E [  ]  )     ( container )  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jbox2d.pooling.normal.CircleStack"}, {"methodBody": ["METHOD_START", "{", "return   ccstack ;", "}", "METHOD_END"], "methodName": ["getCircleContactStack"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   collision ;", "}", "METHOD_END"], "methodName": ["getCollision"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   dist ;", "}", "METHOD_END"], "methodName": ["getDistance"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( afloats . containsKey ( argLength )  )  )     {", "afloats . put ( argLength ,    new   float [ argLength ]  )  ;", "}", "assert    ( afloats . get ( argLength )  . length )     =  =    argLength    :     \" Array   not   built   with   correct   length \"  ;", "return   afloats . get ( argLength )  ;", "}", "METHOD_END"], "methodName": ["getFloatArray"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( aints . containsKey ( argLength )  )  )     {", "aints . put ( argLength ,    new   int [ argLength ]  )  ;", "}", "assert    ( aints . get ( argLength )  . length )     =  =    argLength    :     \" Array   not   built   with   correct   length \"  ;", "return   aints . get ( argLength )  ;", "}", "METHOD_END"], "methodName": ["getIntArray"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   cpstack ;", "}", "METHOD_END"], "methodName": ["getPolyCircleContactStack"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   pcstack ;", "}", "METHOD_END"], "methodName": ["getPolyContactStack"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   toi ;", "}", "METHOD_END"], "methodName": ["getTimeOfImpact"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( avecs . containsKey ( argLength )  )  )     {", "Vec 2  [  ]    ray    =    new   Vec 2  [ argLength ]  ;", "for    ( int   i    =     0  ;    i    <    argLength ;    i +  +  )     {", "ray [ i ]     =    new   Vec 2  (  )  ;", "}", "avecs . put ( argLength ,    ray )  ;", "}", "assert    ( avecs . get ( argLength )  . length )     =  =    argLength    :     \" Array   not   built   with   correct   length \"  ;", "return   avecs . get ( argLength )  ;", "}", "METHOD_END"], "methodName": ["getVec2Array"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   aabbs . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popAABB"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   aabbs . pop ( argNum )  ;", "}", "METHOD_END"], "methodName": ["popAABB"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   mats . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popMat22"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   mats . pop ( argNum )  ;", "}", "METHOD_END"], "methodName": ["popMat22"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   mat 3  3 s . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popMat33"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   rots . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popRot"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   vecs . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popVec2"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   vecs . pop ( argNum )  ;", "}", "METHOD_END"], "methodName": ["popVec2"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   vec 3 s . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popVec3"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "return   vec 3 s . pop ( argNum )  ;", "}", "METHOD_END"], "methodName": ["popVec3"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "aabbs . push ( argNum )  ;", "}", "METHOD_END"], "methodName": ["pushAABB"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "mats . push ( argNum )  ;", "}", "METHOD_END"], "methodName": ["pushMat22"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "mat 3  3 s . push ( argNum )  ;", "}", "METHOD_END"], "methodName": ["pushMat33"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "rots . push ( num )  ;", "}", "METHOD_END"], "methodName": ["pushRot"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "vecs . push ( argNum )  ;", "}", "METHOD_END"], "methodName": ["pushVec2"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "vec 3 s . push ( argNum )  ;", "}", "METHOD_END"], "methodName": ["pushVec3"], "fileName": "org.jbox2d.pooling.normal.DefaultWorldPool"}, {"methodBody": ["METHOD_START", "{", "E [  ]    newStack    =    newArray ( argSize )  ;", "if    (  ( stack )     !  =    null )     {", "System . arraycopy ( stack ,     0  ,    newStack ,     0  ,    size )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( newStack . length )  ;    i +  +  )     {", "newStack [ i ]     =    newInstance (  )  ;", "}", "stack    =    newStack ;", "size    =    newStack . length ;", "}", "METHOD_END"], "methodName": ["extendStack"], "fileName": "org.jbox2d.pooling.normal.MutableStack"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index )     >  =     ( size )  )     {", "extend (  (  ( size )     *     2  )  )  ;", "}", "return   stack [  (  ( index )  +  +  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jbox2d.pooling.normal.MutableStack"}, {"methodBody": ["METHOD_START", "{", "assert    ( index )     >     0  ;", "s [  (  -  -  ( index )  )  ]     =    argObject ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jbox2d.pooling.normal.MutableStack"}, {"methodBody": ["METHOD_START", "{", "assert    ( index )     <     ( size )     :     \" End   of   stack   reached ,    there   is   probably   a   leak   somewhere \"  ;", "return    (  ( E )     ( pool [  (  ( index )  +  +  )  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jbox2d.pooling.normal.OrderedStack"}, {"methodBody": ["METHOD_START", "{", "assert    (  ( index )     +    argNum )     <     ( size )     :     \" End   of   stack   reached ,    there   is   probably   a   leak   somewhere \"  ;", "assert   argNum    <  =     ( container . length )     :     \" Container   array   is   too   small \"  ;", "System . arraycopy ( pool ,    index ,    container ,     0  ,    argNum )  ;", "index    +  =    argNum ;", "return    (  ( E [  ]  )     ( container )  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jbox2d.pooling.normal.OrderedStack"}, {"methodBody": ["METHOD_START", "{", "index    -  =    argNum ;", "assert    ( index )     >  =     0     :     \" Beginning   of   s   reached ,    push / pops   are   unmatched \"  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jbox2d.pooling.normal.OrderedStack"}, {"methodBody": ["METHOD_START", "{", "return   position ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.jbox2d.pooling.stacks.DynamicIntStack"}, {"methodBody": ["METHOD_START", "{", "assert    ( position )     >     0  ;", "return    [  (  -  -  ( position )  )  ]  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.jbox2d.pooling.stacks.DynamicIntStack"}, {"methodBody": ["METHOD_START", "{", "if    (  ( position )     =  =     ( size )  )     {", "int [  ]    old    =     ;", "=    new   int [  ( size )     *     2  ]  ;", "size    =     . length ;", "System . arraycopy ( old ,     0  ,     ,     0  ,    old . length )  ;", "}", "[  (  ( position )  +  +  )  ]     =    i ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.jbox2d.pooling.stacks.DynamicIntStack"}, {"methodBody": ["METHOD_START", "{", "position    =     0  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.jbox2d.pooling.stacks.DynamicIntStack"}]