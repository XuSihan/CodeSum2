[{"methodBody": ["METHOD_START", "{", "this . servletRequest    =    new   MockHttpServletRequest (  )  ;", "this . servletRequest . setAsyncSupported ( true )  ;", "this . request    =    new   http . server . ServletServerHttpRequest ( this . servletRequest )  ;", "}", "METHOD_END"], "methodName": ["resetRequest"], "fileName": "org.springframework.web.socket.AbstractHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "resetRequest (  )  ;", "resetResponse (  )  ;", "this . asyncControl    =    this . request . getAsyncRequestControl ( this . response )  ;", "}", "METHOD_END"], "methodName": ["resetRequestAndResponse"], "fileName": "org.springframework.web.socket.AbstractHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . servletResponse    =    new   MockHttpServletResponse (  )  ;", "this . response    =    new   http . server . ServletServerHttpResponse ( this . servletResponse )  ;", "}", "METHOD_END"], "methodName": ["resetResponse"], "fileName": "org.springframework.web.socket.AbstractHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setMethod ( method )  ;", "this . servletRequest . setRequestURI ( requestUri )  ;", "this . request    =    new   http . server . ServletServerHttpRequest ( this . servletRequest )  ;", "}", "METHOD_END"], "methodName": ["setRequest"], "fileName": "org.springframework.web.socket.AbstractHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "resetRequestAndResponse (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.AbstractHttpRequestTests"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketClient . doHandshake ( clientHandler ,     (  ( getWsBaseUrl (  )  )     +    endpointPath )  )  ;", "}", "METHOD_END"], "methodName": ["doHandshake"], "fileName": "org.springframework.web.socket.AbstractWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return    \" ws :  /  / localhost :  \"     +     ( this . server . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["getWsBaseUrl"], "fileName": "org.springframework.web.socket.AbstractWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  (  (  (  (  (  \" Setting   up    '  \"     +     ( this . testName . getMethodName (  )  )  )     +     \"  '  ,    client =  \"  )     +     ( this . webSocketClient . getClass (  )  . getSimpleName (  )  )  )     +     \"  ,    server =  \"  )     +     ( this . server . getClass (  )  . getSimpleName (  )  )  )  )  ;", "this . wac    =    new   AnnotationConfigWebApplicationContext (  )  ;", "this . wac . register ( getAnnotatedConfigClasses (  )  )  ;", "this . wac . register (  . upgradeStrategyConfigTypes . get ( this . server . getClass (  )  )  )  ;", "if    (  ( this . webSocketClient )    instanceof   Lifecycle )     {", "(  ( Lifecycle )     ( this . webSocketClient )  )  . start (  )  ;", "}", "this . server . setup (  )  ;", "this . server . deployConfig ( this . wac )  ;", "this . server . start (  )  ;", "this . wac . setServletContext ( this . server . getServletContext (  )  )  ;", "this . wac . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.AbstractWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( this . webSocketClient )    instanceof   Lifecycle )     {", "(  ( Lifecycle )     ( this . webSocketClient )  )  . stop (  )  ;", "}", "}    catch    ( Throwable   t )     {", "logger . error (  \" Failed   to   stop      client \"  ,    t )  ;", "}", "try    {", "this . server . undeployConfig (  )  ;", "}    catch    ( Throwable   t )     {", "logger . error (  \" Failed   to   undeploy   application   config \"  ,    t )  ;", "}", "try    {", "this . server . stop (  )  ;", "}    catch    ( Throwable   t )     {", "logger . error (  \" Failed   to   stop   server \"  ,    t )  ;", "}", "try    {", "this . wac . close (  )  ;", "}    catch    ( Throwable   t )     {", "logger . error (  \" Failed   to   close   WebApplicationContext \"  ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.springframework.web.socket.AbstractWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . payload ;", "}", "METHOD_END"], "methodName": ["getPayload"], "fileName": "org.springframework.web.socket.AbstractWebSocketMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . last ;", "}", "METHOD_END"], "methodName": ["isLast"], "fileName": "org.springframework.web.socket.AbstractWebSocketMessage"}, {"methodBody": ["METHOD_START", "{", "return    ( this . code )     =  =     ( other . code )  ;", "}", "METHOD_END"], "methodName": ["equalsCode"], "fileName": "org.springframework.web.socket.CloseStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . code ;", "}", "METHOD_END"], "methodName": ["getCode"], "fileName": "org.springframework.web.socket.CloseStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . reason ;", "}", "METHOD_END"], "methodName": ["getReason"], "fileName": "org.springframework.web.socket.CloseStatus"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( reason ,     \" Reason   must   not   be   empty \"  )  ;", "return   new    ( this . code ,    reason )  ;", "}", "METHOD_END"], "methodName": ["withReason"], "fileName": "org.springframework.web.socket.CloseStatus"}, {"methodBody": ["METHOD_START", "{", "try    {", "Field   field    =     . class . getDeclaredField (  \" currentContextPerThread \"  )  ;", "field . setAccessible ( true )  ;", "return    (  ( Map < ClassLoader ,    WebApplicationContext >  )     ( field . get ( null )  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getCurrentContextPerThreadFromContextLoader"], "fileName": "org.springframework.web.socket.ContextLoaderTestUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( applicationContext    !  =    null )     {", ". currentContextPerThread . put ( classLoader ,    applicationContext )  ;", "} else    {", ". currentContextPerThread . remove ( classLoader )  ;", "}", "}", "METHOD_END"], "methodName": ["setCurrentWebApplicationContext"], "fileName": "org.springframework.web.socket.ContextLoaderTestUtils"}, {"methodBody": ["METHOD_START", "{", "ContextLoaderTestUtils . setCurrentWebApplicationContext ( Thread . currentThread (  )  . getContextClassLoader (  )  ,    applicationContext )  ;", "}", "METHOD_END"], "methodName": ["setCurrentWebApplicationContext"], "fileName": "org.springframework.web.socket.ContextLoaderTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   EnumSet . of ( REQUEST ,    FORWARD ,    INCLUDE ,    ASYNC )  ;", "}", "METHOD_END"], "methodName": ["getDispatcherTypes"], "fileName": "org.springframework.web.socket.JettyWebSocketTestServer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . bytes )     !  =    null    ?    this . bytes    :    getPayload (  )  . getBytes ( StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["asBytes"], "fileName": "org.springframework.web.socket.TextMessage"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" foo , bar \"  ;", "actual    =    new    ( expected )  ;", "assertThat ( actual . getPayload (  )  ,    Matchers . is ( expected )  )  ;", "assertThat ( actual . toString (  )  ,    Matchers . containsString ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["toStringWithAscii"], "fileName": "org.springframework.web.socket.TextMessageTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \"  \\ u 3  0  4  2  \\ u 3  0  4  4  \\ u 3  0  4  6  \\ u 3  0  4  8  \\ u 3  0  4 a \"  ;", "actual    =    new    ( expected )  ;", "assertThat ( actual . getPayload (  )  ,    Matchers . is ( expected )  )  ;", "assertThat ( actual . toString (  )  ,    Matchers . containsString ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["toStringWithMultibyteString"], "fileName": "org.springframework.web.socket.TextMessageTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "File   tempFolder    =    File . createTempFile (  ( prefix    +     \"  .  \"  )  ,     (  \"  .  \"     +     ( getPort (  )  )  )  )  ;", "tempFolder . delete (  )  ;", "tempFolder . mkdir (  )  ;", "tempFolder . deleteOnExit (  )  ;", "return   tempFolder ;", "}    ch    ( IOException   ex )     {", "throw   new   IllegalStateException (  \" Unable   to   create   temp   directory \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createTempDir"], "fileName": "org.springframework.web.socket.TomcatWebSocketTestServer"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.web.socket.WebSocketExtension"}, {"methodBody": ["METHOD_START", "{", "return   this . parameters ;", "}", "METHOD_END"], "methodName": ["getParameters"], "fileName": "org.springframework.web.socket.WebSocketExtension"}, {"methodBody": ["METHOD_START", "{", "if    ( extension . contains (  \"  ,  \"  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Expected   single   extension   value :     [  \"     +    extension )     +     \"  ]  \"  )  )  ;", "}", "String [  ]    parts    =    StringUtils . tokenizeToStringArray ( extension ,     \"  ;  \"  )  ;", "String   name    =    parts [  0  ]  . trim (  )  ;", "Map < String ,    String >    parameters    =    null ;", "if    (  ( parts . length )     >     1  )     {", "parameters    =    new   LinkedHashMap <  >  (  (  ( parts . length )     -     1  )  )  ;", "for    ( int   i    =     1  ;    i    <     ( parts . length )  ;    i +  +  )     {", "String   parameter    =    parts [ i ]  ;", "int   eqIndex    =    parameter . indexOf (  '  =  '  )  ;", "if    ( eqIndex    !  =     (  -  1  )  )     {", "String   attribute    =    parameter . substring (  0  ,    eqIndex )  ;", "String   value    =    parameter . substring (  ( eqIndex    +     1  )  ,    parameter . length (  )  )  ;", "parameters . put ( attribute ,    value )  ;", "}", "}", "}", "return   new    ( name ,    parameters )  ;", "}", "METHOD_END"], "methodName": ["parseExtension"], "fileName": "org.springframework.web.socket.WebSocketExtension"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( extensions )  )     {", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( extensions ,     \"  ,  \"  )  ;", "List <  >    result    =    new   ArrayList <  >  ( tokens . length )  ;", "for    ( String   token    :    tokens )     {", "result . add (  . parseExtension ( token )  )  ;", "}", "return   result ;", "} else    {", "return   Collections . emptyList (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseExtensions"], "fileName": "org.springframework.web.socket.WebSocketExtension"}, {"methodBody": ["METHOD_START", "{", "List < WebSocketExtension >    extensions    =    WebSocketExtension . parseExtensions (  \" x - foo - extension ,    x - bar - extension \"  )  ;", "assertThat ( extensions ,    Matchers . hasSize (  2  )  )  ;", "assertEquals (  \" x - foo - extension \"  ,    extensions . get (  0  )  . getName (  )  )  ;", "assertEquals (  \" x - bar - extension \"  ,    extensions . get (  1  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseHeaderMultiple"], "fileName": "org.springframework.web.socket.WebSocketExtensionTests"}, {"methodBody": ["METHOD_START", "{", "List < WebSocketExtension >    extensions    =    WebSocketExtension . parseExtensions (  \" x - test - extension    ;    foo = bar    ;    bar = baz \"  )  ;", "assertThat ( extensions ,    Matchers . hasSize (  1  )  )  ;", "WebSocketExtension   extension    =    extensions . get (  0  )  ;", "assertEquals (  \" x - test - extension \"  ,    extension . getName (  )  )  ;", "assertEquals (  2  ,    extension . getParameters (  )  . size (  )  )  ;", "assertEquals (  \" bar \"  ,    extension . getParameters (  )  . get (  \" foo \"  )  )  ;", "assertEquals (  \" baz \"  ,    extension . getParameters (  )  . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseHeaderSingle"], "fileName": "org.springframework.web.socket.WebSocketExtensionTests"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( new   Object [  ]  [  ]  {    new   Object [  ]  {    new   JettyWebSocketTestServer (  )  ,    new   JettyWebSocketClient (  )     }  ,    new   Object [  ]  {    new   TomcatWebSocketTestServer (  )  ,    new   StandardWebSocketClient (  )     }  ,    new   Object [  ]  {    new   UndertowTestServer (  )  ,    new   JettyWebSocketClient (  )     }     }  )  ;", "}", "METHOD_END"], "methodName": ["arguments"], "fileName": "org.springframework.web.socket.WebSocketHandshakeTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders (  )  ;", "headers . setSecWebSocketProtocol (  \" foo \"  )  ;", "URI   url    =    new   URI (  (  ( getWsBaseUrl (  )  )     +     \"  / ws \"  )  )  ;", "WebSocketSession   session    =    this . webSocketClient . doHandshake ( new   Textler (  )  ,    headers ,    url )  . get (  )  ;", "assertEquals (  \" foo \"  ,    session . getAcceptedProtocol (  )  )  ;", "session . close (  )  ;", "}", "METHOD_END"], "methodName": ["subProtocolNegotiation"], "fileName": "org.springframework.web.socket.WebSocketHandshakeTests"}, {"methodBody": ["METHOD_START", "{", "String   url    =     ( getWsBaseUrl (  )  )     +     \"  / ws \"  ;", "WebSocketSession   session    =    this . webSocketClient . doHandshake ( new   AbstractWebSocketHandler (  )     {  }  ,    url )  . get (  )  ;", ". TestWebSocketHandler   serverHandler    =    this . wac . getBean (  . TestWebSocketHandler . class )  ;", "serverHandler . setWaitMessageCount (  1  )  ;", "session . sendMessage ( new   PongMessage (  )  )  ;", "serverHandler . await (  )  ;", "assertNull ( serverHandler . getTransportError (  )  )  ;", "assertEquals (  1  ,    serverHandler . getReceivedMessages (  )  . size (  )  )  ;", "assertEquals ( PongMessage . class ,    serverHandler . getReceivedMessages (  )  . get (  0  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["unsolicitedPongWithEmptyPayload"], "fileName": "org.springframework.web.socket.WebSocketHandshakeTests"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ ACCEPT )  ;", "}", "METHOD_END"], "methodName": ["getSecWebSocketAccept"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "List < String >    values    =    get ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ EXTENSIONS )  ;", "if    ( CollectionUtils . isEmpty ( values )  )     {", "return   Collections . emptyList (  )  ;", "} else    {", "List < WebSocketExtension >    result    =    new   ArrayList <  >  ( values . size (  )  )  ;", "for    ( String   value    :    values )     {", "result . addAll ( WebSocketExtension . parseExtensions ( value )  )  ;", "}", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["getSecWebSocketExtensions"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ KEY )  ;", "}", "METHOD_END"], "methodName": ["getSecWebSocketKey"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "List < String >    values    =    get ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ PROTOCOL )  ;", "if    ( CollectionUtils . isEmpty ( values )  )     {", "return   Collections . emptyList (  )  ;", "} else", "if    (  ( values . size (  )  )     =  =     1  )     {", "return   getValuesAsList ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ PROTOCOL )  ;", "} else    {", "return   values ;", "}", "}", "METHOD_END"], "methodName": ["getSecWebSocketProtocol"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ VERSION )  ;", "}", "METHOD_END"], "methodName": ["getSecWebSocketVersion"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "return   new   WebSocketHttpHeaders ( headers ,    true )  ;", "}", "METHOD_END"], "methodName": ["readOnlyWebSocketHttpHeaders"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ ACCEPT ,    secWebSocketAccept )  ;", "}", "METHOD_END"], "methodName": ["setSecWebSocketAccept"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  ( extensions . size (  )  )  ;", "for    ( WebSocketExtension   extension    :    extensions )     {", "result . add ( extension . toString (  )  )  ;", "}", "set (  . SEC _ WEBSOCKET _ EXTENSIONS ,    toCommaDelimitedString ( result )  )  ;", "}", "METHOD_END"], "methodName": ["setSecWebSocketExtensions"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ KEY ,    secWebSocketKey )  ;", "}", "METHOD_END"], "methodName": ["setSecWebSocketKey"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ PROTOCOL ,    secWebSocketProtocol )  ;", "}", "METHOD_END"], "methodName": ["setSecWebSocketProtocol"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ PROTOCOL ,    toCommaDelimitedString ( secWebSocketProtocols )  )  ;", "}", "METHOD_END"], "methodName": ["setSecWebSocketProtocol"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ VERSION ,    secWebSocketVersion )  ;", "}", "METHOD_END"], "methodName": ["setSecWebSocketVersion"], "fileName": "org.springframework.web.socket.WebSocketHttpHeaders"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . nativeSession )     !  =    null )  ,     \" WebSocket   session   is   not   yet   initialized \"  )  ;", "}", "METHOD_END"], "methodName": ["checkNativeSessionInitialized"], "fileName": "org.springframework.web.socket.adapter.AbstractWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( session ,     \" WebSocket   session   must   not   be   null \"  )  ;", "this . nativeSession    =    session ;", "}", "METHOD_END"], "methodName": ["initializeNativeSession"], "fileName": "org.springframework.web.socket.adapter.AbstractWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "BinaryMessage   message    =    new   BinaryMessage ( payload ,    offset ,    length ,    true )  ;", "try    {", "this . webSocketHandler . handleMessage ( this . wsSession ,    message )  ;", "}    catch    ( Throwable   ex )     {", "ExceptionWebSocketHandlerDecorator . tryCloseWithError ( this . wsSession ,    ex ,     . logger )  ;", "}", "}", "METHOD_END"], "methodName": ["onWebSocketBinary"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "CloseStatus   closeStatus    =    new   CloseStatus ( statusCode ,    reason )  ;", "try    {", "this . webSocketHandler . afterConnectionClosed ( this . wsSession ,    closeStatus )  ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  \" Unhandled   exception   after   connection   closed   for    \"     +     ( this )  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["onWebSocketClose"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . wsSession . initializeNativeSession ( session )  ;", "this . webSocketHandler . afterConnectionEstablished ( this . wsSession )  ;", "}    catch    ( Throwable   ex )     {", "ExceptionWebSocketHandlerDecorator . tryCloseWithError ( this . wsSession ,    ex ,     . logger )  ;", "}", "}", "METHOD_END"], "methodName": ["onWebSocketConnect"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . webSocketHandler . handleTransportError ( this . wsSession ,    cause )  ;", "}    catch    ( Throwable   ex )     {", "ExceptionWebSocketHandlerDecorator . tryCloseWithError ( this . wsSession ,    ex ,     . logger )  ;", "}", "}", "METHOD_END"], "methodName": ["onWebSocketError"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( OpCode . PONG )     =  =     ( frame . getOpCode (  )  )  )     {", "ByteBuffer   payload    =     (  ( frame . getPayload (  )  )     !  =    null )     ?    frame . getPayload (  )     :     . EMPTY _ PAYLOAD ;", "PongMessage   message    =    new   PongMessage ( payload )  ;", "try    {", "this . webSocketHandler . handleMessage ( this . wsSession ,    message )  ;", "}    catch    ( Throwable   ex )     {", "ExceptionWebSocketHandlerDecorator . tryCloseWithError ( this . wsSession ,    ex ,     . logger )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["onWebSocketFrame"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "TextMessage   message    =    new   TextMessage ( payload )  ;", "try    {", "this . webSocketHandler . handleMessage ( this . wsSession ,    message )  ;", "}    catch    ( Throwable   ex )     {", "ExceptionWebSocketHandlerDecorator . tryCloseWithError ( this . wsSession ,    ex ,     . logger )  ;", "}", "}", "METHOD_END"], "methodName": ["onWebSocketText"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . adapter . onWebSocketClose (  1  0  0  0  ,     \" reason \"  )  ;", "verify ( this . w )  . afterConnectionClosed ( this . webSocketSession ,    CloseStatus . NORMAL . withReason (  \" reason \"  )  )  ;", "}", "METHOD_END"], "methodName": ["onClose"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Exception   exception    =    new   Exception (  )  ;", "this . adapter . onWebSocketError ( exception )  ;", "verify ( this . w )  . handleTransportError ( this . webSocketSession ,    exception )  ;", "}", "METHOD_END"], "methodName": ["onError"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "this . adapter . onWebSocketConnect ( this . session )  ;", "verify ( this . w )  . afterConnectionEstablished ( this . webSocketSession )  ;", "}", "METHOD_END"], "methodName": ["onOpen"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "this . session    =    mock ( Session . class )  ;", "given ( this . session . getUpgradeRequest (  )  )  . willReturn ( Mockito . mock ( UpgradeRequest . class )  )  ;", "given ( this . session . getUpgradeResponse (  )  )  . willReturn ( Mockito . mock ( UpgradeResponse . class )  )  ;", "this . webSocketHandler    =    mock ( WebSocketHandler . class )  ;", "this . webSocketSession    =    new   JettyWebSocketSession ( null ,    null )  ;", "this . adapter    =    new    ( this . webSocketHandler ,    this . webSocketSession )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketHandlerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   getNativeSession (  )  . getRemote (  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   IOException (  (  \" Unable   to   obtain   RemoteEndpoint   in   session    \"     +     ( getId (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getRemoteEndpoint"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "String   protocol    =     \" foo \"  ;", "UpgradeRequest   request    =    Mockito . mock ( UpgradeRequest . class )  ;", "given ( request . getUserPrincipal (  )  )  . willReturn ( null )  ;", "UpgradeResponse   response    =    Mockito . mock ( UpgradeResponse . class )  ;", "given ( response . getAcceptedSubProtocol (  )  )  . willReturn ( protocol )  ;", "Session   nativeSession    =    Mockito . mock ( Session . class )  ;", "given ( nativeSession . getUpgradeRequest (  )  )  . willReturn ( request )  ;", "given ( nativeSession . getUpgradeResponse (  )  )  . willReturn ( response )  ;", "session    =    new    ( attributes )  ;", "session . initializeNativeSession ( nativeSession )  ;", "reset ( nativeSession )  ;", "assertSame ( protocol ,    session . getAcceptedProtocol (  )  )  ;", "verifyNoMoreInteractions ( nativeSession )  ;", "}", "METHOD_END"], "methodName": ["getAcceptedProtocol"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketSessionTests"}, {"methodBody": ["METHOD_START", "{", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "UpgradeRequest   request    =    Mockito . mock ( UpgradeRequest . class )  ;", "given ( request . getUserPrincipal (  )  )  . willReturn ( user )  ;", "UpgradeResponse   response    =    Mockito . mock ( UpgradeResponse . class )  ;", "given ( response . getAcceptedSubProtocol (  )  )  . willReturn ( null )  ;", "Session   nativeSession    =    Mockito . mock ( Session . class )  ;", "given ( nativeSession . getUpgradeRequest (  )  )  . willReturn ( request )  ;", "given ( nativeSession . getUpgradeResponse (  )  )  . willReturn ( response )  ;", "session    =    new    ( attributes )  ;", "session . initializeNativeSession ( nativeSession )  ;", "reset ( nativeSession )  ;", "assertSame ( user ,    session . getPrincipal (  )  )  ;", "verifyNoMoreInteractions ( nativeSession )  ;", "}", "METHOD_END"], "methodName": ["getPrincipalFromNativeSession"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketSessionTests"}, {"methodBody": ["METHOD_START", "{", "UpgradeRequest   request    =    Mockito . mock ( UpgradeRequest . class )  ;", "given ( request . getUserPrincipal (  )  )  . willReturn ( null )  ;", "UpgradeResponse   response    =    Mockito . mock ( UpgradeResponse . class )  ;", "given ( response . getAcceptedSubProtocol (  )  )  . willReturn ( null )  ;", "Session   nativeSession    =    Mockito . mock ( Session . class )  ;", "given ( nativeSession . getUpgradeRequest (  )  )  . willReturn ( request )  ;", "given ( nativeSession . getUpgradeResponse (  )  )  . willReturn ( response )  ;", "session    =    new    ( attributes )  ;", "session . initializeNativeSession ( nativeSession )  ;", "reset ( nativeSession )  ;", "assertNull ( session . getPrincipal (  )  )  ;", "verifyNoMoreInteractions ( nativeSession )  ;", "}", "METHOD_END"], "methodName": ["getPrincipalNotAvailable"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketSessionTests"}, {"methodBody": ["METHOD_START", "{", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "session    =    new    ( attributes ,    user )  ;", "assertSame ( user ,    session . getPrincipal (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPrincipalWithConstructorArg"], "fileName": "org.springframework.web.socket.adapter.jetty.JettyWebSocketSessionTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( T )     ( getConversionService (  )  . convert ( message ,    getMessageType (  )  ,    getType (  )  )  )  )  ;", "}    catch    ( ConversionException   ex )     {", "if    ( message   instanceof   String )     {", "throw   new   webDecodeException (  (  ( String )     ( message )  )  ,     \" Unable   to   decode   webmessage   using   ConversionService \"  ,    ex )  ;", "}", "if    ( message   instanceof   ByteBuffer )     {", "throw   new   webDecodeException (  (  ( ByteBuffer )     ( message )  )  ,     \" Unable   to   decode   webmessage   using   ConversionService \"  ,    ex )  ;", "}", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( M )     ( getConversionService (  )  . convert ( object ,    getType (  )  ,    getMessageType (  )  )  )  )  ;", "}    catch    ( ConversionException   ex )     {", "throw   new   webEncodeException ( object ,     \" Unable   to   encode   webmessage   using   ConversionService \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport"}, {"methodBody": ["METHOD_START", "{", "return   ContextLoader . getCurrentWebApplicationContext (  )  ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    getApplicationContext (  )  ;", "Assert . state (  ( applicationContext    !  =    null )  ,     \" Unable   to   locate   the   Spring   ApplicationContext \"  )  ;", "try    {", "return   applicationContext . getBean (  . CONVERSION _ SERVICE _ BEAN _ NAME ,    ConversionService . class )  ;", "}    catch    ( BeansException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Unable   to   find   ConversionService :    please   configure   a    '  \"     +     (  . CONVERSION _ SERVICE _ BEAN _ NAME )  )     +     \"  '    or   override   the   getConversionService (  )    method \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getConversionService"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport"}, {"methodBody": ["METHOD_START", "{", "return   TypeDescriptor . valueOf ( resolveTypeArguments (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["getMessageType"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport"}, {"methodBody": ["METHOD_START", "{", "return   TypeDescriptor . valueOf ( resolveTypeArguments (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   applicationContext    =    getApplicationContext (  )  ;", "if    (  ( applicationContext    !  =    null )     &  &     ( applicationContext   inceof   ConfigurableApplicationContext )  )     {", "ConfigurableListableBeanFactory   beanFactory    =     (  ( ConfigurableApplicationContext )     ( applicationContext )  )  . getBeanFactory (  )  ;", "beanFactory . autowireBean ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    resolved    =    GenericTypeResolver . resolveTypeArguments ( getClass (  )  ,    ConvertingEncoderDecoderSupport . class )  ;", "if    ( resolved    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" ConvertingEncoderDecoderSupport ' s   generic   types   T   and   M    \"     +     \" need   to   be   substituted   in   subclass :     \"  )     +     ( getClass (  )  )  )  )  ;", "}", "return   resolved ;", "}", "METHOD_END"], "methodName": ["resolveTypeArguments"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport"}, {"methodBody": ["METHOD_START", "{", "return   getConversionService (  )  . canConvert ( getType (  )  ,    getMessageType (  )  )  ;", "}", "METHOD_END"], "methodName": ["willDecode"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupport"}, {"methodBody": ["METHOD_START", "{", "ConvertingEncoderDecoderSupportTests . WithAutowire   withAutowire    =    new   ConvertingEncoderDecoderSupportTests . WithAutowire (  )  ;", "withAutowire . init ( null )  ;", "assertThat ( withAutowire . config ,    equalTo ( applicationContext . getBean ( ConvertingEncoderDecoderSupportTests . Config . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["autowiresIntoEncoder"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "ContextLoaderTestUtils . setCurrentWebApplicationContext ( null )  ;", ". WithAutowire   encoder    =    new    . WithAutowire (  )  ;", "encoder . init ( null )  ;", "thown . expect ( IllegalStateException . class )  ;", "thown . expectMessage (  \" Unable   to   locate   the   Spring   ApplicationContext \"  )  ;", "encoder . encode ( myType )  ;", "}", "METHOD_END"], "methodName": ["cannotFindApplicationContext"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "setup ( ConvertingEncoderDecoderSupportTests . NoConfig . class )  ;", "ConvertingEncoderDecoderSupportTests . MyBinaryEncoder   encoder    =    new   ConvertingEncoderDecoderSupportTests . MyBinaryEncoder (  )  ;", "encoder . init ( null )  ;", "thown . expect ( IllegalStateException . class )  ;", "thown . expectMessage (  \" Unable   to   find   ConversionService \"  )  ;", "encoder . encode ( myType )  ;", "}", "METHOD_END"], "methodName": ["cannotFindConversionService"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "Decoder . Binary < ConvertingEncoderDecoderSupportTests . MyType >    decoder    =    new   ConvertingEncoderDecoderSupportTests . MyBinaryDecoder (  )  ;", "assertThat ( decoder . willDecode ( ConvertingEncoderDecoderSupportTests . CONVERTED _ BYTES )  ,    is ( true )  )  ;", "assertThat ( decoder . decode ( ConvertingEncoderDecoderSupportTests . CONVERTED _ BYTES )  ,    equalTo ( myType )  )  ;", "}", "METHOD_END"], "methodName": ["decodeFromBinary"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "setup ( ConvertingEncoderDecoderSupportTests . NoConvertersConfig . class )  ;", "Decoder . Binary < ConvertingEncoderDecoderSupportTests . MyType >    decoder    =    new   ConvertingEncoderDecoderSupportTests . MyBinaryDecoder (  )  ;", "assertThat ( decoder . willDecode ( ConvertingEncoderDecoderSupportTests . CONVERTED _ BYTES )  ,    is ( false )  )  ;", "thown . expect ( DecodeException . class )  ;", "thown . expectCause ( isA ( ConverterNotFoundException . class )  )  ;", "decoder . decode ( ConvertingEncoderDecoderSupportTests . CONVERTED _ BYTES )  ;", "}", "METHOD_END"], "methodName": ["decodeFromBinaryCannotConvert"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "Decoder . Text < ConvertingEncoderDecoderSupportTests . MyType >    decoder    =    new   ConvertingEncoderDecoderSupportTests . MyTextDecoder (  )  ;", "assertThat ( decoder . willDecode ( ConvertingEncoderDecoderSupportTests . CONVERTED _ TEXT )  ,    is ( true )  )  ;", "assertThat ( decoder . decode ( ConvertingEncoderDecoderSupportTests . CONVERTED _ TEXT )  ,    equalTo ( myType )  )  ;", "}", "METHOD_END"], "methodName": ["decodeFromText"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "setup ( ConvertingEncoderDecoderSupportTests . NoConvertersConfig . class )  ;", "Decoder . Text < ConvertingEncoderDecoderSupportTests . MyType >    decoder    =    new   ConvertingEncoderDecoderSupportTests . MyTextDecoder (  )  ;", "assertThat ( decoder . willDecode ( ConvertingEncoderDecoderSupportTests . CONVERTED _ TEXT )  ,    is ( false )  )  ;", "thown . expect ( DecodeException . class )  ;", "thown . expectCause ( isA ( ConverterNotFoundException . class )  )  ;", "decoder . decode ( ConvertingEncoderDecoderSupportTests . CONVERTED _ TEXT )  ;", "}", "METHOD_END"], "methodName": ["decodeFromTextCannotConvert"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "ConvertingEncoderDecoderSupportTests . MyBinaryEncoderDecoder   encoderDecoder    =    new   ConvertingEncoderDecoderSupportTests . MyBinaryEncoderDecoder (  )  ;", "ByteBuffer   encoded    =    encoderDecoder . encode ( myType )  ;", "assertThat ( encoderDecoder . decode ( encoded )  ,    equalTo ( myType )  )  ;", "}", "METHOD_END"], "methodName": ["encodeAndDecodeBytes"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "ConvertingEncoderDecoderSupportTests . MyTextEncoderDecoder   encoderDecoder    =    new   ConvertingEncoderDecoderSupportTests . MyTextEncoderDecoder (  )  ;", "String   encoded    =    encoderDecoder . encode ( myType )  ;", "assertThat ( encoderDecoder . decode ( encoded )  ,    equalTo ( myType )  )  ;", "}", "METHOD_END"], "methodName": ["encodeAndDecodeText"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( new   ConvertingEncoderDecoderSupportTests . MyBinaryEncoder (  )  . encode ( myType )  . array (  )  ,    equalTo ( ConvertingEncoderDecoderSupportTests . CONVERTED _ BYTES . array (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeToBinary"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "setup ( ConvertingEncoderDecoderSupportTests . NoConvertersConfig . class )  ;", "thown . expect ( EncodeException . class )  ;", "thown . expectCause ( isA ( ConverterNotFoundException . class )  )  ;", "new   ConvertingEncoderDecoderSupportTests . MyBinaryEncoder (  )  . encode ( myType )  ;", "}", "METHOD_END"], "methodName": ["encodeToBinaryCannotConvert"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( new   ConvertingEncoderDecoderSupportTests . MyTextEncoder (  )  . encode ( myType )  ,    equalTo ( ConvertingEncoderDecoderSupportTests . CONVERTED _ TEXT )  )  ;", "}", "METHOD_END"], "methodName": ["encodeToText"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "setup ( ConvertingEncoderDecoderSupportTests . NoConvertersConfig . class )  ;", "thown . expect ( EncodeException . class )  ;", "thown . expectCause ( isA ( ConverterNotFoundException . class )  )  ;", "new   ConvertingEncoderDecoderSupportTests . MyTextEncoder (  )  . encode ( myType )  ;", "}", "METHOD_END"], "methodName": ["encodeToTextCannotConvert"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "setup ( ConvertingEncoderDecoderSupportTests . Config . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigWebApplicationContext   applicationContext    =    new   AnnotationConfigWebApplicationContext (  )  ;", "applicationContext . register ( configurationClass )  ;", "applicationContext . refresh (  )  ;", "this . applicationContext    =    applicationContext ;", "ContextLoaderUtils . setCurrentWebApplicationContext ( this . applicationContext )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "ContextLoaderTestUtils . setCurrentWebApplicationContext ( null )  ;", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.springframework.web.socket.adapter.standard.ConvertingEncoderDecoderSupportTests"}, {"methodBody": ["METHOD_START", "{", "List < Extension . Parameter >    parameters    =    extension . getParameters (  )  ;", "Map < String ,    String >    result    =    new   util . LinkedCaseInsensitiveMap ( parameters . size (  )  ,    Locale . ENGLISH )  ;", "for    ( Extension . Parameter   parameter    :    parameters )     {", "result . put ( parameter . getName (  )  ,    parameter . getValue (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["initParameters"], "fileName": "org.springframework.web.socket.adapter.standard.StandardToWebSocketExtensionAdapter"}, {"methodBody": ["METHOD_START", "{", "BinaryMessage   binaryMessage    =    new   BinaryMessage ( payload ,    isLast )  ;", "try    {", "this . handler . handleMessage ( this . wsSession ,    binaryMessage )  ;", "}    catch    ( Throwable   ex )     {", "ExceptionWebSocketHandlerDecorator . tryCloseWithError ( this . wsSession ,    ex ,     . logger )  ;", "}", "}", "METHOD_END"], "methodName": ["handleBinaryMessage"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "PongMessage   pongMessage    =    new   PongMessage ( payload )  ;", "try    {", "this . handler . handleMessage ( this . wsSession ,    pongMessage )  ;", "}    catch    ( Throwable   ex )     {", "ExceptionWebSocketHandlerDecorator . tryCloseWithError ( this . wsSession ,    ex ,     . logger )  ;", "}", "}", "METHOD_END"], "methodName": ["handlePongMessage"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessage    =    new   TextMessage ( payload ,    isLast )  ;", "try    {", "this . handler . handleMessage ( this . wsSession ,    textMessage )  ;", "}    catch    ( Throwable   ex )     {", "ExceptionWebSocketHandlerDecorator . tryCloseWithError ( this . wsSession ,    ex ,     . logger )  ;", "}", "}", "METHOD_END"], "methodName": ["handleTextMessage"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . adapter . onClose ( this . session ,    new   CloseReason ( CloseCodes . NORMAL _ CLOSURE ,     \" reason \"  )  )  ;", "verify ( this . w )  . afterConnectionClosed ( this . webSocketSession ,    CloseStatus . NORMAL . withReason (  \" reason \"  )  )  ;", "}", "METHOD_END"], "methodName": ["onClose"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Exception   exception    =    new   Exception (  )  ;", "this . adapter . onError ( this . session ,    exception )  ;", "verify ( this . w )  . handleTransportError ( this . webSocketSession ,    exception )  ;", "}", "METHOD_END"], "methodName": ["onError"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . session . getId (  )  )  . willReturn (  \"  1  2  3  \"  )  ;", "this . adapter . onOpen ( this . session ,    null )  ;", "verify ( this . w )  . afterConnectionEstablished ( this . webSocketSession )  ;", "verify ( this . session ,    atLeast (  2  )  )  . addMessageHandler ( any ( Whole . class )  )  ;", "given ( this . session . getId (  )  )  . willReturn (  \"  1  2  3  \"  )  ;", "assertEquals (  \"  1  2  3  \"  ,    this . webSocketSession . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["onOpen"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "this . session    =    mock ( Session . class )  ;", "this . webSocketHandler    =    mock ( WebSocketHandler . class )  ;", "this . webSocketSession    =    new   StandardWebSocketSession ( null ,    null ,    null ,    null )  ;", "this . adapter    =    new    ( this . webSocketHandler ,    this . webSocketSession )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . user ;", "}", "METHOD_END"], "methodName": ["getPrincipal"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "String   protocol    =     \" foo \"  ;", "Session   nativeSession    =    Mockito . mock ( Session . class )  ;", "given ( nativeSession . getNegotiatedSubprotocol (  )  )  . willReturn ( protocol )  ;", "session    =    new    ( this . headers ,    this . attributes ,    null ,    null )  ;", "session . initializeNativeSession ( nativeSession )  ;", "reset ( nativeSession )  ;", "assertEquals ( protocol ,    session . getAcceptedProtocol (  )  )  ;", "verifyNoMoreInteractions ( nativeSession )  ;", "}", "METHOD_END"], "methodName": ["getAcceptedProtocol"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketSessionTests"}, {"methodBody": ["METHOD_START", "{", "Session   nativeSession    =    Mockito . mock ( Session . class )  ;", "given ( nativeSession . getUserPrincipal (  )  )  . willReturn ( null )  ;", "session    =    new    ( this . headers ,    this . attributes ,    null ,    null )  ;", "session . initializeNativeSession ( nativeSession )  ;", "reset ( nativeSession )  ;", "assertNull ( session . getPrincipal (  )  )  ;", "verifyNoMoreInteractions ( nativeSession )  ;", "}", "METHOD_END"], "methodName": ["getPrincipalNone"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketSessionTests"}, {"methodBody": ["METHOD_START", "{", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "session    =    new    ( this . headers ,    this . attributes ,    null ,    null ,    user )  ;", "assertSame ( user ,    session . getPrincipal (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPrincipalWithConstructorArg"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketSessionTests"}, {"methodBody": ["METHOD_START", "{", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "Session   nativeSession    =    Mockito . mock ( Session . class )  ;", "given ( nativeSession . getUserPrincipal (  )  )  . willReturn ( user )  ;", "session    =    new    ( this . headers ,    this . attributes ,    null ,    null )  ;", "session . initializeNativeSession ( nativeSession )  ;", "assertSame ( user ,    session . getPrincipal (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPrincipalWithNativeSession"], "fileName": "org.springframework.web.socket.adapter.standard.StandardWebSocketSessionTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( uri ,     \" URI   must   not   be   null \"  )  ;", "St   scheme    =    uri . getScheme (  )  ;", "if    (  (  !  (  \" ws \"  . equals ( scheme )  )  )     &  &     (  !  (  \" wss \"  . equals ( scheme )  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Invalid   scheme :     \"     +    scheme )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertUri"], "fileName": "org.springframework.web.socket.client.AbstractWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . uri ;", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "org.springframework.web.socket.client.ConnectionManagerSupport"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.web.socket.client.ConnectionManagerSupport"}, {"methodBody": ["METHOD_START", "{", "this . phase    =    phase ;", "}", "METHOD_END"], "methodName": ["setPhase"], "fileName": "org.springframework.web.socket.client.ConnectionManagerSupport"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Starting    \"     +     ( getClass (  )  . getSimpleName (  )  )  )  )  ;", "}", "this . running    =    true ;", "open (  )  ;", "}", "}", "METHOD_END"], "methodName": ["startInternal"], "fileName": "org.springframework.web.socket.client.ConnectionManagerSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( isConnected (  )  )     {", "close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stopInternal"], "fileName": "org.springframework.web.socket.client.ConnectionManagerSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   LoggingWebSocketHandlerDecorator ( handler )  ;", "}", "METHOD_END"], "methodName": ["decorateWebSocketHandler"], "fileName": "org.springframework.web.socket.client.WebSocketConnectionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.web.socket.client.WebSocketConnectionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . headers . getOrigin (  )  ;", "}", "METHOD_END"], "methodName": ["getOrigin"], "fileName": "org.springframework.web.socket.client.WebSocketConnectionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . headers . getSecWebSocketProtocol (  )  ;", "}", "METHOD_END"], "methodName": ["getSubProtocols"], "fileName": "org.springframework.web.socket.client.WebSocketConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . headers . clear (  )  ;", "this . headers . putAll ( headers )  ;", "}", "METHOD_END"], "methodName": ["setHeaders"], "fileName": "org.springframework.web.socket.client.WebSocketConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . headers . setOrigin ( origin )  ;", "}", "METHOD_END"], "methodName": ["setOrigin"], "fileName": "org.springframework.web.socket.client.WebSocketConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . headers . setSecWebSocketProtocol ( protocols )  ;", "}", "METHOD_END"], "methodName": ["setSubProtocols"], "fileName": "org.springframework.web.socket.client.WebSocketConnectionManager"}, {"methodBody": ["METHOD_START", "{", "WebSocketConnectionManagerTests . TestLifecycleWebSocketClient   client    =    new   WebSocketConnectionManagerTests . TestLifecycleWebSocketClient ( false )  ;", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "WebSocketConnectionManager   manager    =    new   WebSocketConnectionManager ( client ,    handler ,     \"  / a \"  )  ;", "manager . startInternal (  )  ;", "assertTrue ( client . isRunning (  )  )  ;", "manager . stopInternal (  )  ;", "assertFalse ( client . isRunning (  )  )  ;", "}", "METHOD_END"], "methodName": ["clientLifecycle"], "fileName": "org.springframework.web.socket.client.WebSocketConnectionManagerTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    subprotocols    =    Arrays . asList (  \" abc \"  )  ;", ". TestLifecycleWebSocketClient   client    =    new    . TestLifecycleWebSocketClient ( false )  ;", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "WebSocketConnectionManager   manager    =    new   WebSocketConnectionManager ( client ,    handler ,     \"  / path /  { id }  \"  ,     \"  1  2  3  \"  )  ;", "manager . setSubProtocols ( subprotocols )  ;", "manager . openConnection (  )  ;", "WebSocketHttpHeaders   expectedHeaders    =    new   WebSocketHttpHeaders (  )  ;", "expectedHeaders . setSecWebSocketProtocol ( subprotocols )  ;", "assertEquals ( expectedHeaders ,    client . headers )  ;", "assertEquals ( new   URI (  \"  / path /  1  2  3  \"  )  ,    client . uri )  ;", "WebSocketHandlerDecorator   loggingHandler    =     (  ( WebSocketHandlerDecorator )     ( client . webSocketHandler )  )  ;", "assertEquals ( LoggingWebSocketHandlerDecorator . class ,    loggingHandler . getClass (  )  )  ;", "assertSame ( handler ,    loggingHandler . getDelegate (  )  )  ;", "}", "METHOD_END"], "methodName": ["openConnection"], "fileName": "org.springframework.web.socket.client.WebSocketConnectionManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . taskExecutor ;", "}", "METHOD_END"], "methodName": ["getTaskExecutor"], "fileName": "org.springframework.web.socket.client.jetty.JettyWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getUser"], "fileName": "org.springframework.web.socket.client.jetty.JettyWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.web.socket.client.jetty.JettyWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders (  )  ;", "headers . setSecWebSocketProtocol ( Arrays . asList (  \" echo \"  )  )  ;", "this . wsSession    =    this . client . doHandshake ( new   TextWebSocketHandler (  )  ,    headers ,    new   URI ( this . wsUrl )  )  . get (  )  ;", "assertEquals ( this . wsUrl ,    this . wsSession . getUri (  )  . toString (  )  )  ;", "assertEquals (  \" echo \"  ,    this . wsSession . getAcceptedProtocol (  )  )  ;", "}", "METHOD_END"], "methodName": ["doHandshake"], "fileName": "org.springframework.web.socket.client.jetty.JettyWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders (  )  ;", "headers . setSecWebSocketProtocol ( Arrays . asList (  \" echo \"  )  )  ;", "this . client . setTaskExecutor ( new   SimpleAsyncTaskExecutor (  )  )  ;", "this . wsSession    =    this . client . doHandshake ( new   TextWebSocketHandler (  )  ,    headers ,    new   URI ( this . wsUrl )  )  . get (  )  ;", "assertEquals ( this . wsUrl ,    this . wsSession . getUri (  )  . toString (  )  )  ;", "assertEquals (  \" echo \"  ,    this . wsSession . getAcceptedProtocol (  )  )  ;", "}", "METHOD_END"], "methodName": ["doHandshakeWithTaskExecutor"], "fileName": "org.springframework.web.socket.client.jetty.JettyWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "this . server    =    new   JettyWebSocketClientTests . TestJettyWebSocketServer ( new   TextWebSocketHandler (  )  )  ;", "this . server . start (  )  ;", "this . client    =    new   JettyWebSocketClient (  )  ;", "this . client . start (  )  ;", "this . wsUrl    =     (  \" ws :  /  / localhost :  \"     +     ( this . server . getPort (  )  )  )     +     \"  / test \"  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.client.jetty.JettyWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "this . wsSession . close (  )  ;", "thisstop (  )  ;", "this . server . stop (  )  ;", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.springframework.web.socket.client.jetty.JettyWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "return   this . taskExecutor ;", "}", "METHOD_END"], "methodName": ["getTaskExecutor"], "fileName": "org.springframework.web.socket.client.standard.AnnotatedEndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketContainer ;", "}", "METHOD_END"], "methodName": ["getWebSocketContainer"], "fileName": "org.springframework.web.socket.client.standard.AnnotatedEndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( taskExecutor ,     \" TaskExecutor   must   not   be   null \"  )  ;", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.web.socket.client.standard.AnnotatedEndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . webSocketContainer    =    webSocketContainer ;", "}", "METHOD_END"], "methodName": ["setWebSocketContainer"], "fileName": "org.springframework.web.socket.client.standard.AnnotatedEndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . taskExecutor ;", "}", "METHOD_END"], "methodName": ["getTaskExecutor"], "fileName": "org.springframework.web.socket.client.standard.EndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketContainer ;", "}", "METHOD_END"], "methodName": ["getWebSocketContainer"], "fileName": "org.springframework.web.socket.client.standard.EndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . configBuilder . configurator ( configurator )  ;", "}", "METHOD_END"], "methodName": ["setConfigurator"], "fileName": "org.springframework.web.socket.client.standard.EndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . configBuilder . decoders ( decoders )  ;", "}", "METHOD_END"], "methodName": ["setDecoders"], "fileName": "org.springframework.web.socket.client.standard.EndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . configBuilder . encoders ( encoders )  ;", "}", "METHOD_END"], "methodName": ["setEncoders"], "fileName": "org.springframework.web.socket.client.standard.EndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . configBuilder . extensions ( Arrays . asList ( extensions )  )  ;", "}", "METHOD_END"], "methodName": ["setExtensions"], "fileName": "org.springframework.web.socket.client.standard.EndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . configBuilder . preferredSubprotocols ( Arrays . asList ( protocols )  )  ;", "}", "METHOD_END"], "methodName": ["setSupportedProtocols"], "fileName": "org.springframework.web.socket.client.standard.EndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( taskExecutor ,     \" TaskExecutor   must   not   be   null \"  )  ;", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.web.socket.client.standard.EndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "this . webSocketContainer    =    webSocketContainer ;", "}", "METHOD_END"], "methodName": ["setWebSocketContainer"], "fileName": "org.springframework.web.socket.client.standard.EndpointConnectionManager"}, {"methodBody": ["METHOD_START", "{", "List < Extension >    result    =    new   ArrayList <  >  (  )  ;", "for    ( Extension   extension    :    extensions )     {", "result . add ( new   ToStandardExtensionAdapter ( extension )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["adaptExtensions"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "try    {", "rurn   InAddress . gLocalHost (  )  ;", "}    catch    ( UnknownHostException   ex )     {", "rurn   InAddress . gLoopbackAddress (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getLocalHost"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "if    (  ( uri . getPort (  )  )     =  =     (  -  1  )  )     {", "St   scheme    =    uri . getScheme (  )  . toLowerCase ( Locale . ENGLISH )  ;", "return    \" wss \"  . equals ( scheme )     ?     4  4  3     :     8  0  ;", "}", "return   uri . getPort (  )  ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . taskExecutor ;", "}", "METHOD_END"], "methodName": ["getTaskExecutor"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "return   this . userProperties ;", "}", "METHOD_END"], "methodName": ["getUserProperties"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "if    ( userProperties    !  =    null )     {", "this . userProperties . putAll ( userProperties )  ;", "}", "}", "METHOD_END"], "methodName": ["setUserProperties"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClient"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" ws :  /  / localhost / abc \"  )  ;", "List < String >    protocols    =    Collections . singletonList (  \" abc \"  )  ;", "this . headers . setSecProtocol ( protocols )  ;", "this . wsClient . doHandshake ( this . wsHandler ,    this . headers ,    uri )  . get (  )  ;", "ArgumentCaptor < ClientEndpointConfig >    captor    =    ArgumentCaptor . forClass ( ClientEndpointConfig . class )  ;", "verify ( this . wsContainer )  . connectToServer ( any ( Endpoint . class )  ,    captor . capture (  )  ,    any ( URI . class )  )  ;", "ClientEndpointConfig   endpointConfig    =    captor . getValue (  )  ;", "assertEquals ( protocols ,    endpointConfig . getPreferredSubprotocols (  )  )  ;", "}", "METHOD_END"], "methodName": ["clientEndpointConfig"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    userProperties    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "URI   uri    =    new   URI (  \" ws :  /  / localhost / abc \"  )  ;", "this . wsCetUserProperties ( userProperties )  ;", "this . wsClient . doHandshake ( this . wsHandler ,    this . headers ,    uri )  . get (  )  ;", "ArgumentCaptor < ClientEndpointConfig >    captor    =    ArgumentCaptor . forClass ( ClientEndpointConfig . class )  ;", "verify ( this . wsContainer )  . connectToServer ( any ( Endpoint . class )  ,    captor . capture (  )  ,    any ( URI . class )  )  ;", "ClientEndpointConfig   endpointConfig    =    captor . getValue (  )  ;", "assertEquals ( userProperties ,    endpointConfig . getUserProperties (  )  )  ;", "}", "METHOD_END"], "methodName": ["clientEndpointConfigWithUserProperties"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" ws :  /  / localhost / abc \"  )  ;", "List < String >    protocols    =    Collections . singletonList (  \" abc \"  )  ;", "this . headers . setSecProtocol ( protocols )  ;", "this . headers . add (  \" foo \"  ,     \" bar \"  )  ;", "Session   session    =    this . wsClient . doHandshake ( this . wsHandler ,    this . headers ,    uri )  . get (  )  ;", "assertEquals (  1  ,    session . getHandshakeHeaders (  )  . size (  )  )  ;", "assertEquals (  \" bar \"  ,    session . getHandshakeHeaders (  )  . getFirst (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handshakeHeaders"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "this . headers    =    new   WebSocketHttpHeaders (  )  ;", "this . wsHandler    =    new   AbstractWebSocketHandler (  )     {  }  ;", "this . wsContainer    =    mock ( WebSocketContainer . class )  ;", "this . wsClient    =    new    ( this . wsContainer )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" ws :  /  / localhost / abc \"  )  ;", "this . headers . add (  \" foo \"  ,     \" bar \"  )  ;", "this . ws . doHandshake ( this . wsHandler ,    this . headers ,    uri )  . get (  )  ;", "ArgumentCaptor < EndpointConfig >    captor    =    ArgumentCaptor . forClass ( EndpointConfig . class )  ;", "verify ( this . wsContainer )  . connectToServer ( any ( Endpoint . class )  ,    captor . capture (  )  ,    any ( URI . class )  )  ;", "EndpointConfig   endpointConfig    =    captor . getValue (  )  ;", "Map < String ,    List < String >  >    headers    =    new   HashMap <  >  (  )  ;", "endpointConfig . getConfigurator (  )  . beforeRequest ( headers )  ;", "assertEquals (  1  ,    headers . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["standardWebSocketClientConfiguratorInsertsHandshakeHeaders"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" ws :  /  / localhost / abc \"  )  ;", "this . wsClient . setTaskExecutor ( new   SimpleAsyncTaskExecutor (  )  )  ;", "Session   session    =    this . wsClient . doHandshake ( this . wsHandler ,    this . headers ,    uri )  . get (  )  ;", "assertNotNull ( session )  ;", "}", "METHOD_END"], "methodName": ["taskExecutor"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" ws :  /  / localhost / abc \"  )  ;", "Session   session    =    this . wsClient . doHandshake ( this . wsHandler ,    this . headers ,    uri )  . get (  )  ;", "assertNotNull ( session . getLocalAddress (  )  )  ;", "assertEquals (  8  0  ,    session . getLocalAddress (  )  . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetLocalAddress"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" localhost / abc \"  )  ;", "this . ws . doHandshake ( this . wsHandler ,    this . headers ,    uri )  ;", "}", "METHOD_END"], "methodName": ["testGetLocalAddressNoScheme"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" wss :  /  / localhost / abc \"  )  ;", "Session   session    =    this . wsClient . doHandshake ( this . wsHandler ,    this . headers ,    uri )  . get (  )  ;", "assertNotNull ( session . getLocalAddress (  )  )  ;", "assertEquals (  4  4  3  ,    session . getLocalAddress (  )  . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetLocalAddressWss"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    new   URI (  \" wss :  /  / localhost / abc \"  )  ;", "Session   session    =    this . wsClient . doHandshake ( this . wsHandler ,    this . headers ,    uri )  . get (  )  ;", "assertNotNull ( session . getRemoteAddress (  )  )  ;", "assertEquals (  \" localhost \"  ,    session . getRemoteAddress (  )  . getHostName (  )  )  ;", "assertEquals (  4  4  3  ,    session . getLocalAddress (  )  . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetRemoteAddress"], "fileName": "org.springframework.web.socket.client.standard.StandardWebSocketClientTests"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketContainer . getDefaultAsyncSendTimeout (  )  ;", "}", "METHOD_END"], "methodName": ["getAsyncSendTimeout"], "fileName": "org.springframework.web.socket.client.standard.WebSocketContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketContainer . getDefaultMaxBinaryMessageBufferSize (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxBinaryMessageBufferSize"], "fileName": "org.springframework.web.socket.client.standard.WebSocketContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketContainer . getDefaultMaxSessionIdleTimeout (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxSessionIdleTimeout"], "fileName": "org.springframework.web.socket.client.standard.WebSocketContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketContainer . getDefaultMaxTextMessageBufferSize (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxTextMessageBufferSize"], "fileName": "org.springframework.web.socket.client.standard.WebSocketContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . webSocketContainer . setAsyncSendTimeout ( timeoutInMillis )  ;", "}", "METHOD_END"], "methodName": ["setAsyncSendTimeout"], "fileName": "org.springframework.web.socket.client.standard.WebSocketContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . webSocketContainer . setDefaultMaxBinaryMessageBufferSize ( bufferSize )  ;", "}", "METHOD_END"], "methodName": ["setMaxBinaryMessageBufferSize"], "fileName": "org.springframework.web.socket.client.standard.WebSocketContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . webSocketContainer . setDefaultMaxSessionIdleTimeout ( timeoutInMillis )  ;", "}", "METHOD_END"], "methodName": ["setMaxSessionIdleTimeout"], "fileName": "org.springframework.web.socket.client.standard.WebSocketContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . webSocketContainer . setDefaultMaxTextMessageBufferSize ( bufferSize )  ;", "}", "METHOD_END"], "methodName": ["setMaxTextMessageBufferSize"], "fileName": "org.springframework.web.socket.client.standard.WebSocketContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . appContext )  ;", "ClassPathResource   resource    =    new   ClassPathResource ( fileName ,     . class )  ;", "reader . loadBeanDefinitions ( resource )  ;", "this . appContext . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.web.socket.config.HandlersBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - handlers - sockjs . xml \"  )  ;", "SimpleUrlHandlerMapping   handlerMapping    =    this . appContext . getBean ( SimpleUrlHandlerMapping . class )  ;", "assertNotNull ( handlerMapping )  ;", "SockJsHttpRequestHandler   testHandler    =     (  ( SockJsHttpRequestHandler )     ( handlerMapping . getUrlMap (  )  . get (  \"  / test /  *  *  \"  )  )  )  ;", "assertNotNull ( testHandler )  ;", ". unwrapAndCheckDecoratedHandlerType ( testHandler . getWebSocketHandler (  )  ,    TestWebSocketHandler . class )  ;", "SockJsService   testSockJsService    =    testHandler . getSockJsService (  )  ;", "SockJsHttpRequestHandler   fooHandler    =     (  ( SockJsHttpRequestHandler )     ( handlerMapping . getUrlMap (  )  . get (  \"  / foo /  *  *  \"  )  )  )  ;", "assertNotNull ( fooHandler )  ;", ". unwrapAndCheckDecoratedHandlerType ( fooHandler . getWebSocketHandler (  )  ,    FooWebSocketHandler . class )  ;", "SockJsService   sockJsService    =    fooHandler . getSockJsService (  )  ;", "assertNotNull ( sockJsService )  ;", "assertSame ( testSockJsService ,    sockJsService )  ;", "assertThat ( sockJsService ,    instanceOf ( DefaultSockJsService . class )  )  ;", "DefaultSockJsService   defaultSockJsService    =     (  ( DefaultSockJsService )     ( sockJsService )  )  ;", "assertThat ( defaultSockJsService . getTaskScheduler (  )  ,    instanceOf ( ThreadPoolTaskScheduler . class )  )  ;", "assertFalse ( defaultSockJsService . shouldSuppressCors (  )  )  ;", "Map < TransportType ,    TransportHandler >    handlerMap    =    defaultSockJsService . getTransportHandlers (  )  ;", "assertThat ( handlerMap . values (  )  ,    containsInAnyOrder ( instanceOf ( XhrPollingTransportHandler . class )  ,    instanceOf ( XhrReceivingTransportHandler . class )  ,    instanceOf ( JsonpPollingTransportHandler . class )  ,    instanceOf ( JsonpReceivingTransportHandler . class )  ,    instanceOf ( XhrStreamingTransportHandler . class )  ,    instanceOf ( EventSourceTransportHandler . class )  ,    instanceOf ( HtmlFileTransportHandler . class )  ,    instanceOf ( WebSocketTransportHandler . class )  )  )  ;", "WebSocketTransportHandler   handler    =     (  ( WebSocketTransportHandler )     ( handlerMap . get ( TransportType . WEBSOCKET )  )  )  ;", "assertEquals ( TestHandshakeHandler . class ,    handler . getHandshakeHandler (  )  . getClass (  )  )  ;", "List < HandshakeInterceptor >    interceptors    =    defaultSockJsService . getHandshakeInterceptors (  )  ;", "assertThat ( interceptors ,    contains ( instanceOf ( FooTestInterceptor . class )  ,    instanceOf ( BarTestInterceptor . class )  ,    instanceOf ( OriginHandshakeInterceptor . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["sockJs"], "fileName": "org.springframework.web.socket.config.HandlersBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - handlers - sockjs - attributes . xml \"  )  ;", "SimpleUrlHandlerMapping   handlerMapping    =    appContext . getBean ( SimpleUrlHandlerMapping . class )  ;", "assertNotNull ( handlerMapping )  ;", "SockJsHttpRequestHandler   handler    =     (  ( SockJsHttpRequestHandler )     ( handlerMapping . getUrlMap (  )  . get (  \"  / test /  *  *  \"  )  )  )  ;", "assertNotNull ( handler )  ;", ". unwrapAndCheckDecoratedHandlerType ( handler . getWebSocketHandler (  )  ,    TestWebSocketHandler . class )  ;", "SockJsService   sockJsService    =    handler . getSockJsService (  )  ;", "assertNotNull ( sockJsService )  ;", "assertThat ( sockJsService ,    instanceOf ( TransportHandlingSockJsService . class )  )  ;", "TransportHandlingSockJsService   transportService    =     (  ( TransportHandlingSockJsService )     ( sockJsService )  )  ;", "assertThat ( transportService . getTaskScheduler (  )  ,    instanceOf ( TestTaskScheduler . class )  )  ;", "assertThat ( transportService . getTransportHandlers (  )  . values (  )  ,    containsInAnyOrder ( instanceOf ( XhrPollingTransportHandler . class )  ,    instanceOf ( XhrStreamingTransportHandler . class )  )  )  ;", "assertEquals (  \" testSockJsService \"  ,    transportService . getName (  )  )  ;", "assertFalse ( transportService . isWebSocketEnabled (  )  )  ;", "assertFalse ( transportService . isSessionCookieNeeded (  )  )  ;", "assertEquals (  2  0  4  8  ,    transportService . getStreamBytesLimit (  )  )  ;", "assertEquals (  2  5  6  ,    transportService . getDisconnectDelay (  )  )  ;", "assertEquals (  1  0  2  4  ,    transportService . getHttpMessageCacheSize (  )  )  ;", "assertEquals (  2  0  ,    transportService . getHeartbeatTime (  )  )  ;", "assertEquals (  \"  / js / sockjs . min . js \"  ,    transportService . getSockJsClientLibraryUrl (  )  )  ;", "assertEquals ( TestMessageCodec . class ,    transportService . getMessageCodec (  )  . getClass (  )  )  ;", "List < HandshakeInterceptor >    interceptors    =    transportService . getHandshakeInterceptors (  )  ;", "assertThat ( interceptors ,    contains ( instanceOf ( OriginHandshakeInterceptor . class )  )  )  ;", "assertTrue ( transportService . shouldSuppressCors (  )  )  ;", "assertTrue ( transportService . getAllowedOrigins (  )  . contains (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( transportService . getAllowedOrigins (  )  . contains (  \" http :  /  / mydomain 2  . com \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sockJsAttributes"], "fileName": "org.springframework.web.socket.config.HandlersBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "if    ( handler   instanceof   WebSocketHandlerDecorator )     {", "handler    =     (  ( WebSocketHandlerDecorator )     ( handler )  )  . getLastHandler (  )  ;", "}", "assertTrue ( handlerClass . isInstance ( handler )  )  ;", "}", "METHOD_END"], "methodName": ["unwrapAndCheckDecoratedHandlerType"], "fileName": "org.springframework.web.socket.config.HandlersBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - handlers . xml \"  )  ;", "Map < String ,    HandlerMapping >    handlersMap    =    this . appContext . getBeansOfType ( HandlerMapping . class )  ;", "assertNotNull ( handlersMap )  ;", "assertThat ( handlersMap . values (  )  ,    hasSize (  2  )  )  ;", "for    ( HandlerMapping   hm    :    handlersMap . values (  )  )     {", "assertTrue (  ( hm   instanceof   SimpleUrlHandlerMapping )  )  ;", "SimpleUrlHandlerMapping   shm    =     (  ( SimpleUrlHandlerMapping )     ( hm )  )  ;", "if    ( shm . getUrlMap (  )  . keySet (  )  . contains (  \"  / foo \"  )  )     {", "assertThat ( shm . getUrlMap (  )  . keySet (  )  ,    contains (  \"  / foo \"  ,     \"  / bar \"  )  )  ;", "WebSocketHttpRequestHandler   handler    =     (  ( WebSocketHttpRequestHandler )     ( shm . getUrlMap (  )  . get (  \"  / foo \"  )  )  )  ;", "assertNotNull ( handler )  ;", ". unwrapAndCheckDecoratedHandlerType ( handler . getWebSocketHandler (  )  ,    FooWebSocketHandler . class )  ;", "HandshakeHandler   handshakeHandler    =    handler . getHandshakeHandler (  )  ;", "assertNotNull ( handshakeHandler )  ;", "assertTrue (  ( handshakeHandler   instanceof   DefaultHandshakeHandler )  )  ;", "assertFalse ( handler . getHandshakeInterceptors (  )  . isEmpty (  )  )  ;", "assertTrue (  (  ( handler . getHandshakeInterceptors (  )  . get (  0  )  )    instanceof   OriginHandshakeInterceptor )  )  ;", "} else    {", "assertThat ( shm . getUrlMap (  )  . keySet (  )  ,    contains (  \"  / test \"  )  )  ;", "WebSocketHttpRequestHandler   handler    =     (  ( WebSocketHttpRequestHandler )     ( shm . getUrlMap (  )  . get (  \"  / test \"  )  )  )  ;", "assertNotNull ( handler )  ;", ". unwrapAndCheckDecoratedHandlerType ( handler . getWebSocketHandler (  )  ,    TestWebSocketHandler . class )  ;", "HandshakeHandler   handshakeHandler    =    handler . getHandshakeHandler (  )  ;", "assertNotNull ( handshakeHandler )  ;", "assertTrue (  ( handshakeHandler   instanceof   DefaultHandshakeHandler )  )  ;", "assertFalse ( handler . getHandshakeInterceptors (  )  . isEmpty (  )  )  ;", "assertTrue (  (  ( handler . getHandshakeInterceptors (  )  . get (  0  )  )    instanceof   OriginHandshakeInterceptor )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["webSocketHandlers"], "fileName": "org.springframework.web.socket.config.HandlersBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - handlers - attributes . xml \"  )  ;", "HandlerMapping   handlerMapping    =    this . appContext . getBean ( HandlerMapping . class )  ;", "assertNotNull ( handlerMapping )  ;", "assertTrue (  ( handlerMapping   instanceof   SimpleUrlHandlerMapping )  )  ;", "SimpleUrlHandlerMapping   urlHandlerMapping    =     (  ( SimpleUrlHandlerMapping )     ( handlerMapping )  )  ;", "assertEquals (  2  ,    urlHandlerMapping . getOrder (  )  )  ;", "WebSocketHttpRequestHandler   handler    =     (  ( WebSocketHttpRequestHandler )     ( urlHandlerMapping . getUrlMap (  )  . get (  \"  / foo \"  )  )  )  ;", "assertNotNull ( handler )  ;", ". unwrapAndCheckDecoratedHandlerType ( handler . getWebSocketHandler (  )  ,    FooWebSocketHandler . class )  ;", "HandshakeHandler   handshakeHandler    =    handler . getHandshakeHandler (  )  ;", "assertNotNull ( handshakeHandler )  ;", "assertTrue (  ( handshakeHandler   instanceof   TestHandshakeHandler )  )  ;", "List < HandshakeInterceptor >    interceptors    =    handler . getHandshakeInterceptors (  )  ;", "assertThat ( interceptors ,    contains ( instanceOf ( FooTestInterceptor . class )  ,    instanceOf ( BarTestInterceptor . class )  ,    instanceOf ( OriginHandshakeInterceptor . class )  )  )  ;", "handler    =     (  ( WebSocketHttpRequestHandler )     ( urlHandlerMapping . getUrlMap (  )  . get (  \"  / test \"  )  )  )  ;", "assertNotNull ( handler )  ;", ". unwrapAndCheckDecoratedHandlerType ( handler . getWebSocketHandler (  )  ,    TestWebSocketHandler . class )  ;", "handshakeHandler    =    handler . getHandshakeHandler (  )  ;", "assertNotNull ( handshakeHandler )  ;", "assertTrue (  ( handshakeHandler   instanceof   TestHandshakeHandler )  )  ;", "interceptors    =    handler . getHandshakeInterceptors (  )  ;", "assertThat ( interceptors ,    contains ( instanceOf ( FooTestInterceptor . class )  ,    instanceOf ( BarTestInterceptor . class )  ,    instanceOf ( OriginHandshakeInterceptor . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["webSocketHandlersAttributes"], "fileName": "org.springframework.web.socket.config.HandlersBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "ManagedList < Object >    list    =    new   ManagedList (  )  ;", "list . setSource ( pContext . extractSource ( parentElement )  )  ;", "for    ( Element   beanElement    :    DomUtils . getChildElementsByTagName ( parentElement ,     \" bean \"  ,     \" ref \"  )  )     {", "Object   object    =    pContext . getDelegate (  )  . parsePropertySubElement ( beanElement ,    null )  ;", "list . add ( object )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["extractBeanSubElements"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( channelName . equals (  \" brokerChannel \"  )  )     {", "return   null ;", "}", "Root   executorDef    =    new   Root ( ThreadPoolTaskExecutor . class )  ;", "executorDef . getPropertyValues (  )  . add (  \" corePoolSize \"  ,     (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     2  )  )  ;", "executorDef . getPropertyValues (  )  . add (  \" maxPoolSize \"  ,    Integer . MAX _ VALUE )  ;", "executorDef . getPropertyValues (  )  . add (  \" queueCapacity \"  ,    Integer . MAX _ VALUE )  ;", "executorDef . getPropertyValues (  )  . add (  \" allowCoreThreadTimeOut \"  ,    true )  ;", "return   executorDef ;", "}", "METHOD_END"], "methodName": ["getDefaultExecutorBeanDefinition"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   executor ;", "if    ( element    =  =    null )     {", "executor    =    getDefaultExecutorBeanDefinition ( name )  ;", "} else    {", "Element   executorElem    =    DomUtils . getChildElementByTagName ( element ,     \" executor \"  )  ;", "if    ( executorElem    =  =    null )     {", "executor    =    getDefaultExecutorBeanDefinition ( name )  ;", "} else    {", "executor    =    new   RootBeanDefinition ( ThreadPoolTaskExecutor . class )  ;", "if    ( executorElem . hasAttribute (  \" core - pool - size \"  )  )     {", "executor . getPropertyValues (  )  . add (  \" corePoolSize \"  ,    executorElem . getAttribute (  \" core - pool - size \"  )  )  ;", "}", "if    ( executorElem . hasAttribute (  \" max - pool - size \"  )  )     {", "executor . getPropertyValues (  )  . add (  \" maxPoolSize \"  ,    executorElem . getAttribute (  \" max - pool - size \"  )  )  ;", "}", "if    ( executorElem . hasAttribute (  \" keep - alive - seconds \"  )  )     {", "executor . getPropertyValues (  )  . add (  \" keepAliveSeconds \"  ,    executorElem . getAttribute (  \" keep - alive - seconds \"  )  )  ;", "}", "if    ( executorElem . hasAttribute (  \" queue - capacity \"  )  )     {", "executor . getPropertyValues (  )  . add (  \" queueCapacity \"  ,    executorElem . getAttribute (  \" queue - capacity \"  )  )  ;", "}", "}", "}", "ConstructorArgumentValues   cargs    =    new   ConstructorArgumentValues (  )  ;", "if    ( executor    !  =    null )     {", "executor . getPropertyValues (  )  . add (  \" threadNamePrefix \"  ,     ( name    +     \"  -  \"  )  )  ;", "String   executorName    =    name    +     \" Executor \"  ;", ". registerBeanDefByName ( executorName ,    executor ,    context ,    source )  ;", "cargs . addIndexedArgumentValue (  0  ,    new   RuntimeBeanReference ( executorName )  )  ;", "}", "RootBeanDefinition   channelDef    =    new   RootBeanDefinition ( ExecutorSubscribableChannel . class ,    cargs ,    null )  ;", "ManagedList <  ?    super   Object >    interceptors    =    new   ManagedList (  )  ;", "if    ( element    !  =    null )     {", "Element   interceptorsElement    =    DomUtils . getChildElementByTagName ( element ,     \" interceptors \"  )  ;", "interceptors . addAll ( WebSocketNamespaceUtils . parseBeanSubElements ( interceptorsElement ,    context )  )  ;", "}", "interceptors . add ( new   ImmutableMessageChannelInterceptor (  )  )  ;", "channelDef . getPropertyValues (  )  . add (  \" interceptors \"  ,    interceptors )  ;", ". registerBeanDefByName ( name ,    channelDef ,    context ,    source )  ;", "return   new   RuntimeBeanReference ( name )  ;", "}", "METHOD_END"], "methodName": ["getMessageChannel"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( messageBrokerElement . hasAttribute (  \" validator \"  )  )     {", "return   new   RuntimeBeanReference ( messageBrokerElement . getAttribute (  \" validator \"  )  )  ;", "} else", "if    (  . javaxValidationPresent )     {", "RootBeanDefinition   validatorDef    =    new   RootBeanDefinition (  \" OptionalValidatorFactoryBean \"  )  ;", "validatorDef . setSource ( source )  ;", "validatorDef . setRole ( BeanDefinition . ROLE _ INFRASTRUCTURE )  ;", "String   validatorName    =    parserContext . getReaderContext (  )  . registerWithGeneratedName ( validatorDef )  ;", "parserContext . registerComponent ( new   BeanComponentDefinition ( validatorDef ,    validatorName )  )  ;", "return   new   RuntimeBeanReference ( validatorName )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getValidator"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "ConstructorArgumentValues   cargs    =    new   ConstructorArgumentValues (  )  ;", "cargs . addIndexedArgumentValue (  0  ,    inChannel )  ;", "cargs . addIndexedArgumentValue (  1  ,    outChannel )  ;", "cargs . addIndexedArgumentValue (  2  ,    messagingTemplate )  ;", "MutablePropertyValues   values    =    new   MutablePropertyValues (  )  ;", "String   prefixAttribute    =    messageBrokerElement . getAttribute (  \" application - destination - prefix \"  )  ;", "values . add (  \" destinationPrefixes \"  ,    Arrays . asList ( StringUtils . tokenizeToStringArray ( prefixAttribute ,     \"  ,  \"  )  )  )  ;", "values . add (  \" messageConverter \"  ,    converter )  ;", "RootBeanDefinition   beanDef    =    new   RootBeanDefinition ( WebSocketAnnotationMethodMessageHandler . class ,    cargs ,    values )  ;", "if    ( messageBrokerElement . hasAttribute (  \" path - matcher \"  )  )     {", "String   pathMatcherRef    =    messageBrokerElement . getAttribute (  \" path - matcher \"  )  ;", "beanDef . getPropertyValues (  )  . add (  \" pathMatcher \"  ,    new   RuntimeBeanReference ( pathMatcherRef )  )  ;", "}", "RuntimeBeanReference   validatorRef    =    getValidator ( messageBrokerElement ,    source ,    context )  ;", "if    ( validatorRef    !  =    null )     {", "beanDef . getPropertyValues (  )  . add (  \" validator \"  ,    validatorRef )  ;", "}", "Element   resolversElement    =    DomUtils . getChildElementByTagName ( messageBrokerElement ,     \" argument - resolvers \"  )  ;", "if    ( resolversElement    !  =    null )     {", "values . add (  \" customArgumentResolvers \"  ,    extractBeanSubElements ( resolversElement ,    context )  )  ;", "}", "Element   handlersElement    =    DomUtils . getChildElementByTagName ( messageBrokerElement ,     \" return - value - handlers \"  )  ;", "if    ( handlersElement    !  =    null )     {", "values . add (  \" customReturnValueHandlers \"  ,    extractBeanSubElements ( handlersElement ,    context )  )  ;", "}", ". registerBeanDef ( beanDef ,    context ,    source )  ;", "}", "METHOD_END"], "methodName": ["registerAnnotationMethodMessageHandler"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String   name    =    context . getReaderContext (  )  . generateBeanName ( beanDef )  ;", ". registerBeanDefByName ( name ,    beanDef ,    context ,    source )  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["registerBeanDef"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "beanDef . setSource ( source )  ;", "beanDef . setRole ( ROLE _ INFRASTRUCTURE )  ;", "context . getRegistry (  )  . registerBeanDefinition ( name ,    beanDef )  ;", "context . registerComponent ( new   beans . factory . parsing . BeanComponentDefinition ( beanDef ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefByName"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   handlerMappingDef    =    new   RootBeanDefinition ( WebSocketHandlerMapping . class )  ;", "String   orderAttribute    =    element . getAttribute (  \" order \"  )  ;", "int   order    =     ( orderAttribute . isEmpty (  )  )     ?     . DEFAULT _ MAPPING _ ORDER    :    Integer . valueOf ( orderAttribute )  ;", "handlerMappingDef . getPropertyValues (  )  . add (  \" order \"  ,    order )  ;", "String   pathHelper    =    element . getAttribute (  \" path - helper \"  )  ;", "if    ( StringUtils . hasText ( pathHelper )  )     {", "handlerMappingDef . getPropertyValues (  )  . add (  \" urlPathHelper \"  ,    new   RuntimeBeanReference ( pathHelper )  )  ;", "}", "ManagedMap < String ,    Object >    urlMap    =    new   ManagedMap (  )  ;", "urlMap . setSource ( source )  ;", "handlerMappingDef . getPropertyValues (  )  . add (  \" urlMap \"  ,    urlMap )  ;", ". registerBeanDef ( handlerMappingDef ,    context ,    source )  ;", "return   urlMap ;", "}", "METHOD_END"], "methodName": ["registerHandlerMapping"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "Element   simpleBrokerElem    =    DomUtils . getChildElementByTagName ( brokerElement ,     \" simple - broker \"  )  ;", "Element   brokerRelayElem    =    DomUtils . getChildElementByTagName ( brokerElement ,     \" stomp - broker - relay \"  )  ;", "ConstructorArgumentValues   cargs    =    new   ConstructorArgumentValues (  )  ;", "cargs . addIndexedArgumentValue (  0  ,    inChannel )  ;", "cargs . addIndexedArgumentValue (  1  ,    outChannel )  ;", "cargs . addIndexedArgumentValue (  2  ,    brokerChannel )  ;", "RootBeanDefinition   brokerDef ;", "if    ( simpleBrokerElem    !  =    null )     {", "String   prefix    =    simpleBrokerElem . getAttribute (  \" prefix \"  )  ;", "cargs . addIndexedArgumentValue (  3  ,    Arrays . asList ( StringUtils . tokenizeToStringArray ( prefix ,     \"  ,  \"  )  )  )  ;", "brokerDef    =    new   RootBeanDefinition ( SimpleBrokerMessageHandler . class ,    cargs ,    null )  ;", "if    ( brokerElement . hasAttribute (  \" path - matcher \"  )  )     {", "String   pathMatcherRef    =    brokerElement . getAttribute (  \" path - matcher \"  )  ;", "brokerDef . getPropertyValues (  )  . add (  \" pathMatcher \"  ,    new   RuntimeBeanReference ( pathMatcherRef )  )  ;", "}", "if    ( simpleBrokerElem . hasAttribute (  \" scheduler \"  )  )     {", "String   scheduler    =    simpleBrokerElem . getAttribute (  \" scheduler \"  )  ;", "brokerDef . getPropertyValues (  )  . add (  \" taskScheduler \"  ,    new   RuntimeBeanReference ( scheduler )  )  ;", "}", "if    ( simpleBrokerElem . hasAttribute (  \" heartbeat \"  )  )     {", "String   heartbeatValue    =    simpleBrokerElem . getAttribute (  \" heartbeat \"  )  ;", "brokerDef . getPropertyValues (  )  . add (  \" heartbeatValue \"  ,    heartbeatValue )  ;", "}", "if    ( simpleBrokerElem . hasAttribute (  \" selector - header \"  )  )     {", "String   headerName    =    simpleBrokerElem . getAttribute (  \" selector - header \"  )  ;", "brokerDef . getPropertyValues (  )  . add (  \" selectorHeaderName \"  ,    headerName )  ;", "}", "} else", "if    ( brokerRelayElem    !  =    null )     {", "String   prefix    =    brokerRelayElem . getAttribute (  \" prefix \"  )  ;", "cargs . addIndexedArgumentValue (  3  ,    Arrays . asList ( StringUtils . tokenizeToStringArray ( prefix ,     \"  ,  \"  )  )  )  ;", "MutablePropertyValues   values    =    new   MutablePropertyValues (  )  ;", "if    ( brokerRelayElem . hasAttribute (  \" relay - host \"  )  )     {", "values . add (  \" relayHost \"  ,    brokerRelayElem . getAttribute (  \" relay - host \"  )  )  ;", "}", "if    ( brokerRelayElem . hasAttribute (  \" relay - port \"  )  )     {", "values . add (  \" relayPort \"  ,    brokerRelayElem . getAttribute (  \" relay - port \"  )  )  ;", "}", "if    ( brokerRelayElem . hasAttribute (  \" client - login \"  )  )     {", "values . add (  \" clientLogin \"  ,    brokerRelayElem . getAttribute (  \" client - login \"  )  )  ;", "}", "if    ( brokerRelayElem . hasAttribute (  \" client - passcode \"  )  )     {", "values . add (  \" clientPasscode \"  ,    brokerRelayElem . getAttribute (  \" client - passcode \"  )  )  ;", "}", "if    ( brokerRelayElem . hasAttribute (  \" system - login \"  )  )     {", "values . add (  \" systemLogin \"  ,    brokerRelayElem . getAttribute (  \" system - login \"  )  )  ;", "}", "if    ( brokerRelayElem . hasAttribute (  \" system - passcode \"  )  )     {", "values . add (  \" systemPasscode \"  ,    brokerRelayElem . getAttribute (  \" system - passcode \"  )  )  ;", "}", "if    ( brokerRelayElem . hasAttribute (  \" heartbeat - send - interval \"  )  )     {", "values . add (  \" systemHeartbeatSendInterval \"  ,    brokerRelayElem . getAttribute (  \" heartbeat - send - interval \"  )  )  ;", "}", "if    ( brokerRelayElem . hasAttribute (  \" heartbeat - receive - interval \"  )  )     {", "values . add (  \" systemHeartbeatReceiveInterval \"  ,    brokerRelayElem . getAttribute (  \" heartbeat - receive - interval \"  )  )  ;", "}", "if    ( brokerRelayElem . hasAttribute (  \" virtual - host \"  )  )     {", "values . add (  \" virtualHost \"  ,    brokerRelayElem . getAttribute (  \" virtual - host \"  )  )  ;", "}", "ManagedMap < String ,    Object >    map    =    new   ManagedMap (  )  ;", "map . setSource ( source )  ;", "if    ( brokerRelayElem . hasAttribute (  \" user - destination - broadcast \"  )  )     {", "String   destination    =    brokerRelayElem . getAttribute (  \" user - destination - broadcast \"  )  ;", "map . put ( destination ,    userDestHandler )  ;", "}", "if    ( brokerRelayElem . hasAttribute (  \" user - registry - broadcast \"  )  )     {", "String   destination    =    brokerRelayElem . getAttribute (  \" user - registry - broadcast \"  )  ;", "map . put ( destination ,    registerUserRegistryMessageHandler ( userRegistry ,    brokerTemplate ,    destination ,    context ,    source )  )  ;", "}", "if    (  !  ( map . isEmpty (  )  )  )     {", "values . add (  \" systemSubscriptions \"  ,    map )  ;", "}", "Class <  ?  >    handlerType    =    class ;", "brokerDef    =    new   RootBeanDefinition ( handlerType ,    cargs ,    values )  ;", "} else    {", "throw   new   IllegalStateException (  \" Neither    < simple - broker >    nor    < stomp - broker - relay >    elements   found .  \"  )  ;", "}", ". registerBeanDef ( brokerDef ,    context ,    source )  ;", "return   brokerDef ;", "}", "METHOD_END"], "methodName": ["registerMessageBroker"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "Element   convertersElement    =    DomUtils . getChildElementByTagName ( element ,     \" message - converters \"  )  ;", "ManagedList <  ?    super   Object >    converters    =    new   ManagedList (  )  ;", "if    ( convertersElement    !  =    null )     {", "converters . setSource ( source )  ;", "for    ( Element   beanElement    :    DomUtils . getChildElementsByTagName ( convertersElement ,     \" bean \"  ,     \" ref \"  )  )     {", "Object   object    =    context . getDelegate (  )  . parsePropertySubElement ( beanElement ,    null )  ;", "converters . add ( object )  ;", "}", "}", "if    (  ( convertersElement    =  =    null )     |  |     ( Boolean . valueOf ( convertersElement . getAttribute (  \" register - defaults \"  )  )  )  )     {", "converters . setSource ( source )  ;", "converters . add ( new   RootBeanDefinition ( StringMessageConverter . class )  )  ;", "converters . add ( new   RootBeanDefinition ( ByteArrayMessageConverter . class )  )  ;", "if    (  . jackson 2 Present )     {", "RootBeanDefinition   jacksonConverterDef    =    new   RootBeanDefinition ( MappingJackson 2 MessageConverter . class )  ;", "RootBeanDefinition   resolverDef    =    new   RootBeanDefinition ( DefaultContentTypeResolver . class )  ;", "resolverDef . getPropertyValues (  )  . add (  \" defaultMimeType \"  ,    APPLICATION _ JSON )  ;", "jacksonConverterDef . getPropertyValues (  )  . add (  \" contentTypeResolver \"  ,    resolverDef )  ;", "GenericBeanDefinition   jacksonFactoryDef    =    new   GenericBeanDefinition (  )  ;", "jacksonFactoryDef . setBeanClass ( Jackson 2 ObjectMapperFactoryBean . class )  ;", "jacksonFactoryDef . setRole ( ROLE _ INFRASTRUCTURE )  ;", "jacksonFactoryDef . setSource ( source )  ;", "jacksonConverterDef . getPropertyValues (  )  . add (  \" objectMapper \"  ,    jacksonFactoryDef )  ;", "converters . add ( jacksonConverterDef )  ;", "}", "}", "ConstructorArgumentValues   cargs    =    new   ConstructorArgumentValues (  )  ;", "cargs . addIndexedArgumentValue (  0  ,    converters )  ;", "RootBeanDefinition   messageConverterDef    =    new   RootBeanDefinition ( CompositeMessageConverter . class ,    cargs ,    null )  ;", "String   name    =     . MESSAGE _ CONVERTER _ BEAN _ NAME ;", ". registerBeanDefByName ( name ,    messageConverterDef ,    context ,    source )  ;", "return   new   RuntimeBeanReference ( name )  ;", "}", "METHOD_END"], "methodName": ["registerMessageConverter"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "ConstructorArgumentValues   cargs    =    new   ConstructorArgumentValues (  )  ;", "cargs . addIndexedArgumentValue (  0  ,    brokerChannel )  ;", "RootBeanDefinition   beanDef    =    new   RootBeanDefinition ( SimpMessagingTemplate . class ,    cargs ,    null )  ;", "if    ( element . hasAttribute (  \" user - destination - prefix \"  )  )     {", "beanDef . getPropertyValues (  )  . add (  \" userDestinationPrefix \"  ,    element . getAttribute (  \" user - destination - prefix \"  )  )  ;", "}", "beanDef . getPropertyValues (  )  . add (  \" messageConverter \"  ,    messageConverter )  ;", "String   name    =     . MESSAGING _ TEMPLATE _ BEAN _ NAME ;", ". registerBeanDefByName ( name ,    beanDef ,    context ,    source )  ;", "return   new   RuntimeBeanReference ( name )  ;", "}", "METHOD_END"], "methodName": ["registerMessagingTemplate"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDef ;", "RuntimeBeanReference   sockJsService    =    WebSocketNamespaceUtils . registerSockJsService ( element ,     . SCHEDULER _ BEAN _ NAME ,    cxt ,    source )  ;", "if    ( sockJsService    !  =    null )     {", "ConstructorArgumentValues   cargs    =    new   ConstructorArgumentValues (  )  ;", "cargs . addIndexedArgumentValue (  0  ,    sockJsService )  ;", "cargs . addIndexedArgumentValue (  1  ,    subProtoHandler )  ;", "beanDef    =    new   RootBeanDefinition ( SockJsHttpRequestHandler . class ,    cargs ,    null )  ;", "cxt . getRegistry (  )  . registerAlias (  . SCHEDULER _ BEAN _ NAME ,     . SOCKJS _ SCHEDULER _ BEAN _ NAME )  ;", "} else    {", "RuntimeBeanReference   handler    =    WebSocketNamespaceUtils . registerHandshakeHandler ( element ,    cxt ,    source )  ;", "Element   interceptElem    =    DomUtils . getChildElementByTagName ( element ,     \" handshake - interceptors \"  )  ;", "ManagedList <  ?    super   Object >    interceptors    =    WebSocketNamespaceUtils . parseBeanSubElements ( interceptElem ,    cxt )  ;", "String   allowedOrigins    =    element . getAttribute (  \" allowed - origins \"  )  ;", "List < String >    origins    =    Arrays . asList ( StringUtils . tokenizeToStringArray ( allowedOrigins ,     \"  ,  \"  )  )  ;", "interceptors . add ( new   OriginHandshakeInterceptor ( origins )  )  ;", "ConstructorArgumentValues   cargs    =    new   ConstructorArgumentValues (  )  ;", "cargs . addIndexedArgumentValue (  0  ,    subProtoHandler )  ;", "cargs . addIndexedArgumentValue (  1  ,    handler )  ;", "beanDef    =    new   RootBeanDefinition ( WebSocketHttpRequestHandler . class ,    cargs ,    null )  ;", "beanDef . getPropertyValues (  )  . add (  \" handshakeInterceptors \"  ,    interceptors )  ;", "}", "return   new   RuntimeBeanReference (  . registerBeanDef ( beanDef ,    cxt ,    source )  )  ;", "}", "METHOD_END"], "methodName": ["registerRequestHandler"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   stompHandlerDef    =    new   RootBeanDefinition ( StompSubProtocolHandler . class )  ;", ". registerBeanDef ( stompHandlerDef ,    context ,    source )  ;", "Element   errorHandlerElem    =    DomUtils . getChildElementByTagName ( element ,     \" stomp - error - handler \"  )  ;", "if    ( errorHandlerElem    !  =    null )     {", "RuntimeBeanReference   errorHandlerRef    =    new   RuntimeBeanReference ( errorHandlerElem . getAttribute (  \" ref \"  )  )  ;", "stompHandlerDef . getPropertyValues (  )  . add (  \" errorHandler \"  ,    errorHandlerRef )  ;", "}", "ConstructorArgumentValues   cargs    =    new   ConstructorArgumentValues (  )  ;", "cargs . addIndexedArgumentValue (  0  ,    inChannel )  ;", "cargs . addIndexedArgumentValue (  1  ,    outChannel )  ;", "RootBeanDefinition   handlerDef    =    new   RootBeanDefinition ( SubProtocolWebSocketHandler . class ,    cargs ,    null )  ;", "handlerDef . getPropertyValues (  )  . addPropertyValue (  \" protocolHandlers \"  ,    stompHandlerDef )  ;", ". registerBeanDefByName (  . WEB _ SOCKET _ HANDLER _ BEAN _ NAME ,    handlerDef ,    context ,    source )  ;", "RuntimeBeanReference   result    =    new   RuntimeBeanReference (  . WEB _ SOCKET _ HANDLER _ BEAN _ NAME )  ;", "Element   transportElem    =    DomUtils . getChildElementByTagName ( element ,     \" transport \"  )  ;", "if    ( transportElem    !  =    null )     {", "if    ( transportElem . hasAttribute (  \" message - size \"  )  )     {", "stompHandlerDef . getPropertyValues (  )  . add (  \" messageSizeLimit \"  ,    transportElem . getAttribute (  \" message - size \"  )  )  ;", "}", "if    ( transportElem . hasAttribute (  \" send - timeout \"  )  )     {", "handlerDef . getPropertyValues (  )  . add (  \" sendTimeLimit \"  ,    transportElem . getAttribute (  \" send - timeout \"  )  )  ;", "}", "if    ( transportElem . hasAttribute (  \" send - buffer - size \"  )  )     {", "handlerDef . getPropertyValues (  )  . add (  \" sendBufferSizeLimit \"  ,    transportElem . getAttribute (  \" send - buffer - size \"  )  )  ;", "}", "Element   factoriesElement    =    DomUtils . getChildElementByTagName ( transportElem ,     \" decorator - factories \"  )  ;", "if    ( factoriesElement    !  =    null )     {", "ManagedList < Object >    factories    =    extractBeanSubElements ( factoriesElement ,    context )  ;", "RootBeanDefinition   factoryBean    =    new   RootBeanDefinition (  . DecoratingFactoryBean . class )  ;", "factoryBean . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  0  ,    result )  ;", "factoryBean . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    factories )  ;", "result    =    new   RuntimeBeanReference (  . registerBeanDef ( factoryBean ,    context ,    source )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["registerStompHandler"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "Object   userDestResolver    =    registerUserDestResolver ( brokerElem ,    userRegistry ,    context ,    source )  ;", "RootBeanDefinition   beanDef    =    new   RootBeanDefinition ( UserDestinationMessageHandler . class )  ;", "beanDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  0  ,    inChannel )  ;", "beanDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    brokerChannel )  ;", "beanDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  2  ,    userDestResolver )  ;", "Element   relayElement    =    DomUtils . getChildElementByTagName ( brokerElem ,     \" stomp - broker - relay \"  )  ;", "if    (  ( relayElement    !  =    null )     &  &     ( relayElement . hasAttribute (  \" user - destination - broadcast \"  )  )  )     {", "String   destination    =    relayElement . getAttribute (  \" user - destination - broadcast \"  )  ;", "beanDef . getPropertyValues (  )  . add (  \" broadcastDestination \"  ,    destination )  ;", "}", "String   beanName    =     . registerBeanDef ( beanDef ,    context ,    source )  ;", "return   new   RuntimeBeanReference ( beanName )  ;", "}", "METHOD_END"], "methodName": ["registerUserDestHandler"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDef    =    new   RootBeanDefinition ( DefaultUserDestinationResolver . class )  ;", "beanDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  0  ,    userRegistry )  ;", "if    ( brokerElem . hasAttribute (  \" user - destination - prefix \"  )  )     {", "beanDef . getPropertyValues (  )  . add (  \" userDestinationPrefix \"  ,    brokerElem . getAttribute (  \" user - destination - prefix \"  )  )  ;", "}", "if    ( brokerElem . hasAttribute (  \" path - matcher \"  )  )     {", "String   pathMatcherRef    =    brokerElem . getAttribute (  \" path - matcher \"  )  ;", "beanDef . getPropertyValues (  )  . add (  \" pathMatcher \"  ,    new   RuntimeBeanReference ( pathMatcherRef )  )  ;", "}", "return   new   RuntimeBeanReference (  . registerBeanDef ( beanDef ,    context ,    source )  )  ;", "}", "METHOD_END"], "methodName": ["registerUserDestResolver"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "Element   relayElement    =    DomUtils . getChildElementByTagName ( element ,     \" stomp - broker - relay \"  )  ;", "boolean   multiServer    =     ( relayElement    !  =    null )     &  &     ( relayElement . hasAttribute (  \" user - registry - broadcast \"  )  )  ;", "if    ( multiServer )     {", "RootBeanDefinition   localRegistryBeanDef    =    new   RootBeanDefinition ( DefaultSimpUserRegistry . class )  ;", "RootBeanDefinition   beanDef    =    new   RootBeanDefinition ( MultiServerUserRegistry . class )  ;", "beanDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  0  ,    localRegistryBeanDef )  ;", "String   beanName    =     . registerBeanDef ( beanDef ,    context ,    source )  ;", "return   new   RuntimeBeanReference ( beanName )  ;", "} else    {", "RootBeanDefinition   beanDef    =    new   RootBeanDefinition ( DefaultSimpUserRegistry . class )  ;", "String   beanName    =     . registerBeanDef ( beanDef ,    context ,    source )  ;", "return   new   RuntimeBeanReference ( beanName )  ;", "}", "}", "METHOD_END"], "methodName": ["registerUserRegistry"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "Object   scheduler    =    WebSocketNamespaceUtils . registerScheduler ( MessageBrokerBeanDefinitionParser . SCHEDULER _ BEAN _ NAME ,    context ,    source )  ;", "RootBeanDefinition   beanDef    =    new   RootBeanDefinition ( UserRegistryMessageHandler . class )  ;", "beanDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  0  ,    userRegistry )  ;", "beanDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    brokerTemplate )  ;", "beanDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  2  ,    destination )  ;", "beanDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  3  ,    scheduler )  ;", "String   beanName    =    MessageBrokerBeanDefinitionParser . registerBeanDef ( beanDef ,    context ,    source )  ;", "return   new   RuntimeBeanReference ( beanName )  ;", "}", "METHOD_END"], "methodName": ["registerUserRegistryMessageHandler"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDef    =    new   RootBeanDefinition ( WebSocketMessageBrokerStats . class )  ;", "RuntimeBeanReference   webSocketHandler    =    new   RuntimeBeanReference (  . WEB _ SOCKET _ HANDLER _ BEAN _ NAME )  ;", "beanDef . getPropertyValues (  )  . add (  \" subProtocolWebSocketHandler \"  ,    webSocketHandler )  ;", "if    (  ( StompBrokerRelayMessageHandler . class )     =  =     ( broker . getBeanClass (  )  )  )     {", "beanDef . getPropertyValues (  )  . add (  \" stompBrokerRelay \"  ,    broker )  ;", "}", "String   name    =     ( inChannel . getBeanName (  )  )     +     \" Executor \"  ;", "if    ( context . getRegistry (  )  . containsBeanDefinition ( name )  )     {", "beanDef . getPropertyValues (  )  . add (  \" inboundChannelExecutor \"  ,    context . getRegistry (  )  . getBeanDefinition ( name )  )  ;", "}", "name    =     ( outChannel . getBeanName (  )  )     +     \" Executor \"  ;", "if    ( context . getRegistry (  )  . containsBeanDefinition ( name )  )     {", "beanDef . getPropertyValues (  )  . add (  \" outboundChannelExecutor \"  ,    context . getRegistry (  )  . getBeanDefinition ( name )  )  ;", "}", "Object   scheduler    =    WebSocketNamespaceUtils . registerScheduler (  . SCHEDULER _ BEAN _ NAME ,    context ,    source )  ;", "beanDef . getPropertyValues (  )  . add (  \" sockJsTaskScheduler \"  ,    scheduler )  ;", ". registerBeanDefByName (  \" webSocketMessageBrokerStats \"  ,    beanDef ,    context ,    source )  ;", "}", "METHOD_END"], "methodName": ["registerWebSocketMessageBrokerStats"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - broker - simple . xml \"  )  ;", "SimpAnnotationMethodMessageHandler   annotationMethodMessageHandler    =    this . appContext . getBean ( SimpAnnotationMethodMessageHandler . class )  ;", "assertNotNull ( annotationMethodMessageHandler )  ;", "MessageConverter   messageConverter    =    annotationMethodMessageHandler . getMessageConverter (  )  ;", "assertNotNull ( messageConverter )  ;", "assertTrue (  ( messageConverter   instanceof   CompositeMessageConverter )  )  ;", "String   name    =     . MESSAGE _ CONVERTER _ BEAN _ NAME ;", "CompositeMessageConverter   compositeMessageConverter    =    this . appContext . getBean ( name ,    CompositeMessageConverter . class )  ;", "assertNotNull ( compositeMessageConverter )  ;", "name    =     . MESSAGING _ TEMPLATE _ BEAN _ NAME ;", "SimpMessagingTemplate   simpMessagingTemplate    =    this . appContext . getBean ( name ,    SimpMessagingTemplate . class )  ;", "assertNotNull ( simpMessagingTemplate )  ;", "assertEquals (  \"  / personal /  \"  ,    simpMessagingTemplate . getUserDestinationPrefix (  )  )  ;", "List < MessageConverter >    converters    =    compositeMessageConverter . getConverters (  )  ;", "assertThat ( converters . size (  )  ,    Matchers . is (  3  )  )  ;", "assertThat ( converters . get (  0  )  ,    Matchers . instanceOf ( StringMessageConverter . class )  )  ;", "assertThat ( converters . get (  1  )  ,    Matchers . instanceOf ( ByteArrayMessageConverter . class )  )  ;", "assertThat ( converters . get (  2  )  ,    Matchers . instanceOf ( MappingJackson 2 MessageConverter . class )  )  ;", "ContentTypeResolver   resolver    =     (  ( MappingJackson 2 MessageConverter )     ( converters . get (  2  )  )  )  . getContentTypeResolver (  )  ;", "assertEquals ( APPLICATION _ JSON ,     (  ( DefaultContentTypeResolver )     ( resolver )  )  . getDefaultMimeType (  )  )  ;", "DirectFieldAccessor   handlerAccessor    =    new   DirectFieldAccessor ( annotationMethodMessageHandler )  ;", "Object   pathMatcher    =    handlerAccessor . getPropertyValue (  \" pathMatcher \"  )  ;", "String   pathSeparator    =     (  ( String )     ( new   DirectFieldAccessor ( pathMatcher )  . getPropertyValue (  \" pathSeparator \"  )  )  )  ;", "assertEquals (  \"  .  \"  ,    pathSeparator )  ;", "}", "METHOD_END"], "methodName": ["annotationMethodMessageHandler"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - broker - custom - argument - and - return - value - types . xml \"  )  ;", "SimpAnnotationMethodMessageHandler   handler    =    this . appContext . getBean ( SimpAnnotationMethodMessageHandler . class )  ;", "List < HandlerMethodArgumentResolver >    customResolvers    =    handler . getCustomArgumentResolvers (  )  ;", "assertEquals (  2  ,    customResolvers . size (  )  )  ;", "assertTrue ( handler . getArgumentResolvers (  )  . contains ( customResolvers . get (  0  )  )  )  ;", "assertTrue ( handler . getArgumentResolvers (  )  . contains ( customResolvers . get (  1  )  )  )  ;", "List < HandlerMethodReturnValueHandler >    customHandlers    =    handler . getCustomReturnValueHandlers (  )  ;", "assertEquals (  2  ,    customHandlers . size (  )  )  ;", "assertTrue ( handler . getReturnValueHandlers (  )  . contains ( customHandlers . get (  0  )  )  )  ;", "assertTrue ( handler . getReturnValueHandlers (  )  . contains ( customHandlers . get (  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["customArgumentAndReturnValueTypes"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - broker - customchannels . xml \"  )  ;", "SimpAnnotationMethodMessageHandler   annotationMethodMessageHandler    =    this . appContext . getBean ( SimpAnnotationMethodMessageHandler . class )  ;", "Validator   validator    =    annotationMethodMessageHandler . getValidator (  )  ;", "assertNotNull ( validator )  ;", "assertSame ( this . appContext . getBean (  \" myValidator \"  )  ,    validator )  ;", "assertThat ( validator ,    Matchers . instanceOf ( TestValidator . class )  )  ;", "List < Class <  ?    extends   MessageHandler >  >    subscriberTypes    =    Arrays .  < Class <  ?    extends   MessageHandler >  > asList ( SimpAnnotationMethodMessageHandler . class ,    UserDestinationMessageHandler . class ,    SimpleBrokerMessageHandler . class )  ;", "testChannel (  \" clientInboundChannel \"  ,    subscriberTypes ,     3  )  ;", "testExecutor (  \" clientInboundChannel \"  ,     1  0  0  ,     2  0  0  ,     6  0  0  )  ;", "subscriberTypes    =    Collections . singletonList ( SubProtocolWebSocketHandler . class )  ;", "testChannel (  \" clientOutboundChannel \"  ,    subscriberTypes ,     3  )  ;", "testExecutor (  \" clientOutboundChannel \"  ,     1  0  1  ,     2  0  1  ,     6  0  1  )  ;", "subscriberTypes    =    Arrays .  < Class <  ?    extends   MessageHandler >  > asList ( SimpleBrokerMessageHandler . class ,    UserDestinationMessageHandler . class )  ;", "testChannel (  \" brokerChannel \"  ,    subscriberTypes ,     1  )  ;", "testExecutor (  \" brokerChannel \"  ,     1  0  2  ,     2  0  2  ,     6  0  2  )  ;", "}", "METHOD_END"], "methodName": ["customChannels"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - broker - customchannels - default - executor . xml \"  )  ;", "testExecutor (  \" clientInboundChannel \"  ,     (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     2  )  ,    Integer . MAX _ VALUE ,     6  0  )  ;", "testExecutor (  \" clientOutboundChannel \"  ,     (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     2  )  ,    Integer . MAX _ VALUE ,     6  0  )  ;", "assertFalse ( this . appContext . containsBean (  \" brokerChannelExecutor \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customChannelsWithDefaultExecutor"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . appContext )  ;", "ClassPathResource   resource    =    new   ClassPathResource ( fileName ,     . class )  ;", "reader . loadBeanDefinitions ( resource )  ;", "this . appContext . setServletContext ( new   MockServletContext (  )  )  ;", "this . appContext . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - broker - converters . xml \"  )  ;", "CompositeMessageConverter   compositeConverter    =    this . appContext . getBean ( CompositeMessageConverter . class )  ;", "assertNotNull ( compositeConverter )  ;", "assertEquals (  4  ,    compositeConverter . getConverters (  )  . size (  )  )  ;", "assertEquals ( StringMessageConverter . class ,    compositeConverter . getConverters (  )  . iterator (  )  . next (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["messageConverters"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - broker - converters - defaults - off . xml \"  )  ;", "CompositeMessageConverter   compositeConverter    =    this . appContext . getBean ( CompositeMessageConverter . class )  ;", "assertNotNull ( compositeConverter )  ;", "assertEquals (  1  ,    compositeConverter . getConverters (  )  . size (  )  )  ;", "assertEquals ( StringMessageConverter . class ,    compositeConverter . getConverters (  )  . iterator (  )  . next (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["messageConvertersDefaultsOff"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - broker - simple . xml \"  )  ;", "HandlerMapping   hm    =    this . appContext . getBean ( HandlerMapping . class )  ;", "assertThat ( hm ,    Matchers . instanceOf ( SimpleUrlHandlerMapping . class )  )  ;", "SimpleUrlHandlerMapping   suhm    =     (  ( SimpleUrlHandlerMapping )     ( hm )  )  ;", "assertThat ( suhm . getUrlMap (  )  . keySet (  )  ,    Matchers . hasSize (  4  )  )  ;", "assertThat ( suhm . getUrlMap (  )  . values (  )  ,    Matchers . hasSize (  4  )  )  ;", "HttpRequestHandler   httpRequestHandler    =     (  ( HttpRequestHandler )     ( suhm . getUrlMap (  )  . get (  \"  / foo \"  )  )  )  ;", "assertNotNull ( httpRequestHandler )  ;", "assertThat ( httpRequestHandler ,    Matchers . instanceOf ( WebSocketHttpRequestHandler . class )  )  ;", "WebSocketHttpRequestHandler   wsHttpRequestHandler    =     (  ( WebSocketHttpRequestHandler )     ( httpRequestHandler )  )  ;", "HandshakeHandler   handshakeHandler    =    wsHttpRequestHandler . getHandshakeHandler (  )  ;", "assertNotNull ( handshakeHandler )  ;", "assertTrue (  ( handshakeHandler   instanceof   TestHandshakeHandler )  )  ;", "List < HandshakeInterceptor >    interceptors    =    wsHttpRequestHandler . getHandshakeInterceptors (  )  ;", "assertThat ( interceptors ,    contains ( instanceOf ( FooTestInterceptor . class )  ,    instanceOf ( BarTestInterceptor . class )  ,    instanceOf ( OriginHandshakeInterceptor . class )  )  )  ;", "WebSocketSession   session    =    new   TestWebSocketSession (  \" id \"  )  ;", "wsHttpRequestHandler . getWebSocketHandler (  )  . afterConnectionEstablished ( session )  ;", "assertEquals ( true ,    session . getAttributes (  )  . get (  \" decorated \"  )  )  ;", "WebSocketHandler   wsHandler    =    wsHttpRequestHandler . getWebSocketHandler (  )  ;", "assertThat ( wsHandler ,    Matchers . instanceOf ( ExceptionWebSocketHandlerDecorator . class )  )  ;", "wsHandler    =     (  ( ExceptionWebSocketHandlerDecorator )     ( wsHandler )  )  . getDelegate (  )  ;", "assertThat ( wsHandler ,    Matchers . instanceOf ( LoggingWebSocketHandlerDecorator . class )  )  ;", "wsHandler    =     (  ( LoggingWebSocketHandlerDecorator )     ( wsHandler )  )  . getDelegate (  )  ;", "assertThat ( wsHandler ,    Matchers . instanceOf ( TestWebSocketHandlerDecorator . class )  )  ;", "wsHandler    =     (  ( TestWebSocketHandlerDecorator )     ( wsHandler )  )  . getDelegate (  )  ;", "assertThat ( wsHandler ,    Matchers . instanceOf ( SubProtocolWebSocketHandler . class )  )  ;", "assertSame ( wsHandler ,    this . appContext . getBean (  . WEB _ SOCKET _ HANDLER _ BEAN _ NAME )  )  ;", "SubProtocolWebSocketHandler   subProtocolWsHandler    =     (  ( SubProtocolWebSocketHandler )     ( wsHandler )  )  ;", "assertEquals ( Arrays . asList (  \" v 1  0  . stomp \"  ,     \" v 1  1  . stomp \"  ,     \" v 1  2  . stomp \"  )  ,    subProtocolWsHandler . getSubProtocols (  )  )  ;", "assertEquals (  (  2  5     *     1  0  0  0  )  ,    subProtocolWsHandler . getSendTimeLimit (  )  )  ;", "assertEquals (  (  1  0  2  4     *     1  0  2  4  )  ,    subProtocolWsHandler . getSendBufferSizeLimit (  )  )  ;", "Map < String ,    SubProtocolHandler >    handlerMap    =    subProtocolWsHandler . getProtocolHandlerMap (  )  ;", "StompSubProtocolHandler   stompHandler    =     (  ( StompSubProtocolHandler )     ( handlerMap . get (  \" v 1  2  . stomp \"  )  )  )  ;", "assertNotNull ( stompHandler )  ;", "assertEquals (  (  1  2  8     *     1  0  2  4  )  ,    stompHandler . getMessageSizeLimit (  )  )  ;", "assertNotNull ( stompHandler . getErrorHandler (  )  )  ;", "assertEquals ( TestStompErrorHandler . class ,    stompHandler . getErrorHandler (  )  . getClass (  )  )  ;", "assertNotNull ( new   DirectFieldAccessor ( stompHandler )  . getPropertyValue (  \" eventPublisher \"  )  )  ;", "httpRequestHandler    =     (  ( HttpRequestHandler )     ( suhm . getUrlMap (  )  . get (  \"  / test /  *  *  \"  )  )  )  ;", "assertNotNull ( httpRequestHandler )  ;", "assertThat ( httpRequestHandler ,    Matchers . instanceOf ( SockJsHttpRequestHandler . class )  )  ;", "SockJsHttpRequestHandler   sockJsHttpRequestHandler    =     (  ( SockJsHttpRequestHandler )     ( httpRequestHandler )  )  ;", "wsHandler    =    unwrapWebSocketHandler ( sockJsHttpRequestHandler . getWebSocketHandler (  )  )  ;", "assertNotNull ( wsHandler )  ;", "assertThat ( wsHandler ,    Matchers . instanceOf ( SubProtocolWebSocketHandler . class )  )  ;", "assertNotNull ( sockJsHttpRequestHandler . getSockJsService (  )  )  ;", "assertThat ( sockJsHttpRequestHandler . getSockJsService (  )  ,    Matchers . instanceOf ( DefaultSockJsService . class )  )  ;", "DefaultSockJsService   defaultSockJsService    =     (  ( DefaultSockJsService )     ( sockJsHttpRequestHandler . getSockJsService (  )  )  )  ;", "WebSocketTransportHandler   wsTransportHandler    =     (  ( WebSocketTransportHandler )     ( defaultSockJsService . getTransportHandlers (  )  . get ( TransportType . WEBSOCKET )  )  )  ;", "assertNotNull ( wsTransportHandler . getHandshakeHandler (  )  )  ;", "assertThat ( wsTransportHandler . getHandshakeHandler (  )  ,    Matchers . instanceOf ( TestHandshakeHandler . class )  )  ;", "assertFalse ( defaultSockJsService . shouldSuppressCors (  )  )  ;", "ThreadPoolTaskScheduler   scheduler    =     (  ( ThreadPoolTaskScheduler )     ( defaultSockJsService . getTaskScheduler (  )  )  )  ;", "ScheduledThreadPoolExecutor   executor    =    scheduler . getScheduledThreadPoolExecutor (  )  ;", "assertEquals ( Runtime . getRuntime (  )  . availableProcessors (  )  ,    executor . getCorePoolSize (  )  )  ;", "assertTrue ( executor . getRemoveOnCancelPolicy (  )  )  ;", "interceptors    =    defaultSockJsService . getHandshakeInterceptors (  )  ;", "assertThat ( interceptors ,    contains ( instanceOf ( FooTestInterceptor . class )  ,    instanceOf ( BarTestInterceptor . class )  ,    instanceOf ( OriginHandshakeInterceptor . class )  )  )  ;", "assertTrue ( defaultSockJsService . getAllowedOrigins (  )  . contains (  \" http :  /  / mydomain 3  . com \"  )  )  ;", "assertTrue ( defaultSockJsService . getAllowedOrigins (  )  . contains (  \" http :  /  / mydomain 4  . com \"  )  )  ;", "SimpUserRegistry   userRegistry    =    this . appContext . getBean ( SimpUserRegistry . class )  ;", "assertNotNull ( userRegistry )  ;", "assertEquals ( DefaultSimpUserRegistry . class ,    userRegistry . getClass (  )  )  ;", "UserDestinationResolver   userDestResolver    =    this . appContext . getBean ( UserDestinationResolver . class )  ;", "assertNotNull ( userDestResolver )  ;", "assertThat ( userDestResolver ,    Matchers . instanceOf ( DefaultUserDestinationResolver . class )  )  ;", "DefaultUserDestinationResolver   defaultUserDestResolver    =     (  ( DefaultUserDestinationResolver )     ( userDestResolver )  )  ;", "assertEquals (  \"  / personal /  \"  ,    defaultUserDestResolver . getDestinationPrefix (  )  )  ;", "UserDestinationMessageHandler   userDestHandler    =    this . appContext . getBean ( UserDestinationMessageHandler . class )  ;", "assertNotNull ( userDestHandler )  ;", "SimpleBrokerMessageHandler   brokerMessageHandler    =    this . appContext . getBean ( SimpleBrokerMessageHandler . class )  ;", "assertNotNull ( brokerMessageHandler )  ;", "Collection < String >    prefixes    =    brokerMessageHandler . getDestinationPrefixes (  )  ;", "assertEquals ( Arrays . asList (  \"  / topic \"  ,     \"  / queue \"  )  ,    new   ArrayList ( prefixes )  )  ;", "DefaultSubscriptionRegistry   registry    =     (  ( DefaultSubscriptionRegistry )     ( brokerMessageHandler . getSubscriptionRegistry (  )  )  )  ;", "assertEquals (  \" my - selector \"  ,    registry . getSelectorHeaderName (  )  )  ;", "assertNotNull ( brokerMessageHandler . getTaskScheduler (  )  )  ;", "assertArrayEquals ( new   long [  ]  {     1  5  0  0  0  ,     1  5  0  0  0     }  ,    brokerMessageHandler . getHeartbeatValue (  )  )  ;", "List < Class <  ?    extends   MessageHandler >  >    subscriberTypes    =    Arrays .  < Class <  ?    extends   MessageHandler >  > asList ( SimpAnnotationMethodMessageHandler . class ,    UserDestinationMessageHandler . class ,    SimpleBrokerMessageHandler . class )  ;", "testChannel (  \" clientInboundChannel \"  ,    subscriberTypes ,     2  )  ;", "testExecutor (  \" clientInboundChannel \"  ,     (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     2  )  ,    Integer . MAX _ VALUE ,     6  0  )  ;", "subscriberTypes    =    Collections . singletonList ( SubProtocolWebSocketHandler . class )  ;", "testChannel (  \" clientOutboundChannel \"  ,    subscriberTypes ,     1  )  ;", "testExecutor (  \" clientOutboundChannel \"  ,     (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     2  )  ,    Integer . MAX _ VALUE ,     6  0  )  ;", "subscriberTypes    =    Arrays .  < Class <  ?    extends   MessageHandler >  > asList ( SimpleBrokerMessageHandler . class ,    UserDestinationMessageHandler . class )  ;", "testChannel (  \" brokerChannel \"  ,    subscriberTypes ,     1  )  ;", "try    {", "this . appContext . getBean (  \" brokerChannelExecutor \"  ,    ThreadPoolTaskExecutor . class )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "assertNotNull ( this . appContext . getBean (  \" webSocketScopeConfigurer \"  ,    CustomScopeConfigurer . class )  )  ;", "DirectFieldAccessor   accessor    =    new   DirectFieldAccessor ( registry )  ;", "Object   pathMatcher    =    accessor . getPropertyValue (  \" pathMatcher \"  )  ;", "String   pathSeparator    =     (  ( String )     ( new   DirectFieldAccessor ( pathMatcher )  . getPropertyValue (  \" pathSeparator \"  )  )  )  ;", "assertEquals (  \"  .  \"  ,    pathSeparator )  ;", "}", "METHOD_END"], "methodName": ["simpleBroker"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions (  \" websocket - config - broker - relay . xml \"  )  ;", "HandlerMapping   hm    =    this . appContext . getBean ( HandlerMapping . class )  ;", "assertNotNull ( hm )  ;", "assertThat ( hm ,    Matchers . instanceOf ( SimpleUrlHandlerMapping . class )  )  ;", "SimpleUrlHandlerMapping   suhm    =     (  ( SimpleUrlHandlerMapping )     ( hm )  )  ;", "assertThat ( suhm . getUrlMap (  )  . keySet (  )  ,    Matchers . hasSize (  1  )  )  ;", "assertThat ( suhm . getUrlMap (  )  . values (  )  ,    Matchers . hasSize (  1  )  )  ;", "assertEquals (  2  ,    suhm . getOrder (  )  )  ;", "HttpRequestHandler   httpRequestHandler    =     (  ( HttpRequestHandler )     ( suhm . getUrlMap (  )  . get (  \"  / foo /  *  *  \"  )  )  )  ;", "assertNotNull ( httpRequestHandler )  ;", "assertThat ( httpRequestHandler ,    Matchers . instanceOf ( SockJsHttpRequestHandler . class )  )  ;", "SockJsHttpRequestHandler   sockJsHttpRequestHandler    =     (  ( SockJsHttpRequestHandler )     ( httpRequestHandler )  )  ;", "WebSocketHandler   wsHandler    =    unwrapWebSocketHandler ( sockJsHttpRequestHandler . getWebSocketHandler (  )  )  ;", "assertNotNull ( wsHandler )  ;", "assertThat ( wsHandler ,    Matchers . instanceOf ( SubProtocolWebSocketHandler . class )  )  ;", "assertNotNull ( sockJsHttpRequestHandler . getSockJsService (  )  )  ;", "UserDestinationResolver   userDestResolver    =    this . appContext . getBean ( UserDestinationResolver . class )  ;", "assertNotNull ( userDestResolver )  ;", "assertThat ( userDestResolver ,    Matchers . instanceOf ( DefaultUserDestinationResolver . class )  )  ;", "DefaultUserDestinationResolver   defaultUserDestResolver    =     (  ( DefaultUserDestinationResolver )     ( userDestResolver )  )  ;", "assertEquals (  \"  / user /  \"  ,    defaultUserDestResolver . getDestinationPrefix (  )  )  ;", "StompBrokerRelayMessageHandler   messageBroker    =    this . appContext . getBean ( StompBrokerRelayMessageHandler . class )  ;", "assertNotNull ( messageBroker )  ;", "assertEquals (  \" clientlogin \"  ,    messageBroker . getClientLogin (  )  )  ;", "assertEquals (  \" clientpass \"  ,    messageBroker . getClientPasscode (  )  )  ;", "assertEquals (  \" syslogin \"  ,    messageBroker . getSystemLogin (  )  )  ;", "assertEquals (  \" syspass \"  ,    messageBroker . getSystemPasscode (  )  )  ;", "assertEquals (  \" relayhost \"  ,    messageBroker . getRelayHost (  )  )  ;", "assertEquals (  1  2  3  4  ,    messageBroker . getRelayPort (  )  )  ;", "assertEquals (  \" spring . io \"  ,    messageBroker . getVirtualHost (  )  )  ;", "assertEquals (  5  0  0  0  ,    messageBroker . getSystemHeartbeatReceiveInterval (  )  )  ;", "assertEquals (  5  0  0  0  ,    messageBroker . getSystemHeartbeatSendInterval (  )  )  ;", "assertThat ( messageBroker . getDestinationPrefixes (  )  ,    Matchers . containsInAnyOrder (  \"  / topic \"  ,     \"  / queue \"  )  )  ;", "List < Class <  ?    extends   MessageHandler >  >    subscriberTypes    =    Arrays .  < Class <  ?    extends   MessageHandler >  > asList ( SimpAnnotationMethodMessageHandler . class ,    UserDestinationMessageHandler . class ,    StompBrokerRelayMessageHandler . class )  ;", "testChannel (  \" clientInboundChannel \"  ,    subscriberTypes ,     2  )  ;", "testExecutor (  \" clientInboundChannel \"  ,     (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     2  )  ,    Integer . MAX _ VALUE ,     6  0  )  ;", "subscriberTypes    =    Collections . singletonList ( SubProtocolWebSocketHandler . class )  ;", "testChannel (  \" clientOutboundChannel \"  ,    subscriberTypes ,     1  )  ;", "testExecutor (  \" clientOutboundChannel \"  ,     (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     2  )  ,    Integer . MAX _ VALUE ,     6  0  )  ;", "subscriberTypes    =    Arrays .  < Class <  ?    extends   MessageHandler >  > asList ( StompBrokerRelayMessageHandler . class ,    UserDestinationMessageHandler . class )  ;", "testChannel (  \" brokerChannel \"  ,    subscriberTypes ,     1  )  ;", "try    {", "this . appContext . getBean (  \" brokerChannelExecutor \"  ,    ThreadPoolTaskExecutor . class )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "String   destination    =     \"  / topic / unresolved - user - destination \"  ;", "UserDestinationMessageHandler   userDestHandler    =    this . appContext . getBean ( UserDestinationMessageHandler . class )  ;", "assertEquals ( destination ,    userDestHandler . getBroadcastDestination (  )  )  ;", "assertNotNull ( messageBroker . getSystemSubscriptions (  )  )  ;", "assertSame ( userDestHandler ,    messageBroker . getSystemSubscriptions (  )  . get ( destination )  )  ;", "destination    =     \"  / topic / simp - user - registry \"  ;", "UserRegistryMessageHandler   userRegistryHandler    =    this . appContext . getBean ( UserRegistryMessageHandler . class )  ;", "assertEquals ( destination ,    userRegistryHandler . getBroadcastDestination (  )  )  ;", "assertNotNull ( messageBroker . getSystemSubscriptions (  )  )  ;", "assertSame ( userRegistryHandler ,    messageBroker . getSystemSubscriptions (  )  . get ( destination )  )  ;", "SimpUserRegistry   userRegistry    =    this . appContext . getBean ( SimpUserRegistry . class )  ;", "assertEquals ( MultiServerUserRegistry . class ,    userRegistry . getClass (  )  )  ;", "String   name    =     \" webSocketMessageBrokerStats \"  ;", "WebSocketMessageBrokerStats   stats    =    this . appContext . getBean ( name ,    WebSocketMessageBrokerStats . class )  ;", "String   actual    =    stats . toString (  )  ;", "String   expected    =     \" WebSocketSession \\  \\  [  0    current   WS \\  \\  (  0  \\  \\  )  - HttpStream \\  \\  (  0  \\  \\  )  - HttpPoll \\  \\  (  0  \\  \\  )  ,     \"     +     (  (  (  (  (  (  (  (  (  \"  0    total ,     0    closed   abnormally    \\  \\  (  0    connect   failure ,     0    send   limit ,     0    transport   error \\  \\  )  \\  \\  ]  ,     \"     +     \" stompSubProtocol \\  \\  [ processed   CONNECT \\  \\  (  0  \\  \\  )  - CONNECTED \\  \\  (  0  \\  \\  )  - DISCONNECT \\  \\  (  0  \\  \\  )  \\  \\  ]  ,     \"  )     +     \" stompBrokerRelay \\  \\  [  0    sessions ,    relayhost :  1  2  3  4     \\  \\  ( not   available \\  \\  )  ,     \"  )     +     \" processed   CONNECT \\  \\  (  0  \\  \\  )  - CONNECTED \\  \\  (  0  \\  \\  )  - DISCONNECT \\  \\  (  0  \\  \\  )  \\  \\  ]  ,     \"  )     +     \" inboundChannel \\  \\  [ pool   size    =     \\  \\ d ,    active   threads    =     \\  \\ d ,    queued   tasks    =     \\  \\ d ,     \"  )     +     \" completed   tasks    =     \\  \\ d \\  \\  ]  ,     \"  )     +     \" outboundChannelpool   size    =     \\  \\ d ,    active   threads    =     \\  \\ d ,    queued   tasks    =     \\  \\ d ,     \"  )     +     \" completed   tasks    =     \\  \\ d \\  \\  ]  ,     \"  )     +     \" sockJsScheduler \\  \\  [ pool   size    =     \\  \\ d ,    active   threads    =     \\  \\ d ,    queued   tasks    =     \\  \\ d ,     \"  )     +     \" completed   tasks    =     \\  \\ d \\  \\  ]  \"  )  ;", "assertTrue (  (  (  (  \"  \\ nExpected :     \"     +     ( expected . replace (  \"  \\  \\  \"  ,     \"  \"  )  )  )     +     \"  \\ n      Actual :     \"  )     +    actual )  ,    actual . matches ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["stompBrokerRelay"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSubscribableChannel   channel    =    this . appContext . getBean ( channelName ,    AbstractSubscribableChannel . class )  ;", "for    ( Class <  ?    extends   Handler >    subscriberType    :    subscriberTypes )     {", "Handler   subscriber    =    this . appContext . getBean ( subscriberType )  ;", "assertNotNull (  (  \" No   subsription   for    \"     +    subscriberType )  ,    subscriber )  ;", "assertTrue ( channel . hasSubscription ( subscriber )  )  ;", "}", "List < ChannelInterceptor >    interceptors    =    channel . getInterceptors (  )  ;", "assertEquals ( interceptorCount ,    interceptors . size (  )  )  ;", "assertEquals ( ImmutableChannelInterceptor . class ,    interceptors . get (  (  ( interceptors . size (  )  )     -     1  )  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testChannel"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskExecutor   taskExecutor    =    this . appContext . getBean (  ( channelName    +     \" Executor \"  )  ,    ThreadPoolTaskExecutor . class )  ;", "assertEquals ( corePoolSize ,    taskExecutor . getCorePoolSize (  )  )  ;", "assertEquals ( maxPoolSize ,    taskExecutor . getMaxPoolSize (  )  )  ;", "assertEquals ( keepAliveSeconds ,    taskExecutor . getKeepAliveSeconds (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExecutor"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return   handler   instanceof   WebSocketHandlerDecorator    ?     (  ( WebSocketHandlerDecorator )     ( handler )  )  . getLastHandler (  )     :    handler ;", "}", "METHOD_END"], "methodName": ["unwrapWebSocketHandler"], "fileName": "org.springframework.web.socket.config.MessageBrokerBeanDefinitionParserTests"}, {"methodBody": ["METHOD_START", "{", "return    ( this . inboundChannelExecutor )     !  =    null    ?    getExecutorStatsInfo ( this . inboundChannelExecutor )     :     \" null \"  ;", "}", "METHOD_END"], "methodName": ["getClientInboundExecutorStatsInfo"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "return    ( this . outboundChannelExecutor )     !  =    null    ?    getExecutorStatsInfo ( this . outboundChannelExecutor )     :     \" null \"  ;", "}", "METHOD_END"], "methodName": ["getClientOutboundExecutorStatsInfo"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "String   str    =    executor . toString (  )  ;", "return   str . substring ( str . indexOf (  \" pool \"  )  ,     (  ( str . length (  )  )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getExecutorStatsInfo"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "return   this . loggingPeriod ;", "}", "METHOD_END"], "methodName": ["getLoggingPeriod"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "return    ( this . sockJsTaskScheduler )     !  =    null    ?    getExecutorStatsInfo ( this . sockJsTaskScheduler )     :     \" null \"  ;", "}", "METHOD_END"], "methodName": ["getSockJsTaskSchedulerStatsInfo"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "return    ( this . stompBrokerRelay )     !  =    null    ?    this . stompBrokerRelay . getStatsInfo (  )     :     \" null \"  ;", "}", "METHOD_END"], "methodName": ["getStompBrokerRelayStatsInfo"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "return    ( this . stompSubProtocolHandler )     !  =    null    ?    this . stompSubProtocolHandler . getStatsInfo (  )     :     \" null \"  ;", "}", "METHOD_END"], "methodName": ["getStompSubProtocolStatsInfo"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "return    ( this . webSocketHandler )     !  =    null    ?    this . webSocketHandler . getStatsInfo (  )     :     \" null \"  ;", "}", "METHOD_END"], "methodName": ["getWebSocketSessionStatsInfo"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( this . sockJsTaskScheduler )     !  =    null )     &  &     (  ( this . loggingPeriod )     >     0  )  )     &  &     ( WebSocketMessageBrokerStats . logger . isInfoEnabled (  )  )  )     {", "return   this . sockJsTaskScheduler . scheduleAtFixedRate (  (  )     -  >    WebSocketMessageBrokerStats . logger . info ( this . toString (  )  )  ,    initialDelay ,    this . loggingPeriod ,    TimeUnit . MILLISECONDS )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["initLoggingTask"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . webSocketHandler )     =  =    null )     {", "return   null ;", "}", "for    ( SubProtocolHandler   handler    :    this . webSocketHandler . getProtocolHandlers (  )  )     {", "if    ( handler   instanceof   StompSubProtocolHandler )     {", "return    (  ( StompSubProtocolHandler )     ( handler )  )  ;", "}", "}", "SubProtocolHandler   defaultHandler    =    this . webSocketHandler . getDefaultProtocolHandler (  )  ;", "if    (  ( defaultHandler    !  =    null )     &  &     ( defaultHandler   instanceof   StompSubProtocolHandler )  )     {", "return    (  ( StompSubProtocolHandler )     ( defaultHandler )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["initStompSubProtocolHandler"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "this . inboundChannelExecutor    =    inboundChannelExecutor . getThreadPoolExecutor (  )  ;", "}", "METHOD_END"], "methodName": ["setInboundChannelExecutor"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . loggingTask )     !  =    null )     {", "this . loggingTask . cancel ( true )  ;", "}", "this . loggingPeriod    =    period ;", "this . loggingTask    =    initLoggingTask (  0  )  ;", "}", "METHOD_END"], "methodName": ["setLoggingPeriod"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "this . outboundChannelExecutor    =    outboundChannelExecutor . getThreadPoolExecutor (  )  ;", "}", "METHOD_END"], "methodName": ["setOutboundChannelExecutor"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "this . sockJsTaskScheduler    =    sockJsTaskScheduler . getScheduledThreadPoolExecutor (  )  ;", "this . loggingTask    =    initLoggingTask ( TimeUnit . MINUTES . toMillis (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setSockJsTaskScheduler"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "this . stompBrokerRelay    =    stompBrokerRelay ;", "}", "METHOD_END"], "methodName": ["setStompBrokerRelay"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "this . webSocketHandler    =    webSocketHandler ;", "this . stompSubProtocolHandler    =    initStompSubProtocolHandler (  )  ;", "}", "METHOD_END"], "methodName": ["setSubProtocolWebSocketHandler"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" WebSocketSession [  \"     +     ( getWebSocketSessionStatsInfo (  )  )  )     +     \"  ]  \"  )     +     \"  ,    stompSubProtocol [  \"  )     +     ( getStompSubProtocolStatsInfo (  )  )  )     +     \"  ]  \"  )     +     \"  ,    stompBrokerRelay [  \"  )     +     ( getStompBrokerRelayStatsInfo (  )  )  )     +     \"  ]  \"  )     +     \"  ,    inboundChannel [  \"  )     +     ( getClientInboundExecutorStatsInfo (  )  )  )     +     \"  ]  \"  )     +     \"  ,    outboundChannel \"  )     +     ( getClientOutboundExecutorStatsInfo (  )  )  )     +     \"  ]  \"  )     +     \"  ,    sockJsScheduler [  \"  )     +     ( getSockJsTaskSchedulerStatsInfo (  )  )  )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.web.socket.config.WebSocketMessageBrokerStats"}, {"methodBody": ["METHOD_START", "{", "ManagedList <  ?    super   Object >    beans    =    new   ManagedList (  )  ;", "if    ( parentElement    !  =    null )     {", "beans . setSource ( context . extractSource ( parentElement )  )  ;", "for    ( Element   beanElement    :    Dom . getChildElementsByTagName ( parentElement ,     \" bean \"  ,     \" ref \"  )  )     {", "beans . add ( context . getDelegate (  )  . parsePropertySubElement ( beanElement ,    null )  )  ;", "}", "}", "return   beans ;", "}", "METHOD_END"], "methodName": ["parseBeanSubElements"], "fileName": "org.springframework.web.socket.config.WebSocketNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "RuntimeBeanReference   handlerRef ;", "Element   handlerElem    =    Dom . getChildElementByTagName ( element ,     \" handshake - handler \"  )  ;", "if    ( handlerElem    !  =    null )     {", "handlerRef    =    new   RuntimeBeanReference ( handlerElem . getAttribute (  \" ref \"  )  )  ;", "} else    {", "RootBeanDefinition   defaultHandlerDef    =    new   RootBeanDefinition ( DefaultHandshakeHandler . class )  ;", "defaultHandlerDef . setSource ( source )  ;", "defaultHandlerDef . setRole ( ROLE _ INFRASTRUCTURE )  ;", "String   handlerName    =    context . getReaderContext (  )  . registerWithGeneratedName ( defaultHandlerDef )  ;", "handlerRef    =    new   RuntimeBeanReference ( handlerName )  ;", "}", "return   handlerRef ;", "}", "METHOD_END"], "methodName": ["registerHandshakeHandler"], "fileName": "org.springframework.web.socket.config.WebSocketNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( context . getRegistry (  )  . containsBeanDefinition ( schedulerName )  )  )     {", "RootBeanDefinition   taskSchedulerDef    =    new   RootBeanDefinition ( ThreadPoolTaskScheduler . class )  ;", "taskSchedulerDef . setSource ( source )  ;", "taskSchedulerDef . setRole ( ROLE _ INFRASTRUCTURE )  ;", "taskSchedulerDef . getPropertyValues (  )  . add (  \" poolSize \"  ,    Runtime . getRuntime (  )  . availableProcessors (  )  )  ;", "taskSchedulerDef . getPropertyValues (  )  . add (  \" threadNamePrefix \"  ,     ( schedulerName    +     \"  -  \"  )  )  ;", "taskSchedulerDef . getPropertyValues (  )  . add (  \" removeOnCancelPolicy \"  ,    true )  ;", "context . getRegistry (  )  . registerBeanDefinition ( schedulerName ,    taskSchedulerDef )  ;", "context . registerComponent ( new   beans . factory . parsing . BeanComponentDefinition ( taskSchedulerDef ,    schedulerName )  )  ;", "}", "return   new   RuntimeBeanReference ( schedulerName )  ;", "}", "METHOD_END"], "methodName": ["registerScheduler"], "fileName": "org.springframework.web.socket.config.WebSocketNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "Element   sockJsElement    =    DomUtils . getChildElementByTagName ( element ,     \" sockjs \"  )  ;", "if    ( sockJsElement    !  =    null )     {", "Element   handshakeHandler    =    DomUtils . getChildElementByTagName ( element ,     \" handshake - handler \"  )  ;", "RootBeanDefinition   sockJsServiceDef    =    new   RootBeanDefinition ( DefaultSockJsService . class )  ;", "sockJsServiceDef . setSource ( source )  ;", "Object   scheduler ;", "String   customTaskSchedulerName    =    sockJsElement . getAttribute (  \" scheduler \"  )  ;", "if    (  !  ( customTaskSchedulerName . isEmpty (  )  )  )     {", "scheduler    =    new   RuntimeBeanReference ( customTaskSchedulerName )  ;", "} else    {", "scheduler    =    WebSocketNamespaceUtils . registerScheduler ( schedulerName ,    cxt ,    source )  ;", "}", "sockJsServiceDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  0  ,    scheduler )  ;", "Element   transportHandlersElement    =    DomUtils . getChildElementByTagName ( sockJsElement ,     \" transport - handlers \"  )  ;", "if    ( transportHandlersElement    !  =    null )     {", "String   registerDefaults    =    transportHandlersElement . getAttribute (  \" register - defaults \"  )  ;", "if    ( registerDefaults . equals (  \" false \"  )  )     {", "sockJsServiceDef . setBeanClass ( TransportHandlingSockJsService . class )  ;", "}", "ManagedList <  ?  >    transportHandlers    =    WebSocketNamespaceUtils . parseBeanSubElements ( transportHandlersElement ,    cxt )  ;", "sockJsServiceDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    transportHandlers )  ;", "} else", "if    ( handshakeHandler    !  =    null )     {", "RuntimeBeanReference   handshakeHandlerRef    =    new   RuntimeBeanReference ( handshakeHandler . getAttribute (  \" ref \"  )  )  ;", "RootBeanDefinition   transportHandler    =    new   RootBeanDefinition ( sockjs . transport . handler . WebSocketTransportHandler . class )  ;", "transportHandler . setSource ( source )  ;", "transportHandler . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  0  ,    handshakeHandlerRef )  ;", "sockJsServiceDef . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    transportHandler )  ;", "}", "Element   interceptElem    =    DomUtils . getChildElementByTagName ( element ,     \" handshake - interceptors \"  )  ;", "ManagedList <  ?    super   Object >    interceptors    =    WebSocketNamespaceUtils . parseBeanSubElements ( interceptElem ,    cxt )  ;", "String   allowedOrigins    =    element . getAttribute (  \" allowed - origins \"  )  ;", "List < String >    origins    =    Arrays . asList ( StringUtils . tokenizeToStringArray ( allowedOrigins ,     \"  ,  \"  )  )  ;", "sockJsServiceDef . getPropertyValues (  )  . add (  \" allowedOrigins \"  ,    origins )  ;", "RootBeanDefinition   originHandshakeInterceptor    =    new   RootBeanDefinition ( OriginHandshakeInterceptor . class )  ;", "originHandshakeInterceptor . getPropertyValues (  )  . add (  \" allowedOrigins \"  ,    origins )  ;", "interceptors . add ( originHandshakeInterceptor )  ;", "sockJsServiceDef . getPropertyValues (  )  . add (  \" handshakeInterceptors \"  ,    interceptors )  ;", "String   attrValue    =    sockJsElement . getAttribute (  \" name \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" name \"  ,    attrValue )  ;", "}", "attrValue    =    sockJsElement . getAttribute (  \" websocket - enabled \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" webSocketEnabled \"  ,    Boolean . valueOf ( attrValue )  )  ;", "}", "attrValue    =    sockJsElement . getAttribute (  \" session - cookie - needed \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" sessionCookieNeeded \"  ,    Boolean . valueOf ( attrValue )  )  ;", "}", "attrValue    =    sockJsElement . getAttribute (  \" stream - bytes - limit \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" streamBytesLimit \"  ,    Integer . valueOf ( attrValue )  )  ;", "}", "attrValue    =    sockJsElement . getAttribute (  \" disconnect - delay \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" disconnectDelay \"  ,    Long . valueOf ( attrValue )  )  ;", "}", "attrValue    =    sockJsElement . getAttribute (  \" message - cache - size \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" httpMessageCacheSize \"  ,    Integer . valueOf ( attrValue )  )  ;", "}", "attrValue    =    sockJsElement . getAttribute (  \" heartbeat - time \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" heartbeatTime \"  ,    Long . valueOf ( attrValue )  )  ;", "}", "attrValue    =    sockJsElement . getAttribute (  \" client - library - url \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" sockJsClientLibraryUrl \"  ,    attrValue )  ;", "}", "attrValue    =    sockJsElement . getAttribute (  \" message - codec \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" messageCodec \"  ,    new   RuntimeBeanReference ( attrValue )  )  ;", "}", "attrValue    =    sockJsElement . getAttribute (  \" suppress - cors \"  )  ;", "if    (  !  ( attrValue . isEmpty (  )  )  )     {", "sockJsServiceDef . getPropertyValues (  )  . add (  \" suppressCors \"  ,    Boolean . valueOf ( attrValue )  )  ;", "}", "sockJsServiceDef . setRole ( ROLE _ INFRASTRUCTURE )  ;", "String   sockJsServiceName    =    cxt . getReaderContext (  )  . registerWithGeneratedName ( sockJsServiceDef )  ;", "return   new   RuntimeBeanReference ( sockJsServiceName )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["registerSockJsService"], "fileName": "org.springframework.web.socket.config.WebSocketNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . handshakeHandler ;", "}", "METHOD_END"], "methodName": ["getHandshakeHandler"], "fileName": "org.springframework.web.socket.config.annotation.AbstractWebSocketHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "List < HandshakeInterceptor >    interceptors    =    new   ArrayList <  >  (  (  ( this . interceptors . size (  )  )     +     1  )  )  ;", "interceptors . addAll ( this . interceptors )  ;", "interceptors . add ( new   OriginHandshakeInterceptor ( this . allowedOrigins )  )  ;", "return   interceptors . toArray ( new   HandshakeInterceptor [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getInterceptors"], "fileName": "org.springframework.web.socket.config.annotation.AbstractWebSocketHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "M   mappings    =    createMappings (  )  ;", "if    (  ( this . sockJsServiceRegistration )     !  =    null )     {", "SockJsService   sockJsService    =    this . sockJsServiceRegistration . getSockJsService (  )  ;", "this . handlerMap . forEach (  (    wsHandler ,    paths )     -  >     {", "for    ( String   path    :    paths )     {", "String   pathPattern    =     ( path . endsWith (  \"  /  \"  )  )     ?    path    +     \"  *  *  \"     :    path    +     \"  /  *  *  \"  ;", "addSockJsServiceMapping ( mappings ,    sockJsService ,    wsHandler ,    pathPattern )  ;", "}", "}  )  ;", "} else    {", "HandshakeHandler   handshakeHandler    =    getOrCreateHandshakeHandler (  )  ;", "HandshakeInterceptor [  ]    interceptors    =    getInterceptors (  )  ;", "this . handlerMap . forEach (  (    wsHandler ,    paths )     -  >     {", "for    ( String   path    :    paths )     {", "addMapping ( mappings ,    wsHandler ,    handshakeHandler ,    interceptors ,    path )  ;", "}", "}  )  ;", "}", "return   mappings ;", "}", "METHOD_END"], "methodName": ["getMappings"], "fileName": "org.springframework.web.socket.config.annotation.AbstractWebSocketHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "return    ( this . handshakeHandler )     !  =    null    ?    this . handshakeHandler    :    new   DefaultHandshakeHandler (  )  ;", "}", "METHOD_END"], "methodName": ["getOrCreateHandshakeHandler"], "fileName": "org.springframework.web.socket.config.annotation.AbstractWebSocketHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . sockJsServiceRegistration ;", "}", "METHOD_END"], "methodName": ["getSockJsServiceRegistration"], "fileName": "org.springframework.web.socket.config.annotation.AbstractWebSocketHandlerRegistration"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CollectionUtils . isEmpty ( configurers )  )  )     {", "this . configurers . addAll ( configurers )  ;", "}", "}", "METHOD_END"], "methodName": ["setConfigurers"], "fileName": "org.springframework.web.socket.config.annotation.DelegatingWebSocketConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CollectionUtils . isEmpty ( configurers )  )  )     {", "this . configurers . addAll ( configurers )  ;", "}", "}", "METHOD_END"], "methodName": ["setConfigurers"], "fileName": "org.springframework.web.socket.config.annotation.DelegatingWebSocketMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    urlMap    =    new   LinkedHashMap <  >  (  )  ;", "for    ( ation   registration    :    this . registrations )     {", "updateTaskScheduler ( registration )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "mappings . forEach (  (    httpHandler ,    patterns )     -  >     {", "for    ( String   pattern    :    patterns )     {", "urlMap . put ( pattern ,    httpHandler )  ;", "}", "}  )  ;", "}", "WebSocketHandlerMapping   hm    =    new   WebSocketHandlerMapping (  )  ;", "hm . setUrlMap ( urlMap )  ;", "hm . setOrder ( this . order )  ;", "if    (  ( this . urlPathHelper )     !  =    null )     {", "hm . setUrlPathHelper ( this . urlPathHelper )  ;", "}", "return   hm ;", "}", "METHOD_END"], "methodName": ["getHandlerMapping"], "fileName": "org.springframework.web.socket.config.annotation.ServletWebSocketHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . order ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.web.socket.config.annotation.ServletWebSocketHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . urlPathHelper ;", "}", "METHOD_END"], "methodName": ["getUrlPathHelper"], "fileName": "org.springframework.web.socket.config.annotation.ServletWebSocketHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . registrations . stream (  )  . anyMatch (  (    r )     -  >     (  ( r . getSockJsServiceRegistration (  )  )     !  =    null )     &  &     (  ( r . getSockJsServiceRegistration (  )  . getTaskScheduler (  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["requiresTaskScheduler"], "fileName": "org.springframework.web.socket.config.annotation.ServletWebSocketHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.web.socket.config.annotation.ServletWebSocketHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . scheduler    =    scheduler ;", "}", "METHOD_END"], "methodName": ["setTaskScheduler"], "fileName": "org.springframework.web.socket.config.annotation.ServletWebSocketHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . urlPathHelper    =    urlPathHelper ;", "}", "METHOD_END"], "methodName": ["setUrlPathHelper"], "fileName": "org.springframework.web.socket.config.annotation.ServletWebSocketHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "SockJsServiceRegistration   sockJsRegistration    =    registration . getSockJsServiceRegistration (  )  ;", "if    (  (  ( sockJsRegistration    !  =    null )     &  &     (  ( this . scheduler )     !  =    null )  )     &  &     (  ( sockJsRegistration . getTaskScheduler (  )  )     =  =    null )  )     {", "sockJsRegistration . setTaskScheduler ( this . scheduler )  ;", "}", "}", "METHOD_END"], "methodName": ["updateTaskScheduler"], "fileName": "org.springframework.web.socket.config.annotation.ServletWebSocketHandlerRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . scheduler )     !  =    null )  ,     \" No   TaskScheduler   available \"  )  ;", "Assert . state (  (  ( this . transportHandlers . isEmpty (  )  )     |  |     ( this . transportHandlerOverrides . isEmpty (  )  )  )  ,     \" Specify   either   TransportHandlers   or   TransportHandler   overrides ,    not   both \"  )  ;", "return    !  ( this . transportHandlers . isEmpty (  )  )     ?    new   TransportHandling ( this . scheduler ,    this . transportHandlers )     :    new   Default ( this . scheduler ,    this . transportHandlerOverrides )  ;", "}", "METHOD_END"], "methodName": ["createSockJsService"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "TransportHandlingSockJsService   service    =    createSockJsService (  )  ;", "service . setHandshakeInterceptors ( this . interceptors )  ;", "if    (  ( this . clientLibraryUrl )     !  =    null )     {", "service . setSockJsClientLibraryUrl ( this . clientLibraryUrl )  ;", "}", "if    (  ( this . streamBytesLimit )     !  =    null )     {", "service . setStreamBytesLimit ( this . streamBytesLimit )  ;", "}", "if    (  ( this . sessionCookieNeeded )     !  =    null )     {", "service . setSessionCookieNeeded ( this . sessionCookieNeeded )  ;", "}", "if    (  ( this . heartbeatTime )     !  =    null )     {", "service . setHeartbeatTime ( this . heartbeatTime )  ;", "}", "if    (  ( this . disconnectDelay )     !  =    null )     {", "service . setDisconnectDelay ( this . disconnectDelay )  ;", "}", "if    (  ( this . httpMessageCacheSize )     !  =    null )     {", "service . setHttpMessageCacheSize ( this . httpMessageCacheSize )  ;", "}", "if    (  ( this . webSocketEnabled )     !  =    null )     {", "service . setWebSocketEnabled ( this . webSocketEnabled )  ;", "}", "if    (  ( this . suppressCors )     !  =    null )     {", "service . setSuppressCors ( this . suppressCors )  ;", "}", "service . setAllowedOrigins ( this . allowedOrigins )  ;", "if    (  ( this . messageCodec )     !  =    null )     {", "service . setMessageCodec ( this . messageCodec )  ;", "}", "return   service ;", "}", "METHOD_END"], "methodName": ["getSockJsService"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . scheduler ;", "}", "METHOD_END"], "methodName": ["getTaskScheduler"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . allowedOrigins . clear (  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( allowedOrigins )  )  )     {", "this . allowedOrigins . addAll ( Arrays . asL ( allowedOrigins )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["setAllowedOrigins"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . clientLibraryUrl    =    clientLibraryUrl ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setClientLibraryUrl"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . disconnectDelay    =    disconnectDelay ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDisconnectDelay"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . heartbeatTime    =    heartbeatTime ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHeartbeatTime"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . httpMessageCacheSize    =    httpMessageCacheSize ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHttpMessageCacheSize"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . interceptors . clear (  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( interceptors )  )  )     {", "this . interceptors . addAll ( Arrays . asL ( interceptors )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["setInterceptors"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . messageCodec    =    codec ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setMessageCodec"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . sessionCookieNeeded    =    sessionCookieNeeded ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSessionCookieNeeded"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . streamBytesLimit    =    streamBytesLimit ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStreamBytesLimit"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . suppressCors    =    suppressCors ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSupressCors"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( scheduler ,     \" TaskScheduler   is   required \"  )  ;", "this . scheduler    =    scheduler ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTaskScheduler"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . transportHandlerOverrides . clear (  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( handlers )  )  )     {", "this . transportHandlerOverrides . addAll ( Arrays . asList ( handlers )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["setTransportHandlerOverrides"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . transportHandlers . clear (  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( handlers )  )  )     {", "this . transportHandlers . addAll ( Arrays . asList ( handlers )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["setTransportHandlers"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "this . webSocketEnabled    =    webSocketEnabled ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setWebSocketEnabled"], "fileName": "org.springframework.web.socket.config.annotation.SockJsServiceRegistration"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    urlMap    =    new   LinkedHashMap <  >  (  )  ;", "for    ( WebMvcStompWebSocketation   registration    :    this . registrations )     {", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "mappings . forEach (  (    httpHandler ,    patterns )     -  >     {", "for    ( String   pattern    :    patterns )     {", "urlMap . put ( pattern ,    httpHandler )  ;", "}", "}  )  ;", "}", "WebSocketHandlerMapping   hm    =    new   WebSocketHandlerMapping (  )  ;", "hm . setUrlMap ( urlMap )  ;", "hm . setOrder ( this . order )  ;", "if    (  ( this . urlPathHelper )     !  =    null )     {", "hm . setUrlPathHelper ( this . urlPathHelper )  ;", "}", "return   hm ;", "}", "METHOD_END"], "methodName": ["getHandlerMapping"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . order ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . urlPathHelper ;", "}", "METHOD_END"], "methodName": ["getUrlPathHelper"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "this . stompHandler . setApplicationEventPublisher ( applicationContext )  ;", "}", "METHOD_END"], "methodName": ["setApplicationContext"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   actual    =    WebSocketHandlerDecorator . unwrap ( handler )  ;", "if    (  !  ( actual   instanceof   SubProtocolWebSocketHandler )  )     {", "throw   new   IllegalArgumentException (  (  \" No   SubProtocolWebSocketHandler   in    \"     +    handler )  )  ;", "}", "return    (  ( SubProtocolWebSocketHandler )     ( actual )  )  ;", "}", "METHOD_END"], "methodName": ["unwrapSubProtocolWebSocketHandler"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "StompSubProtocolErrorHandler   errorHandler    =    mock ( StompSubProtocolErrorHandler . class )  ;", "this . e . setErrorHandler ( errorHandler )  ;", "this . e . addEndpoint (  \"  / stompOverWebSocket \"  )  ;", "Map < String ,    SubProtocolHandler >    protocolHandlers    =    this . webSocketHandler . getProtocolHandlerMap (  )  ;", "StompSubProtocolHandler   stompHandler    =     (  ( StompSubProtocolHandler )     ( protocolHandlers . get (  \" v 1  2  . stomp \"  )  )  )  ;", "assertSame ( errorHandler ,    stompHandler . getErrorHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["errorHandler"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistryTests"}, {"methodBody": ["METHOD_START", "{", "SimpleUrlHandlerMapping   hm    =     (  ( SimpleUrlHandlerMapping )     ( this . endpointRegistry . getHandlerMapping (  )  )  )  ;", "assertEquals (  0  ,    hm . getUrlMap (  )  . size (  )  )  ;", "UrlPathHelper   pathHelper    =    new   UrlPathHelper (  )  ;", "this . endpointRegistry . setUrlPathHelper ( pathHelper )  ;", "this . endpointRegistry . addEndpoint (  \"  / stompOverWebSocket \"  )  ;", "this . endpointRegistry . addEndpoint (  \"  / stompOverSockJS \"  )  . withSockJS (  )  ;", "assertEquals (  1  ,    this . webSocketHandler . getProtocolHandlers (  )  . size (  )  )  ;", "hm    =     (  ( SimpleUrlHandlerMapping )     ( this . endpointRegistry . getHandlerMapping (  )  )  )  ;", "assertEquals (  2  ,    hm . getUrlMap (  )  . size (  )  )  ;", "assertNotNull ( hm . getUrlMap (  )  . get (  \"  / stompOverWebSocket \"  )  )  ;", "assertNotNull ( hm . getUrlMap (  )  . get (  \"  / stompOverSockJS /  *  *  \"  )  )  ;", "assertSame ( pathHelper ,    hm . getUrlPathHelper (  )  )  ;", "}", "METHOD_END"], "methodName": ["handlerMapping"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistryTests"}, {"methodBody": ["METHOD_START", "{", "SubscribableChannel   inChannel    =    mock ( SubscribableChannel . class )  ;", "SubscribableChannel   outChannel    =    mock ( SubscribableChannel . class )  ;", "this . webSocketHandler    =    new   SubProtocolWebSocketHandler ( inChannel ,    outChannel )  ;", "WebSocketTransportRegistration   transport    =    new   WebSocketTransportRegistration (  )  ;", "TaskScheduler   scheduler    =    mock ( TaskScheduler . class )  ;", "this . endpointRegistry    =    new    ( this . webSocketHandler ,    transport ,    scheduler )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . endpointRegistry . addEndpoint (  \"  / stomp \"  )  ;", "Map < String ,    SubProtocolHandler >    protocolHandlers    =    webSocketHandler . getProtocolHandlerMap (  )  ;", "assertEquals (  3  ,    protocolHandlers . size (  )  )  ;", "assertNotNull ( protocolHandlers . get (  \" v 1  0  . stomp \"  )  )  ;", "assertNotNull ( protocolHandlers . get (  \" v 1  1  . stomp \"  )  )  ;", "assertNotNull ( protocolHandlers . get (  \" v 1  2  . stomp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["stompProtocolHandler"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < HandshakeInterceptor >    interceptors    =    new   ArrayList <  >  (  (  ( this . interceptors . size (  )  )     +     1  )  )  ;", "interceptors . addAll ( this . interceptors )  ;", "interceptors . add ( new   OriginHandshakeInterceptor ( this . allowedOrigins )  )  ;", "return   interceptors . toArray ( new   HandshakeInterceptor [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getInterceptors"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistration"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    new   LinkedMultiValueMap (  )  ;", "if    (  ( this . registration )     !  =    null )     {", "SockJsService   sockJsService    =    this . registration . getSockJsService (  )  ;", "for    ( String   path    :    this . paths )     {", "String   pattern    =     ( path . endsWith (  \"  /  \"  )  )     ?    path    +     \"  *  *  \"     :    path    +     \"  /  *  *  \"  ;", "SockJsHttpRequestHandler   handler    =    new   SockJsHttpRequestHandler ( sockJsService ,    this . webSocketHandler )  ;", "mappings . add ( handler ,    pattern )  ;", "}", "} else    {", "for    ( String   path    :    this . paths )     {", "WebSocketHttpRequestHandler   handler ;", "if    (  ( this . handshakeHandler )     !  =    null )     {", "handler    =    new   WebSocketHttpRequestHandler ( this . webSocketHandler ,    this . handshakeHandler )  ;", "} else    {", "handler    =    new   WebSocketHttpRequestHandler ( this . webSocketHandler )  ;", "}", "HandshakeInterceptor [  ]    interceptors    =    getInterceptors (  )  ;", "if    (  ( interceptors . length )     >     0  )     {", "handler . setHandshakeInterceptors ( Arrays . asList ( interceptors )  )  ;", "}", "mappings . add ( handler ,    path )  ;", "}", "}", "return   mappings ;", "}", "METHOD_END"], "methodName": ["getMappings"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistration"}, {"methodBody": ["METHOD_START", "{", "WebMvcStompWebSocketEndpointRegistration   registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "registration . setAllowedOrigins (  )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "HttpRequestHandler   handler    =    mappings . entrySet (  )  . iterator (  )  . next (  )  . getKey (  )  ;", "WebSocketHttpRequestHandler   wsHandler    =     (  ( WebSocketHttpRequestHandler )     ( handler )  )  ;", "assertNotNull ( wsHandler . getWebSocketHandler (  )  )  ;", "assertEquals (  1  ,    wsHandler . getHandshakeInterceptors (  )  . size (  )  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    wsHandler . getHandshakeInterceptors (  )  . get (  0  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["allowedOrigins"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebMvcStompWebSocketEndpointRegistration   registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "String   origin    =     \" http :  /  / mydomain . com \"  ;", "registration . setAllowedOrigins ( origin )  . withSockJS (  )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "SockJsHttpRequestHandler   requestHandler    =     (  ( SockJsHttpRequestHandler )     ( mappings . entrySet (  )  . iterator (  )  . next (  )  . getKey (  )  )  )  ;", "assertNotNull ( requestHandler . getSockJsService (  )  )  ;", "DefaultSockJsService   sockJsService    =     (  ( DefaultSockJsService )     ( requestHandler . getSockJsService (  )  )  )  ;", "assertTrue ( sockJsService . getAllowedOrigins (  )  . contains ( origin )  )  ;", "assertFalse ( sockJsService . shouldSuppressCors (  )  )  ;", "registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "registration . withSockJS (  )  . setAllowedOrigins ( origin )  ;", "mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "requestHandler    =     (  ( SockJsHttpRequestHandler )     ( mappings . entrySet (  )  . iterator (  )  . next (  )  . getKey (  )  )  )  ;", "assertNotNull ( requestHandler . getSockJsService (  )  )  ;", "sockJsService    =     (  ( DefaultSockJsService )     ( requestHandler . getSockJsService (  )  )  )  ;", "assertTrue ( sockJsService . getAllowedOrigins (  )  . contains ( origin )  )  ;", "assertFalse ( sockJsService . shouldSuppressCors (  )  )  ;", "}", "METHOD_END"], "methodName": ["allowedOriginsWithSockJsService"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebMvcStompWebSocketEndpointRegistration   registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "registration . withSockJS (  )  . setSupressCors ( true )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "SockJsHttpRequestHandler   requestHandler    =     (  ( SockJsHttpRequestHandler )     ( mappings . entrySet (  )  . iterator (  )  . next (  )  . getKey (  )  )  )  ;", "assertNotNull ( requestHandler . getSockJsService (  )  )  ;", "DefaultSockJsService   sockJsService    =     (  ( DefaultSockJsService )     ( requestHandler . getSockJsService (  )  )  )  ;", "assertTrue ( sockJsService . shouldSuppressCors (  )  )  ;", "}", "METHOD_END"], "methodName": ["disableCorsWithSockJsService"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebMvcStompWebSocketEndpointRegistration   registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "DefaultHandshakeHandler   handshakeHandler    =    new   DefaultHandshakeHandler (  )  ;", "HttpSessionHandshakeInterceptor   interceptor    =    new   HttpSessionHandshakeInterceptor (  )  ;", "registration . setHandshakeHandler ( handshakeHandler )  . addInterceptors ( interceptor )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "Map . Entry < HttpRequestHandler ,    List < String >  >    entry    =    mappings . entrySet (  )  . iterator (  )  . next (  )  ;", "assertEquals ( Arrays . asList (  \"  / foo \"  )  ,    entry . getValue (  )  )  ;", "WebSocketHttpRequestHandler   requestHandler    =     (  ( WebSocketHttpRequestHandler )     ( entry . getKey (  )  )  )  ;", "assertNotNull ( requestHandler . getWebSocketHandler (  )  )  ;", "assertSame ( handshakeHandler ,    requestHandler . getHandshakeHandler (  )  )  ;", "assertEquals (  2  ,    requestHandler . getHandshakeInterceptors (  )  . size (  )  )  ;", "assertEquals ( interceptor ,    requestHandler . getHandshakeInterceptors (  )  . get (  0  )  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    requestHandler . getHandshakeInterceptors (  )  . get (  1  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["handshakeHandlerAndInterceptor"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebMvcStompWebSocketEndpointRegistration   registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "DefaultHandshakeHandler   handshakeHandler    =    new   DefaultHandshakeHandler (  )  ;", "HttpSessionHandshakeInterceptor   interceptor    =    new   HttpSessionHandshakeInterceptor (  )  ;", "String   origin    =     \" http :  /  / mydomain . com \"  ;", "registration . setHandshakeHandler ( handshakeHandler )  . addInterceptors ( interceptor )  . setAllowedOrigins ( origin )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "Map . Entry < HttpRequestHandler ,    List < String >  >    entry    =    mappings . entrySet (  )  . iterator (  )  . next (  )  ;", "assertEquals ( Arrays . asList (  \"  / foo \"  )  ,    entry . getValue (  )  )  ;", "WebSocketHttpRequestHandler   requestHandler    =     (  ( WebSocketHttpRequestHandler )     ( entry . getKey (  )  )  )  ;", "assertNotNull ( requestHandler . getWebSocketHandler (  )  )  ;", "assertSame ( handshakeHandler ,    requestHandler . getHandshakeHandler (  )  )  ;", "assertEquals (  2  ,    requestHandler . getHandshakeInterceptors (  )  . size (  )  )  ;", "assertEquals ( interceptor ,    requestHandler . getHandshakeInterceptors (  )  . get (  0  )  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    requestHandler . getHandshakeInterceptors (  )  . get (  1  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["handshakeHandlerAndInterceptorWithAllowedOrigins"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebMvcStompWebSocketEndpointRegistration   registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "DefaultHandshakeHandler   handshakeHandler    =    new   DefaultHandshakeHandler (  )  ;", "HttpSessionHandshakeInterceptor   interceptor    =    new   HttpSessionHandshakeInterceptor (  )  ;", "registration . setHandshakeHandler ( handshakeHandler )  . addInterceptors ( interceptor )  . withSockJS (  )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "Map . Entry < HttpRequestHandler ,    List < String >  >    entry    =    mappings . entrySet (  )  . iterator (  )  . next (  )  ;", "assertEquals ( Arrays . asList (  \"  / foo /  *  *  \"  )  ,    entry . getValue (  )  )  ;", "SockJsHttpRequestHandler   requestHandler    =     (  ( SockJsHttpRequestHandler )     ( entry . getKey (  )  )  )  ;", "assertNotNull ( requestHandler . getWebSocketHandler (  )  )  ;", "DefaultSockJsService   sockJsService    =     (  ( DefaultSockJsService )     ( requestHandler . getSockJsService (  )  )  )  ;", "assertNotNull ( sockJsService )  ;", "Map < TransportType ,    TransportHandler >    handlers    =    sockJsService . getTransportHandlers (  )  ;", "WebSocketTransportHandler   transportHandler    =     (  ( WebSocketTransportHandler )     ( handlers . get ( TransportType . WEBSOCKET )  )  )  ;", "assertSame ( handshakeHandler ,    transportHandler . getHandshakeHandler (  )  )  ;", "assertEquals (  2  ,    sockJsService . getHandshakeInterceptors (  )  . size (  )  )  ;", "assertEquals ( interceptor ,    sockJsService . getHandshakeInterceptors (  )  . get (  0  )  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    sockJsService . getHandshakeInterceptors (  )  . get (  1  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["handshakeHandlerInterceptorWithSockJsService"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebMvcStompWebSocketEndpointRegistration   registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "DefaultHandshakeHandler   handshakeHandler    =    new   DefaultHandshakeHandler (  )  ;", "HttpSessionHandshakeInterceptor   interceptor    =    new   HttpSessionHandshakeInterceptor (  )  ;", "String   origin    =     \" http :  /  / mydomain . com \"  ;", "registration . setHandshakeHandler ( handshakeHandler )  . addInterceptors ( interceptor )  . setAllowedOrigins ( origin )  . withSockJS (  )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "Map . Entry < HttpRequestHandler ,    List < String >  >    entry    =    mappings . entrySet (  )  . iterator (  )  . next (  )  ;", "assertEquals ( Arrays . asList (  \"  / foo /  *  *  \"  )  ,    entry . getValue (  )  )  ;", "SockJsHttpRequestHandler   requestHandler    =     (  ( SockJsHttpRequestHandler )     ( entry . getKey (  )  )  )  ;", "assertNotNull ( requestHandler . getWebSocketHandler (  )  )  ;", "DefaultSockJsService   sockJsService    =     (  ( DefaultSockJsService )     ( requestHandler . getSockJsService (  )  )  )  ;", "assertNotNull ( sockJsService )  ;", "Map < TransportType ,    TransportHandler >    handlers    =    sockJsService . getTransportHandlers (  )  ;", "WebSocketTransportHandler   transportHandler    =     (  ( WebSocketTransportHandler )     ( handlers . get ( TransportType . WEBSOCKET )  )  )  ;", "assertSame ( handshakeHandler ,    transportHandler . getHandshakeHandler (  )  )  ;", "assertEquals (  2  ,    sockJsService . getHandshakeInterceptors (  )  . size (  )  )  ;", "assertEquals ( interceptor ,    sockJsService . getHandshakeInterceptors (  )  . get (  0  )  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    sockJsService . getHandshakeInterceptors (  )  . get (  1  )  . getClass (  )  )  ;", "assertTrue ( sockJsService . getAllowedOrigins (  )  . contains ( origin )  )  ;", "}", "METHOD_END"], "methodName": ["handshakeHandlerInterceptorWithSockJsServiceAndAllowedOrigins"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebMvcStompWebSocketEndpointRegistration   registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "Map . Entry < HttpRequestHandler ,    List < String >  >    entry    =    mappings . entrySet (  )  . iterator (  )  . next (  )  ;", "assertNotNull (  (  ( WebSocketHttpRequestHandler )     ( entry . getKey (  )  )  )  . getWebSocketHandler (  )  )  ;", "assertEquals (  1  ,     (  ( WebSocketHttpRequestHandler )     ( entry . getKey (  )  )  )  . getHandshakeInterceptors (  )  . size (  )  )  ;", "assertEquals ( Arrays . asList (  \"  / foo \"  )  ,    entry . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["minimalRegistration"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebMvcStompWebSocketEndpointRegistration   registration    =    new   WebMvcStompWebSocketEndpointRegistration ( new   String [  ]  {     \"  / foo \"     }  ,    this . handler ,    this . scheduler )  ;", "registration . setAllowedOrigins (  )  ;", "MultiValueMap < HttpRequestHandler ,    String >    mappings    =    registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", "HttpRequestHandler   handler    =    mappings . entrySet (  )  . iterator (  )  . next (  )  . getKey (  )  ;", "WebSocketHttpRequestHandler   wsHandler    =     (  ( WebSocketHttpRequestHandler )     ( handler )  )  ;", "assertNotNull ( wsHandler . getWebSocketHandler (  )  )  ;", "assertEquals (  1  ,    wsHandler . getHandshakeInterceptors (  )  . size (  )  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    wsHandler . getHandshakeInterceptors (  )  . get (  0  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["sameOrigin"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "this . handler    =    new   SubProtocolWebSocketHandler ( mock ( MessageChannel . class )  ,    mock ( SubscribableChannel . class )  )  ;", "this . scheduler    =    mock ( TaskScheduler . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "return   initTaskScheduler (  )  ;", "}", "METHOD_END"], "methodName": ["defaultSockJsTaskScheduler"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . handlerRegistry )     =  =    null )     {", "this . handlerRegistry    =    new   ServletHandlerRegistry (  )  ;", "registerHandlers ( this . handlerRegistry )  ;", "}", "return   this . handlerRegistry ;", "}", "METHOD_END"], "methodName": ["initHandlerRegistry"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scheduler )     =  =    null )     {", "ServletWebSocketHandlerRegistry   registry    =    initHandlerRegistry (  )  ;", "if    ( registry . requiresTaskScheduler (  )  )     {", "ThreadPoolTaskScheduler   threadPoolScheduler    =    new   ThreadPoolTaskScheduler (  )  ;", "threadPoolScheduler . setThreadNamePrefix (  \" SockJS -  \"  )  ;", "threadPoolScheduler . setPoolSize ( Runtime . getRuntime (  )  . availableProcessors (  )  )  ;", "threadPoolScheduler . setRemoveOnCancelPolicy ( true )  ;", "this . scheduler    =    threadPoolScheduler ;", "} else    {", "this . scheduler    =    new    . NoOpScheduler (  )  ;", "}", "}", "return   this . scheduler ;", "}", "METHOD_END"], "methodName": ["initTaskScheduler"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "ServletWebSocketHandlerRegistry   registry    =    initHandlerRegistry (  )  ;", "if    ( registry . requiresTaskScheduler (  )  )     {", "registry . setTaskScheduler ( initTaskScheduler (  )  )  ;", "}", "return   registry . getHandlerMapping (  )  ;", "}", "METHOD_END"], "methodName": ["webSocketHandlerMapping"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( new   Object [  ]  [  ]  {    new   Object [  ]  {    new   JettyWebSocketTestServer (  )  ,    new   JettyWebSocketClient (  )     }  ,    new   Object [  ]  {    new   TomcatWebSocketTestServer (  )  ,    new   StandardWebSocketClient (  )     }  ,    new   Object [  ]  {    new   UndertowTestServer (  )  ,    new   StandardWebSocketClient (  )     }     }  )  ;", "}", "METHOD_END"], "methodName": ["arguments"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketSession   session    =    this . webSocketClient . doHandshake ( new   AbstractWebSocketHandler (  )     {  }  ,     (  ( getWsBaseUrl (  )  )     +     \"  / ws \"  )  )  . get (  )  ;", ". TestHandler   serverHandler    =    this . wac . getBean (  . TestHandler . class )  ;", "assertTrue ( serverHandler . connectLatch . await (  2  ,    TimeUnit . SECONDS )  )  ;", "session . close (  )  ;", "}", "METHOD_END"], "methodName": ["registerWebSocketHandler"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketSession   session    =    this . webSocketClient . doHandshake ( new   AbstractWebSocketHandler (  )     {  }  ,     (  ( getWsBaseUrl (  )  )     +     \"  / sockjs / websocket \"  )  )  . get (  )  ;", ". TestHandler   serverHandler    =    this . wac . getBean (  . TestHandler . class )  ;", "assertTrue ( serverHandler . connectLatch . await (  2  ,    TimeUnit . SECONDS )  )  ;", "session . close (  )  ;", "}", "METHOD_END"], "methodName": ["registerWebSocketHandlerWithSockJS"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "HttpSessionHandshakeInterceptor   interceptor    =    new   HttpSessionHandshakeInterceptor (  )  ;", "this . registration . addHandler ( handler ,     \"  / foo \"  )  . addInterceptors ( interceptor )  . setAllowedOrigins (  )  ;", "List <  . Mapping >    mappings    =    this . registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", ". Mapping   mapping    =    mappings . get (  0  )  ;", "assertEquals ( handler ,    mapping . webSocketHandler )  ;", "assertEquals (  \"  / foo \"  ,    mapping . path )  ;", "assertNotNull ( mapping . interceptors )  ;", "assertEquals (  2  ,    mapping . interceptors . length )  ;", "assertEquals ( interceptor ,    mapping . interceptors [  0  ]  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    mapping . interceptors [  1  ]  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyAllowedOrigin"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketHandlerRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "HandshakeHandler   handshakeHandler    =    new   DefaultHandshakeHandler (  )  ;", "this . registration . addHandler ( handler ,     \"  / foo \"  )  . setHandshakeHandler ( handshakeHandler )  ;", "List <  . Mapping >    mappings    =    this . registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", ". Mapping   mapping    =    mappings . get (  0  )  ;", "assertEquals ( handler ,    mapping . webSocketHandler )  ;", "assertEquals (  \"  / foo \"  ,    mapping . path )  ;", "assertSame ( handshakeHandler ,    mapping . handshakeHandler )  ;", "}", "METHOD_END"], "methodName": ["handshakeHandler"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketHandlerRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "HandshakeHandler   handshakeHandler    =    new   DefaultHandshakeHandler (  )  ;", "this . registration . addHandler ( handler ,     \"  / foo \"  )  . setHandshakeHandler ( handshakeHandler )  . withSockJS (  )  ;", "this . registration . getSockJsServiceRegistration (  )  . setTaskScheduler ( this . taskScheduler )  ;", "List <  . Mapping >    mappings    =    this . registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", ". Mapping   mapping    =    mappings . get (  0  )  ;", "assertEquals ( handler ,    mapping . webSocketHandler )  ;", "assertEquals (  \"  / foo /  *  *  \"  ,    mapping . path )  ;", "assertNotNull ( mapping . sockJsService )  ;", "WebSocketTransportHandler   transportHandler    =     (  ( WebSocketTransportHandler )     ( mapping . sockJsService . getTransportHandlers (  )  . get ( TransportType . WEBSOCKET )  )  )  ;", "assertSame ( handshakeHandler ,    transportHandler . getHandshakeHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["handshakeHandlerPassedToSockJsRegistration"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketHandlerRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "HttpSessionHandshakeInterceptor   interceptor    =    new   HttpSessionHandshakeInterceptor (  )  ;", "this . registration . addHandler ( handler ,     \"  / foo \"  )  . addInterceptors ( interceptor )  ;", "List <  . Mapping >    mappings    =    this . registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", ". Mapping   mapping    =    mappings . get (  0  )  ;", "assertEquals ( handler ,    mapping . webSocketHandler )  ;", "assertEquals (  \"  / foo \"  ,    mapping . path )  ;", "assertNotNull ( mapping . interceptors )  ;", "assertEquals (  2  ,    mapping . interceptors . length )  ;", "assertEquals ( interceptor ,    mapping . interceptors [  0  ]  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    mapping . interceptors [  1  ]  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["interceptors"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketHandlerRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "HttpSessionHandshakeInterceptor   interceptor    =    new   HttpSessionHandshakeInterceptor (  )  ;", "this . registration . addHandler ( handler ,     \"  / foo \"  )  . addInterceptors ( interceptor )  . setAllowedOrigins (  \" http :  /  / mydomain 1  . com \"  )  . withSockJS (  )  ;", "this . registration . getSockJsServiceRegistration (  )  . setTaskScheduler ( this . taskScheduler )  ;", "List <  . Mapping >    mappings    =    this . registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", ". Mapping   mapping    =    mappings . get (  0  )  ;", "assertEquals ( handler ,    mapping . webSocketHandler )  ;", "assertEquals (  \"  / foo /  *  *  \"  ,    mapping . path )  ;", "assertNotNull ( mapping . sockJsService )  ;", "assertTrue ( mapping . sockJsService . getAllowedOrigins (  )  . contains (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "List < HandshakeInterceptor >    interceptors    =    mapping . sockJsService . getHandshakeInterceptors (  )  ;", "assertEquals ( interceptor ,    interceptors . get (  0  )  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    interceptors . get (  1  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["interceptorsPassedToSockJsRegistration"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketHandlerRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "HttpSessionHandshakeInterceptor   interceptor    =    new   HttpSessionHandshakeInterceptor (  )  ;", "this . registration . addHandler ( handler ,     \"  / foo \"  )  . addInterceptors ( interceptor )  . setAllowedOrigins (  \" http :  /  / mydomain 1  . com \"  )  ;", "List <  . Mapping >    mappings    =    this . registration . getMappings (  )  ;", "assertEquals (  1  ,    mappings . size (  )  )  ;", ". Mapping   mapping    =    mappings . get (  0  )  ;", "assertEquals ( handler ,    mapping . webSocketHandler )  ;", "assertEquals (  \"  / foo \"  ,    mapping . path )  ;", "assertNotNull ( mapping . interceptors )  ;", "assertEquals (  2  ,    mapping . interceptors . length )  ;", "assertEquals ( interceptor ,    mapping . interceptors [  0  ]  )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    mapping . interceptors [  1  ]  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["interceptorsWithAllowedOrigins"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketHandlerRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "this . registration . addHandler ( handler ,     \"  / foo \"  ,     \"  / bar \"  )  ;", "List <  . Mapping >    mappings    =    this . registration . getMappings (  )  ;", "assertEquals (  2  ,    mappings . size (  )  )  ;", ". Mapping   m 1     =    mappings . get (  0  )  ;", "assertEquals ( handler ,    m 1  . webSocketHandler )  ;", "assertEquals (  \"  / foo \"  ,    m 1  . path )  ;", "assertNotNull ( m 1  . interceptors )  ;", "assertEquals (  1  ,    m 1  . interceptors . length )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    m 1  . interceptors [  0  ]  . getClass (  )  )  ;", ". Mapping   m 2     =    mappings . get (  1  )  ;", "assertEquals ( handler ,    m 2  . webSocketHandler )  ;", "assertEquals (  \"  / bar \"  ,    m 2  . path )  ;", "assertNotNull ( m 2  . interceptors )  ;", "assertEquals (  1  ,    m 2  . interceptors . length )  ;", "assertEquals ( OriginHandshakeInterceptor . class ,    m 2  . interceptors [  0  ]  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["minimal"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketHandlerRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "this . taskScheduler    =    Mockito . mock ( TaskScheduler . class )  ;", "this . registration    =    new    . TestWebSocketHandlerRegistration (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketHandlerRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "for    ( WebSocketHandlerDecoratorFactory   factory    :    getTransportRegistration (  )  . getDecoratorFactories (  )  )     {", "handler    =    factory . decorate ( handler )  ;", "}", "return   handler ;", "}", "METHOD_END"], "methodName": ["decorateWebSocketHandler"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . transportRegistration )     =  =    null )     {", "this . transportRegistration    =    new   TransportRegistration (  )  ;", "configureTransport ( this . transportRegistration )  ;", "}", "return   this . transportRegistration ;", "}", "METHOD_END"], "methodName": ["getTransportRegistration"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    decorateWebSocketHandler ( subProtocolWebSocketHandler (  )  )  ;", "WebMvcStompEndpointRegistry   registry    =    new   WebMvcStompEndpointRegistry ( handler ,    getTransportRegistration (  )  ,    mTaskScheduler (  )  )  ;", "ApplicationContext   applicationContext    =    getApplicationContext (  )  ;", "if    ( applicationContext    !  =    null )     {", "registry . setApplicationContext ( applicationContext )  ;", "}", "registerStompEndpoints ( registry )  ;", "return   registry . getHandlerMapping (  )  ;", "}", "METHOD_END"], "methodName": ["stompWebSocketHandlerMapping"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   SubProtocolWebSocketHandler ( clientInboundChannel (  )  ,    clientOutboundChannel (  )  )  ;", "}", "METHOD_END"], "methodName": ["subProtocolWebSocketHandler"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "AbstractBrokerMessageHandler   relayBean    =    stompBrokerRelayMessageHandler (  )  ;", "stompWebSocketHandlerMapping (  )  ;", "Stats   stats    =    new   Stats (  )  ;", "stats . setSubProtocolWebSocketHandler (  (  ( SubProtocolWebSocketHandler )     ( subProtocolWebSocketHandler (  )  )  )  )  ;", "if    ( relayBean   instanceof   StompBrokerRelayMessageHandler )     {", "stats . setStompBrokerRelay (  (  ( StompBrokerRelayMessageHandler )     ( relayBean )  )  )  ;", "}", "stats . setInboundChannelExecutor ( clientInboundChannelExecutor (  )  )  ;", "stats . setOutboundChannelExecutor ( clientOutboundChannelExecutor (  )  )  ;", "stats . setSockJsTaskScheduler ( messageBrokerTaskScheduler (  )  )  ;", "return   stats ;", "}", "METHOD_END"], "methodName": ["webSocketMessageBrokerStats"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "CustomScopeConfigurer   configurer    =    new   CustomScopeConfigurer (  )  ;", "configurer . addScope (  \" websocket \"  ,    new   SimpSessionScope (  )  )  ;", "return   configurer ;", "}", "METHOD_END"], "methodName": ["webSocketScopeConfigurer"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   config    =    createConfig ( WebSocketMessageBrokerConfigurationSupportTests . TestChannelConfig . class ,    WebSocketMessageBrokerConfigurationSupportTests . TestConfigurer . class )  ;", "WebSocketMessageBrokerConfigurationSupportTests . TestChannel   channel    =    config . getBean (  \" brokerChannel \"  ,    WebSocketMessageBrokerConfigurationSupportTests . TestChannel . class )  ;", "Set < MessageHandler >    handlers    =    channel . getSubscribers (  )  ;", "List < ChannelInterceptor >    interceptors    =    channel . getInterceptors (  )  ;", "assertEquals ( ImmutableMessageChannelInterceptor . class ,    interceptors . get (  (  ( interceptors . size (  )  )     -     1  )  )  . getClass (  )  )  ;", "assertEquals (  2  ,    handlers . size (  )  )  ;", "assertTrue ( handlers . contains ( config . getBean ( SimpleBrokerMessageHandler . class )  )  )  ;", "assertTrue ( handlers . contains ( config . getBean ( UserDestinationMessageHandler . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["brokerChannel"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   config    =    createConfig ( WebSocketMessageBrokerConfigurationSupportTests . TestChannelConfig . class ,    WebSocketMessageBrokerConfigurationSupportTests . TestConfigurer . class )  ;", "WebSocketMessageBrokerConfigurationSupportTests . TestChannel   channel    =    config . getBean (  \" clientInboundChannel \"  ,    WebSocketMessageBrokerConfigurationSupportTests . TestChannel . class )  ;", "SubProtocolWebSocketHandler   webSocketHandler    =    config . getBean ( SubProtocolWebSocketHandler . class )  ;", "List < ChannelInterceptor >    interceptors    =    channel . getInterceptors (  )  ;", "assertEquals ( ImmutableMessageChannelInterceptor . class ,    interceptors . get (  (  ( interceptors . size (  )  )     -     1  )  )  . getClass (  )  )  ;", "TestWebSocketSession   session    =    new   TestWebSocketSession (  \" s 1  \"  )  ;", "session . setOpen ( true )  ;", "webSocketHandler . afterConnectionEstablished ( session )  ;", "TextMessage   textMessage    =    StompTextMessageBuilder . create ( SEND )  . headers (  \" destination :  / foo \"  )  . build (  )  ;", "webSocketHandler . handleMessage ( session ,    textMessage )  ;", "Message <  ?  >    message    =    channel . messages . get (  0  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "assertNotNull ( accessor )  ;", "assertFalse ( accessor . isMutable (  )  )  ;", "assertEquals ( MESSAGE ,    accessor . getMessageType (  )  )  ;", "assertEquals (  \"  / foo \"  ,    accessor . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["clientInboundChannelSendMessage"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   config    =    createConfig ( WebSocketMessageBrokerConfigurationSupportTests . TestChannelConfig . class ,    WebSocketMessageBrokerConfigurationSupportTests . TestConfigurer . class )  ;", "WebSocketMessageBrokerConfigurationSupportTests . TestChannel   channel    =    config . getBean (  \" clientOutboundChannel \"  ,    WebSocketMessageBrokerConfigurationSupportTests . TestChannel . class )  ;", "Set < MessageHandler >    handlers    =    channel . getSubscribers (  )  ;", "List < ChannelInterceptor >    interceptors    =    channel . getInterceptors (  )  ;", "assertEquals ( ImmutableMessageChannelInterceptor . class ,    interceptors . get (  (  ( interceptors . size (  )  )     -     1  )  )  . getClass (  )  )  ;", "assertEquals (  1  ,    handlers . size (  )  )  ;", "assertTrue ( handlers . contains ( config . getBean ( SubProtocolWebSocketHandler . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["clientOutboundChannel"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   config    =    new   AnnotationConfigApplicationContext (  )  ;", "config . register ( configClasses )  ;", "config . refresh (  )  ;", "return   config ;", "}", "METHOD_END"], "methodName": ["createConfig"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   config    =    createConfig ( WebSocketMessageBrokerConfigurationSupportTests . TestChannelConfig . class ,    WebSocketMessageBrokerConfigurationSupportTests . TestConfigurer . class )  ;", "SimpleUrlHandlerMapping   hm    =     (  ( SimpleUrlHandlerMapping )     ( config . getBean ( HandlerMapping . class )  )  )  ;", "assertEquals (  1  ,    hm . getOrder (  )  )  ;", "Map < String ,    Object >    handlerMap    =    hm . getHandlerMap (  )  ;", "assertEquals (  1  ,    handlerMap . size (  )  )  ;", "assertNotNull ( handlerMap . get (  \"  / simpleBroker \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handlerMapping"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   config    =    createConfig ( WebSocketMessageBrokerConfigurationSupportTests . TestChannelConfig . class ,    WebSocketMessageBrokerConfigurationSupportTests . TestConfigurer . class )  ;", "String   name    =     \" messageBrokerSockJsTaskScheduler \"  ;", "ThreadPoolTaskScheduler   taskScheduler    =    config . getBean ( name ,    ThreadPoolTaskScheduler . class )  ;", "ScheduledThreadPoolExecutor   executor    =    taskScheduler . getScheduledThreadPoolExecutor (  )  ;", "assertEquals ( Runtime . getRuntime (  )  . availableProcessors (  )  ,    executor . getCorePoolSize (  )  )  ;", "assertTrue ( executor . getRemoveOnCancelPolicy (  )  )  ;", "SimpleBrokerMessageHandler   handler    =    config . getBean ( SimpleBrokerMessageHandler . class )  ;", "assertNotNull ( handler . getTaskScheduler (  )  )  ;", "assertArrayEquals ( new   long [  ]  {     1  5  0  0  0  ,     1  5  0  0  0     }  ,    handler . getHeartbeatValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["taskScheduler"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   config    =    createConfig ( WebSocketMessageBrokerConfigurationSupportTests . TestChannelConfig . class ,    WebSocketMessageBrokerConfigurationSupportTests . TestConfigurer . class )  ;", "SubProtocolWebSocketHandler   subWsHandler    =    config . getBean ( SubProtocolWebSocketHandler . class )  ;", "assertEquals (  (  1  0  2  4     *     1  0  2  4  )  ,    subWsHandler . getSendBufferSizeLimit (  )  )  ;", "assertEquals (  (  2  5     *     1  0  0  0  )  ,    subWsHandler . getSendTimeLimit (  )  )  ;", "Map < String ,    SubProtocolHandler >    handlerMap    =    subWsHandler . getProtocolHandlerMap (  )  ;", "StompSubProtocolHandler   protocolHandler    =     (  ( StompSubProtocolHandler )     ( handlerMap . get (  \" v 1  2  . stomp \"  )  )  )  ;", "assertEquals (  (  1  2  8     *     1  0  2  4  )  ,    protocolHandler . getMessageSizeLimit (  )  )  ;", "}", "METHOD_END"], "methodName": ["webSocketHandler"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   config    =    createConfig ( WebSocketMessageBrokerConfigurationSupportTests . WebSocketHandlerDecoratorConfig . class )  ;", "WebSocketHandler   handler    =    config . getBean ( SubProtocolWebSocketHandler . class )  ;", "assertNotNull ( handler )  ;", "SimpleUrlHandlerMapping   mapping    =     (  ( SimpleUrlHandlerMapping )     ( config . getBean (  \" stompWebSocketHandlerMapping \"  )  )  )  ;", "WebSocketHttpRequestHandler   httpHandler    =     (  ( WebSocketHttpRequestHandler )     ( mapping . getHandlerMap (  )  . get (  \"  / test \"  )  )  )  ;", "handler    =    httpHandler . getWebSocketHandler (  )  ;", "WebSocketSession   session    =    new   TestWebSocketSession (  \" id \"  )  ;", "handler . afterConnectionEstablished ( session )  ;", "assertEquals ( true ,    session . getAttributes (  )  . get (  \" decorated \"  )  )  ;", "}", "METHOD_END"], "methodName": ["webSocketHandlerDecorator"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   config    =    createConfig ( WebSocketMessageBrokerConfigurationSupportTests . TestChannelConfig . class ,    WebSocketMessageBrokerConfigurationSupportTests . TestConfigurer . class )  ;", "String   name    =     \" webSocketMessageBrokerStats \"  ;", "WebSocketMessageBrokerStats   stats    =    config . getBean ( name ,    WebSocketMessageBrokerStats . class )  ;", "String   actual    =    stats . toString (  )  ;", "String   expected    =     \" WebSocketSession \\  \\  [  0    current   WS \\  \\  (  0  \\  \\  )  - HttpStream \\  \\  (  0  \\  \\  )  - HttpPoll \\  \\  (  0  \\  \\  )  ,     \"     +     (  (  (  (  (  \"  0    total ,     0    closed   abnormally    \\  \\  (  0    connect   failure ,     0    send   limit ,     0    transport   error \\  \\  )  \\  \\  ]  ,     \"     +     \" stompSubProtocol \\  \\  [ processed   CONNECT \\  \\  (  0  \\  \\  )  - CONNECTED \\  \\  (  0  \\  \\  )  - DISCONNECT \\  \\  (  0  \\  \\  )  \\  \\  ]  ,     \"  )     +     \" stompBrokerRelay \\  \\  [ null \\  \\  ]  ,     \"  )     +     \" inboundChannel \\  \\  [ pool   size    =     \\  \\ d ,    active   threads    =     \\  \\ d ,    queued   tasks    =     \\  \\ d ,    completed   tasks    =     \\  \\ d \\  \\  ]  ,     \"  )     +     \" outboundChannelpool   size    =     \\  \\ d ,    active   threads    =     \\  \\ d ,    queued   tasks    =     \\  \\ d ,    completed   tasks    =     \\  \\ d \\  \\  ]  ,     \"  )     +     \" sockJsScheduler \\  \\  [ pool   size    =     \\  \\ d ,    active   threads    =     \\  \\ d ,    queued   tasks    =     \\  \\ d ,    completed   tasks    =     \\  \\ d \\  \\  ]  \"  )  ;", "assertTrue (  (  (  (  \"  \\ nExpected :     \"     +     ( expected . replace (  \"  \\  \\  \"  ,     \"  \"  )  )  )     +     \"  \\ n      Actual :     \"  )     +    actual )  ,    actual . matches ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["webSocketMessageBrokerStats"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupportTests"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["configureMessageConverters"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . decoratorFactories . add ( factory )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addDecoratorFactory"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketTransportRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . decoratorFactories ;", "}", "METHOD_END"], "methodName": ["getDecoratorFactories"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketTransportRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSizeLimit ;", "}", "METHOD_END"], "methodName": ["getMessageSizeLimit"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketTransportRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . sendBufferSizeLimit ;", "}", "METHOD_END"], "methodName": ["getSendBufferSizeLimit"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketTransportRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . sendTimeLimit ;", "}", "METHOD_END"], "methodName": ["getSendTimeLimit"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketTransportRegistration"}, {"methodBody": ["METHOD_START", "{", "this . decoratorFactories . addAll ( Arrays . asList ( factories )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDecoratorFactories"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketTransportRegistration"}, {"methodBody": ["METHOD_START", "{", "this . messageSizeLimit    =    messageSizeLimit ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setMessageSizeLimit"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketTransportRegistration"}, {"methodBody": ["METHOD_START", "{", "this . sendBufferSizeLimit    =    sendBufferSizeLimit ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSendBufferSizeLimit"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketTransportRegistration"}, {"methodBody": ["METHOD_START", "{", "this . sendTimeLimit    =    timeLimit ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSendTimeLimit"], "fileName": "org.springframework.web.socket.config.annotation.WebSocketTransportRegistration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )     !  =    null )     {", "this . beanFactory . destroyBean (  )  ;", "}", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.springframework.web.socket.handler.BeanCreatingHandlerProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )     !  =    null )     {", "return   this . beanFactory . createBean ( thisType )  ;", "} else    {", "return   BeanUtils . instantiateClass ( thisType )  ;", "}", "}", "METHOD_END"], "methodName": ["getHandler"], "fileName": "org.springframework.web.socket.handler.BeanCreatingHandlerProvider"}, {"methodBody": ["METHOD_START", "{", "return   this . handlerType ;", "}", "METHOD_END"], "methodName": ["getHandlerType"], "fileName": "org.springframework.web.socket.handler.BeanCreatingHandlerProvider"}, {"methodBody": ["METHOD_START", "{", "BeanCreatingHandlerProvider < BeanCreatingHandlerProviderTests . EchoHandler >    provider    =    new   BeanCreatingHandlerProvider <  >  ( BeanCreatingHandlerProviderTests . EchoHandler . class )  ;", "provider . getHandler (  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerNoBeanFactory"], "fileName": "org.springframework.web.socket.handler.BeanCreatingHandlerProviderTests"}, {"methodBody": ["METHOD_START", "{", "BeanCreatingHandlerProvider < BeanCreatingHandlerProviderTests . SimpleEchoHandler >    provider    =    new   BeanCreatingHandlerProvider <  >  ( BeanCreatingHandlerProviderTests . SimpleEchoHandler . class )  ;", "assertNotNull ( provider . getHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerSimpleInstantiation"], "fileName": "org.springframework.web.socket.handler.BeanCreatingHandlerProviderTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" resource \"  )", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext (  . Config . class )  ;", "BeanCreatingHandlerProvider <  . EchoHandler >    provider    =    new   BeanCreatingHandlerProvider <  >  (  . EchoHandler . class )  ;", "provider . setBeanFactory ( context . getBeanFactory (  )  )  ;", "assertNotNull ( provider . getHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerWithBeanFactory"], "fileName": "org.springframework.web.socket.handler.BeanCreatingHandlerProviderTests"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( shouldNotSend (  )  )  )     &  &     ( this . closeLock . tryLock (  )  )  )     {", "try    {", "if    (  ( getTimeSinceSendStarted (  )  )     >     ( getSendTimeLimit (  )  )  )     {", "String   format    =     \" Message   send   time    % d    ( ms )    for   s    '  % s '    exceeded   the   allowed   limit    % d \"  ;", "String   reason    =    String . format ( format ,    getTimeSinceSendStarted (  )  ,    getId (  )  ,    getSendTimeLimit (  )  )  ;", "limitExceeded ( reason )  ;", "} else", "if    (  ( getBufferSize (  )  )     >     ( getBufferSizeLimit (  )  )  )     {", "String   format    =     \" The   send   buffer   size    % d   bytes   for   s    '  % s '    exceeded   the   allowed   limit    % d \"  ;", "String   reason    =    String . format ( format ,    getBufferSize (  )  ,    getId (  )  ,    getBufferSizeLimit (  )  )  ;", "limitExceeded ( reason )  ;", "}", "}    finally    {", "this . closeLock . unlock (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkSessionLimits"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "return   this . bufferSize . get (  )  ;", "}", "METHOD_END"], "methodName": ["getBufferSize"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "return   this . bufferSizeLimit ;", "}", "METHOD_END"], "methodName": ["getBufferSizeLimit"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "return   this . sendTimeLimit ;", "}", "METHOD_END"], "methodName": ["getSendTimeLimit"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "long   start    =    this . sendStartTime ;", "return   start    >     0     ?     ( System . TimeMillis (  )  )     -    start    :     0  ;", "}", "METHOD_END"], "methodName": ["getTimeSinceSendStarted"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "this . limitExceeded    =    true ;", "throw   new   LimitExceededException ( reason ,    CloseStatus . SESSION _ NOT _ RELIABLE )  ;", "}", "METHOD_END"], "methodName": ["limitExceeded"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "return    ( this . limitExceeded )     |  |     ( this . closeInProgress )  ;", "}", "METHOD_END"], "methodName": ["shouldNotSend"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "if    ( this . flushLock . tryLock (  )  )     {", "try    {", "while    ( true )     {", "Message <  ?  >    message    =    this . buffer . poll (  )  ;", "if    (  ( message    =  =    null )     |  |     ( shouldNotSend (  )  )  )     {", "break ;", "}", "this . bufferSize . addAndGet (  (  ( message . getPayloadLength (  )  )     *     (  -  1  )  )  )  ;", "this . sendStartTime    =    System . currentTimeMillis (  )  ;", "getDelegate (  )  . sendMessage ( message )  ;", "this . sendStartTime    =     0  ;", "}", "}    finally    {", "this . sendStartTime    =     0  ;", "flushLock . unlock (  )  ;", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["tryFlushMessageBuffer"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "ConcurrentWebSocketSessionDecoratorTests . BlockingSession   blockingSession    =    new   ConcurrentWebSocketSessionDecoratorTests . BlockingSession (  )  ;", "blockingSession . setId (  \"  1  2  3  \"  )  ;", "blockingSession . setOpen ( true )  ;", "CountDownLatch   sentMessageLatch    =    blockingSession . getSentMessageLatch (  )  ;", "int   sendTimeLimit    =     1  0  0  ;", "int   bufferSizeLimit    =     1  0  2  4  ;", "final   ConcurrentWebSocketSessionDecorator   concurrentSession    =    new   ConcurrentWebSocketSessionDecorator ( blockingSession ,    sendTimeLimit ,    bufferSizeLimit )  ;", "Executors . newSingleThreadExecutor (  )  . submit (  (  ( Runnable )     (  (  )     -  >     {", "TextMessage   message    =    new   TextMessage (  \" slow   message \"  )  ;", "try    {", "concurrentSession . sendMessage ( message )  ;", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}", "}  )  )  )  ;", "assertTrue ( sentMessageLatch . await (  5  ,    TimeUnit . SECONDS )  )  ;", "Thread . sleep (  ( sendTimeLimit    +     1  0  0  )  )  ;", "concurrentSession . close ( CloseStatus . PROTOCOL _ ERROR )  ;", "assertEquals (  \" CloseStatus   should   have   changed   to   SESSION _ NOT _ RELIABLE \"  ,    CloseStatus . SESSION _ NOT _ RELIABLE ,    blockingSession . getCloseStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["closeStatusChangesToSessionNotReliable"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentWebSocketSessionDecoratorTests . BlockingSession   delegate    =    new   ConcurrentWebSocketSessionDecoratorTests . BlockingSession (  )  ;", "delegate . setOpen ( true )  ;", "WebSocketSession   decorator    =    new   ConcurrentWebSocketSessionDecorator ( delegate ,     (  1  0     *     1  0  0  0  )  ,     1  0  2  4  )  ;", "decorator . close ( CloseStatus . PROTOCOL _ ERROR )  ;", "assertEquals ( CloseStatus . PROTOCOL _ ERROR ,    delegate . getCloseStatus (  )  )  ;", "decorator . close ( CloseStatus . SERVER _ ERROR )  ;", "assertEquals (  \" Should   have   been   ignored \"  ,    CloseStatus . PROTOCOL _ ERROR ,    delegate . getCloseStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["closeStatusNormal"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "TestWebSocketSession   session    =    new   TestWebSocketSession (  )  ;", "session . setOpen ( true )  ;", "concurrentSession    =    new    ( session ,     1  0  0  0  ,     1  0  2  4  )  ;", "TextMessage   textMessage    =    new   TextMessage (  \" payload \"  )  ;", "concurrentSession . sendMessage ( textMessage )  ;", "assertEquals (  1  ,    session . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( textMessage ,    session . getSentMessages (  )  . get (  0  )  )  ;", "assertEquals (  0  ,    concurrentSession . getBufferSize (  )  )  ;", "assertEquals (  0  ,    concurrentSession . getTimeSinceSendStarted (  )  )  ;", "assertTrue ( session . isOpen (  )  )  ;", "}", "METHOD_END"], "methodName": ["send"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentWebSocketSessionDecoratorTests . BlockingSession   blockingSession    =    new   ConcurrentWebSocketSessionDecoratorTests . BlockingSession (  )  ;", "blockingSession . setOpen ( true )  ;", "CountDownLatch   sentMessageLatch    =    blockingSession . getSentMessageLatch (  )  ;", "final   ConcurrentWebSocketSessionDecorator   concurrentSession    =    new   ConcurrentWebSocketSessionDecorator ( blockingSession ,     (  1  0     *     1  0  0  0  )  ,     1  0  2  4  )  ;", "Executors . newSingleThreadExecutor (  )  . submit (  (  ( Runnable )     (  (  )     -  >     {", "TextMessage   message    =    new   TextMessage (  \" slow   message \"  )  ;", "try    {", "concurrentSession . sendMessage ( message )  ;", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}", "}  )  )  )  ;", "assertTrue ( sentMessageLatch . await (  5  ,    TimeUnit . SECONDS )  )  ;", "Thread . sleep (  1  0  0  )  ;", "assertTrue (  (  ( concurrentSession . getTimeSinceSendStarted (  )  )     >     0  )  )  ;", "TextMessage   payload    =    new   TextMessage (  \" payload \"  )  ;", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )     {", "concurrentSession . sendMessage ( payload )  ;", "}", "assertTrue (  (  ( concurrentSession . getTimeSinceSendStarted (  )  )     >     0  )  )  ;", "assertEquals (  (  5     *     ( payload . getPayloadLength (  )  )  )  ,    concurrentSession . getBufferSize (  )  )  ;", "assertTrue ( blockingSession . isOpen (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendAfterBlockedSend"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentWebSocketSessionDecoratorTests . BlockingSession   blockingSession    =    new   ConcurrentWebSocketSessionDecoratorTests . BlockingSession (  )  ;", "blockingSession . setId (  \"  1  2  3  \"  )  ;", "blockingSession . setOpen ( true )  ;", "CountDownLatch   sentMessageLatch    =    blockingSession . getSentMessageLatch (  )  ;", "int   sendTimeLimit    =     1  0     *     1  0  0  0  ;", "int   bufferSizeLimit    =     1  0  2  4  ;", "final   ConcurrentWebSocketSessionDecorator   concurrentSession    =    new   ConcurrentWebSocketSessionDecorator ( blockingSession ,    sendTimeLimit ,    bufferSizeLimit )  ;", "Executors . newSingleThreadExecutor (  )  . submit (  (  ( Runnable )     (  (  )     -  >     {", "TextMessage   message    =    new   TextMessage (  \" slow   message \"  )  ;", "try    {", "concurrentSession . sendMessage ( message )  ;", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}", "}  )  )  )  ;", "assertTrue ( sentMessageLatch . await (  5  ,    TimeUnit . SECONDS )  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  2  3  ;    i +  +  )     {", "sb . append (  \" a \"  )  ;", "}", "TextMessage   message    =    new   TextMessage ( sb . toString (  )  )  ;", "concurrentSession . sendMessage ( message )  ;", "assertEquals (  1  0  2  3  ,    concurrentSession . getBufferSize (  )  )  ;", "assertTrue ( blockingSession . isOpen (  )  )  ;", "try    {", "concurrentSession . sendMessage ( message )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( SessionLimitExceededException   ex )     {", "String   actual    =    ex . getMessage (  )  ;", "String   regex    =     \" The   send   buffer   size    [  \\  \\ d ]  +    bytes   for   session    \\  '  1  2  3  \\  '    exceeded   the   allowed   limit    1  0  2  4  \"  ;", "assertTrue (  (  \" Unexpected   message :     \"     +    actual )  ,    actual . matches ( regex )  )  ;", "assertEquals ( CloseStatus . SESSION _ NOT _ RELIABLE ,    ex . getStatus (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sendBufferSizeExceeded"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentWebSocketSessionDecoratorTests . BlockingSession   blockingSession    =    new   ConcurrentWebSocketSessionDecoratorTests . BlockingSession (  )  ;", "blockingSession . setId (  \"  1  2  3  \"  )  ;", "blockingSession . setOpen ( true )  ;", "CountDownLatch   sentMessageLatch    =    blockingSession . getSentMessageLatch (  )  ;", "int   sendTimeLimit    =     1  0  0  ;", "int   bufferSizeLimit    =     1  0  2  4  ;", "final   ConcurrentWebSocketSessionDecorator   concurrentSession    =    new   ConcurrentWebSocketSessionDecorator ( blockingSession ,    sendTimeLimit ,    bufferSizeLimit )  ;", "Executors . newSingleThreadExecutor (  )  . submit (  (  ( Runnable )     (  (  )     -  >     {", "TextMessage   message    =    new   TextMessage (  \" slow   message \"  )  ;", "try    {", "concurrentSession . sendMessage ( message )  ;", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}", "}  )  )  )  ;", "assertTrue ( sentMessageLatch . await (  5  ,    TimeUnit . SECONDS )  )  ;", "Thread . sleep (  ( sendTimeLimit    +     1  0  0  )  )  ;", "try    {", "TextMessage   payload    =    new   TextMessage (  \" payload \"  )  ;", "concurrentSession . sendMessage ( payload )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( SessionLimitExceededException   ex )     {", "String   actual    =    ex . getMessage (  )  ;", "String   regex    =     \" Message   send   time    [  \\  \\ d ]  +     \\  \\  ( ms \\  \\  )    for   session    \\  '  1  2  3  \\  '    exceeded   the   allowed   limit    1  0  0  \"  ;", "assertTrue (  (  \" Unexpected   message :     \"     +    actual )  ,    actual . matches ( regex )  )  ;", "assertEquals ( CloseStatus . SESSION _ NOT _ RELIABLE ,    ex . getStatus (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sendTimeLimitExceeded"], "fileName": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  \" Closing   session   due   to   e   for    \"     +    session )  ,    e )  ;", "}", "if    ( session . isOpen (  )  )     {", "try    {", "session . close ( CloseStatus . SERVER _ ERROR )  ;", "}    catch    ( Throwable   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["tryCloseWithError"], "fileName": "org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecorator"}, {"methodBody": ["METHOD_START", "{", "CloseStatus   closeStatus    =    CloseStatus . NORMAL ;", "willThrow ( new   IllegalState (  \" error \"  )  )  . given ( this . delegate )  . afterConnectionClosed ( this . session ,    closeStatus )  ;", "this . decorator . afterConnectionClosed ( this . session ,    closeStatus )  ;", "assertNull ( this . session . getCloseStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["afterConnectionClosed"], "fileName": "org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "willThrow ( new   IllegalStateException (  \" error \"  )  )  . given ( this . delegate )  . afterConnectionEstablished ( this . session )  ;", "this . decorator . afterConnectionEstablished ( this . session )  ;", "assertEquals ( CloseStatus . SERVER _ ERROR ,    this . session . getCloseStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["afterConnectionEstablished"], "fileName": "org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   message    =    new   TextMessage (  \" payload \"  )  ;", "willThrow ( new   IllegalState (  \" error \"  )  )  . given ( this . delegate )  . handleMessage ( this . session ,    message )  ;", "this . decorator . handleMessage ( this . session ,    message )  ;", "assertEquals ( CloseStatus . SERVER _ ERROR ,    this . session . getCloseStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessage"], "fileName": "org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "Exception   exception    =    new   Exception (  \" transport   error \"  )  ;", "willThrow ( new   IllegalStateException (  \" error \"  )  )  . given ( this . delegate )  . handleTransportError ( this . session ,    exception )  ;", "this . decorator . handleTransportError ( this . session ,    exception )  ;", "assertEquals ( CloseStatus . SERVER _ ERROR ,    this . session . getCloseStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportError"], "fileName": "org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "this . delegate    =    mock ( WebSocketHandler . class )  ;", "this . decorator    =    new    ( this . delegate )  ;", "this . session    =    new   TestWebSocketSession (  )  ;", "this . session . setOpen ( true )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    this . handlers . remove ( session )  ;", "try    {", "if    ( handler    !  =    null )     {", "this . provider . destroy ( handler )  ;", "}", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  \" Error   while   destroying    \"     +    handler )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["destroyHandler"], "fileName": "org.springframework.web.socket.handler.PerConnectionWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    this . handlers . get ( session )  ;", "if    ( handler    =  =    null )     {", "throw   new   IllegalStateException (  (  \" WebSocketHandler   not   found   for    \"     +    session )  )  ;", "}", "return   handler ;", "}", "METHOD_END"], "methodName": ["getHandler"], "fileName": "org.springframework.web.socket.handler.PerConnectionWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" resource \"  )", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext (  )  ;", "context . refresh (  )  ;", ". EchoHandler . reset (  )  ;", "PerConnectionWebSocketHandler   handler    =    new   PerConnectionWebSocketHandler (  . EchoHandler . class )  ;", "handler . setBeanFactory ( context . getBeanFactory (  )  )  ;", "WebSocketSession   session    =    new   TestWebSocketSession (  )  ;", "handler . afterConnectionEstablished ( session )  ;", "assertEquals (  1  ,     . EchoHandler . initCount )  ;", "assertEquals (  0  ,     . EchoHandler . destroyCount )  ;", "handler . afterConnectionClosed ( session ,    CloseStatus . NORMAL )  ;", "assertEquals (  1  ,     . EchoHandler . initCount )  ;", "assertEquals (  1  ,     . EchoHandler . destroyCount )  ;", "}", "METHOD_END"], "methodName": ["afterConnectionEstablished"], "fileName": "org.springframework.web.socket.handler.PerConnectionWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . status ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.springframework.web.socket.handler.SessionLimitExceededException"}, {"methodBody": ["METHOD_START", "{", "return   this . protocol ;", "}", "METHOD_END"], "methodName": ["getAcceptedProtocol"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "return   this . status ;", "}", "METHOD_END"], "methodName": ["getCloseStatus"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "return   this . messages ;", "}", "METHOD_END"], "methodName": ["getSentMessages"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . protocol    =    protocol ;", "}", "METHOD_END"], "methodName": ["setAcceptedProtocol"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . attributes    =    attributes ;", "}", "METHOD_END"], "methodName": ["setAttributes"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . extensions    =    extensions ;", "}", "METHOD_END"], "methodName": ["setExtensions"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . headers    =    headers ;", "}", "METHOD_END"], "methodName": ["setHeaders"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . localAddress    =    localAddress ;", "}", "METHOD_END"], "methodName": ["setLocalAddress"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . open    =    open ;", "}", "METHOD_END"], "methodName": ["setOpen"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . principal    =    principal ;", "}", "METHOD_END"], "methodName": ["setPrincipal"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . remoteAddress    =    remoteAddress ;", "}", "METHOD_END"], "methodName": ["setRemoteAddress"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "this . uri    =    uri ;", "}", "METHOD_END"], "methodName": ["setUri"], "fileName": "org.springframework.web.socket.handler.TestWebSocketSession"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.web.socket.handler.WebSocketHandlerDecorator"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   result    =    this . delegate ;", "while    ( result   instanceof    )     {", "result    =     (  (  )     ( result )  )  . getDelegate (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getLastHandler"], "fileName": "org.springframework.web.socket.handler.WebSocketHandlerDecorator"}, {"methodBody": ["METHOD_START", "{", "if    ( handler   instanceof   WebSocketHandlerDecorator )     {", "return    (  ( WebSocketHandlerDecorator )     ( handler )  )  . getLastHandler (  )  ;", "} else    {", "return   handler ;", "}", "}", "METHOD_END"], "methodName": ["unwrap"], "fileName": "org.springframework.web.socket.handler.WebSocketHandlerDecorator"}, {"methodBody": ["METHOD_START", "{", "AbstractWebSocketHandler   h 1     =    new   AbstractWebSocketHandler (  )     {  }  ;", "h 2     =    new    ( h 1  )  ;", "h 3     =    new    ( h 2  )  ;", "assertSame ( h 1  ,    h 3  . getLastHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["getLastHandler"], "fileName": "org.springframework.web.socket.handler.WebSocketHandlerDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    extensions    =    new   ArrayList <  >  (  )  ;", "extensions . add (  \" x - foo - extension ,    x - bar - extension \"  )  ;", "extensions . add (  \" x - test - extension \"  )  ;", "this . headers . put (  . SEC _ WEBSOCKET _ EXTENSIONS ,    extensions )  ;", "List < WebSocketExtension >    parsedExtensions    =    this . headers . getSecWebSocketExtensions (  )  ;", "assertThat ( parsedExtensions ,    Matchers . hasSize (  3  )  )  ;", "}", "METHOD_END"], "methodName": ["parseWebSocketExtensions"], "fileName": "org.springframework.web.socket.handler.WebSocketHttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "headers    =    new   WebSocketHttpHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.socket.handler.WebSocketHttpHeadersTests"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.web.socket.handler.WebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "WebSocketSession   result    =    this . delegate ;", "while    ( result   instanceof    )     {", "result    =     (  (  )     ( result )  )  . getDelegate (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getLastSession"], "fileName": "org.springframework.web.socket.handler.WebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "if    ( session   instanceof   WebSocketSessionDecorator )     {", "return    (  ( WebSocketSessionDecorator )     ( session )  )  . getLastSession (  )  ;", "} else    {", "return   session ;", "}", "}", "METHOD_END"], "methodName": ["unwrap"], "fileName": "org.springframework.web.socket.handler.WebSocketSessionDecorator"}, {"methodBody": ["METHOD_START", "{", "return   this . message ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.web.socket.messaging.AbstractSubProtocolEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . user ;", "}", "METHOD_END"], "methodName": ["getUser"], "fileName": "org.springframework.web.socket.messaging.AbstractSubProtocolEvent"}, {"methodBody": ["METHOD_START", "{", "Set < SimpSubscription >    result    =    new   HashSet <  >  (  )  ;", "for    (  . LocalSimpSession   session    :    this . sessions . values (  )  )     {", "for    ( SimpSubscription   subscription    :    session . subscriptions . values (  )  )     {", "if    ( matcher . match ( subscription )  )     {", "result . add ( subscription )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findSubscriptions"], "fileName": "org.springframework.web.socket.messaging.DefaultSimpUserRegistry"}, {"methodBody": ["METHOD_START", "{", "DefaultSimpUserRegistry   registry    =    new   DefaultSimpUserRegistry (  )  ;", ". TestPrincipal   user    =    new    . TestPrincipal (  \" joe \"  )  ;", "Message < byte [  ]  >    message    =    createMessage ( CONNECT _ ACK ,     \"  1  2  3  \"  )  ;", "SessionConnectedEvent   event    =    new   SessionConnectedEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( event )  ;", "message    =    createMessage ( CONNECT _ ACK ,     \"  4  5  6  \"  )  ;", "event    =    new   SessionConnectedEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( event )  ;", "message    =    createMessage ( CONNECT _ ACK ,     \"  7  8  9  \"  )  ;", "event    =    new   SessionConnectedEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( event )  ;", "SimpUser   simpUser    =    registry . getUser (  \" joe \"  )  ;", "assertNotNull ( simpUser )  ;", "assertEquals (  1  ,    registry . getUserCount (  )  )  ;", "assertEquals (  3  ,    simpUser . getSessions (  )  . size (  )  )  ;", "assertNotNull ( simpUser . getSession (  \"  1  2  3  \"  )  )  ;", "assertNotNull ( simpUser . getSession (  \"  4  5  6  \"  )  )  ;", "assertNotNull ( simpUser . getSession (  \"  7  8  9  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addMultipleSessionIds"], "fileName": "org.springframework.web.socket.messaging.DefaultSimpUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultSimpUserRegistryTests . TestPrincipal   user    =    new   DefaultSimpUserRegistryTests . TestPrincipal (  \" joe \"  )  ;", "Message < byte [  ]  >    message    =    createMessage ( CONNECT _ ACK ,     \"  1  2  3  \"  )  ;", "SessionConnectedEvent   event    =    new   SessionConnectedEvent ( this ,    message ,    user )  ;", "DefaultSimpUserRegistry   registry    =    new   DefaultSimpUserRegistry (  )  ;", "registry . onApplicationEvent ( event )  ;", "SimpUser   simpUser    =    registry . getUser (  \" joe \"  )  ;", "assertNotNull ( simpUser )  ;", "assertEquals (  1  ,    registry . getUserCount (  )  )  ;", "assertEquals (  1  ,    simpUser . getSessions (  )  . size (  )  )  ;", "assertNotNull ( simpUser . getSession (  \"  1  2  3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addOneSessionId"], "fileName": "org.springframework.web.socket.messaging.DefaultSimpUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "return   createMessage ( type ,    sessionId ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.web.socket.messaging.DefaultSimpUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create ( type )  ;", "accessor . setSessionId ( sessionId )  ;", "if    ( destination    !  =    null )     {", "accessor . setDestination ( destination )  ;", "}", "if    ( subscriptionId    !  =    null )     {", "accessor . setSubscriptionId ( subscriptionId )  ;", "}", "return   MessageBuilder . createMessage ( new   byte [  0  ]  ,    accessor . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.web.socket.messaging.DefaultSimpUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultSimpUserRegistry   registry    =    new   DefaultSimpUserRegistry (  )  ;", ". TestPrincipal   user    =    new    . TestPrincipal (  \" joe \"  )  ;", "Message < byte [  ]  >    message    =    createMessage ( CONNECT _ ACK ,     \"  1  2  3  \"  )  ;", "SessionConnectedEvent   event    =    new   SessionConnectedEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( event )  ;", "message    =    createMessage ( SUBSCRIBE ,     \"  1  2  3  \"  ,     \" sub 1  \"  ,     \"  / match \"  )  ;", "SessionSubscribeEvent   subscribeEvent    =    new   SessionSubscribeEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( subscribeEvent )  ;", "message    =    createMessage ( SUBSCRIBE ,     \"  1  2  3  \"  ,     \" sub 2  \"  ,     \"  / match \"  )  ;", "subscribeEvent    =    new   SessionSubscribeEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( subscribeEvent )  ;", "message    =    createMessage ( SUBSCRIBE ,     \"  1  2  3  \"  ,     \" sub 3  \"  ,     \"  / not - a - match \"  )  ;", "subscribeEvent    =    new   SessionSubscribeEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( subscribeEvent )  ;", "Set < SimpSubscription >    matches    =    registry . findSubscriptions ( new   SimpSubscriptionMatcher (  )     {", "@ Override", "public   boolean   match ( SimpSubscription   subscription )     {", "return   subscription . getDestination (  )  . equals (  \"  / match \"  )  ;", "}", "}  )  ;", "assertEquals (  2  ,    matches . size (  )  )  ;", "Iterator < SimpSubscription >    iterator    =    matches . iterator (  )  ;", "Set < String >    sessionIds    =    new   HashSet <  >  (  2  )  ;", "sessionIds . add ( iterator . next (  )  . getId (  )  )  ;", "sessionIds . add ( iterator . next (  )  . getId (  )  )  ;", "assertEquals ( new   HashSet ( Arrays . asList (  \" sub 1  \"  ,     \" sub 2  \"  )  )  ,    sessionIds )  ;", "}", "METHOD_END"], "methodName": ["findSubscriptions"], "fileName": "org.springframework.web.socket.messaging.DefaultSimpUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultSimpUserRegistry   registry    =    new   DefaultSimpUserRegistry (  )  ;", ". TestPrincipal   user    =    new    . TestPrincipal (  \" joe \"  )  ;", "Message < byte [  ]  >    message    =    createMessage ( CONNECT _ ACK ,     \"  1  2  3  \"  )  ;", "SessionConnectedEvent   event    =    new   SessionConnectedEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( event )  ;", "SimpUser   simpUser    =    registry . getUser (  \" joe \"  )  ;", "assertNull ( simpUser . getSession ( null )  )  ;", "}", "METHOD_END"], "methodName": ["nullSessionId"], "fileName": "org.springframework.web.socket.messaging.DefaultSimpUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultSimpUserRegistry   registry    =    new   DefaultSimpUserRegistry (  )  ;", ". TestPrincipal   user    =    new    . TestPrincipal (  \" joe \"  )  ;", "Message < byte [  ]  >    message    =    createMessage ( CONNECT _ ACK ,     \"  1  2  3  \"  )  ;", "SessionConnectedEvent   connectedEvent    =    new   SessionConnectedEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( connectedEvent )  ;", "message    =    createMessage ( CONNECT _ ACK ,     \"  4  5  6  \"  )  ;", "connectedEvent    =    new   SessionConnectedEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( connectedEvent )  ;", "message    =    createMessage ( CONNECT _ ACK ,     \"  7  8  9  \"  )  ;", "connectedEvent    =    new   SessionConnectedEvent ( this ,    message ,    user )  ;", "registry . onApplicationEvent ( connectedEvent )  ;", "SimpUser   simpUser    =    registry . getUser (  \" joe \"  )  ;", "assertNotNull ( simpUser )  ;", "assertEquals (  3  ,    simpUser . getSessions (  )  . size (  )  )  ;", "CloseStatus   status    =    CloseStatus . GOING _ AWAY ;", "message    =    createMessage ( DISCONNECT ,     \"  4  5  6  \"  )  ;", "SessionDisconnectEvent   disconnectEvent    =    new   SessionDisconnectEvent ( this ,    message ,     \"  4  5  6  \"  ,    status ,    user )  ;", "registry . onApplicationEvent ( disconnectEvent )  ;", "message    =    createMessage ( DISCONNECT ,     \"  7  8  9  \"  )  ;", "disconnectEvent    =    new   SessionDisconnectEvent ( this ,    message ,     \"  7  8  9  \"  ,    status ,    user )  ;", "registry . onApplicationEvent ( disconnectEvent )  ;", "assertEquals (  1  ,    simpUser . getSessions (  )  . size (  )  )  ;", "assertNotNull ( simpUser . getSession (  \"  1  2  3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["removeSessionIds"], "fileName": "org.springframework.web.socket.messaging.DefaultSimpUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "return   this . status ;", "}", "METHOD_END"], "methodName": ["getCloseStatus"], "fileName": "org.springframework.web.socket.messaging.SessionDisconnectEvent"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionId ;", "}", "METHOD_END"], "methodName": ["getSessionId"], "fileName": "org.springframework.web.socket.messaging.SessionDisconnectEvent"}, {"methodBody": ["METHOD_START", "{", "return   MessageBuilder . createMessage ( errorPayload ,    errorHeaderAccessor . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleInternal"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolErrorHandler"}, {"methodBody": ["METHOD_START", "{", "Exception   ex    =    new   Exception (  \" fake   exception \"  )  ;", "Message < byte [  ]  >    actual    =    this . h . handleClientMessageProcessingError ( null ,    ex )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( actual ,    StompHeaderAccessor . class )  ;", "assertNotNull ( accessor )  ;", "assertEquals ( ERROR ,    accessor . getCommand (  )  )  ;", "assertEquals ( ex . getMessage (  )  ,    accessor . getMessage (  )  )  ;", "assertArrayEquals ( new   byte [  0  ]  ,    actual . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleClientMessageProcessingError"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   receiptId    =     \"  1  2  3  \"  ;", "StompHeaderAccessor   clientHeaderAccessor    =    StompHeaderAccessor . create ( SEND )  ;", "clientHeaderAccessor . setReceipt ( receiptId )  ;", "MessageHeaders   clientHeaders    =    clientHeaderAccessor . getMessageHeaders (  )  ;", "Message < byte [  ]  >    clientMessage    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    clientHeaders )  ;", "Message < byte [  ]  >    actual    =    this . h . handleClientMessageProcessingError ( clientMessage ,    new   Exception (  )  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( actual ,    StompHeaderAccessor . class )  ;", "assertNotNull ( accessor )  ;", "assertEquals ( receiptId ,    accessor . getReceiptId (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleClientMessageProcessingErrorWithReceipt"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler    =    new   StompSubProtocolErrorHandler (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Principal   principal    =    getUser ( session )  ;", "if    ( principal    !  =    null )     {", "accessor    =    toMutableAccessor ( accessor ,    message )  ;", "accessor . setNativeHeader (  . CONNECTED _ USER _ HEADER ,    principal . getName (  )  )  ;", "}", "long [  ]    heartbeat    =    accessor . getHeartbeat (  )  ;", "if    (  ( heartbeat [  1  ]  )     >     0  )     {", "session    =    WebSocketSessionDecorator . unwrap ( session )  ;", "if    ( session   instanceof   SockJsSession )     {", "(  ( SockJsSession )     ( session )  )  . disableHeartbeat (  )  ;", "}", "}", "return   accessor ;", "}", "METHOD_END"], "methodName": ["afterStompSessionConnected"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "String   name    =    StompHeaderAccessor . CONNECT _ MESSAGE _ HEADER ;", "Message <  ?  >    e    =     (  ( Message <  ?  >  )     ( connectAckHeaders . getHeader ( name )  )  )  ;", "if    ( e    =  =    null )     {", "throw   new   IllegalStateException (  (  \" Original   STOMP   CONNECT   not   found   in    \"     +    connectAckHeaders )  )  ;", "}", "StompHeaderAccessor   connectHeaders    =    MessageHeaderAccessor . getAccessor ( e ,    StompHeaderAccessor . class )  ;", "StompHeaderAccessor   connectedHeaders    =    StompHeaderAccessor . create ( CONNECTED )  ;", "if    ( connectHeaders    !  =    null )     {", "Set < String >    acceptVersions    =    connectHeaders . getAcceptVersion (  )  ;", "if    ( acceptVersions . contains (  \"  1  .  2  \"  )  )     {", "connectedHeaders . setVersion (  \"  1  .  2  \"  )  ;", "} else", "if    ( acceptVersions . contains (  \"  1  .  1  \"  )  )     {", "connectedHeaders . setVersion (  \"  1  .  1  \"  )  ;", "} else", "if    (  !  ( acceptVersions . isEmpty (  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Unsupported   STOMP   version    '  \"     +    acceptVersions )     +     \"  '  \"  )  )  ;", "}", "}", "long [  ]    heartbeat    =     (  ( long [  ]  )     ( connectAckHeaders . getHeader ( HEART _ BEAT _ HEADER )  )  )  ;", "if    ( heartbeat    !  =    null )     {", "connectedHeaders . setHeartbeat ( heartbeat [  0  ]  ,    heartbeat [  1  ]  )  ;", "} else    {", "connectedHeaders . setHeartbeat (  0  ,     0  )  ;", "}", "return   connectedHeaders ;", "}", "METHOD_END"], "methodName": ["convertConnectAcktoStompConnected"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headerAccessor    =    StompHeaderAccessor . create ( DISCONNECT )  ;", "if    (  ( getHeaderInitializer (  )  )     !  =    null )     {", "getHeaderInitializer (  )  . initHeaders ( headerAccessor )  ;", "}", "headerAccessor . setSessionId ( session . getId (  )  )  ;", "headerAccessor . setSessionAttributes ( session . getAttributes (  )  )  ;", "Principal   user    =    getUser ( session )  ;", "if    ( user    !  =    null )     {", "headerAccessor . setUser ( user )  ;", "}", "return   MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    headerAccessor . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["createDisconnectMessage"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . immutableMessageInterceptorPresent )     !  =    null )     {", "return   this . immutableMessageInterceptorPresent ;", "}", "if    ( channel   instanceof   AbstractMessageChannel )     {", "for    ( ChannelInterceptor   interceptor    :     (  ( AbstractMessageChannel )     ( channel )  )  . getInterceptors (  )  )     {", "if    ( interceptor   instanceof   ImmutableMessageChannelInterceptor )     {", "this . immutableMessageInterceptorPresent    =    true ;", "return   true ;", "}", "}", "}", "this . immutableMessageInterceptorPresent    =    false ;", "return   false ;", "}", "METHOD_END"], "methodName": ["detectImmutableMessageInterceptor"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "String   name    =    StompHeaderAccessor . DISCONNECT _ MESSAGE _ HEADER ;", "Message <  ?  >    e    =     (  ( Message <  ?  >  )     ( simpHeaders . getHeader ( name )  )  )  ;", "if    ( e    !  =    null )     {", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( e ,    StompHeaderAccessor . class )  ;", "if    ( accessor    !  =    null )     {", "return   accessor . getReceipt (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDisconnectReceipt"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . errorHandler ;", "}", "METHOD_END"], "methodName": ["getErrorHandler"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . headerInitializer ;", "}", "METHOD_END"], "methodName": ["getHeaderInitializer"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSizeLimit ;", "}", "METHOD_END"], "methodName": ["getMessageSizeLimit"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . stats . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getStatsInfo"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    MessageHeaderAccessor . class )  ;", "if    ( accessor   instanceof   StompHeaderAccessor )     {", "return    (  ( StompHeaderAccessor )     ( accessor )  )  ;", "} else    {", "StompHeaderAccessor   stompAccessor    =    StompHeaderAccessor . wrap ( message )  ;", "SimpMessageType   messageType    =    SimpMessageHeaderAccessor . getMessageType ( message . getHeaders (  )  )  ;", "if    ( CONNECT _ ACK . equals ( messageType )  )     {", "stompAccessor    =    convertConnectAcktoStompConnected ( stompAccessor )  ;", "} else", "if    ( SimpMessageType . DISCONNECT _ ACK . equals ( messageType )  )     {", "String   receipt    =    getDisconnectReceipt ( stompAccessor )  ;", "if    ( receipt    !  =    null )     {", "stompAccessor    =    StompHeaderAccessor . create ( StompCommand . RECEIPT )  ;", "stompAccessor . setReceiptId ( receipt )  ;", "} else    {", "stompAccessor    =    StompHeaderAccessor . create ( StompCommand . ERROR )  ;", "stompAccessor . setMessage (  \" Session   closed .  \"  )  ;", "}", "} else", "if    ( SimpMessageType . HEARTBEAT . equals ( messageType )  )     {", "stompAccessor    =    StompHeaderAccessor . createForHeartbeat (  )  ;", "} else", "if    (  (  ( stompAccessor . getCommand (  )  )     =  =    null )     |  |     ( StompCommand . SEND . equals ( stompAccessor . getCommand (  )  )  )  )     {", "stompAccessor . updateStompCommandAsServerMessage (  )  ;", "}", "return   stompAccessor ;", "}", "}", "METHOD_END"], "methodName": ["getStompHeaderAccessor"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "Principal   user    =    this . stompAuthentications . get ( session . getId (  )  )  ;", "return   user    !  =    null    ?    user    :    session . getPrincipal (  )  ;", "}", "METHOD_END"], "methodName": ["getUser"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getErrorHandler (  )  )     =  =    null )     {", "sendErrorMessage ( session ,    ex )  ;", "return ;", "}", "Message < byte [  ]  >    message    =    getErrorHandler (  )  . handleClientMessageProcessingError ( clientMessage ,    ex )  ;", "if    ( message    =  =    null )     {", "return ;", "}", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "Assert . state (  ( accessor    !  =    null )  ,     \" No   StompHeaderAccessor \"  )  ;", "sendToClient ( session ,    accessor ,    message . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleError"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "List < Message < byte [  ]  >  >    messages ;", "try    {", "ByteBuffer   byteBuffer ;", "if    ( webSocketMessage   instanceof   TextMessage )     {", "byteBuffer    =    ByteBuffer . wrap (  (  ( TextMessage )     ( webSocketMessage )  )  . asBytes (  )  )  ;", "} else", "if    ( webSocketMessage   instanceof   BinaryMessage )     {", "byteBuffer    =     (  ( BinaryMessage )     ( webSocketMessage )  )  . getPayload (  )  ;", "} else    {", "return ;", "}", "BufferingStompDecoder   decoder    =    this . decoders . get ( session . getId (  )  )  ;", "if    ( decoder    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No   decoder   for   session   id    '  \"     +     ( session . getId (  )  )  )     +     \"  '  \"  )  )  ;", "}", "messages    =    decoder . decode ( byteBuffer )  ;", "if    ( messages . isEmpty (  )  )     {", "if    ( StompSubProtocolHandler . logger . isTraceEnabled (  )  )     {", "StompSubProtocolHandler . logger . trace (  (  (  (  (  (  (  \" Incomplete   STOMP   frame   content   received   in   session    \"     +    session )     +     \"  ,    bufferSize =  \"  )     +     ( decoder . getBufferSize (  )  )  )     +     \"  ,    bufferSizeLimit =  \"  )     +     ( decoder . getBufferSizeLimit (  )  )  )     +     \"  .  \"  )  )  ;", "}", "return ;", "}", "}    catch    ( Throwable   ex )     {", "if    ( StompSubProtocolHandler . logger . isErrorEnabled (  )  )     {", "StompSubProtocolHandler . logger . error (  (  (  (  (  \" Failed   to   parse    \"     +    webSocketMessage )     +     \"    in   session    \"  )     +     ( session . getId (  )  )  )     +     \"  .    Sending   STOMP   ERROR   to   client .  \"  )  ,    ex )  ;", "}", "handleError ( session ,    ex ,    null )  ;", "return ;", "}", "for    ( Message < byte [  ]  >    message    :    messages )     {", "try    {", "StompHeaderAccessor   headerAccessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "Assert . state (  ( headerAccessor    !  =    null )  ,     \" No   StompHeaderAccessor \"  )  ;", "headerAccessor . setSessionId ( session . getId (  )  )  ;", "headerAccessor . setSessionAttributes ( session . getAttributes (  )  )  ;", "headerAccessor . setUser ( getUser ( session )  )  ;", "headerAccessor . setHeader ( HEART _ BEAT _ HEADER ,    headerAccessor . getHeartbeat (  )  )  ;", "if    (  !  ( detectImmutableMessageInterceptor ( outputChannel )  )  )     {", "headerAccessor . setImmutable (  )  ;", "}", "if    ( StompSubProtocolHandler . logger . isTraceEnabled (  )  )     {", "StompSubProtocolHandler . logger . trace (  (  \" From   client :     \"     +     ( headerAccessor . getShortLogMessage ( message . getPayload (  )  )  )  )  )  ;", "}", "StompCommand   command    =    headerAccessor . getCommand (  )  ;", "boolean   isConnect    =    CONNECT . equals ( command )  ;", "if    ( isConnect )     {", "this . stats . incrementConnectCount (  )  ;", "} else", "if    ( StompCommand . DISCONNECT . equals ( command )  )     {", "this . stats . incrementDisconnectCount (  )  ;", "}", "try    {", "SimpAttributesContextHolder . setAttributesFromMessage ( message )  ;", "boolean   sent    =    outputChannel . send ( message )  ;", "if    ( sent )     {", "if    ( isConnect )     {", "Principal   user    =    headerAccessor . getUser (  )  ;", "if    (  ( user    !  =    null )     &  &     ( user    !  =     ( session . getPrincipal (  )  )  )  )     {", "this . stompAuthentications . put ( session . getId (  )  ,    user )  ;", "}", "}", "if    (  ( this . eventPublisher )     !  =    null )     {", "Principal   user    =    getUser ( session )  ;", "if    ( isConnect )     {", "publishEvent ( this . eventPublisher ,    new   SessionConnectEvent ( this ,    message ,    user )  )  ;", "} else", "if    ( StompCommand . SUBSCRIBE . equals ( command )  )     {", "publishEvent ( this . eventPublisher ,    new   SessionSubscribeEvent ( this ,    message ,    user )  )  ;", "} else", "if    ( StompCommand . UNSUBSCRIBE . equals ( command )  )     {", "publishEvent ( this . eventPublisher ,    new   SessionUnsubscribeEvent ( this ,    message ,    user )  )  ;", "}", "}", "}", "}    finally    {", "SimpAttributesContextHolder . resetAttributes (  )  ;", "}", "}    catch    ( Throwable   ex )     {", "if    ( StompSubProtocolHandler . logger . isErrorEnabled (  )  )     {", "StompSubProtocolHandler . logger . error (  (  (  (  \" Failed   to   send   client   message   to   application   via   MessageChannel \"     +     \"    in   session    \"  )     +     ( session . getId (  )  )  )     +     \"  .    Sending   STOMP   ERROR   to   client .  \"  )  ,    ex )  ;", "}", "handleError ( session ,    ex ,    message )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleMessageFromClient"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "publisher . publishEvent ( event )  ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isErrorEnabled (  )  )     {", ". logger . error (  (  \" Error   publishing    \"     +    event )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["publishEvent"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headerAccessor    =    StompHeaderAccessor . create ( ERROR )  ;", "headerAccessor . setMessage ( error . getMessage (  )  )  ;", "byte [  ]    bytes    =    this . stompEncoder . encode ( headerAccessor . getMessageHeaders (  )  ,     . EMPTY _ PAYLOAD )  ;", "try    {", "session . sendMessage ( new   TextMessage ( bytes )  )  ;", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Failed   to   send   STOMP   ERROR   to   client \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["sendErrorMessage"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "StompCommand   command    =    stompAccessor . getCommand (  )  ;", "try    {", "byte [  ]    bytes    =    this . stompEncoder . encode ( stompAccessor . getMessageHeaders (  )  ,    payload )  ;", "boolean   useBinary    =     (  (  ( payload . length )     >     0  )     &  &     (  !  ( session   instanceof   SockJsSession )  )  )     &  &     ( APPLICATION _ OCTET _ STREAM . isCompatibleWith ( stompAccessor . getContentType (  )  )  )  ;", "if    ( useBinary )     {", "session . sendMessage ( new   BinaryMessage ( bytes )  )  ;", "} else    {", "session . sendMessage ( new   TextMessage ( bytes )  )  ;", "}", "}    catch    ( SessionLimitExceededException   ex )     {", "throw   ex ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Failed   to   send   WebSocket   message   to   client   in   session    \"     +     ( session . getId (  )  )  )  ,    ex )  ;", "}", "command    =    StompCommand . ERROR ;", "}    finally    {", "if    ( ERROR . equals ( command )  )     {", "try    {", "session . close ( CloseStatus . PROTOCOL _ ERROR )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["sendToClient"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "this . stompDecoder    =    decoder ;", "}", "METHOD_END"], "methodName": ["setDecoder"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "this . stompEncoder    =    encoder ;", "}", "METHOD_END"], "methodName": ["setEncoder"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "this . headerInitializer    =    headerInitializer ;", "this . sDecoder . setHeaderInitializer ( headerInitializer )  ;", "}", "METHOD_END"], "methodName": ["setHeaderInitializer"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "this . messageSizeLimit    =    messageSizeLimit ;", "}", "METHOD_END"], "methodName": ["setMessageSizeLimit"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "return   headerAccessor . isMutable (  )     ?    headerAccessor    :    StompHeaderAccessor . wrap ( message )  ;", "}", "METHOD_END"], "methodName": ["toMutableAccessor"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandler"}, {"methodBody": ["METHOD_START", "{", "StompSubProtocolHandlerTests . TestPublisher   publisher    =    new   StompSubProtocolHandlerTests . TestPublisher (  )  ;", "this . protocolHandler . setApplicationEventPublisher ( publisher )  ;", "this . protocolHandler . afterSessionStarted ( this . session ,    this . channel )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( CONNECT )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage ( StompSubProtocolHandlerTests . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "TextMessage   textMessage    =    new   TextMessage ( new   StompEncoder (  )  . encode ( message )  )  ;", "this . protocolHandler . handleMessageFromClient ( this . session ,    textMessage ,    this . channel )  ;", "headers    =    StompHeaderAccessor . create ( CONNECTED )  ;", "message    =    MessageBuilder . createMessage ( StompSubProtocolHandlerTests . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    message )  ;", "headers    =    StompHeaderAccessor . create ( SUBSCRIBE )  ;", "message    =    MessageBuilder . createMessage ( StompSubProtocolHandlerTests . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "textMessage    =    new   TextMessage ( new   StompEncoder (  )  . encode ( message )  )  ;", "this . protocolHandler . handleMessageFromClient ( this . session ,    textMessage ,    this . channel )  ;", "headers    =    StompHeaderAccessor . create ( UNSUBSCRIBE )  ;", "message    =    MessageBuilder . createMessage ( StompSubProtocolHandlerTests . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "textMessage    =    new   TextMessage ( new   StompEncoder (  )  . encode ( message )  )  ;", "this . protocolHandler . handleMessageFromClient ( this . session ,    textMessage ,    this . channel )  ;", "this . protocolHandler . afterSessionEnded ( this . session ,    CloseStatus . BAD _ DATA ,    this . channel )  ;", "assertEquals (  (  \" Unexpected   events    \"     +     ( publisher . events )  )  ,     5  ,    publisher . events . size (  )  )  ;", "assertEquals ( SessionConnectEvent . class ,    publisher . events . get (  0  )  . getClass (  )  )  ;", "assertEquals ( SessionConnectedEvent . class ,    publisher . events . get (  1  )  . getClass (  )  )  ;", "assertEquals ( SessionSubscribeEvent . class ,    publisher . events . get (  2  )  . getClass (  )  )  ;", "assertEquals ( SessionUnsubscribeEvent . class ,    publisher . events . get (  3  )  . getClass (  )  )  ;", "assertEquals ( SessionDisconnectEvent . class ,    publisher . events . get (  4  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["eventPublication"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationEventPublisher   publisher    =    mock ( ApplicationEventPublisher . class )  ;", "this . protocolHandler . setApplicationEventPublisher ( publisher )  ;", "this . protocolHandler . afterSessionStarted ( this . session ,    this . channel )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( CONNECT )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "TextMessage   textMessage    =    new   TextMessage ( new   StompEncoder (  )  . encode ( message )  )  ;", "this . protocolHandler . handleMessageFromClient ( this . session ,    textMessage ,    this . channel )  ;", "verify ( this . channel )  . send ( this . messageCaptor . capture (  )  )  ;", "Message <  ?  >    actual    =    this . messageCaptor . getValue (  )  ;", "assertNotNull ( actual )  ;", "assertEquals ( CONNECT ,    StompHeaderAccessor . wrap ( actual )  . getCommand (  )  )  ;", "reset ( this . channel )  ;", "headers    =    StompHeaderAccessor . create ( CONNECTED )  ;", "message    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    message )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "textMessage    =     (  ( TextMessage )     ( this . session . getSentMessages (  )  . get (  0  )  )  )  ;", "assertEquals (  (  \" CONNECTED \\ n \"     +     (  (  \" user - name : joe \\ n \"     +     \"  \\ n \"  )     +     \"  \\ u 0  0  0  0  \"  )  )  ,    textMessage . getPayload (  )  )  ;", "this . protocolHandler . afterSessionEnded ( this . session ,    CloseStatus . BAD _ DATA ,    this . channel )  ;", "verify ( this . channel )  . send ( this . messageCaptor . capture (  )  )  ;", "actual    =    this . messageCaptor . getValue (  )  ;", "assertNotNull ( actual )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . wrap ( actual )  ;", "assertEquals ( DISCONNECT ,    accessor . getCommand (  )  )  ;", "assertEquals (  \" s 1  \"  ,    accessor . getSessionId (  )  )  ;", "assertEquals (  \" joe \"  ,    accessor . getUser (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["eventPublicationWithExceptions"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessage    =    StompTextMessageBuilder . create ( CONNECT )  . headers (  \" login : guest \"  ,     \" passcode : guest \"  ,     \" accept - version :  1  .  1  ,  1  .  0  \"  ,     \" heart - beat :  1  0  0  0  0  ,  1  0  0  0  0  \"  )  . build (  )  ;", "this . p . afterSessionStarted ( this . session ,    this . channel )  ;", "this . p . handleMessageFromClient ( this . session ,    textMessage ,    this . channel )  ;", "verify ( this . channel )  . send ( this . messageCaptor . capture (  )  )  ;", "Message <  ?  >    actual    =    this . messageCaptor . getValue (  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  \" s 1  \"  ,    SimpMessageHeaderAccessor . getSessionId ( actual . getHeaders (  )  )  )  ;", "assertNotNull ( SimpMessageHeaderAccessor . getSessionAttributes ( actual . getHeaders (  )  )  )  ;", "assertNotNull ( SimpMessageHeaderAccessor . getUser ( actual . getHeaders (  )  )  )  ;", "assertEquals (  \" joe \"  ,    SimpMessageHeaderAccessor . getUser ( actual . getHeaders (  )  )  . getName (  )  )  ;", "assertNotNull ( SimpMessageHeaderAccessor . getHeartbeat ( actual . getHeaders (  )  )  )  ;", "assertArrayEquals ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ,    SimpMessageHeaderAccessor . getHeartbeat ( actual . getHeaders (  )  )  )  ;", "StompHeaderAccessor   stompAccessor    =    StompHeaderAccessor . wrap ( actual )  ;", "assertEquals ( CONNECT ,    stompAccessor . getCommand (  )  )  ;", "assertEquals (  \" guest \"  ,    stompAccessor . getLogin (  )  )  ;", "assertEquals (  \" guest \"  ,    stompAccessor . getPasscode (  )  )  ;", "assertArrayEquals ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ,    stompAccessor . getHeartbeat (  )  )  ;", "assertEquals ( new   HashSet ( Arrays . asList (  \"  1  .  1  \"  ,     \"  1  .  0  \"  )  )  ,    stompAccessor . getAcceptVersion (  )  )  ;", "assertEquals (  0  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFromClient"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AtomicReference < Boolean >    mutable    =    new   AtomicReference <  >  (  )  ;", "ExecutorSubscribableChannel   channel    =    new   ExecutorSubscribableChannel (  )  ;", "channel . addInterceptor ( new   ChannelInterceptorAdapter (  )     {", "@ Override", "public   Message <  ?  >    preSend ( Message <  ?  >    message ,    MessageChannel   channel )     {", "mutable . set ( MessageHeaderAccessor . getAccessor ( message ,    MessageHeaderAccessor . class )  . isMutable (  )  )  ;", "return   message ;", "}", "}  )  ;", "channel . addInterceptor ( new   ImmutableMessageChannelInterceptor (  )  )  ;", "handler    =    new    (  )  ;", "handler . afterSessionStarted ( this . session ,    channel )  ;", "TextMessage   message    =    StompTextMessageBuilder . create ( CONNECT )  . build (  )  ;", "handler . handleMessageFromClient ( this . session ,    message ,    channel )  ;", "assertNotNull ( mutable . get (  )  )  ;", "assertTrue ( mutable . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFromClientWithImmutableMessageInterceptor"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessage    =    new   TextMessage (  \" FOO \\ n \\ n \\ u 0  0  0  0  \"  )  ;", "this . p . afterSessionStarted ( this . session ,    this . channel )  ;", "this . p . handleMessageFromClient ( this . session ,    textMessage ,    this . channel )  ;", "verifyZeroInteractions ( this . channel )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "TextMessage   actual    =     (  ( TextMessage )     ( this . session . getSentMessages (  )  . get (  0  )  )  )  ;", "assertTrue ( actual . getPayload (  )  . startsWith (  \" ERROR \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFromClientWithInvalidStompCommand"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ExecutorSubscribableChannel   channel    =    new   ExecutorSubscribableChannel (  )  ;", "channel . addInterceptor ( new    . AuthenticationInterceptor (  \"  _  _ pete _  _  @ gmail . com \"  )  )  ;", "channel . addInterceptor ( new   ImmutableMessageChannelInterceptor (  )  )  ;", ". TestMessageHandler   messageHandler    =    new    . TestMessageHandler (  )  ;", "channel . subscribe ( messageHandler )  ;", "StompSubProtocolHandler   handler    =    new   StompSubProtocolHandler (  )  ;", "handler . afterSessionStarted ( this . session ,    channel )  ;", "TextMessage   wsMessage    =    StompTextMessageBuilder . create ( CONNECT )  . build (  )  ;", "handler . handleMessageFromClient ( this . session ,    wsMessage ,    channel )  ;", "assertEquals (  1  ,    messageHandler . getMessages (  )  . size (  )  )  ;", "Message <  ?  >    message    =    messageHandler . getMessages (  )  . get (  0  )  ;", "Principal   user    =    SimpMessageHeaderAccessor . getUser ( message . getHeaders (  )  )  ;", "assertNotNull ( user )  ;", "assertEquals (  \"  _  _ pete _  _  @ gmail . com \"  ,    user . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFromClientWithTokenAuthentication"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AtomicReference < Boolean >    mutable    =    new   AtomicReference <  >  (  )  ;", "ExecutorSubscribableChannel   channel    =    new   ExecutorSubscribableChannel (  )  ;", "channel . addInterceptor ( new   ChannelInterceptorAdapter (  )     {", "@ Override", "public   Message <  ?  >    preSend ( Message <  ?  >    message ,    MessageChannel   channel )     {", "mutable . set ( MessageHeaderAccessor . getAccessor ( message ,    MessageHeaderAccessor . class )  . isMutable (  )  )  ;", "return   message ;", "}", "}  )  ;", "handler    =    new    (  )  ;", "handler . afterSessionStarted ( this . session ,    channel )  ;", "TextMessage   message    =    StompTextMessageBuilder . create ( CONNECT )  . build (  )  ;", "handler . handleMessageFromClient ( this . session ,    message ,    channel )  ;", "assertNotNull ( mutable . get (  )  )  ;", "assertFalse ( mutable . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFromClientWithoutImmutableMessageInterceptor"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( MESSAGE )  ;", "headers . setMessageId (  \" mess 0  \"  )  ;", "headers . setSubscriptionId (  \" sub 0  \"  )  ;", "headers . setContentType ( APPLICATION _ OCTET _ STREAM )  ;", "headers . setDestination (  \"  / queue / foo \"  )  ;", "byte [  ]    payload    =    new   byte [  1  ]  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage ( payload ,    headers . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    message )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "WebSocketMessage <  ?  >    webSocketMessage    =    this . session . getSentMessages (  )  . get (  0  )  ;", "assertTrue (  ( webSocketMessage   instanceof   BinaryMessage )  )  ;", "payload    =     . EMPTY _ PAYLOAD ;", "message    =    MessageBuilder . createMessage ( payload ,    headers . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    message )  ;", "assertEquals (  2  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "webSocketMessage    =    this . session . getSentMessages (  )  . get (  1  )  ;", "assertTrue (  ( webSocketMessage   instanceof   TextMessage )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithBinaryWebSocketMessage"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( CONNECTED )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    message )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "WebSocketMessage <  ?  >    textMessage    =    this . session . getSentMessages (  )  . get (  0  )  ;", "assertEquals (  (  \" CONNECTED \\ n \"     +     (  (  \" user - name : joe \\ n \"     +     \"  \\ n \"  )     +     \"  \\ u 0  0  0  0  \"  )  )  ,    textMessage . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithConnectedFrame"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . session . setPrincipal ( new   StompSubProtocolHandlerTests . UniqueUser (  \" joe \"  )  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( CONNECTED )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage ( StompSubProtocolHandlerTests . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    message )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "WebSocketMessage <  ?  >    textMessage    =    this . session . getSentMessages (  )  . get (  0  )  ;", "assertEquals (  (  \" CONNECTED \\ n \"     +     (  (  \" user - name : joe \\ n \"     +     \"  \\ n \"  )     +     \"  \\ u 0  0  0  0  \"  )  )  ,    textMessage . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithDestinationUserNameProvider"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SockJsSession   sockJsSession    =    Mockito . mock ( SockJsSession . class )  ;", "when ( sockJsSession . getId (  )  )  . thenReturn (  \" s 1  \"  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( CONNECTED )  ;", "accessor . setHeartbeat (  0  ,     1  0  )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( sockJsSession ,    message )  ;", "verify ( sockJsSession )  . getId (  )  ;", "verify ( sockJsSession )  . getPrincipal (  )  ;", "verify ( sockJsSession )  . disableHeartbeat (  )  ;", "verify ( sockJsSession )  . sendMessage ( any ( WebSocketMessage . class )  )  ;", "verifyNoMoreInteractions ( sockJsSession )  ;", "sockJsSession    =    Mockito . mock ( SockJsSession . class )  ;", "when ( sockJsSession . getId (  )  )  . thenReturn (  \" s 1  \"  )  ;", "accessor    =    StompHeaderAccessor . create ( CONNECTED )  ;", "accessor . setHeartbeat (  0  ,     0  )  ;", "message    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( sockJsSession ,    message )  ;", "verify ( sockJsSession )  . getId (  )  ;", "verify ( sockJsSession )  . getPrincipal (  )  ;", "verify ( sockJsSession )  . sendMessage ( any ( WebSocketMessage . class )  )  ;", "verifyNoMoreInteractions ( sockJsSession )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithHeartbeatSuppressingSockJsHeartbeat"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( CONNECT )  ;", "accessor . setHeartbeat (  1  0  0  0  0  ,     1  0  0  0  0  )  ;", "accessor . setAcceptVersion (  \"  1  .  0  ,  1  .  1  \"  )  ;", "Message <  ?  >    connectMessage    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "SimpMessageHeaderAccessor   ackAccessor    =    SimpMessageHeaderAccessor . create ( CONNECT _ ACK )  ;", "ackAccessor . setHeader ( CONNECT _ MESSAGE _ HEADER ,    connectMessage )  ;", "ackAccessor . setHeader ( HEART _ BEAT _ HEADER ,    new   long [  ]  {     1  5  0  0  0  ,     1  5  0  0  0     }  )  ;", "Message < byte [  ]  >    ackMessage    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    ackAccessor . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    ackMessage )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "TextMessage   actual    =     (  ( TextMessage )     ( this . session . getSentMessages (  )  . get (  0  )  )  )  ;", "assertEquals (  (  \" CONNECTED \\ n \"     +     (  (  (  (  \" version :  1  .  1  \\ n \"     +     \" heart - beat :  1  5  0  0  0  ,  1  5  0  0  0  \\ n \"  )     +     \" user - name : joe \\ n \"  )     +     \"  \\ n \"  )     +     \"  \\ u 0  0  0  0  \"  )  )  ,    actual . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithSimpConnectAck"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( CONNECT )  ;", "accessor . setHeartbeat (  1  0  0  0  0  ,     1  0  0  0  0  )  ;", "accessor . setAcceptVersion (  \"  1  .  0  ,  1  .  1  \"  )  ;", "Message <  ?  >    connectMessage    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "SimpMessageHeaderAccessor   ackAccessor    =    SimpMessageHeaderAccessor . create ( CONNECT _ ACK )  ;", "ackAccessor . setHeader ( CONNECT _ MESSAGE _ HEADER ,    connectMessage )  ;", "Message < byte [  ]  >    ackMessage    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    ackAccessor . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    ackMessage )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "TextMessage   actual    =     (  ( TextMessage )     ( this . session . getSentMessages (  )  . get (  0  )  )  )  ;", "assertEquals (  (  \" CONNECTED \\ n \"     +     (  (  (  (  \" version :  1  .  1  \\ n \"     +     \" heart - beat :  0  ,  0  \\ n \"  )     +     \" user - name : joe \\ n \"  )     +     \"  \\ n \"  )     +     \"  \\ u 0  0  0  0  \"  )  )  ,    actual . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithSimpConnectAckDefaultHeartBeat"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( DISCONNECT )  ;", "Message <  ?  >    connectMessage    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "SimpMessageHeaderAccessor   ackAccessor    =    SimpMessageHeaderAccessor . create ( DISCONNECT _ ACK )  ;", "ackAccessor . setHeader ( DISCONNECT _ MESSAGE _ HEADER ,    connectMessage )  ;", "Message < byte [  ]  >    ackMessage    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    ackAccessor . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    ackMessage )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "TextMessage   actual    =     (  ( TextMessage )     ( this . session . getSentMessages (  )  . get (  0  )  )  )  ;", "assertEquals (  (  \" ERROR \\ n \"     +     (  (  \" message : Session   closed .  \\ n \"     +     \" content - length :  0  \\ n \"  )     +     \"  \\ n \\ u 0  0  0  0  \"  )  )  ,    actual . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithSimpDisconnectAck"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( DISCONNECT )  ;", "accessor . setReceipt (  \" message -  1  2  3  \"  )  ;", "Message <  ?  >    connectMessage    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "SimpMessageHeaderAccessor   ackAccessor    =    SimpMessageHeaderAccessor . create ( DISCONNECT _ ACK )  ;", "ackAccessor . setHeader ( DISCONNECT _ MESSAGE _ HEADER ,    connectMessage )  ;", "Message < byte [  ]  >    ackMessage    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    ackAccessor . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    ackMessage )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "TextMessage   actual    =     (  ( TextMessage )     ( this . session . getSentMessages (  )  . get (  0  )  )  )  ;", "assertEquals (  (  \" RECEIPT \\ n \"     +     (  \" receipt - id : message -  1  2  3  \\ n \"     +     \"  \\ n \\ u 0  0  0  0  \"  )  )  ,    actual . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithSimpDisconnectAckAndReceipt"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create ( HEARTBEAT )  ;", "accessor . setSessionId (  \" s 1  \"  )  ;", "accessor . setUser ( new   TestPrincipal (  \" joe \"  )  )  ;", "Message < byte [  ]  >    ackMessage    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    ackMessage )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "TextMessage   actual    =     (  ( TextMessage )     ( this . session . getSentMessages (  )  . get (  0  )  )  )  ;", "assertEquals (  \"  \\ n \"  ,    actual . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithSimpHeartbeat"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( MESSAGE )  ;", "headers . setMessageId (  \" mess 0  \"  )  ;", "headers . setSubscriptionId (  \" sub 0  \"  )  ;", "headers . setDestination (  \"  / queue / foo - user 1  2  3  \"  )  ;", "headers . setNativeHeader ( ORIGINAL _ DESTINATION ,     \"  / user / queue / foo \"  )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "this . protocolHandler . handleMessageToClient ( this . session ,    message )  ;", "assertEquals (  1  ,    this . session . getSentMessages (  )  . size (  )  )  ;", "WebSocketMessage <  ?  >    textMessage    =    this . session . getSentMessages (  )  . get (  0  )  ;", "assertTrue (  (  ( String )     ( textMessage . getPayload (  )  )  )  . contains (  \" destination :  / user / queue / foo \\ n \"  )  )  ;", "assertFalse (  (  ( String )     ( textMessage . getPayload (  )  )  )  . contains ( SimpMessageHeaderAccessor . ORIGINAL _ DESTINATION )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToClientWithUserDestination"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . protocolHandler    =    new   StompSubProtocolHandler (  )  ;", "this . channel    =    Mockito . mock ( MessageChannel . class )  ;", "this . messageCaptor    =    ArgumentCaptor . forClass ( Message . class )  ;", "when ( this . channel . send ( any (  )  )  )  . thenReturn ( true )  ;", "this . session    =    new   TestWebSocketSession (  )  ;", "this . session . setId (  \" s 1  \"  )  ;", "this . session . setPrincipal ( new   TestPrincipal (  \" joe \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   runnable    =    Mockito . mock ( Runnable . class )  ;", "SimpAttributes   simpAttributes    =    new   SimpAttributes ( this . session . getId (  )  ,    this . session . getAttributes (  )  )  ;", "simpAttributes . setAttribute (  \" name \"  ,     \" value \"  )  ;", "simpAttributes . registerDestructionCallback (  \" name \"  ,    runnable )  ;", "MessageChannel   testChannel    =    new   MessageChannel (  )     {", "@ Override", "public   boolean   send ( Message <  ?  >    message )     {", "SimpAttributes   simpAttributes    =    SimpAttributesContextHolder . currentAttributes (  )  ;", "assertThat ( simpAttributes . getAttribute (  \" name \"  )  ,    is (  \" value \"  )  )  ;", "return   true ;", "}", "@ Override", "public   boolean   send ( Message <  ?  >    message ,    long   timeout )     {", "return   false ;", "}", "}  ;", "this . protocolHandler . afterSessionStarted ( this . session ,    this . channel )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( CONNECT )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    headers . getMessageHeaders (  )  )  ;", "TextMessage   textMessage    =    new   TextMessage ( new   StompEncoder (  )  . encode ( message )  )  ;", "this . protocolHandler . handleMessageFromClient ( this . session ,    textMessage ,    testChannel )  ;", "assertEquals ( Collections .  < WebSocketMessage <  ?  >  > emptyList (  )  ,    session . getSentMessages (  )  )  ;", "this . protocolHandler . afterSessionEnded ( this . session ,    CloseStatus . BAD _ DATA ,    testChannel )  ;", "assertEquals ( Collections .  < WebSocketMessage <  ?  >  > emptyList (  )  ,    this . session . getSentMessages (  )  )  ;", "verify ( runnable ,    times (  1  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["webSocketScope"], "fileName": "org.springframework.web.socket.messaging.StompSubProtocolHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . body    =    body ;", "rurn   this ;", "}", "METHOD_END"], "methodName": ["body"], "fileName": "org.springframework.web.socket.messaging.StompTextMessageBuilder"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( this . command . name (  )  )  . append (  \"  \\ n \"  )  ;", "for    ( String   line    :    this . headerLines )     {", "sb . append ( line )  . append (  \"  \\ n \"  )  ;", "}", "sb . append (  \"  \\ n \"  )  ;", "if    (  ( this . body )     !  =    null )     {", "sb . append ( this . body )  ;", "}", "sb . append (  \"  \\ u 0  0  0  0  \"  )  ;", "return   new    ( sb . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.web.socket.messaging.StompTextMessageBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   StompTextMessageBuilder ( command )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.web.socket.messaging.StompTextMessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerLines . addAll ( Arrays . asList ( headerLines )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["headers"], "fileName": "org.springframework.web.socket.messaging.StompTextMessageBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  [  ]  {    new   Object [  ]  {    new   JettyWebSocketTestServer (  )  ,    new   JettyWebSocketClient (  )     }  ,    new   Object [  ]  {    new   TomcatWebSocketTestServer (  )  ,    new   StandardWebSocketClient (  )     }  ,    new   Object [  ]  {    new   UndertowTestServer (  )  ,    new   StandardWebSocketClient (  )     }     }  ;", "}", "METHOD_END"], "methodName": ["arguments"], "fileName": "org.springframework.web.socket.messaging.StompWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   destHeader    =     \" destination :  / user / queue / error \"  ;", "TextMessage   m 1     =    StompTextMessageBuilder . create ( SUBSCRIBE )  . headers (  \" id : subs 1  \"  ,    destHeader )  . build (  )  ;", "TextMessage   m 2     =    StompTextMessageBuilder . create ( SEND )  . headers (  \" destination :  / app / exception \"  )  . build (  )  ;", ". TestClientWebSocketHandler   clientHandler    =    new    . TestClientWebSocketHandler (  1  ,    m 1  ,    m 2  )  ;", "WebSocketSession   session    =    doHandshake ( clientHandler ,     \"  / ws \"  )  . get (  )  ;", "try    {", "assertTrue ( clientHandler . latch . await (  . TIMEOUT ,    TimeUnit . SECONDS )  )  ;", "String   payload    =    clientHandler . actual . get (  0  )  . getPayload (  )  ;", "assertTrue ( payload . startsWith (  \" MESSAGE \\ n \"  )  )  ;", "assertTrue ( payload . contains (  \" destination :  / user / queue / error \\ n \"  )  )  ;", "assertTrue ( payload . endsWith (  \" Got   error :    Bad   input \\ u 0  0  0  0  \"  )  )  ;", "}    finally    {", "session . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleExceptionAndSendToUser"], "fileName": "org.springframework.web.socket.messaging.StompWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   m 1     =    StompTextMessageBuilder . create ( SUBSCRIBE )  . headers (  \" id : subs 1  \"  ,     \" destination :  / topic / foo \"  )  . build (  )  ;", "TextMessage   m 2     =    StompTextMessageBuilder . create ( SEND )  . headers (  \" destination :  / topic / foo \"  )  . body (  \"  5  \"  )  . build (  )  ;", ". TestClientWebSocketHandler   clientHandler    =    new    . TestClientWebSocketHandler (  1  ,    m 1  ,    m 2  )  ;", "WebSocketSession   session    =    doHandshake ( clientHandler ,     \"  / ws \"  )  . get (  )  ;", "try    {", "assertTrue ( clientHandler . latch . await (  . TIMEOUT ,    TimeUnit . SECONDS )  )  ;", "String   payload    =    clientHandler . actual . get (  0  )  . getPayload (  )  ;", "assertTrue (  (  \" Expected   STOMP   MESSAGE ,    got    \"     +    payload )  ,    payload . startsWith (  \" MESSAGE \\ n \"  )  )  ;", "}    finally    {", "session . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sendMessageToBrokerAndReceiveReplyViaTopic"], "fileName": "org.springframework.web.socket.messaging.StompWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   message    =    StompTextMessageBuilder . create ( SEND )  . headers (  \" destination :  / app / simple \"  )  . build (  )  ;", "WebSocketSession   session    =    doHandshake ( new    . TestClientWebSocketHandler (  0  ,    message )  ,     \"  / ws \"  )  . get (  )  ;", ". SimpleController   controller    =    this . wac . getBean (  . SimpleController . class )  ;", "try    {", "assertTrue ( controller . latch . await (  . TIMEOUT ,    TimeUnit . SECONDS )  )  ;", "}    finally    {", "session . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sendMessageToController"], "fileName": "org.springframework.web.socket.messaging.StompWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   message 1     =    StompTextMessageBuilder . create ( SUBSCRIBE )  . headers (  \" id : subs 1  \"  ,     \" destination :  / topic / increment \"  )  . build (  )  ;", "TextMessage   message 2     =    StompTextMessageBuilder . create ( SEND )  . headers (  \" destination :  / app / increment \"  )  . body (  \"  5  \"  )  . build (  )  ;", ". TestClientWebSocketHandler   clientHandler    =    new    . TestClientWebSocketHandler (  1  ,    message 1  ,    message 2  )  ;", "WebSocketSession   session    =    doHandshake ( clientHandler ,     \"  / ws \"  )  . get (  )  ;", "try    {", "assertTrue ( clientHandler . latch . await (  . TIMEOUT ,    TimeUnit . SECONDS )  )  ;", "}    finally    {", "session . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sendMessageToControllerAndReceiveReplyViaTopic"], "fileName": "org.springframework.web.socket.messaging.StompWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "String   destHeader    =     \" destination :  / app / number \"  ;", "TextMessage   message    =    StompTextMessageBuilder . create ( SUBSCRIBE )  . headers (  \" id : subs 1  \"  ,    destHeader )  . build (  )  ;", ". TestClientWebSocketHandler   clientHandler    =    new    . TestClientWebSocketHandler (  1  ,    message )  ;", "WebSocketSession   session    =    doHandshake ( clientHandler ,     \"  / ws \"  )  . get (  )  ;", "try    {", "assertTrue ( clientHandler . latch . await (  . TIMEOUT ,    TimeUnit . SECONDS )  )  ;", "String   payload    =    clientHandler . actual . get (  0  )  . getPayload (  )  ;", "assertTrue (  (  \" Expected   STOMP   destination =  / app / number ,    got    \"     +    payload )  ,    payload . contains ( destHeader )  )  ;", "assertTrue (  (  \" Expected   STOMP   Payload =  4  2  ,    got    \"     +    payload )  ,    payload . contains (  \"  4  2  \"  )  )  ;", "}    finally    {", "session . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sendSubscribeToControllerAndReceiveReply"], "fileName": "org.springframework.web.socket.messaging.StompWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   message 1     =    StompTextMessageBuilder . create ( SUBSCRIBE )  . headers (  \" id : subs 1  \"  ,     \" destination :  / topic / scopedBeanValue \"  )  . build (  )  ;", "TextMessage   message 2     =    StompTextMessageBuilder . create ( SEND )  . headers (  \" destination :  / app / scopedBeanValue \"  )  . build (  )  ;", ". TestClientWebSocketHandler   clientHandler    =    new    . TestClientWebSocketHandler (  1  ,    message 1  ,    message 2  )  ;", "WebSocketSession   session    =    doHandshake ( clientHandler ,     \"  / ws \"  )  . get (  )  ;", "try    {", "assertTrue ( clientHandler . latch . await (  . TIMEOUT ,    TimeUnit . SECONDS )  )  ;", "String   payload    =    clientHandler . actual . get (  0  )  . getPayload (  )  ;", "assertTrue ( payload . startsWith (  \" MESSAGE \\ n \"  )  )  ;", "assertTrue ( payload . contains (  \" destination :  / topic / scopedBeanValue \\ n \"  )  )  ;", "assertTrue ( payload . endsWith (  \"  5  5  \\ u 0  0  0  0  \"  )  )  ;", "}    finally    {", "session . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["webSocketScope"], "fileName": "org.springframework.web.socket.messaging.StompWebSocketIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    protocols    =    handler . getSupportedProtocols (  )  ;", "if    ( CollectionUtils . isEmpty ( protocols )  )     {", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  \" No   sub - protocols   for    \"     +    handler )  )  ;", "}", "return ;", "}", "for    ( String   protocol    :    protocols )     {", "Handler   replaced    =    this . protocolHandlerLookup . put ( protocol ,    handler )  ;", "if    (  ( replaced    !  =    null )     &  &     ( replaced    !  =    handler )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Cannot   map    \"     +    handler )     +     \"    to   protocol    '  \"  )     +    protocol )     +     \"  '  :    already   mapped   to    \"  )     +    replaced )     +     \"  .  \"  )  )  ;", "}", "}", "this . protocolHandlers . add ( handler )  ;", "}", "METHOD_END"], "methodName": ["addProtocolHandler"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "long   currentTime    =    System . currentTimeMillis (  )  ;", "if    (  (  !  ( isRunning (  )  )  )     |  |     (  ( currentTime    -     ( this . lastSessionCheckTime )  )     <     (  . TIME _ TO _ FIRST _ MESSAGE )  )  )     {", "return ;", "}", "if    ( this . sessionCheckLock . tryLock (  )  )     {", "try    {", "for    (  . WebSocketSessionHolder   holder    :    this . sessions . values (  )  )     {", "if    ( holder . hasHandledMessages (  )  )     {", "continue ;", "}", "long   timeSinceCreated    =    currentTime    -     ( holder . getCreateTime (  )  )  ;", "if    ( timeSinceCreated    <     (  . TIME _ TO _ FIRST _ MESSAGE )  )     {", "continue ;", "}", "WebSocketSession   session    =    holder . getSession (  )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  (  (  \" No   messages   received   after    \"     +    timeSinceCreated )     +     \"    ms .     \"  )     +     \" Closing    \"  )     +     ( holder . getSession (  )  )  )     +     \"  .  \"  )  )  ;", "}", "try    {", "this . stats . incrementNoMessagesReceivedCount (  )  ;", "session . close ( CloseStatus . SESSION _ NOT _ RELIABLE )  ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  \" Failed   to   close   unreliable    \"     +    session )  ,    ex )  ;", "}", "}", "}", "}    finally    {", "this . lastSessionCheckTime    =    currentTime ;", "this . sessionCheckLock . unlock (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkSessions"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Clearing   session    \"     +     ( session . getId (  )  )  )  )  ;", "}", "if    (  ( this . sessions . remove ( session . getId (  )  )  )     !  =    null )     {", "this . stats . decrementSessionCount ( session )  ;", "}", "findHandler ( session )  . afterSessionEnded ( session ,    closeStatus ,    this . clientInboundChannel )  ;", "}", "METHOD_END"], "methodName": ["clearSession"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   ConcurrentWebSocketSessionDecorator ( session ,    getSendTimeLimit (  )  ,    getSendBufferSizeLimit (  )  )  ;", "}", "METHOD_END"], "methodName": ["decorateSession"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "String   protocol    =    null ;", "try    {", "protocol    =    session . getAcceptedProtocol (  )  ;", "}    catch    ( Exception   ex )     {", "logger . error (  (  \" Failed   to   obtain   session . getAcceptedProtocol (  )  :     \"     +     \" will   use   the   default   protocol   handler    ( if   configured )  .  \"  )  ,    ex )  ;", "}", "Handler   handler ;", "if    (  !  ( StringUtils . isEmpty ( protocol )  )  )     {", "handler    =    this . protocolHandlerLookup . get ( protocol )  ;", "if    ( handler    =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  \" No   handler   for    '  \"     +    protocol )     +     \"  '    among    \"  )     +     ( this . protocolHandlerLookup )  )  )  ;", "}", "} else    {", "if    (  ( this . defaultProtocolHandler )     !  =    null )     {", "handler    =    this . defaultProtocolHandler ;", "} else", "if    (  ( this . protocolHandlers . size (  )  )     =  =     1  )     {", "handler    =    this . protocolHandlers . iterator (  )  . next (  )  ;", "} else    {", "throw   new   IllegalStateException (  (  \" Multiple   protocol   handlers   configured   and    \"     +     \" no   protocol   was   negotiated .    Consider   configuring   a   default   Handler .  \"  )  )  ;", "}", "}", "return   handler ;", "}", "METHOD_END"], "methodName": ["findProtocolHandler"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultProtocolHandler ;", "}", "METHOD_END"], "methodName": ["getDefaultProtocolHandler"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . protocolHandlerLookup ;", "}", "METHOD_END"], "methodName": ["getProtocolHandlerMap"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList <  >  ( this . protocolHandlers )  ;", "}", "METHOD_END"], "methodName": ["getProtocolHandlers"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . sendBufferSizeLimit ;", "}", "METHOD_END"], "methodName": ["getSendBufferSizeLimit"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . sendTimeLimit ;", "}", "METHOD_END"], "methodName": ["getSendTimeLimit"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . stats . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getStatsInfo"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList <  >  ( this . protocolHandlerLookup . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSubProtocols"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( SubProtocolHandler   handler    :    this . protocolHandlerLookup . values (  )  )     {", "String   sessionId    =    handler . resolveSessionId ( message )  ;", "if    ( sessionId    !  =    null )     {", "return   sessionId ;", "}", "}", "if    (  ( this . defaultProtocolHandler )     !  =    null )     {", "String   sessionId    =    this . defaultProtocolHandler . resolveSessionId ( message )  ;", "if    ( sessionId    !  =    null )     {", "return   sessionId ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveSessionId"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "this . defaultProtocolHandler    =    defaultProtocolHandler ;", "if    ( this . protocolHandlerLookup . isEmpty (  )  )     {", "setProtocolHandlers ( Collections . singletonList ( defaultProtocolHandler )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setDefaultProtocolHandler"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "this . protocolHandlerLookup . clear (  )  ;", "this . protocolHandlers . clear (  )  ;", "for    ( Handler   handler    :    protocolHandlers )     {", "addProtocolHandler ( handler )  ;", "}", "}", "METHOD_END"], "methodName": ["setProtocolHandlers"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "this . sendBufferSizeLimit    =    sendBufferSizeLimit ;", "}", "METHOD_END"], "methodName": ["setSendBufferSizeLimit"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "this . sendTimeLimit    =    sendTimeLimit ;", "}", "METHOD_END"], "methodName": ["setSendTimeLimit"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "TestWebSocketSession   session 1     =    new   TestWebSocketSession (  \" id 1  \"  )  ;", "TestWebSocketSession   session 2     =    new   TestWebSocketSession (  \" id 2  \"  )  ;", "session 1  . setOpen ( true )  ;", "session 2  . setOpen ( true )  ;", "session 1  . setAcceptedProtocol (  \" v 1  2  . stomp \"  )  ;", "session 2  . setAcceptedProtocol (  \" v 1  2  . stomp \"  )  ;", "this . w . setProtocolHandlers ( Arrays . asList ( this . stompHandler )  )  ;", "this . w . afterConnectionEstablished ( session 1  )  ;", "this . w . afterConnectionEstablished ( session 2  )  ;", "DirectFieldAccessor   handlerAccessor    =    new   DirectFieldAccessor ( this . w )  ;", "Map < String ,     ?  >    map    =     (  ( Map < String ,     ?  >  )     ( handlerAccessor . getPropertyValue (  \" sessions \"  )  )  )  ;", "DirectFieldAccessor   session 1 Accessor    =    new   DirectFieldAccessor ( map . get (  \" id 1  \"  )  )  ;", "DirectFieldAccessor   session 2 Accessor    =    new   DirectFieldAccessor ( map . get (  \" id 2  \"  )  )  ;", "long   sixtyOneSecondsAgo    =     ( System . currentTimeMillis (  )  )     -     (  6  1     *     1  0  0  0  )  ;", "handlerAccessor . setPropertyValue (  \" lastSessionCheckTime \"  ,    sixtyOneSecondsAgo )  ;", "session 1 Accessor . setPropertyValue (  \" createTime \"  ,    sixtyOneSecondsAgo )  ;", "session 2 Accessor . setPropertyValue (  \" createTime \"  ,    sixtyOneSecondsAgo )  ;", "this . w . start (  )  ;", "this . w . handleMessage ( session 1  ,    new   TextMessage (  \" foo \"  )  )  ;", "assertTrue ( session 1  . isOpen (  )  )  ;", "assertNull ( session 1  . getCloseStatus (  )  )  ;", "assertFalse ( session 2  . isOpen (  )  )  ;", "assertEquals ( CloseStatus . SESSION _ NOT _ RELIABLE ,    session 2  . getCloseStatus (  )  )  ;", "assertNotEquals (  \" lastSessionCheckTime   not   updated \"  ,    sixtyOneSecondsAgo ,    handlerAccessor . getPropertyValue (  \" lastSessionCheckTime \"  )  )  ;", "}", "METHOD_END"], "methodName": ["checkSession"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . session . setAcceptedProtocol (  \"  \"  )  ;", "this . w . setDefaultProtocolHandler ( this . defaultHandler )  ;", "this . w . afterConnectionEstablished ( session )  ;", "verify ( this . defaultHandler )  . afterSessionStarted ( isA ( ConcurrentWebSocketSessionDecorator . class )  ,    eq ( this . inClientChannel )  )  ;", "verify ( this . stompHandler ,    times (  0  )  )  . afterSessionStarted ( session ,    this . inClientChannel )  ;", "verify ( this . mqttHandler ,    times (  0  )  )  . afterSessionStarted ( session ,    this . inClientChannel )  ;", "}", "METHOD_END"], "methodName": ["emptySubProtocol"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . webSocketHandler . setProtocolHandlers ( Arrays . asList ( stompHandler ,    mqttHandler )  )  ;", "this . webSocketHandler . afterConnectionEstablished ( session )  ;", "}", "METHOD_END"], "methodName": ["noSubProtocolNoDefaultHandler"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . webSocketHandler . setProtocolHandlers ( Arrays . asList ( stompHandler )  )  ;", "this . webSocketHandler . afterConnectionEstablished ( session )  ;", "verify ( this . stompHandler )  . afterSessionStarted ( isA ( ConcurrentWebSocketSessionDecorator . class )  ,    eq ( this . inClientChannel )  )  ;", "}", "METHOD_END"], "methodName": ["noSubProtocolOneHandler"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . webSocketHandler . setProtocolHandlers ( Arrays . asList ( stompHandler ,    mqttHandler )  )  ;", "this . webSocketHandler . afterConnectionEstablished ( session )  ;", "}", "METHOD_END"], "methodName": ["noSubProtocolTwoHandlers"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . webSocketHandler . setDefaultProtocolHandler ( defaultHandler )  ;", "this . webSocketHandler . afterConnectionEstablished ( session )  ;", "verify ( this . defaultHandler )  . afterSessionStarted ( isA ( ConcurrentWebSocketSessionDecorator . class )  ,    eq ( this . inClientChannel )  )  ;", "verify ( this . stompHandler ,    times (  0  )  )  . afterSessionStarted ( session ,    this . inClientChannel )  ;", "verify ( this . mqttHandler ,    times (  0  )  )  . afterSessionStarted ( session ,    this . inClientChannel )  ;", "}", "METHOD_END"], "methodName": ["nullSubProtocol"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "this . webSocketHandler    =    new    ( this . inClientChannel ,    this . outClientChannel )  ;", "given ( stompHandler . getSupportedProtocols (  )  )  . willReturn ( Arrays . asList (  \" v 1  0  . stomp \"  ,     \" v 1  1  . stomp \"  ,     \" v 1  2  . stomp \"  )  )  ;", "given ( mqttHandler . getSupportedProtocols (  )  )  . willReturn ( Arrays . asList (  \" MQTT \"  )  )  ;", "this . session    =    new   TestWebSocketSession (  )  ;", "this . session . setId (  \"  1  \"  )  ;", "this . session . setOpen ( true )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . webSocketHandler . setDefaultProtocolHandler ( stompHandler )  ;", "this . session . setAcceptedProtocol (  \" v 1  2  . sToMp \"  )  ;", "this . webSocketHandler . afterConnectionEstablished ( session )  ;", "verify ( this . stompHandler )  . afterSessionStarted ( isA ( ConcurrentWebSocketSessionDecorator . class )  ,    eq ( this . inClientChannel )  )  ;", "}", "METHOD_END"], "methodName": ["subProtocolDefaultHandlerOnly"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . webSocketHandler . setProtocolHandlers ( Arrays . asList ( stompHandler ,    mqttHandler )  )  ;", "this . session . setAcceptedProtocol (  \" v 1  2  . sToMp \"  )  ;", "this . webSocketHandler . afterConnectionEstablished ( session )  ;", "verify ( this . stompHandler )  . afterSessionStarted ( isA ( ConcurrentWebSocketSessionDecorator . class )  ,    eq ( this . inClientChannel )  )  ;", "verify ( this . mqttHandler ,    times (  0  )  )  . afterSessionStarted ( session ,    this . inClientChannel )  ;", "}", "METHOD_END"], "methodName": ["subProtocolMatch"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . webSocketHandler . setDefaultProtocolHandler ( defaultHandler )  ;", "this . webSocketHandler . setProtocolHandlers ( Arrays . asList ( stompHandler ,    mqttHandler )  )  ;", "this . session . setAcceptedProtocol (  \" wamp \"  )  ;", "this . webSocketHandler . afterConnectionEstablished ( session )  ;", "}", "METHOD_END"], "methodName": ["subProtocolNoMatch"], "fileName": "org.springframework.web.socket.messaging.SubProtocolWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    getApplicationContext (  )  ;", "if    ( context    =  =    null )     {", "return ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Looking   for    @ MessageExceptionHandler   mappings :     \"     +    context )  )  ;", "}", "List < ControllerAdviceBean >    beans    =    ControllerAdviceBean . findAnnotatedBeans ( context )  ;", "AnnotationAwareOrderComparator . sort ( beans )  ;", "initMessagingAdviceCache (  . MessagingControllerAdviceBean . createFromList ( beans )  )  ;", "}", "METHOD_END"], "methodName": ["initControllerAdviceCache"], "fileName": "org.springframework.web.socket.messaging.WebSocketAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( beans    =  =    null )     {", "return ;", "}", "for    ( MessagingAdviceBean   bean    :    beans )     {", "Class <  ?  >    type    =    bean . getBeanType (  )  ;", "if    ( type    !  =    null )     {", "ExceptionHandlerMethodResolver   resolver    =    new   ExceptionHandlerMethodResolver ( type )  ;", "if    ( resolver . hasExceptionMappings (  )  )     {", "registerExceptionHandlerAdvice ( bean ,    resolver )  ;", "logger . info (  (  \" Detected    @ MessageExceptionHandler   methods   in    \"     +    bean )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["initMessagingAdviceCache"], "fileName": "org.springframework.web.socket.messaging.WebSocketAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . create (  )  ;", "headers . setSessionId (  \" session 1  \"  )  ;", "headers . setSessionAttributes ( new   ConcurrentHashMap (  )  )  ;", "headers . setDestination (  \"  / exception \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeaders ( headers )  . build (  )  ;", "this . messageHandler . handleMessage ( message )  ;", ". TestControllerAdvice   controllerAdvice    =    this . applicationContext . getBean (  . TestControllerAdvice . class )  ;", "assertTrue ( controllerAdvice . isExceptionHandled (  )  )  ;", "}", "METHOD_END"], "methodName": ["globalException"], "fileName": "org.springframework.web.socket.messaging.WebSocketAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . applicationContext    =    new   StaticApplicationContext (  )  ;", "this . applicationContext . registerSingleton (  \" controller \"  ,     . TestController . class )  ;", "this . applicationContext . registerSingleton (  \" controllerAdvice \"  ,     . TestControllerAdvice . class )  ;", "this . applicationContext . refresh (  )  ;", "SubscribableChannel   channel    =    Mockito . mock ( SubscribableChannel . class )  ;", "SimpMessageSendingOperations   brokerTemplate    =    new   SimpMessagingTemplate ( channel )  ;", "this . messageHandler    =    new    . TestWebSocketAnnotationMethodMessageHandler ( brokerTemplate ,    channel ,    channel )  ;", "this . messageHandler . setApplicationContext ( this . applicationContext )  ;", "this . messageHandler . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.socket.messaging.WebSocketAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   connect ( url ,    null ,    handler ,    uriVars )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClient"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( url ,     \"  ' url '    must   not   be   null \"  )  ;", "URI   uri    =    UriComponentsBuilder . fromUriSt ( url )  . buildAndExpand ( uriVariables )  . encode (  )  . toUri (  )  ;", "return   connect ( uri ,    handshakeHeaders ,    connectHeaders ,    handler )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClient"}, {"methodBody": ["METHOD_START", "{", "return   connect ( url ,    handshakeHeaders ,    null ,    handler ,    uriVariables )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClient"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( url ,     \"  ' url '    must   not   be   null \"  )  ;", "ConnectionHandlingStompSession   session    =    createSession ( connectHeaders ,    sessionHandler )  ;", ". WebSocketTcpConnectionHandlerAdapter   adapter    =    new    . WebSocketTcpConnectionHandlerAdapter ( session )  ;", "getWebSocketClient (  )  . doHandshake ( adapter ,    handshakeHeaders ,    url )  . addCallback ( adapter )  ;", "return   session . getSessionFuture (  )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClient"}, {"methodBody": ["METHOD_START", "{", "return   this . inboundMessageSizeLimit ;", "}", "METHOD_END"], "methodName": ["getInboundMessageSizeLimit"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClient"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketClient ;", "}", "METHOD_END"], "methodName": ["getWebSocketClient"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClient"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClient"}, {"methodBody": ["METHOD_START", "{", "this . inboundMessageSizeLimit    =    inboundMessageSizeLimit ;", "}", "METHOD_END"], "methodName": ["setInboundMessageSizeLimit"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClient"}, {"methodBody": ["METHOD_START", "{", "this . phase    =    phase ;", "}", "METHOD_END"], "methodName": ["setPhase"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClient"}, {"methodBody": ["METHOD_START", "{", "String   url    =     (  \" ws :  /  /  1  2  7  .  0  .  0  .  1  :  \"     +     ( this . server . getPort (  )  )  )     +     \"  / stomp \"  ;", ". TestHandler   testHandler    =    new    . TestHandler (  \"  / topic / foo \"  ,     \" payload \"  )  ;", "this . stompClient . connect ( url ,    testHandler )  ;", "assertTrue ( testHandler . awaitForMessageCount (  1  ,     5  0  0  0  )  )  ;", "assertThat ( testHandler . getReceived (  )  ,    containsInAnyOrder (  \" payload \"  )  )  ;", "}", "METHOD_END"], "methodName": ["publishSubscribe"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketStompClientIntegrationTests . logger . debug (  (  (  \" Setting   up   before    '  \"     +     ( this . testName . getMethodName (  )  )  )     +     \"  '  \"  )  )  ;", "this . wac    =    new   AnnotationConfigWebApplicationContext (  )  ;", "this . wac . register ( WebSocketStompClientIntegrationTests . TestConfig . class )  ;", "this . wac . refresh (  )  ;", "this . server    =    new   TomcatWebSocketTestServer (  )  ;", "this . server . setup (  )  ;", "this . server . deployConfig ( this . wac )  ;", "this . server . start (  )  ;", "WebSocketClient   webSocketClient    =    new   StandardWebSocketClient (  )  ;", "this . stompClient    =    new   WebSocketStompClient ( webSocketClient )  ;", "this . stompClient . setMessageConverter ( new   StringMessageConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . server . undeployConfig (  )  ;", "}    catch    ( Throwable   t )     {", ". logger . error (  \" Failed   to   undeploy   application   config \"  ,    t )  ;", "}", "try    {", "this . server . stop (  )  ;", "}    catch    ( Throwable   t )     {", ". logger . error (  \" Failed   to   stop   server \"  ,    t )  ;", "}", "try    {", "this . wac . close (  )  ;", "}    catch    ( Throwable   t )     {", ". logger . error (  \" Failed   to   close   WebApplicationContext \"  ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "TcpConnection < byte [  ]  >    tcpConnection    =    getTcpConnection (  )  ;", "ScheduledFuture   future    =    mock ( ScheduledFuture . class )  ;", "when ( this . taskScheduler . scheduleWithFixedDelay ( any (  )  ,    eq (  1 L )  )  )  . thenReturn ( future )  ;", "tcpConnection . onReadInactivity ( mock ( Runnable . class )  ,     2 L )  ;", "tcpConnection . onWriteInactivity ( mock ( Runnable . class )  ,     2 L )  ;", "this . webSocketHandlerCaptor . getValue (  )  . afterConnectionClosed ( this . wession ,    CloseStatus . NORMAL )  ;", "verify ( future ,    times (  2  )  )  . cancel ( true )  ;", "verifyNoMoreInteractions ( future )  ;", "}", "METHOD_END"], "methodName": ["cancelInactivityTasks"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "this . stompClient . connect (  \"  / foo \"  ,    mock ( StompSessionHandler . class )  )  ;", "verify ( this . stompSession )  . getSessionFuture (  )  ;", "verifyNoMoreInteractions ( this . stompSession )  ;", "WebSocketHandler   webSocketHandler    =    this . webSocketHandlerCaptor . getValue (  )  ;", "assertNotNull ( webSocketHandler )  ;", "return   webSocketHandler ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   webSocketHandler    =    connect (  )  ;", "webSocketHandler . afterConnectionEstablished ( this . webSocketSession )  ;", "return    (  ( TcpConnection < byte [  ]  >  )     ( webSocketHandler )  )  ;", "}", "METHOD_END"], "methodName": ["getTcpConnection"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" SEND \\ na : alpha \\ n \\ nMessage   payload \\ u 0  0  0  0  \"  ;", "connect (  )  . handleMessage ( this . wession ,    new   TextMessage ( text )  )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "verify ( this . stompSession )  . handleMessage ( captor . capture (  )  )  ;", "Message < byte [  ]  >    message    =    captor . getValue (  )  ;", "assertNotNull ( message )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "StompHeaders   headers    =    StompHeaders . readOnlyStompHeaders ( accessor . toNativeHeaderMap (  )  )  ;", "assertEquals ( SEND ,    accessor . getCommand (  )  )  ;", "assertEquals (  \" alpha \"  ,    headers . getFirst (  \" a \"  )  )  ;", "assertEquals (  \" Message   payload \"  ,    new   String ( message . getPayload (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["handleWebSocketMessage"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" SEND \\ na : alpha \\ n \\ nMessage   payload \\ u 0  0  0  0  \"  ;", "connect (  )  . handleMessage ( this . wession ,    new   BinaryMessage ( text . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "verify ( this . stompSession )  . handleMessage ( captor . capture (  )  )  ;", "Message < byte [  ]  >    message    =    captor . getValue (  )  ;", "assertNotNull ( message )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "StompHeaders   headers    =    StompHeaders . readOnlyStompHeaders ( accessor . toNativeHeaderMap (  )  )  ;", "assertEquals ( SEND ,    accessor . getCommand (  )  )  ;", "assertEquals (  \" alpha \"  ,    headers . getFirst (  \" a \"  )  )  ;", "assertEquals (  \" Message   payload \"  ,    new   String ( message . getPayload (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["handleWebSocketMessageBinary"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "connect (  )  . handleMessage ( this . webSocketSession ,    new   PongMessage (  )  )  ;", "verifyNoMoreInteractions ( this . stompSession )  ;", "}", "METHOD_END"], "methodName": ["handleWebSocketMessagePong"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   webSocketHandler    =    connect (  )  ;", "String   part 1     =     \" SEND \\ na : alpha \\ n \\ nMessage \"  ;", "webSocketHandler . handleMessage ( this . webSocketSession ,    new   TextMessage ( part 1  )  )  ;", "verifyNoMoreInteractions ( this . stompSession )  ;", "String   part 2     =     \"    payload \\ u 0  0  0  0  \"  ;", "webSocketHandler . handleMessage ( this . webSocketSession ,    new   TextMessage ( part 2  )  )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "verify ( this . stompSession )  . handleMessage ( captor . capture (  )  )  ;", "Message < byte [  ]  >    message    =    captor . getValue (  )  ;", "assertNotNull ( message )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "StompHeaders   headers    =    StompHeaders . readOnlyStompHeaders ( accessor . toNativeHeaderMap (  )  )  ;", "assertEquals ( SEND ,    accessor . getCommand (  )  )  ;", "assertEquals (  \" alpha \"  ,    headers . getFirst (  \" a \"  )  )  ;", "assertEquals (  \" Message   payload \"  ,    new   String ( message . getPayload (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["handleWebSocketMessageSplitAcrossTwoMessage"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketStompClient   stompClient    =    new   WebSocketStompClient ( mock ( WebSocketClient . class )  )  ;", "assertArrayEquals ( new   long [  ]  {     0  ,     0     }  ,    stompClient . getDefaultHeartbeat (  )  )  ;", "StompHeaders   connectHeaders    =    stompClient . processConnectHeaders ( null )  ;", "assertArrayEquals ( new   long [  ]  {     0  ,     0     }  ,    connectHeaders . getHeartbeat (  )  )  ;", "}", "METHOD_END"], "methodName": ["heartbeatDefaultValue"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketStompClient   stompClient    =    new   WebSocketStompClient ( mock ( WebSocketClient . class )  )  ;", "stompClient . setDefaultHeartbeat ( new   long [  ]  {     5  ,     5     }  )  ;", "try    {", "stompClient . processConnectHeaders ( null )  ;", "fail (  \" Expected   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["heartbeatDefaultValueSetWithoutScheduler"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketStompClient   stompClient    =    new   WebSocketStompClient ( mock ( WebSocketClient . class )  )  ;", "stompClient . setTaskScheduler ( mock ( TaskScheduler . class )  )  ;", "assertArrayEquals ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ,    stompClient . getDefaultHeartbeat (  )  )  ;", "StompHeaders   connectHeaders    =    stompClient . processConnectHeaders ( null )  ;", "assertArrayEquals ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ,    connectHeaders . getHeartbeat (  )  )  ;", "}", "METHOD_END"], "methodName": ["heartbeatDefaultValueWithScheduler"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "TcpConnection < byte [  ]  >    tcpConnection    =    getTcpConnection (  )  ;", "Runnable   runnable    =    m ( Runnable . class )  ;", "long   delay    =     2  ;", "tcpConnection . onReadInactivity ( runnable ,    delay )  ;", "testInactivityTaskScheduling ( runnable ,    delay ,     1  0  )  ;", "}", "METHOD_END"], "methodName": ["readInactivityAfterDelayHasElapsed"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "TcpConnection < byte [  ]  >    tcpConnection    =    getTcpConnection (  )  ;", "Runnable   runnable    =    m ( Runnable . class )  ;", "long   delay    =     1  0  0  0  0  ;", "tcpConnection . onReadInactivity ( runnable ,    delay )  ;", "testInactivityTaskScheduling ( runnable ,    delay ,     0  )  ;", "}", "METHOD_END"], "methodName": ["readInactivityBeforeDelayHasElapsed"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( SEND )  ;", "accessor . setDestination (  \"  / b \"  )  ;", "accessor . setContentType ( APPLICATION _ OCTET _ STREAM )  ;", "byte [  ]    payload    =     \" payload \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "getTcpConnection (  )  . send ( MessageBuilder . createMessage ( payload ,    accessor . getMessageHeaders (  )  )  )  ;", "ArgumentCaptor < BinaryMessage >    binaryMessageCaptor    =    ArgumentCaptor . forClass ( BinaryMessage . class )  ;", "verify ( this . wession )  . sendMessage ( binaryMessageCaptor . capture (  )  )  ;", "BinaryMessage   binaryMessage    =    binaryMessageCaptor . getValue (  )  ;", "assertNotNull ( binaryMessage )  ;", "assertEquals (  \" SEND \\ ndestination :  / b \\ ncontent - type : application / octet - stream \\ ncontent - length :  7  \\ n \\ npayload \\ u 0  0  0  0  \"  ,    new   String ( binaryMessage . getPayload (  )  . array (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["sendWebSocketBinary"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( SEND )  ;", "accessor . setDestination (  \"  / topic / foo \"  )  ;", "byte [  ]    payload    =     \" payload \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "getTcpConnection (  )  . send ( MessageBuilder . createMessage ( payload ,    accessor . getMessageHeaders (  )  )  )  ;", "ArgumentCaptor < TextMessage >    textMessageCaptor    =    ArgumentCaptor . forClass ( TextMessage . class )  ;", "verify ( this . wession )  . sendMessage ( textMessageCaptor . capture (  )  )  ;", "TextMessage   textMessage    =    textMessageCaptor . getValue (  )  ;", "assertNotNull ( textMessage )  ;", "assertEquals (  \" SEND \\ ndestination :  / topic / foo \\ ncontent - length :  7  \\ n \\ npayload \\ u 0  0  0  0  \"  ,    textMessage . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendWebSocketMessage"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "WebSocketClient   webSocketClient    =    mock ( WebSocketClient . class )  ;", "this . stompClient    =    new    . TestWebSocketStompClient ( webSocketClient )  ;", "this . stompClient . setTaskScheduler ( this . taskScheduler )  ;", "this . stompClient . setStompSession ( this . stompSession )  ;", "this . webSocketHandlerCaptor    =    ArgumentCaptor . forClass ( WebSocketHandler . class )  ;", "this . handshakeFuture    =    new   SettableListenableFuture (  )  ;", "when ( webSocketClient . doHandshake ( this . webSocketHandlerCaptor . capture (  )  ,    any (  )  ,    any ( URI . class )  )  )  . thenReturn ( this . handshakeFuture )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "ArgumentCaptor < Runnable >    inactivityTaskCaptor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "verify ( this . taskScheduler )  . scheduleWithFixedDelay ( inactivityTaskCaptor . capture (  )  ,    eq (  ( delay    /     2  )  )  )  ;", "verifyNoMoreInteractions ( this . taskScheduler )  ;", "if    ( sleepTime    >     0  )     {", "Thread . sleep ( sleepTime )  ;", "}", "Runnable   inactivityTask    =    inactivityTaskCaptor . getValue (  )  ;", "assertNotNull ( inactivityTask )  ;", "inactivityTask . run (  )  ;", "if    ( sleepTime    >     0  )     {", "verify ( runnable )  . run (  )  ;", "} else    {", "verifyNoMoreInteractions ( runnable )  ;", "}", "}", "METHOD_END"], "methodName": ["testInactivityTaskScheduling"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "connect (  )  . afterConnectionClosed ( this . webSocketSession ,    CloseStatus . NORMAL )  ;", "verify ( this . stompSession )  . afterConnectionClosed (  )  ;", "}", "METHOD_END"], "methodName": ["webSocketConnectionClosed"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "connect (  )  . afterConnectionEstablished ( this . webSocketSession )  ;", "verify ( this . stompSession )  . afterConnected ( notNull (  )  )  ;", "}", "METHOD_END"], "methodName": ["webSocketConnectionEstablished"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "connect (  )  ;", "IllegalStateException   handshakeFailure    =    new   IllegalStateException (  \" simulated   exception \"  )  ;", "this . handshakeFuture . setException ( handshakeFailure )  ;", "verify ( this . sSession )  . afterConnectFailure ( same ( handshakeFailure )  )  ;", "}", "METHOD_END"], "methodName": ["webSocketHandshakeFailure"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "IllegalStateException   exception    =    new   IllegalStateException (  \" simulated   exception \"  )  ;", "connect (  )  . handleTransportError ( this . wession ,    exception )  ;", "verify ( this . stompSession )  . handleFailure ( same ( exception )  )  ;", "}", "METHOD_END"], "methodName": ["webSocketTransportError"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "TcpConnection < byte [  ]  >    tcpConnection    =    getTcpConnection (  )  ;", "Runnable   runnable    =    m ( Runnable . class )  ;", "long   delay    =     2  ;", "tcpConnection . onWriteInactivity ( runnable ,    delay )  ;", "testInactivityTaskScheduling ( runnable ,    delay ,     1  0  )  ;", "}", "METHOD_END"], "methodName": ["writeInactivityAfterDelayHasElapsed"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "TcpConnection < byte [  ]  >    tcpConnection    =    getTcpConnection (  )  ;", "Runnable   runnable    =    m ( Runnable . class )  ;", "long   delay    =     1  0  0  0  ;", "tcpConnection . onWriteInactivity ( runnable ,    delay )  ;", "testInactivityTaskScheduling ( runnable ,    delay ,     0  )  ;", "}", "METHOD_END"], "methodName": ["writeInactivityBeforeDelayHasElapsed"], "fileName": "org.springframework.web.socket.messaging.WebSocketStompClientTests"}, {"methodBody": ["METHOD_START", "{", "super . setup (  )  ;", "MockitoAnnotations . initMocks ( this )  ;", "this . handshakeHandler    =    new    ( this . upgradeStrategy )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.server.DefaultHandshakeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . upgradeStrategy . getSupportedVersions (  )  )  . willReturn ( new   String [  ]  {     \"  1  3  \"     }  )  ;", "this . servletRequest . setMethod (  \" GET \"  )  ;", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders ( this . request . getHeaders (  )  )  ;", "headers . setUpgrade (  \" WebSocket \"  )  ;", "headers . setConnection (  \" Upgrade \"  )  ;", "headers . setSecWebSocketVersion (  \"  1  3  \"  )  ;", "headers . setSecWebSocketKey (  \"  8  2  / ZS 2 YHjEnUN 9  7 HLL 8 tbw =  =  \"  )  ;", "headers . setSecWebSocketProtocol (  \" v 1  1  . stomp \"  )  ;", "WebSocketHandler   handler    =    new    . SubProtocolCapableHandler (  \" v 1  2  . stomp \"  ,     \" v 1  1  . stomp \"  )  ;", "Map < String ,    Object >    attributes    =    Collections .  < String ,    Object > emptyMap (  )  ;", "this . handshakeHandler . doHandshake ( this . request ,    this . response ,    handler ,    attributes )  ;", "verify ( this . upgradeStrategy )  . upgrade ( this . request ,    this . response ,     \" v 1  1  . stomp \"  ,    Collections . emptyList (  )  ,    null ,    handler ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["subProtocolCapableHandler"], "fileName": "org.springframework.web.socket.server.DefaultHandshakeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . upgradeStrategy . getSupportedVersions (  )  )  . willReturn ( new   String [  ]  {     \"  1  3  \"     }  )  ;", "this . servletRequest . setMethod (  \" GET \"  )  ;", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders ( this . request . getHeaders (  )  )  ;", "headers . setUpgrade (  \" WebSocket \"  )  ;", "headers . setConnection (  \" Upgrade \"  )  ;", "headers . setSecWebSocketVersion (  \"  1  3  \"  )  ;", "headers . setSecWebSocketKey (  \"  8  2  / ZS 2 YHjEnUN 9  7 HLL 8 tbw =  =  \"  )  ;", "headers . setSecWebSocketProtocol (  \" v 1  0  . stomp \"  )  ;", "WebSocketHandler   handler    =    new    . SubProtocolCapableHandler (  \" v 1  2  . stomp \"  ,     \" v 1  1  . stomp \"  )  ;", "Map < String ,    Object >    attributes    =    Collections .  < String ,    Object > emptyMap (  )  ;", "this . handshakeHandler . doHandshake ( this . request ,    this . response ,    handler ,    attributes )  ;", "verify ( this . upgradeStrategy )  . upgrade ( this . request ,    this . response ,    null ,    Collections . emptyList (  )  ,    null ,    handler ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["subProtocolCapableHandlerNoMatch"], "fileName": "org.springframework.web.socket.server.DefaultHandshakeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketExtension   extension 1     =    new   WebSocketExtension (  \" ext 1  \"  )  ;", "WebSocketExtension   extension 2     =    new   WebSocketExtension (  \" ext 2  \"  )  ;", "given ( this . upgradeStrategy . getSupportedVersions (  )  )  . willReturn ( new   String [  ]  {     \"  1  3  \"     }  )  ;", "given ( this . upgradeStrategy . getSupportedExtensions ( this . request )  )  . willReturn ( Collections . singletonList ( extension 1  )  )  ;", "this . servletRequest . setMethod (  \" GET \"  )  ;", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders ( this . request . getHeaders (  )  )  ;", "headers . setUpgrade (  \" WebSocket \"  )  ;", "headers . setConnection (  \" Upgrade \"  )  ;", "headers . setSecWebSocketVersion (  \"  1  3  \"  )  ;", "headers . setSecWebSocketKey (  \"  8  2  / ZS 2 YHjEnUN 9  7 HLL 8 tbw =  =  \"  )  ;", "headers . setSecWebSocketExtensions ( Arrays . asList ( extension 1  ,    extension 2  )  )  ;", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "Map < String ,    Object >    attributes    =    Collections .  < String ,    Object > emptyMap (  )  ;", "this . h . doHandshake ( this . request ,    this . response ,    handler ,    attributes )  ;", "verify ( this . upgradeStrategy )  . upgrade ( this . request ,    this . response ,    null ,    Collections . singletonList ( extension 1  )  ,    null ,    handler ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["supportedExtensions"], "fileName": "org.springframework.web.socket.server.DefaultHandshakeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handshakeHandler . setSupportedProtocols (  \" stomp \"  ,     \" mqtt \"  )  ;", "given ( this . upgradeStrategy . getSupportedVersions (  )  )  . willReturn ( new   String [  ]  {     \"  1  3  \"     }  )  ;", "this . servletRequest . setMethod (  \" GET \"  )  ;", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders ( this . request . getHeaders (  )  )  ;", "headers . setUpgrade (  \" WebSocket \"  )  ;", "headers . setConnection (  \" Upgrade \"  )  ;", "headers . setSecWebSocketVersion (  \"  1  3  \"  )  ;", "headers . setSecWebSocketKey (  \"  8  2  / ZS 2 YHjEnUN 9  7 HLL 8 tbw =  =  \"  )  ;", "headers . setSecWebSocketProtocol (  \" STOMP \"  )  ;", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "Map < String ,    Object >    attributes    =    Collections . emptyMap (  )  ;", "this . handshakeHandler . doHandshake ( this . request ,    this . response ,    handler ,    attributes )  ;", "verify ( this . upgradeStrategy )  . upgrade ( this . request ,    this . response ,     \" STOMP \"  ,    Collections . emptyList (  )  ,    null ,    handler ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["supportedSubProtocols"], "fileName": "org.springframework.web.socket.server.DefaultHandshakeHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    names    =    this . factory . getExtensionFactory (  )  . getExtensionNames (  )  ;", "List < WebSExtension >    result    =    new   ArrayList <  >  ( names . size (  )  )  ;", "for    ( String   name    :    names )     {", "result . add ( new   WebSExtension ( name )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["buildWebSocketExtensions"], "fileName": "org.springframework.web.socket.server.jetty.JettyRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "ServletContext   servletContext    =    request . getServletContext (  )  ;", "String   attrName    =     \" webServerContainer \"  ;", "ServerContainer   container    =     (  ( ServerContainer )     ( servletContext . getAttribute ( attrName )  )  )  ;", "Assert . notNull ( container ,     (  \" No    ' webServerContainer '    ServletContext   attribute .     \"     +     \" Are   you   running   in   a   Servlet   container   that   supports   JSR -  3  5  6  ?  \"  )  )  ;", "return   container ;", "}", "METHOD_END"], "methodName": ["getContainer"], "fileName": "org.springframework.web.socket.server.standard.AbstractStandardUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( ServletServerHttpRequest . class ,    request ,     \" ServletServerHttpRequest   required \"  )  ;", "return    (  ( ServletServerHttpRequest )     ( request )  )  . getServletRequest (  )  ;", "}", "METHOD_END"], "methodName": ["getHttpServletRequest"], "fileName": "org.springframework.web.socket.server.standard.AbstractStandardUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( ServletServerHttpResponse . class ,    response ,     \" ServletServerHttpResponse   required \"  )  ;", "return    (  ( ServletServerHttpResponse )     ( response )  )  . getServletResponse (  )  ;", "}", "METHOD_END"], "methodName": ["getHttpServletResponse"], "fileName": "org.springframework.web.socket.server.standard.AbstractStandardUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "List < WebSocketExtension >    result    =    new   ArrayList <  >  (  )  ;", "for    ( Extension   extension    :    container . getInstalledExtensions (  )  )     {", "result . add ( new   ToWebSocketExtensionAdapter ( extension )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getInstalledExtensions"], "fileName": "org.springframework.web.socket.server.standard.AbstractStandardUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "DirectFieldAccessor   accessor    =    new   DirectFieldAccessor ( engine )  ;", "Object   sessionListener    =    accessor . getPropertyValue (  \" sessionListener \"  )  ;", "Object   clusterContext    =    accessor . getPropertyValue (  \" clusterContext \"  )  ;", "try    {", "if    (  . constructorWithBooleanArgument )     {", "return    . constructor . newInstance ( registration . getEndpoint (  )  ,    registration ,    provider ,    container ,     \"  /  \"  ,    registration . getConfigurator (  )  ,    sessionListener ,    clusterContext ,    null ,    Boolean . TRUE )  ;", "} else    {", "return    . constructor . newInstance ( registration . getEndpoint (  )  ,    registration ,    provider ,    container ,     \"  /  \"  ,    registration . getConfigurator (  )  ,    sessionListener ,    clusterContext ,    null )  ;", "}", "}    catch    ( Exception   ex )     {", "throw   new   HandshakeFailureException (  (  \" Failed   to   register    \"     +    registration )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createEndpoint"], "fileName": "org.springframework.web.socket.server.standard.AbstractTyrusRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "RequestContext   context    =    Builder . create (  )  . requestURI ( URI . create ( endpointPath )  )  . userPrincipal ( request . getUserPrincipal (  )  )  . secure ( request . isSecure (  )  )  . remoteAddr ( request . getRemoteAddr (  )  )  . build (  )  ;", "headers . forEach (  (    header ,    value )     -  >    context . getHeaders (  )  . put ( header ,    value )  )  ;", "return   context ;", "}", "METHOD_END"], "methodName": ["createRequestContext"], "fileName": "org.springframework.web.socket.server.standard.AbstractTyrusRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "ServerEndpointRegistration   endpointConfig    =    new   ServerEndpointRegistration ( endpointPath ,    endpoint )  ;", "endpointConfig . setSubprotocols ( Collections . singletonList ( protocol )  )  ;", "endpointConfig . setExtensions ( extensions )  ;", "return   createEndpoint ( endpointConfig ,    this . componentProvider ,    container ,    engine )  ;", "}", "METHOD_END"], "methodName": ["createTyrusEndpoint"], "fileName": "org.springframework.web.socket.server.standard.AbstractTyrusRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "for    ( Constructor <  ?  >    current    :    TyrusEndpointWrapper . class . getConstructors (  )  )     {", "Class <  ?  >  [  ]    types    =    current . getParameterTypes (  )  ;", "if    (  (  ( Endpoint . class )     =  =     ( types [  0  ]  )  )     &  &     (  ( EndpointConfig . class )     =  =     ( types [  1  ]  )  )  )     {", "return   current ;", "}", "}", "throw   new   IllegalStateException (  \" No   compatible   Tyrus   version   found \"  )  ;", "}", "METHOD_END"], "methodName": ["getEndpointConstructor"], "fileName": "org.springframework.web.socket.server.standard.AbstractTyrusRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "try    {", ". registerMethod . invoke ( engine ,    endpoint )  ;", "}    catch    ( Exception   ex )     {", "throw   new   HandshakeFailureException (  (  \" Failed   to   register    \"     +    endpoint )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.springframework.web.socket.server.standard.AbstractTyrusRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "try    {", ". unRegisterMethod . invoke ( engine ,    endpoint )  ;", "}    catch    ( Exception   ex )     {", "throw   new   HandshakeFailureException (  (  \" Failed   to   unregister    \"     +    endpoint )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["unregister"], "fileName": "org.springframework.web.socket.server.standard.AbstractTyrusRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "if    ( tyrusEndpoint    !  =    null )     {", "try    {", "unregister ( engine ,    tyrusEndpoint )  ;", "}    catch    ( Throwable   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["unregisterTyrusEndpoint"], "fileName": "org.springframework.web.socket.server.standard.AbstractTyrusRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( Writer )     (  . constructor . newInstance ( handler )  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   HandshakeFailureException (  \" Failed   to   instantiate   TyrusServletWriter \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newServletWriter"], "fileName": "org.springframework.web.socket.server.standard.GlassFishRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "return   this . serverContainer ;", "}", "METHOD_END"], "methodName": ["getServerContainer"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporter"}, {"methodBody": ["METHOD_START", "{", "ServerContainer   serverContainer    =    getServerContainer (  )  ;", "Assert . state (  ( serverContainer    !  =    null )  ,     \" No   ServerContainer   set \"  )  ;", "try    {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Registering    @    class :     \"     +    endpointClass )  )  ;", "}", "serverContainer . addEndpoint ( endpointClass )  ;", "}    catch    ( DeploymentException   ex )     {", "throw   new   IllegalStateException (  (  \" Failed   to   register    @    class :     \"     +    endpointClass )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["registerEndpoint"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporter"}, {"methodBody": ["METHOD_START", "{", "ServerContainer   serverContainer    =    getServerContainer (  )  ;", "Assert . state (  ( serverContainer    !  =    null )  ,     \" No   ServerContainer   set \"  )  ;", "try    {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Registering   Config :     \"     +    endpointConfig )  )  ;", "}", "serverContainer . addEndpoint ( endpointConfig )  ;", "}    catch    ( DeploymentException   ex )     {", "throw   new   IllegalStateException (  (  \" Failed   to   register   Config :     \"     +    endpointConfig )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["registerEndpoint"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporter"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?  >  >    endpointClasses    =    new   LinkedHashSet <  >  (  )  ;", "if    (  ( this . annotatedEndpointClasses )     !  =    null )     {", "endpointClasses . addAll ( this . annotatedEndpointClasses )  ;", "}", "ApplicationContext   context    =    getApplicationContext (  )  ;", "if    ( context    !  =    null )     {", "String [  ]    endpointBeanNames    =    context . getBeanNamesForAnnotation (  . class )  ;", "for    ( String   beanName    :    endpointBeanNames )     {", "endpointClasses . add ( context . getType ( beanName )  )  ;", "}", "}", "for    ( Class <  ?  >    endpointClass    :    endpointClasses )     {", "registerEndpoint ( endpointClass )  ;", "}", "if    ( context    !  =    null )     {", "Map < String ,    Config >    endpointConfigMap    =    context . getBeansOfType ( Config . class )  ;", "for    ( Config   endpointConfig    :    endpointConfigMap . values (  )  )     {", "registerEndpoint ( endpointConfig )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerEndpoints"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporter"}, {"methodBody": ["METHOD_START", "{", "this . annotatedEndpointClasses    =    Arrays . asList ( annotatedEndpointClasses )  ;", "}", "METHOD_END"], "methodName": ["setAnnotatedEndpointClasses"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporter"}, {"methodBody": ["METHOD_START", "{", "this . serverContainer    =    serverContainer ;", "}", "METHOD_END"], "methodName": ["setServerContainer"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporter"}, {"methodBody": ["METHOD_START", "{", "this . exporter . setAnnotatedEndpointClasses ( ServerEndpointExporterTests . AnnotatedDummyEndpoint . class )  ;", "this . exporter . setApplicationContext ( this . webAppContext )  ;", "this . exporter . afterPropertiesSet (  )  ;", "this . exporter . afterSingletonsInstantiated (  )  ;", "verify ( this . serverContainer )  . addEndpoint ( ServerEndpointExporterTests . AnnotatedDummyEndpoint . class )  ;", "verify ( this . serverContainer )  . addEndpoint ( ServerEndpointExporterTests . AnnotatedDummyEndpointBean . class )  ;", "}", "METHOD_END"], "methodName": ["addAnnotatedEndpointClasses"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporterTests"}, {"methodBody": ["METHOD_START", "{", "this . exporter . setAnnotatedEndpointClasses ( ServerEndpointExporterTests . AnnotatedDummyEndpoint . class ,    ServerEndpointExporterTests . AnnotatedDummyEndpointBean . class )  ;", "this . exporter . setServerContainer ( this . serverContainer )  ;", "this . exporter . afterPropertiesSet (  )  ;", "this . exporter . afterSingletonsInstantiated (  )  ;", "verify ( this . serverContainer )  . addEndpoint ( ServerEndpointExporterTests . AnnotatedDummyEndpoint . class )  ;", "verify ( this . serverContainer )  . addEndpoint ( ServerEndpointExporterTests . AnnotatedDummyEndpointBean . class )  ;", "}", "METHOD_END"], "methodName": ["addAnnotatedEndpointClassesWithExplicitServerContainerOnly"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporterTests"}, {"methodBody": ["METHOD_START", "{", "this . exporter . setAnnotatedEndpointClasses ( ServerEndpointExporterTests . AnnotatedDummyEndpoint . class ,    ServerEndpointExporterTests . AnnotatedDummyEndpointBean . class )  ;", "this . exporter . setServletContext ( this . servletContext )  ;", "this . exporter . afterPropertiesSet (  )  ;", "this . exporter . afterSingletonsInstantiated (  )  ;", "verify ( this . serverContainer )  . addEndpoint ( ServerEndpointExporterTests . AnnotatedDummyEndpoint . class )  ;", "verify ( this . serverContainer )  . addEndpoint ( ServerEndpointExporterTests . AnnotatedDummyEndpointBean . class )  ;", "}", "METHOD_END"], "methodName": ["addAnnotatedEndpointClassesWithServletContextOnly"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporterTests"}, {"methodBody": ["METHOD_START", "{", "ServerEndpointRegistration   endpointRegistration    =    new   ServerEndpointRegistration (  \"  / dummy \"  ,    new   ServerEndpointExporterTests . DummyEndpoint (  )  )  ;", "this . webAppContext . getBeanFactory (  )  . registerSingleton (  \" dummyEndpoint \"  ,    endpointRegistration )  ;", "this . exporter . setApplicationContext ( this . webAppContext )  ;", "this . exporter . afterPropertiesSet (  )  ;", "this . exporter . afterSingletonsInstantiated (  )  ;", "verify ( this . serverContainer )  . addEndpoint ( endpointRegistration )  ;", "}", "METHOD_END"], "methodName": ["addServerEndpointConfigBean"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporterTests"}, {"methodBody": ["METHOD_START", "{", "ServerEndpointRegistration   endpointRegistration    =    new   ServerEndpointRegistration (  \"  / dummy \"  ,    new   ServerEndpointExporterTests . DummyEndpoint (  )  )  ;", "this . webAppContext . getBeanFactory (  )  . registerSingleton (  \" dummyEndpoint \"  ,    endpointRegistration )  ;", "this . servletContext . removeAttribute (  \" ServerContainer \"  )  ;", "this . exporter . setServerContainer ( this . serverContainer )  ;", "this . exporter . setApplicationContext ( this . webAppContext )  ;", "this . exporter . afterPropertiesSet (  )  ;", "this . exporter . afterSingletonsInstantiated (  )  ;", "verify ( this . serverContainer )  . addEndpoint ( endpointRegistration )  ;", "}", "METHOD_END"], "methodName": ["addServerEndpointConfigBeanWithExplicitServerContainer"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporterTests"}, {"methodBody": ["METHOD_START", "{", "ServerEndpointRegistration   endpointRegistration    =    new   ServerEndpointRegistration (  \"  / dummy \"  ,    new   ServerEndpointExporterTests . DummyEndpoint (  )  )  ;", "this . webAppContext . getBeanFactory (  )  . registerSingleton (  \" dummyEndpoint \"  ,    endpointRegistration )  ;", "this . exporter . setServletContext ( this . servletContext )  ;", "this . exporter . setApplicationContext ( this . webAppContext )  ;", "this . exporter . afterPropertiesSet (  )  ;", "this . exporter . afterSingletonsInstantiated (  )  ;", "verify ( this . serverContainer )  . addEndpoint ( endpointRegistration )  ;", "}", "METHOD_END"], "methodName": ["addServerEndpointConfigBeanWithExplicitServletContext"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporterTests"}, {"methodBody": ["METHOD_START", "{", "this . serverContainer    =    mock ( ServerContainer . class )  ;", "this . servletContext    =    new   MockServletContext (  )  ;", "this . servletContext . setAttribute (  \" ServerContainer \"  ,    this . serverContainer )  ;", "this . webAppContext    =    new   AnnotationConfigWebApplicationContext (  )  ;", "this . webAppContext . register (  . Config . class )  ;", "this . webAppContext . setServletContext ( this . servletContext )  ;", "this . webAppContext . refresh (  )  ;", "this . exporter    =    new   ServerEndpointExporter (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointExporterTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . endpoint )     !  =    null )     {", "return   this . endpoint ;", "} else    {", "Assert . state (  (  ( this . endpointProvider )     !  =    null )  ,     \" No   endpoint   set \"  )  ;", "return   this . endpointProvider . getHandler (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getEndpoint"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointRegistration"}, {"methodBody": ["METHOD_START", "{", "this . decoders    =    decoders ;", "}", "METHOD_END"], "methodName": ["setDecoders"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointRegistration"}, {"methodBody": ["METHOD_START", "{", "this . encoders    =    encoders ;", "}", "METHOD_END"], "methodName": ["setEncoders"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointRegistration"}, {"methodBody": ["METHOD_START", "{", "this . extensions    =    extensions ;", "}", "METHOD_END"], "methodName": ["setExtensions"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointRegistration"}, {"methodBody": ["METHOD_START", "{", "this . subprotocols    =    subprotocols ;", "}", "METHOD_END"], "methodName": ["setSubprotocols"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointRegistration"}, {"methodBody": ["METHOD_START", "{", "this . userProperties . clear (  )  ;", "this . userProperties . putAll ( userProperties )  ;", "}", "METHOD_END"], "methodName": ["setUserProperties"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointRegistration"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" resource \"  )", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext (  . Config . class )  ;", "ServerEndpointRegistration   registration    =    new   ServerEndpointRegistration (  \"  / path \"  ,     . EchoEndpoint . class )  ;", "registration . setBeanFactory ( context . getBeanFactory (  )  )  ;", ". EchoEndpoint   endpoint    =    registration . getConfigurator (  )  . getEndpointInstance (  . EchoEndpoint . class )  ;", "assertNotNull ( endpoint )  ;", "}", "METHOD_END"], "methodName": ["endpointPerConnection"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "ServerEndpointRegistrationTests . EchoEndpoint   endpoint    =    new   ServerEndpointRegistrationTests . EchoEndpoint ( new   ServerEndpointRegistrationTests . EchoService (  )  )  ;", "ServerEndpointRegistration   registration    =    new   ServerEndpointRegistration (  \"  / path \"  ,    endpoint )  ;", "ServerEndpointRegistrationTests . EchoEndpoint   actual    =    registration . getConfigurator (  )  . getEndpointInstance ( ServerEndpointRegistrationTests . EchoEndpoint . class )  ;", "assertSame ( endpoint ,    actual )  ;", "}", "METHOD_END"], "methodName": ["endpointSingleton"], "fileName": "org.springframework.web.socket.server.standard.ServerEndpointRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . asyncSendTimeout ;", "}", "METHOD_END"], "methodName": ["getAsyncSendTimeout"], "fileName": "org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . maxBinaryMessageBufferSize ;", "}", "METHOD_END"], "methodName": ["getMaxBinaryMessageBufferSize"], "fileName": "org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . maxSessionIdleTimeout ;", "}", "METHOD_END"], "methodName": ["getMaxSessionIdleTimeout"], "fileName": "org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . maxTextMessageBufferSize ;", "}", "METHOD_END"], "methodName": ["getMaxTextMessageBufferSize"], "fileName": "org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . asyncSendTimeout    =    timeoutInMillis ;", "}", "METHOD_END"], "methodName": ["setAsyncSendTimeout"], "fileName": "org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . maxBinaryMessageBufferSize    =    bufferSize ;", "}", "METHOD_END"], "methodName": ["setMaxBinaryMessageBufferSize"], "fileName": "org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . maxSessionIdleTimeout    =    timeoutInMillis ;", "}", "METHOD_END"], "methodName": ["setMaxSessionIdleTimeout"], "fileName": "org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . maxTextMessageBufferSize    =    bufferSize ;", "}", "METHOD_END"], "methodName": ["setMaxTextMessageBufferSize"], "fileName": "org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "String   wacId    =    wac . getId (  )  ;", "Map < Class <  ?  >  ,    String >    beanNamesByType    =     . cache . get ( wacId )  ;", "if    ( beanNamesByType    =  =    null )     {", "beanNamesByType    =    new   ConcurrentHashMap <  >  (  )  ;", ". cache . put ( wacId ,    beanNamesByType )  ;", "}", "if    (  !  ( beanNamesByType . containsKey ( endpointClass )  )  )     {", "String [  ]    names    =    wac . getBeanNamesForType ( endpointClass )  ;", "if    (  ( names . length )     =  =     1  )     {", "beanNamesByType . put ( endpointClass ,    names [  0  ]  )  ;", "} else    {", "beanNamesByType . put ( endpointClass ,     . NO _ VALUE )  ;", "if    (  ( names . length )     >     1  )     {", "throw   new   IllegalStateException (  (  (  (  \" Found   multiple    @ ServerEndpoint ' s   of   type    [  \"     +     ( endpointClass . getName (  )  )  )     +     \"  ]  :    bean   names    \"  )     +     ( Arrays . asList ( names )  )  )  )  ;", "}", "}", "}", "String   beanName    =    beanNamesByType . get ( endpointClass )  ;", "return    . NO _ VALUE . equals ( beanName )     ?    null    :    beanName ;", "}", "METHOD_END"], "methodName": ["getBeanNameByType"], "fileName": "org.springframework.web.socket.server.standard.SpringConfigurator"}, {"methodBody": ["METHOD_START", "{", "this . contextLoader . closeWebApplicationContext ( this . servletContext )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.springframework.web.socket.server.standard.SpringConfiguratorTests"}, {"methodBody": ["METHOD_START", "{", "SpringConfiguratorTests . PerConnectionEchoEndpoint   endpoint    =    this . configurator . getEndpointInstance ( SpringConfiguratorTests . PerConnectionEchoEndpoint . class )  ;", "assertNotNull ( endpoint )  ;", "}", "METHOD_END"], "methodName": ["getEndpointPerConnection"], "fileName": "org.springframework.web.socket.server.standard.SpringConfiguratorTests"}, {"methodBody": ["METHOD_START", "{", "SpringConfiguratorTests . ComponentEchoEndpoint   expected    =    this . webAppContext . getBean ( SpringConfiguratorTests . ComponentEchoEndpoint . class )  ;", "SpringConfiguratorTests . ComponentEchoEndpoint   actual    =    this . configurator . getEndpointInstance ( SpringConfiguratorTests . ComponentEchoEndpoint . class )  ;", "assertSame ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["getEndpointSingletonByComponentName"], "fileName": "org.springframework.web.socket.server.standard.SpringConfiguratorTests"}, {"methodBody": ["METHOD_START", "{", "SpringConfiguratorTests . EchoEndpoint   expected    =    this . webAppContext . getBean ( SpringConfiguratorTests . EchoEndpoint . class )  ;", "SpringConfiguratorTests . EchoEndpoint   actual    =    this . configurator . getEndpointInstance ( SpringConfiguratorTests . EchoEndpoint . class )  ;", "assertSame ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["getEndpointSingletonByType"], "fileName": "org.springframework.web.socket.server.standard.SpringConfiguratorTests"}, {"methodBody": ["METHOD_START", "{", "this . servletContext    =    new   MockServletContext (  )  ;", "this . webAppContext    =    new   AnnotationConfigWebApplicationContext (  )  ;", "this . webAppContext . register ( SpringConfiguratorTests . Config . class )  ;", "this . contextLoader    =    new   context . ContextLoader ( this . webAppContext )  ;", "this . contextLoader . initWebApplicationContext ( this . servletContext )  ;", "this . configurator    =    new   SpringConfigurator (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.server.standard.SpringConfiguratorTests"}, {"methodBody": ["METHOD_START", "{", "while    ( request   instanceof   ServletRequestWrapper )     {", "request    =     (  ( ServletRequestWrapper )     ( request )  )  . getRequest (  )  ;", "}", "return   request ;", "}", "METHOD_END"], "methodName": ["getNativeRequest"], "fileName": "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "return   WebLogicRequestUpgradeStrategy . type ( className )  . getDeclaredMethod ( method ,    paramTypes )  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "return   WebLogicRequestUpgradeStrategy . class . getClassLoader (  )  . loadClass ( className )  ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handlerToCheck    =    WebSocketHandlerDecorator . unwrap ( handler )  ;", "List < String >    subProtocols    =    null ;", "if    ( handlerToCheck   instanceof   SubProtocolCapable )     {", "subProtocols    =     (  ( SubProtocolCapable )     ( handlerToCheck )  )  . getSubProtocols (  )  ;", "}", "return   subProtocols    !  =    null    ?    subProtocols    :    Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["determineHandlerSupportedProtocols"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "return   request . getPrincipal (  )  ;", "}", "METHOD_END"], "methodName": ["determineUser"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . requestUpgradeStrategy )    instanceof   Lifecycle )     {", "(  ( Lifecycle )     ( this . requestUpgradeStrategy )  )  . start (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doStart"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . requestUpgradeStrategy )    instanceof   Lifecycle )     {", "(  ( Lifecycle )     ( this . requestUpgradeStrategy )  )  . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doStop"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "List < WebSocketExtension >    result    =    new   ArrayList <  >  ( requestedExtensions . size (  )  )  ;", "for    ( WebSocketExtension   extension    :    requestedExtensions )     {", "if    ( edExtensions . contains ( extension )  )     {", "result . add ( extension )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["filterRequestedExtensions"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . requestUpgradeStrategy ;", "}", "METHOD_END"], "methodName": ["getRequestUpgradeStrategy"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . toStringArray ( this . supportedProtocols )  ;", "}", "METHOD_END"], "methodName": ["getSupportedProtocols"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . requestUpgradeStrategy . getSupportedVersions (  )  ;", "}", "METHOD_END"], "methodName": ["getSupportedVersions"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  \"    failed   due   to   invalid   Connection   header    \"     +     ( request . getHeaders (  )  . getConnection (  )  )  )  )  ;", "}", "response . setStatusCode ( BAD _ REQUEST )  ;", "response . getBody (  )  . write (  \"  \\  \" Connection \\  \"    must   be    \\  \" upgrade \\  \"  .  \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["handleInvalidConnectHeader"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  \"    failed   due   to   invalid   Upgrade   header :     \"     +     ( request . getHeaders (  )  . getUpgrade (  )  )  )  )  ;", "}", "response . setStatusCode ( BAD _ REQUEST )  ;", "response . getBody (  )  . write (  \" Can    \\  \" Upgrade \\  \"    only   to    \\  \" WebSocket \\  \"  .  \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["handleInvalidUpgradeHeader"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isErrorEnabled (  )  )     {", "String   version    =    request . getHeaders (  )  . getFirst (  \" Sec - WebSocket - Version \"  )  ;", "logger . error (  (  (  (  \"    failed   due   to   unsupported   WebSocket   version :     \"     +    version )     +     \"  .    Supported   versions :     \"  )     +     ( Arrays . toString ( getSupportedVersions (  )  )  )  )  )  ;", "}", "response . setStatusCode ( UPGRADE _ REQUIRED )  ;", "response . getHeaders (  )  . set ( WebSocketHttpHeaders . SEC _ WEBSOCKET _ VERSION ,    StringUtils . arrayToCommaDelimitedString ( getSupportedVersions (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleWebSocketVersionNotSupported"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "String   className ;", "if    ( AbstractHandshakeHandler . tomcatWsPresent )     {", "className    =     \" tandard . TomcatRequestUpgradeStrategy \"  ;", "} else", "if    ( AbstractHandshakeHandler . jettyWsPresent )     {", "className    =     \" JettyRequestUpgradeStrategy \"  ;", "} else", "if    ( AbstractHandshakeHandler . undertowWsPresent )     {", "className    =     \" tandard . UndertowRequestUpgradeStrategy \"  ;", "} else", "if    ( AbstractHandshakeHandler . glassfishWsPresent )     {", "className    =     \" tandard . GlassFishRequestUpgradeStrategy \"  ;", "} else", "if    ( AbstractHandshakeHandler . weblogicWsPresent )     {", "className    =     \" tandard . WebLogicRequestUpgradeStrategy \"  ;", "} else", "if    ( AbstractHandshakeHandler . websphereWsPresent )     {", "className    =     \" tandard . WebSphereRequestUpgradeStrategy \"  ;", "} else    {", "throw   new   IllegalStateException (  \" No   suitable   default   RequestUpgradeStrategy   found \"  )  ;", "}", "try    {", "Class <  ?  >    clazz    =    ClassUtils . forName ( className ,    AbstractHandshakeHandler . class . getClassLoader (  )  )  ;", "return    (  ( RequestUpgradeStrategy )     ( ReflectionUtils . accessibleConstructor ( clazz )  . newInstance (  )  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  \" Failed   to   instantiate   RequestUpgradeStrategy :     \"     +    className )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["initRequestUpgradeStrategy"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isValidOrigin"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "String   version    =    httpHeaders . getSecWebSocketVersion (  )  ;", "String [  ]    edVersions    =    getSupportedVersions (  )  ;", "for    ( String   edVersion    :    edVersions )     {", "if    ( edVersion . trim (  )  . equals ( version )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isWebSocketVersionSupported"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "List < String >    handlerProtocols    =    determineHandlerSupportedProtocols ( webSocketHandler )  ;", "for    ( String   protocol    :    requestedProtocols )     {", "if    ( handlerProtocols . contains ( protocol . toLowerCase (  )  )  )     {", "return   protocol ;", "}", "if    ( this . supportedProtocols . contains ( protocol . toLowerCase (  )  )  )     {", "return   protocol ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["selectProtocol"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "this . supportedProtocols . clear (  )  ;", "for    ( String   protocol    :    protocols )     {", "this . supportedProtocols . add ( protocol . toLowerCase (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setSupportedProtocols"], "fileName": "org.springframework.web.socket.server.support.AbstractHandshakeHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    this . interceptorIndex ;    i    >  =     0  ;    i -  -  )     {", "HandshakeInterceptor   interceptor    =    this . interceptors . get ( i )  ;", "try    {", "interceptor . afterHandshake ( request ,    response ,    this . wsHandler ,    failure )  ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  ( interceptor    +     \"    threw   exception   in   afterHandshake :     \"  )     +    ex )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["applyAfterHandshake"], "fileName": "org.springframework.web.socket.server.support.HandshakeInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( this . interceptors . size (  )  )  ;    i +  +  )     {", "HandshakeInterceptor   interceptor    =    this . interceptors . get ( i )  ;", "if    (  !  ( interceptor . beforeHandshake ( request ,    response ,    this . wsHandler ,    attributes )  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  ( interceptor    +     \"    returns   false   from   beforeHandshake    -    precluding   handshake \"  )  )  ;", "}", "applyAfterHandshake ( request ,    response ,    null )  ;", "return   false ;", "}", "this . interceptorIndex    =    i ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["applyBeforeHandshake"], "fileName": "org.springframework.web.socket.server.support.HandshakeInterceptorChain"}, {"methodBody": ["METHOD_START", "{", "HandshakeInterceptorChain   chain    =    new   HandshakeInterceptorChain ( interceptors ,    wsHandler )  ;", "chain . applyAfterHandshake ( request ,    response ,    null )  ;", "verifyNoMoreInteractions ( i 1  ,    i 2  ,    i 3  )  ;", "}", "METHOD_END"], "methodName": ["applyAfterHandshakeOnly"], "fileName": "org.springframework.web.socket.server.support.HandshakeInterceptorChainTests"}, {"methodBody": ["METHOD_START", "{", "given ( i 1  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  . willReturn ( true )  ;", "given ( i 2  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  . willReturn ( false )  ;", "chain    =    new    ( interceptors ,    wsHandler )  ;", "chain . applyBeforeHandshake ( request ,    response ,    attributes )  ;", "verify ( i 1  )  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  ;", "verify ( i 1  )  . afterHandshake ( request ,    response ,    wsHandler ,    null )  ;", "verify ( i 2  )  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  ;", "verifyNoMoreInteractions ( i 1  ,    i 2  ,    i 3  )  ;", "}", "METHOD_END"], "methodName": ["applyBeforeHandshakeWithFalseReturnValue"], "fileName": "org.springframework.web.socket.server.support.HandshakeInterceptorChainTests"}, {"methodBody": ["METHOD_START", "{", "super . setup (  )  ;", "i 1     =    mock (  . class )  ;", "i 2     =    mock (  . class )  ;", "i 3     =    mock (  . class )  ;", "interceptors    =    Arrays . asList ( i 1  ,    i 2  ,    i 3  )  ;", "wsHandler    =    mock ( WebSocketHandler . class )  ;", "attributes    =    new   HashMap <  >  (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.server.support.HandshakeInterceptorChainTests"}, {"methodBody": ["METHOD_START", "{", "given ( i 1  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  . willReturn ( true )  ;", "given ( i 2  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  . willReturn ( true )  ;", "given ( i 3  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  . willReturn ( true )  ;", "chain    =    new    ( interceptors ,    wsHandler )  ;", "chain . applyBeforeHandshake ( request ,    response ,    attributes )  ;", "verify ( i 1  )  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  ;", "verify ( i 2  )  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  ;", "verify ( i 3  )  . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  ;", "verifyNoMoreInteractions ( i 1  ,    i 2  ,    i 3  )  ;", "}", "METHOD_END"], "methodName": ["success"], "fileName": "org.springframework.web.socket.server.support.HandshakeInterceptorChainTests"}, {"methodBody": ["METHOD_START", "{", "return   this . attributeNames ;", "}", "METHOD_END"], "methodName": ["getAttributeNames"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( request   instanceof   ServletServerHttpRequest )     {", "ServletServerHttpRequest   serverRequest    =     (  ( ServletServerHttpRequest )     ( request )  )  ;", "return   serverRequest . getServletRequest (  )  . get ( isCreate (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . copyAllAttributes ;", "}", "METHOD_END"], "methodName": ["isCopyAllAttributes"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . copyHttpSessionId ;", "}", "METHOD_END"], "methodName": ["isCopyHttpSessionId"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . createSession ;", "}", "METHOD_END"], "methodName": ["isCreateSession"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . copyAllAttributes    =    copyAllAttributes ;", "}", "METHOD_END"], "methodName": ["setCopyAllAttributes"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . copyHttpSessionId    =    copyHttpSessionId ;", "}", "METHOD_END"], "methodName": ["setCopyHttpSessionId"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . createSession    =    createSession ;", "}", "METHOD_END"], "methodName": ["setCreateSession"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . setSession ( new   MockHttpSession ( null ,     \"  1  2  3  \"  )  )  ;", "this . servletRequest . getSession (  )  . setAttribute (  \" foo \"  ,     \" bar \"  )  ;", "this . servletRequest . getSession (  )  . setAttribute (  \" bar \"  ,     \" baz \"  )  ;", "Set < String >    names    =    Collections . singleton (  \" foo \"  )  ;", "interceptor    =    new    ( names )  ;", "interceptor . beforeHandshake ( this . request ,    this . response ,    wsHandler ,    attributes )  ;", "assertEquals (  2  ,    attributes . size (  )  )  ;", "assertEquals (  \" bar \"  ,    attributes . get (  \" foo \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    attributes . get (  . HTTP _ SESSION _ ID _ ATTR _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["constructorWithAttributeNames"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . setSession ( new   MockHttpSession ( null ,     \"  1  2  3  \"  )  )  ;", "this . servletRequest . getSession (  )  . setAttribute (  \" foo \"  ,     \" bar \"  )  ;", "this . servletRequest . getSession (  )  . setAttribute (  \" bar \"  ,     \" baz \"  )  ;", "interceptor    =    new    (  )  ;", "interceptor . beforeHandshake ( this . request ,    this . response ,    wsHandler ,    attributes )  ;", "assertEquals (  3  ,    attributes . size (  )  )  ;", "assertEquals (  \" bar \"  ,    attributes . get (  \" foo \"  )  )  ;", "assertEquals (  \" baz \"  ,    attributes . get (  \" bar \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    attributes . get (  . HTTP _ SESSION _ ID _ ATTR _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["defaultConstructor"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "interceptor    =    new    (  )  ;", "interceptor . beforeHandshake ( this . request ,    this . response ,    wsHandler ,    attributes )  ;", "assertNull ( this . servletRequest . getSession ( false )  )  ;", "}", "METHOD_END"], "methodName": ["doNotCauseSessionCreation"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . setSession ( new   MockHttpSession ( null ,     \"  1  2  3  \"  )  )  ;", "this . servletRequest . getSession (  )  . setAttribute (  \" foo \"  ,     \" bar \"  )  ;", "interceptor    =    new    (  )  ;", "interceptor . setCopyAllAttributes ( false )  ;", "interceptor . beforeHandshake ( this . request ,    this . response ,    wsHandler ,    attributes )  ;", "assertEquals (  1  ,    attributes . size (  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    attributes . get (  . HTTP _ SESSION _ ID _ ATTR _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["doNotCopyAttributes"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . setSession ( new   MockHttpSession ( null ,     \"  1  2  3  \"  )  )  ;", "this . servletRequest . getSession (  )  . setAttribute (  \" foo \"  ,     \" bar \"  )  ;", "interceptor    =    new    (  )  ;", "interceptor . setCopyHttpSessionId ( false )  ;", "interceptor . beforeHandshake ( this . request ,    this . response ,    wsHandler ,    attributes )  ;", "assertEquals (  1  ,    attributes . size (  )  )  ;", "assertEquals (  \" bar \"  ,    attributes . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doNotCopyHttpSessionId"], "fileName": "org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . allowedOrigins )  ;", "}", "METHOD_END"], "methodName": ["getAllowedOrigins"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( allowedOrigins ,     \" Allowed   origins   Collection   must   not   be   null \"  )  ;", "this . allowedOrigins . clear (  )  ;", "this . allowedOrigins . addAll ( allowedOrigins )  ;", "}", "METHOD_END"], "methodName": ["setAllowedOrigins"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptor"}, {"methodBody": ["METHOD_START", "{", "new   OriginHandshakeInterceptor ( null )  ;", "}", "METHOD_END"], "methodName": ["invalidInput"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "List < String >    allowed    =    Arrays . asList (  \" http :  /  / mydomain 1  . com \"  ,     \" http :  /  / mydomain 2  . com \"  ,     \" http :  /  / mydomain 3  . com \"  )  ;", "interceptor    =    new    ( allowed )  ;", "assertTrue ( interceptor . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  ;", "assertNotEquals ( servletResponse . getStatus (  )  ,    FORBIDDEN . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["originListMatch"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 4  . com \"  )  ;", "List < String >    allowed    =    Arrays . asList (  \" http :  /  / mydomain 1  . com \"  ,     \" http :  /  / mydomain 2  . com \"  ,     \" http :  /  / mydomain 3  . com \"  )  ;", "interceptor    =    new    ( allowed )  ;", "assertFalse ( interceptor . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  ;", "assertEquals ( servletResponse . getStatus (  )  ,    FORBIDDEN . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["originListNoMatch"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 1  . com \"  )  ;", "interceptor    =    new    (  )  ;", "interceptor . setAllowedOrigins ( Collections . singletonList (  \"  *  \"  )  )  ;", "assertTrue ( interceptor . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  ;", "assertNotEquals ( servletResponse . getStatus (  )  ,    FORBIDDEN . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["originMatchAll"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 4  . com \"  )  ;", "interceptor    =    new    (  )  ;", "Set < String >    allowedOrigins    =    new   ConcurrentSkipListSet <  >  (  )  ;", "allowedOrigins . add (  \" http :  /  / mydomain 1  . com \"  )  ;", "interceptor . setAllowedOrigins ( allowedOrigins )  ;", "assertFalse ( interceptor . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  ;", "assertEquals ( servletResponse . getStatus (  )  ,    FORBIDDEN . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["originNoMatchWithNullHostileCollection"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 1  . com \"  )  ;", "List < String >    allowed    =    Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  ;", "interceptor    =    new    ( allowed )  ;", "assertTrue ( interceptor . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  ;", "assertNotEquals ( servletResponse . getStatus (  )  ,    FORBIDDEN . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["originValueMatch"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 1  . com \"  )  ;", "List < String >    allowed    =    Collections . singletonList (  \" http :  /  / mydomain 2  . com \"  )  ;", "interceptor    =    new    ( allowed )  ;", "assertFalse ( interceptor . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  ;", "assertEquals ( servletResponse . getStatus (  )  ,    FORBIDDEN . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["originValueNoMatch"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "this . servletRequest . setServerName (  \" mydomain 2  . com \"  )  ;", "interceptor    =    new    ( Arrays . asList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "assertTrue ( interceptor . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  ;", "assertNotEquals ( servletResponse . getStatus (  )  ,    FORBIDDEN . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["sameOriginMatchWithAllowedOrigins"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "this . servletRequest . setServerName (  \" mydomain 2  . com \"  )  ;", "interceptor    =    new    ( Collections . emptyList (  )  )  ;", "assertTrue ( interceptor . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  ;", "assertNotEquals ( servletResponse . getStatus (  )  ,    FORBIDDEN . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["sameOriginMatchWithEmptyAllowedOrigins"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "WebSocketHandler   wsHandler    =    Mockito . mock ( WebSocketHandler . class )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 3  . com \"  )  ;", "this . servletRequest . setServerName (  \" mydomain 2  . com \"  )  ;", "interceptor    =    new    ( Collections . emptyList (  )  )  ;", "assertFalse ( interceptor . beforeHandshake ( request ,    response ,    wsHandler ,    attributes )  )  ;", "assertEquals ( servletResponse . getStatus (  )  ,    FORBIDDEN . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["sameOriginNoMatch"], "fileName": "org.springframework.web.socket.server.support.OriginHandshakeInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . handshakeHandler ;", "}", "METHOD_END"], "methodName": ["getHandshakeHandler"], "fileName": "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . interceptors ;", "}", "METHOD_END"], "methodName": ["getHandshakeInterceptors"], "fileName": "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . wsHandler ;", "}", "METHOD_END"], "methodName": ["getWebSocketHandler"], "fileName": "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler"}, {"methodBody": ["METHOD_START", "{", "this . interceptors . clear (  )  ;", "if    ( interceptors    !  =    null )     {", "this . interceptors . addAll ( interceptors )  ;", "}", "}", "METHOD_END"], "methodName": ["setHandshakeInterceptors"], "fileName": "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionId ;", "}", "METHOD_END"], "methodName": ["getSockJsSessionId"], "fileName": "org.springframework.web.socket.sockjs.SockJsException"}, {"methodBody": ["METHOD_START", "{", "return   this . undeliveredMessages ;", "}", "METHOD_END"], "methodName": ["getUndeliveredMessages"], "fileName": "org.springframework.web.socket.sockjs.SockJsMessageDeliveryException"}, {"methodBody": ["METHOD_START", "{", "CloseStatus   cs    =    this . closeStatus ;", "if    ( cs    =  =    null )     {", "cs    =    closeStatus ;", "this . closeStatus    =    closeStatus ;", "}", "Assert . state (  ( cs    !  =    null )  ,     \" CloseStatus   not   available \"  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Transport   closed   with    \"     +    cs )     +     \"    in    \"  )     +     ( this )  )  )  ;", "}", "this . state    =     . State . CLOSED ;", "try    {", "this . webSocketHandler . afterConnectionClosed ( this ,    cs )  ;", "}    catch    ( Throwable   ex )     {", "logger . error (  \" WebSocketHandler . afterConnectionClosed   threw   an   exception \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["afterTransportClosed"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . state )     =  =    null )     {", "logger . warn (  \" Ignoring   close   since   connect (  )    was   never   invoked \"  )  ;", "return ;", "}", "if    ( isDisconnected (  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Ignoring   close    ( already   closing   or   closed )  :    current   state    \"     +     ( this . state )  )  )  ;", "}", "return ;", "}", "this . state    =     . State . CLOSING ;", "this . closeStatus    =    status ;", "disconnect ( status )  ;", "}", "METHOD_END"], "methodName": ["closeInternal"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . request . getMessageCodec (  )  ;", "}", "METHOD_END"], "methodName": ["getMessageCodec"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "closeInternal ( new   CloseStatus (  2  0  0  7  ,     \" Transport   timed   out \"  )  )  ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Failed   to   close    \"     +     ( this )  )     +     \"    after   nsport   timeout \"  )  ,    ex )  ;", "}", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getTimeoutTask"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketHandler ;", "}", "METHOD_END"], "methodName": ["getWebSocketHandler"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "CloseStatus   closeStatus    =    CloseStatus . NO _ STATUS _ CODE ;", "try    {", "String   Data    =     . getFrameData (  )  ;", "if    ( Data    !  =    null )     {", "String [  ]    data    =    getMessageCodec (  )  . decode ( Data )  ;", "if    (  ( data    !  =    null )     &  &     (  ( data . length )     =  =     2  )  )     {", "closeStatus    =    new   CloseStatus ( Integer . valueOf ( data [  0  ]  )  ,    data [  1  ]  )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Processing   SockJS   close      with    \"     +    closeStatus )     +     \"    in    \"  )     +     ( this )  )  )  ;", "}", "}", "}    catch    ( IOException   ex )     {", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  (  (  \" Failed   to   decode   data   for    \"     +     )     +     \"    in    \"  )     +     ( this )  )  ,    ex )  ;", "}", "}", "silentClose ( closeStatus )  ;", "}", "METHOD_END"], "methodName": ["handleCloseFrame"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "SockJsFrame   frame    =    new   SockJsFrame ( payload )  ;", "switch    ( frame . getType (  )  )     {", "case   OPEN    :", "handleOpenFrame (  )  ;", "break ;", "case   HEARTBEAT    :", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Received   heartbeat   in    \"     +     ( this )  )  )  ;", "}", "break ;", "case   MESSAGE    :", "handleMessageFrame ( frame )  ;", "break ;", "case   CLOSE    :", "handleCloseFrame ( frame )  ;", "}", "}", "METHOD_END"], "methodName": ["handleFrame"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isOpen (  )  )  )     {", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  (  (  \" Ignoring   received   message   due   to   state    \"     +     ( this . state )  )     +     \"    in    \"  )     +     ( this )  )  )  ;", "}", "return ;", "}", "String [  ]    messages    =    null ;", "String   Data    =     . getFrameData (  )  ;", "if    ( Data    !  =    null )     {", "try    {", "messages    =    getMessageCodec (  )  . decode ( Data )  ;", "}    catch    ( IOException   ex )     {", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  (  (  \" Failed   to   decode   data   for   SockJS    \\  \" message \\  \"     :     \"     +     )     +     \"    in    \"  )     +     ( this )  )  ,    ex )  ;", "}", "silentClose ( CloseStatus . BAD _ DATA )  ;", "return ;", "}", "}", "if    ( messages    =  =    null )     {", "return ;", "}", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Processing   SockJS   message       \"     +     (  . getContent (  )  )  )     +     \"    in    \"  )     +     ( this )  )  )  ;", "}", "for    ( String   message    :    messages )     {", "if    ( isOpen (  )  )     {", "try    {", "this . webSocketHandler . handleMessage ( this ,    new   TextMessage ( message )  )  ;", "}    catch    ( Throwable   ex )     {", "logger . error (  (  (  (  \" WebSocketHandler . handleMessage   threw   an   exception   on    \"     +     )     +     \"    in    \"  )     +     ( this )  )  ,    ex )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleMessageFrame"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Processing   SockJS   open   frame   in    \"     +     ( this )  )  )  ;", "}", "if    (  ( this . state )     =  =     (  . State . NEW )  )     {", "this . state    =     . State . OPEN ;", "try    {", "this . webSocketHandler . afterConnectionEstablished ( this )  ;", "this . connectFuture . set ( this )  ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  \" WebSocketHandler . afterConnectionEstablished   threw   exception   in    \"     +     ( this )  )  ,    ex )  ;", "}", "}", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Open   frame   received   in    \"     +     ( getId (  )  )  )     +     \"    but   we ' re   not   connecting    ( current   state    \"  )     +     ( this . state )  )     +     \"  )  .    The   server   might   have   been   restarted   and   lost   track   of   the   session .  \"  )  )  ;", "}", "silentClose ( new   CloseStatus (  1  0  0  6  ,     \" Server   lost   session \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleOpenFrame"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  \" Transport   error   in    \"     +     ( this )  )  ,    error )  ;", "}", "this . webSHandler . handleTransportError ( this ,    error )  ;", "}    catch    ( Throwable   ex )     {", "logger . error (  \" WebSHandler . handleTransportError   threw   an   exception \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["handleTransportError"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . state )     =  =     ( AbstractClientSockJsSession . State . CLOSING )  )     |  |     (  ( this . state )     =  =     ( AbstractClientSockJsSession . State . CLOSED )  )  ;", "}", "METHOD_END"], "methodName": ["isDisconnected"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return    ( status    !  =    null )     &  &     (  (  ( status . getCode (  )  )     =  =     1  0  0  0  )     |  |     (  (  ( status . getCode (  )  )     >  =     3  0  0  0  )     &  &     (  ( status . getCode (  )  )     <  =     4  9  9  9  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isUserSetStatus"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "try    {", "closeInternal ( status )  ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  \" Failed   to   close    \"     +     ( this )  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["silentClose"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "long   timeToSleep    =     2  0  0  ;", "for    ( int   i    =     0  ;    i    <     ( Math . floor (  ( timeToWait    /    timeToSleep )  )  )  ;    i +  +  )     {", "if    ( condi . getAsBoolean (  )  )     {", "return ;", "}", "try    {", "Thread . sleep ( timeToSleep )  ;", "}    catch    ( InterruptedExcep   e )     {", "throw   new   IllegalStateExcep (  (  \" Interrupted   while   waiting   for    \"     +    descrip )  ,    e )  ;", "}", "}", "throw   new   IllegalStateExcep (  (  \" Timed   out   waiting   for    \"     +    descrip )  )  ;", "}", "METHOD_END"], "methodName": ["awaitEvent"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "testEcho (  1  0  0  ,    createWebSocketTransport (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["echoWebSocket"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AbstractXhrTransport   xhrTransport    =    createXhrTransport (  )  ;", "xhrTransport . setXhrStreamingDisabled ( true )  ;", "testEcho (  1  0  0  ,    xhrTransport ,    null )  ;", "}", "METHOD_END"], "methodName": ["echoXhr"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "testEcho (  1  0  0  ,    createXhrTransport (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["echoXhrStreaming"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AbstractXhrTransport   xhrTransport    =    createXhrTransport (  )  ;", "xhrTransport . setXhrStreamingDisabled ( true )  ;", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders (  )  ;", "headers . add (  \" auth \"  ,     \"  1  2  3  \"  )  ;", "testEcho (  1  0  ,    xhrTransport ,    headers )  ;", "for    ( Map . Entry < String ,    HttpHeaders >    entry    :    this . testFilter . requests . entrySet (  )  )     {", "HttpHeaders   httpHeaders    =    entry . getValue (  )  ;", "assertEquals (  (  \" No   auth   header   for :     \"     +     ( entry . getKey (  )  )  )  ,     \"  1  2  3  \"  ,    httpHeaders . getFirst (  \" auth \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["echoXhrWithHeaders"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSockJsIntegrationTests . TestClientHandler   clientHandler    =    new   AbstractSockJsIntegrationTests . TestClientHandler (  )  ;", "this . testFilter . sleepDelayMap . put (  \"  / xhr _ streaming \"  ,     1  0  0  0  0 L )  ;", "this . testFilter . sendErrorMap . put (  \"  / xhr _ streaming \"  ,     5  0  3  )  ;", "initSockJsClient ( createXhrTransport (  )  )  ;", "this . sockJsClient . setConnectTimeoutScheduler ( this . wac . getBean ( ThreadPoolTaskScheduler . class )  )  ;", "WebSocketSession   clientSession    =    sockJsClient . doHandshake ( clientHandler ,     (  ( this . baseUrl )     +     \"  / echo \"  )  )  . get (  )  ;", "assertEquals (  \" Fallback   didn ' t   occur \"  ,    XhrClientSockJsSession . class ,    clientSession . getClass (  )  )  ;", "TextMessage   message    =    new   TextMessage (  \" message 1  \"  )  ;", "clientSession . sendMessage ( message )  ;", "clientHandler . awaitMessage ( message ,     5  0  0  0  )  ;", "clientSession . close (  )  ;", "}", "METHOD_END"], "methodName": ["fallbackAfterConnectTimeout"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . testFilter . sendErrorMap . put (  \"  / websocket \"  ,     2  0  0  )  ;", "this . testFilter . sendErrorMap . put (  \"  / xhr _ streaming \"  ,     5  0  0  )  ;", ". TestClientHandler   handler    =    new    . TestClientHandler (  )  ;", "initSockJsClient ( createWebSocketTransport (  )  ,    createXhrTransport (  )  )  ;", "WebSocketSession   session    =    this . sockJsClient . doHandshake ( handler ,     (  ( this . baseUrl )     +     \"  / echo \"  )  )  . get (  )  ;", "assertEquals (  \" Fallback   didn ' t   occur \"  ,    XhrClientSockJsSession . class ,    session . getClass (  )  )  ;", "TextMessage   message    =    new   TextMessage (  \" message 1  \"  )  ;", "session . sendMessage ( message )  ;", "handler . awaitMessage ( message ,     5  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["fallbackAfterTransportFailure"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSockJsIntegrationTests . TestClientHandler   handler    =    new   AbstractSockJsIntegrationTests . TestClientHandler (  )  ;", "this . testFilter . sendErrorMap . put (  \"  / info \"  ,     5  0  0  )  ;", "CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "initSockJsClient ( createWebSocketTransport (  )  )  ;", "this . sockJsClient . doHandshake ( handler ,     (  ( this . baseUrl )     +     \"  / echo \"  )  )  . addCallback ( new   ListenableFutureCallback < WebSocketSession >  (  )     {", "@ Override", "public   void   onSuccess ( WebSocketSession   result )     {", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "latch . countDown (  )  ;", "}", "}  )  ;", "assertTrue ( latch . await (  5  0  0  0  ,    TimeUnit . MILLISECONDS )  )  ;", "}", "METHOD_END"], "methodName": ["infoRequestFailure"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . sockJsClient    =    new   SockJsClient ( Arrays . asList ( transports )  )  ;", "this . sockJsClient . start (  )  ;", "}", "METHOD_END"], "methodName": ["initSockJsClient"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "}", "METHOD_END"], "methodName": ["performanceTestGroupAssumption"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "testReceiveOneMessage ( createWebSocketTransport (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["receiveOneMessageWebSocket"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AbstractXhrTransport   xhrTransport    =    createXhrTransport (  )  ;", "xhrTransport . setXhrStreamingDisabled ( true )  ;", "testReceiveOneMessage ( xhrTransport ,    null )  ;", "}", "METHOD_END"], "methodName": ["receiveOneMessageXhr"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "testReceiveOneMessage ( createXhrTransport (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["receiveOneMessageXhrStreaming"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  (  (  \" Setting   up    '  \"     +     ( this . testName . getMethodName (  )  )  )     +     \"  '  \"  )  )  ;", "this . testFilter    =    new    . TestFilter (  )  ;", "this . wac    =    new   AnnotationConfigWebApplicationContext (  )  ;", "this . wac . register (  . TestConfig . class ,    upgradeStrategyConfigClass (  )  )  ;", "this . server    =    createWebSocketTestServer (  )  ;", "this . server . setup (  )  ;", "this . server . deployConfig ( this . wac ,    this . testFilter )  ;", "this . server . start (  )  ;", "this . wac . setServletContext ( this . server . getServletContext (  )  )  ;", "this . wac . refresh (  )  ;", "this . baseUrl    =     \" http :  /  / localhost :  \"     +     ( this . server . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . sockJsCstop (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . error (  \" Failed   to   stop   SockJsC ,    ex )  ;", "}", "try    {", "this . server . undeployConfig (  )  ;", "}    catch    ( Throwable   t )     {", "logger . error (  \" Failed   to   undeploy   application   config \"  ,    t )  ;", "}", "try    {", "this . server . stop (  )  ;", "}    catch    ( Throwable   t )     {", "logger . error (  \" Failed   to   stop   server \"  ,    t )  ;", "}", "try    {", "this . wac . close (  )  ;", "}    catch    ( Throwable   t )     {", "logger . error (  \" Failed   to   close   WebApplicationContext \"  ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "List < TextMessage >    messages    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <    messageCount ;    i +  +  )     {", "messages . add ( new   TextMessage (  (  \" m \"     +    i )  )  )  ;", "}", ". TestClientHandler   handler    =    new    . TestClientHandler (  )  ;", "initSockJsClient ( transport )  ;", "URI   url    =    new   URI (  (  ( this . baseUrl )     +     \"  / echo \"  )  )  ;", "WebSocketSession   session    =    this . sockJsClient . doHandshake ( handler ,    headers ,    url )  . get (  )  ;", "for    ( TextMessage   message    :    messages )     {", "session . sendMessage ( message )  ;", "}", "handler . awaitMessageCount ( messageCount ,     5  0  0  0  )  ;", "for    ( TextMessage   message    :    messages )     {", "assertTrue (  (  \" Message   not   received :     \"     +    message )  ,    handler . receivedMessages . remove ( message )  )  ;", "}", "assertEquals (  (  \" Remaining   messages :     \"     +     ( handler . receivedMessages )  )  ,     0  ,    handler . receivedMessages . size (  )  )  ;", "session . close (  )  ;", "}", "METHOD_END"], "methodName": ["testEcho"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSockJsIntegrationTests . TestClientHandler   clientHandler    =    new   AbstractSockJsIntegrationTests . TestClientHandler (  )  ;", "initSockJsClient ( transport )  ;", "this . sockJsClient . doHandshake ( clientHandler ,    headers ,    new   URI (  (  ( this . baseUrl )     +     \"  / test \"  )  )  )  . get (  )  ;", "AbstractSockJsIntegrationTests . TestServerHandler   serverHandler    =    this . wac . getBean ( AbstractSockJsIntegrationTests . TestServerHandler . class )  ;", "assertNotNull (  \" afterConnectionEstablished   should   have   been   called \"  ,    clientHandler . session )  ;", "serverHandler . awaitSession (  5  0  0  0  )  ;", "TextMessage   message    =    new   TextMessage (  \" message 1  \"  )  ;", "serverHandler . session . sendMessage ( message )  ;", "clientHandler . awaitMessage ( message ,     5  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveOneMessage"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractSockJsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . xhrStreamingDisabled ;", "}", "METHOD_END"], "methodName": ["isXhrStreamingDisabled"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractXhrTransport"}, {"methodBody": ["METHOD_START", "{", "this . xhrStreamingDisabled    =    disabled ;", "}", "METHOD_END"], "methodName": ["setXhrStreamingDisabled"], "fileName": "org.springframework.web.socket.sockjs.client.AbstractXhrTransport"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . session . afterTransportClosed ( CloseStatus . SERVER _ ERROR )  ;", "assertThat ( this . session . isOpen (  )  ,    equalTo ( false )  )  ;", "verify ( this . handler )  . afterConnectionEstablished ( this . session )  ;", "verify ( this . handler )  . afterConnectionClosed ( this . session ,    CloseStatus . SERVER _ ERROR )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "}", "METHOD_END"], "methodName": ["afterTransportClosed"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . session . close (  )  ;", "assertThat ( this . session . isOpen (  )  ,    equalTo ( false )  )  ;", "assertThat ( this . session . disconnectStatus ,    equalTo ( CloseStatus . NORMAL )  )  ;", "verify ( this . handler )  . afterConnectionEstablished ( this . session )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Invalid   close   status \"  )  ;", "this . session . close ( null )  ;", "}", "METHOD_END"], "methodName": ["closeWithNullStatus"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . session . close ( new   CloseStatus (  3  0  0  0  ,     \" reason \"  )  )  ;", "assertThat ( this . session . disconnectStatus ,    equalTo ( new   CloseStatus (  3  0  0  0  ,     \" reason \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["closeWithStatus"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Invalid   close   status \"  )  ;", "this . session . close ( new   CloseStatus (  2  9  9  9  ,     \" reason \"  )  )  ;", "}", "METHOD_END"], "methodName": ["closeWithStatusOutOfRange"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . session . handleFrame ( SockJsFrame . closeFrame (  1  0  0  7  ,     \"  \"  )  . getContent (  )  )  ;", "assertThat ( this . session . isOpen (  )  ,    equalTo ( false )  )  ;", "assertThat ( this . session . disconnectStatus ,    equalTo ( new   CloseStatus (  1  0  0  7  ,     \"  \"  )  )  )  ;", "verify ( this . handler )  . afterConnectionEstablished ( this . session )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "}", "METHOD_END"], "methodName": ["handleFrameClose"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . session . handleFrame ( SockJsFrame . messageFrame (  . CODEC ,     \" foo \"  ,     \" bar \"  )  . getContent (  )  )  ;", "verify ( this . handler )  . afterConnectionEstablished ( this . session )  ;", "verify ( this . handler )  . handleMessage ( this . session ,    new   TextMessage (  \" foo \"  )  )  ;", "verify ( this . handler )  . handleMessage ( this . session ,    new   TextMessage (  \" bar \"  )  )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "}", "METHOD_END"], "methodName": ["handleFrameMessage"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . session . close (  )  ;", "reset ( this . handler )  ;", "this . session . handleFrame ( SockJsFrame . messageFrame (  . CODEC ,     \" foo \"  ,     \" bar \"  )  . getContent (  )  )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "}", "METHOD_END"], "methodName": ["handleFrameMessageWhenNotOpen"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . session . handleFrame (  \" a [  ' bad   data \"  )  ;", "assertThat ( this . session . isOpen (  )  ,    equalTo ( false )  )  ;", "assertThat ( this . session . disconnectStatus ,    equalTo ( CloseStatus . BAD _ DATA )  )  ;", "verify ( this . handler )  . afterConnectionEstablished ( this . session )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "}", "METHOD_END"], "methodName": ["handleFrameMessageWithBadData"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "willThrow ( new   IllegalStateException (  \" Fake   error \"  )  )  . given ( this . handler )  . handleMessage ( this . session ,    new   TextMessage (  \" foo \"  )  )  ;", "willThrow ( new   IllegalStateException (  \" Fake   error \"  )  )  . given ( this . handler )  . handleMessage ( this . session ,    new   TextMessage (  \" bar \"  )  )  ;", "this . session . handleFrame ( SockJsFrame . messageFrame (  . CODEC ,     \" foo \"  ,     \" bar \"  )  . getContent (  )  )  ;", "assertThat ( this . session . isOpen (  )  ,    equalTo ( true )  )  ;", "verify ( this . handler )  . afterConnectionEstablished ( this . session )  ;", "verify ( this . handler )  . handleMessage ( this . session ,    new   TextMessage (  \" foo \"  )  )  ;", "verify ( this . handler )  . handleMessage ( this . session ,    new   TextMessage (  \" bar \"  )  )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "}", "METHOD_END"], "methodName": ["handleFrameMessageWithWebSocketHandlerException"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . session . isOpen (  )  ,    is ( false )  )  ;", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "assertThat ( this . session . isOpen (  )  ,    is ( true )  )  ;", "assertTrue ( this . connectFuture . isDone (  )  )  ;", "assertThat ( this . connectFuture . get (  )  ,    sameInstance ( this . session )  )  ;", "verify ( this . handler )  . afterConnectionEstablished ( this . session )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "}", "METHOD_END"], "methodName": ["handleFrameOpen"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "assertThat ( this . session . isOpen (  )  ,    is ( true )  )  ;", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "assertThat ( this . session . disconnectStatus ,    equalTo ( new   CloseStatus (  1  0  0  6  ,     \" Server   lost   session \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleFrameOpenWhenStatusNotNew"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "willThrow ( new   IllegalStateException (  \" Fake   error \"  )  )  . given ( this . handler )  . afterConnectionEstablished ( this . session )  ;", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "assertThat ( this . session . isOpen (  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["handleFrameOpenWithWebSocketHandlerException"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "final   IllegalStateException   ex    =    new   IllegalStateException (  \" Fake   error \"  )  ;", "this . s . handleTransportError ( ex )  ;", "verify ( this . handler )  . handleTransportError ( this . s ,    ex )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "}", "METHOD_END"], "methodName": ["handleTransportError"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleFrame ( SockJsFrame . openFrame (  )  . getContent (  )  )  ;", "this . session . sendMessage ( new   TextMessage (  \" foo \"  )  )  ;", "assertThat ( this . session . sentMessage ,    equalTo ( new   TextMessage (  \"  [  \\  \" foo \\  \"  ]  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["send"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "SockJsUrlInfo   urlInfo    =    new   SockJsUrlInfo ( new   URI (  \" http :  /  / example . com \"  )  )  ;", "Transport   transport    =    mock ( Transport . class )  ;", "TransportRequest   request    =    new   DefaultTransportRequest ( urlInfo ,    null ,    null ,    transport ,    TransportType . XHR ,     . CODEC )  ;", "this . handler    =    mock ( WebSocketHandler . class )  ;", "this . connectFuture    =    new   SettableListenableFuture (  )  ;", "this . session    =    new    . TestClientSockJsSession ( request ,    this . handler ,    this . connectFuture )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . getTimeoutTask (  )  . run (  )  ;", "assertThat ( this . session . disconnectStatus ,    equalTo ( new   CloseStatus (  2  0  0  7  ,     \" Transport   timed   out \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["timeoutTask"], "fileName": "org.springframework.web.socket.sockjs.client.ClientSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "if    ( DefaultTransportRequest . logger . isTraceEnabled (  )  )     {", "DefaultTransportRequest . logger . trace (  (  \" Starting    \"     +     ( this )  )  )  ;", "}", "DefaultTransportRequest . ConnectCallback   connectCallback    =    new   DefaultTransportRequest . ConnectCallback ( handler ,    future )  ;", "scheduleConnectTimeoutTask ( connectCallback )  ;", "this . transport . connect ( this ,    handler )  . addCallback ( connectCallback )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . timeoutScheduler )     !  =    null )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Scheduling   connect   to   time   out   after    \"     +     ( this . timeoutValue )  )     +     \"    ms .  \"  )  )  ;", "}", "Date   timeoutDate    =    new   Date (  (  ( System . currentTimeMillis (  )  )     +     ( this . timeoutValue )  )  )  ;", "this . timeoutScheduler . schedule ( connectHandler ,    timeoutDate )  ;", "} else", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  \" Connect   timeout   task   not   scheduled    ( no   TaskScheduler   configured )  .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["scheduleConnectTimeoutTask"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequest"}, {"methodBody": ["METHOD_START", "{", "this . fallbackRequest    =    fallbackRequest ;", "}", "METHOD_END"], "methodName": ["setFallbackRequest"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequest"}, {"methodBody": ["METHOD_START", "{", "this . timeoutScheduler    =    scheduler ;", "}", "METHOD_END"], "methodName": ["setTimeoutScheduler"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequest"}, {"methodBody": ["METHOD_START", "{", "this . timeoutValue    =    timeoutValue ;", "}", "METHOD_END"], "methodName": ["setTimeoutValue"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequest"}, {"methodBody": ["METHOD_START", "{", "this . user    =    user ;", "}", "METHOD_END"], "methodName": ["setUser"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequest"}, {"methodBody": ["METHOD_START", "{", "DefaultTransportRequest   request    =    createTransportRequest ( this . webSocketTransport ,    TransportType . WEBSOCKET )  ;", "request . connect ( null ,    this . connectFuture )  ;", "WebSocketSession   session    =    mock ( WebSocketSession . class )  ;", "this . webSocketTransport . getConnectCallback (  )  . onSuccess ( session )  ;", "assertSame ( session ,    this . connectFuture . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequestTests"}, {"methodBody": ["METHOD_START", "{", "SockJsUrlInfo   urlInfo    =    new   SockJsUrlInfo ( new   URI (  \" http :  /  / example . com \"  )  )  ;", "return   new   DefaultTransportRequest ( urlInfo ,    new   HttpHeaders (  )  ,    new   HttpHeaders (  )  ,    transport ,    type ,     . CODEC )  ;", "}", "METHOD_END"], "methodName": ["createTransportRequest"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequestTests"}, {"methodBody": ["METHOD_START", "{", "TaskScheduler   scheduler    =    mock ( TaskScheduler . class )  ;", "Runnable   sessionCleanupTask    =    mock ( Runnable . class )  ;", "request 1     =    createTransportRequest ( this . webSocketTransport ,    TransportType . WEBSOCKET )  ;", "request 2     =    createTransportRequest ( this . xhrTransport ,    TransportType . XHR _ STREAMING )  ;", "request 1  . setFallbackRequest ( request 2  )  ;", "request 1  . setTimeoutScheduler ( scheduler )  ;", "request 1  . addTimeoutTask ( sessionCleanupTask )  ;", "request 1  . connect ( null ,    this . connectFuture )  ;", "assertTrue ( this . webSocketTransport . invoked (  )  )  ;", "assertFalse ( this . xhrTransport . invoked (  )  )  ;", "ArgumentCaptor < Runnable >    taskCaptor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "verify ( scheduler )  . schedule ( taskCaptor . capture (  )  ,    any ( Date . class )  )  ;", "verifyNoMoreInteractions ( scheduler )  ;", "taskCaptor . getValue (  )  . run (  )  ;", "assertTrue ( this . xhrTransport . invoked (  )  )  ;", "verify ( sessionCleanupTask )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["fallbackAfterTimeout"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequestTests"}, {"methodBody": ["METHOD_START", "{", "DefaultTransportRequest   request 1     =    createTransportRequest ( this . webSocketTransport ,    TransportType . WEBSOCKET )  ;", "DefaultTransportRequest   request 2     =    createTransportRequest ( this . xhrTransport ,    TransportType . XHR _ STREAMING )  ;", "request 1  . setFallbackRequest ( request 2  )  ;", "request 1  . connect ( null ,    this . connectFuture )  ;", "this . webSocketTransport . getConnectCallback (  )  . onFailure ( new   IOException (  \" Fake   exception    1  \"  )  )  ;", "assertFalse ( this . connectFuture . isDone (  )  )  ;", "assertTrue ( this . xhrTransport . invoked (  )  )  ;", "this . xhrTransport . getConnectCallback (  )  . onFailure ( new   IOException (  \" Fake   exception    2  \"  )  )  ;", "assertTrue ( this . connectFuture . isDone (  )  )  ;", "this . thrown . expect ( ExecutionException . class )  ;", "this . thrown . expectMessage (  \" Fake   exception    2  \"  )  ;", "this . connectFuture . get (  )  ;", "}", "METHOD_END"], "methodName": ["fallbackAfterTransportError"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequestTests"}, {"methodBody": ["METHOD_START", "{", "this . connectCallback    =    mock ( ListenableFutureCallback . class )  ;", "this . connectFuture    =    new   util . concurrent . SettableListenableFuture (  )  ;", "this . connectFuture . addCallback ( this . connectCallback )  ;", "this . webSocketTransport    =    new   TestTransport (  \" WebSocketTestTransport \"  )  ;", "this . xhrTransport    =    new   TestTransport (  \" XhrTestTransport \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.sockjs.client.DefaultTransportRequestTests"}, {"methodBody": ["METHOD_START", "{", "headers . forEach (  (    key ,    values )     -  >     {", "for    ( St   value    :    values )     {", "request . header ( key ,    value )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addHttpHeaders"], "fileName": "org.springframework.web.socket.sockjs.client.JettyXhrTransport"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Starting   XHR   receive   request ,    url =  \"     +    url )  )  ;", "}", "Request   httpRequest    =    this . httpClient . newRequest ( url )  . method ( POST )  ;", ". addHttpHeaders ( httpRequest ,    headers )  ;", "httpRequest . send ( listener )  ;", "}", "METHOD_END"], "methodName": ["executeReceiveRequest"], "fileName": "org.springframework.web.socket.sockjs.client.JettyXhrTransport"}, {"methodBody": ["METHOD_START", "{", "Request   httpRequest    =    this . httpClient . newRequest ( url )  . method ( method )  ;", "JettyXhrTransport . addHttpHeaders ( httpRequest ,    headers )  ;", "if    ( body    !  =    null )     {", "httpRequest . content ( new   StringContentProvider ( body )  )  ;", "}", "ContentResponse   response ;", "try    {", "response    =    httpRequest . send (  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   SockJsTransportFailureException (  (  \" Failed   to   execute   request   to    \"     +    url )  ,    ex )  ;", "}", "HttpStatus   status    =    HttpStatus . valueOf ( response . getStatus (  )  )  ;", "HttpHeaders   responseHeaders    =    JettyXhrTransport . toHttpHeaders ( response . getHeaders (  )  )  ;", "return    ( response . getContent (  )  )     !  =    null    ?    new   http . ResponseEntity ( response . getContentAsString (  )  ,    responseHeaders ,    status )     :    new   http . ResponseEntity ( responseHeaders ,    status )  ;", "}", "METHOD_END"], "methodName": ["executeRequest"], "fileName": "org.springframework.web.socket.sockjs.client.JettyXhrTransport"}, {"methodBody": ["METHOD_START", "{", "return   this . httpClient ;", "}", "METHOD_END"], "methodName": ["getHttpClient"], "fileName": "org.springframework.web.socket.sockjs.client.JettyXhrTransport"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   responseHeaders    =    new   HttpHeaders (  )  ;", "Enumeration < St >    names    =    httpFields . getFieldNames (  )  ;", "while    ( names . hasMoreElements (  )  )     {", "St   name    =    names . nextElement (  )  ;", "Enumeration < St >    values    =    httpFields . getValues ( name )  ;", "while    ( values . hasMoreElements (  )  )     {", "St   value    =    values . nextElement (  )  ;", "responseHeaders . add ( name ,    value )  ;", "}", "}", "return   responseHeaders ;", "}", "METHOD_END"], "methodName": ["toHttpHeaders"], "fileName": "org.springframework.web.socket.sockjs.client.JettyXhrTransport"}, {"methodBody": ["METHOD_START", "{", "return   this . restTemplate ;", "}", "METHOD_END"], "methodName": ["getRestTemplate"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport"}, {"methodBody": ["METHOD_START", "{", "return   this . taskExecutor ;", "}", "METHOD_END"], "methodName": ["getTaskExecutor"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  ( result    !  =    null )  ,     \" No   result \"  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["nonNull"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( taskExecutor ,     \" TaskExecutor   must   not   be   null \"  )  ;", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransport"}, {"methodBody": ["METHOD_START", "{", "return   connect ( new   RestTemplateXhrTransportTests . TestRestTemplate ( responses )  )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "RestTemplateXhrTransport   transport    =    new   RestTemplateXhrTransport ( restTemplate )  ;", "transport . setTaskExecutor ( new   SyncTaskExecutor (  )  )  ;", "SockJsUrlInfo   urlInfo    =    new   SockJsUrlInfo ( new   URI (  \" http :  /  / example . com \"  )  )  ;", "HttpHeaders   headers    =    new   HttpHeaders (  )  ;", "headers . add (  \" h - foo \"  ,     \" h - bar \"  )  ;", "TransportRequest   request    =    new   DefaultTransportRequest ( urlInfo ,    headers ,    headers ,    transport ,    TransportType . XHR ,     . CODEC )  ;", "return   transport . connect ( request ,    this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "final   HttpServerErrorException   expected    =    new   HttpServerErrorException ( HttpStatus . INTERNAL _ SERVER _ ERROR )  ;", "RestOperations   restTemplate    =    mock ( RestOperations . class )  ;", "given ( restTemplate . execute (  (  ( URI )     ( any (  )  )  )  ,    eq ( POST )  ,    any (  )  ,    any (  )  )  )  . willThrow ( expected )  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "connect ( restTemplate )  . addCallback ( new   util . concurrent . ListenableFutureCallback < WebSocketSession >  (  )     {", "@ Override", "public   void   onSuccess ( WebSocketSession   result )     {", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "if    ( ex    =  =    expected )     {", "latch . countDown (  )  ;", "}", "}", "}  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["connectFailure"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" o \\ n \"     +     (  \" a [  \\  \" foo \\  \"  ]  \\ n \"     +     \" c [  3  0  0  0  ,  \\  \" Go   away !  \\  \"  ]  \"  )  ;", "CHttpResponse   response    =    response ( OK ,    body )  ;", "connect ( response )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( any (  )  )  ;", "verify ( this . webSocketHandler )  . handleMessage ( any (  )  ,    eq ( new   TextMessage (  \" foo \"  )  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionClosed ( any (  )  ,    eq ( new   CloseStatus (  3  0  0  0  ,     \" Go   away !  \"  )  )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["connectReceiveAndClose"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  2  0  4  8  )  ;", "for    ( int   i    =     0  ;    i    <     2  0  4  8  ;    i +  +  )     {", "sb . append (  ' h '  )  ;", "}", "String   body    =     (  (  (  ( sb . toString (  )  )     +     \"  \\ n \"  )     +     \" o \\ n \"  )     +     \" a [  \\  \" foo \\  \"  ]  \\ n \"  )     +     \" c [  3  0  0  0  ,  \\  \" Go   away !  \\  \"  ]  \"  ;", "CHttpResponse   response    =    response ( OK ,    body )  ;", "connect ( response )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( any (  )  )  ;", "verify ( this . webSocketHandler )  . handleMessage ( any (  )  ,    eq ( new   TextMessage (  \" foo \"  )  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionClosed ( any (  )  ,    eq ( new   CloseStatus (  3  0  0  0  ,     \" Go   away !  \"  )  )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["connectReceiveAndCloseWithPrelude"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( SEND )  ;", "accessor . setDestination (  \"  / destination \"  )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage (  \" body \"  . getBytes ( StandardCharsets . UTF _  8  )  ,    headers )  ;", "byte [  ]    bytes    =    new   StompEncoder (  )  . encode ( message )  ;", "TextMessage   textMessage    =    new   TextMessage ( bytes )  ;", "SockJsFrame       =    SockJsFrame . messageFrame ( new   Jackson 2 SockJsMessageCodec (  )  ,    textMessage . getPayload (  )  )  ;", "String   body    =     (  (  \" o \\ n \"     +     (  . getContent (  )  )  )     +     \"  \\ n \"  )     +     \" c [  3  0  0  0  ,  \\  \" Go   away !  \\  \"  ]  \"  ;", "ClientHttpResponse   response    =    response ( OK ,    body )  ;", "connect ( response )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( any (  )  )  ;", "verify ( this . webSocketHandler )  . handleMessage ( any (  )  ,    eq ( textMessage )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionClosed ( any (  )  ,    eq ( new   CloseStatus (  3  0  0  0  ,     \" Go   away !  \"  )  )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["connectReceiveAndCloseWithStompFrame"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "connect ( response ( OK ,     \" o \\ n \"  )  ,    response ( INTERNAL _ SERVER _ ERROR ,     \" Oops \"  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( any (  )  )  ;", "verify ( this . webSocketHandler )  . handleError ( any (  )  ,    any (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionClosed ( any (  )  ,    any (  )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["errorResponseStatus"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    content . getBytes ( StandardCharsets . UTF _  8  )  ;", "return   new   ByteArrayInputStream ( bytes )  ;", "}", "METHOD_END"], "methodName": ["getInputStream"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "ClientHttpResponse   response    =    mock ( ClientHttpResponse . class )  ;", "InputStream   inputStream    =    getInputStream ( body )  ;", "given ( response . getRawStatusCode (  )  )  . willReturn ( status . value (  )  )  ;", "given ( response . getBody (  )  )  . willReturn ( inputStream )  ;", "return   response ;", "}", "METHOD_END"], "methodName": ["response"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" o \\ n \"     +     (  \" c [  3  0  0  0  ,  \\  \" Go   away !  \\  \"  ]  \\ n \"     +     \" a [  \\  \" foo \\  \"  ]  \\ n \"  )  ;", "CHttpResponse   response    =    response ( OK ,    body )  ;", "connect ( response )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( any (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionClosed ( any (  )  ,    any (  )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "verify ( response )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["responseClosedAfterDisconnected"], "fileName": "org.springframework.web.socket.sockjs.client.RestTemplateXhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "this . serverInfoCache . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearServerInfoCache"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "List < DefaultTransportRequest >    requests    =    new   ArrayList <  >  ( this . transports . size (  )  )  ;", "for    ( Transport   transport    :    this . transports )     {", "for    ( TransportType   type    :    transport . getTransportTypes (  )  )     {", "if    (  ( serverInfo . isWebSEnabled (  )  )     |  |     (  !  ( TransportType . WEBSOCKET . equals ( type )  )  )  )     {", "requests . add ( new   DefaultTransportRequest ( urlInfo ,    headers ,    getHttpRequestHeaders ( headers )  ,    transport ,    type ,    getMessageCodec (  )  )  )  ;", "}", "}", "}", "if    ( CollectionUtils . isEmpty ( requests )  )     {", "throw   new   IllegalStateException (  (  (  (  \" No   transports :     \"     +    urlInfo )     +     \"  ,    webSEnabled =  \"  )     +     ( serverInfo . isWebSEnabled (  )  )  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     (  ( requests . size (  )  )     -     1  )  ;    i +  +  )     {", "DefaultTransportRequest   request    =    requests . get ( i )  ;", "Principal   user    =    getUser (  )  ;", "if    ( user    !  =    null )     {", "request . setUser ( user )  ;", "}", "if    (  ( this . connectTimeoutScheduler )     !  =    null )     {", "request . setTimeoutValue ( serverInfo . getRetransmissionTimeout (  )  )  ;", "request . setTimeoutScheduler ( this . connectTimeoutScheduler )  ;", "}", "request . setFallbackRequest ( requests . get (  ( i    +     1  )  )  )  ;", "}", "return   requests . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["createRequest"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "return   this . httpHeaderNames ;", "}", "METHOD_END"], "methodName": ["getHttpHeaderNames"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( getHttpHeaderNames (  )  )     =  =    null )     |  |     ( webSocketHttpHeaders    =  =    null )  )     {", "return   webSocketHttpHeaders ;", "} else    {", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "for    ( String   name    :    getHttpHeaderNames (  )  )     {", "List < String >    values    =    webSocketHttpHeaders . get ( name )  ;", "if    ( values    !  =    null )     {", "httpHeaders . put ( name ,    values )  ;", "}", "}", "return   httpHeaders ;", "}", "}", "METHOD_END"], "methodName": ["getHttpRequestHeaders"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "return   this . infoReceiver ;", "}", "METHOD_END"], "methodName": ["getInfoReceiver"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . messageCodec )     !  =    null )  ,     \" No   SockJsMessageCodec   set \"  )  ;", "return   this . messageCodec ;", "}", "METHOD_END"], "methodName": ["getMessageCodec"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "URI   infoUrl    =    sockJsUrlInfo . getInfoUrl (  )  ;", ". ServerInfo   info    =    this . serverInfoCache . get ( infoUrl )  ;", "if    ( info    =  =    null )     {", "long   start    =    System . currentTimeMillis (  )  ;", "String   response    =    this . infoReceiver . executeInfoRequest ( infoUrl ,    headers )  ;", "long   infoRequestTime    =     ( System . currentTimeMillis (  )  )     -    start ;", "info    =    new    . ServerInfo ( response ,    infoRequestTime )  ;", "this . serverInfoCache . put ( infoUrl ,    info )  ;", "}", "return   info ;", "}", "METHOD_END"], "methodName": ["getServerInfo"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getUser"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "for    ( Transport   transport    :    transports )     {", "if    ( transport   instanceof   InfoReceiver )     {", "return    (  ( InfoReceiver )     ( transport )  )  ;", "}", "}", "return   new   RestTemplateXhrTransport (  )  ;", "}", "METHOD_END"], "methodName": ["initInfoReceiver"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "this . connectTimeoutScheduler    =    connectTimeoutScheduler ;", "}", "METHOD_END"], "methodName": ["setConnectTimeoutScheduler"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "this . httpHeaderNames    =    httpHeaderNames ;", "}", "METHOD_END"], "methodName": ["setHttpHeaderNames"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( infoReceiver ,     \" InfoReceiver   is   required \"  )  ;", "this . infoReceiver    =    infoReceiver ;", "}", "METHOD_END"], "methodName": ["setInfoReceiver"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messageCodec ,     \" SockJsMessageCodec   is   required \"  )  ;", "this . messageCodec    =    messageCodec ;", "}", "METHOD_END"], "methodName": ["setMessageCodec"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClient"}, {"methodBody": ["METHOD_START", "{", "ArgumentCaptor < HttpHeaders >    headersCaptor    =    setupInfoRequest ( false )  ;", "this . xhrTransport . setStreamingDisabled ( true )  ;", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders (  )  ;", "headers . set (  \" foo \"  ,     \" bar \"  )  ;", "headers . set (  \" auth \"  ,     \"  1  2  3  \"  )  ;", "this . sockJsClient . setHttpHeaderNames (  \" auth \"  )  ;", "this . sockJsClient . doHandshake (  . handler ,    headers ,    new   URI (  . URL )  )  . addCallback ( this . connectCallback )  ;", "assertEquals (  1  ,    headersCaptor . getValue (  )  . size (  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    headersCaptor . getValue (  )  . getFirst (  \" auth \"  )  )  ;", "assertEquals (  1  ,    this . xhrTransport . getRequest (  )  . getHttpRequestHeaders (  )  . size (  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    this . xhrTransport . getRequest (  )  . getHttpRequestHeaders (  )  . getFirst (  \" auth \"  )  )  ;", "}", "METHOD_END"], "methodName": ["connectAndUseSubsetOfHandshakeHeadersForHttpRequests"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "HttpServerErrorException   exception    =    new   HttpServerErrorException ( HttpStatus . SERVICE _ UNAVAILABLE )  ;", "given ( this . infoReceiver . executeInfoRequest ( any (  )  ,    any (  )  )  )  . willThrow ( exception )  ;", "this . sockJsClient . doHandshake (  . handler ,     . URL )  . addCallback ( this . connectCallback )  ;", "verify ( this . connectCallback )  . onFailure ( exception )  ;", "assertFalse ( this . webSocketTransport . invoked (  )  )  ;", "assertFalse ( this . xhrTransport . invoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["connectInfoRequestFailure"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "setupInfoRequest ( true )  ;", "this . sockJsClient . doHandshake (  . handler ,     . URL )  ;", "verify ( this . infoReceiver ,    times (  1  )  )  . executeInfoRequest ( any (  )  ,    any (  )  )  ;", "}", "METHOD_END"], "methodName": ["connectSockJsInfo"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "setupInfoRequest ( true )  ;", "this . sockJsClient . doHandshake (  . handler ,     . URL )  ;", "this . sockJsClient . doHandshake (  . handler ,     . URL )  ;", "this . sockJsClient . doHandshake (  . handler ,     . URL )  ;", "verify ( this . infoReceiver ,    times (  1  )  )  . executeInfoRequest ( any (  )  ,    any (  )  )  ;", "}", "METHOD_END"], "methodName": ["connectSockJsInfoCached"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "setupInfoRequest ( true )  ;", "this . sockJsClient . doHandshake (  . handler ,     . URL )  . addCallback ( this . connectCallback )  ;", "assertTrue ( this . webSocketTransport . invoked (  )  )  ;", "WebSocketSession   session    =    mock ( WebSocketSession . class )  ;", "this . webSocketTransport . getConnectCallback (  )  . onSuccess ( session )  ;", "verify ( this . connectCallback )  . onSuccess ( session )  ;", "verifyNoMoreInteractions ( this . connectCallback )  ;", "}", "METHOD_END"], "methodName": ["connectWebSocket"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "setupInfoRequest ( false )  ;", "this . sockJsClient . doHandshake (  . handler ,     . URL )  ;", "assertFalse ( this . webSocketTransport . invoked (  )  )  ;", "assertTrue ( this . xhrTransport . invoked (  )  )  ;", "assertTrue ( this . xhrTransport . getRequest (  )  . getTransportUrl (  )  . toString (  )  . endsWith (  \" xhr _ streaming \"  )  )  ;", "}", "METHOD_END"], "methodName": ["connectWebSocketDisabled"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "ArgumentCaptor < HttpHeaders >    headersCaptor    =    setupInfoRequest ( false )  ;", "this . xhrTransport . setStreamingDisabled ( true )  ;", "WebSocketHttpHeaders   headers    =    new   WebSocketHttpHeaders (  )  ;", "headers . set (  \" foo \"  ,     \" bar \"  )  ;", "headers . set (  \" auth \"  ,     \"  1  2  3  \"  )  ;", "this . sockJsClient . doHandshake (  . handler ,    headers ,    new   URI (  . URL )  )  . addCallback ( this . connectCallback )  ;", "HttpHeaders   httpHeaders    =    headersCaptor . getValue (  )  ;", "assertEquals (  2  ,    httpHeaders . size (  )  )  ;", "assertEquals (  \" bar \"  ,    httpHeaders . getFirst (  \" foo \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    httpHeaders . getFirst (  \" auth \"  )  )  ;", "httpHeaders    =    this . xhrTransport . getRequest (  )  . getHttpRequestHeaders (  )  ;", "assertEquals (  2  ,    httpHeaders . size (  )  )  ;", "assertEquals (  \" bar \"  ,    httpHeaders . getFirst (  \" foo \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    httpHeaders . getFirst (  \" auth \"  )  )  ;", "}", "METHOD_END"], "methodName": ["connectWithHandshakeHeaders"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "setupInfoRequest ( false )  ;", "this . xhrTransport . setStreamingDisabled ( true )  ;", "this . sockJsClient . doHandshake (  . handler ,     . URL )  . addCallback ( this . connectCallback )  ;", "assertFalse ( this . webSocketTransport . invoked (  )  )  ;", "assertTrue ( this . xhrTransport . invoked (  )  )  ;", "assertTrue ( this . xhrTransport . getRequest (  )  . getTransportUrl (  )  . toString (  )  . endsWith (  \" xhr \"  )  )  ;", "}", "METHOD_END"], "methodName": ["connectXhrStreamingDisabled"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "this . infoReceiver    =    mock ( InfoReceiver . class )  ;", "this . webSocketTransport    =    new   TestTransport (  \" WebSocketTestTransport \"  )  ;", "this . xhrTransport    =    new   TestTransport . XhrTestTransport (  \" XhrTestTransport \"  )  ;", "List < Transport >    transports    =    new   ArrayList <  >  (  )  ;", "transports . add ( this . webSocketTransport )  ;", "transports . add ( this . xhrTransport )  ;", "this . sockJsClient    =    new    ( transports )  ;", "this . sockJsClient . setInfoReceiver ( this . infoReceiver )  ;", "this . connectCallback    =    mock ( ListenableFutureCallback . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "ArgumentCaptor < HttpHeaders >    headersCaptor    =    ArgumentCaptor . forClass ( HttpHeaders . class )  ;", "when ( this . infoReceiver . executeInfoRequest ( any (  )  ,    headersCaptor . capture (  )  )  )  . thenReturn (  (  (  (  \"  {  \\  \" entropy \\  \"  :  1  2  3  ,  \"     +     (  (  \"  \\  \" origins \\  \"  :  [  \\  \"  *  :  *  \\  \"  ]  ,  \"     +     \"  \\  \" cookie _ needed \\  \"  : true ,  \"  )     +     \"  \\  \" web \\  \"  :  \"  )  )     +    webSocketEnabled )     +     \"  }  \"  )  )  ;", "return   headersCaptor ;", "}", "METHOD_END"], "methodName": ["setupInfoRequest"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsClientTests"}, {"methodBody": ["METHOD_START", "{", "return   UriComponentsBuilder . fromUri ( this . sockJsUrl )  . scheme ( getScheme ( TransportType . XHR )  )  . pathSegment (  \" info \"  )  . build ( true )  . toUri (  )  ;", "}", "METHOD_END"], "methodName": ["getInfoUrl"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfo"}, {"methodBody": ["METHOD_START", "{", "String   scheme    =    this . sockJsUrl . getScheme (  )  ;", "if    ( TransportType . WEBSOCKET . equals ( transportType )  )     {", "if    (  !  ( scheme . startsWith (  \" ws \"  )  )  )     {", "scheme    =     (  \" https \"  . equals ( scheme )  )     ?     \" wss \"     :     \" ws \"  ;", "}", "} else    {", "if    (  !  ( scheme . startsWith (  \" http \"  )  )  )     {", "scheme    =     (  \" wss \"  . equals ( scheme )  )     ?     \" https \"     :     \" http \"  ;", "}", "}", "return   scheme ;", "}", "METHOD_END"], "methodName": ["getScheme"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfo"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . serverId )     =  =    null )     {", "this . serverId    =    St . valueOf (  (  ( Math . abs ( getUuid (  )  . getMostSignificantBits (  )  )  )     %     1  0  0  0  )  )  ;", "}", "return   this . serverId ;", "}", "METHOD_END"], "methodName": ["getServerId"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfo"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . sessionId )     =  =    null )     {", "this . sessionId    =    getUuid (  )  . toSt (  )  . replace (  \"  -  \"  ,     \"  \"  )  ;", "}", "return   this . sessionId ;", "}", "METHOD_END"], "methodName": ["getSessionId"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . sockJsUrl ;", "}", "METHOD_END"], "methodName": ["getSockJsUrl"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfo"}, {"methodBody": ["METHOD_START", "{", "return   UriComponentsBuilder . fromUri ( this . sockJsUrl )  . scheme ( getScheme ( transportType )  )  . pathSegment ( getServerId (  )  )  . pathSegment ( getSessionId (  )  )  . pathSegment ( transportType . toString (  )  )  . build ( true )  . toUri (  )  ;", "}", "METHOD_END"], "methodName": ["getTransportUrl"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfo"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . uuid )     =  =    null )     {", "this . uuid    =     . idGenerator . generateId (  )  ;", "}", "return   this . uuid ;", "}", "METHOD_END"], "methodName": ["getUuid"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfo"}, {"methodBody": ["METHOD_START", "{", "testInfoUrl (  \" http \"  ,     \" http \"  )  ;", "testInfoUrl (  \" http \"  ,     \" http \"  )  ;", "testInfoUrl (  \" https \"  ,     \" https \"  )  ;", "testInfoUrl (  \" https \"  ,     \" https \"  )  ;", "testInfoUrl (  \" ws \"  ,     \" http \"  )  ;", "testInfoUrl (  \" ws \"  ,     \" http \"  )  ;", "testInfoUrl (  \" wss \"  ,     \" https \"  )  ;", "testInfoUrl (  \" wss \"  ,     \" https \"  )  ;", "}", "METHOD_END"], "methodName": ["infoUrl"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfoTests"}, {"methodBody": ["METHOD_START", "{", "SockJsUrlInfo   info    =    new   SockJsUrlInfo ( new   URI (  \" http :  /  / example . com \"  )  )  ;", "int   serverId    =    Integer . valueOf ( info . getServerId (  )  )  ;", "assertTrue (  (  \" Invalid   serverId :     \"     +    serverId )  ,     (  ( serverId    >  =     0  )     &  &     ( serverId    <     1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["serverId"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfoTests"}, {"methodBody": ["METHOD_START", "{", "SockJsUrlInfo   info    =    new   SockJsUrlInfo ( new   URI (  \" http :  /  / example . com \"  )  )  ;", "assertEquals (  (  \" Invalid   sessionId :     \"     +     ( info . getSessionId (  )  )  )  ,     3  2  ,    info . getSessionId (  )  . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["sessionId"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfoTests"}, {"methodBody": ["METHOD_START", "{", "SockJsUrlInfo   info    =    new   SockJsUrlInfo ( new   URI (  ( scheme    +     \"  :  /  / example . com \"  )  )  )  ;", "Assert . assertThat ( info . getInfoUrl (  )  ,    is ( equalTo ( new   URI (  ( expectedScheme    +     \"  :  /  / example . com / info \"  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testInfoUrl"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfoTests"}, {"methodBody": ["METHOD_START", "{", "SockJsUrlInfo   info    =    new   SockJsUrlInfo ( new   URI (  ( scheme    +     \"  :  /  / example . com \"  )  )  )  ;", "String   serverId    =    info . getServerId (  )  ;", "String   sessionId    =    info . getSessionId (  )  ;", "String   transport    =    transportType . toString (  )  . toLowerCase (  )  ;", "URI   expected    =    new   URI (  (  (  (  (  (  ( expectedScheme    +     \"  :  /  / example . com /  \"  )     +    serverId )     +     \"  /  \"  )     +    sessionId )     +     \"  /  \"  )     +    transport )  )  ;", "assertThat ( info . getTransportUrl ( transportType )  ,    equalTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["testTransportUrl"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfoTests"}, {"methodBody": ["METHOD_START", "{", "testTransportUrl (  \" http \"  ,     \" http \"  ,    TransportType . XHR _ STREAMING )  ;", "testTransportUrl (  \" http \"  ,     \" ws \"  ,    TransportType . WEBSOCKET )  ;", "testTransportUrl (  \" https \"  ,     \" https \"  ,    TransportType . XHR _ STREAMING )  ;", "testTransportUrl (  \" https \"  ,     \" wss \"  ,    TransportType . WEBSOCKET )  ;", "testTransportUrl (  \" ws \"  ,     \" http \"  ,    TransportType . XHR _ STREAMING )  ;", "testTransportUrl (  \" ws \"  ,     \" ws \"  ,    TransportType . WEBSOCKET )  ;", "testTransportUrl (  \" wss \"  ,     \" https \"  ,    TransportType . XHR _ STREAMING )  ;", "testTransportUrl (  \" wss \"  ,     \" wss \"  ,    TransportType . WEBSOCKET )  ;", "}", "METHOD_END"], "methodName": ["transportUrl"], "fileName": "org.springframework.web.socket.sockjs.client.SockJsUrlInfoTests"}, {"methodBody": ["METHOD_START", "{", "ArgumentCaptor < ListenableFutureCallback >    captor    =    ArgumentCaptor . forClass ( ListenableFutureCallback . class )  ;", "verify ( this . future )  . addCallback ( captor . capture (  )  )  ;", "return   captor . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getConnectCallback"], "fileName": "org.springframework.web.socket.sockjs.client.TestTransport"}, {"methodBody": ["METHOD_START", "{", "return   this . request ;", "}", "METHOD_END"], "methodName": ["getRequest"], "fileName": "org.springframework.web.socket.sockjs.client.TestTransport"}, {"methodBody": ["METHOD_START", "{", "return    ( this . future )     !  =    null ;", "}", "METHOD_END"], "methodName": ["invoked"], "fileName": "org.springframework.web.socket.sockjs.client.TestTransport"}, {"methodBody": ["METHOD_START", "{", "HeaderMap   headerMap    =    request . getRequestHeaders (  )  ;", "headers . forEach (  (    key ,    values )     -  >     {", "for    ( St   value    :    values )     {", "headerMap . add ( HttpSt . tryFromSt ( key )  ,    value )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addHttpHeaders"], "fileName": "org.springframework.web.socket.sockjs.client.UndertowXhrTransport"}, {"methodBody": ["METHOD_START", "{", "return   new   io . undertow . client . ClientCallback < ClientExchange >  (  )     {", "@ Override", "public   void   completed ( final   ClientExchange   exchange )     {", "exchange . setResponseListener ( new   io . undertow . client . ClientCallback < ClientExchange >  (  )     {", "@ Override", "public   void   completed ( ClientExchange   result )     {", "ClientResponse   response    =    result . getResponse (  )  ;", "if    (  ( response . getResponseCode (  )  )     !  =     2  0  0  )     {", "HttpStatus   status    =    HttpStatus . valueOf ( response . getResponseCode (  )  )  ;", "IoUtils . safeClose ( result . getConnection (  )  )  ;", "onFailure ( new   client . HttpServerErrorException ( status ,     \" Unexpected   XHR   receive   status \"  )  )  ;", "} else    {", "UndertowXhrTransport . SockJsResponseListener   listener    =    new   UndertowXhrTransport . SockJsResponseListener ( transportRequest ,    result . getConnection (  )  ,    url ,    headers ,    sockJsSession ,    connectFuture )  ;", "listener . setup ( result . getResponseChannel (  )  )  ;", "}", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" XHR   receive   headers :     \"     +     ( UndertowXhrTransport . toHttpHeaders ( response . getResponseHeaders (  )  )  )  )  )  ;", "}", "try    {", "StreamSinkChannel   channel    =    result . getRequestChannel (  )  ;", "channel . shutdownWrites (  )  ;", "if    (  !  ( channel . flush (  )  )  )     {", "channel . getWriteSetter (  )  . set ( ChannelListeners .  < StreamSinkChannel > flushingChannelListener ( null ,    null )  )  ;", "channel . resumeWrites (  )  ;", "}", "}    catch    ( IOException   exc )     {", "IoUtils . safeClose ( result . getConnection (  )  )  ;", "onFailure ( exc )  ;", "}", "}", "@ Override", "public   void   failed ( IOException   exc )     {", "IoUtils . safeClose ( exchange . getConnection (  )  )  ;", "onFailure ( exc )  ;", "}", "}  )  ;", "}", "@ Override", "public   void   failed ( IOException   exc )     {", "onFailure ( exc )  ;", "}", "private   void   onFailure ( Throwable   failure )     {", "if    ( connectFuture . setException ( failure )  )     {", "return ;", "}", "if    ( sockJsSession . isDisconnected (  )  )     {", "sockJsSession . afterTransportClosed ( null )  ;", "} else    {", "sockJsSession . handleTransportError ( failure )  ;", "sockJsSession . afterTransportClosed ( new   CloseStatus (  1  0  0  6  ,    failure . getMessage (  )  )  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createReceiveCallback"], "fileName": "org.springframework.web.socket.sockjs.client.UndertowXhrTransport"}, {"methodBody": ["METHOD_START", "{", "return   new   io . undertow . client . ClientCallback < ClientExchange >  (  )     {", "@ Override", "public   void   completed ( ClientExchange   result )     {", "result . setResponseListener ( new   io . undertow . client . ClientCallback < ClientExchange >  (  )     {", "@ Override", "public   void   completed ( final   ClientExchange   result )     {", "responses . add ( result . getResponse (  )  )  ;", "new   StringReadChannelListener ( result . getConnection (  )  . getBufferPool (  )  )     {", "@ Override", "protected   void   stringDone ( String   string )     {", "result . getResponse (  )  . putAttachment (  . RESPONSE _ BODY ,    string )  ;", "latch . countDown (  )  ;", "}", "@ Override", "protected   void   error ( IOException   ex )     {", "onFailure ( latch ,    ex )  ;", "}", "}  . setup ( result . getResponseChannel (  )  )  ;", "}", "@ Override", "public   void   failed ( IOException   ex )     {", "onFailure ( latch ,    ex )  ;", "}", "}  )  ;", "try    {", "if    ( body    !  =    null )     {", "result . getRequestChannel (  )  . write ( ByteBuffer . wrap ( body . getBytes (  )  )  )  ;", "}", "result . getRequestChannel (  )  . shutdownWrites (  )  ;", "if    (  !  ( result . getRequestChannel (  )  . flush (  )  )  )     {", "result . getRequestChannel (  )  . getWriteSetter (  )  . set ( ChannelListeners .  < StreamSinkChannel > flushingChannelListener ( null ,    null )  )  ;", "result . getRequestChannel (  )  . resumeWrites (  )  ;", "}", "}    catch    ( IOException   ex )     {", "onFailure ( latch ,    ex )  ;", "}", "}", "@ Override", "public   void   failed ( IOException   ex )     {", "onFailure ( latch ,    ex )  ;", "}", "private   void   onFailure ( CountDownLatch   latch ,    IOException   ex )     {", "latch . countDown (  )  ;", "throw   new   SockJsTransportFailureException (  \" Failed   to   execute   request \"  ,    ex )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createRequestCallback"], "fileName": "org.springframework.web.socket.sockjs.client.UndertowXhrTransport"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Starting   XHR   receive   request   for    \"     +    url )  )  ;", "}", "ClientCallback < ClientConnection >    clientCallback    =    new   ClientCallback < ClientConnection >  (  )     {", "@ Override", "public   void   completed ( ClientConnection   connection )     {", "ClientRequest   request    =    new   ClientRequest (  )  . setMethod ( POST )  . setPath ( url . getPath (  )  )  ;", "HttpString   headerName    =    HttpString . tryFromString ( HOST )  ;", "request . getRequestHeaders (  )  . add ( headerName ,    url . getHost (  )  )  ;", ". addHttpHeaders ( request ,    headers )  ;", "HttpHeaders   httpHeaders    =    transportRequest . getHttpRequestHeaders (  )  ;", "connection . sendRequest ( request ,    createReceiveCallback ( transportRequest ,    url ,    httpHeaders ,    session ,    connectFuture )  )  ;", "}", "@ Override", "public   void   failed ( IOException   ex )     {", "throw   new   SockJsTransportFailureException (  (  \" Failed   to   execute   request   to    \"     +    url )  ,    ex )  ;", "}", "}  ;", "this . httpClient . connect ( clientCallback ,    url ,    this . worker ,    this . bufferPool ,    this . optionMap )  ;", "}", "METHOD_END"], "methodName": ["executeReceiveRequest"], "fileName": "org.springframework.web.socket.sockjs.client.UndertowXhrTransport"}, {"methodBody": ["METHOD_START", "{", "CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "List < ClientResponse >    responses    =    new   CopyOnWriteArrayList <  >  (  )  ;", "try    {", "ClientConnection   connection    =    this . httpClient . connect ( url ,    this . worker ,    this . bufferPool ,    this . optionMap )  . get (  )  ;", "try    {", "ClientRequest   request    =    new   ClientRequest (  )  . setMethod ( method )  . setPath ( url . getPath (  )  )  ;", "request . getRequestHeaders (  )  . add ( HttpString . tryFromString ( HOST )  ,    url . getHost (  )  )  ;", "if    ( StringUtils . hasLength ( body )  )     {", "HttpString   headerName    =    HttpString . tryFromString ( CONTENT _ LENGTH )  ;", "request . getRequestHeaders (  )  . add ( headerName ,    body . length (  )  )  ;", "}", ". addHttpHeaders ( request ,    headers )  ;", "connection . sendRequest ( request ,    createRequestCallback ( body ,    responses ,    latch )  )  ;", "latch . await (  )  ;", "ClientResponse   response    =    responses . iterator (  )  . next (  )  ;", "HttpStatus   status    =    HttpStatus . valueOf ( response . getResponseCode (  )  )  ;", "HttpHeaders   responseHeaders    =     . toHttpHeaders ( response . getResponseHeaders (  )  )  ;", "String   responseBody    =    response . getAttachment (  . RESPONSE _ BODY )  ;", "return   responseBody    !  =    null    ?    new   ResponseEntity ( responseBody ,    responseHeaders ,    status )     :    new   ResponseEntity ( responseHeaders ,    status )  ;", "}    finally    {", "IoUtils . safeClose ( connection )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   SockJsTransportFailureException (  (  \" Failed   to   execute   request   to    \"     +    url )  ,    ex )  ;", "}    catch    ( InterruptedException   ex )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "throw   new   SockJsTransportFailureException (  (  \" Interrupted   while   processing   request   to    \"     +    url )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["executeRequest"], "fileName": "org.springframework.web.socket.sockjs.client.UndertowXhrTransport"}, {"methodBody": ["METHOD_START", "{", "return   this . httpClient ;", "}", "METHOD_END"], "methodName": ["getHttpClient"], "fileName": "org.springframework.web.socket.sockjs.client.UndertowXhrTransport"}, {"methodBody": ["METHOD_START", "{", "return   this . worker ;", "}", "METHOD_END"], "methodName": ["getWorker"], "fileName": "org.springframework.web.socket.sockjs.client.UndertowXhrTransport"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   httpHeaders    =    new   HttpHeaders (  )  ;", "for    ( HttpSt   name    :    headerMap . getHeaderNames (  )  )     {", "for    ( St   value    :    headerMap . get ( name )  )     {", "httpHeaders . add ( name . toSt (  )  ,    value )  ;", "}", "}", "return   httpHeaders ;", "}", "METHOD_END"], "methodName": ["toHttpHeaders"], "fileName": "org.springframework.web.socket.sockjs.client.UndertowXhrTransport"}, {"methodBody": ["METHOD_START", "{", "this . webSocketSession    =    session ;", "}", "METHOD_END"], "methodName": ["initializeDelegateSession"], "fileName": "org.springframework.web.socket.sockjs.client.WebSocketClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketClient ;", "}", "METHOD_END"], "methodName": ["getWebSocketClient"], "fileName": "org.springframework.web.socket.sockjs.client.WebSocketTransport"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.web.socket.sockjs.client.XhrClientSockJsSession"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   handshakeHeaders    =    new   HttpHeaders (  )  ;", "handshakeHeaders . setOrigin (  \" foo \"  )  ;", "TransportRequest   request    =    mock ( TransportRequest . class )  ;", "given ( request . getSockJsUrlInfo (  )  )  . willReturn ( new   SockJsUrlInfo ( new   URI (  \" http :  /  / example . com \"  )  )  )  ;", "given ( request . getHandshakeHeaders (  )  )  . willReturn ( handshakeHeaders )  ;", "given ( request . getHttpRequestHeaders (  )  )  . willReturn ( new   HttpHeaders (  )  )  ;", ". TestXhrTransport   transport    =    new    . TestXhrTransport (  )  ;", "WebSocketHandler   handler    =    mock ( WebSocketHandler . class )  ;", "transport . connect ( request ,    handler )  ;", "ArgumentCaptor < Runnable >    captor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "verify ( request )  . getSockJsUrlInfo (  )  ;", "verify ( request )  . addTimeoutTask ( captor . capture (  )  )  ;", "verify ( request )  . getTransportUrl (  )  ;", "verify ( request )  . getHandshakeHeaders (  )  ;", "verify ( request )  . getHttpRequestHeaders (  )  ;", "verifyNoMoreInteractions ( request )  ;", "assertEquals (  1  ,    transport . actualHandshakeHeaders . size (  )  )  ;", "assertEquals (  \" foo \"  ,    transport . actualHandshakeHeaders . getOrigin (  )  )  ;", "assertFalse ( transport . actualSession . isDisconnected (  )  )  ;", "captor . getValue (  )  . run (  )  ;", "assertTrue ( transport . actualSession . isDisconnected (  )  )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.web.socket.sockjs.client.XhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "XhrTransportTests . TestXhrTransport   transport    =    new   XhrTransportTests . TestXhrTransport (  )  ;", "transport . infoResponseToReturn    =    new   http . ResponseEntity (  \" body \"  ,    HttpStatus . OK )  ;", "assertEquals (  \" body \"  ,    transport . executeInfoRequest ( new   URI (  \" http :  /  / example . com / info \"  )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["infoResponse"], "fileName": "org.springframework.web.socket.sockjs.client.XhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "XhrTransportTests . TestXhrTransport   transport    =    new   XhrTransportTests . TestXhrTransport (  )  ;", "transport . infoResponseToReturn    =    new   http . ResponseEntity (  \" body \"  ,    HttpStatus . BAD _ REQUEST )  ;", "assertEquals (  \" body \"  ,    transport . executeInfoRequest ( new   URI (  \" http :  /  / example . com / info \"  )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["infoResponseError"], "fileName": "org.springframework.web.socket.sockjs.client.XhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "HttpHeaders   requestHeaders    =    new   HttpHeaders (  )  ;", "requestHeaders . set (  \" foo \"  ,     \" bar \"  )  ;", "requestHeaders . setContentType ( APPLICATION _ JSON )  ;", "XhrTransportTests . TestXhrTransport   transport    =    new   XhrTransportTests . TestXhrTransport (  )  ;", "transport . sendMessageResponseToReturn    =    new   http . ResponseEntity ( HttpStatus . NO _ CONTENT )  ;", "URI   url    =    new   URI (  \" http :  /  / example . com \"  )  ;", "transport . executeSendRequest ( url ,    requestHeaders ,    new   TextMessage (  \" payload \"  )  )  ;", "assertEquals (  2  ,    transport . actualSendRequestHeaders . size (  )  )  ;", "assertEquals (  \" bar \"  ,    transport . actualSendRequestHeaders . getFirst (  \" foo \"  )  )  ;", "assertEquals ( APPLICATION _ JSON ,    transport . actualSendRequestHeaders . getContentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendMessage"], "fileName": "org.springframework.web.socket.sockjs.client.XhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "XhrTransportTests . TestXhrTransport   transport    =    new   XhrTransportTests . TestXhrTransport (  )  ;", "transport . sendMessageResponseToReturn    =    new   http . ResponseEntity ( HttpStatus . BAD _ REQUEST )  ;", "URI   url    =    new   URI (  \" http :  /  / example . com \"  )  ;", "transport . executeSendRequest ( url ,    new   HttpHeaders (  )  ,    new   TextMessage (  \" payload \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sendMessageError"], "fileName": "org.springframework.web.socket.sockjs.client.XhrTransportTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "for    ( char   c    :    characters )     {", "if    ( isSpecialChar ( c )  )     {", "result . append (  '  \\  \\  '  )  . append (  ' u '  )  ;", "String   hex    =    Integer . toHexString ( c )  . toLowerCase (  )  ;", "for    ( int   i    =     0  ;    i    <     (  4     -     ( hex . length (  )  )  )  ;    i +  +  )     {", "result . append (  '  0  '  )  ;", "}", "result . append ( hex )  ;", "} else    {", "result . append ( c )  ;", "}", "}", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["escapeSockJsSpecialChars"], "fileName": "org.springframework.web.socket.sockjs.frame.AbstractSockJsMessageCodec"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( ch    <  =     '  \\ u 0  0  1 f '  )     |  |     (  ( ch    >  =     '  \\ u 2  0  0 c '  )     &  &     ( ch    <  =     '  \\ u 2  0  0 f '  )  )  )     |  |     (  ( ch    >  =     '  \\ u 2  0  2  8  '  )     &  &     ( ch    <  =     '  \\ u 2  0  2 f '  )  )  )     |  |     (  ( ch    >  =     '  \\ u 2  0  6  0  '  )     &  &     ( ch    <  =     '  \\ u 2  0  6 f '  )  )  )     |  |     ( ch    >  =     '  \\ ufff 0  '  )  )     |  |     (  ( ch    >  =     '  \\ ud 8  0  0  '  )     &  &     ( ch    <  =     '  \\ udfff '  )  )  ;", "}", "METHOD_END"], "methodName": ["isSockJsSpecialChar"], "fileName": "org.springframework.web.socket.sockjs.frame.AbstractSockJsMessageCodec"}, {"methodBody": ["METHOD_START", "{", "return   content ;", "}", "METHOD_END"], "methodName": ["preProcessContent"], "fileName": "org.springframework.web.socket.sockjs.frame.DefaultSockJsFrameFormat"}, {"methodBody": ["METHOD_START", "{", "return   new   SockJsFrame (  (  (  (  (  \" c [  \"     +    code )     +     \"  ,  \\  \"  \"  )     +     ( reason    !  =    null    ?    reason    :     \"  \"  )  )     +     \"  \\  \"  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["closeFrame"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "return   SockJsFrame . CLOSE _ ANOTHER _ CONNECTION _ OPEN _ FRAME ;", "}", "METHOD_END"], "methodName": ["closeFrameAnotherConnectionOpen"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "return   SockJsFrame . CLOSE _ GO _ AWAY _ FRAME ;", "}", "METHOD_END"], "methodName": ["closeFrameGoAway"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "return   this . content ;", "}", "METHOD_END"], "methodName": ["getContent"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "return   this . content . getBytes ( SockJsFrame . CHARSET )  ;", "}", "METHOD_END"], "methodName": ["getContentBytes"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( getType (  )  )     =  =     ( SockJsFrameType . OPEN )  )     |  |     (  ( getType (  )  )     =  =     ( SockJsFrameType . HEARTBEAT )  )  )     {", "return   null ;", "} else    {", "return   getContent (  )  . substring (  1  )  ;", "}", "}", "METHOD_END"], "methodName": ["getFrameData"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "return   SockJsFrame . HEARTBEAT _ FRAME ;", "}", "METHOD_END"], "methodName": ["heartbeatFrame"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "String   encoded    =    codec . encode ( messages )  ;", "return   new    ( encoded )  ;", "}", "METHOD_END"], "methodName": ["messageFrame"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "return   SockJsFrame . OPEN _ FRAME ;", "}", "METHOD_END"], "methodName": ["openFrame"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrame"}, {"methodBody": ["METHOD_START", "{", "SockJsFrame   frame    =    SockJsFrame . closeFrame (  3  0  0  0  ,     \" Go   Away !  \"  )  ;", "assertEquals (  \" c [  3  0  0  0  ,  \\  \" Go   Away !  \\  \"  ]  \"  ,    frame . getContent (  )  )  ;", "assertEquals ( ype . CLOSE ,    frame . getType (  )  )  ;", "assertEquals (  \"  [  3  0  0  0  ,  \\  \" Go   Away !  \\  \"  ]  \"  ,    frame . getFrameData (  )  )  ;", "}", "METHOD_END"], "methodName": ["closeFrame"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrameTests"}, {"methodBody": ["METHOD_START", "{", "SockJsFrame   frame    =    new   SockJsFrame (  \" c \"  )  ;", "assertEquals (  \" c [  ]  \"  ,    frame . getContent (  )  )  ;", "assertEquals ( ype . CLOSE ,    frame . getType (  )  )  ;", "assertEquals (  \"  [  ]  \"  ,    frame . getFrameData (  )  )  ;", "frame    =    new   SockJsFrame (  \" c [  ]  \"  )  ;", "assertEquals (  \" c [  ]  \"  ,    frame . getContent (  )  )  ;", "assertEquals ( ype . CLOSE ,    frame . getType (  )  )  ;", "assertEquals (  \"  [  ]  \"  ,    frame . getFrameData (  )  )  ;", "}", "METHOD_END"], "methodName": ["closeFrameEmpty"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrameTests"}, {"methodBody": ["METHOD_START", "{", "SockJsFrame   frame    =    SockJsFrame . heartbeatFrame (  )  ;", "assertEquals (  \" h \"  ,    frame . getContent (  )  )  ;", "assertEquals ( ype . HEARTBEAT ,    frame . getType (  )  )  ;", "assertNull ( frame . getFrameData (  )  )  ;", "}", "METHOD_END"], "methodName": ["heartbeatFrame"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrameTests"}, {"methodBody": ["METHOD_START", "{", "SockJsFrame   frame    =    SockJsFrame . messageFrame ( new   Jackson 2 SockJsMessageCodec (  )  ,     \" m 1  \"  ,     \" m 2  \"  )  ;", "assertEquals (  \" a [  \\  \" m 1  \\  \"  ,  \\  \" m 2  \\  \"  ]  \"  ,    frame . getContent (  )  )  ;", "assertEquals ( ype . MESSAGE ,    frame . getType (  )  )  ;", "assertEquals (  \"  [  \\  \" m 1  \\  \"  ,  \\  \" m 2  \\  \"  ]  \"  ,    frame . getFrameData (  )  )  ;", "}", "METHOD_END"], "methodName": ["messageArrayFrame"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrameTests"}, {"methodBody": ["METHOD_START", "{", "SockJsFrame   frame    =    new   SockJsFrame (  \" a \"  )  ;", "assertEquals (  \" a [  ]  \"  ,    frame . getContent (  )  )  ;", "assertEquals ( ype . MESSAGE ,    frame . getType (  )  )  ;", "assertEquals (  \"  [  ]  \"  ,    frame . getFrameData (  )  )  ;", "frame    =    new   SockJsFrame (  \" a [  ]  \"  )  ;", "assertEquals (  \" a [  ]  \"  ,    frame . getContent (  )  )  ;", "assertEquals ( ype . MESSAGE ,    frame . getType (  )  )  ;", "assertEquals (  \"  [  ]  \"  ,    frame . getFrameData (  )  )  ;", "}", "METHOD_END"], "methodName": ["messageArrayFrameEmpty"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrameTests"}, {"methodBody": ["METHOD_START", "{", "SockJsFrame   frame    =    SockJsFrame . openFrame (  )  ;", "assertEquals (  \" o \"  ,    frame . getContent (  )  )  ;", "assertEquals ( ype . OPEN ,    frame . getType (  )  )  ;", "assertNull ( frame . getFrameData (  )  )  ;", "}", "METHOD_END"], "methodName": ["openFrame"], "fileName": "org.springframework.web.socket.sockjs.frame.SockJsFrameTests"}, {"methodBody": ["METHOD_START", "{", "response . getHeaders (  )  . setCacheControl (  (  \" public ,    max - age =  \"     +     ( AbstractSockJsService . ONE _ YEAR )  )  )  ;", "response . getHeaders (  )  . setExpires (  (  ( new   Date (  )  . getTime (  )  )     +     (  ( AbstractSockJsService . ONE _ YEAR )     *     1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addCacheHeaders"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "response . getHeaders (  )  . setCacheControl (  \" no - store ,    no - cache ,    must - revalidate ,    max - age =  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["addNoCacheHeaders"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "if    ( WebUtils . isSameOrigin ( request )  )     {", "return   true ;", "}", "if    (  !  ( WebUtils . isValidOrigin ( request ,    this . allowedOrigins )  )  )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Origin   header   value    '  \"     +     ( request . getHeaders (  )  . getOrigin (  )  )  )     +     \"  '    not   allowed .  \"  )  )  ;", "}", "response . setStatusCode ( FORBIDDEN )  ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["checkOrigin"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . allowedOrigins )  ;", "}", "METHOD_END"], "methodName": ["getAllowedOrigins"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . disconnectDelay ;", "}", "METHOD_END"], "methodName": ["getDisconnectDelay"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . heartbeatTime ;", "}", "METHOD_END"], "methodName": ["getHeartbeatTime"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . httpMessageCacheSize ;", "}", "METHOD_END"], "methodName": ["getHttpMessageCacheSize"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . clientLibraryUrl ;", "}", "METHOD_END"], "methodName": ["getSockJsClientLibraryUrl"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . streamBytesLimit ;", "}", "METHOD_END"], "methodName": ["getStreamBytesLimit"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . taskScheduler ;", "}", "METHOD_END"], "methodName": ["getTaskScheduler"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionCookieNeeded ;", "}", "METHOD_END"], "methodName": ["isSessionCookieNeeded"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketEnabled ;", "}", "METHOD_END"], "methodName": ["isWebSocketEnabled"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "logger . warn (  \" Sending   Method   Not   Allowed    (  4  0  5  )  \"  )  ;", "response . setStatusCode ( METHOD _ NOT _ ALLOWED )  ;", "response . getHeaders (  )  . setAllow ( new   LinkedHashSet ( Arrays . asList ( httpMethods )  )  )  ;", "}", "METHOD_END"], "methodName": ["sendMethodNotAllowed"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( allowedOrigins ,     \" Allowed   origins   Collection   must   not   be   null \"  )  ;", "this . allowedOrigins . clear (  )  ;", "this . allowedOrigins . addAll ( allowedOrigins )  ;", "}", "METHOD_END"], "methodName": ["setAllowedOrigins"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . disconnectDelay    =    disconnectDelay ;", "}", "METHOD_END"], "methodName": ["setDisconnectDelay"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . heartbeatTime    =    heartbeatTime ;", "}", "METHOD_END"], "methodName": ["setHeartbeatTime"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . httpMessageCacheSize    =    httpMessageCacheSize ;", "}", "METHOD_END"], "methodName": ["setHttpMessageCacheSize"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . sessionCookieNeeded    =    sessionCookieNeeded ;", "}", "METHOD_END"], "methodName": ["setSessionCookieNeeded"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . clientLibraryUrl    =    clientLibraryUrl ;", "}", "METHOD_END"], "methodName": ["setSockJsClientLibraryUrl"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . streamBytesLimit    =    streamBytesLimit ;", "}", "METHOD_END"], "methodName": ["setStreamBytesLimit"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . suppressCors    =    suppressCors ;", "}", "METHOD_END"], "methodName": ["setSuppressCors"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . webSocketEnabled    =    webSocketEnabled ;", "}", "METHOD_END"], "methodName": ["setWebSocketEnabled"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . suppressCors ;", "}", "METHOD_END"], "methodName": ["shouldSuppressCors"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "String   path    =    request . getURI (  )  . getPath (  )  ;", "int   index    =     ( path . lastIndexOf (  '  /  '  )  )     +     1  ;", "String   filename    =    path . substring ( index )  ;", "return    ( filename . indexOf (  '  ;  '  )  )     =  =     (  -  1  )  ;", "}", "METHOD_END"], "methodName": ["validatePath"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( StringUtils . hasText ( serverId )  )  )     |  |     (  !  ( StringUtils . hasText ( sessionId )  )  )  )     |  |     (  !  ( StringUtils . hasText ( transport )  )  )  )     {", "logger . warn (  \" No   server ,    session ,    or   transport   path   segment   in   S   request .  \"  )  ;", "return   false ;", "}", "if    (  ( serverId . contains (  \"  .  \"  )  )     |  |     ( sessionId . contains (  \"  .  \"  )  )  )     {", "logger . warn (  \" Either   server   or   session   contains   a    \\  \"  .  \\  \"    which   is   not   allowed   by   S   protocol .  \"  )  ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["validateRequest"], "fileName": "org.springframework.web.socket.sockjs.support.AbstractSockJsService"}, {"methodBody": ["METHOD_START", "{", "String   attribute    =    HandlerMapping . PATH _ WITHIN _ HANDLER _ MAPPING _ ATTRIBUTE ;", "String   path    =     (  ( String )     ( servletRequest . getAttribute ( attribute )  )  )  ;", "return    (  ( path . length (  )  )     >     0  )     &  &     (  ( path . charAt (  0  )  )     !  =     '  /  '  )     ?     \"  /  \"     +    path    :    path ;", "}", "METHOD_END"], "methodName": ["getSockJsPath"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . sockJsService ;", "}", "METHOD_END"], "methodName": ["getSockJsService"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . webSocketHandler ;", "}", "METHOD_END"], "methodName": ["getWebSocketHandler"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setContentType (  \"  \"  )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "assertEquals (  \" Invalid / empty   content   should   have   been   ignored \"  ,     2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleEmptyContentType"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / iframe . html \"  ,    OK )  ;", "assertEquals (  \" text / html ; charset = UTF -  8  \"  ,    this . servletResponse . getContentType (  )  )  ;", "assertTrue ( this . servletResponse . getContentAsString (  )  . startsWith (  \"  <  ! DOCTYPE   html >  \\ n \"  )  )  ;", "assertEquals (  4  9  0  ,    this . servletResponse . getContentLength (  )  )  ;", "assertEquals (  \" no - store ,    no - cache ,    must - revalidate ,    max - age =  0  \"  ,    this . response . getHeaders (  )  . getCacheControl (  )  )  ;", "assertEquals (  \"  \\  \"  0  0  9  6 cbd 3  7 f 2 a 5  2  1  8 c 3  3 bb 0  8  2  6 a 7 c 7  4 cbf \\  \"  \"  ,    this . response . getHeaders (  )  . getETag (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleIframeRequest"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . addHeader (  \" If - None - Match \"  ,     \"  \\  \"  0  0  9  6 cbd 3  7 f 2 a 5  2  1  8 c 3  3 bb 0  8  2  6 a 7 c 7  4 cbf \\  \"  \"  )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / i . html \"  ,    NOT _ MODIFIED )  ;", "}", "METHOD_END"], "methodName": ["handleIframeRequestNotModified"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "assertEquals (  \" application / json ; charset = UTF -  8  \"  ,    this . servletResponse . getContentType (  )  )  ;", "String   header    =    this . servletResponse . getHeader ( CACHE _ CONTROL )  ;", "assertEquals (  \" no - store ,    no - cache ,    must - revalidate ,    max - age =  0  \"  ,    header )  ;", "assertNull ( this . servletResponse . getHeader ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertNull ( this . servletResponse . getHeader ( ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertNull ( this . servletResponse . getHeader ( VARY )  )  ;", "String   body    =    this . servletResponse . getContentAsString (  )  ;", "assertEquals (  \"  {  \\  \" entropy \\  \"  \"  ,    body . substring (  0  ,    body . indexOf (  '  :  '  )  )  )  ;", "assertEquals (  \"  ,  \\  \" origins \\  \"  :  [  \\  \"  *  :  *  \\  \"  ]  ,  \\  \" cookie _ needed \\  \"  : true ,  \\  \" web \\  \"  : true }  \"  ,    body . substring ( body . indexOf (  '  ,  '  )  )  )  ;", "this . service . setSessionCookieNeeded ( false )  ;", "this . service . setWebSocketEnabled ( false )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "body    =    this . servletResponse . getContentAsString (  )  ;", "assertEquals (  \"  ,  \\  \" origins \\  \"  :  [  \\  \"  *  :  *  \\  \"  ]  ,  \\  \" cookie _ needed \\  \"  : false ,  \\  \" web \\  \"  : false }  \"  ,    body . substring ( body . indexOf (  '  ,  '  )  )  )  ;", "this . service . setAllowedOrigins ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "assertNull ( this . servletResponse . getHeader ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertNull ( this . servletResponse . getHeader ( ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "assertNull ( this . servletResponse . getHeader ( VARY )  )  ;", "}", "METHOD_END"], "methodName": ["handleInfoGet"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "this . servletResponse . setHeader ( ACCESS _ CONTROL _ ALLOW _ ORIGIN ,     \" foobar :  1  2  3  \"  )  ;", "handleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "assertEquals (  \" foobar :  1  2  3  \"  ,    this . servletResponse . getHeader ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "}", "METHOD_END"], "methodName": ["handleInfoGetCorsFilter"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "HttpServletResponse   mockResponse    =    mock ( HttpServletResponse . class )  ;", "ServletOutputStream   ous    =    mock ( ServletOutputStream . class )  ;", "given ( mockResponse . getHeaders ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  . willThrow ( NullPointerException . class )  ;", "given ( mockResponse . getOutputStream (  )  )  . willReturn ( ous )  ;", "this . response    =    new   http . server . ServletServerHttpResponse ( mockResponse )  ;", "handleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "verify ( mockResponse ,    times (  1  )  )  . getOutputStream (  )  ;", "}", "METHOD_END"], "methodName": ["handleInfoGetWildflyNPE"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setServerName (  \" mydomain 2  . com \"  )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "assertEquals (  \" application / json ; charset = UTF -  8  \"  ,    this . servletResponse . getContentType (  )  )  ;", "String   header    =    this . servletResponse . getHeader ( CACHE _ CONTROL )  ;", "assertEquals (  \" no - store ,    no - cache ,    must - revalidate ,    max - age =  0  \"  ,    header )  ;", "String   body    =    this . servletResponse . getContentAsString (  )  ;", "assertEquals (  \"  {  \\  \" entropy \\  \"  \"  ,    body . substring (  0  ,    body . indexOf (  '  :  '  )  )  )  ;", "assertEquals (  \"  ,  \\  \" origins \\  \"  :  [  \\  \"  *  :  *  \\  \"  ]  ,  \\  \" cookie _ needed \\  \"  : true ,  \\  \" web \\  \"  : true }  \"  ,    body . substring ( body . indexOf (  '  ,  '  )  )  )  ;", "this . service . setAllowedOrigins ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "this . service . setAllowedOrigins ( Arrays . asList (  \" http :  /  / mydomain 1  . com \"  ,     \" http :  /  / mydomain 2  . com \"  ,     \" http :  /  / mydomain 3  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "this . service . setAllowedOrigins ( Collections . singletonList (  \"  *  \"  )  )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    OK )  ;", "this . servletRequest . setServerName (  \" mydomain 3  . com \"  )  ;", "this . service . setAllowedOrigins ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / info \"  ,    FORBIDDEN )  ;", "}", "METHOD_END"], "methodName": ["handleInfoGetWithOrigin"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . addHeader ( ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Last - Modified \"  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    NO _ CONTENT )  ;", "assertNull ( this . s . getCorsConfiguration ( this . servletRequest )  )  ;", "this . s . setAllowedOrigins ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    NO _ CONTENT )  ;", "assertNull ( this . s . getCorsConfiguration ( this . servletRequest )  )  ;", "}", "METHOD_END"], "methodName": ["handleInfoOptions"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setServerName (  \" mydomain 2  . com \"  )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "this . servletRequest . addHeader ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . servletRequest . addHeader ( ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Last - Modified \"  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    NO _ CONTENT )  ;", "assertNotNull ( this . s . getCorsConfiguration ( this . servletRequest )  )  ;", "this . s . setAllowedOrigins ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    NO _ CONTENT )  ;", "assertNotNull ( this . s . getCorsConfiguration ( this . servletRequest )  )  ;", "this . s . setAllowedOrigins ( Arrays . asList (  \" http :  /  / mydomain 1  . com \"  ,     \" http :  /  / mydomain 2  . com \"  ,     \" http :  /  / mydomain 3  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    NO _ CONTENT )  ;", "assertNotNull ( this . s . getCorsConfiguration ( this . servletRequest )  )  ;", "this . s . setAllowedOrigins ( Collections . singletonList (  \"  *  \"  )  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    NO _ CONTENT )  ;", "assertNotNull ( this . s . getCorsConfiguration ( this . servletRequest )  )  ;", "}", "METHOD_END"], "methodName": ["handleInfoOptionsWithAllowedOrigin"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setServerName (  \" mydomain 3  . com \"  )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "this . servletRequest . addHeader ( ACCESS _ CONTROL _ REQUEST _ METHOD ,     \" GET \"  )  ;", "this . servletRequest . addHeader ( ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Last - Modified \"  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    FORBIDDEN )  ;", "CorsConfiguration   corsConfiguration    =    this . s . getCorsConfiguration ( this . servletRequest )  ;", "assertTrue ( corsConfiguration . getAllowedOrigins (  )  . isEmpty (  )  )  ;", "this . s . setAllowedOrigins ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    FORBIDDEN )  ;", "corsConfiguration    =    this . s . getCorsConfiguration ( this . servletRequest )  ;", "assertEquals ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  ,    corsConfiguration . getAllowedOrigins (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleInfoOptionsWithForbiddenOrigin"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "this . s . setAllowedOrigins ( Collections . singletonList (  \"  *  \"  )  )  ;", "this . s . setSuppressCors ( true )  ;", "this . servletRequest . addHeader ( ACCESS _ CONTROL _ REQUEST _ HEADERS ,     \" Last - Modified \"  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    NO _ CONTENT )  ;", "assertNull ( this . s . getCorsConfiguration ( this . servletRequest )  )  ;", "this . s . setAllowedOrigins ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    FORBIDDEN )  ;", "assertNull ( this . s . getCorsConfiguration ( this . servletRequest )  )  ;", "this . s . setAllowedOrigins ( Arrays . asList (  \" http :  /  / mydomain 1  . com \"  ,     \" http :  /  / mydomain 2  . com \"  ,     \" http :  /  / mydomain 3  . com \"  )  )  ;", "resetResponseAndHandleRequest (  \" OPTIONS \"  ,     \"  / echo / info \"  ,    NO _ CONTENT )  ;", "assertNull ( this . s . getCorsConfiguration ( this . servletRequest )  )  ;", "}", "METHOD_END"], "methodName": ["handleInfoOptionsWithOriginAndCorsHeadersDisabled"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo \"  ,    OK )  ;", "assertEquals (  \" Welcome   to   SockJS !  \\ n \"  ,    this . servletResponse . getContentAsString (  )  )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / web \"  ,    OK )  ;", "assertNull (  \" Raw   WebSocket   should   not   open   a   SockJS   session \"  ,    this . service . sessionId )  ;", "assertSame ( this . handler ,    this . service . handler )  ;", "}", "METHOD_END"], "methodName": ["handleRawWebSocketRequest"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "setRequest ( httpMethod ,    uri )  ;", "String   sockJsPath    =    uri . substring (  \"  / echo \"  . length (  )  )  ;", "this . s . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . handler )  ;", "assertEquals ( httpStatus . value (  )  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleRequest"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "resetResponse (  )  ;", "handleRequ ( httpMethod ,    uri ,    httpStatus )  ;", "}", "METHOD_END"], "methodName": ["resetResponseAndHandleRequest"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "this . service . setWebSocketEnabled ( false )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / server / session / websocket \"  ,    NOT _ FOUND )  ;", "this . service . setWebSocketEnabled ( true )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / server / session / websocket \"  ,    OK )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo /  /  \"  ,    NOT _ FOUND )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo /  /  /  \"  ,    NOT _ FOUND )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / other \"  ,    NOT _ FOUND )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo /  / service / websocket \"  ,    NOT _ FOUND )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / server /  / websocket \"  ,    NOT _ FOUND )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / server / session /  \"  ,    NOT _ FOUND )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / s . erver / session / websocket \"  ,    NOT _ FOUND )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / server / s . ession / websocket \"  ,    NOT _ FOUND )  ;", "resetResponseAndHandleRequest (  \" GET \"  ,     \"  / echo / server / session / jsonp ; Setup . pl \"  ,    NOT _ FOUND )  ;", "}", "METHOD_END"], "methodName": ["validateRequest"], "fileName": "org.springframework.web.socket.sockjs.support.SockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "SockJsSession   session    =    this . sessions . get ( sessionId )  ;", "if    ( session    !  =    null )     {", "return   session ;", "}", "if    (  ( this . sessionCleanupTask )     =  =    null )     {", "scheduleSessionTask (  )  ;", "}", "session    =    sessionFactory . createSession ( sessionId ,    handler ,    attributes )  ;", "this . sessions . put ( sessionId ,    session )  ;", "return   session ;", "}", "METHOD_END"], "methodName": ["createSockJsSession"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   this . interceptors ;", "}", "METHOD_END"], "methodName": ["getHandshakeInterceptors"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . messageCodec )     !  =    null )  ,     (  \" A   SockJsMessageCodec   is   required   but   not   available :     \"     +     \" Add   Jackson   to   the   classpath ,    or   configure   a   custom   SockJsMessageCodec .  \"  )  )  ;", "return   this . messageCodec ;", "}", "METHOD_END"], "methodName": ["getMessageCodec"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . handlers )  ;", "}", "METHOD_END"], "methodName": ["getTransportHandlers"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . sessions )     {", "if    (  ( this . sessionCleanupTask )     !  =    null )     {", "return ;", "}", "this . sessionCleanupTask    =    getTaskScheduler (  )  . scheduleAtFixedRate (  (  )     -  >     {", "List < String >    removedIds    =    new   ArrayList <  >  (  )  ;", "for    ( ssion   session    :    sessions . values (  )  )     {", "try    {", "if    (  ( session . getTimeSinceLastActive (  )  )     >     ( getDisconnectDelay (  )  )  )     {", "sessions . remove ( session . getId (  )  )  ;", "removedIds . add ( session . getId (  )  )  ;", "session . close (  )  ;", "}", "}    catch    (    ex )     {", "logger . debug (  (  \" Failed   to   close    \"     +    session )  ,    ex )  ;", "}", "}", "if    (  ( logger . isDebugEnabled (  )  )     &  &     (  !  ( removedIds . isEmpty (  )  )  )  )     {", "logger . debug (  (  (  (  \" Closed    \"     +     ( removedIds . size (  )  )  )     +     \"    sessions :     \"  )     +    removedIds )  )  ;", "}", "}  ,    getDisconnectDelay (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["scheduleSessionTask"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . interceptors . clear (  )  ;", "if    ( interceptors    !  =    null )     {", "this . interceptors . addAll ( interceptors )  ;", "}", "}", "METHOD_END"], "methodName": ["setHandshakeInterceptors"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService"}, {"methodBody": ["METHOD_START", "{", "this . messageCodec    =    messageCodec ;", "}", "METHOD_END"], "methodName": ["setMessageCodec"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService"}, {"methodBody": ["METHOD_START", "{", "return   TransportType . TRANSPORT _ TYPES . get ( value )  ;", "}", "METHOD_END"], "methodName": ["fromValue"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportType"}, {"methodBody": ["METHOD_START", "{", "return   this . httpMethod ;", "}", "METHOD_END"], "methodName": ["getHttpMethod"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportType"}, {"methodBody": ["METHOD_START", "{", "return   this . headerHints . contains (  \" no _ cache \"  )  ;", "}", "METHOD_END"], "methodName": ["sendsNoCacheInstruction"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportType"}, {"methodBody": ["METHOD_START", "{", "return   this . headerHints . contains (  \" jsessionid \"  )  ;", "}", "METHOD_END"], "methodName": ["sendsSessionCookie"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportType"}, {"methodBody": ["METHOD_START", "{", "return   this . headerHints . contains (  \" cors \"  )  ;", "}", "METHOD_END"], "methodName": ["supportsCors"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportType"}, {"methodBody": ["METHOD_START", "{", "return    ( this . headerHints . contains (  \" cors \"  )  )     |  |     ( this . headerHints . contains (  \" origin \"  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsOrigin"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportType"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportType"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TransportType . WEBSOCKET ,    TransportType . fromValue (  \" websocket \"  )  )  ;", "assertEquals ( TransportType . XHR ,    TransportType . fromValue (  \" xhr \"  )  )  ;", "assertEquals ( TransportType . XHR _ SEND ,    TransportType . fromValue (  \" xhr _ send \"  )  )  ;", "assertEquals ( TransportType . JSONP ,    TransportType . fromValue (  \" jsonp \"  )  )  ;", "assertEquals ( TransportType . JSONP _ SEND ,    TransportType . fromValue (  \" jsonp _ send \"  )  )  ;", "assertEquals ( TransportType . XHR _ STREAMING ,    TransportType . fromValue (  \" xhr _ streaming \"  )  )  ;", "assertEquals ( TransportType . EVENT _ SOURCE ,    TransportType . fromValue (  \" eventsource \"  )  )  ;", "assertEquals ( TransportType . HTML _ FILE ,    TransportType . fromValue (  \" htmlfile \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFromValue"], "fileName": "org.springframework.web.socket.sockjs.transport.TransportTypeTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "rense . setStatusCode ( INTERNAL _ SERVER _ ERROR )  ;", "rense . getBody (  )  . write ( error . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   SockJsException (  (  \" Failed   to   send   error :     \"     +    error )  ,    sessionId ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["handleReadError"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.AbstractHttpReceivingTransportHandler"}, {"methodBody": ["METHOD_START", "{", "String [  ]    messages ;", "try    {", "messages    =    readMessages ( request )  ;", "}    catch    ( IOException   ex )     {", "logger . error (  \" Failed   to   read   message \"  ,    ex )  ;", "if    ( ex . getClass (  )  . getName (  )  . contains (  \" Mapping \"  )  )     {", "ReadError ( response ,     \" Payload   expected .  \"  ,    sockJsSession . getId (  )  )  ;", "} else    {", "ReadError ( response ,     \" Broken   JSON   encoding .  \"  ,    sockJsSession . getId (  )  )  ;", "}", "return ;", "}    catch    ( Throwable   ex )     {", "logger . error (  \" Failed   to   read   message \"  ,    ex )  ;", "ReadError ( response ,     \" Failed   to   read   message ( s )  \"  ,    sockJsSession . getId (  )  )  ;", "return ;", "}", "if    ( messages    =  =    null )     {", "ReadError ( response ,     \" Payload   expected .  \"  ,    sockJsSession . getId (  )  )  ;", "return ;", "}", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Received   message ( s )  :     \"     +     ( Arrays . asList ( messages )  )  )  )  ;", "}", "response . setStatusCode ( getResponseStatus (  )  )  ;", "response . getHeaders (  )  . setContentType ( new   MediaType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . UTF _  8  )  )  ;", "sockJsSession . delegateMessages ( messages )  ;", "}", "METHOD_END"], "methodName": ["handleRequestInternal"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.AbstractHttpReceivingTransportHandler"}, {"methodBody": ["METHOD_START", "{", "String   query    =    request . getURI (  )  . getQuery (  )  ;", "MultiValueMap < String ,    String >    params    =    newInstance (  )  . query ( query )  . build (  )  . getQueryParams (  )  ;", "String   value    =    params . getFirst (  \" c \"  )  ;", "if    ( StringUtils . isEmpty ( value )  )     {", "return   null ;", "}", "String   result    =    UriUtils . decode ( value ,    StandardCharsets . UTF _  8  )  ;", "return    . CALLBACK _ PARAM _ PATTERN . matcher ( result )  . matches (  )     ?    result    :    null ;", "}", "METHOD_END"], "methodName": ["getCallbackParam"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.AbstractHttpSendingTransportHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( sockJsSession . isNew (  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  ( request . getMethod (  )  )     +     \"     \"  )     +     ( request . getURI (  )  )  )  )  ;", "}", "sockJsSession . handleInitialRequest ( request ,    response ,    getFrameFormat ( request )  )  ;", "} else", "if    ( sockJsSession . isClosed (  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Connection   already   closed    ( but   not   removed   yet )    for    \"     +    sockJsSession )  )  ;", "}", "frame . SockJsFrame   frame    =    frame . SockJsFrame . closeFrameGoAway (  )  ;", "try    {", "response . getBody (  )  . write ( frame . getContentBytes (  )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   SockJsException (  (  \" Failed   to   send    \"     +    frame )  ,    sockJsSession . getId (  )  ,    ex )  ;", "}", "} else", "if    (  !  ( sockJsSession . isActive (  )  )  )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" Starting    \"     +     ( getTransportType (  )  )  )     +     \"    async   request .  \"  )  )  ;", "}", "sockJsSession . handleSuccessiveRequest ( request ,    response ,    getFrameFormat ( request )  )  ;", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Another    \"     +     ( getTransportType (  )  )  )     +     \"    connection   still   open   for    \"  )     +    sockJsSession )  )  ;", "}", "String   formattedFrame    =    getFrameFormat ( request )  . format ( frame . SockJsFrame . closeFrameAnotherConnectionOpen (  )  )  ;", "try    {", "response . getBody (  )  . write ( formattedFrame . getBytes ( frame . SockJsFrame . CHARSET )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   SockJsException (  (  \" Failed   to   send    \"     +    formattedFrame )  ,    sockJsSession . getId (  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleRequestInternal"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.AbstractHttpSendingTransportHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . serviceConfig )     !  =    null )  ,     \" No   SockJsServiceConfig   available \"  )  ;", "return   this . serviceConfig ;", "}", "METHOD_END"], "methodName": ["getServiceConfig"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.AbstractTransportHandler"}, {"methodBody": ["METHOD_START", "{", "Set < TransportHandler >    result    =    new   LinkedHashSet <  >  (  8  )  ;", "result . add ( new   XhrPollingTransportHandler (  )  )  ;", "result . add ( new   XhrReceivingTransportHandler (  )  )  ;", "result . add ( new   XhrStreamingTransportHandler (  )  )  ;", "result . add ( new   JsonpPollingTransportHandler (  )  )  ;", "result . add ( new   JsonpReceivingTransportHandler (  )  )  ;", "result . add ( new   EventSourceTransportHandler (  )  )  ;", "result . add ( new   HtmlFileTransportHandler (  )  )  ;", "try    {", "result . add ( new   WebSocketTransportHandler ( new   DefaultHandshakeHandler (  )  )  )  ;", "}    catch    ( Exception   ex )     {", "Log   logger    =    LogFactory . getLog (  . class )  ;", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  \" Failed   to   create   a   default   WebSocketTransportHandler \"  ,    ex )  ;", "}", "}", "if    ( overrides    !  =    null )     {", "result . addAll ( overrides )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDefaultTransportHandlers"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsService"}, {"methodBody": ["METHOD_START", "{", "TransportHandlingSockJsService   service    =    new   TransportHandlingSockJsService ( mock ( TaskScheduler . class )  ,    new   XhrPollingTransportHandler (  )  ,    new   XhrReceivingTransportHandler (  )  )  ;", "Map < TransportType ,    TransportHandler >    actualHandlers    =    service . getTransportHandlers (  )  ;", "assertEquals (  2  ,    actualHandlers . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["customizedTransportHandlerList"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultSockJsService   service    =    new   DefaultSockJsService ( mock ( TaskScheduler . class )  )  ;", "Map < TransportType ,    TransportHandler >    handlers    =    service . getTransportHandlers (  )  ;", "assertEquals (  8  ,    handlers . size (  )  )  ;", "assertNotNull ( handlers . get ( TransportType . WEBSOCKET )  )  ;", "assertNotNull ( handlers . get ( TransportType . XHR )  )  ;", "assertNotNull ( handlers . get ( TransportType . XHR _ SEND )  )  ;", "assertNotNull ( handlers . get ( TransportType . XHR _ STREAMING )  )  ;", "assertNotNull ( handlers . get ( TransportType . JSONP )  )  ;", "assertNotNull ( handlers . get ( TransportType . JSONP _ SEND )  )  ;", "assertNotNull ( handlers . get ( TransportType . HTML _ FILE )  )  ;", "assertNotNull ( handlers . get ( TransportType . EVENT _ SOURCE )  )  ;", "}", "METHOD_END"], "methodName": ["defaultTransportHandlers"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "XhrReceivingTransportHandler   xhrHandler    =    new   XhrReceivingTransportHandler (  )  ;", "service    =    new    ( mock ( TaskScheduler . class )  ,    xhrHandler )  ;", "Map < TransportType ,    TransportHandler >    handlers    =    service . getTransportHandlers (  )  ;", "assertEquals (  8  ,    handlers . size (  )  )  ;", "assertSame ( xhrHandler ,    handlers . get ( xhrHandler . getTransportType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultTransportHandlersWithOverride"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" invalid \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . setAllowedOrigins ( Arrays . asList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "this . servletRequest . setServerName (  \" mydomain 2  . com \"  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleInvalidTransportType"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     \"  / iframe . html \"  ;", "setRequest (  \" GET \"  ,     (  (  . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertNotEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "assertEquals (  \" SAMEORIGIN \"  ,    this . servletResponse . getHeader (  \" X - Frame - Options \"  )  )  ;", "resetRequestAndResponse (  )  ;", "setRequest (  \" GET \"  ,     (  (  . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . setAllowedOrigins ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "assertNull ( this . servletResponse . getHeader (  \" X - Frame - Options \"  )  )  ;", "resetRequestAndResponse (  )  ;", "setRequest (  \" GET \"  ,     (  (  . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . setAllowedOrigins ( Collections . singletonList (  \"  *  \"  )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertNotEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "assertNull ( this . servletResponse . getHeader (  \" X - Frame - Options \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestIframe"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "TransportHandlingSockJsService   jsonpService    =    new   TransportHandlingSockJsService ( this . taskScheduler ,    this . jsonpHandler ,    this . jsonpSendHandler )  ;", "String   sockJsPath    =     (  . sessionUrlPrefix )     +     \" jsonp \"  ;", "setRequest (  \" GET \"  ,     (  (  . sockJsPrefix )     +    sockJsPath )  )  ;", "jsonpService . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "resetRequestAndResponse (  )  ;", "jsonpService . setAllowedOrigins ( Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "setRequest (  \" GET \"  ,     (  (  . sockJsPrefix )     +    sockJsPath )  )  ;", "jsonpService . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "resetRequestAndResponse (  )  ;", "jsonpService . setAllowedOrigins ( Collections . singletonList (  \"  *  \"  )  )  ;", "setRequest (  \" GET \"  ,     (  (  . sockJsPrefix )     +    sockJsPath )  )  ;", "jsonpService . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertNotEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestJsonp"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" eventsource \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestNoSuitableHandler"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "TransportHandlingSockJsService   wsService    =    new   TransportHandlingSockJsService ( this . taskScheduler ,    this . wsTransportHandler )  ;", "String   sockJsPath    =     \"  / websocket \"  ;", "setRequest (  \" GET \"  ,     (  (  . sockJsPrefix )     +    sockJsPath )  )  ;", "wsService . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertNotEquals (  4  0  3  ,    this . servletResponse . getStatus (  )  )  ;", "resetRequestAndResponse (  )  ;", "List < String >    allowed    =    Collections . singletonList (  \" http :  /  / mydomain 1  . com \"  )  ;", "OriginHandshakeInterceptor   interceptor    =    new   OriginHandshakeInterceptor ( allowed )  ;", "wsService . setHandshakeInterceptors ( Collections . singletonList ( interceptor )  )  ;", "setRequest (  \" GET \"  ,     (  (  . sockJsPrefix )     +    sockJsPath )  )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 1  . com \"  )  ;", "wsService . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertNotEquals (  4  0  3  ,    this . servletResponse . getStatus (  )  )  ;", "resetRequestAndResponse (  )  ;", "setRequest (  \" GET \"  ,     (  (  . sockJsPrefix )     +    sockJsPath )  )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "wsService . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  4  0  3  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestWebsocket"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "verify ( this . xhrHandler )  . handleRequest ( this . request ,    this . response ,    this . wsHandler ,    this . session )  ;", "verify ( taskScheduler )  . scheduleAtFixedRate ( any ( Runnable . class )  ,    eq ( service . getDisconnectDelay (  )  )  )  ;", "assertEquals (  \" no - store ,    no - cache ,    must - revalidate ,    max - age =  0  \"  ,    this . response . getHeaders (  )  . getCacheControl (  )  )  ;", "assertNull ( this . servletResponse . getHeader ( ACCESS _ CONTROL _ ALLOW _ ORIGIN )  )  ;", "assertNull ( this . servletResponse . getHeader ( ACCESS _ CONTROL _ ALLOW _ CREDENTIALS )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestXhr"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . setAllowedOrigins ( Arrays . asList (  \" http :  /  / mydomain 1  . com \"  ,     \" http :  /  / mydomain 2  . com \"  )  )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 1  . com \"  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestXhrAllowedOriginsMatch"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . setAllowedOrigins ( Arrays . asList (  \" http :  /  / mydomain 1  . com \"  ,     \" http :  /  / mydomain 2  . com \"  )  )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 3  . com \"  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  4  0  3  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestXhrAllowedOriginsNoMatch"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr \"  ;", "setRequest (  \" OPTIONS \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  2  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "assertNull ( this . servletResponse . getHeader (  \" Access - Control - Allow - Origin \"  )  )  ;", "assertNull ( this . servletResponse . getHeader (  \" Access - Control - Allow - Credentials \"  )  )  ;", "assertNull ( this . servletResponse . getHeader (  \" Access - Control - Allow - Methods \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestXhrOptions"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . setAllowedOrigins ( Arrays . asList (  \" http :  /  / mydomain 1  . com \"  )  )  ;", "this . servletRequest . addHeader ( ORIGIN ,     \" http :  /  / mydomain 2  . com \"  )  ;", "this . servletRequest . setServerName (  \" mydomain 2  . com \"  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestXhrSameOrigin"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr _ send \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "resetResponse (  )  ;", "sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "verify ( this . xhrHandler )  . handleRequest ( this . request ,    this . response ,    this . wsHandler ,    this . session )  ;", "resetResponse (  )  ;", "sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr _ send \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "given ( this . xhrSendHandler . checkSessionType ( this . session )  )  . willReturn ( true )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "verify ( this . xhrSendHandler )  . handleRequest ( this . request ,    this . response ,    this . wsHandler ,    this . session )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestXhrSend"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "verify ( this . xhrHandler )  . handleRequest ( this . request ,    this . response ,    this . wsHandler ,    this . session )  ;", "this . session . setPrincipal ( new   TestPrincipal (  \" little   red   riding   hood \"  )  )  ;", "this . servletRequest . setUserPrincipal ( new   TestPrincipal (  \" wolf \"  )  )  ;", "resetResponse (  )  ;", "reset ( this . xhrSendHandler )  ;", "sockJsPath    =     ( DefaultSockJsServiceTests . sessionUrlPrefix )     +     \" xhr _ send \"  ;", "setRequest (  \" POST \"  ,     (  ( DefaultSockJsServiceTests . sockJsPrefix )     +    sockJsPath )  )  ;", "this . service . handleRequest ( this . request ,    this . response ,    sockJsPath ,    this . wsHandler )  ;", "assertEquals (  4  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "verifyNoMoreInteractions ( this . xhrSendHandler )  ;", "}", "METHOD_END"], "methodName": ["handleTransportRequestXhrSendWithDifferentUser"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "this . service . setAllowedOrigins ( null )  ;", "}", "METHOD_END"], "methodName": ["invalidAllowedOrigins"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "super . setup (  )  ;", "MockitoAnnotations . initMocks ( this )  ;", "Map < String ,    Object >    attributes    =    Collections . emptyMap (  )  ;", "this . session    =    new   TestSockJsSession (  . sessionId ,    new   StubSockJsServiceConfig (  )  ,    this . wsHandler ,    attributes )  ;", "given ( this . xhrHandler . getTransportType (  )  )  . willReturn ( TransportType . XHR )  ;", "given ( this . xhrHandler . createSession (  . sessionId ,    this . wsHandler ,    attributes )  )  . willReturn ( this . session )  ;", "given ( this . xhrSendHandler . getTransportType (  )  )  . willReturn ( TransportType . XHR _ SEND )  ;", "given ( this . jsonpHandler . getTransportType (  )  )  . willReturn ( TransportType . JSONP )  ;", "given ( this . jsonpHandler . createSession (  . sessionId ,    this . wsHandler ,    attributes )  )  . willReturn ( this . session )  ;", "given ( this . jsonpSendHandler . getTransportType (  )  )  . willReturn ( TransportType . JSONP _ SEND )  ;", "given ( this . wsTransportHandler . getTransportType (  )  )  . willReturn ( TransportType . WEBSOCKET )  ;", "this . service    =    new   TransportHandlingSockJsService ( this . taskScheduler ,    this . xhrHandler ,    this . xhrSendHandler )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsServiceTests"}, {"methodBody": ["METHOD_START", "{", "StubSockJsServiceConfig   sockJsConfig    =    new   StubSockJsServiceConfig (  )  ;", "this . servletRequest . setContent (  \"  [  \\  \" x \\  \"  ]  \"  . getBytes (  \" UTF -  8  \"  )  )  ;", "WebSocketHandler   wsHandler    =    mock ( WebSocketHandler . class )  ;", "TestHttpSockJsSession   session    =    new   TestHttpSockJsSession (  \"  1  \"  ,    sockJsConfig ,    wsHandler ,    null )  ;", "session . delegateConnectionEstablished (  )  ;", "willThrow ( new   Exception (  )  )  . given ( wsHandler )  . handleMessage ( session ,    new   TextMessage (  \" x \"  )  )  ;", "try    {", "Xhr   transportHandler    =    new   Xhr (  )  ;", "transportHandler . initialize ( sockJsConfig )  ;", "transportHandler . handleRequest ( this . request ,    this . response ,    wsHandler ,    session )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( SockJsMessageDeliveryException   ex )     {", "assertNull ( session . getCloseStatus (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["delegateMessageException"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpReceivingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   wsHandler    =    mock ( WebSocketHandler . class )  ;", "AbstractSockJsSession   session    =    new   TestHttpSockJsSession (  \"  1  \"  ,    new   StubSockJsServiceConfig (  )  ,    wsHandler ,    null )  ;", "t . initialize ( new   StubSockJsServiceConfig (  )  )  ;", "t . handleRequest ( this . request ,    this . response ,    wsHandler ,    session )  ;", "assertEquals (  \" text / plain ; charset = UTF -  8  \"  ,    this . response . getHeaders (  )  . getContentType (  )  . toString (  )  )  ;", "verify ( wsHandler )  . handleMessage ( session ,    new   TextMessage (  \" x \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleRequest"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpReceivingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "resetResponse (  )  ;", "WebSocketHandler   wsHandler    =    mock ( WebSocketHandler . class )  ;", "AbstractSockJsSession   session    =    new   TestHttpSockJsSession (  \"  1  \"  ,    new   StubSockJsServiceConfig (  )  ,    wsHandler ,    null )  ;", "new   Xhr (  )  . handleRequest ( this . request ,    this . response ,    wsHandler ,    session )  ;", "assertEquals (  5  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "verifyNoMoreInteractions ( wsHandler )  ;", "}", "METHOD_END"], "methodName": ["handleRequestAndExpectFailure"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpReceivingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setContent (  \"  \"  . getBytes (  \" UTF -  8  \"  )  )  ;", "RequestAndExpectFailure (  )  ;", "this . servletRequest . setContent (  \"  [  \\  \" x ]  \"  . getBytes (  \" UTF -  8  \"  )  )  ;", "RequestAndExpectFailure (  )  ;", "}", "METHOD_END"], "methodName": ["readMessagesBadContent"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpReceivingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setContent (  \"  [  \\  \" x \\  \"  ]  \"  . getBytes (  \" UTF -  8  \"  )  )  ;", "handleRequest ( new   Json (  )  )  ;", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "assertEquals (  \" ok \"  ,    this . servletResponse . getContentAsString (  )  )  ;", "}", "METHOD_END"], "methodName": ["readMessagesJsonp"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpReceivingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setContent (  \" d =  [  \\  \" x \\  \"  ]  \"  . getBytes (  \" UTF -  8  \"  )  )  ;", "this . servletRequest . setContentType ( APPLICATION _ FORM _ URLENCODED _ VALUE )  ;", "handleRequest ( new   Json (  )  )  ;", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "assertEquals (  \" ok \"  ,    this . servletResponse . getContentAsString (  )  )  ;", "}", "METHOD_END"], "methodName": ["readMessagesJsonpFormEncoded"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpReceivingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setContent (  \" d =  [  \\  \" x \\  \"  ]  \"  . getBytes (  \" UTF -  8  \"  )  )  ;", "this . servletRequest . setContentType (  \" application / x - www - form - urlencoded ; charset = UTF -  8  \"  )  ;", "handleRequest ( new   Json (  )  )  ;", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "assertEquals (  \" ok \"  ,    this . servletResponse . getContentAsString (  )  )  ;", "}", "METHOD_END"], "methodName": ["readMessagesJsonpFormEncodedWithEncoding"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpReceivingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   webSocketHandler    =    mock ( WebSocketHandler . class )  ;", "new   Xhr (  )  . handleRequest ( this . request ,    this . response ,    webSocketHandler ,    null )  ;", "}", "METHOD_END"], "methodName": ["readMessagesNoSession"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpReceivingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setContent (  \"  [  \\  \" x \\  \"  ]  \"  . getBytes (  \" UTF -  8  \"  )  )  ;", "handleRequest ( new   Xhr (  )  )  ;", "assertEquals (  2  0  4  ,    this . servletResponse . getStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["readMessagesXhr"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpReceivingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "EventSourceTransportHandler   transportHandler    =    new   EventSourceTransportHandler (  )  ;", "transportHandler . initialize ( this . sockJsConfig )  ;", "StreamingSockJsSession   session    =    transportHandler . createSession (  \"  1  \"  ,    this . webSocketHandler ,    null )  ;", "transportHandler . handleRequest ( this . request ,    this . response ,    this . webSocketHandler ,    session )  ;", "assertEquals (  \" text / event - stream ; charset = UTF -  8  \"  ,    this . response . getHeaders (  )  . getContentType (  )  . toString (  )  )  ;", "assertTrue (  \" Streaming   request   not   started \"  ,    this . servletRequest . isAsyncStarted (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( session )  ;", "}", "METHOD_END"], "methodName": ["eventSourceTransport"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpSendingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . servletRequest . setQueryString (  \" c = callback \"  )  ;", "this . servletRequest . addParameter (  \" c \"  ,     \" callback \"  )  ;", "SockJsFrame   frame    =    SockJsFrame . openFrame (  )  ;", "SockJsFrameFormat   format    =    new   XhrPoll (  )  . getFrameFormat ( this . request )  ;", "String   formatted    =    format . format ( frame )  ;", "assertEquals (  (  ( frame . getContent (  )  )     +     \"  \\ n \"  )  ,    formatted )  ;", "format    =    new   XhrStream (  )  . getFrameFormat ( this . request )  ;", "formatted    =    format . format ( frame )  ;", "assertEquals (  (  ( frame . getContent (  )  )     +     \"  \\ n \"  )  ,    formatted )  ;", "format    =    new   HtmlFileTransportHandler (  )  . getFrameFormat ( this . request )  ;", "formatted    =    format . format ( frame )  ;", "assertEquals (  (  (  \"  < script >  \\ np (  \\  \"  \"     +     ( frame . getContent (  )  )  )     +     \"  \\  \"  )  ;  \\ n <  / script >  \\ r \\ n \"  )  ,    formatted )  ;", "format    =    new   EventSourceTransportHandler (  )  . getFrameFormat ( this . request )  ;", "formatted    =    format . format ( frame )  ;", "assertEquals (  (  (  \" data :     \"     +     ( frame . getContent (  )  )  )     +     \"  \\ r \\ n \\ r \\ n \"  )  ,    formatted )  ;", "format    =    new   JsonpPoll (  )  . getFrameFormat ( this . request )  ;", "formatted    =    format . format ( frame )  ;", "assertEquals (  (  (  \"  /  *  *  / callback (  \\  \"  \"     +     ( frame . getContent (  )  )  )     +     \"  \\  \"  )  ;  \\ r \\ n \"  )  ,    formatted )  ;", "}", "METHOD_END"], "methodName": ["frameFormats"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpSendingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "XhrPollingTransportHandler   transportHandler    =    new   XhrPollingTransportHandler (  )  ;", "transportHandler . initialize ( this . sockJsConfig )  ;", "AbstractSockJsSession   session    =    transportHandler . createSession (  \"  1  \"  ,    this . webSocketHandler ,    null )  ;", "transportHandler . handleRequest ( this . request ,    this . response ,    this . webSocketHandler ,    session )  ;", "assertEquals (  \" application / javascript ; charset = UTF -  8  \"  ,    this . response . getHeaders (  )  . getContentType (  )  . toString (  )  )  ;", "assertEquals (  \" o \\ n \"  ,    this . servletResponse . getContentAsString (  )  )  ;", "assertFalse (  \" Polling   request   should   complete   after   open   frame \"  ,    this . servletRequest . isAsyncStarted (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( session )  ;", "resetRequestAndResponse (  )  ;", "transportHandler . handleRequest ( this . request ,    this . response ,    this . webSocketHandler ,    session )  ;", "assertTrue (  \" Polling   request   should   remain   open \"  ,    this . servletRequest . isAsyncStarted (  )  )  ;", "verify ( this . taskScheduler )  . schedule ( any ( Runnable . class )  ,    any ( Date . class )  )  ;", "resetRequestAndResponse (  )  ;", "transportHandler . handleRequest ( this . request ,    this . response ,    this . webSocketHandler ,    session )  ;", "assertFalse (  \" Request   should   have   been   rejected \"  ,    this . servletRequest . isAsyncStarted (  )  )  ;", "assertEquals (  \" c [  2  0  1  0  ,  \\  \" Another   connection   still   open \\  \"  ]  \\ n \"  ,    this . servletResponse . getContentAsString (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleRequestXhr"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpSendingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "XhrStreamingTransportHandler   transportHandler    =    new   XhrStreamingTransportHandler (  )  ;", "transportHandler . initialize ( this . sockJsConfig )  ;", "AbstractSockJsSession   session    =    transportHandler . createSession (  \"  1  \"  ,    this . webSocketHandler ,    null )  ;", "transportHandler . handleRequest ( this . request ,    this . response ,    this . webSocketHandler ,    session )  ;", "assertEquals (  \" application / javascript ; charset = UTF -  8  \"  ,    this . response . getHeaders (  )  . getContentType (  )  . toString (  )  )  ;", "assertTrue (  \" Streaming   request   not   started \"  ,    this . servletRequest . isAsyncStarted (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( session )  ;", "}", "METHOD_END"], "methodName": ["handleRequestXhrStreaming"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpSendingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "HtmlFileTransportHandler   transportHandler    =    new   HtmlFileTransportHandler (  )  ;", "transportHandler . initialize ( this . sockJsConfig )  ;", "StreamingSockJsSession   session    =    transportHandler . createSession (  \"  1  \"  ,    this . webSocketHandler ,    null )  ;", "transportHandler . handleRequest ( this . request ,    this . response ,    this . webSocketHandler ,    session )  ;", "assertEquals (  5  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "assertEquals (  \"  \\  \" callback \\  \"    parameter   required \"  ,    this . servletResponse . getContentAsString (  )  )  ;", "resetRequestAndResponse (  )  ;", "setRequest (  \" POST \"  ,     \"  /  \"  )  ;", "this . servletRequest . setQueryString (  \" c = callback \"  )  ;", "this . servletRequest . addParameter (  \" c \"  ,     \" callback \"  )  ;", "transportHandler . handleRequest ( this . request ,    this . response ,    this . webSocketHandler ,    session )  ;", "assertEquals (  \" text / html ; charset = UTF -  8  \"  ,    this . response . getHeaders (  )  . getContentType (  )  . toString (  )  )  ;", "assertTrue (  \" Streaming   request   not   started \"  ,    this . servletRequest . isAsyncStarted (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( session )  ;", "}", "METHOD_END"], "methodName": ["htmlFileTransport"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpSendingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "testJsonpTransport ( null ,    false )  ;", "testJsonpTransport (  \"  _ jp 1  2  3 xYz \"  ,    true )  ;", "testJsonpTransport (  \" A .  . B _  _  3  .  .  4  \"  ,    true )  ;", "testJsonpTransport (  \"  ! jp ! abc \"  ,    false )  ;", "testJsonpTransport (  \"  < script >  \"  ,    false )  ;", "testJsonpTransport (  \"  0  1  2  3  4  5  6  7  8  9 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ _  .  \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["jsonpTransport"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpSendingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "JsonpPollingTransportHandler   transportHandler    =    new   JsonpPollingTransportHandler (  )  ;", "transportHandler . initialize ( this . sockJsConfig )  ;", "PollingSockJsSession   session    =    transportHandler . createSession (  \"  1  \"  ,    this . webSocketHandler ,    null )  ;", "resetRequestAndResponse (  )  ;", "setRequest (  \" POST \"  ,     \"  /  \"  )  ;", "if    ( callbackValue    !  =    null )     {", "this . servletRequest . setQueryString (  (  \" c =  \"     +     ( UriUtils . encodeQueryParam ( callbackValue ,     \" UTF -  8  \"  )  )  )  )  ;", "this . servletRequest . addParameter (  \" c \"  ,    callbackValue )  ;", "}", "try    {", "transportHandler . handleRequest ( this . request ,    this . response ,    this . webSocketHandler ,    session )  ;", "}    catch    ( SockJsTransportFailureException   ex )     {", "if    ( expectSuccess )     {", "throw   new   AssertionError (  \" Unexpected   transport   failure \"  ,    ex )  ;", "}", "}", "if    ( expectSuccess )     {", "assertEquals (  2  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "assertEquals (  \" application / javascript ; charset = UTF -  8  \"  ,    this . response . getHeaders (  )  . getContentType (  )  . toString (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( session )  ;", "} else    {", "assertEquals (  5  0  0  ,    this . servletResponse . getStatus (  )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["testJsonpTransport"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.HttpSendingTransportHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . sockJsServiceConfig ;", "}", "METHOD_END"], "methodName": ["getSockJsConfig"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler"}, {"methodBody": ["METHOD_START", "{", "SubscribableChannel   channel    =    mock ( SubscribableChannel . class )  ;", "SubProtocolWebSocketHandler   handler    =    new   SubProtocolWebSocketHandler ( channel ,    channel )  ;", "StompSubProtocolHandler   stompHandler    =    new   StompSubProtocolHandler (  )  ;", "handler . addProtocolHandler ( stompHandler )  ;", "TaskScheduler   scheduler    =    mock ( TaskScheduler . class )  ;", "DefaultSockJsService   service    =    new   DefaultSockJsService ( scheduler )  ;", "WebSocketServerSockJsSession   session    =    new   WebSocketServerSockJsSession (  \"  1  \"  ,    service ,    handler ,    null )  ;", "sockJsHandler    =    new    ( service ,    handler ,    session )  ;", "assertEquals ( stompHandler . getSupportedProtocols (  )  ,    sockJsHandler . getSubProtocols (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSubProtocols"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   handler    =    new   TextWebSocketHandler (  )  ;", "TaskScheduler   scheduler    =    mock ( TaskScheduler . class )  ;", "DefaultSockJsService   service    =    new   DefaultSockJsService ( scheduler )  ;", "WebSocketServerSockJsSession   session    =    new   WebSocketServerSockJsSession (  \"  1  \"  ,    service ,    handler ,    null )  ;", "sockJsHandler    =    new    ( service ,    handler ,    session )  ;", "assertEquals ( Collections . emptyList (  )  ,    sockJsHandler . getSubProtocols (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSubProtocolsNone"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . handshakeHandler ;", "}", "METHOD_END"], "methodName": ["getHandshakeHandler"], "fileName": "org.springframework.web.socket.sockjs.transport.handler.WebSocketTransportHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( request   instanceof   ServletServerHttpRequest )     {", "ServletRequest   servletRequest    =     (  ( ServletServerHttpRequest )     ( request )  )  . getServletRequest (  )  ;", "ShallowEtagHeaderFilter . disableContentCaching ( servletRequest )  ;", "}", "}", "METHOD_END"], "methodName": ["disableShallowEtagHeaderFilter"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . acceptedProtocol ;", "}", "METHOD_END"], "methodName": ["getAcceptedProtocol"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . messageCache ;", "}", "METHOD_END"], "methodName": ["getMessageCache"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . uri    =    request . getURI (  )  ;", "this . handshakeHeaders    =    request . getHeaders (  )  ;", "this . principal    =    request . getPrincipal (  )  ;", "try    {", "this . localAddress    =    request . getLocalAddress (  )  ;", "}    catch    ( Exception   ex )     {", "}", "try    {", "this . remoteAddress    =    request . getRemoteAddress (  )  ;", "}    catch    ( Exception   ex )     {", "}", "synchronized ( this . responseLock )     {", "try    {", "this . response    =    response ;", "this . frameFormat    =    frameFormat ;", "ServerHttpAsyncRequestControl   control    =    request . getAsyncRequestControl ( response )  ;", "this . asyncRequestControl    =    control ;", "control . start (  (  -  1  )  )  ;", "disableShallowEtagHeaderFilter ( request )  ;", "delegateConnectionEstablished (  )  ;", "handleRequestInternal ( request ,    response ,    true )  ;", "this . readyToSend    =    isActive (  )  ;", "}    catch    ( Throwable   ex )     {", "tryCloseWithSockJsTError ( ex ,    CloseStatus . SERVER _ ERROR )  ;", "throw   new   SockJsTFailureException (  \" Failed   to   open   session \"  ,    getId (  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleInitialRequest"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . responseLock )     {", "try    {", "if    ( isClosed (  )  )     {", "response . getBody (  )  . write ( SockJsFrame . closeFrameGoAway (  )  . getContentBytes (  )  )  ;", "return ;", "}", "this . response    =    response ;", "this . frameFormat    =    frameFormat ;", "ServerHttpAsyncRequestControl   control    =    request . getAsyncRequestControl ( response )  ;", "this . asyncRequestControl    =    control ;", "control . start (  (  -  1  )  )  ;", "disableShallowEtagHeaderFilter ( request )  ;", "handleRequestInternal ( request ,    response ,    false )  ;", "this . readyToSend    =    isActive (  )  ;", "}    catch    ( Throwable   ex )     {", "tryCloseWithSockJsTError ( ex ,    CloseStatus . SERVER _ ERROR )  ;", "throw   new   SockJsTFailureException (  \" Failed   to   handle   SockJS   receive   request \"  ,    getId (  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleSuccessiveRequest"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . responseLock )     {", "ServerAsyncRequestControl   control    =    this . asyncRequestControl ;", "this . asyncRequestControl    =    null ;", "this . readyToSend    =    false ;", "this . response    =    null ;", "updateLastActiveTime (  )  ;", "if    (  (  ( control    !  =    null )     &  &     (  !  ( control . isCompleted (  )  )  )  )     &  &     ( control . isStarted (  )  )  )     {", "try    {", "control . complete (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . debug (  (  \" Failed   to   complete   request :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["resetRequest"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . acceptedProtocol    =    protocol ;", "}", "METHOD_END"], "methodName": ["setAcceptedProtocol"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . responseLock )     {", "if    (  ( this . heartbeatFuture )     !  =    null )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Cancelling   heartbeat   in       \"     +     ( getId (  )  )  )  )  ;", "}", "this . heartbeatFuture . cancel ( false )  ;", "this . heartbeatFuture    =    null ;", "}", "if    (  ( this . heartbeatTask )     !  =    null )     {", "this . heartbeatTask . cancel (  )  ;", "this . heartbeatTask    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["cancelHeartbeat"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isClosed (  )  )  )     {", "try    {", "updateLastActiveTime (  )  ;", "ScheduledFuture <  ?  >    future    =    this . heartbeatFuture ;", "if    ( future    !  =    null )     {", "this . heartbeatFuture    =    null ;", "future . cancel ( false )  ;", "}", "}    finally    {", "this . state    =     . State . CLOSED ;", "this . handler . afterConnectionClosed ( this ,    status )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["delegateConnectionClosed"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . state    =    AbstractSockJsSession . State . OPEN ;", "this . handler . afterConnectionEstablished ( this )  ;", "}", "METHOD_END"], "methodName": ["delegateConnectionEstablished"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . handler . handleTransportError ( this ,    ex )  ;", "}", "METHOD_END"], "methodName": ["delegateError"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "List < String >    undelivered    =    new   ArrayList <  >  ( Arrays . asList ( messages )  )  ;", "for    ( String   message    :    messages )     {", "try    {", "if    ( isClosed (  )  )     {", "throw   new   SockJsMessageDeliveryException ( this . id ,    undelivered ,     \"    closed \"  )  ;", "} else    {", "this . handler . handleMessage ( this ,    new   TextMessage ( message )  )  ;", "undelivered . remove (  0  )  ;", "}", "}    catch    ( Throwable   ex )     {", "throw   new   SockJsMessageDeliveryException ( this . id ,    undelivered ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["delegateMessages"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . config . getMessageCodec (  )  ;", "}", "METHOD_END"], "methodName": ["getMessageCodec"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . config ;", "}", "METHOD_END"], "methodName": ["getSockJsServiceConfig"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "String   message    =    NestedExceptionUtils . getMostSpecificCause ( ex )  . getMessage (  )  ;", "message    =     ( message    !  =    null )     ?    message . toLowerCase (  )     :     \"  \"  ;", "String   className    =    ex . getClass (  )  . getSimpleName (  )  ;", "return    ( message . contains (  \" broken   pipe \"  )  )     |  |     (  . DISCONNECTED _ CLIENT _ EXCEPTIONS . contains ( className )  )  ;", "}", "METHOD_END"], "methodName": ["indicatesDisconnectedClient"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   AbstractSockJsSession . State . CLOSED . equals ( this . state )  ;", "}", "METHOD_END"], "methodName": ["isClosed"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   AbstractSockJsSession . State . NEW . equals ( this . state )  ;", "}", "METHOD_END"], "methodName": ["isNew"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "if    ( indicatesDisconnectedClient ( ex )  )     {", "if    (  . disconnectedClientLogger . isTraceEnabled (  )  )     {", ". disconnectedClientLogger . trace (  \" Looks   like   the   client   has   gone   away \"  ,    ex )  ;", "} else", "if    (  . disconnectedClientLogger . isDebugEnabled (  )  )     {", ". disconnectedClientLogger . debug (  (  (  (  (  \" Looks   like   the   client   has   gone   away :     \"     +    ex )     +     \"     ( For   a   full   stack   trace ,    set   the   log   category    '  \"  )     +     (  . DISCONNECTED _ CLIENT _ LOG _ CATEGORY )  )     +     \"  '    to   TRACE   level .  )  \"  )  )  ;", "}", "} else    {", "logger . debug (  \" Terminating   connection   after   failure   to   send   message   to   client \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["logWriteFrameFailure"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "if    ( this . heartbeatDisabled )     {", "return ;", "}", "synchronized ( this . responseLock )     {", "cancelHeartbeat (  )  ;", "if    (  !  ( isActive (  )  )  )     {", "return ;", "}", "Date   time    =    new   Date (  (  ( System . currentTimeMillis (  )  )     +     ( this . config . getHeartbeatTime (  )  )  )  )  ;", "this . heartbeatTask    =    new    . HeartbeatTask (  )  ;", "this . heartbeatFuture    =    this . config . getTaskScheduler (  )  . schedule ( this . heartbeatTask ,    time )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Scheduled   heartbeat   in   session    \"     +     ( getId (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["scheduleHeartbeat"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . responseLock )     {", "if    (  ( isActive (  )  )     &  &     (  !  ( this . heartbeatDisabled )  )  )     {", "writeFrame ( Frame . heartbeatFrame (  )  )  ;", "scheduleHeartbeat (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["sendHeartbeat"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  !  ( isClosed (  )  )  )  ,     \" Cannot   send   a   message   when   session   is   closed \"  )  ;", "Assert . isInstanceOf ( TextMessage . class ,    message ,     \" SockJS   supports   text   messages   only \"  )  ;", "sendMessageInternal (  (  ( TextMessage )     ( message )  )  . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendMessage"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Closing   due   to      error   for    \"     +     ( this )  )  )  ;", "}", "try    {", "delegateError ( error )  ;", "}    catch    ( Throwable   delegateException )     {", "logger . debug (  \" Exception   from   error   handling   delegate \"  ,    delegateException )  ;", "}", "try    {", "close ( closeStatus )  ;", "}    catch    ( Throwable   closeException )     {", "logger . debug (  (  \" Failure   while   closing    \"     +     ( this )  )  ,    closeException )  ;", "}", "}", "METHOD_END"], "methodName": ["tryCloseWithSockJsTransportError"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . timeLastActive    =    System . currentTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["updateLastActiveTime"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Preparing   to   write    \"     +    frame )  )  ;", "}", "try    {", "writeFrameInternal ( frame )  ;", "}    catch    ( Throwable   ex )     {", "logWriteFrameFailure ( ex )  ;", "try    {", "disconnect ( CloseStatus . SERVER _ ERROR )  ;", "}    catch    ( Throwable   disconnectFailure )     {", "}", "try    {", "close ( CloseStatus . SERVER _ ERROR )  ;", "}    catch    ( Throwable   closeFailure )     {", "}", "throw   new   SockJsTFailureException (  (  \" Failed   to   write    \"     +    frame )  ,    getId (  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["writeFrame"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession"}, {"methodBody": ["METHOD_START", "{", "assertState ( false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["assertClosed"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "assertState ( true ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["assertNew"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "assertState ( false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["assertOpen"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "AbstractSockJsSessionTests . assertEquals ( isNew ,    this . session . isNew (  )  )  ;", "AbstractSockJsSessionTests . assertEquals ( isOpen ,    this . session . isOpen (  )  )  ;", "AbstractSockJsSessionTests . assertEquals ( isClosed ,    this . session . isClosed (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertState"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . webSocketHandler    =    AbstractSockJsSessionTests . mock ( WebSocketHandler . class )  ;", "this . taskScheduler    =    AbstractSockJsSessionTests . mock ( TaskScheduler . class )  ;", "this . sockJsConfig    =    new   StubSockJsServiceConfig (  )  ;", "this . sockJsConfig . setTaskScheduler ( this . taskScheduler )  ;", "this . session    =    initSockJsSession (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleInitialRequest ( this . request ,    this . response ,    this . frameFormat )  ;", "assertEquals (  \" hhh \\ no \"  ,    this . servletResponse . getContentAsString (  )  )  ;", "assertTrue ( this . servletRequest . isAsyncStarted (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( this . session )  ;", "}", "METHOD_END"], "methodName": ["handleInitialRequest"], "fileName": "org.springframework.web.socket.sockjs.transport.session.HttpSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . getMessageCache (  )  . add (  \" x \"  )  ;", "this . session . handleSuccessiveRequest ( this . request ,    this . response ,    this . frameFormat )  ;", "assertTrue ( this . servletRequest . isAsyncStarted (  )  )  ;", "assertTrue ( this . session . wasHeartbeatScheduled (  )  )  ;", "assertTrue ( this . session . wasCacheFlushed (  )  )  ;", "assertEquals (  \" hhh \\ n \"  ,    this . servletResponse . getContentAsString (  )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["handleSuccessiveRequest"], "fileName": "org.springframework.web.socket.sockjs.transport.session.HttpSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "super . setUp (  )  ;", "this . frameFormat    =    new   DefaultSockJsFrameFormat (  \"  % s \"  )  ;", "this . servletResponse    =    new   MockHttpServletResponse (  )  ;", "this . response    =    new   http . server . ServletServerHttpResponse ( this . servletResponse )  ;", "this . servletRequest    =    new   MockHttpServletRequest (  )  ;", "this . servletRequest . setAsyncSupported ( true )  ;", "this . request    =    new   http . server . ServletServerHttpRequest ( this . servletRequest )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.sockjs.transport.session.HttpSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . delegateConnectionEstablished (  )  ;", "assertOpen (  )  ;", "this . session . setActive ( true )  ;", "this . session . close (  )  ;", "assertEquals (  1  ,    this . session . getSockJsFramesWritten (  )  . size (  )  )  ;", "assertEquals ( SockJsFrame . closeFrameGoAway (  )  ,    this . session . getSockJsFramesWritten (  )  . get (  0  )  )  ;", "assertEquals (  1  ,    this . session . getNumberOfLastActiveTimeUpdates (  )  )  ;", "assertTrue ( this . session . didCancelHeartbeat (  )  )  ;", "assertEquals ( new   CloseStatus (  3  0  0  0  ,     \" Go   away !  \"  )  ,    this . session . getCloseStatus (  )  )  ;", "assertClosed (  )  ;", "verify ( this . webSocketHandler )  . afterConnectionClosed ( this . session ,    new   CloseStatus (  3  0  0  0  ,     \" Go   away !  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . delegateConnectionEstablished (  )  ;", "assertOpen (  )  ;", "this . session . setActive ( false )  ;", "this . session . close (  )  ;", "assertEquals ( Collections . emptyList (  )  ,    this . session . getSockJsFramesWritten (  )  )  ;", "}", "METHOD_END"], "methodName": ["closeWhenNotActive"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "assertNew (  )  ;", "thisclose (  )  ;", "assertNull (  \" Close   not   ignored   for   a   new ,    thisgetCloseStatus (  )  )  ;", "thisdelegateConnectionEstablished (  )  ;", "assertOpen (  )  ;", "thisclose (  )  ;", "assertClosed (  )  ;", "assertEquals (  3  0  0  0  ,    thisgetCloseStatus (  )  . getCode (  )  )  ;", "thisclose ( CloseStatus . SERVER _ ERROR )  ;", "assertEquals (  \" Close   should   be   ignored   if   already   closed \"  ,     3  0  0  0  ,    thisgetCloseStatus (  )  . getCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["closeWhenNotOpen"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "willThrow ( new   Exception (  )  )  . given ( this . webSocketHandler )  . afterConnectionClosed ( this   CloseStatus . NORMAL )  ;", "thisdelegateConnectionEstablished (  )  ;", "thissetActive ( true )  ;", "thisclose ( CloseStatus . NORMAL )  ;", "assertEquals ( CloseStatus . NORMAL ,    thisgetCloseStatus (  )  )  ;", "assertClosed (  )  ;", "}", "METHOD_END"], "methodName": ["closeWithWebSocketHandlerExceptions"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . setExceptionOnWrite ( new   IOException (  )  )  ;", "this . session . delegateConnectionEstablished (  )  ;", "this . session . setActive ( true )  ;", "this . session . close (  )  ;", "assertEquals ( new   CloseStatus (  3  0  0  0  ,     \" Go   away !  \"  )  ,    this . session . getCloseStatus (  )  )  ;", "assertClosed (  )  ;", "}", "METHOD_END"], "methodName": ["closeWithWriteFrameExceptions"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . delegateConnectionEstablished (  )  ;", "this . session . delegateConnectionClosed ( CloseStatus . GOING _ AWAY )  ;", "assertClosed (  )  ;", "assertEquals (  1  ,    this . session . getNumberOfLastActiveTimeUpdates (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionClosed ( this . session ,    CloseStatus . GOING _ AWAY )  ;", "}", "METHOD_END"], "methodName": ["delegateConnectionClosed"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "assertNew (  )  ;", "thisdelegateConnectionEstablished (  )  ;", "assertOpen (  )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( this ;", "}", "METHOD_END"], "methodName": ["delegateConnectionEstablished"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "Exception   ex    =    new   Exception (  )  ;", "thisdelegateError ( ex )  ;", "verify ( this . webSocketHandler )  . handleTransportError ( this   ex )  ;", "}", "METHOD_END"], "methodName": ["delegateError"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "String   msg 1     =     \" message    1  \"  ;", "String   msg 2     =     \" message    2  \"  ;", "thisdelegateMessages ( msg 1  ,    msg 2  )  ;", "verify ( this . webSocketHandler )  . handleMessage ( this   new   TextMessage ( msg 1  )  )  ;", "verify ( this . webSocketHandler )  . handleMessage ( this   new   TextMessage ( msg 2  )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["delegateMessages"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "WebSocketHandler   wsHandler    =    new   ExceptionWebSocketHandlerDecorator ( this . webSocketHandler )  ;", "Test   sockJsSession    =    new   Test (  \"  1  \"  ,    this . sockJsConfig ,    wsHandler ,    Collections .  < String ,    Object > emptyMap (  )  )  ;", "String   msg 1     =     \" message    1  \"  ;", "String   msg 2     =     \" message    2  \"  ;", "String   msg 3     =     \" message    3  \"  ;", "willThrow ( new   IOException (  )  )  . given ( this . webSocketHandler )  . handleMessage ( sockJsSession ,    new   TextMessage ( msg 2  )  )  ;", "sockJsSession . delegateConnectionEstablished (  )  ;", "try    {", "sockJsSession . delegateMessages ( msg 1  ,    msg 2  ,    msg 3  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( SockJsMessageDeliveryException   ex )     {", "assertEquals ( Collections . singletonList ( msg 3  )  ,    ex . getUndeliveredMessages (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( sockJsSession )  ;", "verify ( this . webSocketHandler )  . handleMessage ( sockJsSession ,    new   TextMessage ( msg 1  )  )  ;", "verify ( this . webSocketHandler )  . handleMessage ( sockJsSession ,    new   TextMessage ( msg 2  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionClosed ( sockJsSession ,    CloseStatus . SERVER _ ERROR )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["delegateMessagesWithErrorAndConnectionClosing"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "Thread . sleep (  1  )  ;", "long   time 1     =    thisgetTimeSinceLastActive (  )  ;", "assertTrue (  ( time 1     >     0  )  )  ;", "Thread . sleep (  1  )  ;", "long   time 2     =    thisgetTimeSinceLastActive (  )  ;", "assertTrue (  ( time 2     >    time 1  )  )  ;", "thisdelegateConnectionEstablished (  )  ;", "Thread . sleep (  1  )  ;", "thissetActive ( false )  ;", "assertTrue (  (  ( thisgetTimeSinceLastActive (  )  )     >     0  )  )  ;", "thissetActive ( true )  ;", "assertEquals (  0  ,    thisgetTimeSinceLastActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTimeSinceLastActive"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "ScheduledFuture <  ?  >    task    =    mock ( ScheduledFuture . class )  ;", "willReturn ( task )  . given ( this . taskScheduler )  . schedule ( any ( Runnable . class )  ,    any ( Date . class )  )  ;", "thissetActive ( true )  ;", "thisscheduleHeartbeat (  )  ;", "verify ( this . taskScheduler )  . schedule ( any ( Runnable . class )  ,    any ( Date . class )  )  ;", "verifyNoMoreInteractions ( this . taskScheduler )  ;", "given ( task . isCancelled (  )  )  . willReturn ( false )  ;", "given ( task . cancel ( false )  )  . willReturn ( true )  ;", "thiscancelHeartbeat (  )  ;", "verify ( task )  . cancel ( false )  ;", "verifyNoMoreInteractions ( task )  ;", "}", "METHOD_END"], "methodName": ["scheduleAndCancelHeartbeat"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . setActive ( false )  ;", "this . session . scheduleHeartbeat (  )  ;", "verifyNoMoreInteractions ( this . taskScheduler )  ;", "}", "METHOD_END"], "methodName": ["scheduleHeartbeatNotActive"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . setActive ( true )  ;", "this . session . sendHeartbeat (  )  ;", "assertEquals (  1  ,    this . session . getSockJsFramesWritten (  )  . size (  )  )  ;", "assertEquals ( SockJsFrame . heartbeatFrame (  )  ,    this . session . getSockJsFramesWritten (  )  . get (  0  )  )  ;", "verify ( this . taskScheduler )  . schedule ( any ( Runnable . class )  ,    any ( Date . class )  )  ;", "verifyNoMoreInteractions ( this . taskScheduler )  ;", "}", "METHOD_END"], "methodName": ["sendHeartbeat"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . disableHeartbeat (  )  ;", "this . session . setActive ( true )  ;", "this . session . sendHeartbeat (  )  ;", "assertEquals ( Collections . emptyList (  )  ,    this . session . getSockJsFramesWritten (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendHeartbeatWhenDisabled"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . delegateConnectionEstablished (  )  ;", "this . session . setActive ( true )  ;", "this . session . tryCloseWithSockJsTransportError ( new   Exception (  )  ,    CloseStatus . BAD _ DATA )  ;", "assertEquals ( CloseStatus . BAD _ DATA ,    this . session . getCloseStatus (  )  )  ;", "assertClosed (  )  ;", "}", "METHOD_END"], "methodName": ["tryCloseWithWebSocketHandlerExceptions"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . writeFrame ( SockJsFrame . openFrame (  )  )  ;", "assertEquals (  1  ,    this . session . getSockJsFramesWritten (  )  . size (  )  )  ;", "assertEquals ( SockJsFrame . openFrame (  )  ,    this . session . getSockJsFramesWritten (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["writeFrame"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . setExceptionOnWrite ( new   IOException (  )  )  ;", "this . session . delegateConnectionEstablished (  )  ;", "try    {", "this . session . writeFrame ( SockJsFrame . openFrame (  )  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( SockJsTransportFailureException   ex )     {", "assertEquals ( CloseStatus . SERVER _ ERROR ,    this . session . getCloseStatus (  )  )  ;", "verify ( this . webSocketHandler )  . afterConnectionClosed ( this . session ,    CloseStatus . SERVER _ ERROR )  ;", "}", "}", "METHOD_END"], "methodName": ["writeFrameIoException"], "fileName": "org.springframework.web.socket.sockjs.transport.session.SockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "return   this . httpMessageCacheSize ;", "}", "METHOD_END"], "methodName": ["getHttpMessageCacheSize"], "fileName": "org.springframework.web.socket.sockjs.transport.session.StubSockJsServiceConfig"}, {"methodBody": ["METHOD_START", "{", "this . heartbeatTime    =    heartbeatTime ;", "}", "METHOD_END"], "methodName": ["setHeartbeatTime"], "fileName": "org.springframework.web.socket.sockjs.transport.session.StubSockJsServiceConfig"}, {"methodBody": ["METHOD_START", "{", "this . httpMessageCacheSize    =    httpMessageCacheSize ;", "}", "METHOD_END"], "methodName": ["setHttpMessageCacheSize"], "fileName": "org.springframework.web.socket.sockjs.transport.session.StubSockJsServiceConfig"}, {"methodBody": ["METHOD_START", "{", "this . messageCodec    =    messageCodec ;", "}", "METHOD_END"], "methodName": ["setMessageCodec"], "fileName": "org.springframework.web.socket.sockjs.transport.session.StubSockJsServiceConfig"}, {"methodBody": ["METHOD_START", "{", "this . streamBytesLimit    =    streamBytesLimit ;", "}", "METHOD_END"], "methodName": ["setStreamBytesLimit"], "fileName": "org.springframework.web.socket.sockjs.transport.session.StubSockJsServiceConfig"}, {"methodBody": ["METHOD_START", "{", "this . taskScheduler    =    taskScheduler ;", "}", "METHOD_END"], "methodName": ["setTaskScheduler"], "fileName": "org.springframework.web.socket.sockjs.transport.session.StubSockJsServiceConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . cancelledHeartbeat ;", "}", "METHOD_END"], "methodName": ["didCancelHeartbeat"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . closeStatus ;", "}", "METHOD_END"], "methodName": ["getCloseStatus"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . numberOfLastActiveTimeUpdates ;", "}", "METHOD_END"], "methodName": ["getNumberOfLastActiveTimeUpdates"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . sockJsFrames ;", "}", "METHOD_END"], "methodName": ["getSockJsFramesWritten"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . active    =    active ;", "}", "METHOD_END"], "methodName": ["setActive"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . exceptionOnWrite    =    exceptionOnWrite ;", "}", "METHOD_END"], "methodName": ["setExceptionOnWrite"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestHttpSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . cancelledHeartbeat ;", "}", "METHOD_END"], "methodName": ["didCancelHeartbeat"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . closeStatus ;", "}", "METHOD_END"], "methodName": ["getCloseStatus"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . numberOfLastActiveTimeUpdates ;", "}", "METHOD_END"], "methodName": ["getNumberOfLastActiveTimeUpdates"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "return   this . sockJsFrames ;", "}", "METHOD_END"], "methodName": ["getSockJsFramesWritten"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . subProtocol    =    protocol ;", "}", "METHOD_END"], "methodName": ["setAcceptedProtocol"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . active    =    active ;", "}", "METHOD_END"], "methodName": ["setActive"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . exceptionOnWrite    =    exceptionOnWrite ;", "}", "METHOD_END"], "methodName": ["setExceptionOnWrite"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . extensions    =    extensions ;", "}", "METHOD_END"], "methodName": ["setExtensions"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . headers    =    headers ;", "}", "METHOD_END"], "methodName": ["setHeaders"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . localAddress    =    localAddress ;", "}", "METHOD_END"], "methodName": ["setLocalAddress"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . principal    =    principal ;", "}", "METHOD_END"], "methodName": ["setPrincipal"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . remoteAddress    =    remoteAddress ;", "}", "METHOD_END"], "methodName": ["setRemoteAddress"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . uri    =    uri ;", "}", "METHOD_END"], "methodName": ["setUri"], "fileName": "org.springframework.web.socket.sockjs.transport.session.TestSockJsSession"}, {"methodBody": ["METHOD_START", "{", "String   payload    =    message . getPayload (  )  ;", "if    ( StringUtils . isEmpty ( payload )  )     {", "return ;", "}", "String [  ]    messages ;", "try    {", "messages    =    getSockJsServiceConfig (  )  . getMessageCodec (  )  . decode ( payload )  ;", "}    catch    ( Throwable   ex )     {", "logger . error (  \" Broken   data   received .    Terminating      connection   abruptly \"  ,    ex )  ;", "tryCloseWithSockJsTransportError ( ex ,    CloseStatus . BAD _ DATA )  ;", "return ;", "}", "if    ( messages    !  =    null )     {", "delegateMessages ( messages )  ;", "}", "}", "METHOD_END"], "methodName": ["handleMessage"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . initSessionLock )     {", "this . wssion    =    session ;", "try    {", "delegateConnectionEstablished (  )  ;", "this . wssion . sendMessage ( new   TextMessage ( SockJsFrame . openFrame (  )  . getContent (  )  )  )  ;", "while    (  !  ( this . initSessionCache . isEmpty (  )  )  )     {", "writeFrame ( SockJsFrame . messageFrame ( getMessageCodec (  )  ,    this . initSessionCache . poll (  )  )  )  ;", "}", "scheduleHeartbeat (  )  ;", "this . openFrameSent    =    true ;", "}    catch    ( Throwable   ex )     {", "tryCloseWithSockJsTransportError ( ex ,    CloseStatus . SERVER _ ERROR )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initializeDelegateSession"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession"}, {"methodBody": ["METHOD_START", "{", "this . session . initializeDelegateSession ( this . webSocketSession )  ;", "assertEquals ( Collections . singletonList ( new   TextMessage (  \" o \"  )  )  ,    this . webSocketSession . getSentMessages (  )  )  ;", "assertEquals ( Arrays . asList (  \" schedule \"  )  ,    this . session . heartbeatSchedulingEvents )  ;", "verify ( this . webSocketHandler )  . afterConnectionEstablished ( this . session )  ;", "verifyNoMoreInteractions ( this . taskScheduler ,    this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["afterSessionInitialized"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "TextWebSocketHandler   handler    =    new   TextWebSocketHandler (  )     {", "@ Override", "public   void   afterConnectionEstablished ( WebSocketSession   session )    throws   Exception    {", "session . sendMessage ( new   TextMessage (  \" go   go \"  )  )  ;", "}", "}  ;", ". TestWebSocketServerSockJsSession   session    =    new    . TestWebSocketServerSockJsSession ( this . sockJsConfig ,    handler ,    null )  ;", "session . initializeDelegateSession ( this . webSocketSession )  ;", "List < TextMessage >    expected    =    Arrays . asList ( new   TextMessage (  \" o \"  )  ,    new   TextMessage (  \" a [  \\  \" go   go \\  \"  ]  \"  )  )  ;", "assertEquals ( expected ,    this . webSocketSession . getSentMessages (  )  )  ;", "}", "METHOD_END"], "methodName": ["afterSessionInitializedOpenFrameFirst"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . initializeDelegateSession ( this . webSocketSession )  ;", "this . session . close ( CloseStatus . NOT _ ACCEPTABLE )  ;", "assertEquals ( CloseStatus . NOT _ ACCEPTABLE ,    this . webSocketSession . getCloseStatus (  )  )  ;", "}", "METHOD_END"], "methodName": ["disconnect"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   message    =    new   TextMessage (  \"  [  \\  \" x \\  \"  ]  \"  )  ;", "this . session . handleMessage ( message ,    this . wssion )  ;", "verify ( this . webSocketHandler )  . handleMessage ( this . session ,    new   TextMessage (  \" x \"  )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["handleMessage"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   message    =    new   TextMessage (  \"  [  \\  \" x ]  \"  )  ;", "this . session . handleMessage ( message ,    this . wssion )  ;", "this . session . isClosed (  )  ;", "verify ( this . webSocketHandler )  . handleTransportError ( same ( this . session )  ,    any ( IOException . class )  )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["handleMessageBadData"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . handleMessage ( new   TextMessage (  \"  \"  )  ,    this . webSocketSession )  ;", "verifyNoMoreInteractions ( this . webSocketHandler )  ;", "}", "METHOD_END"], "methodName": ["handleMessageEmptyPayload"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . session . isActive (  )  )  ;", "this . session . initializeDelegateSession ( this . wssion )  ;", "assertTrue ( this . session . isActive (  )  )  ;", "this . wssion . setOpen ( false )  ;", "assertFalse ( this . session . isActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . initializeDelegateSession ( this . webSocketSession )  ;", "this . session . sendMessageInternal (  \" x \"  )  ;", "assertEquals ( Arrays . asList ( new   TextMessage (  \" o \"  )  ,    new   TextMessage (  \" a [  \\  \" x \\  \"  ]  \"  )  )  ,    this . webSocketSession . getSentMessages (  )  )  ;", "assertEquals ( Arrays . asList (  \" schedule \"  ,     \" cancel \"  ,     \" schedule \"  )  ,    this . session . heartbeatSchedulingEvents )  ;", "}", "METHOD_END"], "methodName": ["sendMessageInternal"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSessionTests"}, {"methodBody": ["METHOD_START", "{", "super . setUp (  )  ;", "this . webSocketSession    =    new   Testssion (  )  ;", "this . webSocketSession . setOpen ( true )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSessionTests"}]