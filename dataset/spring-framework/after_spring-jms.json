[{"methodBody": ["METHOD_START", "{", "Throwable   cause    =    getCause (  )  ;", "if    ( cause   instanceof   JMS )     {", "return    (  ( JMS )     ( cause )  )  . getErrorCode (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getErrorCode"], "fileName": "org.springframework.jms.JmsException"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["acknowledge"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . text    =    null ;", "}", "METHOD_END"], "methodName": ["clearBody"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearProperties"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . properties . get ( name )  ;", "return   value   instanceof   Boolean    ?     (  ( Boolean )     ( value )  )  . booleanValue (  )     :    false ;", "}", "METHOD_END"], "methodName": ["getBooleanProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . properties . get ( name )  ;", "return   value   instanceof   Byte    ?     (  ( Byte )     ( value )  )  . byteValue (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getByteProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . properties . get ( name )  ;", "return   value   instanceof   Double    ?     (  ( Double )     ( value )  )  . doubleValue (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getDoubleProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . properties . get ( name )  ;", "return   value   instanceof   Float    ?     (  ( Float )     ( value )  )  . floatValue (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getFloatProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . properties . get ( name )  ;", "return   value   instanceof   Integer    ?     (  ( Integer )     ( value )  )  . intValue (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getIntProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . correlationId ;", "}", "METHOD_END"], "methodName": ["getJMSCorrelationID"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . correlationId . getBytes (  )  ;", "}", "METHOD_END"], "methodName": ["getJMSCorrelationIDAsBytes"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . deliveryMode ;", "}", "METHOD_END"], "methodName": ["getJMSDeliveryMode"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . destination ;", "}", "METHOD_END"], "methodName": ["getJMSDestination"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . expiration ;", "}", "METHOD_END"], "methodName": ["getJMSExpiration"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . messageId ;", "}", "METHOD_END"], "methodName": ["getJMSMessageID"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . priority ;", "}", "METHOD_END"], "methodName": ["getJMSPriority"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . redelivered ;", "}", "METHOD_END"], "methodName": ["getJMSRedelivered"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . replyTo ;", "}", "METHOD_END"], "methodName": ["getJMSReplyTo"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . timestamp ;", "}", "METHOD_END"], "methodName": ["getJMSTimestamp"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getJMSType"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . properties . get ( name )  ;", "return   value   instanceof   Long    ?     (  ( Long )     ( value )  )  . longValue (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getLongProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . properties . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getObjectProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . properties . keys (  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyNames"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . properties . get ( name )  ;", "return   value   instanceof   Short    ?     (  ( Short )     ( value )  )  . shortValue (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getShortProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . properties . get ( name )  ;", "return   value   instanceof   St    ?     (  ( St )     ( value )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getStringProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . text ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . properties . containsKey ( name )  ;", "}", "METHOD_END"], "methodName": ["propertyExists"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setBooleanProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setByteProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setDoubleProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setFloatProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setIntProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . correlationId    =    correlationId ;", "}", "METHOD_END"], "methodName": ["setJMSCorrelationID"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . correlationId    =    new   String ( correlationID )  ;", "}", "METHOD_END"], "methodName": ["setJMSCorrelationIDAsBytes"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . deliveryMode    =    deliveryMode ;", "}", "METHOD_END"], "methodName": ["setJMSDeliveryMode"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . destination    =    destination ;", "}", "METHOD_END"], "methodName": ["setJMSDestination"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . expiration    =    expiration ;", "}", "METHOD_END"], "methodName": ["setJMSExpiration"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . messageId    =    id ;", "}", "METHOD_END"], "methodName": ["setJMSMessageID"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . priority    =    priority ;", "}", "METHOD_END"], "methodName": ["setJMSPriority"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . redelivered    =    redelivered ;", "}", "METHOD_END"], "methodName": ["setJMSRedelivered"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . replyTo    =    replyTo ;", "}", "METHOD_END"], "methodName": ["setJMSReplyTo"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . timestamp    =    timestamp ;", "}", "METHOD_END"], "methodName": ["setJMSTimestamp"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setJMSType"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setLongProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setObjectProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setShortProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . properties . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setStringProperty"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "this . text    =    text ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "org.springframework.jms.StubTextMessage"}, {"methodBody": ["METHOD_START", "{", "JmsListenerContainerTestFactory   defaultFactory    =    context . getBean (  \" jmsListenerContainerFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "JmsListenerContainerTestFactory   customFactory    =    context . getBean (  \" customFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "assertEquals (  1  ,    defaultFactory . getListenerContainers (  )  . size (  )  )  ;", "assertEquals (  1  ,    customFactory . getListenerContainers (  )  . size (  )  )  ;", "JmsListenerEndpoint   endpoint    =    defaultFactory . getListenerContainers (  )  . get (  0  )  . getEndpoint (  )  ;", "assertEquals (  \" Wrong   endpoint   type \"  ,    SimpleJmsListenerEndpoint . class ,    endpoint . getClass (  )  )  ;", "assertEquals (  \" Wrong   listener   set   in   custom   endpoint \"  ,    context . getBean (  \" simpleMessageListener \"  )  ,     (  ( SimpleJmsListenerEndpoint )     ( endpoint )  )  . getMessageListener (  )  )  ;", "JmsListenerEndpointRegistry   customRegistry    =    context . getBean (  \" customRegistry \"  ,    JmsListenerEndpointRegistry . class )  ;", "assertEquals (  \" Wrong   number   of   containers   in   the   registry \"  ,     2  ,    customRegistry . getListenerContainerIds (  )  . size (  )  )  ;", "assertEquals (  \" Wrong   number   of   containers   in   the   registry \"  ,     2  ,    customRegistry . getListenerContainers (  )  . size (  )  )  ;", "assertNotNull (  \" Container   with   custom   id   on   the      should   be   found \"  ,    customRegistry . getListenerContainer (  \" listenerId \"  )  )  ;", "assertNotNull (  \" Container   created   with   custom   id   should   be   found \"  ,    customRegistry . getListenerContainer (  \" myCustomEndpointId \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomConfiguration"], "fileName": "org.springframework.jms.annotation.AbstractJmsAnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "JmsListenerContainerTestFactory   defaultFactory    =    context . getBean (  \" jmsListenerContainerFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "assertEquals (  1  ,    defaultFactory . getListenerContainers (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultContainerFactoryConfiguration"], "fileName": "org.springframework.jms.annotation.AbstractJmsAnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "JmsListenerContainerTestFactory   defaultFactory    =    context . getBean (  \" simpleFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "assertEquals (  1  ,    defaultFactory . getListenerContainers (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExplicitContainerFactoryConfiguration"], "fileName": "org.springframework.jms.annotation.AbstractJmsAnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "JmsListenerContainerTestFactory   simpleFactory    =    context . getBean (  \" simpleFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "assertEquals (  1  ,    simpleFactory . getListenerContainers (  )  . size (  )  )  ;", "MethodJmsListenerEndpoint   endpoint    =     (  ( MethodJmsListenerEndpoint )     ( simpleFactory . getListenerContainers (  )  . get (  0  )  . getEndpoint (  )  )  )  ;", "assertEquals (  \" listener 1  \"  ,    endpoint . getId (  )  )  ;", "assertEquals (  \" queueIn \"  ,    endpoint . getDestin (  )  )  ;", "assertEquals (  \" mySelector \"  ,    endpoint . getSelector (  )  )  ;", "assertEquals (  \" mySubscription \"  ,    endpoint . getSubscription (  )  )  ;", "assertEquals (  \"  1  -  1  0  \"  ,    endpoint . getConcurrency (  )  )  ;", "Method   m    =    ReflectionUtils . findMethod ( endpoint . getClass (  )  ,     \" getDefaultResponseDestin \"  )  ;", "ReflectionUtils . makeAccessible ( m )  ;", "Object   destin    =    ReflectionUtils . invokeMethod ( m ,    endpoint )  ;", "assertEquals (  \" queueOut \"  ,    destin )  ;", "}", "METHOD_END"], "methodName": ["testFullConfiguration"], "fileName": "org.springframework.jms.annotation.AbstractJmsAnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "JmsListenerContainerTestFactory   simpleFactory    =    context . getBean (  \" defaultFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "assertEquals (  1  ,    simpleFactory . getListenerContainers (  )  . size (  )  )  ;", "MethodJmsListenerEndpoint   endpoint    =     (  ( MethodJmsListenerEndpoint )     ( simpleFactory . getListenerContainers (  )  . get (  0  )  . getEndpoint (  )  )  )  ;", "SimpleMessageListenerContainer   container    =    new   SimpleMessageListenerContainer (  )  ;", "endpoint . setupListenerContainer ( container )  ;", "MessagingMessageListenerAdapter   listener    =     (  ( MessagingMessageListenerAdapter )     ( container . getMessageListener (  )  )  )  ;", "listener . onMessage ( new   StubTextMessage (  \" failValid \"  )  ,    mock ( Session . class )  )  ;", "}", "METHOD_END"], "methodName": ["testJmsHandlerMethodFactoryConfiguration"], "fileName": "org.springframework.jms.annotation.AbstractJmsAnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "JmsListenerContainerTestFactory   simpleFactory    =    context . getBean (  \" jmsListenerContainerFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "assertEquals (  2  ,    simpleFactory . getListenerContainers (  )  . size (  )  )  ;", "MethodJmsListenerEndpoint   first    =     (  ( MethodJmsListenerEndpoint )     ( simpleFactory . getListenerContainer (  \" first \"  )  . getEndpoint (  )  )  )  ;", "assertEquals (  \" first \"  ,    first . getId (  )  )  ;", "assertEquals (  \" myQueue \"  ,    first . getDestin (  )  )  ;", "assertEquals ( null ,    first . getConcurrency (  )  )  ;", "MethodJmsListenerEndpoint   second    =     (  ( MethodJmsListenerEndpoint )     ( simpleFactory . getListenerContainer (  \" second \"  )  . getEndpoint (  )  )  )  ;", "assertEquals (  \" second \"  ,    second . getId (  )  )  ;", "assertEquals (  \" anotherQueue \"  ,    second . getDestin (  )  )  ;", "assertEquals (  \"  2  -  1  0  \"  ,    second . getConcurrency (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJmsListenerRepeatable"], "fileName": "org.springframework.jms.annotation.AbstractJmsAnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "JmsListenerContainerTestFactory   defaultFactory    =    context . getBean (  \" jmsListenerContainerFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "JmsListenerContainerTestFactory   simpleFactory    =    context . getBean (  \" simpleFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "assertEquals (  1  ,    defaultFactory . getListenerContainers (  )  . size (  )  )  ;", "assertEquals (  1  ,    simpleFactory . getListenerContainers (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSampleConfiguration"], "fileName": "org.springframework.jms.annotation.AbstractJmsAnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "try    ( ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( EnableJmsTests . EnableJmsDefaultContainerFactoryConfig . class ,    EnableJmsTests . ComposedJmsListenersBean . class )  )     {", "JmsListenerContainerTestFactory   simpleFactory    =    context . getBean (  \" jmsListenerContainerFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "assertEquals (  2  ,    simpleFactory . getListenerContainers (  )  . size (  )  )  ;", "MethodJmsListenerEndpoint   first    =     (  ( MethodJmsListenerEndpoint )     ( simpleFactory . getListenerContainer (  \" first \"  )  . getEndpoint (  )  )  )  ;", "assertEquals (  \" first \"  ,    first . getId (  )  )  ;", "assertEquals (  \" orderQueue \"  ,    first . getDestination (  )  )  ;", "assertNull ( first . getConcurrency (  )  )  ;", "MethodJmsListenerEndpoint   second    =     (  ( MethodJmsListenerEndpoint )     ( simpleFactory . getListenerContainer (  \" second \"  )  . getEndpoint (  )  )  )  ;", "assertEquals (  \" second \"  ,    second . getId (  )  )  ;", "assertEquals (  \" billingQueue \"  ,    second . getDestination (  )  )  ;", "assertEquals (  \"  2  -  1  0  \"  ,    second . getConcurrency (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["composedJmsListeners"], "fileName": "org.springframework.jms.annotation.EnableJmsTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( EnableJmsTests . EnableJmsDefaultContainerFactoryConfig . class ,    AbstractJmsAnnotationDrivenTests . DefaultBean . class )  ;", "JmsListenerContainerTestFactory   factory    =    context . getBean ( JmsListenerContainerTestFactory . class )  ;", "MessageListenerTestContainer   container    =    factory . getListenerContainers (  )  . get (  0  )  ;", "assertTrue ( container . isAutoStartup (  )  )  ;", "assertTrue ( container . isStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["containerAreStartedByDefault"], "fileName": "org.springframework.jms.annotation.EnableJmsTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( EnableJmsTests . EnableJmsAutoStartupFalseConfig . class ,    AbstractJmsAnnotationDrivenTests . DefaultBean . class )  ;", "JmsListenerContainerTestFactory   factory    =    context . getBean ( JmsListenerContainerTestFactory . class )  ;", "MessageListenerTestContainer   container    =    factory . getListenerContainers (  )  . get (  0  )  ;", "assertFalse ( container . isAutoStartup (  )  )  ;", "assertFalse ( container . isStarted (  )  )  ;", "JmsListenerEndpointRegistry   registry    =    context . getBean ( JmsListenerEndpointRegistry . class )  ;", "registry . start (  )  ;", "assertTrue ( container . isStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["containerCanBeStarterViaTheRegistry"], "fileName": "org.springframework.jms.annotation.EnableJmsTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( EnableJmsTests . EnableJmsDefaultContainerFactoryConfig . class ,    EnableJmsTests . LazyBean . class )  ;", "JmsListenerContainerTestFactory   defaultFactory    =    context . getBean (  \" jmsListenerContainerFactory \"  ,    JmsListenerContainerTestFactory . class )  ;", "assertEquals (  0  ,    defaultFactory . getListenerContainers (  )  . size (  )  )  ;", "context . getBean ( EnableJmsTests . LazyBean . class )  ;", "assertEquals (  1  ,    defaultFactory . getListenerContainers (  )  . size (  )  )  ;", "MessageListenerTestContainer   container    =    defaultFactory . getListenerContainers (  )  . get (  0  )  ;", "assertTrue (  (  \" Should   have   been   started    \"     +    container )  ,    container . isStarted (  )  )  ;", "context . close (  )  ;", "assertTrue (  (  \" Should   have   been   stopped    \"     +    container )  ,    container . isStopped (  )  )  ;", "}", "METHOD_END"], "methodName": ["lazyComponent"], "fileName": "org.springframework.jms.annotation.EnableJmsTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( BeanCreationException . class )  ;", "thrown . expectMessage (  \" customFactory \"  )  ;", "new   AnnotationConfigApplicationContext (  . EnableJmsSampleConfig . class ,    AbstractJmsAnnotationDrivenTests . CustomBean . class )  ;", "}", "METHOD_END"], "methodName": ["unknownFactory"], "fileName": "org.springframework.jms.annotation.EnableJmsTests"}, {"methodBody": ["METHOD_START", "{", "return   new   JmsListenerEndpointRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["defaultJmsListenerEndpointRegistry"], "fileName": "org.springframework.jms.annotation.JmsBootstrapConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   JmsListenerAnnotationBeanPostProcessor (  )  ;", "}", "METHOD_END"], "methodName": ["jmsListenerAnnotationProcessor"], "fileName": "org.springframework.jms.annotation.JmsBootstrapConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodJmsListenerEndpoint (  )  ;", "}", "METHOD_END"], "methodName": ["createMethodJmsListenerEndpoint"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( jmsListener . id (  )  )  )     {", "String   id    =    resolve ( jmsListener . id (  )  )  ;", "return   id    !  =    null    ?    id    :     \"  \"  ;", "} else    {", "return    \" JmsListenerEndpointContainer #  \"     +     ( this . counter . getAndIncrement (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getEndpointId"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Method   invocableMethod    =    AopUtils . selectInvocableMethod ( mostSpecificMethod ,    bean . getClass (  )  )  ;", "MethodJmsListenerEndpoint   endpoint    =    createMethodJmsListenerEndpoint (  )  ;", "endpoint . setBean ( bean )  ;", "endpoint . setMethod ( invocableMethod )  ;", "endpoint . setMostSpecificMethod ( mostSpecificMethod )  ;", "endpoint . setMessageHandlerMethodFactory ( this . messageHandlerMethodFactory )  ;", "endpoint . setEmbeddedValueResolver ( this . embeddedValueResolver )  ;", "endpoint . setBeanFactory ( this . beanFactory )  ;", "endpoint . setId ( getEndpointId ( jmsListener )  )  ;", "endpoint . setDestination ( resolve ( jmsListener . destination (  )  )  )  ;", "if    ( StringUtils . hasText ( jmsListener . selector (  )  )  )     {", "endpoint . setSelector ( resolve ( jmsListener . selector (  )  )  )  ;", "}", "if    ( StringUtils . hasText ( jmsListener . subscription (  )  )  )     {", "endpoint . setSubscription ( resolve ( jmsListener . subscription (  )  )  )  ;", "}", "if    ( StringUtils . hasText ( jmsListener . concurrency (  )  )  )     {", "endpoint . setConcurrency ( resolve ( jmsListener . concurrency (  )  )  )  ;", "}", "JmsListenerContainerFactory <  ?  >    factory    =    null ;", "String   containerFactoryBeanName    =    resolve ( jmsListener . containerFactory (  )  )  ;", "if    ( StringUtils . hasText ( containerFactoryBeanName )  )     {", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" BeanFactory   must   be   set   to   obtain   container   factory   by   bean   name \"  )  ;", "try    {", "factory    =    this . beanFactory . getBean ( containerFactoryBeanName ,    JmsListenerContainerFactory . class )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "throw   new   beans . factory . BeanInitializationException (  (  (  (  (  (  (  \" Could   not   register   JMS   listener   endpoint   on    [  \"     +    mostSpecificMethod )     +     \"  ]  ,    no    \"  )     +     ( JmsListenerContainerFactory . class . getSimpleName (  )  )  )     +     \"    with   id    '  \"  )     +    containerFactoryBeanName )     +     \"  '    was   found   in   the   application   context \"  )  ,    ex )  ;", "}", "}", "this . registrar . registerEndpoint ( endpoint ,    factory )  ;", "}", "METHOD_END"], "methodName": ["processJmsListener"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return    ( this . embeddedValueResolver )     !  =    null    ?    this . embeddedValueResolver . resolveStringValue ( value )     :    value ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . containerFactoryBeanName    =    containerFactoryBeanName ;", "}", "METHOD_END"], "methodName": ["setContainerFactoryBeanName"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . endpointRegistry    =    endpointRegistry ;", "}", "METHOD_END"], "methodName": ["setEndpointRegistry"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . messageHandlerMethodFactory . setMessageHandlerMethodFactory ( messageHandlerMethodFactory )  ;", "}", "METHOD_END"], "methodName": ["setMessageHandlerMethodFactory"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( BeanCreationException . class )  ;", "thrown . expectCause ( is ( instanceOf ( IllegalStateException . class )  )  )  ;", "thrown . expectMessage (  \" handleIt 2  \"  )  ;", "new   AnnotationConfigApplicationContext (  . Config . class ,     . ProxyConfig . class ,     . InvalidProxyTestBean . class )  ;", "}", "METHOD_END"], "methodName": ["invalidProxy"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JmsListenerAnnotationBeanPostProcessorTests . Config . class ,    JmsListenerAnnotationBeanPostProcessorTests . MetaAnnotationTestBean . class )  ;", "try    {", "JmsListenerContainerTestFactory   factory    =    context . getBean ( JmsListenerContainerTestFactory . class )  ;", "assertEquals (  \" one   container   should   have   been   registered \"  ,     1  ,    factory . getListenerContainers (  )  . size (  )  )  ;", "JmsListenerEndpoint   endpoint    =    factory . getListenerContainers (  )  . get (  0  )  . getEndpoint (  )  ;", "assertEquals (  \" Wrong   endpoint   type \"  ,    MethodJmsListenerEndpoint . class ,    endpoint . getClass (  )  )  ;", "MethodJmsListenerEndpoint   methodEndpoint    =     (  ( MethodJmsListenerEndpoint )     ( endpoint )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . MetaAnnotationTestBean . class ,    methodEndpoint . getBean (  )  . getClass (  )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . MetaAnnotationTestBean . class . getMethod (  \" handleIt \"  ,    String . class )  ,    methodEndpoint . getMethod (  )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . MetaAnnotationTestBean . class . getMethod (  \" handleIt \"  ,    String . class )  ,    methodEndpoint . getMostSpecificMethod (  )  )  ;", "assertEquals (  \" metaTestQueue \"  ,     (  ( AbstractJmsListenerEndpoint )     ( endpoint )  )  . getDestination (  )  )  ;", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["metaAnnotationIsDiscovered"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JmsListenerAnnotationBeanPostProcessorTests . Config . class ,    JmsListenerAnnotationBeanPostProcessorTests . ProxyConfig . class ,    JmsListenerAnnotationBeanPostProcessorTests . ClassProxyTestBean . class )  ;", "try    {", "JmsListenerContainerTestFactory   factory    =    context . getBean ( JmsListenerContainerTestFactory . class )  ;", "assertEquals (  \" one   container   should   have   been   registered \"  ,     1  ,    factory . getListenerContainers (  )  . size (  )  )  ;", "JmsListenerEndpoint   endpoint    =    factory . getListenerContainers (  )  . get (  0  )  . getEndpoint (  )  ;", "assertEquals (  \" Wrong   endpoint   type \"  ,    MethodJmsListenerEndpoint . class ,    endpoint . getClass (  )  )  ;", "MethodJmsListenerEndpoint   methodEndpoint    =     (  ( MethodJmsListenerEndpoint )     ( endpoint )  )  ;", "assertTrue ( AopUtils . isCglibProxy ( methodEndpoint . getBean (  )  )  )  ;", "assertTrue (  (  ( methodEndpoint . getBean (  )  )    instanceof   JmsListenerAnnotationBeanPostProcessorTests . ClassProxyTestBean )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . ClassProxyTestBean . class . getMethod (  \" handleIt \"  ,    String . class ,    String . class )  ,    methodEndpoint . getMethod (  )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . ClassProxyTestBean . class . getMethod (  \" handleIt \"  ,    String . class ,    String . class )  ,    methodEndpoint . getMostSpecificMethod (  )  )  ;", "Method   m    =    ReflectionUtils . findMethod ( endpoint . getClass (  )  ,     \" getDefaultResponseDestination \"  )  ;", "ReflectionUtils . makeAccessible ( m )  ;", "Object   destination    =    ReflectionUtils . invokeMethod ( m ,    endpoint )  ;", "assertEquals (  \" SendTo   annotation   not   found   on   proxy \"  ,     \" foobar \"  ,    destination )  ;", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sendToAnnotationFoundOnCglibProxy"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JmsListenerAnnotationBeanPostProcessorTests . Config . class ,    JmsListenerAnnotationBeanPostProcessorTests . ProxyConfig . class ,    JmsListenerAnnotationBeanPostProcessorTests . InterfaceProxyTestBean . class )  ;", "try    {", "JmsListenerContainerTestFactory   factory    =    context . getBean ( JmsListenerContainerTestFactory . class )  ;", "assertEquals (  \" one   container   should   have   been   registered \"  ,     1  ,    factory . getListenerContainers (  )  . size (  )  )  ;", "JmsListenerEndpoint   endpoint    =    factory . getListenerContainers (  )  . get (  0  )  . getEndpoint (  )  ;", "assertEquals (  \" Wrong   endpoint   type \"  ,    MethodJmsListenerEndpoint . class ,    endpoint . getClass (  )  )  ;", "MethodJmsListenerEndpoint   methodEndpoint    =     (  ( MethodJmsListenerEndpoint )     ( endpoint )  )  ;", "assertTrue ( AopUtils . isJdkDynamicProxy ( methodEndpoint . getBean (  )  )  )  ;", "assertTrue (  (  ( methodEndpoint . getBean (  )  )    instanceof   JmsListenerAnnotationBeanPostProcessorTests . SimpleService )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . SimpleService . class . getMethod (  \" handleIt \"  ,    String . class ,    String . class )  ,    methodEndpoint . getMethod (  )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . InterfaceProxyTestBean . class . getMethod (  \" handleIt \"  ,    String . class ,    String . class )  ,    methodEndpoint . getMostSpecificMethod (  )  )  ;", "Method   m    =    ReflectionUtils . findMethod ( endpoint . getClass (  )  ,     \" getDefaultResponseDestination \"  )  ;", "ReflectionUtils . makeAccessible ( m )  ;", "Object   destination    =    ReflectionUtils . invokeMethod ( m ,    endpoint )  ;", "assertEquals (  \" SendTo   annotation   not   found   on   proxy \"  ,     \" foobar \"  ,    destination )  ;", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sendToAnnotationFoundOnInterfaceProxy"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JmsListenerAnnotationBeanPostProcessorTests . Config . class ,    JmsListenerAnnotationBeanPostProcessorTests . SimpleMessageListenerTestBean . class )  ;", "JmsListenerContainerTestFactory   factory    =    context . getBean ( JmsListenerContainerTestFactory . class )  ;", "assertEquals (  \" One   container   should   have   been   registered \"  ,     1  ,    factory . getListenerContainers (  )  . size (  )  )  ;", "MessageListenerTestContainer   container    =    factory . getListenerContainers (  )  . get (  0  )  ;", "JmsListenerEndpoint   endpoint    =    container . getEndpoint (  )  ;", "assertEquals (  \" Wrong   endpoint   type \"  ,    MethodJmsListenerEndpoint . class ,    endpoint . getClass (  )  )  ;", "MethodJmsListenerEndpoint   methodEndpoint    =     (  ( MethodJmsListenerEndpoint )     ( endpoint )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . SimpleMessageListenerTestBean . class ,    methodEndpoint . getBean (  )  . getClass (  )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . SimpleMessageListenerTestBean . class . getMethod (  \" handleIt \"  ,    String . class )  ,    methodEndpoint . getMethod (  )  )  ;", "assertEquals ( JmsListenerAnnotationBeanPostProcessorTests . SimpleMessageListenerTestBean . class . getMethod (  \" handleIt \"  ,    String . class )  ,    methodEndpoint . getMostSpecificMethod (  )  )  ;", "SimpleMessageListenerContainer   listenerContainer    =    new   SimpleMessageListenerContainer (  )  ;", "methodEndpoint . setupListenerContainer ( listenerContainer )  ;", "assertNotNull ( listenerContainer . getMessageListener (  )  )  ;", "assertTrue (  (  \" Should   have   been   started    \"     +    container )  ,    container . isStarted (  )  )  ;", "context . close (  )  ;", "assertTrue (  (  \" Should   have   been   stopped    \"     +    container )  ,    container . isStopped (  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleMessageListener"], "fileName": "org.springframework.jms.annotation.JmsListenerAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . clientId    =    clientId ;", "}", "METHOD_END"], "methodName": ["setClientId"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . connectionFactory    =    connectionFactory ;", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . destinationResolver    =    destinationResolver ;", "}", "METHOD_END"], "methodName": ["setDestinationResolver"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . messageConverter    =    messageConverter ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . phase    =    phase ;", "}", "METHOD_END"], "methodName": ["setPhase"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . pubSubDomain    =    pubSubDomain ;", "}", "METHOD_END"], "methodName": ["setPubSubDomain"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . replyPubSubDomain    =    replyPubSubDomain ;", "}", "METHOD_END"], "methodName": ["setReplyPubSubDomain"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . replyQosSettings    =    replyQosSettings ;", "}", "METHOD_END"], "methodName": ["setReplyQosSettings"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . sessionAcknowledgeMode    =    sessionAcknowledgeMode ;", "}", "METHOD_END"], "methodName": ["setSessionAcknowledgeMode"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . sessionTransacted    =    sessionTransacted ;", "}", "METHOD_END"], "methodName": ["setSessionTransacted"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionDurable    =    subscriptionDurable ;", "}", "METHOD_END"], "methodName": ["setSubscriptionDurable"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionShared    =    subscriptionShared ;", "}", "METHOD_END"], "methodName": ["setSubscriptionShared"], "fileName": "org.springframework.jms.config.AbstractJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . concurrency ;", "}", "METHOD_END"], "methodName": ["getConcurrency"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "return   this . destination ;", "}", "METHOD_END"], "methodName": ["getDestination"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "return   result . append ( getClass (  )  . getSimpleName (  )  )  . append (  \"  [  \"  )  . append ( this . id )  . append (  \"  ]    destination =  \"  )  . append ( this . destination )  . append (  \"  '     |    subscription =  '  \"  )  . append ( this . subscription )  . append (  \"     |    selector =  '  \"  )  . append ( this . selector )  . append (  \"  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["getEndpointDescription"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "return   this . selector ;", "}", "METHOD_END"], "methodName": ["getSelector"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "return   this . subscription ;", "}", "METHOD_END"], "methodName": ["getSubscription"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . concurrency    =    concurrency ;", "}", "METHOD_END"], "methodName": ["setConcurrency"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . destination    =    destination ;", "}", "METHOD_END"], "methodName": ["setDestination"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . selector    =    selector ;", "}", "METHOD_END"], "methodName": ["setSelector"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . subscription    =    subscription ;", "}", "METHOD_END"], "methodName": ["setSubscription"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getDestination (  )  )     !  =    null )     {", "listenerContainer . setDestinationName ( getDestination (  )  )  ;", "}", "if    (  ( getSubscription (  )  )     !  =    null )     {", "listenerContainer . setSubscriptionName ( getSubscription (  )  )  ;", "}", "if    (  ( getSelector (  )  )     !  =    null )     {", "listenerContainer . setMessageSelector ( getSelector (  )  )  ;", "}", "if    (  ( getConcurrency (  )  )     !  =    null )     {", "listenerContainer . setConcurrency ( getConcurrency (  )  )  ;", "}", "setupMessage ( listenerContainer )  ;", "}", "METHOD_END"], "methodName": ["setupJmsListenerContainer"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "container . setupMessageListener ( createMessageListener ( container )  )  ;", "}", "METHOD_END"], "methodName": ["setupMessageListener"], "fileName": "org.springframework.jms.config.AbstractJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "String   acknowledge    =    ele . getAttribute ( AbstractListenerContainerParser . ACKNOWLEDGE _ ATTRIBUTE )  ;", "if    ( StringUtils . hasText ( acknowledge )  )     {", "int   acknowledgeMode    =    Session . AUTO _ ACKNOWLEDGE ;", "if    ( AbstractListenerContainerParser . ACKNOWLEDGE _ TRANSACTED . equals ( acknowledge )  )     {", "acknowledgeMode    =    Session . SESSION _ TRANSACTED ;", "} else", "if    ( AbstractListenerContainerParser . ACKNOWLEDGE _ DUPS _ OK . equals ( acknowledge )  )     {", "acknowledgeMode    =    Session . DUPS _ OK _ ACKNOWLEDGE ;", "} else", "if    ( AbstractListenerContainerParser . ACKNOWLEDGE _ CLIENT . equals ( acknowledge )  )     {", "acknowledgeMode    =    Session . CLIENT _ ACKNOWLEDGE ;", "} else", "if    (  !  ( AbstractListenerContainerParser . ACKNOWLEDGE _ AUTO . equals ( acknowledge )  )  )     {", "parserContext . getReaderContext (  )  . error (  (  (  \" Invalid   listener   container    ' acknowledge '    setting    [  \"     +    acknowledge )     +     \"  ]  :    only    \\  \" auto \\  \"  ,     \\  \" client \\  \"  ,     \\  \" dups - ok \\  \"    and    \\  \" transacted \\  \"    supported .  \"  )  ,    ele )  ;", "}", "return   acknowledgeMode ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["parseAcknowledgeMode"], "fileName": "org.springframework.jms.config.AbstractListenerContainerParser"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   properties    =    new   MutablePropertyValues (  )  ;", "String   destinationType    =    containerEle . getAttribute (  . DESTINATION _ TYPE _ ATTRIBUTE )  ;", "boolean   pubSubDomain    =    false ;", "boolean   subscriptionDurable    =    false ;", "boolean   subscriptionShared    =    false ;", "if    (  . DESTINATION _ TYPE _ SHARED _ DURABLE _ TOPIC . equals ( destinationType )  )     {", "pubSubDomain    =    true ;", "subscriptionDurable    =    true ;", "subscriptionShared    =    true ;", "} else", "if    (  . DESTINATION _ TYPE _ SHARED _ TOPIC . equals ( destinationType )  )     {", "pubSubDomain    =    true ;", "subscriptionShared    =    true ;", "} else", "if    (  . DESTINATION _ TYPE _ DURABLE _ TOPIC . equals ( destinationType )  )     {", "pubSubDomain    =    true ;", "subscriptionDurable    =    true ;", "} else", "if    (  . DESTINATION _ TYPE _ TOPIC . equals ( destinationType )  )     {", "pubSubDomain    =    true ;", "} else", "if    (  (  \"  \"  . equals ( destinationType )  )     |  |     (  . DESTINATION _ TYPE _ QUEUE . equals ( destinationType )  )  )     {", "} else    {", "parserContext . getReaderContext (  )  . error (  (  \" Invalid   listener   container    ' destination - type '  :    only    \"     +     \"  \\  \" queue \\  \"  ,     \\  \" topic \\  \"  ,     \\  \" durableTopic \\  \"  ,     \\  \" sharedTopic \\  \"  ,     \\  \" sharedDurableTopic \\  \"    supported .  \"  )  ,    containerEle )  ;", "}", "properties . add (  \" pubSubDomain \"  ,    pubSubDomain )  ;", "properties . add (  \" subscriptionDurable \"  ,    subscriptionDurable )  ;", "properties . add (  \" subscriptionShared \"  ,    subscriptionShared )  ;", "boolean   replyPubSubDomain    =    false ;", "String   replyDestinationType    =    containerEle . getAttribute (  . RESPONSE _ DESTINATION _ TYPE _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( replyDestinationType )  )  )     {", "replyPubSubDomain    =    pubSubDomain ;", "} else", "if    (  . DESTINATION _ TYPE _ TOPIC . equals ( replyDestinationType )  )     {", "replyPubSubDomain    =    true ;", "} else", "if    (  !  (  . DESTINATION _ TYPE _ QUEUE . equals ( replyDestinationType )  )  )     {", "parserContext . getReaderContext (  )  . error (  (  \" Invalid   listener   container    ' response - destination - type '  :    only    \"     +     \"  \\  \" queue \\  \"  ,     \\  \" topic \\  \"    supported .  \"  )  ,    containerEle )  ;", "}", "properties . add (  \" replyPubSubDomain \"  ,    replyPubSubDomain )  ;", "if    ( containerEle . hasAttribute (  . CLIENT _ ID _ ATTRIBUTE )  )     {", "String   clientId    =    containerEle . getAttribute (  . CLIENT _ ID _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( clientId )  )  )     {", "parserContext . getReaderContext (  )  . error (  \" Listener    ' client - id '    attribute   contains   empty   value .  \"  ,    containerEle )  ;", "}", "properties . add (  \" clientId \"  ,    clientId )  ;", "}", "if    ( containerEle . hasAttribute (  . MESSAGE _ CONVERTER _ ATTRIBUTE )  )     {", "String   messageConverter    =    containerEle . getAttribute (  . MESSAGE _ CONVERTER _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( messageConverter )  )  )     {", "parserContext . getReaderContext (  )  . error (  \" listener   container    ' message - converter '    attribute   contains   empty   value .  \"  ,    containerEle )  ;", "} else    {", "properties . add (  \" messageConverter \"  ,    new   RuntimeBeanReference ( messageConverter )  )  ;", "}", "}", "return   properties ;", "}", "METHOD_END"], "methodName": ["parseCommonContainerProperties"], "fileName": "org.springframework.jms.config.AbstractListenerContainerParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   listenerDef    =    new   RootBeanDefinition (  )  ;", "listenerDef . setSource ( parserContext . extractSource ( listenerEle )  )  ;", "listenerDef . setBeanClassName (  \" MessageListenerAdapter \"  )  ;", "String   ref    =    listenerEle . getAttribute (  . REF _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( ref )  )  )     {", "parserContext . getReaderContext (  )  . error (  \" Listener    ' ref '    attribute   contains   empty   value .  \"  ,    listenerEle )  ;", "} else    {", "listenerDef . getPropertyValues (  )  . add (  \" delegate \"  ,    new   RuntimeBeanReference ( ref )  )  ;", "}", "if    ( listenerEle . hasAttribute (  . METHOD _ ATTRIBUTE )  )     {", "String   method    =    listenerEle . getAttribute (  . METHOD _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( method )  )  )     {", "parserContext . getReaderContext (  )  . error (  \" Listener    ' method '    attribute   contains   empty   value .  \"  ,    listenerEle )  ;", "}", "listenerDef . getPropertyValues (  )  . add (  \" defaultListenerMethod \"  ,    method )  ;", "}", "PropertyValue   messageConverterPv    =    commonContainerProperties . getPropertyValue (  \" messageConverter \"  )  ;", "if    ( messageConverterPv    !  =    null )     {", "listenerDef . getPropertyValues (  )  . addPropertyValue ( messageConverterPv )  ;", "}", "BeanDefinition   containerDef    =    createContainer ( containerEle ,    listenerEle ,    parserContext ,    commonContainerProperties ,    specificContainerProperties )  ;", "containerDef . getPropertyValues (  )  . add (  \" messageListener \"  ,    listenerDef )  ;", "if    ( listenerEle . hasAttribute (  . RESPONSE _ DESTINATION _ ATTRIBUTE )  )     {", "String   responseDestination    =    listenerEle . getAttribute (  . RESPONSE _ DESTINATION _ ATTRIBUTE )  ;", "Boolean   pubSubDomain    =     (  ( Boolean )     ( commonContainerProperties . get (  \" replyPubSubDomain \"  )  )  )  ;", "if    ( pubSubDomain    =  =    null )     {", "pubSubDomain    =    false ;", "}", "listenerDef . getPropertyValues (  )  . add (  ( pubSubDomain    ?     \" defaultResponseTopicName \"     :     \" defaultResponseQueueName \"  )  ,    responseDestination )  ;", "PropertyValue   destinationResolver    =    containerDef . getPropertyValues (  )  . getPropertyValue (  \" destinationResolver \"  )  ;", "if    ( destinationResolver    !  =    null )     {", "listenerDef . getPropertyValues (  )  . addPropertyValue ( destinationResolver )  ;", "}", "}", "String   containerBeanName    =    listenerEle . getAttribute (  . ID _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( containerBeanName )  )  )     {", "containerBeanName    =    parserContext . getReaderContext (  )  . generateBeanName ( containerDef )  ;", "}", "parserContext . registerBeanComponent ( new   BeanComponentDefinition ( containerDef ,    containerBeanName )  )  ;", "}", "METHOD_END"], "methodName": ["parseListener"], "fileName": "org.springframework.jms.config.AbstractListenerContainerParser"}, {"methodBody": ["METHOD_START", "{", "String   destination    =    ele . getAttribute ( AbstractListenerContainerParser . DESTINATION _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( destination )  )  )     {", "parserContext . getReaderContext (  )  . error (  \" Listener    ' destination '    attribute   contains   empty   value .  \"  ,    ele )  ;", "}", "configValues . add (  \" destinationName \"  ,    destination )  ;", "if    ( ele . hasAttribute ( AbstractListenerContainerParser . SUBSCRIPTION _ ATTRIBUTE )  )     {", "String   subscription    =    ele . getAttribute ( AbstractListenerContainerParser . SUBSCRIPTION _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( subscription )  )  )     {", "parserContext . getReaderContext (  )  . error (  \" Listener    ' subscription '    attribute   contains   empty   value .  \"  ,    ele )  ;", "}", "configValues . add (  \" subscriptionName \"  ,    subscription )  ;", "}", "if    ( ele . hasAttribute ( AbstractListenerContainerParser . SELECTOR _ ATTRIBUTE )  )     {", "String   selector    =    ele . getAttribute ( AbstractListenerContainerParser . SELECTOR _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( selector )  )  )     {", "parserContext . getReaderContext (  )  . error (  \" Listener    ' selector '    attribute   contains   empty   value .  \"  ,    ele )  ;", "}", "configValues . add (  \" messageSelector \"  ,    selector )  ;", "}", "if    ( ele . hasAttribute ( AbstractListenerContainerParser . CONCURRENCY _ ATTRIBUTE )  )     {", "String   concurrency    =    ele . getAttribute ( AbstractListenerContainerParser . CONCURRENCY _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( concurrency )  )  )     {", "parserContext . getReaderContext (  )  . error (  \" Listener    ' concurrency '    attribute   contains   empty   value .  \"  ,    ele )  ;", "}", "configValues . add (  \" concurrency \"  ,    concurrency )  ;", "}", "}", "METHOD_END"], "methodName": ["parseListenerConfiguration"], "fileName": "org.springframework.jms.config.AbstractListenerContainerParser"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . genericBeanDefinition (  \" JmsListenerEndpointRegistry \"  )  ;", "builder . getRawBeanDefinition (  )  . setSource ( source )  ;", ". registerInfrastructureBean ( parserContext ,    builder ,    JmsListenerConfigUtils . JMS _ LISTENER _ ENDPOINT _ REGISTRY _ BEAN _ NAME )  ;", "}", "METHOD_END"], "methodName": ["registerDefaultEndpointRegistry"], "fileName": "org.springframework.jms.config.AnnotationDrivenJmsBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "builder . setRole ( ROLE _ INFRASTRUCTURE )  ;", "parserContext . getRegistry (  )  . registerBeanDefinition ( beanName ,    builder . getBeanDefinition (  )  )  ;", "BeanDefinitionHolder   holder    =    new   BeanDefinitionHolder ( builder . getBeanDefinition (  )  ,    beanName )  ;", "parserContext . registerComponent ( new   beans . factory . parsing . BeanComponentDefinition ( holder )  )  ;", "}", "METHOD_END"], "methodName": ["registerInfrastructureBean"], "fileName": "org.springframework.jms.config.AnnotationDrivenJmsBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   new   JmsMessageEndpointManager (  )  ;", "}", "METHOD_END"], "methodName": ["createContainerInstance"], "fileName": "org.springframework.jms.config.DefaultJcaListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . activationSpecFactory    =    activationSpecFactory ;", "}", "METHOD_END"], "methodName": ["setActivationSpecFactory"], "fileName": "org.springframework.jms.config.DefaultJcaListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . destinationResolver    =    destinationResolver ;", "}", "METHOD_END"], "methodName": ["setDestinationResolver"], "fileName": "org.springframework.jms.config.DefaultJcaListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . phase    =    phase ;", "}", "METHOD_END"], "methodName": ["setPhase"], "fileName": "org.springframework.jms.config.DefaultJcaListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . resourceAdapter    =    resourceAdapter ;", "}", "METHOD_END"], "methodName": ["setResourceAdapter"], "fileName": "org.springframework.jms.config.DefaultJcaListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . transactionManager    =    transactionManager ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.jms.config.DefaultJcaListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . backOff    =    backOff ;", "}", "METHOD_END"], "methodName": ["setBackOff"], "fileName": "org.springframework.jms.config.DefaultJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . cacheLevel    =    cacheLevel ;", "}", "METHOD_END"], "methodName": ["setCacheLevel"], "fileName": "org.springframework.jms.config.DefaultJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . cacheLevelName    =    cacheLevelName ;", "}", "METHOD_END"], "methodName": ["setCacheLevelName"], "fileName": "org.springframework.jms.config.DefaultJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . concurrency    =    concurrency ;", "}", "METHOD_END"], "methodName": ["setConcurrency"], "fileName": "org.springframework.jms.config.DefaultJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . maxMessagesPerTask    =    maxMessagesPerTask ;", "}", "METHOD_END"], "methodName": ["setMaxMessagesPerTask"], "fileName": "org.springframework.jms.config.DefaultJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . receiveTimeout    =    receiveTimeout ;", "}", "METHOD_END"], "methodName": ["setReceiveTimeout"], "fileName": "org.springframework.jms.config.DefaultJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . recoveryInterval    =    recoveryInterval ;", "}", "METHOD_END"], "methodName": ["setRecoveryInterval"], "fileName": "org.springframework.jms.config.DefaultJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.jms.config.DefaultJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "this . transactionManager    =    transactionManager ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.jms.config.DefaultJmsListenerContainerFactory"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  (  \" Method    \"     +    methodName )     +     \"    should   have   been   invoked \"  )  ,    sample . invocations . get ( methodName )  )  ;", "}", "METHOD_END"], "methodName": ["assertListenerMethodInvocation"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   createMethodJmsEndpoint ( this . factory ,    ReflectionUtils . findMethod ( clazz ,    methodName ,    paramTypes )  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultMethodJmsEndpoint"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "MethodJmsListenerEndpoint   endpoint    =    new   MethodJmsListenerEndpoint (  )  ;", "endpoint . setBean ( listener )  ;", "endpoint . setMethod ( method )  ;", "endpoint . setMessageHandlerMethodFactory ( factory )  ;", "return   endpoint ;", "}", "METHOD_END"], "methodName": ["createMethodJmsEndpoint"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "factory . setBeanFactory ( new   StaticListableBeanFactory (  )  )  ;", "factory . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["initializeFactory"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   messageListenerContainer    =    containerFactory . createListenerContainer ( endpoint )  ;", "Object   listener    =    messageListenerContainer . getMessageListener (  )  ;", "if    ( listener   instanceof   SessionAwareMessageListener )     {", "(  ( SessionAwareMessageListener < Message >  )     ( listener )  )  . onMessage ( message ,    mock ( Session . class )  )  ;", "} else    {", "(  ( MessageListener )     ( listener )  )  . onMessage ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeListener"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . containerFactory . setMessageConverter ( new   JmsListenerContainerFactoryIntegrationTests . UpperCaseMessageConverter (  )  )  ;", "testMessageConverterIsUsed (  )  ;", "}", "METHOD_END"], "methodName": ["messageConverterUsedIfSet"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageConverter   converter    =    new   MessagingMessageConverter (  )  ;", "converter . setPayloadConverter ( new    . UpperCaseMessageConverter (  )  )  ;", "this . containerFactory . setMessageConverter ( converter )  ;", "testMessageConverterIsUsed (  )  ;", "}", "METHOD_END"], "methodName": ["messagingMessageConverterCanBeUsed"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory ( sample )  ;", "pf . setProxyTargetClass ( true )  ;", "listener    =     (  (  . JmsEndpointSampleBean )     ( pf . getProxy (  )  )  )  ;", "containerFactory . setMessageConverter ( new    . UpperCaseMessageConverter (  )  )  ;", "MethodJmsListenerEndpoint   endpoint    =    createDefaultMethodJmsEndpoint (  . JmsEndpointSampleBean . class ,     \" handleIt \"  ,    String . class ,    String . class )  ;", "Message   message    =    new   StubTextMessage (  \" foo - bar \"  )  ;", "message . setStringProperty (  \" my - header \"  ,     \" my - value \"  )  ;", "invokeListener ( endpoint ,    message )  ;", "assertListenerMethodInvocation (  \" handleIt \"  )  ;", "}", "METHOD_END"], "methodName": ["parameterAnnotationWithCglibProxy"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory ( sample )  ;", "listener    =     (  (  . JmsEndpointSampleInterface )     ( pf . getProxy (  )  )  )  ;", "containerFactory . setMessageConverter ( new    . UpperCaseMessageConverter (  )  )  ;", "MethodJmsListenerEndpoint   endpoint    =    createDefaultMethodJmsEndpoint (  . JmsEndpointSampleInterface . class ,     \" handleIt \"  ,    String . class ,    String . class )  ;", "Message   message    =    new   StubTextMessage (  \" foo - bar \"  )  ;", "message . setStringProperty (  \" my - header \"  ,     \" my - value \"  )  ;", "invokeListener ( endpoint ,    message )  ;", "assertListenerMethodInvocation (  \" handleIt \"  )  ;", "}", "METHOD_END"], "methodName": ["parameterAnnotationWithJdkProxy"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "initializeFactory ( factory )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "MethodJmsListenerEndpoint   endpoint    =    createDefaultMethodJmsEndpoint ( this . listener . getClass (  )  ,     \" handleIt \"  ,    String . class ,    String . class )  ;", "Message   message    =    new   StubTextMessage (  \" foo - bar \"  )  ;", "message . setStringProperty (  \" my - header \"  ,     \" my - value \"  )  ;", "invokeListener ( endpoint ,    message )  ;", "assertListenerMethodInvocation (  \" handleIt \"  )  ;", "}", "METHOD_END"], "methodName": ["testMessageConverterIsUsed"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( this . messageConverter ,    container . getMessageConverter (  )  )  ;", "assertEquals ( this . destinationResolver ,    container . getDestinationResolver (  )  )  ;", "JmsActivationSpecConfig   config    =    container . getActivationSpecConfig (  )  ;", "assertNotNull ( config )  ;", "assertEquals ( DUPS _ OK _ ACKNOWLEDGE ,    config . getAcknowledgeMode (  )  )  ;", "assertEquals ( true ,    config . isPubSubDomain (  )  )  ;", "assertEquals ( new   QosSettings (  1  ,     7  ,     5  0  0  0  )  ,    container . getReplyQosSettings (  )  )  ;", "assertEquals ( true ,    config . isSubscriptionDurable (  )  )  ;", "assertEquals (  \" client -  1  2  3  4  \"  ,    config . getClientId (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDefaultJcaConfig"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( this . connectionFactory ,    container . getConnectionFactory (  )  )  ;", "assertEquals ( this . destinationResolver ,    container . getDestinationResolver (  )  )  ;", "assertEquals ( this . messageConverter ,    container . getMessageConverter (  )  )  ;", "assertEquals ( true ,    container . isSessionTransacted (  )  )  ;", "assertEquals ( DUPS _ OK _ ACKNOWLEDGE ,    container . getSessionAcknowledgeMode (  )  )  ;", "assertEquals ( true ,    container . isPubSubDomain (  )  )  ;", "assertEquals ( true ,    container . isReplyPubSubDomain (  )  )  ;", "assertEquals ( new   QosSettings (  1  ,     7  ,     5  0  0  0  )  ,    container . getReplyQosSettings (  )  )  ;", "assertEquals ( true ,    container . isSubscriptionDurable (  )  )  ;", "assertEquals (  \" client -  1  2  3  4  \"  ,    container . getClientId (  )  )  ;", "assertEquals ( false ,    container . isAutoStartup (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDefaultJmsConfig"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultJmsListenerContainerFactory   factory    =    new   DefaultJmsListenerContainerFactory (  )  ;", "BackOff   backOff    =    new   FixedBackOff (  )  ;", "factory . setBackOff ( backOff )  ;", "factory . setRecoveryInterval (  2  0  0  0 L )  ;", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "MessageListener   messageListener    =    new   MessageListenerAdapter (  )  ;", "endpoint . setMessageListener ( messageListener )  ;", "endpoint . setDestination (  \" myQueue \"  )  ;", "DefaultMessageListenerContainer   container    =    factory . createListenerContainer ( endpoint )  ;", "assertSame ( backOff ,    new   DirectFieldAccessor ( container )  . getPropertyValue (  \" backOff \"  )  )  ;", "}", "METHOD_END"], "methodName": ["backOffOverridesRecoveryInterval"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultJcaListenerContainerFactory   factory    =    new   DefaultJcaListenerContainerFactory (  )  ;", "setDefaultJcaConfig ( factory )  ;", "factory . setConcurrency (  \"  1  0  \"  )  ;", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "MessageListener   messageListener    =    new   MessageListenerAdapter (  )  ;", "endpoint . setMessageListener ( messageListener )  ;", "endpoint . setDestination (  \" myQueue \"  )  ;", "JmsMessageEndpointManager   container    =    factory . createListenerContainer ( endpoint )  ;", "assertDefaultJcaConfig ( container )  ;", "assertEquals (  1  0  ,    container . getActivationSpecConfig (  )  . getMaxConcurrency (  )  )  ;", "assertEquals ( messageListener ,    container . getMessageListener (  )  )  ;", "assertEquals (  \" myQueue \"  ,    container . getActivationSpecConfig (  )  . getDestinationName (  )  )  ;", "}", "METHOD_END"], "methodName": ["createJcaContainerFullConfig"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultJmsListenerContainerFactory   factory    =    new   DefaultJmsListenerContainerFactory (  )  ;", "setDefaultJmsConfig ( factory )  ;", "factory . setCacheLevel ( DefaultMessageListenerContainer . CACHE _ CONSUMER )  ;", "factory . setConcurrency (  \"  3  -  1  0  \"  )  ;", "factory . setMaxMessagesPerTask (  5  )  ;", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "MessageListener   messageListener    =    new   MessageListenerAdapter (  )  ;", "endpoint . setMessageListener ( messageListener )  ;", "endpoint . setDestination (  \" myQueue \"  )  ;", "DefaultMessageListenerContainer   container    =    factory . createListenerContainer ( endpoint )  ;", "assertDefaultJmsConfig ( container )  ;", "assertEquals ( DefaultMessageListenerContainer . CACHE _ CONSUMER ,    container . getCacheLevel (  )  )  ;", "assertEquals (  3  ,    container . getConcurrentConsumers (  )  )  ;", "assertEquals (  1  0  ,    container . getMaxConcurrentConsumers (  )  )  ;", "assertEquals (  5  ,    container . getMaxMessagesPerTask (  )  )  ;", "assertEquals ( messageListener ,    container . getMessageListener (  )  )  ;", "assertEquals (  \" myQueue \"  ,    container . getDestinationName (  )  )  ;", "}", "METHOD_END"], "methodName": ["createJmsContainerFullConfig"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SimpleJmsListenerContainerFactory   factory    =    new   SimpleJmsListenerContainerFactory (  )  ;", "setDefaultJmsConfig ( factory )  ;", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "MessageListener   messageListener    =    new   MessageListenerAdapter (  )  ;", "endpoint . setMessageListener ( messageListener )  ;", "endpoint . setDestination (  \" myQueue \"  )  ;", "SimpleMessageListenerContainer   container    =    factory . createListenerContainer ( endpoint )  ;", "assertDefaultJmsConfig ( container )  ;", "assertEquals ( messageListener ,    container . getMessageListener (  )  )  ;", "assertEquals (  \" myQueue \"  ,    container . getDestinationName (  )  )  ;", "}", "METHOD_END"], "methodName": ["createSimpleContainer"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultJmsListenerContainerFactory   factory    =    new   DefaultJmsListenerContainerFactory (  )  ;", "factory . setConcurrency (  \"  2  -  1  0  \"  )  ;", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "MessageListener   messageListener    =    new   MessageListenerAdapter (  )  ;", "endpoint . setMessageListener ( messageListener )  ;", "endpoint . setDestination (  \" myQueue \"  )  ;", "endpoint . setConcurrency (  \"  4  -  6  \"  )  ;", "DefaultMessageListenerContainer   container    =    factory . createListenerContainer ( endpoint )  ;", "assertEquals (  4  ,    container . getConcurrentConsumers (  )  )  ;", "assertEquals (  6  ,    container . getMaxConcurrentConsumers (  )  )  ;", "}", "METHOD_END"], "methodName": ["endpointConcurrencyTakesPrecedence"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultJcaListenerContainerFactory   factory    =    new   DefaultJcaListenerContainerFactory (  )  ;", "factory . setDestinationResolver ( this . destinationResolver )  ;", "factory . setActivationSpecFactory ( new   StubJmsActivationSpecFactory (  )  )  ;", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "endpoint . setMessageListener ( new   MessageListenerAdapter (  )  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "factory . createListenerContainer ( endpoint )  ;", "}", "METHOD_END"], "methodName": ["jcaExclusiveProperties"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "factory . setDestinationResolver ( this . destinationResolver )  ;", "factory . setTransactionManager ( this . transactionManager )  ;", "factory . setMessageConverter ( this . messageConverter )  ;", "factory . setAcknowledgeMode ( DUPS _ OK _ ACKNOWLEDGE )  ;", "factory . setPubSubDomain ( true )  ;", "factory . setReplyQosSettings ( new   QosSettings (  1  ,     7  ,     5  0  0  0  )  )  ;", "factory . setSubscriptionDurable ( true )  ;", "factory . setClientId (  \" client -  1  2  3  4  \"  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultJcaConfig"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "factory . setConnectionFactory ( this . connectionFactory )  ;", "factory . setDestinationResolver ( this . destinationResolver )  ;", "factory . setMessageConverter ( this . messageConverter )  ;", "factory . setSessionTransacted ( true )  ;", "factory . setSessionAcknowledgeMode ( DUPS _ OK _ ACKNOWLEDGE )  ;", "factory . setPubSubDomain ( true )  ;", "factory . setReplyPubSubDomain ( true )  ;", "factory . setReplyQosSettings ( new   QosSettings (  1  ,     7  ,     5  0  0  0  )  )  ;", "factory . setSubscriptionDurable ( true )  ;", "factory . setClientId (  \" client -  1  2  3  4  \"  )  ;", "factory . setAutoStartup ( false )  ;", "}", "METHOD_END"], "methodName": ["setDefaultJmsConfig"], "fileName": "org.springframework.jms.config.JmsListenerContainerFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   this . listenerContainers . get ( id )  ;", "}", "METHOD_END"], "methodName": ["getListenerContainer"], "fileName": "org.springframework.jms.config.JmsListenerContainerTestFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList <  >  ( this . listenerContainers . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getListenerContainers"], "fileName": "org.springframework.jms.config.JmsListenerContainerTestFactory"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.jms.config.JmsListenerContainerTestFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . endpointRegistry ;", "}", "METHOD_END"], "methodName": ["getEndpointRegistry"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "return   this . messageHandlerMethodFactory ;", "}", "METHOD_END"], "methodName": ["getMessageHandlerMethodFactory"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . endpointRegistry )     !  =    null )  ,     \" No   JmsListenerEndpointRegistry   set \"  )  ;", "synchronized ( this . mutex )     {", "for    (  . JmsListenerEndpointDescriptor   descriptor    :    this . endpointDescriptors )     {", "this . endpointRegistry . registerListenerContainer ( descriptor . endpoint ,    resolveContainerFactory ( descriptor )  )  ;", "}", "this . startImmediately    =    true ;", "}", "}", "METHOD_END"], "methodName": ["registerAllEndpoints"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "registerEndpoint ( endpoint ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerEndpoint"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( endpoint ,     \" Endpoint   must   not   be   null \"  )  ;", "Assert . hasText ( endpoint . getId (  )  ,     \" Endpoint   id   must   be   set \"  )  ;", ". JmsListenerEndpointDescriptor   descriptor    =    new    . JmsListenerEndpointDescriptor ( endpoint ,    factory )  ;", "synchronized ( this . mutex )     {", "if    ( this . startImmediately )     {", "Assert . state (  (  ( this . endpointRegistry )     !  =    null )  ,     \" No   JmsListenerEndpointRegistry   set \"  )  ;", "this . endpointRegistry . registerListenerContainer ( descriptor . endpoint ,    resolveContainerFactory ( descriptor )  ,    true )  ;", "} else    {", "this . endpointDescriptors . add ( descriptor )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerEndpoint"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    (  ( descriptor . containerFactory )     !  =    null )     {", "return   descriptor . containerFactory ;", "} else", "if    (  ( this . containerFactory )     !  =    null )     {", "return   this . containerFactory ;", "} else", "if    (  ( this . containerFactoryBeanName )     !  =    null )     {", "util . Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" BeanFactory   must   be   set   to   obtain   container   factory   by   bean   name \"  )  ;", "this . containerFactory    =    this . beanFactory . getBean ( this . containerFactoryBeanName ,    JmsListenerContainerFactory . class )  ;", "return   this . containerFactory ;", "} else    {", "throw   new   IllegalStateException (  (  (  (  (  \" Could   not   resolve   the    \"     +     ( JmsListenerContainerFactory . class . getSimpleName (  )  )  )     +     \"    to   use   for    [  \"  )     +     ( descriptor . endpoint )  )     +     \"  ]    no   factory   was   given   and   no   default   is   set .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveContainerFactory"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . containerFactory    =    containerFactory ;", "}", "METHOD_END"], "methodName": ["setContainerFactory"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . containerFactoryBeanName    =    containerFactoryBeanName ;", "}", "METHOD_END"], "methodName": ["setContainerFactoryBeanName"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . endpointRegistry    =    endpointRegistry ;", "}", "METHOD_END"], "methodName": ["setEndpointRegistry"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "this . messageHandlerMethodFactory    =    messageHandlerMethodFactory ;", "}", "METHOD_END"], "methodName": ["setMessageHandlerMethodFactory"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrar"}, {"methodBody": ["METHOD_START", "{", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "endpoint . setId (  \" myEndpoint \"  )  ;", "this . registrar . setContainerFactory ( this . containerFactory )  ;", "this . registrar . registerEndpoint ( endpoint )  ;", "this . registrar . afterPropertiesSet (  )  ;", "assertNotNull (  \" Container   not   created \"  ,    this . registry . getListenerContainer (  \" myEndpoint \"  )  )  ;", "assertEquals (  1  ,    this . registry . getListenerContainers (  )  . size (  )  )  ;", "assertEquals (  \" myEndpoint \"  ,    this . registry . getListenerContainerIds (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerContainerWithoutFactory"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "endpoint . setId (  \"  \"  )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . registrar . registerEndpoint ( endpoint ,    this . containerFactory )  ;", "}", "METHOD_END"], "methodName": ["registerEmptyEndpointId"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "endpoint . setId (  \" some   id \"  )  ;", "this . registrar . setContainerFactory ( this . containerFactory )  ;", "this . registrar . registerEndpoint ( endpoint ,    null )  ;", "this . registrar . afterPropertiesSet (  )  ;", "assertNotNull (  \" Container   not   created \"  ,    this . registry . getListenerContainer (  \" some   id \"  )  )  ;", "assertEquals (  1  ,    this . registry . getListenerContainers (  )  . size (  )  )  ;", "assertEquals (  \" some   id \"  ,    this . registry . getListenerContainerIds (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerNullContainerFactoryIsAllowed"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "endpoint . setId (  \" some   id \"  )  ;", "this . registrar . registerEndpoint ( endpoint ,    null )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage ( endpoint . toString (  )  )  ;", "this . registrar . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["registerNullContainerFactoryWithNoDefault"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . registrar . regist ( null ,    this . containerFactory )  ;", "}", "METHOD_END"], "methodName": ["registerNullEndpoint"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . registrar . registerEndpoint ( new   Simple (  )  ,    this . containerFactory )  ;", "}", "METHOD_END"], "methodName": ["registerNullEndpointId"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "this . registrar . setEndpointRegistry ( this . registry )  ;", "this . registrar . setBeanFactory ( new   StaticListableBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "MessageListenerContainer   listenerContainer    =    factory . createListenerContainer ( endpoint )  ;", "if    ( listenerContainer   instanceof   InitializingBean )     {", "try    {", "(  ( InitializingBean )     ( listenerContainer )  )  . afterPropertiesSet (  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   BeanInitializationException (  \" Failed   to   initialize   message   listener   container \"  ,    ex )  ;", "}", "}", "int   containerPhase    =    listenerContainer . getPhase (  )  ;", "if    ( containerPhase    <     ( Integer . MAX _ VALUE )  )     {", "if    (  (  ( this . phase )     <     ( Integer . MAX _ VALUE )  )     &  &     (  ( this . phase )     !  =    containerPhase )  )     {", "throw   new   IllegalStateException (  (  (  (  \" Encountered   phase   mismatch   between   container   factory   definitions :     \"     +     ( this . phase )  )     +     \"    vs    \"  )     +    containerPhase )  )  ;", "}", "this . phase    =    listenerContainer . getPhase (  )  ;", "}", "return   listenerContainer ;", "}", "METHOD_END"], "methodName": ["createListenerContainer"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( id ,     \" Container   identifier   must   not   be   null \"  )  ;", "return   this . lContainers . get ( id )  ;", "}", "METHOD_END"], "methodName": ["getListenerContainer"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . listenerContainers . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getListenerContainerIds"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableCollection ( this . listenerContainers . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getListenerContainers"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "registerListenerContainer ( endpoint ,    factory ,    false )  ;", "}", "METHOD_END"], "methodName": ["registerListenerContainer"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( endpoint ,     \" Endpoint   must   not   be   null \"  )  ;", "Assert . notNull ( factory ,     \" Factory   must   not   be   null \"  )  ;", "String   id    =    endpoint . getId (  )  ;", "Assert . hasText ( id ,     \" Endpoint   id   must   be   set \"  )  ;", "synchronized ( this . listenerContainers )     {", "if    ( this . listenerContainers . containsKey ( id )  )     {", "throw   new   IllegalStateException (  (  (  \" Another   endpoint   is   already   registered   with   id    '  \"     +    id )     +     \"  '  \"  )  )  ;", "}", "MessageListenerContainer   container    =    createListenerContainer ( endpoint ,    factory )  ;", "this . listenerContainers . put ( id ,    container )  ;", "if    ( startImmediately )     {", "startIfNecessary ( container )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerListenerContainer"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . contextRefreshed )     |  |     ( listenerContainer . isAutoStartup (  )  )  )     {", "listenerContainer . start (  )  ;", "}", "}", "METHOD_END"], "methodName": ["startIfNecessary"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistry"}, {"methodBody": ["METHOD_START", "{", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "endpoint . setId ( id )  ;", "endpoint . setDestination ( destinationName )  ;", "return   endpoint ;", "}", "METHOD_END"], "methodName": ["createEndpoint"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistryTests"}, {"methodBody": ["METHOD_START", "{", "registry . registerListenerContainer ( createEndpoint (  \" test \"  ,     \" queue \"  )  ,    containerFactory )  ;", "thrown . expect ( IllegalStateException . class )  ;", "registry . registerListenerContainer ( createEndpoint (  \" test \"  ,     \" queue \"  )  ,    containerFactory )  ;", "}", "METHOD_END"], "methodName": ["createWithDuplicateEndpointId"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistryTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "registry . registerContainer ( createEndpoint (  \" foo \"  ,     \" myDestination \"  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["createWithNullContainerFactory"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistryTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "registry . registerContainer ( null ,    containerFactory )  ;", "}", "METHOD_END"], "methodName": ["createWithNullEndpoint"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistryTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "registry . registerListenerContainer ( new   Simple (  )  ,    containerFactory )  ;", "}", "METHOD_END"], "methodName": ["createWithNullEndpointId"], "fileName": "org.springframework.jms.config.JmsListenerEndpointRegistryTests"}, {"methodBody": ["METHOD_START", "{", "SimpleMessageListenerContainer   container    =    new   SimpleMessageListenerContainer (  )  ;", "MessageListener   messageListener    =    new   MessageListenerAdapter (  )  ;", "Simple   endpoint    =    new   Simple (  )  ;", "endpoint . setConcurrency (  \"  5  -  1  0  \"  )  ;", "endpoint . setMessageListener ( messageListener )  ;", "endpoint . setupListenerContainer ( container )  ;", "assertEquals (  1  0  ,    new   DirectFieldAccessor ( container )  . getPropertyValue (  \" concurrentConsumers \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setupConcurrencySimpleContainer"], "fileName": "org.springframework.jms.config.JmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   container    =    new   JmsMessageEndpointManager (  )  ;", "MessageListener   messageListener    =    new   MessageListenerAdapter (  )  ;", "Simple   endpoint    =    new   Simple (  )  ;", "endpoint . setDestination (  \" myQueue \"  )  ;", "endpoint . setSelector (  \" foo    =     ' bar '  \"  )  ;", "endpoint . setSubscription (  \" mySubscription \"  )  ;", "endpoint . setConcurrency (  \"  1  0  \"  )  ;", "endpoint . setMessageListener ( messageListener )  ;", "endpoint . setupListenerContainer ( container )  ;", "JmsActivationSpecConfig   config    =    container . getActivationSpecConfig (  )  ;", "assertEquals (  \" myQueue \"  ,    config . getDestinationName (  )  )  ;", "assertEquals (  \" foo    =     ' bar '  \"  ,    config . getMessageSelector (  )  )  ;", "assertEquals (  \" mySubscription \"  ,    config . getSubscriptionName (  )  )  ;", "assertEquals (  1  0  ,    config . getMaxConcurrency (  )  )  ;", "assertEquals ( messageListener ,    container . getMessageListener (  )  )  ;", "}", "METHOD_END"], "methodName": ["setupJcaMessageContainerFullConfig"], "fileName": "org.springframework.jms.config.JmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   container    =    new   DefaultMessageListenerContainer (  )  ;", "MessageListener   messageListener    =    new   MessageListenerAdapter (  )  ;", "Simple   endpoint    =    new   Simple (  )  ;", "endpoint . setDestination (  \" myQueue \"  )  ;", "endpoint . setSelector (  \" foo    =     ' bar '  \"  )  ;", "endpoint . setSubscription (  \" mySubscription \"  )  ;", "endpoint . setConcurrency (  \"  5  -  1  0  \"  )  ;", "endpoint . setMessageListener ( messageListener )  ;", "endpoint . setupListenerContainer ( container )  ;", "assertEquals (  \" myQueue \"  ,    container . getDestinationName (  )  )  ;", "assertEquals (  \" foo    =     ' bar '  \"  ,    container . getMessageSelector (  )  )  ;", "assertEquals (  \" mySubscription \"  ,    container . getSubscriptionName (  )  )  ;", "assertEquals (  5  ,    container . getConcurrentConsumers (  )  )  ;", "assertEquals (  1  0  ,    container . getMaxConcurrentConsumers (  )  )  ;", "assertEquals ( messageListener ,    container . getMessageListener (  )  )  ;", "}", "METHOD_END"], "methodName": ["setupJmsMessageContainerFullConfig"], "fileName": "org.springframework.jms.config.JmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   container    =    new   DefaultMessageListenerContainer (  )  ;", "Simple   endpoint    =    new   Simple (  )  ;", "thrown . expect ( IllegalStateException . class )  ;", "endpoint . setupListenerContainer ( container )  ;", "}", "METHOD_END"], "methodName": ["setupMessageContainerNoListener"], "fileName": "org.springframework.jms.config.JmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessageListenerContainer   container    =    mock ( MessageListenerContainer . class )  ;", "Simple   endpoint    =    new   Simple (  )  ;", "endpoint . setMessageListener ( new   MessageListenerAdapter (  )  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "endpoint . setupListenerContainer ( container )  ;", "}", "METHOD_END"], "methodName": ["setupMessageContainerUnsupportedContainer"], "fileName": "org.springframework.jms.config.JmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "endpoint . setMessageListener ( new   MessageListenerAdapter (  )  )  ;", "endpoint . setDestination (  \" testQueue \"  )  ;", "return   endpoint ;", "}", "METHOD_END"], "methodName": ["createDummyEndpoint"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   container    =    this . context . getBean ( containerBeanName ,    DefaultMessageListenerContainer . class )  ;", "return    (  ( BackOff )     ( new   DirectFieldAccessor ( container )  . getPropertyValue (  \" backOff \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getBackOff"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   container    =    this . context . getBean ( containerBeanName ,    DefaultMessageListenerContainer . class )  ;", "return    (  ( Error )     ( new   DirectFieldAccessor ( container )  . getPropertyValue (  \" error \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getErrorHandler"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   container    =    this . context . getBean ( containerBeanName ,    DefaultMessageListenerContainer . class )  ;", "return    (  ( MessageListener )     ( container . getMessageListener (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getListener"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Object   container    =    this . context . getBean ( containerBeanName )  ;", "if    (  !  ( container   instanceof   Phased )  )     {", "throw   new   IllegalStateException (  (  (  \" Container    '  \"     +    containerBeanName )     +     \"  '    does   not   implement   Phased .  \"  )  )  ;", "}", "return    (  ( Phased )     ( container )  )  . getPhase (  )  ;", "}", "METHOD_END"], "methodName": ["getPhase"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BackOff   backOff    =    getBackOff ( containerBeanName )  ;", "assertEquals ( FixedBackOff . class ,    backOff . getClass (  )  )  ;", "return    (  ( FixedBackOff )     ( backOff )  )  . getInterval (  )  ;", "}", "METHOD_END"], "methodName": ["getRecoveryInterval"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   JmsNamespaceHandlerTests . ToolingTestApplicationContext (  \" jmsNamespaceHandlerTests . xml \"  ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . context . close (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,     ?  >    containers    =    context . getBeansOfType ( DefaultMessageListenerContainer . class )  ;", "assertEquals (  \" Context   should   contain    3    JMS   listener   containers \"  ,     3  ,    containers . size (  )  )  ;", "containers    =    context . getBeansOfType ( GenericMessageEndpointManager . class )  ;", "assertEquals (  \" Context   should   contain    3    JCA   endpoint   containers \"  ,     3  ,    containers . size (  )  )  ;", "Map < String ,    JmsListenerContainerFactory >    containerFactories    =    context . getBeansOfType ( JmsListenerContainerFactory . class )  ;", "assertEquals (  \" Context   should   contain    3    JmsListenerContainerFactory   instances \"  ,     3  ,    containerFactories . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeansCreated"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Parser   should   have   registered   a   component   named    ' listener 1  '  \"  ,    context . containsComponentDefinition (  \" listener 1  \"  )  )  ;", "assertTrue (  \" Parser   should   have   registered   a   component   named    ' listener 2  '  \"  ,    context . containsComponentDefinition (  \" listener 2  \"  )  )  ;", "assertTrue (  \" Parser   should   have   registered   a   component   named    ' listener 3  '  \"  ,    context . containsComponentDefinition (  \" listener 3  \"  )  )  ;", "assertTrue (  (  (  \" Parser   should   have   registered   a   component   named    '  \"     +     ( DefaultMessageListenerContainer . class . getName (  )  )  )     +     \"  #  0  '  \"  )  ,    context . containsComponentDefinition (  (  ( DefaultMessageListenerContainer . class . getName (  )  )     +     \"  #  0  \"  )  )  )  ;", "assertTrue (  (  (  \" Parser   should   have   registered   a   component   named    '  \"     +     ( JmsMessageEndpointManager . class . getName (  )  )  )     +     \"  #  0  '  \"  )  ,    context . containsComponentDefinition (  (  ( JmsMessageEndpointManager . class . getName (  )  )     +     \"  #  0  \"  )  )  )  ;", "assertTrue (  \" Parser   should   have   registered   a   component   named    ' testJmsFactory \"  ,    context . containsComponentDefinition (  \" testJmsFactory \"  )  )  ;", "assertTrue (  \" Parser   should   have   registered   a   component   named    ' testJcaFactory \"  ,    context . containsComponentDefinition (  \" testJcaFactory \"  )  )  ;", "assertTrue (  \" Parser   should   have   registered   a   component   named    ' testJcaFactory \"  ,    context . containsComponentDefinition (  \" onlyJmsFactory \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testComponentRegistration"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   listener 0     =    this . context . getBean (  (  ( DefaultMessageListenerContainer . class . getName (  )  )     +     \"  #  0  \"  )  ,    DefaultMessageListenerContainer . class )  ;", "DefaultMessageListenerContainer   listener 1     =    this . context . getBean (  \" listener 1  \"  ,    DefaultMessageListenerContainer . class )  ;", "DefaultMessageListenerContainer   listener 2     =    this . context . getBean (  \" listener 2  \"  ,    DefaultMessageListenerContainer . class )  ;", "assertEquals (  \" Wrong   concurrency   on   listener   using   placeholder \"  ,     2  ,    listener 0  . getConcurrentConsumers (  )  )  ;", "assertEquals (  \" Wrong   concurrency   on   listener   using   placeholder \"  ,     3  ,    listener 0  . getMaxConcurrentConsumers (  )  )  ;", "assertEquals (  \" Wrong   concurrency   on   listener 1  \"  ,     3  ,    listener 1  . getConcurrentConsumers (  )  )  ;", "assertEquals (  \" Wrong   max   concurrency   on   listener 1  \"  ,     5  ,    listener 1  . getMaxConcurrentConsumers (  )  )  ;", "assertEquals (  \" Wrong   custom   concurrency   on   listener 2  \"  ,     5  ,    listener 2  . getConcurrentConsumers (  )  )  ;", "assertEquals (  \" Wrong   custom   max   concurrency   on   listener 2  \"  ,     1  0  ,    listener 2  . getMaxConcurrentConsumers (  )  )  ;", "JmsMessageEndpointManager   listener 3     =    this . context . getBean (  \" listener 3  \"  ,    JmsMessageEndpointManager . class )  ;", "JmsMessageEndpointManager   listener 4     =    this . context . getBean (  \" listener 4  \"  ,    JmsMessageEndpointManager . class )  ;", "assertEquals (  \" Wrong   concurrency   on   listener 3  \"  ,     5  ,    listener 3  . getActivationSpecConfig (  )  . getMaxConcurrency (  )  )  ;", "assertEquals (  \" Wrong   custom   concurrency   on   listener 4  \"  ,     7  ,    listener 4  . getActivationSpecConfig (  )  . getMaxConcurrency (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConcurrency"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    DefaultMessageListenerContainer >    containers    =    context . getBeansOfType ( DefaultMessageListenerContainer . class )  ;", "ConnectionFactory   defaultConnectionFactory    =    context . getBean (  . DEFAULT _ CONNECTION _ FACTORY ,    ConnectionFactory . class )  ;", "ConnectionFactory   explicitConnectionFactory    =    context . getBean (  . EXPLICIT _ CONNECTION _ FACTORY ,    ConnectionFactory . class )  ;", "int   defaultConnectionFactoryCount    =     0  ;", "int   explicitConnectionFactoryCount    =     0  ;", "for    ( DefaultMessageListenerContainer   container    :    containers . values (  )  )     {", "if    ( container . getConnectionFactory (  )  . equals ( defaultConnectionFactory )  )     {", "defaultConnectionFactoryCount +  +  ;", "} else", "if    ( container . getConnectionFactory (  )  . equals ( explicitConnectionFactory )  )     {", "explicitConnectionFactoryCount +  +  ;", "}", "}", "assertEquals (  \"  1    container   should   have   the   default   connectionFactory \"  ,     1  ,    defaultConnectionFactoryCount )  ;", "assertEquals (  \"  2    containers   should   have   the   explicit   connectionFactory \"  ,     2  ,    explicitConnectionFactoryCount )  ;", "}", "METHOD_END"], "methodName": ["testContainerConfiguration"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ErrorHandler   expected    =    this . context . getBean (  \" testErrorHandler \"  ,    ErrorHandler . class )  ;", "ErrorHandler   errorHandler 1     =    getErrorHandler (  \" listener 1  \"  )  ;", "ErrorHandler   errorHandler 2     =    getErrorHandler (  \" listener 2  \"  )  ;", "ErrorHandler   defaultErrorHandler    =    getErrorHandler (  (  ( DefaultMessageListenerContainer . class . getName (  )  )     +     \"  #  0  \"  )  )  ;", "assertSame ( expected ,    errorHandler 1  )  ;", "assertSame ( expected ,    errorHandler 2  )  ;", "assertNull ( defaultErrorHandler )  ;", "}", "METHOD_END"], "methodName": ["testErrorHandlers"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    JmsMessageEndpointManager >    containers    =    context . getBeansOfType ( JmsMessageEndpointManager . class )  ;", "assertTrue (  \" listener 3    not   found \"  ,    containertainsKey (  \" listener 3  \"  )  )  ;", "JmsMessageEndpointManager   listener 3     =    containers . get (  \" listener 3  \"  )  ;", "assertEquals (  \" Wrong   resource   adapter \"  ,    context . getBean (  \" testResourceAdapter \"  )  ,    listener 3  . getResourceAdapter (  )  )  ;", "assertEquals (  \" Wrong   activation   spec   factory \"  ,    context . getBean (  \" testActivationSpecFactory \"  )  ,    new   DirectFieldAccessor ( listener 3  )  . getPropertyValue (  \" activationSpecFactory \"  )  )  ;", "Object   endpointFactory    =    new   DirectFieldAccessor ( listener 3  )  . getPropertyValue (  \" endpointFactory \"  )  ;", "Object   messageListener    =    new   DirectFieldAccessor ( endpointFactory )  . getPropertyValue (  \" messageListener \"  )  ;", "assertEquals (  \" Wrong   message   listener \"  ,    MessageListenerAdapter . class ,    messageListener . getClass (  )  )  ;", "MessageListenerAdapter   adapter    =     (  ( MessageListenerAdapter )     ( messageListener )  )  ;", "DirectFieldAccessor   adapterFieldAccessor    =    new   DirectFieldAccessor ( adapter )  ;", "assertEquals (  \" Message   converter   not   set   properly \"  ,    context . getBean (  \" testMessageConverter \"  )  ,    adapterFieldAccessor . getPropertyValue (  \" messageConverter \"  )  )  ;", "assertEquals (  \" Wrong   delegate \"  ,    context . getBean (  \" testBean 1  \"  )  ,    adapterFieldAccessor . getPropertyValue (  \" delegate \"  )  )  ;", "assertEquals (  \" Wrong   method   name \"  ,     \" setName \"  ,    adapterFieldAccessor . getPropertyValue (  \" defaultListenerMethod \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testJcaContainerConfiguration"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    DefaultJcaListenerContainerFactory >    containers    =    context . getBeansOfType ( DefaultJcaListenerContainerFactory . class )  ;", "DefaultJcaListenerContainerFactory   factory    =    containers . get (  \" testJcaFactory \"  )  ;", "assertNotNull (  \" No   factory   registered   with   testJcaFactory   id \"  ,    factory )  ;", "JmsMessageEndpointManager   container    =    factory . createListenerContainer ( createDummyEndpoint (  )  )  ;", "assertEquals (  \" explicit   resource   adapter   not   set \"  ,    context . getBean (  \" testResourceAdapter \"  )  ,    container . getResourceAdapter (  )  )  ;", "assertEquals (  \" explicit   message   converter   not   set \"  ,    context . getBean (  \" testMessageConverter \"  )  ,    container . getActivationSpecC (  )  . getMessageConverter (  )  )  ;", "assertEquals (  \" Wrong   pub / sub \"  ,    true ,    container . isPubSubDomain (  )  )  ;", "assertEquals (  \" wrong   concurrency \"  ,     5  ,    container . getActivationSpecC (  )  . getMaxConcurrency (  )  )  ;", "assertEquals (  \" Wrong   prefetch \"  ,     5  0  ,    container . getActivationSpecC (  )  . getPrefetchSize (  )  )  ;", "assertEquals (  \" Wrong   phase \"  ,     7  7  ,    container . getPhase (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJcaContainerFactoryConfiguration"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    DefaultJmsListenerContainerFactory >    containers    =    context . getBeansOfType ( DefaultJmsListenerContainerFactory . class )  ;", "DefaultJmsListenerContainerFactory   factory    =    containers . get (  \" testJmsFactory \"  )  ;", "assertNotNull (  \" No   factory   registered   with   testJmsFactory   id \"  ,    factory )  ;", "DefaultMessageListenerContainer   container    =    factory . createListenerContainer ( createDummyEndpoint (  )  )  ;", "assertEquals (  \" explicit   connection   factory   not   set \"  ,    context . getBean (  . EXPLICIT _ CONNECTION _ FACTORY )  ,    container . getConnectionFactory (  )  )  ;", "assertEquals (  \" explicit   destination   resolver   not   set \"  ,    context . getBean (  \" testDestinationResolver \"  )  ,    container . getDestinationResolver (  )  )  ;", "assertEquals (  \" explicit   message   converter   not   set \"  ,    context . getBean (  \" testMessageConverter \"  )  ,    container . getMessageConverter (  )  )  ;", "assertEquals (  \" Wrong   pub / sub \"  ,    true ,    container . isPubSubDomain (  )  )  ;", "assertEquals (  \" Wrong   durable   flag \"  ,    true ,    container . isSubscriptionDurable (  )  )  ;", "assertEquals (  \" wrong   cache \"  ,    DefaultMessageListenerContainer . CACHE _ CONNECTION ,    container . getCacheLevel (  )  )  ;", "assertEquals (  \" wrong   concurrency \"  ,     3  ,    container . getConcurrentConsumers (  )  )  ;", "assertEquals (  \" wrong   concurrency \"  ,     5  ,    container . getMaxConcurrentConsumers (  )  )  ;", "assertEquals (  \" wrong   prefetch \"  ,     5  0  ,    container . getMaxMessagesPerTask (  )  )  ;", "assertEquals (  \" Wrong   phase \"  ,     9  9  ,    container . getPhase (  )  )  ;", "assertSame ( context . getBean (  \" testBackOff \"  )  ,    new   DirectFieldAccessor ( container )  . getPropertyValue (  \" backOff \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testJmsContainerFactoryConfiguration"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   testBean 1     =    context . getBean (  \" testBean 1  \"  ,    TestBean . class )  ;", "TestBean   testBean 2     =    context . getBean (  \" testBean 2  \"  ,    TestBean . class )  ;", ". TestMessageListener   testBean 3     =    context . getBean (  \" testBean 3  \"  ,     . TestMessageListener . class )  ;", "assertNull ( testBean 1  . getName (  )  )  ;", "assertNull ( testBean 2  . getName (  )  )  ;", "assertNull ( testBean 3  . message )  ;", "TextMessage   message 1     =    mock ( TextMessage . class )  ;", "given ( message 1  . getText (  )  )  . willReturn (  \" Test 1  \"  )  ;", "MessageListener   listener 1     =    getListener (  \" listener 1  \"  )  ;", "listener 1  . onMessage ( message 1  )  ;", "assertEquals (  \" Test 1  \"  ,    testBean 1  . getName (  )  )  ;", "TextMessage   message 2     =    mock ( TextMessage . class )  ;", "given ( message 2  . getText (  )  )  . willReturn (  \" Test 2  \"  )  ;", "MessageListener   listener 2     =    getListener (  \" listener 2  \"  )  ;", "listener 2  . onMessage ( message 2  )  ;", "assertEquals (  \" Test 2  \"  ,    testBean 2  . getName (  )  )  ;", "TextMessage   message 3     =    mock ( TextMessage . class )  ;", "MessageListener   listener 3     =    getListener (  (  ( DefaultMessageListenerContainer . class . getName (  )  )     +     \"  #  0  \"  )  )  ;", "listener 3  . onMessage ( message 3  )  ;", "assertSame ( message 3  ,    testBean 3  . message )  ;", "}", "METHOD_END"], "methodName": ["testListeners"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "int   phase 1     =    getPhase (  \" listener 1  \"  )  ;", "int   phase 2     =    getPhase (  \" listener 2  \"  )  ;", "int   phase 3     =    getPhase (  \" listener 3  \"  )  ;", "int   phase 4     =    getPhase (  \" listener 4  \"  )  ;", "int   defaultPhase    =    getPhase (  (  ( DefaultMessageListenerContainer . class . get (  )  )     +     \"  #  0  \"  )  )  ;", "assertEquals (  9  9  ,    phase 1  )  ;", "assertEquals (  9  9  ,    phase 2  )  ;", "assertEquals (  7  7  ,    phase 3  )  ;", "assertEquals (  7  7  ,    phase 4  )  ;", "assertEquals ( Integer . MAX _ VALUE ,    defaultPhase )  ;", "}", "METHOD_END"], "methodName": ["testPhases"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Object   testBackOff    =    context . getBean (  \" testBackOff \"  )  ;", "BackOff   backOff 1     =    getBackOff (  \" listener 1  \"  )  ;", "BackOff   backOff 2     =    getBackOff (  \" listener 2  \"  )  ;", "long   recoveryInterval 3     =    getRecoveryInterval (  (  ( DefaultMessageListenerContainer . class . get (  )  )     +     \"  #  0  \"  )  )  ;", "assertSame ( testBackOff ,    backOff 1  )  ;", "assertSame ( testBackOff ,    backOff 2  )  ;", "assertEquals ( DefaultMessageListenerContainer . DEFAULT _ RECOVERY _ INTERVAL ,    recoveryInterval 3  )  ;", "}", "METHOD_END"], "methodName": ["testRecoveryInterval"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   listener 1     =    this . context . getBean (  \" listener 1  \"  ,    DefaultMessageListenerContainer . class )  ;", "DefaultMessageListenerContainer   listener 2     =    this . context . getBean (  \" listener 2  \"  ,    DefaultMessageListenerContainer . class )  ;", "assertEquals (  \" Wrong   destination   type   on   listener 1  \"  ,    true ,    listener 1  . isPubSubDomain (  )  )  ;", "assertEquals (  \" Wrong   destination   type   on   listener 2  \"  ,    true ,    listener 2  . isPubSubDomain (  )  )  ;", "assertEquals (  \" Wrong   response   destination   type   on   listener 1  \"  ,    false ,    listener 1  . isReplyPubSubDomain (  )  )  ;", "assertEquals (  \" Wrong   response   destination   type   on   listener 2  \"  ,    false ,    listener 2  . isReplyPubSubDomain (  )  )  ;", "JmsMessageEndpointManager   listener 3     =    this . context . getBean (  \" listener 3  \"  ,    JmsMessageEndpointManager . class )  ;", "JmsMessageEndpointManager   listener 4     =    this . context . getBean (  \" listener 4  \"  ,    JmsMessageEndpointManager . class )  ;", "assertEquals (  \" Wrong   destination   type   on   listener 3  \"  ,    true ,    listener 3  . isPubSubDomain (  )  )  ;", "assertEquals (  \" Wrong   destination   type   on   listener 4  \"  ,    true ,    listener 4  . isPubSubDomain (  )  )  ;", "assertEquals (  \" Wrong   response   destination   type   on   listener 3  \"  ,    false ,    listener 3  . isReplyPubSubDomain (  )  )  ;", "assertEquals (  \" Wrong   response   destination   type   on   listener 4  \"  ,    false ,    listener 4  . isReplyPubSubDomain (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResponseDestination"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Iterator < ComponentDefinition >    iterator    =    context . getRegisteredComponents (  )  ;", "while    ( iterator . hasNext (  )  )     {", "ComponentDefinition   compDef    =    iterator . next (  )  ;", "assertNotNull (  (  (  \" CompositeComponentDefinition    '  \"     +     ( compDef . get (  )  )  )     +     \"  '    has   no   source   attachment \"  )  ,    compDef . getSource (  )  )  ;", "validateComponentDefinition ( compDef )  ;", "}", "}", "METHOD_END"], "methodName": ["testSourceExtraction"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition [  ]    beanDefs    =    compDef . getBeanDefinitions (  )  ;", "for    ( BeanDefinition   beanDef    :    beanDefs )     {", "assertNotNull (  \" BeanDefinition   has   no   source   attachment \"  ,    beanDef . getSource (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateComponentDefinition"], "fileName": "org.springframework.jms.config.JmsNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . endpoint ;", "}", "METHOD_END"], "methodName": ["getEndpoint"], "fileName": "org.springframework.jms.config.MessageListenerTestContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . startInvoked )     &  &     ( this . initializationInvoked )  ;", "}", "METHOD_END"], "methodName": ["isStarted"], "fileName": "org.springframework.jms.config.MessageListenerTestContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . stopInvoked )     &  &     ( this . destroyInvoked )  ;", "}", "METHOD_END"], "methodName": ["isStopped"], "fileName": "org.springframework.jms.config.MessageListenerTestContainer"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.jms.config.MessageListenerTestContainer"}, {"methodBody": ["METHOD_START", "{", "return   new   MessagingMessageListenerAdapter (  )  ;", "}", "METHOD_END"], "methodName": ["createMessageListenerInstance"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "return   this . bean ;", "}", "METHOD_END"], "methodName": ["getBean"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "Method   specificMethod    =    getMostSpecificMethod (  )  ;", "if    ( specificMethod    =  =    null )     {", "return   null ;", "}", "SendTo   ann    =    getSendTo ( specificMethod )  ;", "if    ( ann    !  =    null )     {", "Object [  ]    destinations    =    ann . value (  )  ;", "if    (  ( destinations . length )     !  =     1  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Invalid    @  \"     +     ( SendTo . class . getSimpleName (  )  )  )     +     \"    annotation   on    '  \"  )     +    specificMethod )     +     \"  '    one   destination   must   be   set    ( got    \"  )     +     ( Arrays . toString ( destinations )  )  )     +     \"  )  \"  )  )  ;", "}", "return   resolve (  (  ( String )     ( destinations [  0  ]  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultResponseDestination"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . mostSpecificMethod )     !  =    null )     {", "return   this . mostSpecificMethod ;", "}", "Method   method    =    getMethod (  )  ;", "if    ( method    !  =    null )     {", "Object   bean    =    getBean (  )  ;", "if    ( AopUtils . isAopProxy ( bean )  )     {", "Class <  ?  >    targetClass    =    AopProxyUtils . ultimateTargetClass ( bean )  ;", "method    =    AopUtils . getMostSpecificMethod ( method ,    targetClass )  ;", "}", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["getMostSpecificMethod"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "SendTo   ann    =    AnnotatedElementUtils . findMergedAnnotation ( specificMethod ,    SendTo . class )  ;", "if    ( ann    =  =    null )     {", "ann    =    AnnotatedElementUtils . findMergedAnnotation ( specificMethod . getDeclaringClass (  )  ,    SendTo . class )  ;", "}", "return   ann ;", "}", "METHOD_END"], "methodName": ["getSendTo"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "return    ( this . embeddedValueResolver )     !  =    null    ?    this . embeddedValueResolver . resolveStringValue ( value )     :    value ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . bean    =    bean ;", "}", "METHOD_END"], "methodName": ["setBean"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . embeddedValueResolver    =    embeddedValueResolver ;", "}", "METHOD_END"], "methodName": ["setEmbeddedValueResolver"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . messageHandlerMethodFactory    =    messageHandlerMethodFactory ;", "}", "METHOD_END"], "methodName": ["setMessageHandlerMethodFactory"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . method    =    method ;", "}", "METHOD_END"], "methodName": ["setMethod"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . mostSpecificMethod    =    mostSpecificMethod ;", "}", "METHOD_END"], "methodName": ["setMostSpecificMethod"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "assertListenerMethodInvocation ( this . sample ,    this . name . getMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDefaultListenerMethodInvocation"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  (  \" Method    \"     +    methodName )     +     \"    should   have   been   invoked \"  )  ,    bean . invocations . get ( methodName )  )  ;", "}", "METHOD_END"], "methodName": ["assertListenerMethodInvocation"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "return   createInstance ( this . factory ,    getDefaultListenerMethod ( parameterTypes )  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultInstance"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "return   createInstance ( factory ,    method ,    new   SimpleMessageListenerContainer (  )  )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MethodJmsListenerEndpoint   endpoint    =    new   MethodJmsListenerEndpoint (  )  ;", "endpoint . setBean ( this . sample )  ;", "endpoint . setMethod ( method )  ;", "endpoint . setMessageHandlerMethodFactory ( factory )  ;", "return   endpoint . createMessageListener ( container )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MethodJmsListenerEndpoint   endpoint    =    new   MethodJmsListenerEndpoint (  )  ;", "endpoint . setBean ( this )  ;", "endpoint . setMethod ( getTestMethod (  )  )  ;", "endpoint . setMessageHandlerMethodFactory ( this . factory )  ;", "assertNotNull ( endpoint . createMessageListener ( this . container )  )  ;", "}", "METHOD_END"], "methodName": ["createMessageListener"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MethodJmsListenerEndpoint   endpoint    =    new   MethodJmsListenerEndpoint (  )  ;", "endpoint . setBean ( this )  ;", "endpoint . setMethod ( getTestMethod (  )  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "endpoint . createMessageListener ( this . container )  ;", "}", "METHOD_END"], "methodName": ["createMessageListenerNoFactory"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "return   new   StubTextMessage ( body )  ;", "}", "METHOD_END"], "methodName": ["createSimpleJmsTextMessage"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( String . class )  ;", "TextMessage   reply    =    mock ( TextMessage . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createTextMessage (  \" content \"  )  )  . willReturn ( reply )  ;", "this . thrown . expect ( ReplyFailureException . class )  ;", "this . thrown . expectCause ( Matchers . isA ( InvalidDestinationException . class )  )  ;", "listener . onMessage ( createSimpleJmsTextMessage (  \" content \"  )  ,    session )  ;", "}", "METHOD_END"], "methodName": ["emptySendTo"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "return   getListenerMethod ( this . name . getMethodName (  )  ,    parameterTypes )  ;", "}", "METHOD_END"], "methodName": ["getDefaultListenerMethod"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( MethodJmsListenerEndpointTests . JmsEndpointSampleBean . class ,    methodName ,    parameterTypes )  ;", "assertNotNull (  (  (  (  \" no   method   found   with   name    \"     +    methodName )     +     \"    and   parameters    \"  )     +     ( Arrays . toString ( parameterTypes )  )  )  )  ;", "return   method ;", "}", "METHOD_END"], "methodName": ["getListenerMethod"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtils . findMethod ( MethodJmsListenerEndpointTests . class ,    this . name . getMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTestMethod"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "factory . setBeanFactory ( new   StaticListableBeanFactory (  )  )  ;", "factory . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["initializeFactory"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( Message . class )  ;", "Session   session    =    mock ( Session . class )  ;", "this . thrown . expect ( xecutionFailedException . class )  ;", "this . thrown . expectCause ( Matchers . isA ( MessageConversionException . class )  )  ;", "listener . onMessage ( createSimpleJmsTextMessage (  \" test \"  )  ,    session )  ;", "}", "METHOD_END"], "methodName": ["invalidMessagePayloadType"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( Integer . class )  ;", "Session   session    =    mock ( Session . class )  ;", "this . thrown . expect ( xecutionFailedException . class )  ;", "this . thrown . expectCause ( Matchers . isA ( MessageConversionException . class )  )  ;", "this . thrown . expectMessage ( getDefaultListenerMethod ( Integer . class )  . toGenericString (  )  )  ;", "listener . onMessage ( createSimpleJmsTextMessage (  \" test \"  )  ,    session )  ;", "}", "METHOD_END"], "methodName": ["invalidPayloadType"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" firstDestination \"  )  ;", "this . thrown . expectMessage (  \" secondDestination \"  )  ;", "createDefaultInstance ( St . class )  ;", "}", "METHOD_END"], "methodName": ["invalidSendTo"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( String . class )  ;", "String   body    =     \" echo   text \"  ;", "String   correlationId    =     \" link -  1  2  3  4  \"  ;", "Destination   replyDestination    =    new   Destination (  )     {  }  ;", "TextMessage   reply    =    mock ( TextMessage . class )  ;", "QueueSender   queueSender    =    mock ( QueueSender . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createTextMessage ( body )  )  . willReturn ( reply )  ;", "given ( session . createProducer ( replyDestination )  )  . willReturn ( queueSender )  ;", "listener . setDefaultResponseDestination ( replyDestination )  ;", "StubTextMessage   inputMessage    =    createSimpleJmsTextMessage ( body )  ;", "inputMessage . setJMSCorrelationID ( correlationId )  ;", "listener . onMessage ( inputMessage ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "verify ( reply )  . setJMSCorrelationID ( correlationId )  ;", "verify ( queueSender )  . send ( reply )  ;", "verify ( queueSender )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["processAndReply"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" processAndReplyWithSendTo \"  ;", "SimpleMessageContainer   container    =    new   SimpleMessageContainer (  )  ;", "QosSettings   replyQosSettings    =    new   QosSettings (  1  ,     6  ,     6  0  0  0  )  ;", "container . setReplyQosSettings ( replyQosSettings )  ;", "MessagingMessageAdapter   listener    =    createInstance ( this . factory ,    getMethod ( methodName ,    String . class )  ,    container )  ;", "processAndReplyWithSendTo ( listener ,     \" replyDestination \"  ,    false ,    replyQosSettings )  ;", "assertMethodInvocation ( this . sample ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["processAndReplyWithCustomReplyQosSettings"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( String . class )  ;", "processAndReplyWithSendTo ( listener ,     \" defaultReply \"  ,    false )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["processAndReplyWithDefaultSendTo"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" processAndReplyWithSendTo \"  ;", "SimpleMessageContainer   container    =    new   SimpleMessageContainer (  )  ;", "container . setReplyQosSettings ( null )  ;", "MessagingMessageAdapter   listener    =    createInstance ( this . factory ,    getMethod ( methodName ,    String . class )  ,    container )  ;", "processAndReplyWithSendTo ( listener ,     \" replyDestination \"  ,    false )  ;", "assertMethodInvocation ( this . sample ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["processAndReplyWithNullReplyQosSettings"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "processAndReplyWithSendTo ( listener ,    replyDestinationName ,    pubSubDomain ,    null )  ;", "}", "METHOD_END"], "methodName": ["processAndReplyWithSendTo"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \" echo   text \"  ;", "String   correlationId    =     \" link -  1  2  3  4  \"  ;", "Destination   replyDestination    =    new   Destination (  )     {  }  ;", "DestinationResolver   destinationResolver    =    mock ( DestinationResolver . class )  ;", "TextMessage   reply    =    mock ( TextMessage . class )  ;", "QueueSender   queueSender    =    mock ( QueueSender . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( destinationResolver . resolveDestinationName ( session ,    replyDestinationName ,    pubSubDomain )  )  . willReturn ( replyDestination )  ;", "given ( session . createTextMessage ( body )  )  . willReturn ( reply )  ;", "given ( session . createProducer ( replyDestination )  )  . willReturn ( queueSender )  ;", "l . setDestinationResolver ( destinationResolver )  ;", "StubTextMessage   inputMessage    =    createSimpleJmsTextMessage ( body )  ;", "inputMessage . setJMSCorrelationID ( correlationId )  ;", "l . onMessage ( inputMessage ,    session )  ;", "verify ( destinationResolver )  . resolveDestinationName ( session ,    replyDestinationName ,    pubSubDomain )  ;", "verify ( reply )  . setJMSCorrelationID ( correlationId )  ;", "if    ( replyQosSettings    !  =    null )     {", "verify ( queueSender )  . send ( reply ,    replyQosSettings . getDeliveryMode (  )  ,    replyQosSettings . getPriority (  )  ,    replyQosSettings . getTimeToLive (  )  )  ;", "} else    {", "verify ( queueSender )  . send ( reply )  ;", "}", "verify ( queueSender )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["processAndReplyWithSendTo"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" processAndReplyWithSendTo \"  ;", "SimpleMessageContainer   container    =    new   SimpleMessageContainer (  )  ;", "MessagingMessageAdapter   listener    =    createInstance ( this . factory ,    getMethod ( methodName ,    String . class )  ,    container )  ;", "processAndReplyWithSendTo ( listener ,     \" replyDestination \"  ,    false )  ;", "assertMethodInvocation ( this . sample ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["processAndReplyWithSendToQueue"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" processAndReplyWithSendTo \"  ;", "SimpleMessageContainer   container    =    new   SimpleMessageContainer (  )  ;", "container . setPubSubDomain ( true )  ;", "MessagingMessageAdapter   listener    =    createInstance ( this . factory ,    getMethod ( methodName ,    String . class )  ,    container )  ;", "processAndReplyWithSendTo ( listener ,     \" replyDestination \"  ,    true )  ;", "assertMethodInvocation ( this . sample ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["processAndReplyWithSendToTopic"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" processAndReplyWithSendTo \"  ;", "SimpleMessageContainer   container    =    new   SimpleMessageContainer (  )  ;", "container . setReplyPubSubDomain ( true )  ;", "MessagingMessageAdapter   listener    =    createInstance ( this . factory ,    getMethod ( methodName ,    String . class )  ,    container )  ;", "processAndReplyWithSendTo ( listener ,     \" replyDestination \"  ,    true )  ;", "assertMethodInvocation ( this . sample ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["processFromQueueAndReplyWithSendToTopic"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" processAndReplyWithSendTo \"  ;", "SimpleMessageContainer   container    =    new   SimpleMessageContainer (  )  ;", "container . setPubSubDomain ( true )  ;", "container . setReplyPubSubDomain ( false )  ;", "MessagingMessageAdapter   listener    =    createInstance ( this . factory ,    getMethod ( methodName ,    String . class )  ,    container )  ;", "processAndReplyWithSendTo ( listener ,     \" replyDestination \"  ,    false )  ;", "assertMethodInvocation ( this . sample ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["processFromTopicAndReplyWithSendToQueue"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( Integer . class )  ;", "Session   session    =    mock ( Session . class )  ;", "listener . onMessage ( createSimpleJmsTextMessage (  \"  3  3  \"  )  ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveConvertedPayload"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( String . class ,    int . class )  ;", "Session   session    =    mock ( Session . class )  ;", "StubTextMessage   message    =    createSimpleJmsTextMessage (  \" my   payload \"  )  ;", "message . setIntProperty (  \" myCounter \"  ,     2  4  )  ;", "listener . onMessage ( message ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveCustomHeaderNameAndPayload"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( String . class ,    int . class )  ;", "Session   session    =    mock ( Session . class )  ;", "StubTextMessage   message    =    createSimpleJmsTextMessage (  \" my   payload \"  )  ;", "message . setIntProperty (  \" myCounter \"  ,     2  4  )  ;", "listener . onMessage ( message ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveCustomHeaderNameAndPayloadWithHeaderNameSet"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( Message . class )  ;", "Session   session    =    mock ( Session . class )  ;", "listener . onMessage ( createSimpleJmsTextMessage (  \" test \"  )  ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveGenericMessage"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( String . class ,    int . class )  ;", "Session   session    =    mock ( Session . class )  ;", "StubTextMessage   message    =    createSimpleJmsTextMessage (  \" my   payload \"  )  ;", "message . setIntProperty (  \" myCounter \"  ,     5  5  )  ;", "listener . onMessage ( message ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveHeaderAndPayload"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( String . class ,    Map . class )  ;", "Session   session    =    mock ( Session . class )  ;", "StubTextMessage   message    =    createSimpleJmsTextMessage (  \" my   payload \"  )  ;", "message . setIntProperty (  \" customInt \"  ,     1  2  3  4  )  ;", "message . setJMSMessageID (  \" abcd -  1  2  3  4  \"  )  ;", "listener . onMessage ( message ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveHeaders"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( JmsMessageHeaderAccessor . class )  ;", "Session   session    =    mock ( Session . class )  ;", "StubTextMessage   message    =    createSimpleJmsTextMessage (  \" my   payload \"  )  ;", "message . setBooleanProperty (  \" customBoolean \"  ,    true )  ;", "message . setJMSPriority (  9  )  ;", "listener . onMessage ( message ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveJmsMessageHeaderAccessor"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( Message . class ,    Session . class )  ;", "Session   session    =    mock ( Session . class )  ;", "listener . onMessage ( createSimpleJmsTextMessage (  \" test \"  )  ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveMessageAndSession"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( MessageHeaders . class )  ;", "Session   session    =    mock ( Session . class )  ;", "StubTextMessage   message    =    createSimpleJmsTextMessage (  \" my   payload \"  )  ;", "message . setLongProperty (  \" customLong \"  ,     4  5  6  7 L )  ;", "message . setJMSType (  \" myMessageType \"  )  ;", "listener . onMessage ( message ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveMessageHeaders"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   listener    =    createDefaultInstance ( MethodJmsListenerEndpointTests . MyBean . class )  ;", "MethodJmsListenerEndpointTests . MyBean   myBean    =    new   MethodJmsListenerEndpointTests . MyBean (  )  ;", "myBean . name    =     \" myBean   name \"  ;", "Session   session    =    mock ( Session . class )  ;", "ObjectMessage   message    =    mock ( ObjectMessage . class )  ;", "given ( message . getObject (  )  )  . willReturn ( myBean )  ;", "listener . onMessage ( message ,    session )  ;", "assertDefaultListenerMethodInvocation (  )  ;", "}", "METHOD_END"], "methodName": ["resolveObjectPayload"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "DestinationResolver   destinationResolver    =    mock ( DestinationResolver . class )  ;", "this . container . setMessageConverter ( messageConverter )  ;", "this . container . setDestinationResolver ( destinationResolver )  ;", "MessagingMessageListenerAdapter   listener    =    createInstance ( this . factory ,    getListenerMethod (  \" resolveObjectPayload \"  ,     . MyBean . class )  ,    this . container )  ;", "DirectFieldAccessor   accessor    =    new   DirectFieldAccessor ( listener )  ;", "assertSame ( messageConverter ,    accessor . getPropertyValue (  \" messageConverter \"  )  )  ;", "assertSame ( destinationResolver ,    accessor . getPropertyValue (  \" destinationResolver \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setExtraCollaborators"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "initializeFactory ( this . factory )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Validator (  )     {", "@ Override", "public   boolean   supports ( Class <  ?  >    clazz )     {", "return   St . class . isAssignableFrom ( clazz )  ;", "}", "@ Override", "public   void   validate (  @ Nullable", "Object   target ,    Errors   errors )     {", "St   value    =     (  ( St )     ( target )  )  ;", "if    ( invalidValue . equals ( value )  )     {", "errors . reject (  \" not   a   valid   value \"  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["testValidator"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageHandlerMethodFactory   customFactory    =    new   DefaultMessageHandlerMethodFactory (  )  ;", "customFactory . setValidator ( testValidator (  \" invalid   value \"  )  )  ;", "Method   method    =    getListenerMethod (  \" validatePayload \"  ,    String . class )  ;", "MessagingMessageListenerAdapter   listener    =    createInstance ( customFactory ,    method )  ;", "Session   session    =    mock ( Session . class )  ;", "this . thrown . expect ( xecutionFailedException . class )  ;", "listener . onMessage ( createSimpleJmsTextMessage (  \" invalid   value \"  )  ,    session )  ;", "}", "METHOD_END"], "methodName": ["validatePayloadInvalid"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =     \" validatePayload \"  ;", "DefaultMessageHandlerMethodFactory   customFactory    =    new   DefaultMessageHandlerMethodFactory (  )  ;", "customFactory . setValidator ( testValidator (  \" invalid   value \"  )  )  ;", "initializeFactory ( customFactory )  ;", "Method   method    =    getMethod ( methodName ,    String . class )  ;", "MessagingMessageAdapter   listener    =    createInstance ( customFactory ,    method )  ;", "Session   session    =    mock ( Session . class )  ;", "listener . onMessage ( createSimpleJmsTextMessage (  \" test \"  )  ,    session )  ;", "assertMethodInvocation ( this . sample ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["validatePayloadValid"], "fileName": "org.springframework.jms.config.MethodJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "return   this . messageListener ;", "}", "METHOD_END"], "methodName": ["getMessageListener"], "fileName": "org.springframework.jms.config.SimpleJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "this . messageListener    =    messageListener ;", "}", "METHOD_END"], "methodName": ["setMessageListener"], "fileName": "org.springframework.jms.config.SimpleJmsListenerEndpoint"}, {"methodBody": ["METHOD_START", "{", "SimpleJmsListenerEndpoint   endpoint    =    new   SimpleJmsListenerEndpoint (  )  ;", "MessageListener   messageListener    =    new   MessageListenerAdapter (  )  ;", "endpoint . setMessageListener ( messageListener )  ;", "assertSame ( messageListener ,    endpoint . createMessageListener ( container )  )  ;", "}", "METHOD_END"], "methodName": ["createListener"], "fileName": "org.springframework.jms.config.SimpleJmsListenerEndpointTests"}, {"methodBody": ["METHOD_START", "{", "return   this . target . getDeliveryDelay (  )  ;", "}", "METHOD_END"], "methodName": ["getDeliveryDelay"], "fileName": "org.springframework.jms.connection.CachedMessageProducer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . originalDeliveryDelay )     =  =    null )     {", "this . originalDeliveryDelay    =    this . target . getDeliveryDelay (  )  ;", "}", "this . target . setDeliveryDelay ( deliveryDelay )  ;", "}", "METHOD_END"], "methodName": ["setDeliveryDelay"], "fileName": "org.springframework.jms.connection.CachedMessageProducer"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    classes    =    new   ArrayList <  >  (  3  )  ;", "classes . add ( SessionProxy . class )  ;", "if    ( target   instanceof   QueueSession )     {", "classes . add ( QueueSession . class )  ;", "}", "if    ( target   instanceof   TopicSession )     {", "classes . add ( TopicSession . class )  ;", "}", "return    (  ( Session )     ( Proxy . newProxyInstance ( SessionProxy . class . getClassLoader (  )  ,    ClassUtils . toClassArray ( classes )  ,    new    . CachedSessionInvocationHandler ( target ,    sessionList )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCachedSessionProxy"], "fileName": "org.springframework.jms.connection.CachingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionCacheSize ;", "}", "METHOD_END"], "methodName": ["getSessionCacheSize"], "fileName": "org.springframework.jms.connection.CachingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheConsumers ;", "}", "METHOD_END"], "methodName": ["isCacheConsumers"], "fileName": "org.springframework.jms.connection.CachingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheProducers ;", "}", "METHOD_END"], "methodName": ["isCacheProducers"], "fileName": "org.springframework.jms.connection.CachingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "this . cacheConsumers    =    cacheConsumers ;", "}", "METHOD_END"], "methodName": ["setCacheConsumers"], "fileName": "org.springframework.jms.connection.CachingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "this . cacheProducers    =    cacheProducers ;", "}", "METHOD_END"], "methodName": ["setCacheProducers"], "fileName": "org.springframework.jms.connection.CachingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( sessionCacheSize    >  =     1  )  ,     \" Session   cache   size   must   be    1    or   higher \"  )  ;", "this . sessionCacheSize    =    sessionCacheSize ;", "}", "METHOD_END"], "methodName": ["setSessionCacheSize"], "fileName": "org.springframework.jms.connection.CachingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( listener ,     \" ExceptionListener   must   not   be   null \"  )  ;", "this . delegates . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["addDelegate"], "fileName": "org.springframework.jms.connection.ChainedExceptionListener"}, {"methodBody": ["METHOD_START", "{", "return   this . delegates . toArray ( new   ExceptionListener [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getDelegates"], "fileName": "org.springframework.jms.connection.ChainedExceptionListener"}, {"methodBody": ["METHOD_START", "{", "return   ConnectionFactoryUtils . doGetTransactionalSession ( connectionFactory ,    resourceFactory ,    true )  ;", "}", "METHOD_END"], "methodName": ["doGetTransactionalSession"], "fileName": "org.springframework.jms.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( connectionFactory ,     \" ConnectionFactory   must   not   be   null \"  )  ;", "Assert . notNull ( resourceFactory ,     \" ResourceFactory   must   not   be   null \"  )  ;", "JmsResourceHolder   resourceHolder    =     (  ( JmsResourceHolder )     ( TransactionSynchronizationManager . getResource ( connectionFactory )  )  )  ;", "if    ( resourceHolder    !  =    null )     {", "Session   session    =    resourceFactory . getSession ( resourceHolder )  ;", "if    ( session    !  =    null )     {", "if    ( startConnection )     {", "Connection   con    =    resourceFactory . getConnection ( resourceHolder )  ;", "if    ( con    !  =    null )     {", "con . start (  )  ;", "}", "}", "return   session ;", "}", "if    ( resourceHolder . isFrozen (  )  )     {", "return   null ;", "}", "}", "if    (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )     {", "return   null ;", "}", "JmsResourceHolder   resourceHolderToUse    =    resourceHolder ;", "if    ( resourceHolderToUse    =  =    null )     {", "resourceHolderToUse    =    new   JmsResourceHolder ( connectionFactory )  ;", "}", "Connection   con    =    resourceFactory . getConnection ( resourceHolderToUse )  ;", "Session   session    =    null ;", "try    {", "boolean   isExistingCon    =    con    !  =    null ;", "if    (  ! isExistingCon )     {", "con    =    resourceFactory . createConnection (  )  ;", "resourceHolderToUse . addConnection ( con )  ;", "}", "session    =    resourceFactory . createSession ( con )  ;", "resourceHolderToUse . addSession ( session ,    con )  ;", "if    ( startConnection )     {", "con . start (  )  ;", "}", "}    catch    ( JMSException   ex )     {", "if    ( session    !  =    null )     {", "try    {", "session . close (  )  ;", "}    catch    ( Throwable   ex 2  )     {", "}", "}", "if    ( con    !  =    null )     {", "try    {", "con . close (  )  ;", "}    catch    ( Throwable   ex 2  )     {", "}", "}", "throw   ex ;", "}", "if    ( resourceHolderToUse    !  =    resourceHolder )     {", "TransactionSynchronizationManager . registerSynchronization ( new    . JmsResourceSynchronization ( resourceHolderToUse ,    connectionFactory ,    resourceFactory . isSynchedLocalTransactionAllowed (  )  )  )  ;", "resourceHolderToUse . setSynchronizedWithTransaction ( true )  ;", "TransactionSynchronizationManager . bindResource ( connectionFactory ,    resourceHolderToUse )  ;", "}", "return   session ;", "}", "METHOD_END"], "methodName": ["doGetTransactionalSession"], "fileName": "org.springframework.jms.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Session   sessionToUse    =    session ;", "while    ( sessionToUse   instanceof   SessionProxy )     {", "sessionToUse    =     (  ( SessionProxy )     ( sessionToUse )  )  . getTargetSession (  )  ;", "}", "return   sessionToUse ;", "}", "METHOD_END"], "methodName": ["getTargetSession"], "fileName": "org.springframework.jms.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( QueueSession )     ( ConnectionFactoryUtils . doGetTransactionalSession ( cf ,    new   ConnectionFactoryUtils . ResourceFactory (  )     {", "@ Override", "@ Nullable", "public   Session   getSession ( JmsResourceHolder   holder )     {", "return   holder . getSession ( QueueSession . class ,    existingCon )  ;", "}", "@ Override", "@ Nullable", "public   Connection   getConnection ( JmsResourceHolder   holder )     {", "return   existingCon    !  =    null    ?    existingCon    :    holder . getConnection ( QueueConnection . class )  ;", "}", "@ Override", "public   Connection   createConnection (  )    throws   JMSException    {", "return   cf . createQueueConnection (  )  ;", "}", "@ Override", "public   Session   createSession ( Connection   con )    throws   JMSException    {", "return    (  ( QueueConnection )     ( con )  )  . createQueueSession ( synchedLocalTransactionAllowed ,    AUTO _ ACKNOWLEDGE )  ;", "}", "@ Override", "public   boolean   isSynchedLocalTransactionAllowed (  )     {", "return   synchedLocalTransactionAllowed ;", "}", "}  ,    true )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionalQueueSession"], "fileName": "org.springframework.jms.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return   ConnectionFactoryUtils . doGetTransactionalSession ( cf ,    new   ConnectionFactoryUtils . ResourceFactory (  )     {", "@ Override", "@ Nullable", "public   Session   getSession ( JmsResourceHolder   holder )     {", "return   holder . getSession ( Session . class ,    existingCon )  ;", "}", "@ Override", "@ Nullable", "public   Connection   getConnection ( JmsResourceHolder   holder )     {", "return   existingCon    !  =    null    ?    existingCon    :    holder . getConnection (  )  ;", "}", "@ Override", "public   Connection   createConnection (  )    throws   JMSException    {", "return   cf . createConnection (  )  ;", "}", "@ Override", "public   Session   createSession ( Connection   con )    throws   JMSException    {", "return   con . createSession ( synchedLocalTransactionAllowed ,    AUTO _ ACKNOWLEDGE )  ;", "}", "@ Override", "public   boolean   isSynchedLocalTransactionAllowed (  )     {", "return   synchedLocalTransactionAllowed ;", "}", "}  ,    true )  ;", "}", "METHOD_END"], "methodName": ["getTransactionalSession"], "fileName": "org.springframework.jms.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( TopicSession )     ( ConnectionFactoryUtils . doGetTransactionalSession ( cf ,    new   ConnectionFactoryUtils . ResourceFactory (  )     {", "@ Override", "@ Nullable", "public   Session   getSession ( JmsResourceHolder   holder )     {", "return   holder . getSession ( TopicSession . class ,    existingCon )  ;", "}", "@ Override", "@ Nullable", "public   Connection   getConnection ( JmsResourceHolder   holder )     {", "return   existingCon    !  =    null    ?    existingCon    :    holder . getConnection ( TopicConnection . class )  ;", "}", "@ Override", "public   Connection   createConnection (  )    throws   JMSException    {", "return   cf . createTopicConnection (  )  ;", "}", "@ Override", "public   Session   createSession ( Connection   con )    throws   JMSException    {", "return    (  ( TopicConnection )     ( con )  )  . createTopicSession ( synchedLocalTransactionAllowed ,    AUTO _ ACKNOWLEDGE )  ;", "}", "@ Override", "public   boolean   isSynchedLocalTransactionAllowed (  )     {", "return   synchedLocalTransactionAllowed ;", "}", "}  ,    true )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionalTopicSession"], "fileName": "org.springframework.jms.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( session    =  =    null )     |  |     ( cf    =  =    null )  )     {", "return   false ;", "}", "JmsResourceHolder   resourceHolder    =     (  ( JmsResourceHolder )     ( TransaSynchronizationManager . getResource ( cf )  )  )  ;", "return    ( resourceHolder    !  =    null )     &  &     ( resourceHolder . containsSession ( session )  )  ;", "}", "METHOD_END"], "methodName": ["isSessionTransactional"], "fileName": "org.springframework.jms.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( con    =  =    null )     {", "return ;", "}", "if    (  ( started    &  &     ( cf   instanceof   SmartConnectionFactory )  )     &  &     (  (  ( SmartConnectionFactory )     ( cf )  )  . shouldStop ( con )  )  )     {", "try    {", "con . stop (  )  ;", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Could   not   stop   JMS   Connection   before   closing   it \"  ,    ex )  ;", "}", "}", "try    {", "con . close (  )  ;", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Could   not   close   JMS   Connection \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["releaseConnection"], "fileName": "org.springframework.jms.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . targetConnectionFactory ;", "}", "METHOD_END"], "methodName": ["getTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.DelegatingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   target    =    getTargetConnectionFactory (  )  ;", "Assert . state (  ( target    !  =    null )  ,     \" No    ' targetConnectionFactory '    set \"  )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["obtainTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.DelegatingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "this . shouldStopConnections    =    shouldStopConnections ;", "}", "METHOD_END"], "methodName": ["setShouldStopConnections"], "fileName": "org.springframework.jms.connection.DelegatingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "this . targetConnectionFactory    =    targetConnectionFactory ;", "}", "METHOD_END"], "methodName": ["setTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.DelegatingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  !  ( this . frozen )  )  ,     \" Cannot   add   Connection   because   JmsResourceHolder   is   frozen \"  )  ;", "Assert . notNull ( connection ,     \" Connection   must   not   be   null \"  )  ;", "if    (  !  ( this . connections . contains ( connection )  )  )     {", "this . connections . add ( connection )  ;", "}", "}", "METHOD_END"], "methodName": ["addConnection"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "addSession ( session ,    null )  ;", "}", "METHOD_END"], "methodName": ["addSession"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  !  ( this . frozen )  )  ,     \" Cannot   add   Session   because   JmsResourceHolder   is   frozen \"  )  ;", "Assert . notNull ( session ,     \" Session   must   not   be   null \"  )  ;", "if    (  !  ( this . sessions . contains ( session )  )  )     {", "this . sessions . add ( session )  ;", "if    ( connection    !  =    null )     {", "List < Session >    sessions    =    this . sessionsPerConnection . computeIfAbsent ( connection ,     (    k )     -  >    new   LinkedList <  >  (  )  )  ;", "sessions . add ( session )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addSession"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "for    ( Session   session    :    this . sessions )     {", "try    {", "session . close (  )  ;", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Could   not   close   synchronized   JMS   Session   after   transaction \"  ,    ex )  ;", "}", "}", "for    ( Connection   con    :    this . connections )     {", "ConnectionFactoryUtils . releaseConnection ( con ,    this . connectionFactory ,    true )  ;", "}", "this . connections . clear (  )  ;", "this . sessions . clear (  )  ;", "this . sessionsPerConnection . clear (  )  ;", "}", "METHOD_END"], "methodName": ["closeAll"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "for    ( Session   session    :    this . sessions )     {", "try    {", "session . commit (  )  ;", "}    catch    ( TransactionInProgressException   ex )     {", "}    catch    ( jms   ex )     {", "if    (  ( this . connectionFactory )     !  =    null )     {", "try    {", "Method   getDataSourceMethod    =    this . connectionFactory . getClass (  )  . getMethod (  \" getDataSource \"  )  ;", "Object   ds    =    ReflectionUtils . invokeMethod ( getDataSourceMethod ,    this . connectionFactory )  ;", "while    ( ds    !  =    null )     {", "if    ( TransactionSynchronizationManager . hasResource ( ds )  )     {", "return ;", "}", "try    {", "Method   getTargetDataSourceMethod    =    ds . getClass (  )  . getMethod (  \" getTargetDataSource \"  )  ;", "ds    =    ReflectionUtils . invokeMethod ( getTargetDataSourceMethod ,    ds )  ;", "}    catch    ( NoSuchMethodException   nsme )     {", "ds    =    null ;", "}", "}", "}    catch    ( Throwable   ex 2  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" No   working   getDataSource   method   found   on   ConnectionFactory :     \"     +    ex 2  )  )  ;", "}", "}", "}", "throw   ex ;", "}", "}", "}", "METHOD_END"], "methodName": ["commitAll"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . sessions . contains ( session )  ;", "}", "METHOD_END"], "methodName": ["containsSession"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . connections . isEmpty (  )  )     ?    this . connections . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . findValueOfType ( this . connections ,    connectionType )  ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . sessions . isEmpty (  )  )     ?    this . sessions . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "return   getSession ( sessionType ,    null )  ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "List < Session >    sessions    =     ( connection    !  =    null )     ?    this . sessionsPerConnection . get ( connection )     :    this . sessions ;", "return   CollectionUtils . findValueOfType ( sessions ,    sessionType )  ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . frozen ;", "}", "METHOD_END"], "methodName": ["isFrozen"], "fileName": "org.springframework.jms.connection.JmsResourceHolder"}, {"methodBody": ["METHOD_START", "{", "return   obtainConnectionFactory (  )  . createConnection (  )  ;", "}", "METHOD_END"], "methodName": ["createConnection"], "fileName": "org.springframework.jms.connection.JmsTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   con . createSession ( true ,    AUTO _ ACKNOWLEDGE )  ;", "}", "METHOD_END"], "methodName": ["createSession"], "fileName": "org.springframework.jms.connection.JmsTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . connectionFactory ;", "}", "METHOD_END"], "methodName": ["getConnectionFactory"], "fileName": "org.springframework.jms.connection.JmsTransactionManager"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getConnectionFactory (  )  ;", "Assert . state (  ( connectionFactory    !  =    null )  ,     \" No   ConnectionFactory   set \"  )  ;", "return   connectionFactory ;", "}", "METHOD_END"], "methodName": ["obtainConnectionFactory"], "fileName": "org.springframework.jms.connection.JmsTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cf    !  =    null )     &  &     ( cf   instanceof   TransactionAwareConnectionFactoryProxy )  )     {", "thiFactory    =     (  ( TransactionAwareConnectionFactoryProxy )     ( cf )  )  . getTargetConnectionFactory (  )  ;", "} else    {", "thiFactory    =    cf ;", "}", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jms.connection.JmsTransactionManager"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "final   Session   session    =    mock ( Session . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "given ( con . createSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( session )  ;", "tm    =    new    ( cf )  ;", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "final   JmsTemplate   jt    =    new   JmsTemplate ( cf )  ;", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "}", "}  )  ;", "tm . commit ( ts )  ;", "verify ( session )  . commit (  )  ;", "verify ( session )  . close (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testParticipatingTransactionWithCommit"], "fileName": "org.springframework.jms.connection.JmsTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "final   Session   session    =    mock ( Session . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "given ( con . createSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( session )  ;", "tm    =    new    ( cf )  ;", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "final   JmsTemplate   jt    =    new   JmsTemplate ( cf )  ;", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "try    {", "tm . commit ( ts )  ;", "fail (  \" Should   have   thrown   UnexpectedRollbackException \"  )  ;", "}    catch    ( UnexpectedRollbackException   ex )     {", "}", "verify ( session )  . rollback (  )  ;", "verify ( session )  . close (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testParticipatingTransactionWithRollbackOnly"], "fileName": "org.springframework.jms.connection.JmsTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "final   Session   session    =    mock ( Session . class )  ;", "final   Session   session 2     =    mock ( Session . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "given ( con . createSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( session )  ;", "given ( con . createSession ( false ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( session 2  )  ;", "tm    =    new    ( cf )  ;", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "final   JmsTemplate   jt    =    new   JmsTemplate ( cf )  ;", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NOT _ SUPPORTED )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    !  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "}", "}  )  ;", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "tm . commit ( ts )  ;", "verify ( session )  . commit (  )  ;", "verify ( session )  . close (  )  ;", "verify ( session 2  )  . close (  )  ;", "verify ( con ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSuspendedTransaction"], "fileName": "org.springframework.jms.connection.JmsTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "final   Session   session    =    mock ( Session . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "given ( con . createSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( session )  ;", "tm    =    new    ( cf )  ;", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "JmsTemplate   jt    =    new   JmsTemplate ( cf )  ;", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "tm . commit ( ts )  ;", "verify ( session )  . commit (  )  ;", "verify ( session )  . close (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionCommit"], "fileName": "org.springframework.jms.connection.JmsTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "Destination   dest    =    new   StubQueue (  )  ;", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "Session   session    =    mock ( Session . class )  ;", "MessageProducer   producer    =    mock ( MessageProducer . class )  ;", "final   Message   message    =    mock ( Message . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "given ( con . createSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( session )  ;", "given ( session . createProducer ( dest )  )  . willReturn ( producer )  ;", "given ( session . getTransacted (  )  )  . willReturn ( true )  ;", "tm    =    new    ( cf )  ;", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "JmsTemplate   jt    =    new   JmsTemplate ( cf )  ;", "jt . send ( dest ,    new   MessageCreator (  )     {", "@ Override", "public   Message   createMessage ( Session   session )    throws   JMSException    {", "return   message ;", "}", "}  )  ;", "tm . commit ( ts )  ;", "verify ( producer )  . send ( message )  ;", "verify ( session )  . commit (  )  ;", "verify ( producer )  . close (  )  ;", "verify ( session )  . close (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionCommitWithMessageProducer"], "fileName": "org.springframework.jms.connection.JmsTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "final   Session   session    =    mock ( Session . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "given ( con . createSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( session )  ;", "tm    =    new    ( cf )  ;", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "JmsTemplate   jt    =    new   JmsTemplate ( cf )  ;", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "tm . rollback ( ts )  ;", "verify ( session )  . rollback (  )  ;", "verify ( session )  . close (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionRollback"], "fileName": "org.springframework.jms.connection.JmsTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "final   Session   session    =    mock ( Session . class )  ;", "final   Session   session 2     =    mock ( Session . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "given ( con . createSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( session ,    session 2  )  ;", "tm    =    new    ( cf )  ;", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "final   JmsTemplate   jt    =    new   JmsTemplate ( cf )  ;", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    !  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "}", "}  )  ;", "jt . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   sess )     {", "assertTrue (  ( sess    =  =    session )  )  ;", "return   null ;", "}", "}  )  ;", "tm . commit ( ts )  ;", "verify ( session )  . commit (  )  ;", "verify ( session 2  )  . commit (  )  ;", "verify ( session )  . close (  )  ;", "verify ( session 2  )  . close (  )  ;", "verify ( con ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionSuspension"], "fileName": "org.springframework.jms.connection.JmsTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TransactionSynchronizationManager . getResourceMap (  )  . isEmpty (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyTransactionSynchronizationManagerState"], "fileName": "org.springframework.jms.connection.JmsTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Closing   shared   JMS    :     \"     +    con )  )  ;", "}", "try    {", "try    {", "if    (  ( this . startedCount )     >     0  )     {", "con . stop (  )  ;", "}", "}    finally    {", "con . close (  )  ;", "}", "}    catch    ( jms   ex )     {", "logger . debug (  (  \" Ignoring      state   exception    -    assuming   already   closed :     \"     +    ex )  )  ;", "}    catch    ( Throwable   ex )     {", "logger . debug (  \" Could   not   close   shared   JMS    \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["closeConnection"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "boolean   transacted    =    mode    =  =     ( Session . SESSION _ TRANSACTED )  ;", "int   ackMode    =     ( transacted )     ?    Session . AUTO _ ACKNOWLEDGE    :    mode ;", "if    (  ( Boolean . FALSE . equals ( this . pubSubMode )  )     &  &     ( con   instanceof   Queu )  )     {", "return    (  ( Queu )     ( con )  )  . createQueueSession ( transacted ,    ackMode )  ;", "} else", "if    (  ( Boolean . TRUE . equals ( this . pubSubMode )  )     &  &     ( con   instanceof   TopicConnection )  )     {", "return    (  ( TopicConnection )     ( con )  )  . createTopicSession ( transacted ,    ackMode )  ;", "} else    {", "return   con . createSession ( transacted ,    ackMode )  ;", "}", "}", "METHOD_END"], "methodName": ["createSession"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    getTargetConnectionFactory (  )  ;", "if    (  ( Boolean . FALSE . equals ( this . pubSubMode )  )     &  &     ( cf   instanceof   Queu )  )     {", "return    (  ( Queu )     ( cf )  )  . createQueueConnection (  )  ;", "} else", "if    (  ( Boolean . TRUE . equals ( this . pubSubMode )  )     &  &     ( cf   instanceof   TopicConnectionFactory )  )     {", "return    (  ( TopicConnectionFactory )     ( cf )  )  . createTopicConnection (  )  ;", "} else    {", "return   obtainTargetConnectionFactory (  )  . createConnection (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doCreateConnection"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . clientId ;", "}", "METHOD_END"], "methodName": ["getClientId"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . connectionMonitor )     {", "if    (  ( this . connection )     =  =    null )     {", "initConnection (  )  ;", "}", "return   this . connection ;", "}", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . exceptionListener ;", "}", "METHOD_END"], "methodName": ["getExceptionListener"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    classes    =    new   ArrayList <  >  (  3  )  ;", "classes . add ( Connection . class )  ;", "if    ( target   instanceof   QueueConnection )     {", "classes . add ( QueueConnection . class )  ;", "}", "if    ( target   instanceof   TopicConnection )     {", "classes . add ( TopicConnection . class )  ;", "}", "return    (  ( Connection )     ( Proxy . newProxyInstance ( Connection . class . getClassLoader (  )  ,    ClassUtils . toClassArray ( classes )  ,    new    . SharedConnectionInvocationHandler (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSharedConnectionProxy"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . targetConnectionFactory ;", "}", "METHOD_END"], "methodName": ["getTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getTargetConnectionFactory (  )  )     =  =    null )     {", "throw   new   IllegalStateException (  \"  ' targetConnectionFactory '    is   required   for   lazily   initializing   a   Connection \"  )  ;", "}", "synchronized ( this . connectionMonitor )     {", "if    (  ( this . connection )     !  =    null )     {", "closeConnection ( this . connection )  ;", "}", "this . connection    =    doCreateConnection (  )  ;", "prepareConnection ( this . connection )  ;", "if    (  ( this . startedCount )     >     0  )     {", "this . connection . start (  )  ;", "}", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Established   shared   JMS   Connection :     \"     +     ( this . connection )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initConnection"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . reconnectOnException ;", "}", "METHOD_END"], "methodName": ["isReconnectOnException"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   target    =    getTargetConnectionFactory (  )  ;", "Assert . state (  ( target    !  =    null )  ,     \"  ' targetConnectionFactory '    is   required \"  )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["obtainTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getClientId (  )  )     !  =    null )     {", "con . setClientID ( getClientId (  )  )  ;", "}", "if    (  ( this . aggregatedExceptionListener )     !  =    null )     {", "con . setExceptionListener ( this . aggregatedExceptionListener )  ;", "} else", "if    (  (  ( getExceptionListener (  )  )     !  =    null )     |  |     ( isReconnectOnException (  )  )  )     {", "ExceptionListener   listenerToUse    =    getExceptionListener (  )  ;", "if    ( isReconnectOnException (  )  )     {", "this . aggregatedExceptionListener    =    new    . AggregatedExceptionListener (  )  ;", "this . aggregatedExceptionListener . delegates . add ( this )  ;", "if    ( listenerToUse    !  =    null )     {", "this . aggregatedExceptionListener . delegates . add ( listenerToUse )  ;", "}", "listenerToUse    =    this . aggregatedExceptionListener ;", "}", "con . setExceptionListener ( listenerToUse )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareConnection"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . connectionMonitor )     {", "if    (  ( this . connection )     !  =    null )     {", "closeConnection ( this . connection )  ;", "}", "this . connection    =    null ;", "}", "}", "METHOD_END"], "methodName": ["resetConnection"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "this . clientId    =    clientId ;", "}", "METHOD_END"], "methodName": ["setClientId"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "this . exceptionListener    =    exceptionListener ;", "}", "METHOD_END"], "methodName": ["setExceptionListener"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "this . reconnectOnException    =    reconnectOnException ;", "}", "METHOD_END"], "methodName": ["setReconnectOnException"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "this . targetConnectionFactory    =    targetConnectionFactory ;", "}", "METHOD_END"], "methodName": ["setTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "Session   txSession    =    mock ( Session . class )  ;", "Session   nonTxSession    =    mock ( Session . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "given ( con . createSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( txSession )  ;", "given ( txSession . getTransacted (  )  )  . willReturn ( true )  ;", "given ( con . createSession ( false ,    CLIENT _ ACKNOWLEDGE )  )  . willReturn ( nonTxSession )  ;", "CachingConnectionFactory   scf    =    new   CachingConnectionFactory ( cf )  ;", "scf . setReconnectOnException ( false )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "Session   session 1     =    con 1  . createSession ( true ,    AUTO _ ACKNOWLEDGE )  ;", "session 1  . getTransacted (  )  ;", "session 1  . close (  )  ;", "session 1     =    con 1  . createSession ( false ,    CLIENT _ ACKNOWLEDGE )  ;", "session 1  . close (  )  ;", "con 1  . start (  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "Session   session 2     =    con 2  . createSession ( false ,    CLIENT _ ACKNOWLEDGE )  ;", "session 2  . close (  )  ;", "session 2     =    con 2  . createSession ( true ,    AUTO _ ACKNOWLEDGE )  ;", "session 2  . commit (  )  ;", "session 2  . close (  )  ;", "con 2  . start (  )  ;", "con 1  . close (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( txSession )  . commit (  )  ;", "verify ( txSession )  . close (  )  ;", "verify ( nonTxSession )  . close (  )  ;", "verify ( con )  . start (  )  ;", "verify ( con )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testCachingConnectionFactory"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "QueueConnectionFactory   cf    =    mock ( QueueConnectionFactory . class )  ;", "QueueConnection   con    =    mock ( QueueConnection . class )  ;", "QueueSession   txSession    =    mock ( QueueSession . class )  ;", "QueueSession   nonTxSession    =    mock ( QueueSession . class )  ;", "given ( cf . createQueueConnection (  )  )  . willReturn ( con )  ;", "given ( con . createQueueSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( txSession )  ;", "given ( txSession . getTransacted (  )  )  . willReturn ( true )  ;", "given ( con . createQueueSession ( false ,    CLIENT _ ACKNOWLEDGE )  )  . willReturn ( nonTxSession )  ;", "CachingConnectionFactory   scf    =    new   CachingConnectionFactory ( cf )  ;", "scf . setReconnectOnException ( false )  ;", "Connection   con 1     =    scf . createQueueConnection (  )  ;", "Session   session 1     =    con 1  . createSession ( true ,    AUTO _ ACKNOWLEDGE )  ;", "session 1  . rollback (  )  ;", "session 1  . close (  )  ;", "session 1     =    con 1  . createSession ( false ,    CLIENT _ ACKNOWLEDGE )  ;", "session 1  . close (  )  ;", "con 1  . start (  )  ;", "QueueConnection   con 2     =    scf . createQueueConnection (  )  ;", "Session   session 2     =    con 2  . createQueueSession ( false ,    CLIENT _ ACKNOWLEDGE )  ;", "session 2  . close (  )  ;", "session 2     =    con 2  . createSession ( true ,    AUTO _ ACKNOWLEDGE )  ;", "session 2  . getTransacted (  )  ;", "session 2  . close (  )  ;", "con 2  . start (  )  ;", "con 1  . close (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( txSession )  . rollback (  )  ;", "verify ( txSession )  . close (  )  ;", "verify ( nonTxSession )  . close (  )  ;", "verify ( con )  . start (  )  ;", "verify ( con )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testCachingConnectionFactoryWithQueueConnectionFactoryAndJms102Usage"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TopicConnectionFactory   cf    =    mock ( TopicConnectionFactory . class )  ;", "TopicConnection   con    =    mock ( TopicConnection . class )  ;", "TopicSession   txSession    =    mock ( TopicSession . class )  ;", "TopicSession   nonTxSession    =    mock ( TopicSession . class )  ;", "given ( cf . createTopicConnection (  )  )  . willReturn ( con )  ;", "given ( con . createTopicSession ( true ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( txSession )  ;", "given ( txSession . getTransacted (  )  )  . willReturn ( true )  ;", "given ( con . createTopicSession ( false ,    CLIENT _ ACKNOWLEDGE )  )  . willReturn ( nonTxSession )  ;", "CachingConnectionFactory   scf    =    new   CachingConnectionFactory ( cf )  ;", "scf . setReconnectOnException ( false )  ;", "Connection   con 1     =    scf . createTopicConnection (  )  ;", "Session   session 1     =    con 1  . createSession ( true ,    AUTO _ ACKNOWLEDGE )  ;", "session 1  . getTransacted (  )  ;", "session 1  . close (  )  ;", "session 1     =    con 1  . createSession ( false ,    CLIENT _ ACKNOWLEDGE )  ;", "session 1  . close (  )  ;", "con 1  . start (  )  ;", "TopicConnection   con 2     =    scf . createTopicConnection (  )  ;", "Session   session 2     =    con 2  . createTopicSession ( false ,    CLIENT _ ACKNOWLEDGE )  ;", "session 2  . close (  )  ;", "session 2     =    con 2  . createSession ( true ,    AUTO _ ACKNOWLEDGE )  ;", "session 2  . getTransacted (  )  ;", "session 2  . close (  )  ;", "con 2  . start (  )  ;", "con 1  . close (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( txSession )  . close (  )  ;", "verify ( nonTxSession )  . close (  )  ;", "verify ( con )  . start (  )  ;", "verify ( con )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testCachingConnectionFactoryWithTopicConnectionFactoryAndJms102Usage"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Connection   con    =    mock ( Connection . class )  ;", "scf    =    new    ( con )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "con 1  . start (  )  ;", "con 1  . stop (  )  ;", "con 1  . close (  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 2  . start (  )  ;", "con 2  . stop (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con ,    times (  2  )  )  . start (  )  ;", "verify ( con ,    times (  2  )  )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithConnection"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Connection   con    =    mock ( Connection . class )  ;", "scf    =    new    ( con )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "con 1  . start (  )  ;", "verify ( con )  . start (  )  ;", "con 1  . stop (  )  ;", "verify ( con )  . stop (  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 2  . start (  )  ;", "verify ( con ,    times (  2  )  )  . start (  )  ;", "con 2  . stop (  )  ;", "verify ( con ,    times (  2  )  )  . stop (  )  ;", "con 2  . start (  )  ;", "verify ( con ,    times (  3  )  )  . start (  )  ;", "con 1  . start (  )  ;", "con 2  . stop (  )  ;", "con 1  . stop (  )  ;", "verify ( con ,    times (  3  )  )  . stop (  )  ;", "con 1  . start (  )  ;", "verify ( con ,    times (  4  )  )  . start (  )  ;", "con 1  . close (  )  ;", "verify ( con ,    times (  4  )  )  . stop (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithConnectionAggregatedStartStop"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "scf    =    new    ( cf )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 1  . start (  )  ;", "con 2  . start (  )  ;", "con 1  . close (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con )  . start (  )  ;", "verify ( con )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithConnectionFactory"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "scf    =    new    ( cf )  ;", "scf . setClientId (  \" myId \"  )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 1  . start (  )  ;", "con 2  . start (  )  ;", "con 1  . close (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con )  . setClientID (  \" myId \"  )  ;", "verify ( con )  . start (  )  ;", "verify ( con )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithConnectionFactoryAndClientId"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "Connection   con    =    mock ( Connection . class )  ;", "ExceptionListener   listener    =    new   ChainedExceptionListener (  )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "given ( con . getExceptionListener (  )  )  . willReturn ( listener )  ;", "scf    =    new    ( cf )  ;", "scf . setExceptionListener ( listener )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "assertEquals ( listener ,    con 1  . getExceptionListener (  )  )  ;", "con 1  . start (  )  ;", "con 1  . stop (  )  ;", "con 1  . close (  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 2  . start (  )  ;", "con 2  . stop (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con )  . setExceptionListener ( listener )  ;", "verify ( con ,    times (  2  )  )  . start (  )  ;", "verify ( con ,    times (  2  )  )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testWithConnectionFactoryAndExceptionListener"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "TestConnection   con    =    new   TestConnection (  )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "TestExceptionListener   listener    =    new   TestExceptionListener (  )  ;", "scf    =    new    ( cf )  ;", "scf . setExceptionListener ( listener )  ;", "scf . setReconnectOnException ( true )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "assertSame ( listener ,    con 1  . getExceptionListener (  )  )  ;", "con 1  . start (  )  ;", "con . getExceptionListener (  )  . onException ( new   JMSException (  \"  \"  )  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 2  . start (  )  ;", "scf . destroy (  )  ;", "assertEquals (  2  ,    con . getStartCount (  )  )  ;", "assertEquals (  2  ,    con . getCloseCount (  )  )  ;", "assertEquals (  1  ,    listener . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithConnectionFactoryAndExceptionListenerAndReconnectOnException"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "TestConnection   con    =    new   TestConnection (  )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "TestExceptionListener   listener 0     =    new   TestExceptionListener (  )  ;", "TestExceptionListener   listener 1     =    new   TestExceptionListener (  )  ;", "TestExceptionListener   listener 2     =    new   TestExceptionListener (  )  ;", "scf    =    new    ( cf )     {", "@ Override", "public   void   onException ( JMSException   ex )     {", "}", "}  ;", "scf . setReconnectOnException ( true )  ;", "scf . setExceptionListener ( listener 0  )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "con 1  . setExceptionListener ( listener 1  )  ;", "assertSame ( listener 1  ,    con 1  . getExceptionListener (  )  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 2  . setExceptionListener ( listener 2  )  ;", "assertSame ( listener 2  ,    con 2  . getExceptionListener (  )  )  ;", "con . getExceptionListener (  )  . onException ( new   JMSException (  \"  \"  )  )  ;", "con 2  . close (  )  ;", "con . getExceptionListener (  )  . onException ( new   JMSException (  \"  \"  )  )  ;", "con 1  . close (  )  ;", "con . getExceptionListener (  )  . onException ( new   JMSException (  \"  \"  )  )  ;", "scf . destroy (  )  ;", "assertEquals (  0  ,    con . getStartCount (  )  )  ;", "assertEquals (  1  ,    con . getCloseCount (  )  )  ;", "assertEquals (  3  ,    listener 0  . getCount (  )  )  ;", "assertEquals (  2  ,    listener 1  . getCount (  )  )  ;", "assertEquals (  1  ,    listener 2  . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithConnectionFactoryAndLocalExceptionListenerWithCleanup"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "TestConnection   con    =    new   TestConnection (  )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "TestExceptionListener   listener 0     =    new   TestExceptionListener (  )  ;", "TestExceptionListener   listener 1     =    new   TestExceptionListener (  )  ;", "TestExceptionListener   listener 2     =    new   TestExceptionListener (  )  ;", "scf    =    new    ( cf )  ;", "scf . setReconnectOnException ( true )  ;", "scf . setExceptionListener ( listener 0  )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "con 1  . setExceptionListener ( listener 1  )  ;", "assertSame ( listener 1  ,    con 1  . getExceptionListener (  )  )  ;", "con 1  . start (  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 2  . setExceptionListener ( listener 2  )  ;", "assertSame ( listener 2  ,    con 2  . getExceptionListener (  )  )  ;", "con . getExceptionListener (  )  . onException ( new   JMSException (  \"  \"  )  )  ;", "con 2  . close (  )  ;", "con 1  . getMetaData (  )  ;", "con . getExceptionListener (  )  . onException ( new   JMSException (  \"  \"  )  )  ;", "con 1  . close (  )  ;", "scf . destroy (  )  ;", "assertEquals (  2  ,    con . getStartCount (  )  )  ;", "assertEquals (  2  ,    con . getCloseCount (  )  )  ;", "assertEquals (  2  ,    listener 0  . getCount (  )  )  ;", "assertEquals (  2  ,    listener 1  . getCount (  )  )  ;", "assertEquals (  1  ,    listener 2  . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithConnectionFactoryAndLocalExceptionListenerWithReconnect"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   cf    =    mock ( ConnectionFactory . class )  ;", "TestConnection   con    =    new   TestConnection (  )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "scf    =    new    ( cf )  ;", "scf . setReconnectOnException ( true )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "assertNull ( con 1  . getExceptionListener (  )  )  ;", "con 1  . start (  )  ;", "con . getExceptionListener (  )  . onException ( new   JMSException (  \"  \"  )  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 2  . start (  )  ;", "scf . destroy (  )  ;", "assertEquals (  2  ,    con . getStartCount (  )  )  ;", "assertEquals (  2  ,    con . getCloseCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithConnectionFactoryAndReconnectOnException"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Connection   con    =    mock ( QueueConnection . class )  ;", "scf    =    new    ( con )  ;", "QueueConnection   con 1     =    scf . createQueueConnection (  )  ;", "con 1  . start (  )  ;", "con 1  . stop (  )  ;", "con 1  . close (  )  ;", "QueueConnection   con 2     =    scf . createQueueConnection (  )  ;", "con 2  . start (  )  ;", "con 2  . stop (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con ,    times (  2  )  )  . start (  )  ;", "verify ( con ,    times (  2  )  )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithQueueConnection"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "QueueConnectionFactory   cf    =    mock ( QueueConnectionFactory . class )  ;", "QueueConnection   con    =    mock ( QueueConnection . class )  ;", "given ( cf . createQueueConnection (  )  )  . willReturn ( con )  ;", "scf    =    new    ( cf )  ;", "Connection   con 1     =    scf . createQueueConnection (  )  ;", "Connection   con 2     =    scf . createQueueConnection (  )  ;", "con 1  . start (  )  ;", "con 2  . start (  )  ;", "con 1  . close (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con )  . start (  )  ;", "verify ( con )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithQueueConnectionFactoryAndJms102Usage"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "QueueConnectionFactory   cf    =    mock ( QueueConnectionFactory . class )  ;", "QueueConnection   con    =    mock ( QueueConnection . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "scf    =    new    ( cf )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 1  . start (  )  ;", "con 2  . start (  )  ;", "con 1  . close (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con )  . start (  )  ;", "verify ( con )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithQueueConnectionFactoryAndJms11Usage"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Connection   con    =    mock ( TopicConnection . class )  ;", "scf    =    new    ( con )  ;", "TopicConnection   con 1     =    scf . createTopicConnection (  )  ;", "con 1  . start (  )  ;", "con 1  . stop (  )  ;", "con 1  . close (  )  ;", "TopicConnection   con 2     =    scf . createTopicConnection (  )  ;", "con 2  . start (  )  ;", "con 2  . stop (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con ,    times (  2  )  )  . start (  )  ;", "verify ( con ,    times (  2  )  )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithTopicConnection"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TopicConnectionFactory   cf    =    mock ( TopicConnectionFactory . class )  ;", "TopicConnection   con    =    mock ( TopicConnection . class )  ;", "given ( cf . createTopicConnection (  )  )  . willReturn ( con )  ;", "scf    =    new    ( cf )  ;", "Connection   con 1     =    scf . createTopicConnection (  )  ;", "Connection   con 2     =    scf . createTopicConnection (  )  ;", "con 1  . start (  )  ;", "con 2  . start (  )  ;", "con 1  . close (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con )  . start (  )  ;", "verify ( con )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithTopicConnectionFactoryAndJms102Usage"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TopicConnectionFactory   cf    =    mock ( TopicConnectionFactory . class )  ;", "TopicConnection   con    =    mock ( TopicConnection . class )  ;", "given ( cf . createConnection (  )  )  . willReturn ( con )  ;", "scf    =    new    ( cf )  ;", "Connection   con 1     =    scf . createConnection (  )  ;", "Connection   con 2     =    scf . createConnection (  )  ;", "con 1  . start (  )  ;", "con 2  . start (  )  ;", "con 1  . close (  )  ;", "con 2  . close (  )  ;", "scf . destroy (  )  ;", "verify ( con )  . start (  )  ;", "verify ( con )  . stop (  )  ;", "verify ( con )  . close (  )  ;", "verifyNoMoreInteractions ( con )  ;", "}", "METHOD_END"], "methodName": ["testWithTopicConnectionFactoryAndJms11Usage"], "fileName": "org.springframework.jms.connection.SingleConnectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   closeCount ;", "}", "METHOD_END"], "methodName": ["getCloseCount"], "fileName": "org.springframework.jms.connection.TestConnection"}, {"methodBody": ["METHOD_START", "{", "return   startCount ;", "}", "METHOD_END"], "methodName": ["getStartCount"], "fileName": "org.springframework.jms.connection.TestConnection"}, {"methodBody": ["METHOD_START", "{", "return   count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.jms.connection.TestExceptionListener"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   target    =    this . targetConnectionFactory ;", "Assert . state (  ( target    !  =    null )  ,     \"  ' targetConnectionFactory '    is   required \"  )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["getTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    classes    =    new   ArrayList <  >  (  3  )  ;", "classes . add ( Connection . class )  ;", "if    ( target   instanceof   QueueConnection )     {", "classes . add ( QueueConnection . class )  ;", "}", "if    ( target   instanceof   TopicConnection )     {", "classes . add ( TopicConnection . class )  ;", "}", "return    (  ( Connection )     ( Proxy . newProxyInstance ( Connection . class . getClassLoader (  )  ,    ClassUtils . toClassArray ( classes )  ,    new    . TransactionAwareConnectionInvocationHandler ( target )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionAwareConnectionProxy"], "fileName": "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy"}, {"methodBody": ["METHOD_START", "{", "return   this . synchedLocalTransactionAllowed ;", "}", "METHOD_END"], "methodName": ["isSynchedLocalTransactionAllowed"], "fileName": "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy"}, {"methodBody": ["METHOD_START", "{", "this . synchedLocalTransactionAllowed    =    synchedLocalTransactionAllowed ;", "}", "METHOD_END"], "methodName": ["setSynchedLocalTransactionAllowed"], "fileName": "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( targetConnectionFactory ,     \"  ' targetConnectionFactory '    must   not   be   null \"  )  ;", "this . targetConnectionFactory    =    targetConnectionFactory ;", "}", "METHOD_END"], "methodName": ["setTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.TransactionAwareConnectionFactoryProxy"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   target    =    obtainTargetConnectionFactory (  )  ;", "if    ( StringUtils . hasLength ( username )  )     {", "return   target . createConnection ( username ,    password )  ;", "} else    {", "return   target . createConnection (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doCreateConnection"], "fileName": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   target    =    obtainTargetConnectionFactory (  )  ;", "if    (  !  ( target   instanceof   QueueConnectionFactory )  )     {", "throw   new   IllegalStateException (  \"  ' targetConnectionFactory '    is   not   a   QueueConnectionFactory \"  )  ;", "}", "QueueConnectionFactory   queueFactory    =     (  ( QueueConnectionFactory )     ( target )  )  ;", "if    ( StringUtils . hasLength ( username )  )     {", "return   queueFactory . createQueueConnection ( username ,    password )  ;", "} else    {", "return   queueFactory . createQueueConnection (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doCreateQueueConnection"], "fileName": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   target    =    obtainTargetConnectionFactory (  )  ;", "if    (  !  ( target   instanceof   TopicConnectionFactory )  )     {", "throw   new   IllegalStateException (  \"  ' targetConnectionFactory '    is   not   a   TopicConnectionFactory \"  )  ;", "}", "TopicConnectionFactory   queueFactory    =     (  ( TopicConnectionFactory )     ( target )  )  ;", "if    ( StringUtils . hasLength ( username )  )     {", "return   queueFactory . createTopicConnection ( username ,    password )  ;", "} else    {", "return   queueFactory . createTopicConnection (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doCreateTopicConnection"], "fileName": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . targetConnectionFactory )     !  =    null )  ,     \"  ' targetConnectionFactory '    is   required \"  )  ;", "return   this . targetConnectionFactory ;", "}", "METHOD_END"], "methodName": ["obtainTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "this . threadBoundCredentials . remove (  )  ;", "}", "METHOD_END"], "methodName": ["removeCredentialsFromCurrentThread"], "fileName": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "this . threadBoundCredentials . set ( new   UserCredentialsConnectionFactoryAdapter . JmsUserCredentials ( username ,    password )  )  ;", "}", "METHOD_END"], "methodName": ["setCredentialsForCurrentThread"], "fileName": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "this . password    =    password ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( targetConnectionFactory ,     \"  ' targetConnectionFactory '    must   not   be   null \"  )  ;", "this . targetConnectionFactory    =    targetConnectionFactory ;", "}", "METHOD_END"], "methodName": ["setTargetConnectionFactory"], "fileName": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "this . username    =    username ;", "}", "METHOD_END"], "methodName": ["setUsername"], "fileName": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ex   instanceof   DestinationResolutionException )     |  |     ( ex   instanceof   InvalidDestinationException )  )     {", "return   new   messaging . core . DestinationResolutionException ( ex . getMessage (  )  ,    ex )  ;", "}", "if    ( ex   instanceof   MessageConversionException )     {", "return   new   messaging . converter . MessageConversionException ( ex . getMessage (  )  ,    ex )  ;", "}", "return   new   MessagingException ( ex . getMessage (  )  ,    ex )  ;", "}", "METHOD_END"], "methodName": ["convertJmsException"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( message    =  =    null )     {", "return   null ;", "}", "try    {", "return    (  ( Message <  ?  >  )     ( getJmsMessageConverter (  )  . fromMessage ( message )  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   messaging . converter . MessageConversionException (  (  (  \" Could   not   convert    '  \"     +    message )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["convertJmsMessage"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   JmsMessagingTemplate . MessagingMessageCreator ( message ,    getJmsMessageConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["createMessageCreator"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "try    {", "Message   jmsMessage    =    obtainJmsTemplate (  )  . receive ( destinationName )  ;", "return   converte ( jmsMessage )  ;", "}    catch    ( JmsException   ex )     {", "throw   convertJmsException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doReceive"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "try    {", "obtainJms (  )  . send ( destinationName ,    createMessageCreator ( message )  )  ;", "}    catch    ( JmsException   ex )     {", "throw   convertJmsException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doSend"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "try    {", "Message   jmsMessage    =    obtainJmsTemplate (  )  . sendAndReceive ( destinationName ,    createMessageCreator ( requestMessage )  )  ;", "return   converte ( jmsMessage )  ;", "}    catch    ( JmsException   ex )     {", "throw   convertJmsException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doSendAndReceive"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return    ( this . jmsTemplate )     !  =    null    ?    this . jmsTemplate . getConnectionFactory (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getConnectionFactory"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultDestinationName ;", "}", "METHOD_END"], "methodName": ["getDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . jmsMessageConverter ;", "}", "METHOD_END"], "methodName": ["getJmsMessageConverter"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . jmsTemplate ;", "}", "METHOD_END"], "methodName": ["getJmsTemplate"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "String   name    =    getDefaultDestinationName (  )  ;", "if    ( name    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No    ' defaultDestination '    or    ' defaultDestinationName '    specified .     \"     +     \" Check   configuration   of    .  \"  )  )  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["getRequiredDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . jmsTemplate )     !  =    null )  ,     \" No   JmsTemplate   set \"  )  ;", "return   this . jmsTemplate ;", "}", "METHOD_END"], "methodName": ["obtainJmsTemplate"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . jmsTemplate )     !  =    null )     {", "this . jmsTemplate . setConnectionFactory ( connectionFactory )  ;", "} else    {", "this . jmsTemplate    =    new   JmsTemplate ( connectionFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . defaultDestinationName    =    defaultDestinationName ;", "}", "METHOD_END"], "methodName": ["setDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( jmsMessageConverter ,     \" MessageConverter   must   not   be   null \"  )  ;", "this . jmsMessageConverter    =    jmsMessageConverter ;", "this . converterSet    =    true ;", "}", "METHOD_END"], "methodName": ["setJmsMessageConverter"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . jmsTemplate    =    jmsTemplate ;", "}", "METHOD_END"], "methodName": ["setJmsTemplate"], "fileName": "org.springframework.jms.core.JmsMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "MessageConverter   jmsMessageConverter    =    messagingTemplate . getJmsMessageConverter (  )  ;", "assertNotNull ( jmsMessageConverter )  ;", "assertEquals ( MessagingMessageConverter . class ,    jmsMessageConverter . getClass (  )  )  ;", "assertSame ( messageConverter ,    new   DirectFieldAccessor ( jmsMessageConverter )  . getPropertyValue (  \" payloadConverter \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertPayloadConverter"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "TextMessage   je    =    createTextMessage ( messageCreator )  ;", "assertEquals (  \" Wrong   body   message \"  ,     \" Hello \"  ,    je . getText (  )  )  ;", "assertEquals (  \" Invalid   foo   property \"  ,     \" bar \"  ,    je . getStringProperty (  \" foo \"  )  )  ;", "}    catch    ( JMSException   e )     {", "throw   new   IllegalStateException (  \" Wrong   text   message \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["assertTextMessage"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" message   should   not   be   null \"  ,    message )  ;", "assertEquals (  \" Wrong   payload \"  ,     \" Hello \"  ,    message . getPayload (  )  )  ;", "assertEquals (  \" Invalid   foo   property \"  ,     \" bar \"  ,    message . getHeaders (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertTextMessage"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . setJmsMessageConverter ( new   SimpleMessageConverter (  )     {", "@ Override", "public   Message   toMessage ( Object   object ,    Session   session )    throws   JMSException ,    MessageConversionException    {", "throw   new   MessageConversionException (  \" Test   exception \"  )  ;", "}", "}  )  ;", "this . messagingTemplate . convertAndSend (  \" myQueue \"  ,     \" msg   to   convert \"  )  ;", "verify ( this . jmsTemplate )  . send ( eq (  \" myQueue \"  )  ,    this . messageCreator . capture (  )  )  ;", "this . thrown . expect ( messaging . converter . MessageConversionException . class )  ;", "this . thrown . expectMessage ( new   StringContains (  \" Test   exception \"  )  )  ;", "this . messageCreator . getValue (  )  . createMessage ( mock ( Session . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendCustomJmsMessageConverter"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "this . m . setDefaultDestination ( destination )  ;", "this . m . convertAndSend (  \" my   Payload \"  )  ;", "verify ( this . jmsTemplate )  . send ( eq ( destination )  ,    this . messageCreator . capture (  )  )  ;", "TextMessage   textMessage    =    createTextMessage ( this . messageCreator . getValue (  )  )  ;", "assertEquals (  \" my   Payload \"  ,    textMessage . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendDefaultDestination"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . setDefaultDestinationName (  \" myQueue \"  )  ;", "this . messagingTemplate . convertAndSend (  \" my   Payload \"  )  ;", "verify ( this . jmsTemplate )  . send ( eq (  \" myQueue \"  )  ,    this . messageCreator . capture (  )  )  ;", "TextMessage   textMessage    =    createTextMessage ( this . messageCreator . getValue (  )  )  ;", "assertEquals (  \" my   Payload \"  ,    textMessage . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . m . convertAndSend (  \" my   Payload \"  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendNoDefaultSet"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "this . m . convertAndSend ( destination ,     \" my   Payload \"  )  ;", "verify ( this . jmsTemplate )  . send ( eq ( destination )  ,    this . messageCreator . capture (  )  )  ;", "TextMessage   textMessage    =    createTextMessage ( this . messageCreator . getValue (  )  )  ;", "assertEquals (  \" my   Payload \"  ,    textMessage . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayload"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "Map < String ,    Object >    headers    =    new   HashMap <  >  (  )  ;", "headers . put (  \" foo \"  ,     \" bar \"  )  ;", "this . m . convertAndSend ( destination ,     \" Hello \"  ,    headers )  ;", "verify ( this . jmsTemplate )  . send ( eq ( destination )  ,    this . messageCreator . capture (  )  )  ;", "assertTextMessage ( this . messageCreator . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadAndHeaders"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    headers    =    new   HashMap <  >  (  )  ;", "headers . put (  \" foo \"  ,     \" bar \"  )  ;", "this . m . convertAndSend (  \" myQueue \"  ,     \" Hello \"  ,    headers )  ;", "verify ( this . jmsTemplate )  . send ( eq (  \" myQueue \"  )  ,    this . messageCreator . capture (  )  )  ;", "assertTextMessage ( this . messageCreator . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadAndHeadersName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . convertAndSend (  \" myQueue \"  ,     \" my   Payload \"  )  ;", "verify ( this . jmsTemplate )  . send ( eq (  \" myQueue \"  )  ,    this . messageCreator . capture (  )  )  ;", "TextMessage   textMessage    =    createTextMessage ( this . messageCreator . getValue (  )  )  ;", "assertEquals (  \" my   Payload \"  ,    textMessage . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "willThrow ( DestinationResolutionException . class )  . given ( this . jmsTemplate )  . receive ( destination )  ;", "this . thrown . expect ( DestinationResolutionException . class )  ;", "this . m . receive ( destination )  ;", "}", "METHOD_END"], "methodName": ["convertDestinationResolutionExceptionOnReceive"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "willThrow ( DestinationResolutionException . class )  . given ( this . jmsTemplate )  . send ( eq ( destination )  ,    any (  )  )  ;", "this . thrown . expect ( DestinationResolutionException . class )  ;", "this . m . send ( destination ,    createTextMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertDestinationResolutionExceptionOnSend"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "willThrow ( InvalidDestinationException . class )  . given ( this . jmsTemplate )  . sendAndReceive ( eq ( destination )  ,    any (  )  )  ;", "this . thrown . expect ( DestinationResolutionException . class )  ;", "this . m . sendAndReceive ( destination ,    createTextMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertInvalidDestinationExceptionOnSendAndReceive"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "willThrow ( InvalidDestinationException . class )  . given ( this . jmsTemplate )  . sendAndReceive ( eq (  \" unknownQueue \"  )  ,    any (  )  )  ;", "this . thrown . expect ( DestinationResolutionException . class )  ;", "this . m . sendAndReceive (  \" unknownQueue \"  ,    createTextMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertInvalidDestinationExceptionOnSendAndReceiveWithName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message   message    =    createJmsTextMessage (  )  ;", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "willThrow ( MessageConversionException . class )  . given ( messageConverter )  . fromMessage ( message )  ;", "this . messagingTemplate . setJmsMessageConverter ( messageConverter )  ;", "given ( this . jmsTemplate . receive (  \" myQueue \"  )  )  . willReturn ( message )  ;", "this . thrown . expect ( messaging . converter . MessageConversionException . class )  ;", "this . messagingTemplate . receive (  \" myQueue \"  )  ;", "}", "METHOD_END"], "methodName": ["convertMessageConversionExceptionOnReceive"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    createTextMessage (  )  ;", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "willThrow ( MessageConversionException . class )  . given ( messageConverter )  . toMessage ( eq ( message )  ,    any (  )  )  ;", "this . messagingTemplate . setJmsMessageConverter ( messageConverter )  ;", "invokeMessageCreator (  )  ;", "this . thrown . expect ( messaging . converter . MessageConversionException . class )  ;", "this . messagingTemplate . send (  \" myQueue \"  ,    message )  ;", "}", "METHOD_END"], "methodName": ["convertMessageConversionExceptionOnSend"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    createTextMessage (  )  ;", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "willThrow ( MessageFormatException . class )  . given ( messageConverter )  . toMessage ( eq ( message )  ,    any (  )  )  ;", "this . m . setJmsMessageConverter ( messageConverter )  ;", "invokeMessageCreator (  )  ;", "this . thrown . expect ( MessageConversionException . class )  ;", "this . m . send (  \" myQueue \"  ,    message )  ;", "}", "METHOD_END"], "methodName": ["convertMessageFormatException"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "willThrow ( MessageNotReadableException . class )  . given ( this . jmsTemplate )  . receive (  \" myQueue \"  )  ;", "this . thrown . expect ( MessagingException . class )  ;", "this . m . receive (  \" myQueue \"  )  ;", "}", "METHOD_END"], "methodName": ["convertMessageNotReadableException"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    createTextMessage (  )  ;", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "willThrow ( MessageNotWriteableException . class )  . given ( messageConverter )  . toMessage ( eq ( message )  ,    any (  )  )  ;", "this . m . setJmsMessageConverter ( messageConverter )  ;", "invokeMessageCreator (  )  ;", "this . thrown . expect ( MessageConversionException . class )  ;", "this . m . send (  \" myQueue \"  ,    message )  ;", "}", "METHOD_END"], "methodName": ["convertMessageNotWritableException"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "this . m . setDefaultDestination ( destination )  ;", "Message   replyJmsMessage    =    createJmsTextMessage (  \" My   reply \"  )  ;", "given ( this . jmsTemplate . sendAndReceive ( eq ( destination )  ,    any (  )  )  )  . willReturn ( replyJmsMessage )  ;", "String   reply    =    this . m . convertSendAndReceive (  \" my   Payload \"  ,    String . class )  ;", "verify ( this . jmsTemplate ,    times (  1  )  )  . sendAndReceive ( eq ( destination )  ,    any (  )  )  ;", "assertEquals (  \" My   reply \"  ,    reply )  ;", "}", "METHOD_END"], "methodName": ["convertSendAndReceiveDefaultDestination"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . setDefaultDestinationName (  \" myQueue \"  )  ;", "Message   replyJmsMessage    =    createJmsTextMessage (  \" My   reply \"  )  ;", "given ( this . jmsTemplate . sendAndReceive ( eq (  \" myQueue \"  )  ,    any (  )  )  )  . willReturn ( replyJmsMessage )  ;", "String   reply    =    this . messagingTemplate . convertSendAndReceive (  \" my   Payload \"  ,    String . class )  ;", "verify ( this . jmsTemplate ,    times (  1  )  )  . sendAndReceive ( eq (  \" myQueue \"  )  ,    any (  )  )  ;", "assertEquals (  \" My   reply \"  ,    reply )  ;", "}", "METHOD_END"], "methodName": ["convertSendAndReceiveDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . m . convertSendAndReceive (  \" my   Payload \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["convertSendAndReceiveNoDefaultSet"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "Message   replyJmsMessage    =    createJmsTextMessage (  \" My   reply \"  )  ;", "given ( this . jmsTemplate . sendAndReceive ( eq ( destination )  ,    any (  )  )  )  . willReturn ( replyJmsMessage )  ;", "String   reply    =    this . m . convertSendAndReceive ( destination ,     \" my   Payload \"  ,    String . class )  ;", "verify ( this . jmsTemplate ,    times (  1  )  )  . sendAndReceive ( eq ( destination )  ,    any (  )  )  ;", "assertEquals (  \" My   reply \"  ,    reply )  ;", "}", "METHOD_END"], "methodName": ["convertSendAndReceivePayload"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message   replyJmsMessage    =    createJmsTextMessage (  \" My   reply \"  )  ;", "given ( this . jmsTemplate . sendAndReceive ( eq (  \" myQueue \"  )  ,    any (  )  )  )  . willReturn ( replyJmsMessage )  ;", "String   reply    =    this . m . convertSendAndReceive (  \" myQueue \"  ,     \" my   Payload \"  ,    String . class )  ;", "verify ( this . jmsTemplate ,    times (  1  )  )  . sendAndReceive ( eq (  \" myQueue \"  )  ,    any (  )  )  ;", "assertEquals (  \" My   reply \"  ,    reply )  ;", "}", "METHOD_END"], "methodName": ["convertSendAndReceivePayloadName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   createJmsTextMessage (  \" Hello \"  )  ;", "}", "METHOD_END"], "methodName": ["createJmsTextMessage"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "StubTextMessage   je    =    new   StubTextMessage ( payload )  ;", "je . setStringProperty (  \" foo \"  ,     \" bar \"  )  ;", "return   je ;", "}    catch    ( JMSException   e )     {", "throw   new   IllegalStateException (  \" Should   not   happen \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["createJmsTextMessage"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   createTextMessage (  \" Hello \"  )  ;", "}", "METHOD_END"], "methodName": ["createTextMessage"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   MessageBuilder . withPayload ( payload )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createTextMessage"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Session   mock    =    mock ( Session . class )  ;", "given ( mock . createTexte ( BDDMockito . any (  )  )  )  . willAnswer (  (  ( Answer < Texte >  )     (  (    invocation )     -  >    new   StubTexte (  (  ( String )     ( invocation . getArguments (  )  [  0  ]  )  )  )  )  )  )  ;", "e   message    =    creator . createe ( mock )  ;", "verify ( mock )  . createTexte ( BDDMockito . any (  )  )  ;", "return   Texte . class . cast ( message )  ;", "}", "METHOD_END"], "methodName": ["createTextMessage"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "given ( this . jmsTemplate . getMessageConverter (  )  )  . willReturn ( messageConverter )  ;", "MessageConverter   customMessageConverter    =    mock ( MessageConverter . class )  ;", "messagingTemplate    =    new    (  )  ;", "messagingTemplate . setJmsMessageConverter ( new   MessagingMessageConverter ( customMessageConverter )  )  ;", "messagingTemplate . setJmsTemplate ( this . jmsTemplate )  ;", "messagingTemplate . afterPropertiesSet (  )  ;", "assertPayloadConverter ( messagingTemplate ,    customMessageConverter )  ;", "}", "METHOD_END"], "methodName": ["customConverterAlwaysTakesPrecedence"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "willAnswer (  (    invocation )     -  >     {", "MessageCreator   messageCreator    =     (  ( MessageCreator )     ( invocation . getArguments (  )  [  1  ]  )  )  ;", "messageCreator . createMessage ( null )  ;", "return   null ;", "}  )  . given ( this . jms )  . send ( eq (  \" myQueue \"  )  ,    any (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeMessageCreator"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "given ( this . jmsTemplate . getMessageConverter (  )  )  . willReturn ( messageConverter )  ;", "messagingTemplate    =    new    ( this . jmsTemplate )  ;", "messagingTemplate . afterPropertiesSet (  )  ;", "assertPayloadConverter ( messagingTemplate ,    messageConverter )  ;", "}", "METHOD_END"], "methodName": ["payloadConverterIsConsistentConstructor"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "given ( this . jmsTemplate . getMessageConverter (  )  )  . willReturn ( messageConverter )  ;", "messagingTemplate    =    new    (  )  ;", "messagingTemplate . setJmsTemplate ( this . jmsTemplate )  ;", "messagingTemplate . afterPropertiesSet (  )  ;", "assertPayloadConverter ( messagingTemplate ,    messageConverter )  ;", "}", "METHOD_END"], "methodName": ["payloadConverterIsConsistentSetter"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "Message   jmsMessage    =    createJmsTextMessage (  )  ;", "given ( this . jmsTemplate . receive ( destination )  )  . willReturn ( jmsMessage )  ;", "messaging . Message <  ?  >    message    =    this . messagingTemplate . receive ( destination )  ;", "verify ( this . jmsTemplate )  . receive ( destination )  ;", "assertTextMessage ( message )  ;", "}", "METHOD_END"], "methodName": ["receive"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "Message   jmsMessage    =    createJmsTextMessage (  \" my   Payload \"  )  ;", "given ( this . jmsTemplate . receive ( destination )  )  . willReturn ( jmsMessage )  ;", "String   payload    =    this . m . receiveAndConvert ( destination ,    String . class )  ;", "assertEquals (  \" my   Payload \"  ,    payload )  ;", "verify ( this . jmsTemplate )  . receive ( destination )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvert"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "this . m . setDefaultDestination ( destination )  ;", "Message   jmsMessage    =    createJmsTextMessage (  \" my   Payload \"  )  ;", "given ( this . jmsTemplate . receive ( destination )  )  . willReturn ( jmsMessage )  ;", "String   payload    =    this . m . receiveAndConvert ( String . class )  ;", "assertEquals (  \" my   Payload \"  ,    payload )  ;", "verify ( this . jmsTemplate )  . receive ( destination )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvertDefaultDestination"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . setDefaultDestinationName (  \" myQueue \"  )  ;", "Message   jmsMessage    =    createJmsTextMessage (  \" my   Payload \"  )  ;", "given ( this . jmsTemplate . receive (  \" myQueue \"  )  )  . willReturn ( jmsMessage )  ;", "String   payload    =    this . messagingTemplate . receiveAndConvert ( String . class )  ;", "assertEquals (  \" my   Payload \"  ,    payload )  ;", "verify ( this . jmsTemplate )  . receive (  \" myQueue \"  )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvertDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    createJmsTextMessage (  \" my   Payload \"  )  ;", "given ( this . jmsTemplate . receive (  \" myQueue \"  )  )  . willReturn ( jmsMessage )  ;", "String   payload    =    this . m . receiveAndConvert (  \" myQueue \"  ,    String . class )  ;", "assertEquals (  \" my   Payload \"  ,    payload )  ;", "verify ( this . jmsTemplate )  . receive (  \" myQueue \"  )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvertName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    createJmsTextMessage (  \" Hello \"  )  ;", "given ( this . jmsTemplate . receive (  \" myQueue \"  )  )  . willReturn ( jmsMessage )  ;", "this . thrown . expect ( MessageConversionException . class )  ;", "this . m . receiveAndConvert (  \" myQueue \"  ,    Writer . class )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvertNoConverter"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . jmsTemplate . receive (  \" myQueue \"  )  )  . willReturn ( null )  ;", "assertNull ( this . m . receiveAndConvert (  \" myQueue \"  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvertNoInput"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    createJmsTextMessage (  \"  1  2  3  \"  )  ;", "given ( this . jmsTemplate . receive (  \" myQueue \"  )  )  . willReturn ( jmsMessage )  ;", "this . m . setMessageConverter ( new   GenericMessageConverter (  )  )  ;", "Integer   payload    =    this . m . receiveAndConvert (  \" myQueue \"  ,    Integer . class )  ;", "assertEquals ( Integer . valueOf (  1  2  3  )  ,    payload )  ;", "verify ( this . jmsTemplate )  . receive (  \" myQueue \"  )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvertWithConversion"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "this . messagingTemplate . setDefaultDestination ( destination )  ;", "Message   jmsMessage    =    createJmsTextMessage (  )  ;", "given ( this . jmsTemplate . receive ( destination )  )  . willReturn ( jmsMessage )  ;", "messaging . Message <  ?  >    message    =    this . messagingTemplate . receive (  )  ;", "verify ( this . jmsTemplate )  . receive ( destination )  ;", "assertTextMessage ( message )  ;", "}", "METHOD_END"], "methodName": ["receiveDefaultDestination"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . setDefaultDestinationName (  \" myQueue \"  )  ;", "Message   jmsMessage    =    createJmsTextMessage (  )  ;", "given ( this . jmsTemplate . receive (  \" myQueue \"  )  )  . willReturn ( jmsMessage )  ;", "messaging . Message <  ?  >    message    =    this . messagingTemplate . receive (  )  ;", "verify ( this . jmsTemplate )  . receive (  \" myQueue \"  )  ;", "assertTextMessage ( message )  ;", "}", "METHOD_END"], "methodName": ["receiveDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    createJmsTextMessage (  )  ;", "given ( this . jmsTemplate . receive (  \" myQueue \"  )  )  . willReturn ( jmsMessage )  ;", "messaging . Message <  ?  >    message    =    this . messagingTemplate . receive (  \" myQueue \"  )  ;", "verify ( this . jmsTemplate )  . receive (  \" myQueue \"  )  ;", "assertTextMessage ( message )  ;", "}", "METHOD_END"], "methodName": ["receiveName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . m . receive (  )  ;", "}", "METHOD_END"], "methodName": ["receiveNoDefaultSet"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "Message < String >    message    =    createTextMessage (  )  ;", "this . m . send ( destination ,    message )  ;", "verify ( this . jmsTemplate )  . send ( eq ( destination )  ,    this . messageCreator . capture (  )  )  ;", "assertTextMessage ( this . messageCreator . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["send"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "Message < String >    request    =    createTextMessage (  )  ;", "Message   replyJmsMessage    =    createJmsTextMessage (  )  ;", "given ( this . jmsTemplate . sendAndReceive ( eq ( destination )  ,    any (  )  )  )  . willReturn ( replyJmsMessage )  ;", "Message <  ?  >    actual    =    this . m . sendAndReceive ( destination ,    request )  ;", "verify ( this . jmsTemplate ,    times (  1  )  )  . sendAndReceive ( eq ( destination )  ,    any (  )  )  ;", "assertTextMessage ( actual )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceive"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "this . m . setDefaultDestination ( destination )  ;", "Message < String >    request    =    createTextMessage (  )  ;", "Message   replyJmsMessage    =    createJmsTextMessage (  )  ;", "given ( this . jmsTemplate . sendAndReceive ( eq ( destination )  ,    any (  )  )  )  . willReturn ( replyJmsMessage )  ;", "Message <  ?  >    actual    =    this . m . sendAndReceive ( request )  ;", "verify ( this . jmsTemplate ,    times (  1  )  )  . sendAndReceive ( eq ( destination )  ,    any (  )  )  ;", "assertTextMessage ( actual )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceiveDefaultDestination"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . setDefaultDestinationName (  \" myQueue \"  )  ;", "Message < String >    request    =    createTextMessage (  )  ;", "Message   replyJmsMessage    =    createJmsTextMessage (  )  ;", "given ( this . jmsTemplate . sendAndReceive ( eq (  \" myQueue \"  )  ,    any (  )  )  )  . willReturn ( replyJmsMessage )  ;", "Message <  ?  >    actual    =    this . messagingTemplate . sendAndReceive ( request )  ;", "verify ( this . jmsTemplate ,    times (  1  )  )  . sendAndReceive ( eq (  \" myQueue \"  )  ,    any (  )  )  ;", "assertTextMessage ( actual )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceiveDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    request    =    createTextMessage (  )  ;", "Message   replyJmsMessage    =    createJmsTextMessage (  )  ;", "given ( this . jmsTemplate . sendAndReceive ( eq (  \" myQueue \"  )  ,    any (  )  )  )  . willReturn ( replyJmsMessage )  ;", "Message <  ?  >    actual    =    this . m . sendAndReceive (  \" myQueue \"  ,    request )  ;", "verify ( this . jmsTemplate ,    times (  1  )  )  . sendAndReceive ( eq (  \" myQueue \"  )  ,    any (  )  )  ;", "assertTextMessage ( actual )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceiveName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    createTextMessage (  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . m . sendAndReceive ( message )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceiveNoDefaultSet"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "this . m . setDefaultDestination ( destination )  ;", "Message < String >    message    =    createTextMessage (  )  ;", "this . m . send ( message )  ;", "verify ( this . jmsTemplate )  . send ( eq ( destination )  ,    this . messageCreator . capture (  )  )  ;", "assertTextMessage ( this . messageCreator . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendDefaultDestination"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . setDefaultDestinationName (  \" myQueue \"  )  ;", "Message < String >    message    =    createTextMessage (  )  ;", "this . messagingTemplate . send ( message )  ;", "verify ( this . jmsTemplate )  . send ( eq (  \" myQueue \"  )  ,    this . messageCreator . capture (  )  )  ;", "assertTextMessage ( this . messageCreator . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    createTextMessage (  )  ;", "this . m . send (  \" myQueue \"  ,    message )  ;", "verify ( this . jmsTemplate )  . send ( eq (  \" myQueue \"  )  ,    this . messageCreator . capture (  )  )  ;", "assertTextMessage ( this . messageCreator . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendName"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    createTextMessage (  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . m . send ( message )  ;", "}", "METHOD_END"], "methodName": ["sendNoDefaultSet"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessagingTemplate   t    =    new   JmsMessagingTemplate (  )  ;", "t . setJmsTemplate ( this . jmsTemplate )  ;", "t . setDefaultDestinationName (  \" myQueue \"  )  ;", "t . afterPropertiesSet (  )  ;", "Message < String >    message    =    createTextMessage (  )  ;", "t . send ( message )  ;", "verify ( this . jmsTemplate )  . send ( eq (  \" myQueue \"  )  ,    this . messageCreator . capture (  )  )  ;", "assertTextMessage ( this . messageCreator . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendPropertyInjection"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "this . messagingTemplate    =    new    ( this . jmsTemplate )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( this . jmsTemplate ,    this . messagingTemplate . getJmsTemplate (  )  )  ;", "}", "METHOD_END"], "methodName": ["validateJmsTemplate"], "fileName": "org.springframework.jms.core.JmsMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   session . createBrowser ( queue ,    messageSelector )  ;", "}", "METHOD_END"], "methodName": ["createBrowser"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( isPubSubDomain (  )  )     {", "return   session . creConsumer ( destination ,    messageSelector ,    isPubSubNoLocal (  )  )  ;", "} else    {", "return   session . creConsumer ( destination ,    messageSelector )  ;", "}", "}", "METHOD_END"], "methodName": ["createConsumer"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "MessageProducer   producer    =    doCreateProducer ( session ,    destination )  ;", "if    (  !  ( isMessageIdEnabled (  )  )  )     {", "producer . setDisableMessageID ( true )  ;", "}", "if    (  !  ( isMessageTimestampEnabled (  )  )  )     {", "producer . setDisableMessageTimestamp ( true )  ;", "}", "return   producer ;", "}", "METHOD_END"], "methodName": ["createProducer"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( message    !  =    null )     {", "try    {", "return   getRequiredMessageConverter (  )  . fromMessage ( message )  ;", "}    catch    ( JMSException   ex )     {", "throw   convertAccessException ( ex )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["doConvertFromMessage"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   session . createProducer ( destination )  ;", "}", "METHOD_END"], "methodName": ["doCreateProducer"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   doReceive ( session ,    createConsumer ( session ,    destination ,    messageSelector )  )  ;", "}", "METHOD_END"], "methodName": ["doReceive"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "try    {", "long   timeout    =    getReceiveTimeout (  )  ;", "ConnectionFactory   connectionFactory    =    getConnectionFactory (  )  ;", "JmsResourceHolder   resourceHolder    =    null ;", "if    ( connectionFactory    !  =    null )     {", "resourceHolder    =     (  ( JmsResourceHolder )     ( TransactionSynchronizationManager . getResource ( connectionFactory )  )  )  ;", "}", "if    (  ( resourceHolder    !  =    null )     &  &     ( resourceHolder . hasTimeout (  )  )  )     {", "timeout    =    Math . min ( timeout ,    resourceHolder . getTimeToLiveInMillis (  )  )  ;", "}", "Message   message    =    receiveFromConsumer ( consumer ,    timeout )  ;", "if    ( session . getTransacted (  )  )     {", "if    ( isSessionLocallyTransacted ( session )  )     {", "JmsUtilmmitIfNecessary ( session )  ;", "}", "} else", "if    ( isClientAcknowledge ( session )  )     {", "if    ( message    !  =    null )     {", "message . acknowledge (  )  ;", "}", "}", "return   message ;", "}    finally    {", "JmsUtils . closeMessageConsumer ( consumer )  ;", "}", "}", "METHOD_END"], "methodName": ["doReceive"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . deliveryDelay )     >  =     0  )     {", "producer . setDeliveryDelay ( this . deliveryDelay )  ;", "}", "if    ( isExplicitQosEnabled (  )  )     {", "producer . send ( message ,    getDeliveryMode (  )  ,    getPriority (  )  ,    getTimeToLive (  )  )  ;", "} else    {", "producer . send ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["doSend"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messageCreator ,     \" MessageCreator   must   not   be   null \"  )  ;", "MessageProducer   producer    =    createProducer ( session ,    destination )  ;", "try    {", "Message   message    =    messageCreator . createMessage ( session )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Sending   created   message :     \"     +    message )  )  ;", "}", "doSend ( producer ,    message )  ;", "if    (  ( session . getTransacted (  )  )     &  &     ( isSessionLocallyTransacted ( session )  )  )     {", "JmsUtilmmitIfNecessary ( session )  ;", "}", "}    finally    {", "JmsUtils . closeMessageProducer ( producer )  ;", "}", "}", "METHOD_END"], "methodName": ["doSend"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messageCreator ,     \" MessageCreator   must   not   be   null \"  )  ;", "oraryQueue   responseQueue    =    null ;", "MessageProducer   producer    =    null ;", "MessageConsumer   consumer    =    null ;", "try    {", "Message   requestMessage    =    messageCreator . createMessage ( session )  ;", "responseQueue    =    session . createoraryQueue (  )  ;", "producer    =    session . createProducer ( destination )  ;", "consumer    =    session . createConsumer ( responseQueue )  ;", "requestMessage . setJMSReplyTo ( responseQueue )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Sending   created   message :     \"     +    requestMessage )  )  ;", "}", "doSend ( producer ,    requestMessage )  ;", "return   receiveFromConsumer ( consumer ,    getReceiveTimeout (  )  )  ;", "}    finally    {", "JmsUtils . closeMessageConsumer ( consumer )  ;", "JmsUtils . closeMessageProducer ( producer )  ;", "if    ( responseQueue    !  =    null )     {", "responseQueue . delete (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doSendAndReceive"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( action ,     \" Callback   object   must   not   be   null \"  )  ;", "Connection   conToClose    =    null ;", "Session   sessionToClose    =    null ;", "try    {", "Session   sessionToUse    =    ConnectionFactoryUtils . doGetTransactionalSession ( obtainConnectionFactory (  )  ,    this . transactionalResourceFactory ,    startConnection )  ;", "if    ( sessionToUse    =  =    null )     {", "conToClose    =    creConnection (  )  ;", "sessionToClose    =    creSession ( conToClose )  ;", "if    ( startConnection )     {", "conToClose . start (  )  ;", "}", "sessionToUse    =    sessionToClose ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Executing   callback   on   JMS   Session :     \"     +    sessionToUse )  )  ;", "}", "return   action . doInJms ( sessionToUse )  ;", "}    catch    ( JMSException   ex )     {", "throw   convertJmsAccessException ( ex )  ;", "}    finally    {", "JmsUtils . closeSession ( sessionToClose )  ;", "ConnectionFactoryUtils . releaseConnection ( conToClose ,    getConnectionFactory (  )  ,    startConnection )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( action ,     \" Callback   object   must   not   be   null \"  )  ;", "Connection   con    =    null ;", "Session   session    =    null ;", "try    {", "con    =    creConnection (  )  ;", "session    =    con . creSession ( false ,    AUTO _ ACKNOWLEDGE )  ;", "if    ( startConnection )     {", "con . start (  )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Executing   callback   on   JMS   Session :     \"     +    session )  )  ;", "}", "return   action . doInJms ( session )  ;", "}    catch    ( JMSException   ex )     {", "throw   convertJmsAccessException ( ex )  ;", "}    finally    {", "JmsUtils . closeSession ( session )  ;", "ConnectionFactoryUtils . releaseConnection ( con ,    getConnectionFactory (  )  ,    startConnection )  ;", "}", "}", "METHOD_END"], "methodName": ["executeLocal"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   holder . getConnection (  )  ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return    ( this . defaultDestination )    instanceof   Destination    ?     (  ( Destination )     ( this . defaultDestination )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDefaultDestination"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return    ( this . defaultDestination )    instanceof   String    ?     (  ( String )     ( this . defaultDestination )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "Destination   defaultDestination    =    getDefaultDestination (  )  ;", "if    (  ( defaultDestination    !  =    null )     &  &     (  !  ( defaultDestination   instanceof   Queue )  )  )     {", "throw   new   IllegalStateException (  \"  ' defaultDestination '    does   not   correspond   to   a   Queue .    Check   configuration   of    .  \"  )  ;", "}", "return    (  ( Queue )     ( defaultDestination )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultQueue"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . deliveryDelay ;", "}", "METHOD_END"], "methodName": ["getDeliveryDelay"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . deliveryMode ;", "}", "METHOD_END"], "methodName": ["getDeliveryMode"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . messageConverter ;", "}", "METHOD_END"], "methodName": ["getMessageConverter"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . priority ;", "}", "METHOD_END"], "methodName": ["getPriority"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . receiveTimeout ;", "}", "METHOD_END"], "methodName": ["getReceiveTimeout"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "String   name    =    getDefaultDestinationName (  )  ;", "if    ( name    =  =    null )     {", "throw   new   IllegalStateException (  \" No    ' defaultDestination '    or    ' defaultDestinationName '    specified .    Check   configuration   of    .  \"  )  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["getRequiredDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "MessageConverter   converter    =    getMessageConverter (  )  ;", "if    ( converter    =  =    null )     {", "throw   new   IllegalStateException (  \" No    ' messageConverter '    specified .    Check   configuration   of    .  \"  )  ;", "}", "return   converter ;", "}", "METHOD_END"], "methodName": ["getRequiredMessageConverter"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   holder . getSession (  )  ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . timeToLive ;", "}", "METHOD_END"], "methodName": ["getTimeToLive"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "setMessageConverter ( new   SimpleMessageConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["initDefaultStrategies"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . explicitQosEnabled ;", "}", "METHOD_END"], "methodName": ["isExplicitQosEnabled"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . messageIdEnabled ;", "}", "METHOD_END"], "methodName": ["isMessageIdEnabled"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . messageTimestampEnabled ;", "}", "METHOD_END"], "methodName": ["isMessageTimestampEnabled"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . pubSubNoLocal ;", "}", "METHOD_END"], "methodName": ["isPubSubNoLocal"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "return    ( isSessionTransacted (  )  )     &  &     (  !  ( ConnectionFactoryUtils . isSessionTransactional ( session ,    getConnectionFactory (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSessionLocallyTransacted"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . defaultDestination    =    destination ;", "}", "METHOD_END"], "methodName": ["setDefaultDestination"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . defaultDestination    =    destinationName ;", "}", "METHOD_END"], "methodName": ["setDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . deliveryDelay    =    deliveryDelay ;", "}", "METHOD_END"], "methodName": ["setDeliveryDelay"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . deliveryMode    =    deliveryMode ;", "}", "METHOD_END"], "methodName": ["setDeliveryMode"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . deliveryMode    =     ( deliveryPersistent )     ?    DeliveryMode . PERSISTENT    :    DeliveryMode . NON _ PERSISTENT ;", "}", "METHOD_END"], "methodName": ["setDeliveryPersistent"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . explicitQosEnabled    =    explicitQosEnabled ;", "}", "METHOD_END"], "methodName": ["setExplicitQosEnabled"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . messageConverter    =    messageConverter ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . messageIdEnabled    =    messageIdEnabled ;", "}", "METHOD_END"], "methodName": ["setMessageIdEnabled"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . messageTimestampEnabled    =    messageTimestampEnabled ;", "}", "METHOD_END"], "methodName": ["setMessageTimestampEnabled"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . priority    =    priority ;", "}", "METHOD_END"], "methodName": ["setPriority"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . pubSubNoLocal    =    pubSubNoLocal ;", "}", "METHOD_END"], "methodName": ["setPubSubNoLocal"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( settings ,     \" Settings   must   not   be   null \"  )  ;", "setExplicitQosEnabled ( true )  ;", "setDeliveryMode ( settings . getDeliveryMode (  )  )  ;", "setPriority ( settings . getPriority (  )  )  ;", "setTimeToLive ( settings . getTimeToLive (  )  )  ;", "}", "METHOD_END"], "methodName": ["setQosSettings"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . receiveTimeout    =    receiveTimeout ;", "}", "METHOD_END"], "methodName": ["setReceiveTimeout"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "this . timeToLive    =    timeToLive ;", "}", "METHOD_END"], "methodName": ["setTimeToLive"], "fileName": "org.springframework.jms.core.JmsTemplate"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    new   JmsTemplate (  )  ;", "JndiDestinationResolver   destMan    =    new   JndiDestinationResolver (  )  ;", "destMan . setJndiTemplate ( new   JndiTemplate (  )     {", "@ Override", "protected   Context   createInitialContext (  )     {", "return    . this . jndiContext ;", "}", "}  )  ;", "template . setDestinationResolver ( destMan )  ;", "template . setSessionTransacted ( useTransactedTemplate (  )  )  ;", "return   template ;", "}", "METHOD_END"], "methodName": ["createTemplate"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    createTemplate (  )  ;", "template . setConnectionFactory ( this . connectionFactory )  ;", "template . setMessageConverter ( new   SimpleMessageConverter (  )  )  ;", "String   s    =     \" Hello   world \"  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "reset ( this . session )  ;", "given ( this . session . createProducer ( this . queue )  )  . willReturn ( messageProducer )  ;", "given ( this . session . createTextMessage (  \" Hello   world \"  )  )  . willReturn ( textMessage )  ;", "willThrow ( original )  . given ( messageProducer )  . send ( textMessage )  ;", "try    {", "template . convertAndSend ( this . queue ,    s )  ;", "fail (  \" Should   have   thrown   JmsException \"  )  ;", "}    catch    ( JmsException   wrappedEx )     {", "assertEquals ( thrownExceptionClass ,    wrappedEx . getClass (  )  )  ;", "assertEquals ( original ,    wrappedEx . getCause (  )  )  ;", "}", "verify ( messageProducer )  . close (  )  ;", "verify ( this . session )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestJmsException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    createTemplate (  )  ;", "template . setConnectionFactory ( this . connectionFactory )  ;", "String   destinationName    =     \" testDestination \"  ;", "if    ( useDefaultDestination )     {", "if    ( explicitDestination )     {", "template . setDefaultDestination ( this . queue )  ;", "} else    {", "template . setDefaultDestinationName ( destinationName )  ;", "}", "}", "if    ( noLocal )     {", "template . setPubSubNoLocal ( true )  ;", "}", "template . setReceiveTimeout ( timeout )  ;", "MessageConsumer   messageConsumer    =    mock ( MessageConsumer . class )  ;", "String   selectorString    =     \" selector \"  ;", "given ( this . session . createConsumer ( this . queue ,     ( messageSelector    ?    selectorString    :    null )  )  )  . willReturn ( messageConsumer )  ;", "if    (  (  !  ( useTransactedTemplate (  )  )  )     &  &     (  !  ( useTransactedSession (  )  )  )  )     {", "given ( this . session . getAcknowledgeMode (  )  )  . willReturn (  ( clientAcknowledge    ?    Session . CLIENT _ ACKNOWLEDGE    :    Session . AUTO _ ACKNOWLEDGE )  )  ;", "}", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "if    ( testConverter )     {", "given ( textMessage . getText (  )  )  . willReturn (  \" Hello   World !  \"  )  ;", "}", "if    ( timeout    =  =     ( JmsTemplate . RECEIVE _ TIMEOUT _ NO _ WAIT )  )     {", "given ( messageConsumer . receiveNoWait (  )  )  . willReturn ( textMessage )  ;", "} else", "if    ( timeout    =  =     ( JmsTemplate . RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT )  )     {", "given ( messageConsumer . receive (  )  )  . willReturn ( textMessage )  ;", "} else    {", "given ( messageConsumer . receive ( timeout )  )  . willReturn ( textMessage )  ;", "}", "Message   message    =    null ;", "String   textFromMessage    =    null ;", "if    ( useDefaultDestination )     {", "if    ( testConverter )     {", "textFromMessage    =     (  ( String )     (  ( messageSelector )     ?    template . receiveSelectedAndConvert ( selectorString )     :    template . receiveAndConvert (  )  )  )  ;", "} else    {", "message    =     ( messageSelector )     ?    template . receiveSelected ( selectorString )     :    template . receive (  )  ;", "}", "} else", "if    ( explicitDestination )     {", "if    ( testConverter )     {", "textFromMessage    =     (  ( String )     (  ( messageSelector )     ?    template . receiveSelectedAndConvert ( this . queue ,    selectorString )     :    template . receiveAndConvert ( this . queue )  )  )  ;", "} else    {", "message    =     ( messageSelector )     ?    template . receiveSelected ( this . queue ,    selectorString )     :    template . receive ( this . queue )  ;", "}", "} else    {", "if    ( testConverter )     {", "textFromMessage    =     (  ( String )     (  ( messageSelector )     ?    template . receiveSelectedAndConvert ( destinationName ,    selectorString )     :    template . receiveAndConvert ( destinationName )  )  )  ;", "} else    {", "message    =     ( messageSelector )     ?    template . receiveSelected ( destinationName ,    selectorString )     :    template . receive ( destinationName )  ;", "}", "}", "if    ( testConverter )     {", "assertEquals (  \" Message   text   should   be   equal \"  ,     \" Hello   World !  \"  ,    textFromMessage )  ;", "} else    {", "assertEquals (  \" Messages   should   refer   to   the   same   object \"  ,    message ,    textMessage )  ;", "}", "verify ( this . connection )  . start (  )  ;", "verify ( this . connection )  . close (  )  ;", "if    ( useTransactedTemplate (  )  )     {", "verify ( this . session )  . commit (  )  ;", "}", "verify ( this . session )  . close (  )  ;", "if    (  (  !  ( useTransactedSession (  )  )  )     &  &    clientAcknowledge )     {", "verify ( textMessage )  . acknowledge (  )  ;", "}", "verify ( messageConsumer )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestReceive"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    createTemplate (  )  ;", "template . setConnectionFactory ( this . connectionFactory )  ;", "String   destinationName    =     \" testDestination \"  ;", "if    ( useDefaultDestination )     {", "if    ( explicitDestination )     {", "template . setDefaultDestination ( this . queue )  ;", "} else    {", "template . setDefaultDestinationName ( destinationName )  ;", "}", "}", "template . setReceiveTimeout ( timeout )  ;", "Session   localSession    =    getLocalSession (  )  ;", "TemporaryQueue   replyDestination    =    mock ( TemporaryQueue . class )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "given ( localSession . createProducer ( this . queue )  )  . willReturn ( messageProducer )  ;", "given ( localSession . createTemporaryQueue (  )  )  . willReturn ( replyDestination )  ;", "MessageConsumer   messageConsumer    =    mock ( MessageConsumer . class )  ;", "given ( localSession . createConsumer ( replyDestination )  )  . willReturn ( messageConsumer )  ;", "TextMessage   request    =    mock ( TextMessage . class )  ;", "MessageCreator   messageCreator    =    mock ( MessageCreator . class )  ;", "given ( messageCreator . createMessage ( localSession )  )  . willReturn ( request )  ;", "TextMessage   reply    =    mock ( TextMessage . class )  ;", "if    ( timeout    =  =     ( JmsTemplate . RECEIVE _ TIMEOUT _ NO _ WAIT )  )     {", "given ( messageConsumer . receiveNoWait (  )  )  . willReturn ( reply )  ;", "} else", "if    ( timeout    =  =     ( JmsTemplate . RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT )  )     {", "given ( messageConsumer . receive (  )  )  . willReturn ( reply )  ;", "} else    {", "given ( messageConsumer . receive ( timeout )  )  . willReturn ( reply )  ;", "}", "Message   message    =    null ;", "if    ( useDefaultDestination )     {", "message    =    template . sendAndReceive ( messageCreator )  ;", "} else", "if    ( explicitDestination )     {", "message    =    template . sendAndReceive ( this . queue ,    messageCreator )  ;", "} else    {", "message    =    template . sendAndReceive ( destinationName ,    messageCreator )  ;", "}", "verify ( request )  . setJMSReplyTo ( replyDestination )  ;", "assertSame (  \" Reply   message   not   received \"  ,    reply ,    message )  ;", "verify ( this . connection )  . start (  )  ;", "verify ( this . connection )  . close (  )  ;", "verify ( localSession )  . close (  )  ;", "verify ( messageConsumer )  . close (  )  ;", "verify ( messageProducer )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestSendAndReceive"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    createTemplate (  )  ;", "template . setConnectionFactory ( this . connectionFactory )  ;", "String   destinationName    =     \" testDestination \"  ;", "if    ( useDefaultDestination )     {", "if    ( explicitDestination )     {", "template . setDefaultDestination ( this . queue )  ;", "} else    {", "template . setDefaultDestinationName ( destinationName )  ;", "}", "}", "if    ( disableIdAndTimestamp )     {", "template . setMessageIdEnabled ( false )  ;", "template . setMessageTimestampEnabled ( false )  ;", "}", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "given ( this . session . createProducer ( this . queue )  )  . willReturn ( messageProducer )  ;", "given ( this . session . createTextMessage (  \" just   testing \"  )  )  . willReturn ( textMessage )  ;", "if    (  ! ignoreQOS )     {", "template . setQosSettings ( this . qosSettings )  ;", "}", "if    ( useDefaultDestination )     {", "template . send ( new   MessageCreator (  )     {", "@ Override", "public   Message   createMessage ( Session   session )    throws   JMSException    {", "return   session . createTextMessage (  \" just   testing \"  )  ;", "}", "}  )  ;", "} else    {", "if    ( explicitDestination )     {", "template . send ( this . queue ,    new   MessageCreator (  )     {", "@ Override", "public   Message   createMessage ( Session   session )    throws   JMSException    {", "return   session . createTextMessage (  \" just   testing \"  )  ;", "}", "}  )  ;", "} else    {", "template . send ( destinationName ,    new   MessageCreator (  )     {", "@ Override", "public   Message   createMessage ( Session   session )    throws   JMSException    {", "return   session . createTextMessage (  \" just   testing \"  )  ;", "}", "}  )  ;", "}", "}", "if    ( useTransactedTemplate (  )  )     {", "verify ( this . session )  . commit (  )  ;", "}", "if    ( disableIdAndTimestamp )     {", "verify ( messageProducer )  . setDisableMessageID ( true )  ;", "verify ( messageProducer )  . setDisableMessageTimestamp ( true )  ;", "}", "if    ( ignoreQOS )     {", "verify ( messageProducer )  . send ( textMessage )  ;", "} else    {", "verify ( messageProducer )  . send ( textMessage ,    this . qosSettings . getDeliveryMode (  )  ,    this . qosSettings . getPriority (  )  ,    this . qosSettings . getTimeToLive (  )  )  ;", "}", "verify ( messageProducer )  . close (  )  ;", "verify ( this . session )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestSendDestination"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   this . session ;", "}", "METHOD_END"], "methodName": ["getLocalSession"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . jndiContext    =    mock ( Context . class )  ;", "this . connectionFactory    =    mock ( ConnectionFactory . class )  ;", "this . connection    =    mock ( Connection . class )  ;", "this . session    =    mock ( Session . class )  ;", "this . queue    =    mock ( Queue . class )  ;", "given ( this . connectionFactory . createConnection (  )  )  . willReturn ( this . connection )  ;", "given ( this . connection . createSession ( useTransacted (  )  ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( this . session )  ;", "given ( this . session . getTransacted (  )  )  . willReturn ( useTransactedSession (  )  )  ;", "given ( this . jndiContext . lookup (  \" testDestination \"  )  )  . willReturn ( this . queue )  ;", "}", "METHOD_END"], "methodName": ["setupMocks"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    createTemplate (  )  ;", "template . setConnectionFactory ( this . connectionFactory )  ;", "template . setMessageConverter ( new   SimpleMessageConverter (  )  )  ;", "String   s    =     \" Hello   world \"  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "given ( this . session . createProducer ( this . queue )  )  . willReturn ( messageProducer )  ;", "given ( this . session . createTextMessage (  \" Hello   world \"  )  )  . willReturn ( textMessage )  ;", "template . convertAndSend ( this . queue ,    s )  ;", "verify ( messageProducer )  . send ( textMessage )  ;", "verify ( messageProducer )  . close (  )  ;", "if    ( useTransactedTemplate (  )  )     {", "verify ( this . session )  . commit (  )  ;", "}", "verify ( this . session )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testConverter"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JMSException   jmsEx    =    new   JMSException (  \" could   not   connect \"  )  ;", "Exception   innerEx    =    new   Exception (  \" host   not   found \"  )  ;", "jmsEx . setLinkedException ( innerEx )  ;", "JmsException   JmsEx    =    JmsUtils . convertJmsAccessException ( jmsEx )  ;", "StringWriter   sw    =    new   StringWriter (  )  ;", "PrintWriter   out    =    new   PrintWriter ( sw )  ;", "JmsEx . printStackTrace ( out )  ;", "String   trace    =    sw . toString (  )  ;", "assertTrue (  \" inner   jms   exception   not   found \"  ,     (  ( trace . indexOf (  \" host   not   found \"  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testExceptionStackTrace"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   IllegalStateException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testIllegalStateException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   InvalidClientIDException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testInvalidClientIDException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   InvalidDestinationException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testInvalidDestinationException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   InvalidSelectorException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testInvalidSelectorException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   JMSSecurityException (  \"  \"  )  ,    JmsSecurityException . class )  ;", "}", "METHOD_END"], "methodName": ["testJmsSecurityException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   MessageEOFException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testMessageEOFException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   MessageFormatException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testMessageFormatException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   MessageNotReadableException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testMessageNotReadableException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   MessageNotWriteableException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testMessageNotWriteableException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    createTemplate (  )  ;", "template . setConnectionFactory ( this . connectionFactory )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "given ( this . session . createProducer ( null )  )  . willReturn ( messageProducer )  ;", "given ( messageProducer . getPriority (  )  )  . willReturn (  4  )  ;", "template . execute (  (  ( ProducerCallback < Void >  )     (  (    session 1  ,    producer )     -  >     {", "session 1  . getTransacted (  )  ;", "producer . getPriority (  )  ;", "return   null ;", "}  )  )  )  ;", "verify ( messageProducer )  . close (  )  ;", "verify ( this . session )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testProducerCallback"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    createTemplate (  )  ;", "template . setConnectionFactory ( this . connectionFactory )  ;", "template . setMessageIdEnabled ( false )  ;", "template . setMessageTimestampEnabled ( false )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "given ( this . session . createProducer ( null )  )  . willReturn ( messageProducer )  ;", "given ( messageProducer . getPriority (  )  )  . willReturn (  4  )  ;", "template . execute (  (  ( ProducerCallback < Void >  )     (  (    session 1  ,    producer )     -  >     {", "session 1  . getTransacted (  )  ;", "producer . getPriority (  )  ;", "return   null ;", "}  )  )  )  ;", "verify ( messageProducer )  . setDisableMessageID ( true )  ;", "verify ( messageProducer )  . setDisableMessageTimestamp ( true )  ;", "verify ( messageProducer )  . close (  )  ;", "verify ( this . session )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testProducerCallbackWithIdAndTimestampDisabled"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    true ,    true ,    false ,    false ,    false ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveAndConvertDefaultDestination"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( false ,    true ,    true ,    false ,    false ,    false ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveAndConvertDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    true ,    true ,    false ,    true ,    true ,    JmsTemplate . RECEIVE _ TIMEOUT _ NO _ WAIT )  ;", "}", "METHOD_END"], "methodName": ["testReceiveAndConvertDefaultDestinationWithSelector"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    false ,    true ,    false ,    false ,    true ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveAndConvertDestination"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( false ,    false ,    true ,    false ,    false ,    true ,    JmsTemplate . RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT )  ;", "}", "METHOD_END"], "methodName": ["testReceiveAndConvertDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( false ,    false ,    true ,    false ,    true ,    true ,    JmsTemplate . RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT )  ;", "}", "METHOD_END"], "methodName": ["testReceiveAndConvertDestinationNameWithSelector"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    false ,    true ,    false ,    true ,    false ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveAndConvertDestinationWithSelector"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    true ,    false ,    false ,    false ,    false ,    JmsTemplate . RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDefaultDestination"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( false ,    true ,    false ,    false ,    false ,    false ,    JmsTemplate . RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( false ,    true ,    false ,    false ,    true ,    true ,    JmsTemplate . RECEIVE _ TIMEOUT _ NO _ WAIT )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDefaultDestinationNameWithSelector"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    true ,    false ,    false ,    true ,    true ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDefaultDestinationWithSelector"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    false ,    false ,    false ,    false ,    true ,    JmsTemplate . RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDestination"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( false ,    false ,    false ,    false ,    false ,    true ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( false ,    false ,    false ,    false ,    true ,    false ,    JmsTemplate . RECEIVE _ TIMEOUT _ NO _ WAIT )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDestinationNameWithSelector"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    false ,    false ,    true ,    false ,    false ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDestinationWithClientAcknowledge"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    false ,    false ,    true ,    true ,    true ,    JmsTemplate . RECEIVE _ TIMEOUT _ INDEFINITE _ WAIT )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDestinationWithClientAcknowledgeWithSelector"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestReceive ( true ,    false ,    false ,    false ,    true ,    false ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["testReceiveDestinationWithSelector"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   ResourceAllocationException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testResourceAllocationException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendAndReceive ( true ,    true ,     1  0  0  0 L )  ;", "}", "METHOD_END"], "methodName": ["testSendAndReceiveDefaultDestination"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendAndReceive ( false ,    true ,     1  0  0  0 L )  ;", "}", "METHOD_END"], "methodName": ["testSendAndReceiveDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendAndReceive ( true ,    false ,     1  0  0  0 L )  ;", "}", "METHOD_END"], "methodName": ["testSendAndReceiveDestination"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendAndReceive ( false ,    false ,     1  0  0  0 L )  ;", "}", "METHOD_END"], "methodName": ["testSendAndReceiveDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendDestination ( true ,    true ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testSendDefaultDestination"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendDestination ( false ,    true ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testSendDefaultDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendDestination ( false ,    true ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSendDefaultDestinationNameWithQOS"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendDestination ( true ,    true ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSendDefaultDestinationWithQOS"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendDestination ( true ,    false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSendDestination"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendDestination ( false ,    false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSendDestinationName"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendDestination ( false ,    false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testSendDestinationNameWithQOS"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestSendDestination ( true ,    false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testSendDestinationWithQOS"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    createTemplate (  )  ;", "template . setConnectionFactory ( this . connectionFactory )  ;", "template . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   session )    throws   JMSException    {", "session . getTransacted (  )  ;", "return   null ;", "}", "}  )  ;", "verify ( this . session )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSessionCallback"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SingleConnectionFactory   scf    =    new   SingleConnectionFactory ( this . connectionFactory )  ;", "template    =    createTemplate (  )  ;", "template . setConnectionFactory ( scf )  ;", "TransactionSynchronizationManager . initSynchronization (  )  ;", "try    {", "template . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   session )    throws   JMSException    {", "session . getTransacted (  )  ;", "return   null ;", "}", "}  )  ;", "template . execute ( new   SessionCallback < Void >  (  )     {", "@ Override", "public   Void   doInJms ( Session   session )    throws   JMSException    {", "session . getTransacted (  )  ;", "return   null ;", "}", "}  )  ;", "assertSame ( this . session ,    ConnectionFactoryUtils . getTransactionalSession ( scf ,    null ,    false )  )  ;", "assertSame ( this . session ,    ConnectionFactoryUtils . getTransactionalSession ( scf ,    scf . createConnection (  )  ,    false )  )  ;", "TransactionAwareConnectionFactoryProxy   tacf    =    new   TransactionAwareConnectionFactoryProxy ( scf )  ;", "Connection   tac    =    tacf . createConnection (  )  ;", "Session   tas    =    tac . createSession ( false ,    AUTO _ ACKNOWLEDGE )  ;", "tas . getTransacted (  )  ;", "tas . close (  )  ;", "tac . close (  )  ;", "List < TransactionSynchronization >    synchs    =    TransactionSynchronizationManager . getSynchronizations (  )  ;", "assertEquals (  1  ,    synchs . size (  )  )  ;", "TransactionSynchronization   synch    =    synchs . get (  0  )  ;", "synch . beforeCommit ( false )  ;", "synch . beforeCompletion (  )  ;", "synch . afterCommit (  )  ;", "synch . afterCompletion ( STATUS _ UNKNOWN )  ;", "}    finally    {", "TransactionSynchronizationManager . clearSynchronization (  )  ;", "scf . destroy (  )  ;", "}", "assertTrue ( TransactionSynchronizationManager . getResourceMap (  )  . isEmpty (  )  )  ;", "verify ( this . connection )  . start (  )  ;", "if    ( useTransactedTemplate (  )  )     {", "verify ( this . session )  . commit (  )  ;", "}", "verify ( this . session )  . close (  )  ;", "verify ( this . connection )  . stop (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSessionCallbackWithinSynchronizedTransaction"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   TransactionInProgressException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testTransactionInProgressException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   TransactionRolledBackException (  \"  \"  )  ,    class )  ;", "}", "METHOD_END"], "methodName": ["testTransactionRolledBackException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsException ( new   JMSException (  \"  \"  )  ,    UncategorizedJmsException . class )  ;", "}", "METHOD_END"], "methodName": ["testUncategorizedJmsException"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["useTransactedSession"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["useTransactedTemplate"], "fileName": "org.springframework.jms.core.JmsTemplateTests"}, {"methodBody": ["METHOD_START", "{", "return   new   JmsTemplate ( connectionFactory )  ;", "}", "METHOD_END"], "methodName": ["createJmsTemplate"], "fileName": "org.springframework.jms.core.support.JmsGatewaySupport"}, {"methodBody": ["METHOD_START", "{", "return    ( this . jmsTemplate )     !  =    null    ?    this . jmsTemplate . getConnectionFactory (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getConnectionFactory"], "fileName": "org.springframework.jms.core.support.JmsGatewaySupport"}, {"methodBody": ["METHOD_START", "{", "return   this . jmsTemplate ;", "}", "METHOD_END"], "methodName": ["getJmsTemplate"], "fileName": "org.springframework.jms.core.support.JmsGatewaySupport"}, {"methodBody": ["METHOD_START", "{", "this . jmsTemplate    =    createJmsTemplate ( connectionFactory )  ;", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jms.core.support.JmsGatewaySupport"}, {"methodBody": ["METHOD_START", "{", "this . jmsTemplate    =    jmsTemplate ;", "}", "METHOD_END"], "methodName": ["setJmsTemplate"], "fileName": "org.springframework.jms.core.support.JmsGatewaySupport"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   mockConnectionFactory    =    mock ( ConnectionFactory . class )  ;", "final   List < String >    test    =    new   ArrayList <  >  (  1  )  ;", "gateway    =    new    (  )     {", "@ Override", "protected   void   initGateway (  )     {", "test . add (  \" test \"  )  ;", "}", "}  ;", "gateway . setConnectionFactory ( mockConnectionFactory )  ;", "gateway . afterPropertiesSet (  )  ;", "assertEquals (  \" Correct   ConnectionFactory \"  ,    mockConnectionFactory ,    gateway . getConnectionFactory (  )  )  ;", "assertEquals (  \" Correct   JmsTemplate \"  ,    mockConnectionFactory ,    gateway . getJmsTemplate (  )  . getConnectionFactory (  )  )  ;", "assertEquals (  \" initGatway   called \"  ,     1  ,    test . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJmsGatewaySupportWithConnectionFactory"], "fileName": "org.springframework.jms.core.support.JmsGatewaySupportTests"}, {"methodBody": ["METHOD_START", "{", "JmsTemplate   template    =    new   JmsTemplate (  )  ;", "final   List < String >    test    =    new   ArrayList <  >  (  1  )  ;", "gateway    =    new    (  )     {", "@ Override", "protected   void   initGateway (  )     {", "test . add (  \" test \"  )  ;", "}", "}  ;", "gateway . setJmsTemplate ( template )  ;", "gateway . afterPropertiesSet (  )  ;", "assertEquals (  \" Correct   JmsTemplate \"  ,    template ,    gateway . getJmsTemplate (  )  )  ;", "assertEquals (  \" initGateway   called \"  ,     1  ,    test . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJmsGatewaySupportWithJmsTemplate"], "fileName": "org.springframework.jms.core.support.JmsGatewaySupportTests"}, {"methodBody": ["METHOD_START", "{", "Connection   con    =    createConnection (  )  ;", "try    {", "prepareSharedConnection ( con )  ;", "return   con ;", "}    catch    ( JMSException   ex )     {", "JmsUtils . closeConnection ( con )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["createSharedConnection"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  (  ( ClassUtils . getShortName ( getClass (  )  )  )     +     \"    does   not   support   rescheduling   of   tasks \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doRescheduleTask"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( sharedConnectionEnabled (  )  )     {", "establishSharedConnection (  )  ;", "}", "synchronized ( thifecycleMonitor )     {", "this . running    =    true ;", "thifecycleMonitor . notifyAll (  )  ;", "resumePausedTasks (  )  ;", "}", "if    ( sharedConnectionEnabled (  )  )     {", "startSharedConnection (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doStart"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "this . running    =    false ;", "this . lifecycleMonitor . notifyAll (  )  ;", "}", "if    ( sharedConnectionEnabled (  )  )     {", "stopSharedConnection (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doStop"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . sharedConnectionMonitor )     {", "if    (  ( this . sharedConnection )     =  =    null )     {", "this . sharedConnection    =    createSharedConnection (  )  ;", "logger . debug (  \" Established   shared   JMS   Connection \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["establishSharedConnection"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . clientId ;", "}", "METHOD_END"], "methodName": ["getClientId"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return   this . pausedTasks . size (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPausedTaskCount"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( sharedConnectionEnabled (  )  )  )     {", "throw   new   IllegalStateException (  \" This   listener   container   does   not   maintain   a   shared   Connection \"  )  ;", "}", "synchronized ( this . sharedConnectionMonitor )     {", "if    (  ( this . sharedConnection )     =  =    null )     {", "throw   new    . SharedConnectionNotInitializedException (  \" This   listener   container ' s   shared   Connection   has   not   been   initialized   yet \"  )  ;", "}", "return   this . sharedConnection ;", "}", "}", "METHOD_END"], "methodName": ["getSharedConnection"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "try    {", "synchronized ( thifecycleMonitor )     {", "this . active    =    true ;", "thifecycleMonitor . notifyAll (  )  ;", "}", "doInitialize (  )  ;", "}    catch    ( JMSException   ex )     {", "synchronized ( this . sharedConnectionMonitor )     {", "ConnectionFactoryUtils . releaseConnection ( this . sharedConnection ,    getConnectionFactory (  )  ,    this . autoStartup )  ;", "this . sharedConnection    =    null ;", "}", "throw   convertJmsAccessException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return   this . active ;", "}", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Listener   c   task    [  \"     +    task )     +     \"  ]    has   been   rejected   and   paused :     \"  )     +    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["logRejectedTask"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "String   clientId    =    getClientId (  )  ;", "if    ( clientId    !  =    null )     {", "connection . setClientID ( clientId )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareSharedConnection"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . sharedConnectionMonitor )     {", "ConnectionFactoryUtils . releaseConnection ( this . sharedConnection ,    getConnectionFactory (  )  ,    this . sharedConnectionStarted )  ;", "this . sharedConnection    =    null ;", "this . sharedConnection    =    createSharedConnection (  )  ;", "if    ( this . sharedConnectionStarted )     {", "this . sharedConnection . start (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["refreshSharedConnection"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( this . running )     {", "try    {", "doRescheduleTask ( task )  ;", "}    catch    ( RuntimeException   ex )     {", "logRejectedTask ( task ,    ex )  ;", "this . pausedTasks . add ( task )  ;", "}", "return   true ;", "} else", "if    ( this . active )     {", "this . pausedTasks . add ( task )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["rescheduleTaskIfNecessary"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "if    (  !  ( this . pausedTasks . isEmpty (  )  )  )     {", "for    ( Iterator <  ?  >    it    =    this . pausedTasks . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Object   task    =    it . next (  )  ;", "try    {", "doRescheduleTask ( task )  ;", "it . remove (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Resumed   paused   task :     \"     +    task )  )  ;", "}", "}    catch    ( RuntimeException   ex )     {", "logRejectedTask ( task ,    ex )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["resumePausedTasks"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["runningAllowed"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "this . clientId    =    clientId ;", "}", "METHOD_END"], "methodName": ["setClientId"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "this . phase    =    phase ;", "}", "METHOD_END"], "methodName": ["setPhase"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  \" Shutting   down   JMS   listener   container \"  )  ;", "boolean   wasRunning ;", "synchronized ( this . lifecycleMonitor )     {", "wasRunning    =    this . running ;", "this . running    =    false ;", "this . active    =    false ;", "this . pausedTasks . clear (  )  ;", "this . lifecycleMonitor . notifyAll (  )  ;", "}", "if    ( wasRunning    &  &     ( sharedConnectionEnabled (  )  )  )     {", "try    {", "stopSharedConnection (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . debug (  \" Could   not   stop   JMS   Connection   on   shutdown \"  ,    ex )  ;", "}", "}", "try    {", "doShutdown (  )  ;", "}    catch    ( JMSException   ex )     {", "throw   convertJmsAccessException ( ex )  ;", "}    finally    {", "if    ( sharedConnectionEnabled (  )  )     {", "synchronized ( this . sharedConnectionMonitor )     {", "ConnectionFactoryUtils . releaseConnection ( this . sharedConnection ,    getConnectionFactory (  )  ,    false )  ;", "this . sharedConnection    =    null ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . sharedConnectionMonitor )     {", "this . sharedConnectionStarted    =    true ;", "if    (  ( this . sharedConnection )     !  =    null )     {", "try    {", "this . sharedConnection . start (  )  ;", "}    catch    ( javax   ex )     {", "logger . debug (  (  \" Ignoring   Connection   start   exception    -    assuming   already   started :     \"     +    ex )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["startSharedConnection"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . sharedConnectionMonitor )     {", "this . sharedConnectionStarted    =    false ;", "if    (  ( this . sharedConnection )     !  =    null )     {", "try    {", "this . sharedConnection . stop (  )  ;", "}    catch    ( javax   ex )     {", "logger . debug (  (  \" Ignoring   Connection   stop   exception    -    assuming   already   stopped :     \"     +    ex )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["stopSharedConnection"], "fileName": "org.springframework.jms.listener.AbstractJmsListeningContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( messageListener    !  =    null )     &  &     (  !  (  ( messageListener   instanceof   MessageListener )     |  |     ( messageListener   instanceof   SessionAwareMessageListener )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Message   listener   needs   to   be   of   type    [  \"     +     ( MessageListener . class . getName (  )  )  )     +     \"  ]    or    [  \"  )     +     ( SessionAwareMessageListener . class . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkMessageListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( session . getTransacted (  )  )     {", "if    ( isSessionLocallyTransacted ( session )  )     {", "JmsUtils . commitIfNecessary ( session )  ;", "}", "} else", "if    (  ( m    !  =    null )     &  &     ( isClientAcknowledge ( session )  )  )     {", "m . acknowledge (  )  ;", "}", "}", "METHOD_END"], "methodName": ["commitIfNecessary"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( isPubSubDomain (  )  )     &  &     ( destination   instanceof   Topic )  )     {", "if    ( isSubscriptionShared (  )  )     {", "return   isSubscriptionDurable (  )     ?    session . createSharedDurableConsumer (  (  ( Topic )     ( destination )  )  ,    getSubscriptionName (  )  ,    geSelector (  )  )     :    session . createSharedConsumer (  (  ( Topic )     ( destination )  )  ,    getSubscriptionName (  )  ,    geSelector (  )  )  ;", "} else", "if    ( isSubscriptionDurable (  )  )     {", "return   session . createDurableSubscriber (  (  ( Topic )     ( destination )  )  ,    getSubscriptionName (  )  ,    geSelector (  )  ,    isPubSubNoLocal (  )  )  ;", "} else    {", "return   session . createConsumer ( destination ,    geSelector (  )  ,    isPubSubNoLocal (  )  )  ;", "}", "} else    {", "return   session . createConsumer ( destination ,    geSelector (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createConsumer"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( isAcceptMessagesWhileStopping (  )  )  )     &  &     (  !  ( isRunning (  )  )  )  )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Rejecting   received   message   because   of   the   listener   container    \"     +     \" having   been   stopped   in   the   meantime :     \"  )     +    message )  )  ;", "}", "rollbackIfNecessary ( session )  ;", "throw   new    . MessageRejectedWhileStoppingException (  )  ;", "}", "try    {", "invokeListener ( session ,    message )  ;", "}    catch    ( JMSException    |    RuntimeException    |    Error   ex )     {", "rollbackOnExceptionIfNecessary ( session ,    ex )  ;", "throw   ex ;", "}", "commitIfNecessary ( session ,    message )  ;", "}", "METHOD_END"], "methodName": ["doExecuteListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "listener . onMessage ( message )  ;", "}", "METHOD_END"], "methodName": ["doInvokeListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Connection   conToClose    =    null ;", "Session   sessionToClose    =    null ;", "try    {", "Session   sessionToUse    =    session ;", "if    (  !  ( isExposSession (  )  )  )     {", "conToClose    =    createConnection (  )  ;", "sessionToClose    =    createSession ( conToClose )  ;", "sessionToUse    =    sessionToClose ;", "}", "listener . onMessage ( message ,    sessionToUse )  ;", "if    ( sessionToUse    !  =    session )     {", "if    (  ( sessionToUse . getTransacted (  )  )     &  &     ( isSessionLocallyTransacted ( sessionToUse )  )  )     {", "JmsUtils . commitIfNecessary ( sessionToUse )  ;", "}", "}", "}    finally    {", "JmsUtils . closeSession ( sessionToClose )  ;", "JmsUtils . closeConnection ( conToClose )  ;", "}", "}", "METHOD_END"], "methodName": ["doInvokeListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "try    {", "doExecut ( session ,    message )  ;", "}    catch    ( Throwable   ex )     {", "handlException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["executeListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( messageListener   instanceof   SubscriptionNameProvider )     {", "return    (  ( SubscriptionNameProvider )     ( messageListener )  )  . getSubscriptionName (  )  ;", "} else    {", "return   messageListener . getClass (  )  . getName (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDefaultSubscriptionName"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . destination )    instanceof   Destination    ?     (  ( Destination )     ( this . destination )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDestination"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Object   destination    =    this . destination ;", "return   destination    !  =    null    ?    destination . toSt (  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getDestinationDescription"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . destination )    instanceof   String    ?     (  ( String )     ( this . destination )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDestinationName"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionDurable    ?    this . subscriptionName    :    null ;", "}", "METHOD_END"], "methodName": ["getDurableSubscriptionName"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . errorHandler ;", "}", "METHOD_END"], "methodName": ["getErrorHandler"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . exceptionListener ;", "}", "METHOD_END"], "methodName": ["getExceptionListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . messageListener ;", "}", "METHOD_END"], "methodName": ["getMessageListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSelector ;", "}", "METHOD_END"], "methodName": ["getMessageSelector"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionName ;", "}", "METHOD_END"], "methodName": ["getSubscriptionName"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   AbstractMessageListenerContainer . MessageRejectedWhileStoppingException )     {", "return ;", "}", "if    ( ex   instanceof   JMSException )     {", "invokeExceptionListener (  (  ( JMSException )     ( ex )  )  )  ;", "}", "if    ( isActive (  )  )     {", "invokeErrorHandler ( ex )  ;", "} else    {", "logger . debug (  \" Listener   exception   after   container   shutdown \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["handleListenerException"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "ErrorHandler   errorHandler    =    getErrorHandler (  )  ;", "if    ( errorHandler    !  =    null )     {", "errorHandler . handleError ( ex )  ;", "} else    {", "logger . warn (  \" Execution   of   JMS   message      failed ,    and   no   ErrorHandler   has   been   set .  \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeErrorHandler"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "ExceptionListener   exceptionListener    =    getExceptionListener (  )  ;", "if    ( exceptionListener    !  =    null )     {", "exceptionListener . onException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeExceptionListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Object   listener    =    getMessageListener (  )  ;", "if    ( listener   instanceof   SessionAwareMessageListener )     {", "doInvokeListener (  (  ( SessionAwareMessageListener )     ( listener )  )  ,    session ,    message )  ;", "} else", "if    ( listener   instanceof   MessageListener )     {", "doInvokeListener (  (  ( MessageListener )     ( listener )  )  ,    message )  ;", "} else", "if    ( listener    !  =    null )     {", "throw   new   IllegalArgumentException (  (  \" Only   MessageListener   and   SessionAwareMessageListener   supported :     \"     +    listener )  )  ;", "} else    {", "throw   new   IllegalStateException (  \" No   message   listener   specified    -    see   property    ' messageListener '  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . acceptMessagesWhileStopping ;", "}", "METHOD_END"], "methodName": ["isAcceptMessagesWhileStopping"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . exposeListenerSession ;", "}", "METHOD_END"], "methodName": ["isExposeListenerSession"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . pubSubNoLocal ;", "}", "METHOD_END"], "methodName": ["isPubSubNoLocal"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   isSessionTransacted (  )  ;", "}", "METHOD_END"], "methodName": ["isSessionLocallyTransacted"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionDurable ;", "}", "METHOD_END"], "methodName": ["isSubscriptionDurable"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionShared ;", "}", "METHOD_END"], "methodName": ["isSubscriptionShared"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( session . getTransacted (  )  )     {", "if    ( isSessionLocallyTransacted ( session )  )     {", "JmsUtils . rollbackIfNecry ( session )  ;", "}", "} else", "if    ( isClientAcknowledge ( session )  )     {", "session . recover (  )  ;", "}", "}", "METHOD_END"], "methodName": ["rollbackIfNecessary"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( session . getTransacted (  )  )     {", "if    ( isSessionLocallyTransacted ( session )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  \" Initiating   transaction   rollback   on   application   exception \"  ,    ex )  ;", "}", "JmsUtils . rollbackIfNecry ( session )  ;", "}", "} else", "if    ( isClientAcknowledge ( session )  )     {", "session . recover (  )  ;", "}", "}    catch    ( IllegalStateException   ex 2  )     {", "logger . debug (  \" Could   not   roll   back   because   Session   already   closed \"  ,    ex 2  )  ;", "}    catch    ( JMSException    |    RuntimeException    |    Error   ex 2  )     {", "logger . error (  \" Application   exception   overridden   by   rollback   error \"  ,    ex )  ;", "throw   ex 2  ;", "}", "}", "METHOD_END"], "methodName": ["rollbackOnExceptionIfNecessary"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . acceptMessagesWhileStopping    =    acceptMessagesWhileStopping ;", "}", "METHOD_END"], "methodName": ["setAcceptMessagesWhileStopping"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . destination    =    destination ;", "if    (  ( destination   instanceof   Topic )     &  &     (  !  ( destination   instanceof   Queue )  )  )     {", "setPubSubDom ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["setDestination"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . destination    =    destinationName ;", "}", "METHOD_END"], "methodName": ["setDestinationName"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionName    =    durableSubscriptionName ;", "this . subscriptionDurable    =    durableSubscriptionName    !  =    null ;", "}", "METHOD_END"], "methodName": ["setDurableSubscriptionName"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . exceptionListener    =    exceptionListener ;", "}", "METHOD_END"], "methodName": ["setExceptionListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . exposeListenerSession    =    exposeListenerSession ;", "}", "METHOD_END"], "methodName": ["setExposeListenerSession"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . messageConverter    =    messageConverter ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "checkMessageListener ( messageListener )  ;", "this . messageListener    =    messageListener ;", "if    (  ( messageListener    !  =    null )     &  &     (  ( this . subscriptionName )     =  =    null )  )     {", "this . subscriptionName    =    getDefaultSubscriptionName ( messageListener )  ;", "}", "}", "METHOD_END"], "methodName": ["setMessageListener"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . messageSelector    =    messageSelector ;", "}", "METHOD_END"], "methodName": ["setMessageSelector"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . pubSubNoLocal    =    pubSubNoLocal ;", "}", "METHOD_END"], "methodName": ["setPubSubNoLocal"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . replyPubSubDomain    =    replyPubSubDomain ;", "}", "METHOD_END"], "methodName": ["setReplyPubSubDomain"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . replyQosSettings    =    replyQosSettings ;", "}", "METHOD_END"], "methodName": ["setReplyQosSettings"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionDurable    =    subscriptionDurable ;", "if    ( subscriptionDurable )     {", "setPubSubDom ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["setSubscriptionDurable"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionName    =    subscriptionName ;", "}", "METHOD_END"], "methodName": ["setSubscriptionName"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionShared    =    subscriptionShared ;", "if    ( subscriptionShared )     {", "setPubSubDom ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["setSubscriptionShared"], "fileName": "org.springframework.jms.listener.AbstractMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    getDestination (  )  ;", "if    ( destination    =  =    null )     {", "St   destinationName    =    getDestinationName (  )  ;", "Assert . state (  ( destinationName    !  =    null )  ,     \" No   destination   set \"  )  ;", "destination    =    resolveDestinationName ( session ,    destinationName )  ;", "}", "return   createConsumer ( session ,    destination )  ;", "}", "METHOD_END"], "methodName": ["createListenerConsumer"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Connection   conToClose    =    null ;", "Session   sessionToClose    =    null ;", "MessageConsumer   consumerToClose    =    null ;", "try    {", "Session   sessionToUse    =    session ;", "boolean   transactional    =    false ;", "if    ( sessionToUse    =  =    null )     {", "sessionToUse    =    ConnectionFactoryUtils . doGetTransactionalSession ( obtainConnectionFactory (  )  ,    this . transactionalResourceFactory ,    true )  ;", "transactional    =    sessionToUse    !  =    null ;", "}", "if    ( sessionToUse    =  =    null )     {", "Connection   conToUse ;", "if    ( sharedConnectionEnabled (  )  )     {", "conToUse    =    getSharedConnection (  )  ;", "} else    {", "conToUse    =    createConnection (  )  ;", "conToClose    =    conToUse ;", "conToUse . start (  )  ;", "}", "sessionToUse    =    createSession ( conToUse )  ;", "sessionToClose    =    sessionToUse ;", "}", "MessageConsumer   consumerToUse    =    consumer ;", "if    ( consumerToUse    =  =    null )     {", "consumerToUse    =    creatsumer ( sessionToUse )  ;", "consumerToClose    =    consumerToUse ;", "}", "Message   message    =    receiveMessage ( consumerToUse )  ;", "if    ( message    !  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  (  (  (  \" Received   message   of   type    [  \"     +     ( message . getClass (  )  )  )     +     \"  ]    from   consumer    [  \"  )     +    consumerToUse )     +     \"  ]    of    \"  )     +     ( transactional    ?     \" transactional    \"     :     \"  \"  )  )     +     \" session    [  \"  )     +    sessionToUse )     +     \"  ]  \"  )  )  ;", "}", "messageReceived ( invoker ,    sessionToUse )  ;", "boolean   exposeResource    =     (  (  ! transactional )     &  &     ( isExposeListenerSession (  )  )  )     &  &     (  !  ( TransactionSynchronizationManager . hasResource ( obtainConnectionFactory (  )  )  )  )  ;", "if    ( exposeResource )     {", "TransactionSynchronizationManager . bindResource ( obtainConnectionFactory (  )  ,    new   LocallyExposedJmsResourceHolder ( sessionToUse )  )  ;", "}", "try    {", "doExecuteListener ( sessionToUse ,    message )  ;", "}    catch    ( Throwable   ex )     {", "if    ( status    !  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Rolling   back   transaction   because   of   listener   exception   thrown :     \"     +    ex )  )  ;", "}", "status . setRollbackOnly (  )  ;", "}", "handleListenerException ( ex )  ;", "if    ( ex   instanceof   JMSException )     {", "throw    (  ( JMSException )     ( ex )  )  ;", "}", "}    finally    {", "if    ( exposeResource )     {", "TransactionSynchronizationManager . unbindResource ( obtainConnectionFactory (  )  )  ;", "}", "}", "return   true ;", "} else    {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  (  (  \" Consumer    [  \"     +    consumerToUse )     +     \"  ]    of    \"  )     +     ( transactional    ?     \" transactional    \"     :     \"  \"  )  )     +     \" session    [  \"  )     +    sessionToUse )     +     \"  ]    did   not   receive   a   message \"  )  )  ;", "}", "noMessageReceived ( invoker ,    sessionToUse )  ;", "if    ( shouldCommitAfterNoMessageReceived ( sessionToUse )  )     {", "commitIfNecessary ( sessionToUse ,    null )  ;", "}", "return   false ;", "}", "}    finally    {", "JmsUtils . closeMessageConsumer ( consumerToClose )  ;", "JmsUtils . closeSession ( sessionToClose )  ;", "ConnectionFactoryUtils . releaseConnection ( conToClose ,    getConnectionFactory (  )  ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["doReceiveAndExecute"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   holder . getConnection (  )  ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . receiveTimeout ;", "}", "METHOD_END"], "methodName": ["getReceiveTimeout"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   holder . getSession (  )  ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . transactionManager )     !  =    null )     {", "TransactionStatus   status    =    this . transactionManager . getTransaction ( this . transactionDefinition )  ;", "boolean   mReceived ;", "try    {", "mReceived    =    doReceiveAndExecute ( invoker ,    session ,    consumer ,    status )  ;", "}    catch    ( JMSException    |    RuntimeException    |    Error   ex )     {", "rollbackOnException ( this . transactionManager ,    status ,    ex )  ;", "throw   ex ;", "}", "this . transactionManager . commit ( status )  ;", "return   mReceived ;", "} else    {", "return   doReceiveAndExecute ( invoker ,    session ,    consumer ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["receiveAndExecute"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   receiveFromConsumer ( consumer ,    getReceiveTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["receiveMessage"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  \" Initiating   transaction   rollback   on   listener   exception \"  ,    ex )  ;", "try    {", "manager . rollback ( status )  ;", "}    catch    ( RuntimeException   ex 2  )     {", "logger . error (  \" Listener   exception   overridden   by   rollback   exception \"  ,    ex )  ;", "throw   ex 2  ;", "}    catch    ( Error   err )     {", "logger . error (  \" Listener   exception   overridden   by   rollback   error \"  ,    ex )  ;", "throw   err ;", "}", "}", "METHOD_END"], "methodName": ["rollbackOnException"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . receiveTimeout    =    receiveTimeout ;", "}", "METHOD_END"], "methodName": ["setReceiveTimeout"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . transactionManager    =    transactionManager ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . transactionDefinition . setName ( transactionName )  ;", "}", "METHOD_END"], "methodName": ["setTransactionName"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . transactionDefinition . setTimeout ( transactionTimeout )  ;", "}", "METHOD_END"], "methodName": ["setTransactionTimeout"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldCommitAfterNoMessageReceived"], "fileName": "org.springframework.jms.listener.AbstractPollingMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . recovering )     &  &     ( this . interrupted )  )     {", "return   false ;", "}", "long   interval    =    execution . nextBackOff (  )  ;", "if    ( interval    =  =     ( BackOffExecution . STOP )  )     {", "return   false ;", "} else    {", "try    {", "synchronized ( this . lifecycleMonitor )     {", "this . lifecycleMonitor . wait ( interval )  ;", "}", "}    catch    ( InterruptedException   interEx )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "if    ( this . recovering )     {", "this . interrupted    =    true ;", "}", "}", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["applyBackOffTime"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =    getBeanName (  )  ;", "String   threadNamePrefix    =     ( beanName    !  =    null )     ?    beanName    +     \"  -  \"     :     . DEFAULT _ THREAD _ NAME _ PREFIX ;", "return   new   SimpleAsyncTaskExecutor ( threadNamePrefix )  ;", "}", "METHOD_END"], "methodName": ["createDefaultTaskExecutor"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return   this . activeInvokerCount ;", "}", "}", "METHOD_END"], "methodName": ["getActiveConsumerCount"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheLevel ;", "}", "METHOD_END"], "methodName": ["getCacheLevel"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return   this . concurrentConsumers ;", "}", "}", "METHOD_END"], "methodName": ["getConcurrentConsumers"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return   this . idleConsumerLimit ;", "}", "}", "METHOD_END"], "methodName": ["getIdleConsumerLimit"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "for    (  . AsyncMessageListenerInvoker   invoker    :    this . scheduledInvokers )     {", "if    ( invoker . isIdle (  )  )     {", "count +  +  ;", "}", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["getIdleInvokerCount"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return   this . idleTaskExecutionLimit ;", "}", "}", "METHOD_END"], "methodName": ["getIdleTaskExecutionLimit"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return   this . maxConcurrentConsumers ;", "}", "}", "METHOD_END"], "methodName": ["getMaxConcurrentConsumers"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return   this . maxsPerTask ;", "}", "}", "METHOD_END"], "methodName": ["getMaxMessagesPerTask"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return   this . scheduledInvokers . size (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getScheduledConsumerCount"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   JMSException )     {", "invokeExceptionListener (  (  ( JMSException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   AbstractJmsListening . SharedConnectionNotInitializedException )     {", "if    (  ! alreadyRecovered )     {", "logger . info (  \" JMS   message   listener   invoker   needs   to   establish   shared   Connection \"  )  ;", "}", "} else    {", "if    ( alreadyRecovered )     {", "logger . debug (  \" Setup   of   JMS   message   listener   invoker   failed    -    already   recovered   by   other   invoker \"  ,    ex )  ;", "} else    {", "StringBuilder   msg    =    new   StringBuilder (  )  ;", "msg . append (  \" Setup   of   JMS   message   listener   invoker   failed   for   destination    '  \"  )  ;", "msg . append ( getDestinationDescription (  )  )  . append (  \"  '     -    trying   to   recover .    Cause :     \"  )  ;", "msg . append (  ( ex   instanceof   JMSException    ?    JmsUtils . buildExceptionMessage (  (  ( JMSException )     ( ex )  )  )     :    ex . getMessage (  )  )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . warn ( msg ,    ex )  ;", "} else    {", "logger . warn ( msg )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["handleListenerSetupFailure"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "return   this . recovering ;", "}", "METHOD_END"], "methodName": ["isRecovering"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . lifecycleMonitor )     {", "return    ( this . registeredWithDestination )     >     0  ;", "}", "}", "METHOD_END"], "methodName": ["isRegisteredWithDestination"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . recovering    =    true ;", "try    {", "refreshConnectionUntilSuccessful (  )  ;", "refreshDestination (  )  ;", "}    finally    {", "this . recovering    =    false ;", "this . interrupted    =    false ;", "}", "}", "METHOD_END"], "methodName": ["recoverAfterListenerSetupFailure"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "BackOffExecution   execution    =    this . backOff . start (  )  ;", "while    ( isRunning (  )  )     {", "try    {", "if    ( sharedConnectionEnabled (  )  )     {", "refreshSharedConnection (  )  ;", "} else    {", "Connection   con    =    createConnection (  )  ;", "JmsUtils . closeConnection ( con )  ;", "}", "logger . info (  \" Successfully   refreshed   JMS   Connection \"  )  ;", "break ;", "}    catch    ( Exception   ex )     {", "if    ( ex   instanceof   JMSException )     {", "invokeException (  (  ( JMSException )     ( ex )  )  )  ;", "}", "StringBuilder   msg    =    new   StringBuilder (  )  ;", "msg . append (  \" Could   not   refresh   JMS   Connection   for   destination    '  \"  )  ;", "msg . append ( getDestinationDescription (  )  )  . append (  \"  '     -    retrying   using    \"  )  ;", "msg . append ( execution )  . append (  \"  .    Cause :     \"  )  ;", "msg . append (  ( ex   instanceof   JMSException    ?    JmsUtils . buildExceptionMessage (  (  ( JMSException )     ( ex )  )  )     :    ex . getMessage (  )  )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . error ( msg ,    ex )  ;", "} else    {", "logger . error ( msg )  ;", "}", "}", "if    (  !  ( applyBackOffTime ( execution )  )  )     {", "StringBuilder   msg    =    new   StringBuilder (  )  ;", "msg . append (  \" Stopping   container   for   destination    '  \"  )  . append ( getDestinationDescription (  )  )  . append (  \"  '  :    back - off   policy   does   not   allow    \"  )  . append (  \" for   further   attempts .  \"  )  ;", "logger . error ( msg . toString (  )  )  ;", "stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["refreshConnectionUntilSuccessful"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "String   destName    =    getDestinationName (  )  ;", "if    ( destName    !  =    null )     {", "DestinationResolver   destResolver    =    getDestinationResolver (  )  ;", "if    ( destResolver   instanceof   CachingDestinationResolver )     {", "(  ( CachingDestinationResolver )     ( destResolver )  )  . removeFromCache ( destName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["refreshDestination"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer . AsyncMessageListenerInvoker   invoker    =    new   DefaultMessageListenerContainer . AsyncMessageListenerInvoker (  )  ;", "if    ( rescheduleTaskIfNecessary ( invoker )  )     {", "this . scheduledInvokers . add ( invoker )  ;", "}", "}", "METHOD_END"], "methodName": ["scheduleNewInvoker"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( isRunning (  )  )     {", "resumePausedTasks (  )  ;", "synchronized ( thifecycleMonitor )     {", "if    (  (  ( this . scheduledInvokers . size (  )  )     <     ( this . maxConcurrentConsumers )  )     &  &     (  ( getIdleInvokerCount (  )  )     <     ( this . idleConsumerLimit )  )  )     {", "scheduleNewInvoker (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Raised   scheduled   invoker   count :     \"     +     ( this . scheduledInvokers . size (  )  )  )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["scheduleNewInvokerIfAppropriate"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . backOff    =    backOff ;", "}", "METHOD_END"], "methodName": ["setBackOff"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . cacheLevel    =    cacheLevel ;", "}", "METHOD_END"], "methodName": ["setCacheLevel"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( constantName . startsWith (  \" CACHE _  \"  )  )  )     {", "throw   new   IllegalArgumentException (  \" Only   cache   constants   allowed \"  )  ;", "}", "setCacheLevel (  . constants . asNumber ( constantName )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setCacheLevelName"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( concurrentConsumers    >     0  )  ,     \"  ' concurrentConsumers '    value   must   be   at   least    1     ( one )  \"  )  ;", "synchronized ( thifecycleMonitor )     {", "this . concurrentConsumers    =    concurrentConsumers ;", "if    (  ( this . maxConcurrentConsumers )     <    concurrentConsumers )     {", "this . maxConcurrentConsumers    =    concurrentConsumers ;", "}", "}", "}", "METHOD_END"], "methodName": ["setConcurrentConsumers"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( idleConsumerLimit    >     0  )  ,     \"  ' idleConsumerLimit '    must   be    1    or   higher \"  )  ;", "synchronized ( thifecycleMonitor )     {", "this . idleConsumerLimit    =    idleConsumerLimit ;", "}", "}", "METHOD_END"], "methodName": ["setIdleConsumerLimit"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( idleTaskExecutionLimit    >     0  )  ,     \"  ' idleTaskExecutionLimit '    must   be    1    or   higher \"  )  ;", "synchronized ( thifecycleMonitor )     {", "this . idleTaskExecutionLimit    =    idleTaskExecutionLimit ;", "}", "}", "METHOD_END"], "methodName": ["setIdleTaskExecutionLimit"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( maxConcurrentConsumers    >     0  )  ,     \"  ' maxConcurrentConsumers '    value   must   be   at   least    1     ( one )  \"  )  ;", "synchronized ( thifecycleMonitor )     {", "this . maxConcurrentConsumers    =     ( maxConcurrentConsumers    >     ( this . concurrentConsumers )  )     ?    maxConcurrentConsumers    :    this . concurrentConsumers ;", "}", "}", "METHOD_END"], "methodName": ["setMaxConcurrentConsumers"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( maxMessagesPerTask    !  =     0  )  ,     \"  ' maxMessagesPerTask '    must   not   be    0  \"  )  ;", "synchronized ( this . lifecycleMonitor )     {", "this . maxMessagesPerTask    =    maxMessagesPerTask ;", "}", "}", "METHOD_END"], "methodName": ["setMaxMessagesPerTask"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . backOff    =    new   FixedBackOff ( recoveryInterval ,    Long . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["setRecoveryInterval"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "boolean   superfluous    =     ( idleTaskExecutionCount    >  =     ( this . idleTaskExecutionLimit )  )     &  &     (  ( getIdleInvokerCount (  )  )     >     1  )  ;", "return    ( this . scheduledInvokers . size (  )  )     <  =     ( superfluous    ?    this . concurrentConsumers    :    this . maxConcurrentConsumers )  ;", "}", "METHOD_END"], "methodName": ["shouldRescheduleInvoker"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "BackOff   backOff    =    mock ( BackOff . class )  ;", "BackOffExecution   execution    =    mock ( BackOffExecution . class )  ;", "given ( execution . nextBackOff (  )  )  . willReturn ( STOP )  ;", "given ( backOff . start (  )  )  . willReturn ( execution )  ;", "container    =    createContainer ( createFailingContainerFactory (  )  )  ;", "container . setBackOff ( backOff )  ;", "container . start (  )  ;", "assertEquals ( true ,    container . isRunning (  )  )  ;", "container . refreshConnectionUntilSuccessful (  )  ;", "assertEquals ( false ,    container . isRunning (  )  )  ;", "verify ( backOff )  . start (  )  ;", "verify ( execution )  . nextBackOff (  )  ;", "}", "METHOD_END"], "methodName": ["applyBackOff"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "BackOff   backOff    =    mock ( BackOff . class )  ;", "BackOffExecution   execution    =    mock ( BackOffExecution . class )  ;", "given ( execution . nextBackOff (  )  )  . willReturn (  5  0 L ,    STOP )  ;", "given ( backOff . start (  )  )  . willReturn ( execution )  ;", "container    =    createContainer ( createFailingContainerFactory (  )  )  ;", "container . setBackOff ( backOff )  ;", "container . start (  )  ;", "container . refreshConnectionUntilSuccessful (  )  ;", "assertEquals ( false ,    container . isRunning (  )  )  ;", "verify ( backOff )  . start (  )  ;", "verify ( execution ,    times (  2  )  )  . nextBackOff (  )  ;", "}", "METHOD_END"], "methodName": ["applyBackOffRetry"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "container    =    new    (  )  ;", "container . setConnectionFactory ( connectionFactory )  ;", "container . setCacheLevel (  . CACHE _ NONE )  ;", "container . setDestination ( destination )  ;", "return   container ;", "}", "METHOD_END"], "methodName": ["createContainer"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . will (  (    invocation )     -  >     {", "throw   new   JMSException (  \"    exception \"  )  ;", "}  )  ;", "return   connectionFactory ;", "}    catch    ( JMSException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createFailingContainerFactory"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . will ( new   mockito . stubbing . Answer < Object >  (  )     {", "int   currentAttempts    =     0  ;", "@ Override", "public   Object   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "( currentAttempts )  +  +  ;", "if    (  ( currentAttempts )     <  =    failingAttempts )     {", "throw   new   JMSException (  (  (  \" Test   exception    ( attempt    \"     +     ( currentAttempts )  )     +     \"  )  \"  )  )  ;", "} else    {", "return   mock ( Connection . class )  ;", "}", "}", "}  )  ;", "return   connectionFactory ;", "}    catch    ( JMSException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createRecoverableContainerFactory"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   container    =    createContainer ( createSuccessfulConnectionFactory (  )  )  ;", "container . afterPropertiesSet (  )  ;", "container . start (  )  ;", "return   container ;", "}", "METHOD_END"], "methodName": ["createRunningContainer"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "nectionFactory   connectionFactory    =    mock ( nectionFactory . class )  ;", "given ( connectionFactory . createnection (  )  )  . willReturn ( mock ( nection . class )  )  ;", "return   connectionFactory ;", "}    catch    ( JMSException   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createSuccessfulConnectionFactory"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "BackOff   backOff    =    mock ( BackOff . class )  ;", "BackOffExecution   execution    =    mock ( BackOffExecution . class )  ;", "given ( execution . nextBackOff (  )  )  . willReturn (  5  0 L ,     5  0 L ,     5  0 L )  ;", "given ( backOff . start (  )  )  . willReturn ( execution )  ;", "container    =    createContainer ( createRecoverableContainerFactory (  1  )  )  ;", "container . setBackOff ( backOff )  ;", "container . start (  )  ;", "container . refreshConnectionUntilSuccessful (  )  ;", "assertEquals ( true ,    container . isRunning (  )  )  ;", "verify ( backOff )  . start (  )  ;", "verify ( execution ,    times (  1  )  )  . nextBackOff (  )  ;", "}", "METHOD_END"], "methodName": ["recoverResetBackOff"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageListenerContainer   container    =    createRunningContainer (  )  ;", "container . stop (  )  ;", ". TestRunnable   runnable 2     =    new    . TestRunnable (  )  ;", "container . stop ( runnable 2  )  ;", "runnable 2  . waitForCompletion (  )  ;", "}", "METHOD_END"], "methodName": ["runnableIsInvokedEvenIfContainerIsNotRunning"], "fileName": "org.springframework.jms.listener.DefaultMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    getDestination (  )  ;", "if    ( destination    =  =    null )     {", "String   destinationName    =    getDestinationName (  )  ;", "Assert . state (  ( destinationName    !  =    null )  ,     \" No   destination   set \"  )  ;", "destination    =    resolveDestinationName ( session ,    destinationName )  ;", "}", "MessageConsumer   consumer    =    createConsumer ( session ,    destination )  ;", "if    (  ( this . taskExecutor )     !  =    null )     {", "consumer . set (  (    message )     -  >    taskExecutor . execute (  (  )     -  >    processMessage ( message ,    session )  )  )  ;", "} else    {", "consumer . set (  (    message )     -  >    processMessage ( message ,    session )  )  ;", "}", "return   consumer ;", "}", "METHOD_END"], "methodName": ["createListenerConsumer"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . consumersMonitor )     {", "if    (  ( this . consumers )     =  =    null )     {", "this . sessions    =    new   HashSet ( this . concurrentConsumers )  ;", "this . consumers    =    new   HashSet ( this . concurrentConsumers )  ;", "Connection   con    =    getSharedConnection (  )  ;", "for    ( int   i    =     0  ;    i    <     ( this . concurrentConsumers )  ;    i +  +  )     {", "Session   session    =    createSession ( con )  ;", "MessageConsumer   consumer    =    creatsumer ( session )  ;", "this . sessions . add ( session )  ;", "this . consumers . add ( consumer )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["initializeConsumers"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getConnectionFactory (  )  ;", "boolean   exposeResource    =     ( connectionFactory    !  =    null )     &  &     ( isExposSession (  )  )  ;", "if    ( exposeResource )     {", "TransactionSynchronizationManager . bindResource ( connectionFactory ,    new   LocallyExposedJmsResourceHolder ( session )  )  ;", "}", "try    {", "execut ( session ,    message )  ;", "}    finally    {", "if    ( exposeResource )     {", "TransactionSynchronizationManager . unbindResource ( getConnectionFactory (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processMessage"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( concurrentConsumers    >     0  )  ,     \"  ' concurrentConsumers '    value   must   be   at   least    1     ( one )  \"  )  ;", "this . concurrentConsumers    =    concurrentConsumers ;", "}", "METHOD_END"], "methodName": ["setConcurrentConsumers"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . connectLazily    =    connectLazily ;", "}", "METHOD_END"], "methodName": ["setConnectLazily"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainer"}, {"methodBody": ["METHOD_START", "{", "MessageConsumer   messageConsumer    =    mock ( MessageConsumer . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue (  . DESTINATION _ NAME )  )  . willReturn (  . QUEUE _ DESTINATION )  ;", "given ( session . createConsumer (  . QUEUE _ DESTINATION ,    null )  )  . willReturn ( messageConsumer )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . createSession ( this . container . isSessionTransacted (  )  ,    this . container . getSessionAcknowledgeMode (  )  )  )  . willReturn ( session )  ;", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . willReturn ( connection )  ;", "this . container . setConnectionFactory ( connectionFactory )  ;", "this . container . setDestinationName (  . DESTINATION _ NAME )  ;", "this . container . setMessageListener ( new    . TestMessageListener (  )  )  ;", "this . container . setAutoStartup ( false )  ;", "this . container . afterPropertiesSet (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" messageListenerContainer \"  ,    this . container )  ;", "context . refresh (  )  ;", "verify ( connection )  . setExceptionListener ( this . container )  ;", "}", "METHOD_END"], "methodName": ["testContextRefreshedEventDoesNotStartTheConnectionIfAutoStartIsSetToFalse"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "MessageConsumer   messageConsumer    =    mock ( MessageConsumer . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue (  . DESTINATION _ NAME )  )  . willReturn (  . QUEUE _ DESTINATION )  ;", "given ( session . createConsumer (  . QUEUE _ DESTINATION ,    null )  )  . willReturn ( messageConsumer )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . createSession ( this . container . isSessionTransacted (  )  ,    this . container . getSessionAcknowledgeMode (  )  )  )  . willReturn ( session )  ;", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . willReturn ( connection )  ;", "this . container . setConnectionFactory ( connectionFactory )  ;", "this . container . setDestinationName (  . DESTINATION _ NAME )  ;", "this . container . setMessageListener ( new    . TestMessageListener (  )  )  ;", "this . container . afterPropertiesSet (  )  ;", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerSingleton (  \" messageListenerContainer \"  ,    this . container )  ;", "context . refresh (  )  ;", "verify ( connection )  . setExceptionListener ( this . container )  ;", "verify ( connection )  . start (  )  ;", "}", "METHOD_END"], "methodName": ["testContextRefreshedEventStartsTheConnectionByDefault"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleMessageListenerContainerTests . SimpleMessageConsumer   messageConsumer    =    new   SimpleMessageListenerContainerTests . SimpleMessageConsumer (  )  ;", "final   Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  )  . willReturn ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION )  ;", "given ( session . createConsumer ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION ,    null )  )  . willReturn ( messageConsumer )  ;", "given ( session . getTransacted (  )  )  . willReturn ( false )  ;", "given ( session . getAcknowledgeMode (  )  )  . willReturn ( AUTO _ ACKNOWLEDGE )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . createSession ( this . container . isSessionTransacted (  )  ,    this . container . getSessionAcknowledgeMode (  )  )  )  . willReturn ( session )  ;", "final   ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . willReturn ( connection )  ;", "final   Set < String >    failure    =    new   HashSet <  >  (  1  )  ;", "this . container . setConnectionFactory ( connectionFactory )  ;", "this . container . setDestinationName ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  ;", "this . container . setMessageListener ( new   SessionAwareMessageListener < Message >  (  )     {", "@ Override", "public   void   onMessage ( Message   message ,     @ Nullable", "Session   sess )     {", "try    {", "assertSame ( sess ,    session )  ;", "}    catch    ( Throwable   ex )     {", "failure . add (  (  \" MessageListener   execution   failed :     \"     +    ex )  )  ;", "}", "}", "}  )  ;", "this . container . afterPropertiesSet (  )  ;", "this . container . start (  )  ;", "final   Message   message    =    mock ( Message . class )  ;", "messageConsumer . sendMessage ( message )  ;", "if    (  !  ( failure . isEmpty (  )  )  )     {", "fail ( failure . iterator (  )  . next (  )  . toString (  )  )  ;", "}", "verify ( connection )  . setExceptionListener ( this . container )  ;", "verify ( connection )  . start (  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectSessionExposedForSessionAwareMessageListenerInvocation"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "MessageConsumer   messageConsumer    =    mock ( MessageConsumer . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue (  . DESTINATION _ NAME )  )  . willReturn (  . QUEUE _ DESTINATION )  ;", "given ( session . createConsumer (  . QUEUE _ DESTINATION ,    null )  )  . willReturn ( messageConsumer )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . createSession ( this . container . isSessionTransacted (  )  ,    this . container . getSessionAcknowledgeMode (  )  )  )  . willReturn ( session )  ;", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . willReturn ( connection )  ;", "this . container . setConnectionFactory ( connectionFactory )  ;", "this . container . setDestinationName (  . DESTINATION _ NAME )  ;", "this . container . setMessageListener ( new    . TestMessageListener (  )  )  ;", "this . container . afterPropertiesSet (  )  ;", "this . container . start (  )  ;", "this . container . destroy (  )  ;", "verify ( messageConsumer )  . close (  )  ;", "verify ( session )  . close (  )  ;", "verify ( connection )  . setExceptionListener ( this . container )  ;", "verify ( connection )  . start (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testDestroyClosesConsumersSessionsAndConnectionInThatOrder"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleMessageListenerContainerTests . SimpleMessageConsumer   messageConsumer    =    new   SimpleMessageListenerContainerTests . SimpleMessageConsumer (  )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  )  . willReturn ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION )  ;", "given ( session . createConsumer ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION ,    null )  )  . willReturn ( messageConsumer )  ;", "given ( session . getTransacted (  )  )  . willReturn ( false )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . createSession ( this . container . isSessionTransacted (  )  ,    this . container . getSessionAcknowledgeMode (  )  )  )  . willReturn ( session )  ;", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . willReturn ( connection )  ;", "this . container . setConnectionFactory ( connectionFactory )  ;", "this . container . setDestinationName ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  ;", "this . container . setMessageListener ( new   MessageListener (  )     {", "@ Override", "public   void   onMessage ( Message   message )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  )  ;", "this . container . afterPropertiesSet (  )  ;", "this . container . start (  )  ;", "final   Message   message    =    mock ( Message . class )  ;", "messageConsumer . sendMessage ( message )  ;", "verify ( connection )  . setExceptionListener ( this . container )  ;", "verify ( connection )  . start (  )  ;", "}", "METHOD_END"], "methodName": ["testNoRollbackOccursIfSessionIsNotTransactedAndThatExceptionsDo_NOT_Propagate"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleMessageListenerContainerTests . SimpleMessageConsumer   messageConsumer    =    new   SimpleMessageListenerContainerTests . SimpleMessageConsumer (  )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  )  . willReturn ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION )  ;", "given ( session . createConsumer ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION ,    null )  )  . willReturn ( messageConsumer )  ;", "given ( session . getTransacted (  )  )  . willReturn ( false )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . createSession ( this . container . isSessionTransacted (  )  ,    this . container . getSessionAcknowledgeMode (  )  )  )  . willReturn ( session )  ;", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . willReturn ( connection )  ;", "final   IllegalStateException   theException    =    new   IllegalStateException (  \" intentional   test   failure \"  )  ;", "this . container . setConnectionFactory ( connectionFactory )  ;", "this . container . setDestinationName ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  ;", "this . container . setMessageListener ( new   SessionAwareMessageListener < Message >  (  )     {", "@ Override", "public   void   onMessage ( Message   message ,     @ Nullable", "Session   session )    throws   JMSException    {", "throw   theException ;", "}", "}  )  ;", "ErrorHandler   errorHandler    =    mock ( ErrorHandler . class )  ;", "this . container . setErrorHandler ( errorHandler )  ;", "this . container . afterPropertiesSet (  )  ;", "this . container . start (  )  ;", "Message   message    =    mock ( Message . class )  ;", "messageConsumer . sendMessage ( message )  ;", "verify ( connection )  . setExceptionListener ( this . container )  ;", "verify ( connection )  . start (  )  ;", "verify ( errorHandler )  . handleError ( theException )  ;", "}", "METHOD_END"], "methodName": ["testRegisteredErrorHandlerIsInvokedOnException"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleMessageListenerContainerTests . SimpleMessageConsumer   messageConsumer    =    new   SimpleMessageListenerContainerTests . SimpleMessageConsumer (  )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  )  . willReturn ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION )  ;", "given ( session . createConsumer ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION ,    null )  )  . willReturn ( messageConsumer )  ;", "given ( session . getTransacted (  )  )  . willReturn ( false )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . createSession ( this . container . isSessionTransacted (  )  ,    this . container . getSessionAcknowledgeMode (  )  )  )  . willReturn ( session )  ;", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . willReturn ( connection )  ;", "final   JMSException   theException    =    new   JMSException ( SimpleMessageListenerContainerTests . EXCEPTION _ MESSAGE )  ;", "this . container . setConnectionFactory ( connectionFactory )  ;", "this . container . setDestinationName ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  ;", "this . container . setMessageListener ( new   SessionAwareMessageListener < Message >  (  )     {", "@ Override", "public   void   onMessage ( Message   message ,     @ Nullable", "Session   session )    throws   JMSException    {", "throw   theException ;", "}", "}  )  ;", "ExceptionListener   exceptionListener    =    mock ( ExceptionListener . class )  ;", "this . container . setExceptionListener ( exceptionListener )  ;", "this . container . afterPropertiesSet (  )  ;", "this . container . start (  )  ;", "final   Message   message    =    mock ( Message . class )  ;", "messageConsumer . sendMessage ( message )  ;", "verify ( connection )  . setExceptionListener ( this . container )  ;", "verify ( connection )  . start (  )  ;", "verify ( exceptionListener )  . onException ( theException )  ;", "}", "METHOD_END"], "methodName": ["testRegisteredExceptionListenerIsInvokedOnException"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  (  \" The    [ pubSubLocal ]    property   of   SimpleMessageListenerContainer    \"     +     (  \" must   default   to   false .    Change   this   test    ( and   the    \"     +     \" attendant   Javadoc )    if   you   have   changed   the   default .  \"  )  )  ,    this . container . isPubSubNoLocal (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSessionTransactedModeReallyDoesDefaultToFalse"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . container . setConcurrentConsumers (  (  -  1  9  8  )  )  ;", "this . container . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testSettingConcurrentConsumersToANegativeValueIsNotAllowed"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . container . setConcurrentConsumers (  0  )  ;", "this . container . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testSettingConcurrentConsumersToZeroIsNotAllowed"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . container . setMessageListener ( null )  ;", "assertNull ( this . container . getMessageListener (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSettingMessageListenerToANullType"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . container . setMessageListener (  \" Bingo \"  )  ;", "}", "METHOD_END"], "methodName": ["testSettingMessageListenerToAnUnsupportedType"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleMessageListenerContainerTests . SimpleMessageConsumer   messageConsumer    =    new   SimpleMessageListenerContainerTests . SimpleMessageConsumer (  )  ;", "final   Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  )  . willReturn ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION )  ;", "given ( session . createConsumer ( SimpleMessageListenerContainerTests . QUEUE _ DESTINATION ,    null )  )  . willReturn ( messageConsumer )  ;", "given ( session . getTransacted (  )  )  . willReturn ( false )  ;", "given ( session . getAcknowledgeMode (  )  )  . willReturn ( AUTO _ ACKNOWLEDGE )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . createSession ( this . container . isSessionTransacted (  )  ,    this . container . getSessionAcknowledgeMode (  )  )  )  . willReturn ( session )  ;", "final   ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . willReturn ( connection )  ;", "final   SimpleMessageListenerContainerTests . TestMessageListener   listener    =    new   SimpleMessageListenerContainerTests . TestMessageListener (  )  ;", "this . container . setConnectionFactory ( connectionFactory )  ;", "this . container . setDestinationName ( SimpleMessageListenerContainerTests . DESTINATION _ NAME )  ;", "this . container . setMessageListener ( listener )  ;", "this . container . setTaskExecutor ( new   TaskExecutor (  )     {", "@ Override", "public   void   execute ( Runnable   task )     {", "listener . executorInvoked    =    true ;", "assertFalse ( listener . listenerInvoked )  ;", "task . run (  )  ;", "assertTrue ( listener . listenerInvoked )  ;", "}", "}  )  ;", "this . container . afterPropertiesSet (  )  ;", "this . container . start (  )  ;", "final   Message   message    =    mock ( Message . class )  ;", "messageConsumer . sendMessage ( message )  ;", "assertTrue ( listener . executorInvoked )  ;", "assertTrue ( listener . listenerInvoked )  ;", "verify ( connection )  . setExceptionListener ( this . container )  ;", "verify ( connection )  . start (  )  ;", "}", "METHOD_END"], "methodName": ["testTaskExecutorCorrectlyInvokedWhenSpecified"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "this . container . setSessionTransacted ( true )  ;", "final    . SimpleMessageConsumer   messageConsumer    =    new    . SimpleMessageConsumer (  )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue (  . DESTINATION _ NAME )  )  . willReturn (  . QUEUE _ DESTINATION )  ;", "given ( session . createConsumer (  . QUEUE _ DESTINATION ,    null )  )  . willReturn ( messageConsumer )  ;", "given ( session . getTransacted (  )  )  . willReturn ( true )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . createSession ( this . container . isSessionTransacted (  )  ,    this . container . getSessionAcknowledgeMode (  )  )  )  . willReturn ( session )  ;", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "given ( connectionFactory . createConnection (  )  )  . willReturn ( connection )  ;", "this . container . setConnectionFactory ( connectionFactory )  ;", "this . container . setDestinationName (  . DESTINATION _ NAME )  ;", "this . container . setMessageListener ( new   MessageListener (  )     {", "@ Override", "public   void   onMessage ( Message   message )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  )  ;", "this . container . afterPropertiesSet (  )  ;", "this . container . start (  )  ;", "final   Message   message    =    mock ( Message . class )  ;", "messageConsumer . sendMessage ( message )  ;", "verify ( session )  . rollback (  )  ;", "verify ( connection )  . setExceptionListener ( this . container )  ;", "verify ( connection )  . start (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactedSessionsGetRollbackLogicAppliedAndThatExceptionsStillDo_NOT_Propagate"], "fileName": "org.springframework.jms.listener.SimpleMessageListenerContainerTests"}, {"methodBody": ["METHOD_START", "{", "Object   content    =    preProcessResponse (  ( result   instanceof   JmsResponse    ?     (  ( JmsResponse <  ?  >  )     ( result )  )  . getResponse (  )     :    result )  )  ;", "Converter   converter    =    getConverter (  )  ;", "if    ( converter    !  =    null )     {", "if    ( content   instanceof    )     {", "return   this . messagingConverter . to ( content ,    session )  ;", "} else    {", "return   converter . to ( content ,    session )  ;", "}", "}", "if    (  !  ( content   instanceof   )  )     {", "throw   new   ConversionException (  (  (  \" No   Converter   specified    -    cannot   handle   message    [  \"     +    content )     +     \"  ]  \"  )  )  ;", "}", "return    (  ( )     ( content )  )  ;", "}", "METHOD_END"], "methodName": ["buildMessage"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "try    {", "Converter   converter    =    getConverter (  )  ;", "if    ( converter    !  =    null )     {", "return   converter . from ( message )  ;", "}", "return   message ;", "}    catch    ( JMSException   ex )     {", "throw   new   ConversionException (  \" Could   not   convert   JMS   message \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["extractMessage"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationResolver ;", "}", "METHOD_END"], "methodName": ["getDestinationResolver"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "return   this . messageConverter ;", "}", "METHOD_END"], "methodName": ["getMessageConverter"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "return   this . messagingMessageConverter ;", "}", "METHOD_END"], "methodName": ["getMessagingMessageConverter"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "Destination   replyTo    =    request . getJMSReplyTo (  )  ;", "if    ( replyTo    =  =    null )     {", "replyTo    =    resolveDefaultResponseDestination ( session )  ;", "if    ( replyTo    =  =    null )     {", "throw   new   InvalidDestinationException (  (  \" Cannot   determine   response   destination :     \"     +     \" Request   m   does   not   contain   reply - to   destination ,    and   no   default   response   destination   set .  \"  )  )  ;", "}", "}", "return   replyTo ;", "}", "METHOD_END"], "methodName": ["getResponseDestination"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "if    ( result   instanceof   JmsResponse )     {", "JmsResponse <  ?  >    Response    =     (  ( JmsResponse )     ( result )  )  ;", "Destination   destination    =    Response . resolveDestination ( getDestinationResolver (  )  ,    session )  ;", "if    ( destination    !  =    null )     {", "return   destination ;", "}", "}", "return   getResponseDestination ( request ,    response ,    session )  ;", "}", "METHOD_END"], "methodName": ["getResponseDestination"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "return   this . responseQosSettings ;", "}", "METHOD_END"], "methodName": ["getResponseQosSettings"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "logger . error (  \" Listener   execution   failed \"  ,    ex )  ;", "}", "METHOD_END"], "methodName": ["handleListenerException"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "if    ( session    !  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \"    method   returned   result    [  \"     +    result )     +     \"  ]     -    generating   response   message   for   it \"  )  )  ;", "}", "try    {", "Message   response    =    buildMessage ( session ,    result )  ;", "postProcessResponse ( request ,    response )  ;", "Destination   destination    =    getResponseDestination ( request ,    response ,    session ,    result )  ;", "sendResponse ( session ,    destination ,    response )  ;", "}    catch    ( Exception   ex )     {", "throw   new   ReplyFailureException (  (  (  \" Failed   to   send   reply   with   payload    [  \"     +    result )     +     \"  ]  \"  )  ,    ex )  ;", "}", "} else    {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \"    method   returned   result    [  \"     +    result )     +     \"  ]  :    not   generating   response   message   for   it   because   of   no   JMS   Session   given \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleResult"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "String   correlation    =    request . getJMSCorrelationID (  )  ;", "if    ( correlation    =  =    null )     {", "correlation    =    request . getJMSID (  )  ;", "}", "response . setJMSCorrelationID ( correlation )  ;", "}", "METHOD_END"], "methodName": ["postProcessResponse"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "return   result ;", "}", "METHOD_END"], "methodName": ["preProcessResponse"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . defaultResponseDestination )    instanceof   Destination )     {", "return    (  ( Destination )     ( this . defaultResponseDestination )  )  ;", "}", "if    (  ( this . defaultResponseDestination )    instanceof    . DestinationNameHolder )     {", ". DestinationNameHolder   nameHolder    =     (  (  . DestinationNameHolder )     ( this . defaultResponseDestination )  )  ;", "return   getDestinationResolver (  )  . resolveDestinationName ( session ,    nameHolder . name ,    nameHolder . isTopic )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveDefaultResponseDestination"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "MessageProducer   producer    =    session . createProducer ( destination )  ;", "try    {", "postProcessProducer ( producer ,    response )  ;", "QosSettings   settings    =    getResponseQosSettings (  )  ;", "if    ( settings    !  =    null )     {", "producer . send ( response ,    settings . getDeliveryMode (  )  ,    settings . getPriority (  )  ,    settings . getTimeToLive (  )  )  ;", "} else    {", "producer . send ( response )  ;", "}", "}    finally    {", "JmsUtils . closProducer ( producer )  ;", "}", "}", "METHOD_END"], "methodName": ["sendResponse"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "this . defaultResponseDestination    =    destination ;", "}", "METHOD_END"], "methodName": ["setDefaultResponseDestination"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "this . defaultResponseDestination    =    new   AbstractAdaptableMessageListener . DestinationNameHolder ( destinationName ,    false )  ;", "}", "METHOD_END"], "methodName": ["setDefaultResponseQueueName"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "this . defaultResponseDestination    =    new   AbstractAdaptableMessageListener . DestinationNameHolder ( destinationName ,    true )  ;", "}", "METHOD_END"], "methodName": ["setDefaultResponseTopicName"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( destinationResolver ,     \" DestinationResolver   must   not   be   null \"  )  ;", "this . destinationResolver    =    destinationResolver ;", "}", "METHOD_END"], "methodName": ["setDestinationResolver"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( headerMapper ,     \" HeaderMapper   must   not   be   null \"  )  ;", "this . messagingConverter . setHeaderMapper ( headerMapper )  ;", "}", "METHOD_END"], "methodName": ["setHeaderMapper"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "this . messageConverter    =    messageConverter ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "this . responseQosSettings    =    responseQosSettings ;", "}", "METHOD_END"], "methodName": ["setResponseQosSettings"], "fileName": "org.springframework.jms.listener.adapter.AbstractAdaptableMessageListener"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( destination ,     \" Destination   must   not   be   null \"  )  ;", "return   new    ( result ,    destination )  ;", "}", "METHOD_END"], "methodName": ["forDestination"], "fileName": "org.springframework.jms.listener.adapter.JmsResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( queueName ,     \" Queue   name   must   not   be   null \"  )  ;", "return   new    <  >  ( result ,    new    . DestinationNameHolder ( queueName ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["forQueue"], "fileName": "org.springframework.jms.listener.adapter.JmsResponse"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( topicName ,     \" Topic   name   must   not   be   null \"  )  ;", "return   new    <  >  ( result ,    new    . DestinationNameHolder ( topicName ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["forTopic"], "fileName": "org.springframework.jms.listener.adapter.JmsResponse"}, {"methodBody": ["METHOD_START", "{", "return   this . response ;", "}", "METHOD_END"], "methodName": ["getResponse"], "fileName": "org.springframework.jms.listener.adapter.JmsResponse"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . destination )    instanceof   Destination )     {", "return    (  ( Destination )     ( this . destination )  )  ;", "}", "if    (  ( this . destination )    instanceof    . DestinationNameHolder )     {", ". DestinationNameHolder   nameHolder    =     (  (  . DestinationNameHolder )     ( this . destination )  )  ;", "return   destinationResolver . resolveDestinationName ( session ,    nameHolder . destinationName ,    nameHolder . pubSubDomain )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveDestination"], "fileName": "org.springframework.jms.listener.adapter.JmsResponse"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", ". forDestination (  \" foo \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["createWithNulDestination"], "fileName": "org.springframework.jms.listener.adapter.JmsResponseTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", ". forQueue ( null ,     \" myQueue \"  )  ;", "}", "METHOD_END"], "methodName": ["createWithNulResponse"], "fileName": "org.springframework.jms.listener.adapter.JmsResponseTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", ". forQueue (  \" foo \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["createWithNullQueueName"], "fileName": "org.springframework.jms.listener.adapter.JmsResponseTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", ". forTopic (  \" foo \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["createWithNullTopicName"], "fileName": "org.springframework.jms.listener.adapter.JmsResponseTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    mock ( Destination . class )  ;", "Destination   actual    =     . forDestination (  \" foo \"  ,    destination )  . resolveDestination ( null ,    null )  ;", "assertSame ( destination ,    actual )  ;", "}", "METHOD_END"], "methodName": ["destinationDoesNotUseDestinationResolver"], "fileName": "org.springframework.jms.listener.adapter.JmsResponseTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "DestinationResolver   destinationResolver    =    mock ( DestinationResolver . class )  ;", "Destination   destination    =    mock ( Destination . class )  ;", "given ( destinationResolver . resolveDestinationName ( session ,     \" myQueue \"  ,    false )  )  . willReturn ( destination )  ;", "< String >    jmsResponse    =     . forQueue (  \" foo \"  ,     \" myQueue \"  )  ;", "Destination   actual    =    jmsResponse . resolveDestination ( destinationResolver ,    session )  ;", "assertSame ( destination ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveDestinationForQueue"], "fileName": "org.springframework.jms.listener.adapter.JmsResponseTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  {    extractedMessage    }  ;", "}", "METHOD_END"], "methodName": ["buildListenerArguments"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultListenerMethod ;", "}", "METHOD_END"], "methodName": ["getDefaultListenerMethod"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   getDefaultListenerMethod (  )  ;", "}", "METHOD_END"], "methodName": ["getListenerMethodName"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetObject ( getDelegate (  )  )  ;", "methodInvoker . setTargetMethod ( methodName )  ;", "methodInvoker . setArguments ( arguments )  ;", "methodInvoker . prepare (  )  ;", "return   methodInvoker . invoke (  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "Throwable   targetEx    =    ex . getTargetException (  )  ;", "if    ( targetEx   instanceof   JMSException )     {", "throw    (  ( JMSException )     ( targetEx )  )  ;", "} else    {", "throw   new   ExecutionFailedException (  (  (  \"    method    '  \"     +    methodName )     +     \"  '    threw   exception \"  )  ,    targetEx )  ;", "}", "}    catch    ( Throwable   ex )     {", "throw   new   ExecutionFailedException (  (  (  (  \" Failed   to   invoke   target   method    '  \"     +    methodName )     +     \"  '    with   arguments    \"  )     +     ( ObjectUtils . nullSafeToString ( arguments )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeListenerMethod"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . defaultListenerMethod    =    defaultListenerMethod ;", "}", "METHOD_END"], "methodName": ["setDefaultListenerMethod"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( delegate ,     \" Delegate   must   not   be   null \"  )  ;", "this . delegate    =    delegate ;", "}", "METHOD_END"], "methodName": ["setDelegate"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "given ( textMessage . getText (  )  )  . willReturn (  . TEXT )  ;", "StubMessageListenerAdapter   adapter    =    new   StubMessageListenerAdapter (  )  ;", "adapter . setDefaultListenerMethod (  \" walnutsRock \"  )  ;", "adapter . onMessage ( textMessage )  ;", "assertFalse ( adapter . wasCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRainyDayWithNoApplicableHandlingMethods"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "final   IllegalArgumentException   exception    =    new   IllegalArgumentException (  )  ;", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "MessageDelegate   delegate    =    mock ( MessageDelegate . class )  ;", "willThrow ( exception )  . given ( delegate )  . handleMessage ( textMessage )  ;", "adapter    =    new    ( delegate )     {", "@ Override", "protected   void   handleListenerException ( Throwable   ex )     {", "assertNotNull (  \" The   Throwable   passed   to   the   handleListenerException (  .  .  )    method   must   never   be   null .  \"  ,    ex )  ;", "assertTrue (  \" The   Throwable   passed   to   the   handleListenerException (  .  .  )    method   must   be   of   type    [ ListenerExecutionFailedException ]  .  \"  ,     ( ex   instanceof   ListenerExecutionFailedException )  )  ;", "ListenerExecutionFailedException   lefx    =     (  ( ListenerExecutionFailedException )     ( ex )  )  ;", "Throwable   cause    =    lefx . getCause (  )  ;", "assertNotNull (  \" The   cause   of   a   ListenerExecutionFailedException   must   be   preserved .  \"  ,    cause )  ;", "assertSame ( exception ,    cause )  ;", "}", "}  ;", "adapter . setMessageConverter ( null )  ;", "adapter . onMessage ( textMessage )  ;", "}", "METHOD_END"], "methodName": ["testThatAnExceptionThrownFromTheHandlingMethodIsSimplySwallowedByDefault"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter (  )  ;", "assertNotNull (  \" The   default    [ MessageConverter ]    must   never   be   null .  \"  ,    adapter . getMessageConverter (  )  )  ;", "assertTrue (  \" The   default    [ MessageConverter ]    must   be   of   the   type    [ SimpleMessageConverter ]  \"  ,     (  ( adapter . getMessageConverter (  )  )    instanceof   SimpleMessageConverter )  )  ;", "}", "METHOD_END"], "methodName": ["testThatTheDefaultMessageConverterisIndeedTheSimpleMessageConverter"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter (  )  ;", "assertEquals ( MessageListenerAdapter . ORIGINAL _ DEFAULT _ LISTENER _ METHOD ,    adapter . getDefaultListenerMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["testThatTheDefaultMessageHandlingMethodNameIsTheConstantDefault"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter (  )  ;", "assertSame ( adapter ,    adapter . getDelegate (  )  )  ;", "}", "METHOD_END"], "methodName": ["testThatWhenNoDelegateIsSuppliedTheDelegateIsAssumedToBeTheMessageListenerAdapterItself"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "given ( textMessage . getText (  )  )  . willReturn (  . TEXT )  ;", "StubMessageListenerAdapter   adapter    =    new   StubMessageListenerAdapter (  )  ;", "adapter . onMessage ( textMessage )  ;", "assertTrue ( adapter . wasCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWhenTheAdapterItselfIsTheDelegate"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "BytesMessage   bytesMessage    =    mock ( BytesMessage . class )  ;", "given ( bytesMessage . getBodyLength (  )  )  . willReturn ( new   Long (  . TEXT . getBytes (  )  . length )  )  ;", "given ( bytesMessage . readBytes ( any ( byte [  ]  . class )  )  )  . willAnswer ( new   Answer < Integer >  (  )     {", "@ Override", "public   Integer   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "byte [  ]    bytes    =     (  ( byte [  ]  )     ( invocation . getArguments (  )  [  0  ]  )  )  ;", "ByteArrayInputStream   inputStream    =    new   ByteArrayInputStream (  . TEXT . getBytes (  )  )  ;", "return   inputStream . read ( bytes )  ;", "}", "}  )  ;", "MessageContentsDelegate   delegate    =    mock ( MessageContentsDelegate . class )  ;", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )  ;", "adapter . onMessage ( bytesMessage )  ;", "verify ( delegate )  . handleMessage (  . TEXT . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithMessageContentsDelegateForBytesMessage"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMessage   objectMessage    =    mock ( ObjectMessage . class )  ;", "given ( objectMessage . getObject (  )  )  . willReturn (  . NUMBER )  ;", "MessageContentsDelegate   delegate    =    mock ( MessageContentsDelegate . class )  ;", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )  ;", "adapter . onMessage ( objectMessage )  ;", "verify ( delegate )  . handleMessage (  . NUMBER )  ;", "}", "METHOD_END"], "methodName": ["testWithMessageContentsDelegateForObjectMessage"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "ObjectMessage   objectMessage    =    mock ( ObjectMessage . class )  ;", "given ( objectMessage . getObject (  )  )  . willReturn (  . OBJECT )  ;", "MessageContentsDelegate   delegate    =    mock ( MessageContentsDelegate . class )  ;", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )  ;", "adapter . onMessage ( objectMessage )  ;", "verify ( delegate )  . handleMessage (  . OBJECT )  ;", "}", "METHOD_END"], "methodName": ["testWithMessageContentsDelegateForObjectMessageWithPlainObject"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "given ( textMessage . getText (  )  )  . willReturn (  . TEXT )  ;", "MessageContentsDelegate   delegate    =    mock ( MessageContentsDelegate . class )  ;", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )  ;", "adapter . onMessage ( textMessage )  ;", "verify ( delegate )  . handleMessage (  . TEXT )  ;", "}", "METHOD_END"], "methodName": ["testWithMessageContentsDelegateForTextMessage"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "MessageDelegate   delegate    =    mock ( MessageDelegate . class )  ;", "adapter    =    new    ( delegate )  ;", "adapter . setMessageConverter ( null )  ;", "adapter . onMessage ( textMessage )  ;", "verify ( delegate )  . handleMessage ( textMessage )  ;", "}", "METHOD_END"], "methodName": ["testWithMessageDelegate"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "final   TextMessage   message    =    mock ( TextMessage . class )  ;", "final   QueueSession   session    =    mock ( QueueSession . class )  ;", "ResponsiveMessageDelegate   delegate    =    mock ( ResponsiveMessageDelegate . class )  ;", "willThrow ( new   IllegalArgumentException (  \" Doe !  \"  )  )  . given ( delegate )  . handleMessage ( message )  ;", "final      adapter    =    new    ( delegate )     {", "@ Override", "protected   Object   extractMessage ( Message   message )     {", "return   message ;", "}", "}  ;", "try    {", "adapter . onMessage ( message ,    session )  ;", "fail (  \" expected   ListenerExecutionFailedException \"  )  ;", "}    catch    ( ListenerExecutionFailedException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testWithResponsiveMessageDelegateDoesNotSendReturnTextMessageWhenSessionSupplied_AndListenerMethodThrowsException"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "final   TextMessage   sentTextMessage    =    mock ( TextMessage . class )  ;", "given ( sentTextMessage . getJMSCorrelationID (  )  )  . willReturn (  . CORRELATION _ ID )  ;", "given ( sentTextMessage . getJMSReplyTo (  )  )  . willReturn ( null )  ;", "TextMessage   responseTextMessage    =    mock ( TextMessage . class )  ;", "final   QueueSession   session    =    mock ( QueueSession . class )  ;", "given ( session . createTextMessage (  . RESPONSE _ TEXT )  )  . willReturn ( responseTextMessage )  ;", "ResponsiveMessageDelegate   delegate    =    mock ( ResponsiveMessageDelegate . class )  ;", "given ( delegate . handleMessage ( sentTextMessage )  )  . willReturn (  . RESPONSE _ TEXT )  ;", "final   MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )     {", "@ Override", "protected   Object   extractMessage ( Message   message )     {", "return   message ;", "}", "}  ;", "try    {", "adapter . onMessage ( sentTextMessage ,    session )  ;", "fail (  \" expected   CouldNotSendReplyException   with   InvalidDestinationException \"  )  ;", "}    catch    ( ReplyFailureException   ex )     {", "assertEquals ( InvalidDestinationException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "}", "verify ( responseTextMessage )  . setJMSCorrelationID (  . CORRELATION _ ID )  ;", "verify ( delegate )  . handleMessage ( sentTextMessage )  ;", "}", "METHOD_END"], "methodName": ["testWithResponsiveMessageDelegateNoDefaultDestinationAndNoReplyToDestination_SendsReturnTextMessageWhenSessionSupplied"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Queue   destination    =    mock ( Queue . class )  ;", "TextMessage   sentTextMessage    =    mock ( TextMessage . class )  ;", "given ( sentTextMessage . getJMSCorrelationID (  )  )  . willReturn ( null )  ;", "given ( sentTextMessage . getJMSMessageID (  )  )  . willReturn (  . CORRELATION _ ID )  ;", "given ( sentTextMessage . getJMSReplyTo (  )  )  . willReturn ( destination )  ;", "TextMessage   responseTextMessage    =    mock ( TextMessage . class )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createTextMessage (  . RESPONSE _ TEXT )  )  . willReturn ( responseTextMessage )  ;", "given ( session . createProducer ( destination )  )  . willReturn ( messageProducer )  ;", "ResponsiveMessageDelegate   delegate    =    mock ( ResponsiveMessageDelegate . class )  ;", "given ( delegate . handleMessage ( sentTextMessage )  )  . willReturn (  . RESPONSE _ TEXT )  ;", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )     {", "@ Override", "protected   Object   extractMessage ( Message   message )     {", "return   message ;", "}", "}  ;", "adapter . onMessage ( sentTextMessage ,    session )  ;", "verify ( responseTextMessage )  . setJMSCorrelationID (  . CORRELATION _ ID )  ;", "verify ( messageProducer )  . send ( responseTextMessage )  ;", "verify ( messageProducer )  . close (  )  ;", "verify ( delegate )  . handleMessage ( sentTextMessage )  ;", "}", "METHOD_END"], "methodName": ["testWithResponsiveMessageDelegateNoDefaultDestination_SendsReturnTextMessageWhenSessionSupplied"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Queue   destination    =    mock ( Queue . class )  ;", "final   TextMessage   sentTextMessage    =    mock ( TextMessage . class )  ;", "given ( sentTextMessage . getJMSCorrelationID (  )  )  . willReturn (  . CORRELATION _ ID )  ;", "given ( sentTextMessage . getJMSReplyTo (  )  )  . willReturn ( destination )  ;", "TextMessage   responseTextMessage    =    mock ( TextMessage . class )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "willThrow ( new   JMSException (  \" Doe !  \"  )  )  . given ( messageProducer )  . send ( responseTextMessage )  ;", "final   QueueSession   session    =    mock ( QueueSession . class )  ;", "given ( session . createTextMessage (  . RESPONSE _ TEXT )  )  . willReturn ( responseTextMessage )  ;", "given ( session . createProducer ( destination )  )  . willReturn ( messageProducer )  ;", "ResponsiveMessageDelegate   delegate    =    mock ( ResponsiveMessageDelegate . class )  ;", "given ( delegate . handleMessage ( sentTextMessage )  )  . willReturn (  . RESPONSE _ TEXT )  ;", "final   MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )     {", "@ Override", "protected   Object   extractMessage ( Message   message )     {", "return   message ;", "}", "}  ;", "try    {", "adapter . onMessage ( sentTextMessage ,    session )  ;", "fail (  \" expected   CouldNotSendReplyException   with   JMSException \"  )  ;", "}    catch    ( ReplyFailureException   ex )     {", "assertEquals ( JMSException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "}", "verify ( responseTextMessage )  . setJMSCorrelationID (  . CORRELATION _ ID )  ;", "verify ( messageProducer )  . close (  )  ;", "verify ( delegate )  . handleMessage ( sentTextMessage )  ;", "}", "METHOD_END"], "methodName": ["testWithResponsiveMessageDelegateNoDefaultDestination_SendsReturnTextMessageWhenSessionSupplied_AndSendingThrowsJMSException"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Queue   destination    =    mock ( Queue . class )  ;", "final   TextMessage   sentTextMessage    =    mock ( TextMessage . class )  ;", "given ( sentTextMessage . getJMSCorrelationID (  )  )  . willReturn (  . CORRELATION _ ID )  ;", "given ( sentTextMessage . getJMSReplyTo (  )  )  . willReturn ( destination )  ;", "TextMessage   responseMessage    =    mock ( TextMessage . class )  ;", "QueueSender   queueSender    =    mock ( QueueSender . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createProducer ( destination )  )  . willReturn ( queueSender )  ;", "ResponsiveJmsTextMessageReturningMessageDelegate   delegate    =    mock ( ResponsiveJmsTextMessageReturningMessageDelegate . class )  ;", "given ( delegate . handleMessage ( sentTextMessage )  )  . willReturn ( responseMessage )  ;", "final   MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )     {", "@ Override", "protected   Object   extractMessage ( Message   message )     {", "return   message ;", "}", "}  ;", "adapter . setMessageConverter ( null )  ;", "adapter . onMessage ( sentTextMessage ,    session )  ;", "verify ( responseMessage )  . setJMSCorrelationID (  . CORRELATION _ ID )  ;", "verify ( queueSender )  . send ( responseMessage )  ;", "verify ( queueSender )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testWithResponsiveMessageDelegateWhenReturnTypeIsAJMSMessageAndNoMessageConverterIsSupplied"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "final   TextMessage   sentTextMessage    =    mock ( TextMessage . class )  ;", "final   Session   session    =    mock ( Session . class )  ;", "ResponsiveMessageDelegate   delegate    =    mock ( ResponsiveMessageDelegate . class )  ;", "given ( delegate . handleMessage ( sentTextMessage )  )  . willReturn (  . RESPONSE _ TEXT )  ;", "final   MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )     {", "@ Override", "protected   Object   extractMessage ( Message   message )     {", "return   message ;", "}", "}  ;", "adapter . setMessageConverter ( null )  ;", "try    {", "adapter . onMessage ( sentTextMessage ,    session )  ;", "fail (  \" expected   CouldNotSendReplyException   with   MessageConversionException \"  )  ;", "}    catch    ( ReplyFailureException   ex )     {", "assertEquals ( MessageConversionException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithResponsiveMessageDelegateWhenReturnTypeIsNotAJMSMessageAndNoMessageConverterIsSupplied"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Queue   destination    =    mock ( Queue . class )  ;", "TextMessage   sentTextMessage    =    mock ( TextMessage . class )  ;", "given ( sentTextMessage . getJMSCorrelationID (  )  )  . willReturn (  . CORRELATION _ ID )  ;", "given ( sentTextMessage . getJMSReplyTo (  )  )  . willReturn ( null )  ;", "TextMessage   responseTextMessage    =    mock ( TextMessage . class )  ;", "QueueSender   queueSender    =    mock ( QueueSender . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createTextMessage (  . RESPONSE _ TEXT )  )  . willReturn ( responseTextMessage )  ;", "given ( session . createProducer ( destination )  )  . willReturn ( queueSender )  ;", "ResponsiveMessageDelegate   delegate    =    mock ( ResponsiveMessageDelegate . class )  ;", "given ( delegate . handleMessage ( sentTextMessage )  )  . willReturn (  . RESPONSE _ TEXT )  ;", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )     {", "@ Override", "protected   Object   extractMessage ( Message   message )     {", "return   message ;", "}", "}  ;", "adapter . setDefaultResponseDestination ( destination )  ;", "adapter . onMessage ( sentTextMessage ,    session )  ;", "verify ( responseTextMessage )  . setJMSCorrelationID (  . CORRELATION _ ID )  ;", "verify ( queueSender )  . send ( responseTextMessage )  ;", "verify ( queueSender )  . close (  )  ;", "verify ( delegate )  . handleMessage ( sentTextMessage )  ;", "}", "METHOD_END"], "methodName": ["testWithResponsiveMessageDelegateWithDefaultDestination_SendsReturnTextMessageWhenSessionSupplied"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessage    =    mock ( TextMessage . class )  ;", "ResponsiveMessageDelegate   delegate    =    mock ( ResponsiveMessageDelegate . class )  ;", "given ( delegate . handleMessage ( textMessage )  )  . willReturn (  . TEXT )  ;", "MessageListenerAdapter   adapter    =    new   MessageListenerAdapter ( delegate )  ;", "adapter . setMessageConverter ( null )  ;", "adapter . onMessage ( textMessage )  ;", "}", "METHOD_END"], "methodName": ["testWithResponsiveMessageDelegate_DoesNotSendReturnTextMessageIfNoSessionSupplied"], "fileName": "org.springframework.jms.listener.adapter.MessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "InvocableHandlerMethod   handlerMethod    =    getHandlerMethod (  )  ;", "StBuilder   sb    =    new   StBuilder ( description )  . append (  \"  \\ n \"  )  . append (  \" Endpoint   handler   details :  \\ n \"  )  . append (  \" Method    [  \"  )  . append ( handlerMethod . getMethod (  )  )  . append (  \"  ]  \\ n \"  )  . append (  \" Bean    [  \"  )  . append ( handlerMethod . getBean (  )  )  . append (  \"  ]  \\ n \"  )  ;", "return   sb . toSt (  )  ;", "}", "METHOD_END"], "methodName": ["createMessagingErrorMessage"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . handlerMethod )     !  =    null )  ,     \" No   HandlerMethod   set \"  )  ;", "return   this . handlerMethod ;", "}", "METHOD_END"], "methodName": ["getHandlerMethod"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "InvocableHandlerMethod   handlerMethod    =    getHandlerMethod (  )  ;", "try    {", "return   handlerMethod . invoke ( message ,    jmsMessage ,    session )  ;", "}    catch    ( Exception   ex )     {", "throw   new   ListenerExecutionFailedException ( createErrorMessage (  \" Listener   method   could   not   be   invoked   with   incoming   message \"  )  ,    ex )  ;", "}    catch    ( Exception   ex )     {", "throw   new   ListenerExecutionFailedException (  (  (  \" Listener   method    '  \"     +     ( handlerMethod . getMethod (  )  . toGenericString (  )  )  )     +     \"  '    threw   exception \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeHandler"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "this . handlerMethod    =    handlerMethod ;", "}", "METHOD_END"], "methodName": ["setHandlerMethod"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( Message <  ?  >  )     ( getConverter (  )  . fromMessage ( jmsMessage )  )  )  ;", "}    catch    ( JMSException   ex )     {", "throw   new   MessageConversionException (  \" Could   not   convert   JMS   message \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["toMessagingMessage"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "Destination   replyTo    =    new   Destination (  )     {  }  ;", "Message < String >    result    =    MessageBuilder . withPayload (  \" Response \"  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . setHeader ( JmsHeaders . TYPE ,     \" msg _ type \"  )  . setHeader ( JmsHeaders . REPLY _ TO ,    replyTo )  . build (  )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createTextMessage (  \" Response \"  )  )  . willReturn ( new   StubTextMessage (  \" Response \"  )  )  ;", "listener    =    getSimpleInstance (  \" echo \"  ,    Message . class )  ;", "Message   replyMessage    =    listener . buildMessage ( session ,    result )  ;", "verify ( session )  . createTextMessage (  \" Response \"  )  ;", "assertNotNull (  \" reply   should   never   be   null \"  ,    replyMessage )  ;", "assertEquals (  \" Response \"  ,     (  ( TextMessage )     ( replyMessage )  )  . getText (  )  )  ;", "assertEquals (  \" custom   header   not   copied \"  ,     \" bar \"  ,    replyMessage . getStringProperty (  \" foo \"  )  )  ;", "assertEquals (  \" type   header   not   copied \"  ,     \" msg _ type \"  ,    replyMessage . getJMSType (  )  )  ;", "assertEquals (  \" replyTo   header   not   copied \"  ,    replyTo ,    replyMessage . getJMSReplyTo (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildMessageWithStandardMessage"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "MessagingMessageListenerAdapter   adapter    =    new   MessagingMessageListenerAdapter (  )  ;", "adapter . setHandlerMethod ( factory . createInvocableHandlerMethod ( sample ,    m )  )  ;", "return   adapter ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Message   message    =    new   StubTextMessage (  \" foo \"  )  ;", "Session   session    =    mock ( Session . class )  ;", "listener    =    getSimpleInstance (  \" wrongParam \"  ,    Integer . class )  ;", "try    {", "listener . onMessage ( message ,    session )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( JMSException   ex )     {", "fail (  \" Should   not   have   thrown   a   JMS   exception \"  )  ;", "}    catch    ( ListenerExecutionFailedException   ex )     {", "assertEquals ( MessageConversionException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["exceptionInInvocation"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Message   message    =    new   StubTextMessage (  \" foo \"  )  ;", "Session   session    =    mock ( Session . class )  ;", "listener    =    getSimpleInstance (  \" fail \"  ,    String . class )  ;", "try    {", "listener . onMessage ( message ,    session )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( JMSException   ex )     {", "fail (  \" Should   not   have   thrown   a   JMS   exception \"  )  ;", "}    catch    ( ListenerExecutionFailedException   ex )     {", "assertEquals ( IllegalArgumentException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "assertEquals (  \" Expected   test   exception \"  ,    ex . getCause (  )  . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["exceptionInListener"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( MessagingMessageListenerAdapterTests . SampleBean . class ,    methodName ,    parameterTypes )  ;", "MessagingMessageListenerAdapter   adapter    =    new   MessagingMessageListenerAdapter (  )     {", "@ Override", "protected   Object   extractMessage ( Message   message )     {", "return   payload ;", "}", "}  ;", "adapter . setHandlerMethod ( factory . createInvocableHandlerMethod ( sample ,    method )  )  ;", "return   adapter ;", "}", "METHOD_END"], "methodName": ["getPayloadInstance"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( MessagingMessageListenerAdapterTests . SampleBean . class ,    methodName ,    parameterTypes )  ;", "return   createInstance ( m )  ;", "}", "METHOD_END"], "methodName": ["getSimpleInstance"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    mock ( class )  ;", "when ( jmsMessage . getPropertyNames (  )  )  . thenThrow ( new   IllegalArgumentException (  \" Header   failure \"  )  )  ;", "listener    =    getSimpleInstance (  \" simple \"  ,    class )  ;", "Message <  ?  >    message    =    listener . toMessagingMessage ( jmsMessage )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Header   failure \"  )  ;", "message . getHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["headerConversionLazilyInvoked"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    mock ( class )  ;", "Session   session    =    mock ( Session . class )  ;", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "given ( messageConverter . fromMessage ( jmsMessage )  )  . willReturn (  \" FooBar \"  )  ;", "listener    =    getSimpleInstance (  \" simple \"  ,    class )  ;", "listener . setMessageConverter ( messageConverter )  ;", "listener . onMessage ( jmsMessage ,    session )  ;", "verify ( messageConverter ,    times (  1  )  )  . fromMessage ( jmsMessage )  ;", "assertEquals (  1  ,    sample . simples . size (  )  )  ;", "assertEquals (  \" FooBar \"  ,    sample . simples . get (  0  )  . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["incomingMessageUsesMessageConverter"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "factory . setBeanFactory ( new   StaticListableBeanFactory (  )  )  ;", "factory . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["initializeFactory"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    mock ( class )  ;", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "given ( messageConverter . fromMessage ( jmsMessage )  )  . willReturn (  \" FooBar \"  )  ;", "listener    =    getSimpleInstance (  \" simple \"  ,    class )  ;", "listener . setMessageConverter ( messageConverter )  ;", "Message <  ?  >    message    =    listener . toMessagingMessage ( jmsMessage )  ;", "verify ( messageConverter ,    never (  )  )  . fromMessage ( jmsMessage )  ;", "assertEquals (  \" FooBar \"  ,    message . getPayload (  )  )  ;", "verify ( messageConverter ,    times (  1  )  )  . fromMessage ( jmsMessage )  ;", "}", "METHOD_END"], "methodName": ["payloadConversionLazilyInvoked"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   reply    =    testReplyWithJackson (  \" replyJackson \"  ,     \"  {  \\  \" counter \\  \"  :  4  2  ,  \\  \" name \\  \"  :  \\  \" Response \\  \"  ,  \\  \" description \\  \"  :  \\  \" lengthy   description \\  \"  }  \"  )  ;", "verify ( reply )  . setObjectProperty (  \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["replyJackson"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   reply    =    testReplyWithJackson (  \" replyJacksonMessageAndJsonView \"  ,     \"  {  \\  \" name \\  \"  :  \\  \" Response \\  \"  }  \"  )  ;", "verify ( reply )  . setObjectProperty (  \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["replyJacksonMessageAndJsonView"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   reply    =    testReplyWithJackson (  \" replyJacksonPojoAndJsonView \"  ,     \"  {  \\  \" name \\  \"  :  \\  \" Response \\  \"  }  \"  )  ;", "verify ( reply ,    never (  )  )  . setObjectProperty (  \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["replyJacksonPojoAndJsonView"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Queue   replyDestination    =    mock ( Queue . class )  ;", "Session   session    =    mock ( Session . class )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   responseMessage    =    mock ( TextMessage . class )  ;", "given ( session . createTextMessage (  \" Response \"  )  )  . willReturn ( responseMessage )  ;", "given ( session . createProducer ( replyDestination )  )  . willReturn ( messageProducer )  ;", "listener    =    getPayloadInstance (  \" Response \"  ,     \" replyPayloadNoDestination \"  ,    Message . class )  ;", "listener . setDefaultResponseDestination ( replyDestination )  ;", "listener . onMessage ( mock ( Message . class )  ,    session )  ;", "verify ( session ,    times (  0  )  )  . createQueue ( anyString (  )  )  ;", "verify ( session )  . createTextMessage (  \" Response \"  )  ;", "verify ( messageProducer )  . send ( responseMessage )  ;", "verify ( messageProducer )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["replyPayloadNoDestination"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   responseMessage    =    mock ( TextMessage . class )  ;", "given ( session . createTextMessage (  \" Response \"  )  )  . willReturn ( responseMessage )  ;", "given ( session . createProducer (  . sharedReplyDestination )  )  . willReturn ( messageProducer )  ;", "MessagingMessageListenerAdapter   listener    =    getPayloadInstance (  \" Response \"  ,     \" replyPayloadToDestination \"  ,    Message . class )  ;", "listener . onMessage ( mock ( Message . class )  ,    session )  ;", "verify ( session ,    times (  0  )  )  . createQueue ( anyString (  )  )  ;", "verify ( session )  . createTextMessage (  \" Response \"  )  ;", "verify ( messageProducer )  . send ( responseMessage )  ;", "verify ( messageProducer )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["replyPayloadToDestination"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "Queue   replyDestination    =    mock ( Queue . class )  ;", "given ( session . createQueue (  \" queueOut \"  )  )  . willReturn ( replyDestination )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   responseMessage    =    mock ( TextMessage . class )  ;", "given ( session . createTextMessage (  \" Response \"  )  )  . willReturn ( responseMessage )  ;", "given ( session . createProducer ( replyDestination )  )  . willReturn ( messageProducer )  ;", "listener    =    getPayloadInstance (  \" Response \"  ,     \" replyPayloadToQueue \"  ,    Message . class )  ;", "listener . onMessage ( mock ( Message . class )  ,    session )  ;", "verify ( session )  . createQueue (  \" queueOut \"  )  ;", "verify ( session )  . createTextMessage (  \" Response \"  )  ;", "verify ( messageProducer )  . send ( responseMessage )  ;", "verify ( messageProducer )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["replyPayloadToQueue"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "Topic   replyDestination    =    mock ( Topic . class )  ;", "given ( session . createTopic (  \" topicOut \"  )  )  . willReturn ( replyDestination )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   responseMessage    =    mock ( TextMessage . class )  ;", "given ( session . createTextMessage (  \" Response \"  )  )  . willReturn ( responseMessage )  ;", "given ( session . createProducer ( replyDestination )  )  . willReturn ( messageProducer )  ;", "listener    =    getPayloadInstance (  \" Response \"  ,     \" replyPayloadToTopic \"  ,    Message . class )  ;", "listener . onMessage ( mock ( Message . class )  ,    session )  ;", "verify ( session )  . createTopic (  \" topicOut \"  )  ;", "verify ( session )  . createTextMessage (  \" Response \"  )  ;", "verify ( messageProducer )  . send ( responseMessage )  ;", "verify ( messageProducer )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["replyPayloadToTopic"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "MessageConverter   messageConverter    =    mock ( MessageConverter . class )  ;", "given ( messageConverter . toMessage (  \" Response \"  ,    session )  )  . willReturn ( new   StubTextMessage (  \" Response \"  )  )  ;", "Message < String >    result    =    MessageBuilder . withPayload (  \" Response \"  )  . build (  )  ;", "listener    =    getSimpleInstance (  \" echo \"  ,    Message . class )  ;", "listener . setMessageConverter ( messageConverter )  ;", "Message   replyMessage    =    listener . buildMessage ( session ,    result )  ;", "verify ( messageConverter ,    times (  1  )  )  . toMessage (  \" Response \"  ,    session )  ;", "assertNotNull (  \" reply   should   never   be   null \"  ,    replyMessage )  ;", "assertEquals (  \" Response \"  ,     (  ( TextMessage )     ( replyMessage )  )  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["replyUsesMessageConverterForPayload"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "Queue   replyDestination    =    mock ( Queue . class )  ;", "given ( session . createQueue (  \" queueOut \"  )  )  . willReturn ( replyDestination )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   responseMessage    =    mock ( TextMessage . class )  ;", "given ( session . createTextMessage (  \" Response \"  )  )  . willReturn ( responseMessage )  ;", "given ( session . createProducer ( replyDestination )  )  . willReturn ( messageProducer )  ;", "listener    =    getPayloadInstance (  \" Response \"  ,     \" replyPayloadToQueue \"  ,    Message . class )  ;", "QosSettings   settings    =    new   QosSettings (  )  ;", "settings . setTimeToLive (  6  0  0  0  )  ;", "listener . setResponseQosSettings ( settings )  ;", "listener . onMessage ( mock ( Message . class )  ,    session )  ;", "verify ( session )  . createQueue (  \" queueOut \"  )  ;", "verify ( session )  . createTextMessage (  \" Response \"  )  ;", "verify ( messageProducer )  . send ( responseMessage ,    Message ,    Message ,     6  0  0  0  )  ;", "verify ( messageProducer )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["replyWithCustomTimeToLive"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "Queue   replyDestination    =    mock ( Queue . class )  ;", "given ( session . createQueue (  \" queueOut \"  )  )  . willReturn ( replyDestination )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   responseMessage    =    mock ( TextMessage . class )  ;", "given ( session . createTextMessage (  \" Response \"  )  )  . willReturn ( responseMessage )  ;", "given ( session . createProducer ( replyDestination )  )  . willReturn ( messageProducer )  ;", "listener    =    getPayloadInstance (  \" Response \"  ,     \" replyPayloadToQueue \"  ,    Message . class )  ;", "QosSettings   settings    =    new   QosSettings ( DeliveryMode . NON _ PERSISTENT ,     6  ,     6  0  0  0  )  ;", "listener . setResponseQosSettings ( settings )  ;", "listener . onMessage ( mock ( Message . class )  ,    session )  ;", "verify ( session )  . createQueue (  \" queueOut \"  )  ;", "verify ( session )  . createTextMessage (  \" Response \"  )  ;", "verify ( messageProducer )  . send ( responseMessage ,    NON _ PERSISTENT ,     6  ,     6  0  0  0  )  ;", "verify ( messageProducer )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["replyWithFullQoS"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "initializeFactory ( factory )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Queue   replyDestination    =    mock ( Queue . class )  ;", "Session   session    =    mock ( Session . class )  ;", "MessageProducer   messageProducer    =    mock ( MessageProducer . class )  ;", "TextMessage   responseMessage    =    mock ( TextMessage . class )  ;", "given ( session . createTextMessage ( replyContent )  )  . willReturn ( responseMessage )  ;", "given ( session . createProducer ( replyDestination )  )  . willReturn ( messageProducer )  ;", "listener    =    getPayloadInstance (  \" Response \"  ,    methodName ,    Message . class )  ;", "MappingJackson 2 MessageConverter   messageConverter    =    new   MappingJackson 2 MessageConverter (  )  ;", "messageConverter . setTargetType ( MessageType . TEXT )  ;", "listener . setMessageConverter ( messageConverter )  ;", "listener . setDefaultResponseDestination ( replyDestination )  ;", "listener . onMessage ( mock ( Message . class )  ,    session )  ;", "verify ( session ,    times (  0  )  )  . createQueue ( anyString (  )  )  ;", "verify ( session )  . createTextMessage ( replyContent )  ;", "verify ( messageProducer )  . send ( responseMessage )  ;", "verify ( messageProducer )  . close (  )  ;", "return   responseMessage ;", "}", "METHOD_END"], "methodName": ["testReplyWithJackson"], "fileName": "org.springframework.jms.listener.adapter.MessagingMessageListenerAdapterTests"}, {"methodBody": ["METHOD_START", "{", "this . wasCalled    =    true ;", "}", "METHOD_END"], "methodName": ["handleMessage"], "fileName": "org.springframework.jms.listener.adapter.StubMessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . wasCalled ;", "}", "METHOD_END"], "methodName": ["wasCalled"], "fileName": "org.springframework.jms.listener.adapter.StubMessageListenerAdapter"}, {"methodBody": ["METHOD_START", "{", "activationSpecConfig . setAcknowledgeMode ( SESSION _ TRANSACTED )  ;", "JmsActivationSpecFactory   activationSpecFactory    =    new   DefaultJmsActivationSpecFactory (  )  ;", ". StubActiveMQActivationSpec   spec    =     (  (  . StubActiveMQActivationSpec )     ( activationSpecFactory . createActivationSpec ( new    . StubActiveMQResourceAdapter (  )  ,    activationSpecConfig )  )  )  ;", "assertEquals (  5  ,    spec . getMaxSessions (  )  )  ;", "assertEquals (  3  ,    spec . getMaxMessagesPerSessions (  )  )  ;", "assertTrue ( spec . isUseRAManagedTransaction (  )  )  ;", "}", "METHOD_END"], "methodName": ["activeMQResourceAdapterSetup"], "fileName": "org.springframework.jms.listener.endpoint.DefaultJmsActivationSpecFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   StubQueue (  )  ;", "DestinationResolver   destinationResolver    =    mock ( DestinationResolver . class )  ;", "given ( destinationResolver . resolveDestinationName ( null ,     \" destinationname \"  ,    false )  )  . willReturn ( destination )  ;", "DefaultJmsActivationSpecFactory   activationSpecFactory    =    new   DefaultJmsActivationSpecFactory (  )  ;", "activationSpecFactory . setDestinationResolver ( destinationResolver )  ;", ". StubWebSphereActivationSpecImpl   spec    =     (  (  . StubWebSphereActivationSpecImpl )     ( activationSpecFactory . createActivationSpec ( new    . StubWebSphereResourceAdapterImpl (  )  ,    activationSpecConfig )  )  )  ;", "assertEquals ( destination ,    spec . getDestination (  )  )  ;", "assertEquals (  5  ,    spec . getMaxConcurrency (  )  )  ;", "assertEquals (  3  ,    spec . getMaxBatchSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["webSphereResourceAdapterSetup"], "fileName": "org.springframework.jms.listener.endpoint.DefaultJmsActivationSpecFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   this . acknowledgeMode ;", "}", "METHOD_END"], "methodName": ["getAcknowledgeMode"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . clientId ;", "}", "METHOD_END"], "methodName": ["getClientId"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationName ;", "}", "METHOD_END"], "methodName": ["getDestinationName"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionDurable    ?    this . subscriptionName    :    null ;", "}", "METHOD_END"], "methodName": ["getDurableSubscriptionName"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . maxConcurrency ;", "}", "METHOD_END"], "methodName": ["getMaxConcurrency"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . messageConverter ;", "}", "METHOD_END"], "methodName": ["getMessageConverter"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . messageSelector ;", "}", "METHOD_END"], "methodName": ["getMessageSelector"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . prefetchSize ;", "}", "METHOD_END"], "methodName": ["getPrefetchSize"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . replyQosSettings ;", "}", "METHOD_END"], "methodName": ["getReplyQosSettings"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionName ;", "}", "METHOD_END"], "methodName": ["getSubscriptionName"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . pubSubDomain ;", "}", "METHOD_END"], "methodName": ["isPubSubDomain"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . replyPubSubDomain )     !  =    null )     {", "return   this . replyPubSubDomain ;", "} else    {", "return   isPubSubDomain (  )  ;", "}", "}", "METHOD_END"], "methodName": ["isReplyPubSubDomain"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionDurable ;", "}", "METHOD_END"], "methodName": ["isSubscriptionDurable"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionShared ;", "}", "METHOD_END"], "methodName": ["isSubscriptionShared"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . acknowledgeMode    =    acknowledgeMode ;", "}", "METHOD_END"], "methodName": ["setAcknowledgeMode"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "setAcknowledgeMode ( JmsActivationSpecConfig . sessionConstants . asNumber ( constantName )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setAcknowledgeModeName"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . clientId    =    clientId ;", "}", "METHOD_END"], "methodName": ["setClientId"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "try    {", "int   separatorIndex    =    concurrency . indexOf (  '  -  '  )  ;", "if    ( separatorIndex    !  =     (  -  1  )  )     {", "setMaxConcurrency ( Integer . parseInt ( concurrency . substring (  ( separatorIndex    +     1  )  ,    concurrency . length (  )  )  )  )  ;", "} else    {", "setMaxConcurrency ( Integer . parseInt ( concurrency )  )  ;", "}", "}    catch    ( NumberFormatException   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Invalid   concurrency   value    [  \"     +    concurrency )     +     \"  ]  :    only    \"  )     +     \" single   maximum   integer    ( e . g .     \\  \"  5  \\  \"  )    and   minimum - maximum   combo    ( e . g .     \\  \"  3  -  5  \\  \"  )    supported .     \"  )     +     \" Note   that      will   effectively   ignore   the   minimum   value   and    \"  )     +     \" scale   from   zero   up   to   the   number   of   consumers   according   to   the   maximum   value .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setConcurrency"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . destinationName    =    destinationName ;", "}", "METHOD_END"], "methodName": ["setDestinationName"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionName    =    durableSubscriptionName ;", "this . subscriptionDurable    =    durableSubscriptionName    !  =    null ;", "}", "METHOD_END"], "methodName": ["setDurableSubscriptionName"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . maxConcurrency    =    maxConcurrency ;", "}", "METHOD_END"], "methodName": ["setMaxConcurrency"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . messageConverter    =    messageConverter ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . messageSelector    =    messageSelector ;", "}", "METHOD_END"], "methodName": ["setMessageSelector"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . prefetchSize    =    prefetchSize ;", "}", "METHOD_END"], "methodName": ["setPrefetchSize"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . pubSubDomain    =    pubSubDomain ;", "}", "METHOD_END"], "methodName": ["setPubSubDomain"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . replyPubSubDomain    =    replyPubSubDomain ;", "}", "METHOD_END"], "methodName": ["setReplyPubSubDomain"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . replyQosSettings    =    replyQosSettings ;", "}", "METHOD_END"], "methodName": ["setReplyQosSettings"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionDurable    =    subscriptionDurable ;", "if    ( subscriptionDurable )     {", "this . pubSubDomain    =    true ;", "}", "}", "METHOD_END"], "methodName": ["setSubscriptionDurable"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionName    =    subscriptionName ;", "}", "METHOD_END"], "methodName": ["setSubscriptionName"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionShared    =    subscriptionShared ;", "if    ( subscriptionShared )     {", "this . pubSubDomain    =    true ;", "}", "}", "METHOD_END"], "methodName": ["setSubscriptionShared"], "fileName": "org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( messageListener )     !  =    null )  ,     \" No   MessageListener   set \"  )  ;", "return   this . messageListener ;", "}", "METHOD_END"], "methodName": ["getMessageListener"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointFactory"}, {"methodBody": ["METHOD_START", "{", "this . messageListener    =    messageListener ;", "}", "METHOD_END"], "methodName": ["setMessageListener"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . activationSpecConfig ;", "}", "METHOD_END"], "methodName": ["getActivationSpecConfig"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "return   this . endpointFactory . getMessageListener (  )  ;", "}", "METHOD_END"], "methodName": ["getMessageListener"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . activationSpecConfig    =    activationSpecConfig ;", "}", "METHOD_END"], "methodName": ["setActivationSpecConfig"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . activationSpecFactory    =     ( activationSpecFactory    !  =    null )     ?    activationSpecFactory    :    new   DefaultJmsActivationSpecFactory (  )  ;", "}", "METHOD_END"], "methodName": ["setActivationSpecFactory"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "DefaultJmsActivationSpecFactory   factory    =    new   DefaultJmsActivationSpecFactory (  )  ;", "factory . setDestinationResolver ( destinationResolver )  ;", "this . activationSpecFactory    =    factory ;", "}", "METHOD_END"], "methodName": ["setDestinationResolver"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . endpointFactory . setMessageListener ( messageListener )  ;", "this . messageListenerSet    =    true ;", "}", "METHOD_END"], "methodName": ["setMessageListener"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . endpointFactory . setTransactionManager ( transactionManager )  ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   endpoint    =    new   JmsMessageEndpointManager (  )  ;", "JmsActivationSpecConfig   config    =    new   JmsActivationSpecConfig (  )  ;", "QosSettings   settings    =    new   QosSettings (  1  ,     3  ,     5  )  ;", "config . setReplyQosSettings ( settings )  ;", "endpoint . setActivationSpecConfig ( config )  ;", "assertNotNull ( endpoint . getReplyQosSettings (  )  )  ;", "assertEquals (  1  ,    endpoint . getReplyQosSettings (  )  . getDeliveryMode (  )  )  ;", "assertEquals (  3  ,    endpoint . getReplyQosSettings (  )  . getPriority (  )  )  ;", "assertEquals (  5  ,    endpoint . getReplyQosSettings (  )  . getTimeToLive (  )  )  ;", "}", "METHOD_END"], "methodName": ["customReplyQosSettings"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManagerTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   endpoint    =    new   JmsMessageEndpointManager (  )  ;", "assertNull ( endpoint . getDestinationResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDestinationResolverNoConfig"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManagerTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   endpoint    =    new   JmsMessageEndpointManager (  )  ;", "assertNull ( endpoint . getMessageConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessageConverterNoConfig"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManagerTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   endpoint    =    new   JmsMessageEndpointManager (  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "endpoint . getReplyQosSettings (  )  ;", "}", "METHOD_END"], "methodName": ["getReplyQosSettingsWithNoConfig"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManagerTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   endpoint    =    new   JmsMessageEndpointManager (  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "endpoint . isPubSubDomain (  )  ;", "}", "METHOD_END"], "methodName": ["isPubSubDomainWithNoConfig"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManagerTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   endpoint    =    new   JmsMessageEndpointManager (  )  ;", "JmsActivationSpecConfig   config    =    new   JmsActivationSpecConfig (  )  ;", "config . setPubSubDomain ( false )  ;", "endpoint . setActivationSpecConfig ( config )  ;", "assertEquals ( false ,    endpoint . isPubSubDomain (  )  )  ;", "assertEquals ( false ,    endpoint . isReplyPubSubDomain (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPubSubDomainWithQueue"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManagerTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   endpoint    =    new   JmsMessageEndpointManager (  )  ;", "JmsActivationSpecConfig   config    =    new   JmsActivationSpecConfig (  )  ;", "config . setPubSubDomain ( true )  ;", "endpoint . setActivationSpecConfig ( config )  ;", "assertEquals ( true ,    endpoint . isPubSubDomain (  )  )  ;", "assertEquals ( true ,    endpoint . isReplyPubSubDomain (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPubSubDomainWithTopic"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManagerTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   endpoint    =    new   JmsMessageEndpointManager (  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "endpoint . isReplyPubSubDomain (  )  ;", "}", "METHOD_END"], "methodName": ["isReplyPubSubDomainWithNoConfig"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManagerTests"}, {"methodBody": ["METHOD_START", "{", "JmsMessageEndpointManager   endpoint    =    new   JmsMessageEndpointManager (  )  ;", "JmsActivationSpecConfig   config    =    new   JmsActivationSpecConfig (  )  ;", "config . setPubSubDomain ( true )  ;", "config . setReplyPubSubDomain ( false )  ;", "endpoint . setActivationSpecConfig ( config )  ;", "assertEquals ( true ,    endpoint . isPubSubDomain (  )  )  ;", "assertEquals ( false ,    endpoint . isReplyPubSubDomain (  )  )  ;", "}", "METHOD_END"], "methodName": ["pubSubDomainCustomForReply"], "fileName": "org.springframework.jms.listener.endpoint.JmsMessageEndpointManagerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( ackMode    =  =     ( Session . SESSION _ TRANSACTED )  )     {", "throw   new   IllegalArgumentException (  (  \" No   support   for   SESSION _ TRANSACTED :    Only    \\  \" Auto - acknowledge \\  \"     \"     +     \" and    \\  \" Dups - ok - acknowledge \\  \"    supported   in   s   JCA    1  .  5  \"  )  )  ;", "} else", "if    ( ackMode    =  =     ( Session . CLIENT _ ACKNOWLEDGE )  )     {", "throw   new   IllegalArgumentException (  (  \" No   support   for   CLIENT _ ACKNOWLEDGE :    Only    \\  \" Auto - acknowledge \\  \"     \"     +     \" and    \\  \" Dups - ok - acknowledge \\  \"    supported   in   s   JCA    1  .  5  \"  )  )  ;", "} else", "if    ( bw . isWritableProperty (  \" acknowledgeMode \"  )  )     {", "bw . setPropertyValue (  \" acknowledgeMode \"  ,     ( ackMode    =  =     ( Session . DUPS _ OK _ ACKNOWLEDGE )     ?     \" Dups - ok - acknowledge \"     :     \" Auto - acknowledge \"  )  )  ;", "} else", "if    ( ackMode    =  =     ( Session . DUPS _ OK _ ACKNOWLEDGE )  )     {", "throw   new   IllegalArgumentException (  \" Dups - ok - acknowledge   not   supported   by   underlying   provider \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyAcknowledgeMode"], "fileName": "org.springframework.jms.listener.endpoint.StandardJmsActivationSpecFactory"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["determineActivationSpecClass"], "fileName": "org.springframework.jms.listener.endpoint.StandardJmsActivationSpecFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationResolver ;", "}", "METHOD_END"], "methodName": ["getDestinationResolver"], "fileName": "org.springframework.jms.listener.endpoint.StandardJmsActivationSpecFactory"}, {"methodBody": ["METHOD_START", "{", "String   destinationName    =    config . getDestinationName (  )  ;", "if    ( destinationName    !  =    null )     {", "boolean   pubSubDomain    =    config . isPubSubDomain (  )  ;", "Object   destination    =    destinationName ;", "if    (  ( this . destinationResolver )     !  =    null )     {", "try    {", "destination    =    this . destinationResolver . resolveDestinationName ( null ,    destinationName ,    pubSubDomain )  ;", "}    catch    ( JMSException   ex )     {", "throw   new   DestinationResolutionException (  (  (  \" Cannot   resolve   destination   name    [  \"     +    destinationName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "bw . setPropertyValue (  \" destination \"  ,    destination )  ;", "bw . setPropertyValue (  \" destinationType \"  ,     ( pubSubDomain    ?    Topic . class . getName (  )     :    Queue . class . getName (  )  )  )  ;", "}", "if    ( bw . isWritableProperty (  \" subscriptionDurability \"  )  )     {", "bw . setPropertyValue (  \" subscriptionDurability \"  ,     ( config . isSubscriptionDurable (  )     ?     \" Durable \"     :     \" NonDurable \"  )  )  ;", "} else", "if    ( config . isSubscriptionDurable (  )  )     {", "throw   new   IllegalArgumentException (  \" Durable   subscriptions   not   supported   by   underlying   provider \"  )  ;", "}", "if    ( config . isSubscriptionShared (  )  )     {", "throw   new   IllegalArgumentException (  \" Shared   subscriptions   not   supported   for   JCA - driven   s \"  )  ;", "}", "if    (  ( config . getSubscriptionName (  )  )     !  =    null )     {", "bw . setPropertyValue (  \" subscriptionName \"  ,    config . getSubscriptionName (  )  )  ;", "}", "if    (  ( config . getClientId (  )  )     !  =    null )     {", "bw . setPropertyValue (  \" clientId \"  ,    config . getClientId (  )  )  ;", "}", "if    (  ( config . getMessageSelector (  )  )     !  =    null )     {", "bw . setPropertyValue (  \" messageSelector \"  ,    config . getMessageSelector (  )  )  ;", "}", "applyAcknowledgeMode ( bw ,    config . getAcknowledgeMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["populateActivationSpecProperties"], "fileName": "org.springframework.jms.listener.endpoint.StandardJmsActivationSpecFactory"}, {"methodBody": ["METHOD_START", "{", "this . activationSpecClass    =    activationSpecClass ;", "}", "METHOD_END"], "methodName": ["setActivationSpecClass"], "fileName": "org.springframework.jms.listener.endpoint.StandardJmsActivationSpecFactory"}, {"methodBody": ["METHOD_START", "{", "this . defaultProperties    =    defaultProperties ;", "}", "METHOD_END"], "methodName": ["setDefaultProperties"], "fileName": "org.springframework.jms.listener.endpoint.StandardJmsActivationSpecFactory"}, {"methodBody": ["METHOD_START", "{", "this . destinationResolver    =    destinationResolver ;", "}", "METHOD_END"], "methodName": ["setDestinationResolver"], "fileName": "org.springframework.jms.listener.endpoint.StandardJmsActivationSpecFactory"}, {"methodBody": ["METHOD_START", "{", "return   acknowledgeMode ;", "}", "METHOD_END"], "methodName": ["getAcknowledgeMode"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "return   clientId ;", "}", "METHOD_END"], "methodName": ["getClientId"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "return   destinationType ;", "}", "METHOD_END"], "methodName": ["getDestinationType"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "return   messageSelector ;", "}", "METHOD_END"], "methodName": ["getMessageSelector"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "return   subscriptionDurability ;", "}", "METHOD_END"], "methodName": ["getSubscriptionDurability"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "return   subscriptionName ;", "}", "METHOD_END"], "methodName": ["getSubscriptionName"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "this . acknowledgeMode    =    acknowledgeMode ;", "}", "METHOD_END"], "methodName": ["setAcknowledgeMode"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "this . clientId    =    clientId ;", "}", "METHOD_END"], "methodName": ["setClientId"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "this . destinationType    =    destinationType ;", "}", "METHOD_END"], "methodName": ["setDestinationType"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "this . messageSelector    =    messageSelector ;", "}", "METHOD_END"], "methodName": ["setMessageSelector"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionDurability    =    subscriptionDurability ;", "}", "METHOD_END"], "methodName": ["setSubscriptionDurability"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "this . subscriptionName    =    subscriptionName ;", "}", "METHOD_END"], "methodName": ["setSubscriptionName"], "fileName": "org.springframework.jms.listener.endpoint.StubJmsActivationSpec"}, {"methodBody": ["METHOD_START", "{", "return   new   RemoteAccessException (  (  (  \" Could   not   access   JMS   invoker   queue    [  \"     +     ( this . queue )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "METHOD_END"], "methodName": ["convertJmsInvokerAccessException"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getConnectionFactory (  )  ;", "Assert . state (  ( connectionFactory    !  =    null )  ,     \" No   ConnectionFactory   set \"  )  ;", "return   connectionFactory . createConnection (  )  ;", "}", "METHOD_END"], "methodName": ["createConnection"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . remoteInvocationFactory . createRemoteInvocation ( methodInvocation )  ;", "}", "METHOD_END"], "methodName": ["createRemoteInvocation"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . messageConverter . toMessage ( invocation ,    session )  ;", "}", "METHOD_END"], "methodName": ["createRequestMessage"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   con . createSession ( false ,    AUTO _ ACKNOWLEDGE )  ;", "}", "METHOD_END"], "methodName": ["createSession"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "TemporaryQueuesponseQueue    =    null ;", "MessageProducer   producer    =    null ;", "MessageConsumer   consumer    =    null ;", "try    {", "sponseQueue    =    session . ateTemporaryQueue (  )  ;", "producer    =    session . ateProducer ( queue )  ;", "consumer    =    session . ateConsumersponseQueue )  ;", "questMessage . setJMSReplyTosponseQueue )  ;", "producer . sendquestMessage )  ;", "long   timeout    =    getReceiveTimeout (  )  ;", "turn   timeout    >     0     ?    consumerceive ( timeout )     :    consumerceive (  )  ;", "}    finally    {", "JmsUtils . closeMessageConsumer ( consumer )  ;", "JmsUtils . closeMessageProducer ( producer )  ;", "if   sponseQueue    !  =    null )     {", "sponseQueue . delete (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doExecuteRequest"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Connection   con    =    createConnection (  )  ;", "Session   session    =    null ;", "try    {", "session    =    createSession ( con )  ;", "Queue   queueToUse    =    resolveQueue ( session )  ;", "Message   requestMessage    =    createRequestMessage ( session ,    invocation )  ;", "con . start (  )  ;", "Message   responseMessage    =    doExecuteRequest ( session ,    queueToUse ,    requestMessage )  ;", "if    ( responseMessage    !  =    null )     {", "return   extractcationResult ( responseMessage )  ;", "} else    {", "return   onReceiveTimeout ( invocation )  ;", "}", "}    finally    {", "JmsUtils . closeSession ( session )  ;", "ConnectionFactoryUtils . releaseConnection ( con ,    getConnectionFactory (  )  ,    true )  ;", "}", "}", "METHOD_END"], "methodName": ["executeRequest"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Object   content    =    this . messageConverter . fromMessage ( responseMessage )  ;", "if    ( content   instanceof   ReInvocationResult )     {", "return    (  ( ReInvocationResult )     ( content )  )  ;", "}", "return   onInvalidResponse ( responseMessage )  ;", "}", "METHOD_END"], "methodName": ["extractInvocationResult"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . connectionFactory ;", "}", "METHOD_END"], "methodName": ["getConnectionFactory"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . receiveTimeout ;", "}", "METHOD_END"], "methodName": ["getReceiveTimeout"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "throw   new   MessageFormatException (  (  \" Invalid   response   message :     \"     +    responseMessage )  )  ;", "}", "METHOD_END"], "methodName": ["onInvalidResponse"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "throw   new   RemoteTimeoutException (  (  (  (  \" Receive   timeout   after    \"     +     ( this . receiveTimeout )  )     +     \"    ms   for    \"  )     +    invocation )  )  ;", "}", "METHOD_END"], "methodName": ["onReceiveTimeout"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   result . recreate (  )  ;", "}", "METHOD_END"], "methodName": ["recreateRemoteInvocationResult"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . queue )    instanceof   Queue )     {", "return    (  ( Queue )     ( this . queue )  )  ;", "} else", "if    (  ( this . queue )    instanceof   String )     {", "return   resolveQueueName ( session ,     (  ( String )     ( this . queue )  )  )  ;", "} else    {", "throw   new   javaxIllegalStateException (  (  (  \" Queue   object    [  \"     +     ( this . queue )  )     +     \"  ]    is   neither   a    [ javaxQueue ]    nor   a   queue   name   String \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveQueue"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Queue )     ( this . destinationResolver . resolveDestinationName ( session ,    queueName ,    false )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveQueueName"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . connectionFactory    =    connectionFactory ;", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . destinationResolver    =     ( destinationResolver    !  =    null )     ?    destinationResolver    :    new   DynamicDestinationResolver (  )  ;", "}", "METHOD_END"], "methodName": ["setDestinationResolver"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . messageConverter    =     ( messageConverter    !  =    null )     ?    messageConverter    :    new   SimpleMessageConverter (  )  ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . queue    =    queue ;", "}", "METHOD_END"], "methodName": ["setQueue"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . queue    =    queueName ;", "}", "METHOD_END"], "methodName": ["setQueueName"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . receiveTimeout    =    receiveTimeout ;", "}", "METHOD_END"], "methodName": ["setReceiveTimeout"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . remoteInvocationFactory    =     ( remoteInvocationFactory    !  =    null )     ?    remoteInvocationFactory    :    new   DefaultRemoteInvocationFactory (  )  ;", "}", "METHOD_END"], "methodName": ["setRemoteInvocationFactory"], "fileName": "org.springframework.jms.remoting.JmsInvokerClientInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( serviceInterface ,     \"  ' serviceInterface '    must   not   be   null \"  )  ;", "Assert . isTrue ( serviceInterface . iterface (  )  ,     \"  ' serviceInterface '    must   be   an   interface \"  )  ;", "this . serviceInterface    =    serviceInterface ;", "}", "METHOD_END"], "methodName": ["setServiceInterface"], "fileName": "org.springframework.jms.remoting.JmsInvokerProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Message   response    =    this . messageConverter . toMessage ( result ,    session )  ;", "String   correlation    =    request . getJMSCorrelationID (  )  ;", "if    ( correlation    =  =    null )     {", "correlation    =    request . getJMSMessageID (  )  ;", "}", "response . setJMSCorrelationID ( correlation )  ;", "return   response ;", "}", "METHOD_END"], "methodName": ["createResponseMessage"], "fileName": "org.springframework.jms.remoting.JmsInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "if    ( this . ignoreInvalidRequests )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  \" Invalid   request   message   will   be   discarded :     \"     +    requestMessage )  )  ;", "}", "return   null ;", "} else    {", "throw   new   javaxMessageFormatException (  (  \" Invalid   request   message :     \"     +    requestMessage )  )  ;", "}", "}", "METHOD_END"], "methodName": ["onInvalidRequest"], "fileName": "org.springframework.jms.remoting.JmsInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "Object   content    =    this . messageConverter . fromMessage ( requestMessage )  ;", "if    ( content   instanceof   RemoteInvocation )     {", "return    (  ( RemoteInvocation )     ( content )  )  ;", "}", "return   onInvalidRequest ( requestMessage )  ;", "}", "METHOD_END"], "methodName": ["readRemoteInvocation"], "fileName": "org.springframework.jms.remoting.JmsInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . ignoreInvalidRequests    =    ignoreInvalidRequests ;", "}", "METHOD_END"], "methodName": ["setIgnoreInvalidRequests"], "fileName": "org.springframework.jms.remoting.JmsInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "this . messageConverter    =     ( messageConverter    !  =    null )     ?    messageConverter    :    new   SimpleMessageConverter (  )  ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.jms.remoting.JmsInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "Message   response    =    createResponseMessage ( requestMessage ,    session ,    result )  ;", "MessageProducer   producer    =    session . createProducer ( requestMessage . getJMSReplyTo (  )  )  ;", "try    {", "producer . send ( response )  ;", "}    finally    {", "Utils . closeMessageProducer ( producer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeRemoteInvocationResult"], "fileName": "org.springframework.jms.remoting.JmsInvokerServiceExporter"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  \" myname \"  ,     9  9  )  ;", "final   JmsInvokerServiceExporter   exporter    =    new   JmsInvokerServiceExporter (  )  ;", "exporter . setServiceInterface ( ITestBean . class )  ;", "exporter . setService ( target )  ;", "exporter . setMessageConverter ( new    . MockSimpleMessageConverter (  )  )  ;", "exporter . afterPropertiesSet (  )  ;", "JmsInvokerProxyFactoryBean   pfb    =    new   JmsInvokerProxyFactoryBean (  )     {", "@ Override", "protected   Message   doExecuteRequest ( Session   session ,    Queue   queue ,    Message   requestMessage )    throws   JMSException    {", "Session   mockExporterSession    =    mock ( Session . class )  ;", ". ResponseStoringProducer   mockProducer    =    new    . ResponseStoringProducer (  )  ;", "given ( mockExporterSession . createProducer ( requestMessage . getJMSReplyTo (  )  )  )  . willReturn ( mockProducer )  ;", "exporter . onMessage ( requestMessage ,    mockExporterSession )  ;", "assertTrue ( mockProducer . closed )  ;", "return   mockProducer . response ;", "}", "}  ;", "pfb . setServiceInterface ( ITestBean . class )  ;", "pfb . setConnectionFactory ( this . mockConnectionFactory )  ;", "if    ( dynamicQueue )     {", "pfb . setQueueName (  \" myQueue \"  )  ;", "} else    {", "pfb . setQueue ( this . mockQueue )  ;", "}", "pfb . setMessageConverter ( new    . MockSimpleMessageConverter (  )  )  ;", "pfb . afterPropertiesSet (  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pfb . getObject (  )  )  )  ;", "assertEquals (  \" myname \"  ,    proxy . getName (  )  )  ;", "assertEquals (  9  9  ,    proxy . getAge (  )  )  ;", "proxy . setAge (  5  0  )  ;", "assertEquals (  5  0  ,    proxy . getAge (  )  )  ;", "proxy . setStringArray ( new   String [  ]  {     \" str 1  \"  ,     \" str 2  \"     }  )  ;", "assertTrue ( Arrays . equals ( new   String [  ]  {     \" str 1  \"  ,     \" str 2  \"     }  ,    proxy . getStringArray (  )  )  )  ;", "try    {", "proxy . exceptional ( new   IllegalStateException (  )  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "try    {", "proxy . exceptional ( new   IllegalAccessException (  )  )  ;", "fail (  \" Should   have   thrown   IllegalAccessException \"  )  ;", "}    catch    ( IllegalAccessException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["doTestJmsInvokerProxyFactoryBeanAndServiceExporter"], "fileName": "org.springframework.jms.remoting.JmsInvokerTests"}, {"methodBody": ["METHOD_START", "{", "JmsInvokerProxyFactoryBean   pfb    =    new   JmsInvokerProxyFactoryBean (  )     {", "@ Override", "protected   Message   doExecuteRequest ( Session   session ,    Queue   queue ,    Message   requestMessage )    throws   JMSException    {", "return   null ;", "}", "}  ;", "pfb . setServiceInterface ( ITestBean . class )  ;", "pfb . setConnectionFactory ( this . mockConnectionFactory )  ;", "pfb . setQueue ( this . mockQueue )  ;", "pfb . setReceiveTimeout (  1  5  0  0  )  ;", "pfb . afterPropertiesSet (  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pfb . getObject (  )  )  )  ;", "thrown . expect ( RemoteTimeoutException . class )  ;", "thrown . expectMessage (  \"  1  5  0  0    ms \"  )  ;", "thrown . expectMessage (  \" getAge \"  )  ;", "proxy . getAge (  )  ;", "}", "METHOD_END"], "methodName": ["receiveTimeoutExpired"], "fileName": "org.springframework.jms.remoting.JmsInvokerTests"}, {"methodBody": ["METHOD_START", "{", "mockConnectionFactory    =    mock ( QueueConnectionFactory . class )  ;", "mockConnection    =    mock ( QueueConnection . class )  ;", "mockSession    =    mock ( QueueSession . class )  ;", "mockQueue    =    mock ( Queue . class )  ;", "given ( mockConnectionFactory . createConnection (  )  )  . willReturn ( mockConnection )  ;", "given ( mockConnection . createSession ( false ,    AUTO _ ACKNOWLEDGE )  )  . willReturn ( mockSession )  ;", "}", "METHOD_END"], "methodName": ["setUpMocks"], "fileName": "org.springframework.jms.remoting.JmsInvokerTests"}, {"methodBody": ["METHOD_START", "{", "doTestJmsInvokerProxyFactoryBeanAndServiceExporter ( false )  ;", "}", "METHOD_END"], "methodName": ["testJmsInvokerProxyFactoryBeanAndServiceExporter"], "fileName": "org.springframework.jms.remoting.JmsInvokerTests"}, {"methodBody": ["METHOD_START", "{", "given ( mockSession . createQueue (  \" myQueue \"  )  )  . willReturn ( mockQueue )  ;", "doTestProxyFactoryBeanAndServiceExporter ( true )  ;", "}", "METHOD_END"], "methodName": ["testJmsInvokerProxyFactoryBeanAndServiceExporterWithDynamicQueue"], "fileName": "org.springframework.jms.remoting.JmsInvokerTests"}, {"methodBody": ["METHOD_START", "{", "return   JmsUtils . convertJmsAccessException ( ex )  ;", "}", "METHOD_END"], "methodName": ["convertJmsAccessException"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "return   obtainConnectionFactory (  )  . createConnection (  )  ;", "}", "METHOD_END"], "methodName": ["createConnection"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "return   con . createSession ( isSessionTransacted (  )  ,    getSessionAcknowledgeMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["createSession"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . connectionFactory ;", "}", "METHOD_END"], "methodName": ["getConnectionFactory"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionAcknowledgeMode ;", "}", "METHOD_END"], "methodName": ["getSessionAcknowledgeMode"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "return    ( session . getAcknowledgeMode (  )  )     =  =     ( Session . CLIENT _ ACKNOWLEDGE )  ;", "}", "METHOD_END"], "methodName": ["isClientAcknowledge"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionTransacted ;", "}", "METHOD_END"], "methodName": ["isSessionTransacted"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getConnectionFactory (  )  ;", "Assestate (  ( connectionFactory    !  =    null )  ,     \" No   ConnectionFactory   set \"  )  ;", "return   connectionFactory ;", "}", "METHOD_END"], "methodName": ["obtainConnectionFactory"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "this . connectionFactory    =    connectionFactory ;", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "this . sessionAcknowledgeMode    =    sessionAcknowledgeMode ;", "}", "METHOD_END"], "methodName": ["setSessionAcknowledgeMode"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "setSessionAcknowledgeMode ( JmsAccessor . sessionConstants . asNumber ( constantName )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setSessionAcknowledgeModeName"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "this . sessionTransacted    =    sessionTransacted ;", "}", "METHOD_END"], "methodName": ["setSessionTransacted"], "fileName": "org.springframework.jms.support.JmsAccessor"}, {"methodBody": ["METHOD_START", "{", "JmsAccessor   accessor    =    new   JmsAccessorTests . StubJmsAccessor (  )  ;", "assertEquals (  (  \" The    [ sessionAcknowledgeMode ]    property   of   JmsAccessor   must   default   to    \"     +     (  \"  [ Session . AUTO _ ACKNOWLEDGE ]  .    Change   this   test    ( and   the   attendant    \"     +     \" Javadoc )    if   you   have   changed   the   default .  \"  )  )  ,    AUTO _ ACKNOWLEDGE ,    accessor . getSessionAcknowledgeMode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAcknowledgeModeReallyDoesDefaultToAutoAcknowledge"], "fileName": "org.springframework.jms.support.JmsAccessorTests"}, {"methodBody": ["METHOD_START", "{", "JmsAccessor   accessor    =    new   JmsAccessorTests . StubJmsAccessor (  )  ;", "accessor . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testChokesIfConnectionFactoryIsNotSupplied"], "fileName": "org.springframework.jms.support.JmsAccessorTests"}, {"methodBody": ["METHOD_START", "{", "JmsAccessor   accessor    =    new   JmsAccessorTests . StubJmsAccessor (  )  ;", "assertFalse (  (  \" The    [ sessionTransacted ]    property   of   JmsAccessor   must   default   to    \"     +     (  \" false .    Change   this   test    ( and   the   attendant   Javadoc )    if   you   have    \"     +     \" changed   the   default .  \"  )  )  ,    accessor . isSessionTransacted (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSessionTransactedModeReallyDoesDefaultToFalse"], "fileName": "org.springframework.jms.support.JmsAccessorTests"}, {"methodBody": ["METHOD_START", "{", "new   JmsAccessorTests . StubJmsAccessor (  )  . setSessionAcknowledgeModeName (  \" Tally   ho   chaps !  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAcknowledgeModeNameChokesIfBadAckModeIsSupplied"], "fileName": "org.springframework.jms.support.JmsAccessorTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( getHeader ( JmsHeaders . CORRELATION _ ID )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCorrelationId"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Integer )     ( getHeader ( JmsHeaders . DELIVERY _ MODE )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDeliveryMode"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Destination )     ( getHeader ( JmsHeaders . DESTINATION )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDestination"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Long )     ( getHeader ( JmsHeaders . EXPIRATION )  )  )  ;", "}", "METHOD_END"], "methodName": ["getExpiration"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( getHeader ( JmsHeaders . MESSAGE _ ID )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessageId"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Integer )     ( getHeader ( JmsHeaders . PRIORITY )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPriority"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Boolean )     ( getHeader ( JmsHeaders . REDELIVERED )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRedelivered"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Destination )     ( getHeader ( JmsHeaders . REPLY _ TO )  )  )  ;", "}", "METHOD_END"], "methodName": ["getReplyTo"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( getHeader ( JmsHeaders . TYPE )  )  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   JmsMessageHeaderAccessor ( message )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "Destination   replyTo    =    new   Destination (  )     {  }  ;", "StubTextMessage   jmsMessage    =    new   StubTextMessage (  \" test \"  )  ;", "jmsMessage . setJMSCorrelationID (  \" correlation -  1  2  3  4  \"  )  ;", "jmsMessage . setJMSPriority (  9  )  ;", "jmsMessage . setJMSDestination ( destination )  ;", "jmsMessage . setJMSDeliveryMode (  1  )  ;", "jmsMessage . setJMSExpiration (  1  2  3  4 L )  ;", "jmsMessage . setJMSMessageID (  \" abcd -  1  2  3  4  \"  )  ;", "jmsMessage . setJMSPriority (  9  )  ;", "jmsMessage . setJMSReplyTo ( replyTo )  ;", "jmsMessage . setJMSRedelivered ( true )  ;", "jmsMessage . setJMSType (  \" type \"  )  ;", "jmsMessage . setJMSTimestamp (  4  5  6  7 L )  ;", "Map < String ,    Object >    mappedHeaders    =    new   SimpleJmsHeaderMapper (  )  . toHeaders ( jmsMessage )  ;", "Message < String >    message    =    MessageBuilder . withPayload (  \" test \"  )  . copyHeaders ( mappedHeaders )  . build (  )  ;", "headerAccessor    =     . wrap ( message )  ;", "assertEquals (  \" correlation -  1  2  3  4  \"  ,    headerAccessor . getCorrelationId (  )  )  ;", "assertEquals ( destination ,    headerAccessor . getDestination (  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    headerAccessor . getDeliveryMode (  )  )  ;", "assertEquals (  1  2  3  4 L ,    headerAccessor . getExpiration (  )  ,     0  .  0  )  ;", "assertEquals (  \" abcd -  1  2  3  4  \"  ,    headerAccessor . getMessageId (  )  )  ;", "assertEquals ( Integer . valueOf (  9  )  ,    headerAccessor . getPriority (  )  )  ;", "assertEquals ( replyTo ,    headerAccessor . getReplyTo (  )  )  ;", "assertEquals ( true ,    headerAccessor . getRedelivered (  )  )  ;", "assertEquals (  \" type \"  ,    headerAccessor . getType (  )  )  ;", "assertEquals (  4  5  6  7 L ,    headerAccessor . getTimestamp (  )  ,     0  .  0  )  ;", "assertNull ( headerAccessor . getReplyChannel (  )  )  ;", "}", "METHOD_END"], "methodName": ["validateJmsHeaders"], "fileName": "org.springframework.jms.support.JmsMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "String   message    =    ex . getMessage (  )  ;", "Exception   linkedEx    =    ex . getLinkedException (  )  ;", "if    ( linkedEx    !  =    null )     {", "if    ( message    =  =    null )     {", "message    =    linkedEx . toString (  )  ;", "} else    {", "String   linkedMessage    =    linkedEx . getMessage (  )  ;", "if    (  ( linkedMessage    !  =    null )     &  &     (  !  ( message . contains ( linkedMessage )  )  )  )     {", "message    =     ( message    +     \"  ;    nested   exception   is    \"  )     +    linkedEx ;", "}", "}", "}", "return   message ;", "}", "METHOD_END"], "methodName": ["buildExceptionMessage"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "JmsUtils . closeConnection ( con ,    false )  ;", "}", "METHOD_END"], "methodName": ["closeConnection"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( con    !  =    null )     {", "try    {", "if    ( stop )     {", "try    {", "con . stop (  )  ;", "}    finally    {", "con . close (  )  ;", "}", "} else    {", "con . close (  )  ;", "}", "}    catch    ( jms   ex )     {", ". logger . debug (  (  \" Ignoring   Connection   state   exception    -    assuming   already   closed :     \"     +    ex )  )  ;", "}    catch    ( JMSException   ex )     {", ". logger . debug (  \" Could   not   close   JMS   Connection \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Unexpected   exception   on   closing   JMS   Connection \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeConnection"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( consumer    !  =    null )     {", "boolean   wasInterrupted    =    Thread . interrupted (  )  ;", "try    {", "consumer . close (  )  ;", "}    catch    ( JMSException   ex )     {", ". logger . trace (  \" Could   not   close   JMS   MessageConsumer \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . trace (  \" Unexpected   exception   on   closing   JMS   MessageConsumer \"  ,    ex )  ;", "}    finally    {", "if    ( wasInterrupted )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["closeMessageConsumer"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( producer    !  =    null )     {", "try    {", "producer . close (  )  ;", "}    catch    ( JMSException   ex )     {", ". logger . trace (  \" Could   not   close   JMS   MessageProducer \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . trace (  \" Unexpected   exception   on   closing   JMS   MessageProducer \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeMessageProducer"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( browser    !  =    null )     {", "try    {", "browser . close (  )  ;", "}    catch    ( JMSException   ex )     {", ". logger . trace (  \" Could   not   close   JMS   QueueBrowser \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . trace (  \" Unexpected   exception   on   closing   JMS   QueueBrowser \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeQueueBrowser"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( requestor    !  =    null )     {", "try    {", "requestor . close (  )  ;", "}    catch    ( JMSException   ex )     {", ". logger . trace (  \" Could   not   close   JMS   QueueRequestor \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . trace (  \" Unexpected   exception   on   closing   JMS   QueueRequestor \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeQueueRequestor"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( session    !  =    null )     {", "try    {", "session . close (  )  ;", "}    catch    ( JMSException   ex )     {", ". logger . trace (  \" Could   not   close   JMS   Session \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . trace (  \" Unexpected   exception   on   closing   JMS   Session \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeSession"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( session ,     \" Session   must   not   be   null \"  )  ;", "try    {", "session . commit (  )  ;", "}    catch    ( javax    |    javax   ex )     {", "}", "}", "METHOD_END"], "methodName": ["commitIfNecessary"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( ex ,     \" JMSException   must   not   be   null \"  )  ;", "if    ( ex   instanceof   IllegalStateException )     {", "return   new   IllegalStateException (  (  ( IllegalStateException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   InvalidClientIDException )     {", "return   new   InvalidClientIDException (  (  ( InvalidClientIDException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   InvalidDestinationException )     {", "return   new   InvalidDestinationException (  (  ( InvalidDestinationException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   InvalidSelectorException )     {", "return   new   InvalidSelectorException (  (  ( InvalidSelectorException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   JMSSecurityException )     {", "return   new   JmsSecurityException (  (  ( JMSSecurityException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   MessageEOFException )     {", "return   new   MessageEOFException (  (  ( MessageEOFException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   MessageFormatException )     {", "return   new   MessageFormatException (  (  ( MessageFormatException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   MessageNotReadableException )     {", "return   new   MessageNotReadableException (  (  ( MessageNotReadableException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   MessageNotWriteableException )     {", "return   new   MessageNotWriteableException (  (  ( MessageNotWriteableException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   ResourceAllocationException )     {", "return   new   ResourceAllocationException (  (  ( ResourceAllocationException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   TransactionInProgressException )     {", "return   new   TransactionInProgressException (  (  ( TransactionInProgressException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   TransactionRolledBackException )     {", "return   new   TransactionRolledBackException (  (  ( TransactionRolledBackException )     ( ex )  )  )  ;", "}", "return   new   UncategorizedJmsException ( ex )  ;", "}", "METHOD_END"], "methodName": ["convertJmsAccessException"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( session ,     \" Session   must   not   be   null \"  )  ;", "try    {", "session . rollback (  )  ;", "}    catch    ( javax    |    javax   ex )     {", "}", "}", "METHOD_END"], "methodName": ["rollbackIfNecessary"], "fileName": "org.springframework.jms.support.JmsUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . deliveryMode ;", "}", "METHOD_END"], "methodName": ["getDeliveryMode"], "fileName": "org.springframework.jms.support.QosSettings"}, {"methodBody": ["METHOD_START", "{", "return   this . priority ;", "}", "METHOD_END"], "methodName": ["getPriority"], "fileName": "org.springframework.jms.support.QosSettings"}, {"methodBody": ["METHOD_START", "{", "return   this . timeToLive ;", "}", "METHOD_END"], "methodName": ["getTimeToLive"], "fileName": "org.springframework.jms.support.QosSettings"}, {"methodBody": ["METHOD_START", "{", "this . deliveryMode    =    deliveryMode ;", "}", "METHOD_END"], "methodName": ["setDeliveryMode"], "fileName": "org.springframework.jms.support.QosSettings"}, {"methodBody": ["METHOD_START", "{", "this . priority    =    priority ;", "}", "METHOD_END"], "methodName": ["setPriority"], "fileName": "org.springframework.jms.support.QosSettings"}, {"methodBody": ["METHOD_START", "{", "this . timeToLive    =    timeToLive ;", "}", "METHOD_END"], "methodName": ["setTimeToLive"], "fileName": "org.springframework.jms.support.QosSettings"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( JmsHeaders . REPLY _ TO ,     \" not - a - destination \"  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNull ( jmsMessage . getJMSReplyTo (  )  )  ;", "}", "METHOD_END"], "methodName": ["JmsReplyToIgnoredIfIncorrectType"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "jmsMessage . setStringProperty (  \" foo \"  ,     \" bar \"  )  ;", "Map < String ,    Object >    headers    =    mapper . tos ( jmsMessage )  ;", "assertNull ( headers . get ( headerId )  )  ;", "assertNotNull ( headers . get (  \" foo \"  )  )  ;", "assertEquals (  \" bar \"  ,    headers . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAttemptReadDisallowedPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    headers    =    mapper . toHeaders ( jmsMessage )  ;", "Object   headerValue    =    headers . get ( headerId )  ;", "if    ( value    =  =    null )     {", "assertNull ( headerValue )  ;", "} else    {", "assertNotNull ( headerValue )  ;", "assertEquals ( value . getClass (  )  ,    headerValue . getClass (  )  )  ;", "assertEquals ( value ,    headerValue )  ;", "}", "}", "METHOD_END"], "methodName": ["assertInboundHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   String   getJMSCorrelationID (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . CORRELATION _ ID )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedCorrelationIdPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   int   getJMSDeliveryMode (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . DELIVERY _ MODE )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedDeliveryModePropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   Destination   getJMSDestination (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . DESTINATION )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedDestinationPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   long   getJMSExpiration (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . EXPIRATION )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedExpirationPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   String   getJMSMessageID (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . MESSAGE _ ID )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedMessageIdPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   int   getJMSPriority (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . PRIORITY )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedPriorityPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   boolean   getJMSRedelivered (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . REDELIVERED )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedRedeliveredPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   Destination   getJMSReplyTo (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . REPLY _ TO )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedReplyToPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   long   getJMSTimestamp (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . TIMESTAMP )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedTimestampPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   String   getJMSType (  )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,    s . TYPE )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedTypePropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   Object   getObjectProperty ( St   name )    throws   JMSException    {", "if    ( name . equals (  \" fail \"  )  )     {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "} else    {", "return   super . getObjectProperty ( name )  ;", "}", "}", "}  ;", "jmsMessage . setBooleanProperty (  \" fail \"  ,    true )  ;", "assertAttemptReadDisallowedPropertyIsNotFatal ( jmsMessage ,     \" fail \"  )  ;", "}", "METHOD_END"], "methodName": ["attemptToReadDisallowedUserPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( JmsHeaders . CORRELATION _ ID ,     1  2  3  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   void   setJMSCorrelationID ( String   correlationId )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNull ( jmsMessage . getJMSCorrelationID (  )  )  ;", "assertNotNull ( jmsMessage . getStringProperty (  \" foo \"  )  )  ;", "assertEquals (  \" bar \"  ,    jmsMessage . getStringProperty (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["attemptToWriteDisallowedCorrelationIdNumberPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( JmsHeaders . CORRELATION _ ID ,     \" abc \"  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   void   setJMSCorrelationID ( String   correlationId )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNull ( jmsMessage . getJMSCorrelationID (  )  )  ;", "assertNotNull ( jmsMessage . getStringProperty (  \" foo \"  )  )  ;", "assertEquals (  \" bar \"  ,    jmsMessage . getStringProperty (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["attemptToWriteDisallowedCorrelationIdStringPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( JmsHeaders . REPLY _ TO ,    new   Destination (  )     {  }  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   void   setJMSReplyTo ( Destination   replyTo )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNull ( jmsMessage . getJMSReplyTo (  )  )  ;", "assertNotNull ( jmsMessage . getStringProperty (  \" foo \"  )  )  ;", "assertEquals (  \" bar \"  ,    jmsMessage . getStringProperty (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["attemptToWriteDisallowedReplyToPropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( JmsHeaders . TYPE ,     \" someType \"  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   void   setJMSType ( String   type )    throws   JMSException    {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "}  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNull ( jmsMessage . getJMSType (  )  )  ;", "assertNotNull ( jmsMessage . getStringProperty (  \" foo \"  )  )  ;", "assertEquals (  \" bar \"  ,    jmsMessage . getStringProperty (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["attemptToWriteDisallowedTypePropertyIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( CONTENT _ TYPE ,     \" foo \"  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "Object   value    =    jmsMessage . getObjectProperty (  . CONTENT _ TYPE _ PROPERTY )  ;", "assertNotNull ( value )  ;", "assertEquals (  \" foo \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["contentTypePropertyMappedFromHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setStringProperty (  \" content _ type \"  ,     \" foo \"  )  ;", "assertInbound ( jmsMessage ,    CONTENT _ TYPE ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["contentTypePropertyMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setJMSDestination ( destination )  ;", "assertInboundHeader ( jmsMessage ,    s . DESTINATION ,    destination )  ;", "}", "METHOD_END"], "methodName": ["destinationMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader (  \" foo \"  ,     1  2  3  )  . setHeader (  \" bad \"  ,     4  5  6  )  . setHeader (  \" bar \"  ,     7  8  9  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   void   setObjectProperty ( String   name ,    Object   value )    throws   JMSException    {", "if    ( name . equals (  \" bad \"  )  )     {", "throw   new   IllegalArgumentException (  \" illegal   property \"  )  ;", "}", "super . setObjectProperty ( name ,    value )  ;", "}", "}  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "Object   foo    =    jmsMessage . getObjectProperty (  \" foo \"  )  ;", "assertNotNull ( foo )  ;", "Object   bar    =    jmsMessage . getObjectProperty (  \" bar \"  )  ;", "assertNotNull ( bar )  ;", "Object   bad    =    jmsMessage . getObjectProperty (  \" bad \"  )  ;", "assertNull ( bad )  ;", "}", "METHOD_END"], "methodName": ["illegalArgumentExceptionIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "return   MessageBuilder . withPayload (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["initBuilder"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( JmsHeaders . CORRELATION _ ID ,    new   Date (  )  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNull ( jmsMessage . getJMSCorrelationID (  )  )  ;", "}", "METHOD_END"], "methodName": ["jmsCorrelationIdIgnoredIfIncorrectType"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "String   jmsCorrelationId    =     \" ABC -  1  2  3  \"  ;", "Message < String >    message    =    initBuilder (  )  . setHeader ( s . CORRELATION _ ID ,    jmsCorrelationId )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNotNull ( jmsMessage . getJMSCorrelationID (  )  )  ;", "assertEquals ( jmsCorrelationId ,    jmsMessage . getJMSCorrelationID (  )  )  ;", "}", "METHOD_END"], "methodName": ["jmsCorrelationIdMappedFromHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "String   correlationId    =     \" ABC -  1  2  3  \"  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setJMSCorrelationID ( correlationId )  ;", "assertInboundHeader ( jmsMessage ,    s . CORRELATION _ ID ,    correlationId )  ;", "}", "METHOD_END"], "methodName": ["jmsCorrelationIdMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( JmsHeaders . CORRELATION _ ID ,     1  2  3  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertEquals (  \"  1  2  3  \"  ,    jmsMessage . getJMSCorrelationID (  )  )  ;", "}", "METHOD_END"], "methodName": ["jmsCorrelationIdNumberConvertsToString"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "int   deliveryMode    =     1  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setJMSDeliveryMode ( deliveryMode )  ;", "assertInboundHeader ( jmsMessage ,    s . DELIVERY _ MODE ,    deliveryMode )  ;", "}", "METHOD_END"], "methodName": ["jmsDeliveryModeMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "long   expiration    =     1  0  0  0 L ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setJMSExpiration ( expiration )  ;", "assertInboundHeader ( jmsMessage ,    s . EXPIRATION ,    expiration )  ;", "}", "METHOD_END"], "methodName": ["jmsExpirationMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "String   messageId    =     \" ID : ABC -  1  2  3  \"  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setJMSMessageID ( messageId )  ;", "assertInboundHeader ( jmsMessage ,    s . MESSAGE _ ID ,    messageId )  ;", "}", "METHOD_END"], "methodName": ["jmsMessageIdMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "int   priority    =     8  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setJMSPriority ( priority )  ;", "assertInboundHeader ( jmsMessage ,    s . PRIORITY ,    priority )  ;", "}", "METHOD_END"], "methodName": ["jmsPriorityMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( JmsHeaders . DESTINATION ,    new   Destination (  )     {  }  )  . setHeader ( JmsHeaders . DELIVERY _ MODE ,    NON _ PERSISTENT )  . setHeader ( JmsHeaders . EXPIRATION ,     1  0  0  0 L )  . setHeader ( JmsHeaders . MESSAGE _ ID ,     \" abc -  1  2  3  \"  )  . setHeader ( JmsHeaders . PRIORITY ,     9  )  . setHeader ( JmsHeaders . REDELIVERED ,    true )  . setHeader ( JmsHeaders . TIMESTAMP ,    System . currentTimeMillis (  )  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNull ( jmsMessage . getJMSDestination (  )  )  ;", "assertEquals ( PERSISTENT ,    jmsMessage . getJMSDeliveryMode (  )  )  ;", "assertEquals (  0  ,    jmsMessage . getJMSExpiration (  )  )  ;", "assertNull ( jmsMessage . getJMSMessageID (  )  )  ;", "assertEquals ( Message ,    jmsMessage . getJMSPriority (  )  )  ;", "assertFalse ( jmsMessage . getJMSRedelivered (  )  )  ;", "assertEquals (  0  ,    jmsMessage . getJMSTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["jmsReadOnlyPropertiesNotMapped"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Destination   replyTo    =    new   Destination (  )     {  }  ;", "Message < String >    message    =    initBuilder (  )  . setHeader ( s . REPLY _ TO ,    replyTo )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNotNull ( jmsMessage . getJMSReplyTo (  )  )  ;", "assertSame ( replyTo ,    jmsMessage . getJMSReplyTo (  )  )  ;", "}", "METHOD_END"], "methodName": ["jmsReplyToMappedFromHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Destination   replyTo    =    new   Destination (  )     {  }  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setJMSReplyTo ( replyTo )  ;", "assertInboundHeader ( jmsMessage ,    s . REPLY _ TO ,    replyTo )  ;", "}", "METHOD_END"], "methodName": ["jmsReplyToMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "long   timestamp    =     1  2  3 L ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setJMSTimestamp ( timestamp )  ;", "assertInboundHeader ( jmsMessage ,    s . TIMESTAMP ,    timestamp )  ;", "}", "METHOD_END"], "methodName": ["jmsTimestampMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader ( JmsHeaders . TYPE ,     1  2  3  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNull ( jmsMessage . getJMSType (  )  )  ;", "}", "METHOD_END"], "methodName": ["jmsTypeIgnoredIfIncorrectType"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "String   jmsType    =     \" testing \"  ;", "Message < String >    message    =    initBuilder (  )  . setHeader ( s . TYPE ,    jmsType )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "assertNotNull ( jmsMessage . getJMSType (  )  )  ;", "assertEquals ( jmsType ,    jmsMessage . getJMSType (  )  )  ;", "}", "METHOD_END"], "methodName": ["jmsTypeMappedFromHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "String   type    =     \" testing \"  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setJMSType ( type )  ;", "assertInboundHeader ( jmsMessage ,    s . TYPE ,    type )  ;", "}", "METHOD_END"], "methodName": ["jmsTypeMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader (  \" foo \"  ,     1  2  3  )  . setHeader (  \" bad \"  ,     4  5  6  )  . setHeader (  \" bar \"  ,     7  8  9  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )     {", "@ Override", "public   void   setObjectProperty ( String   name ,    Object   value )    throws   JMSException    {", "if    ( name . equals (  \" bad \"  )  )     {", "throw   new   JMSException (  \" illegal   property \"  )  ;", "}", "super . setObjectProperty ( name ,    value )  ;", "}", "}  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "Object   foo    =    jmsMessage . getObjectProperty (  \" foo \"  )  ;", "assertNotNull ( foo )  ;", "Object   bar    =    jmsMessage . getObjectProperty (  \" bar \"  )  ;", "assertNotNull ( bar )  ;", "Object   bad    =    jmsMessage . getObjectProperty (  \" bad \"  )  ;", "assertNull ( bad )  ;", "}", "METHOD_END"], "methodName": ["propertyMappingExceptionIsNotFatal"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader (  \" foo \"  ,     1  2  3  )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "Object   value    =    jmsMessage . getObjectProperty (  \" foo \"  )  ;", "assertNotNull ( value )  ;", "assertEquals ( Integer . class ,    value . getClass (  )  )  ;", "assertEquals (  1  2  3  ,     (  ( Integer )     ( value )  )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["userDefinedPropertyMappedFromHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    initBuilder (  )  . setHeader (  \" foo \"  ,     1  2  3  )  . build (  )  ;", "mapper . setOutboundPrefix (  \" custom _  \"  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . fromHeaders ( message . getHeaders (  )  ,    jmsMessage )  ;", "Object   value    =    jmsMessage . getObjectProperty (  \" custom _ foo \"  )  ;", "assertNotNull ( value )  ;", "assertEquals ( Integer . class ,    value . getClass (  )  )  ;", "assertEquals (  1  2  3  ,     (  ( Integer )     ( value )  )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["userDefinedPropertyMappedFromHeaderWithCustomPrefix"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setIntProperty (  \" foo \"  ,     1  2  3  )  ;", "assertInbound ( jmsMessage ,     \" foo \"  ,     1  2  3  )  ;", "}", "METHOD_END"], "methodName": ["userDefinedPropertyMappedToHeader"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "jmsMessage . setIntProperty (  \" foo \"  ,     1  2  3  )  ;", "mapper . setInboundPrefix (  \" custom _  \"  )  ;", "assertInbound ( jmsMessage ,     \" custom _ foo \"  ,     1  2  3  )  ;", "}", "METHOD_END"], "methodName": ["userDefinedPropertyMappedToHeaderWithCustomPrefix"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Destination   destination    =    new   Destination (  )     {  }  ;", "Message < String >    message    =    initBuilder (  )  . set (  \" destination \"  ,    destination )  . build (  )  ;", "Message   jmsMessage    =    new   StubTextMessage (  )  ;", "mapper . froms ( message . gets (  )  ,    jmsMessage )  ;", "Object   value    =    jmsMessage . getObjectProperty (  \" destination \"  )  ;", "assertNull ( value )  ;", "}", "METHOD_END"], "methodName": ["userDefinedPropertyWithUnsupportedType"], "fileName": "org.springframework.jms.support.SimpleJmsHeaderMapperTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "BytesMessage   message    =    mock ( BytesMessage . class )  ;", "byte [  ]    content    =     \" test \"  . getBytes (  )  ;", "final   ByteArrayInputStream   byteArrayInputStream    =    new   ByteArrayInputStream ( content )  ;", "given ( session . createBytesMessage (  )  )  . willReturn ( message )  ;", "given ( message . getBodyLength (  )  )  . willReturn (  (  ( long )     ( content . length )  )  )  ;", "given ( message . readBytes ( any ( byte [  ]  . class )  )  )  . willAnswer ( new   Answer < Integer >  (  )     {", "@ Override", "public   Integer   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "return   byteArrayInputStream . read (  (  ( byte [  ]  )     ( invocation . getArguments (  )  [  0  ]  )  )  )  ;", "}", "}  )  ;", "converter    =    new    (  )  ;", "Message   msg    =    converter . toMessage ( content ,    session )  ;", "assertEquals ( content . length ,     (  ( byte [  ]  )     ( converter . fromMessage ( msg )  )  )  . length )  ;", "verify ( message )  . writeBytes ( content )  ;", "}", "METHOD_END"], "methodName": ["testByteArrayConversion"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message   message    =    mock ( Message . class )  ;", "converter    =    new    (  )  ;", "Object   msg    =    converter . fromMessage ( message )  ;", "assertSame ( message ,    msg )  ;", "}", "METHOD_END"], "methodName": ["testFromMessageSimplyReturnsMessageAsIsIfSuppliedWithMessage"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "MapMessage   message    =    mock ( MapMessage . class )  ;", "Map < String ,    String >    content    =    new   HashMap <  >  (  2  )  ;", "content . put (  \" key 1  \"  ,     \" value 1  \"  )  ;", "content . put (  \" key 2  \"  ,     \" value 2  \"  )  ;", "given ( session . createMapMessage (  )  )  . willReturn ( message )  ;", "given ( message . getMapNames (  )  )  . willReturn ( Collections . enumeration ( content . keySet (  )  )  )  ;", "given ( message . getObject (  \" key 1  \"  )  )  . willReturn (  \" value 1  \"  )  ;", "given ( message . getObject (  \" key 2  \"  )  )  . willReturn (  \" value 2  \"  )  ;", "converter    =    new    (  )  ;", "Message   msg    =    converter . toMessage ( content ,    session )  ;", "assertEquals ( content ,    converter . fromMessage ( msg )  )  ;", "verify ( message )  . setObject (  \" key 1  \"  ,     \" value 1  \"  )  ;", "verify ( message )  . setObject (  \" key 2  \"  ,     \" value 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMapConversion"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MapMessage   message    =    mock ( MapMessage . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createMapMessage (  )  )  . willReturn ( message )  ;", "Map < Object ,    String >    content    =    new   HashMap <  >  (  1  )  ;", "content . put ( null ,     \" value 1  \"  )  ;", "converter    =    new    (  )  ;", "try    {", "converter . toMessage ( content ,    session )  ;", "fail (  \" expected   MessageConversionException \"  )  ;", "}    catch    ( MessageConversionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testMapConversionWhereMapHasNNullForKey"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MapMessage   message    =    mock ( MapMessage . class )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createMapMessage (  )  )  . willReturn ( message )  ;", "Map < Integer ,    String >    content    =    new   HashMap <  >  (  1  )  ;", "content . put (  1  ,     \" value 1  \"  )  ;", "converter    =    new    (  )  ;", "try    {", "converter . toMessage ( content ,    session )  ;", "fail (  \" expected   MessageConversionException \"  )  ;", "}    catch    ( MessageConversionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testMapConversionWhereMapHasNonStringTypesForKeys"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "ObjectMessage   message    =    mock ( ObjectMessage . class )  ;", "Integer   content    =    new   Integer (  5  )  ;", "given ( session . createObjectMessage ( content )  )  . willReturn ( message )  ;", "given ( message . getObject (  )  )  . willReturn ( content )  ;", "converter    =    new    (  )  ;", "Message   msg    =    converter . toMessage ( content ,    session )  ;", "assertEquals ( content ,    converter . fromMessage ( msg )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializableConversion"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "TextMessage   message    =    mock ( TextMessage . class )  ;", "String   content    =     \" test \"  ;", "given ( session . createTextMessage ( content )  )  . willReturn ( message )  ;", "given ( message . getText (  )  )  . willReturn ( content )  ;", "converter    =    new    (  )  ;", "Message   msg    =    converter . toMessage ( content ,    session )  ;", "assertEquals ( content ,    converter . fromMessage ( msg )  )  ;", "}", "METHOD_END"], "methodName": ["testStringConversion"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "ObjectMessage   message    =    mock ( ObjectMessage . class )  ;", "converter    =    new    (  )  ;", "Message   msg    =    converter . toMessage ( message ,    session )  ;", "assertSame ( message ,    msg )  ;", "}", "METHOD_END"], "methodName": ["testToMessageSimplyReturnsMessageAsIsIfSuppliedWithMessage"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "new   SimpleMessageConverter (  )  . toMessage ( new   Object (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testToMessageThrowsExceptionIfGivenIncompatibleObjectToConvert"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "new   SimpleMessageConverter (  )  . toMessage ( null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testToMessageThrowsExceptionIfGivenNullObjectToConvert"], "fileName": "org.springframework.jms.support.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   encoding    =    this . encoding ;", "if    (  (  ( this . encodingPropertyName )     !  =    null )     &  &     ( message . propertyExists ( this . encodingPropertyName )  )  )     {", "encoding    =    message . getStringProperty ( this . encodingPropertyName )  ;", "}", "byte [  ]    bytes    =    new   byte [  (  ( int )     ( message . getBodyLength (  )  )  )  ]  ;", "message . readBytes ( bytes )  ;", "try    {", "String   body    =    new   String ( bytes ,    encoding )  ;", "return   this . objectMapper . readValue ( body ,    targetJavaType )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   sionException (  \" Cannot   convert   bytes   to   String \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["convertFromBytesMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "throw   new   IllegalArgumentException (  (  (  \" Unsupported   message   type    [  \"     +     ( message . getClass (  )  )  )     +     \"  ]  .    MappingJacksonMessageConverter   by   default   only   supports   TextMessages   and   BytesMessages .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertFromMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "String   body    =    message . getText (  )  ;", "return   this . objectMapper . readValue ( body ,    targetJavaType )  ;", "}", "METHOD_END"], "methodName": ["convertFromTextMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( message   instanceof   TextMessage )     {", "return   convertFromTextMessage (  (  ( TextMessage )     ( message )  )  ,    targetJavaType )  ;", "} else", "if    ( message   instanceof   BytesMessage )     {", "return   convertFromBytesMessage (  (  ( BytesMessage )     ( message )  )  ,    targetJavaType )  ;", "} else    {", "return   convertFromMessage ( message ,    targetJavaType )  ;", "}", "}", "METHOD_END"], "methodName": ["convertToObject"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes    =    annotation . value (  )  ;", "if    (  ( classes . length )     !  =     1  )     {", "throw   new   IllegalArgumentException (  (  \"  @ JsonView   only   ed   for   handler   methods   with   exactly    1    class   argument :     \"     +    conversionHint )  )  ;", "}", "return   classes [  0  ]  ;", "}", "METHOD_END"], "methodName": ["extractViewClass"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "String   typeId    =    message . getStringProperty ( this . typeIdPropertyName )  ;", "if    ( typeId    =  =    null )     {", "throw   new   sionException (  (  (  (  (  (  (  \" Could   not   find   type   id   property    [  \"     +     ( this . typeIdPropertyName )  )     +     \"  ]    on   message    [  \"  )     +     ( message . getJMSMessageID (  )  )  )     +     \"  ]    from   destination    [  \"  )     +     ( message . getJMSDestination (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "Class <  ?  >    mappedClass    =    this . idClassMappings . get ( typeId )  ;", "if    ( mappedClass    !  =    null )     {", "return   this . objectMapper . getTypeFactory (  )  . constructType ( mappedClass )  ;", "}", "try    {", "Class <  ?  >    typeClass    =    ClassUtils . forName ( typeId ,    this . beanClassLoader )  ;", "return   this . objectMapper . getTypeFactory (  )  . constructType ( typeClass )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   sionException (  (  (  \" Failed   to   resolve   type   id    [  \"     +    typeId )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getJavaTypeForMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( conversionHint   instanceof   MethodParameter )     {", "MethodParameter   methodParam    =     (  ( MethodParameter )     ( conversionHint )  )  ;", "JsonView   annotation    =    methodParam . getParameterAnnotation ( JsonView . class )  ;", "if    ( annotation    =  =    null )     {", "annotation    =    methodParam . getMethodAnnotation ( JsonView . class )  ;", "if    ( annotation    =  =    null )     {", "return   null ;", "}", "}", "return   extractViewClass ( annotation ,    conversionHint )  ;", "} else", "if    ( conversionHint   instanceof   JsonView )     {", "return   extractViewClass (  (  ( JsonView )     ( conversionHint )  )  ,    conversionHint )  ;", "} else", "if    ( conversionHint   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( conversionHint )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getSerializationView"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream (  1  0  2  4  )  ;", "OutputStreamWriter   writer    =    new   OutputStreamWriter ( bos ,    this . encoding )  ;", "objectWriter . writeValue ( writer ,    object )  ;", "Bytes   message    =    session . createBytes (  )  ;", "message . writeBytes ( bos . toByteArray (  )  )  ;", "if    (  ( this . encodingPropertyName )     !  =    null )     {", "message . setStringProperty ( this . encodingPropertyName ,    this . encoding )  ;", "}", "return   message ;", "}", "METHOD_END"], "methodName": ["mapToBytesMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "throw   new   IllegalArgumentException (  (  (  \" Unsupported   message   type    [  \"     +    targetType )     +     \"  ]  .    MappingJackson 2 MessageConverter   by   default   only   supports   TextMessages   and   BytesMessages .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mapToMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "StringWriter   writer    =    new   StringWriter (  )  ;", "objectWriter . writeValue ( writer ,    object )  ;", "return   session . createText ( writer . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["mapToTextMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . encoding    =    encoding ;", "}", "METHOD_END"], "methodName": ["setEncoding"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . encodingPropertyName    =    encodingPropertyName ;", "}", "METHOD_END"], "methodName": ["setEncodingPropertyName"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( objectMapper ,     \" ObjectMapper   must   not   be   null \"  )  ;", "this . objectMapper    =    objectMapper ;", "}", "METHOD_END"], "methodName": ["setObjectMapper"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( targetType ,     \" MessageType   must   not   be   null \"  )  ;", "this . targetType    =    targetType ;", "}", "METHOD_END"], "methodName": ["setTargetType"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . idClassMappings    =    new   HashMap <  >  (  )  ;", "typeIdMappings . forEach (  (    id ,    clazz )     -  >     {", "this . idClassMappings . put ( id ,    clazz )  ;", "this . classIdMappings . put ( clazz ,    id )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["setTypeIdMappings"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . typeIdPropertyName )     !  =    null )     {", "String   typeId    =    this . classIds . get ( object . getClass (  )  )  ;", "if    ( typeId    =  =    null )     {", "typeId    =    object . getClass (  )  . getName (  )  ;", "}", "message . setStringProperty ( this . typeIdPropertyName ,    typeId )  ;", "}", "}", "METHOD_END"], "methodName": ["setTypeIdOnMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . typeIdPropertyName    =    typeIdPropertyName ;", "}", "METHOD_END"], "methodName": ["setTypeIdPropertyName"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "Message   message ;", "try    {", "switch    ( this . targetType )     {", "case   TEXT    :", "message    =    mapToTextMessage ( object ,    session ,    objectWriter )  ;", "break ;", "case   BYTES    :", "message    =    mapToBytesMessage ( object ,    session ,    objectWriter )  ;", "break ;", "default    :", "message    =    mapToMessage ( object ,    session ,    objectWriter ,    this . targetType )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   sionException (  (  (  \" Could   not   map   JSON   object    [  \"     +    object )     +     \"  ]  \"  )  ,    ex )  ;", "}", "setTypeIdOnMessage ( object ,    message )  ;", "return   message ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( jsonView    !  =    null )     {", "return   to ( object ,    session ,    this . objectMapper . writerWithView ( jsonView )  )  ;", "} else    {", "return   to ( object ,    session ,    this . objectMapper . writer (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "BytesMessage   bytesMessageMock    =    mock ( BytesMessage . class )  ;", "Map < String ,    String >    unmarshalled    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "byte [  ]    bytes    =     \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  }  \"  . getBytes (  )  ;", "final   ByteArrayInputStream   byteStream    =    new   ByteArrayInputStream ( bytes )  ;", "given ( bytesMessageMock . getStringProperty (  \"  _  _ typeid _  _  \"  )  )  . willReturn ( Object . class . getName (  )  )  ;", "given ( bytesMessageMock . propertyExists (  \"  _  _ encoding _  _  \"  )  )  . willReturn ( false )  ;", "given ( bytesMessageMock . getBodyLength (  )  )  . willReturn ( new   Long ( bytes . length )  )  ;", "given ( bytesMessageMock . readBytes ( any ( byte [  ]  . class )  )  )  . willAnswer ( new   Answer < Integer >  (  )     {", "@ Override", "public   Integer   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "return   byteStream . read (  (  ( byte [  ]  )     ( invocation . getArguments (  )  [  0  ]  )  )  )  ;", "}", "}  )  ;", "Object   result    =    fromMessage ( bytesMessageMock )  ;", "assertEquals (  \" Invalid   result \"  ,    result ,    unmarshalled )  ;", "}", "METHOD_END"], "methodName": ["fromBytesMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", ". MyBean   unmarshalled    =    new    . MyBean (  \" bar \"  )  ;", "String   text    =     \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  }  \"  ;", "given ( textMessageMock . getStringProperty (  \"  _  _ typeid _  _  \"  )  )  . willReturn (  . MyBean . class . getName (  )  )  ;", "given ( textMessageMock . getText (  )  )  . willReturn ( text )  ;", ". MyBean   result    =     (  (  . MyBean )     ( converter . fromMessage ( textMessageMock )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,    result ,    unmarshalled )  ;", "}", "METHOD_END"], "methodName": ["fromTextMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", "Map < String ,    String >    unmarshalled    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "String   text    =     \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  }  \"  ;", "given ( textMessageMock . getStringProperty (  \"  _  _ typeid _  _  \"  )  )  . willReturn ( HashMap . class . getName (  )  )  ;", "given ( textMessageMock . getText (  )  )  . willReturn ( text )  ;", "Object   result    =    fromMessage ( textMessageMock )  ;", "assertEquals (  \" Invalid   result \"  ,    result ,    unmarshalled )  ;", "}", "METHOD_END"], "methodName": ["fromTextMessageAsMap"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", "Map < String ,    String >    unmarshalled    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "String   text    =     \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  }  \"  ;", "given ( textMessageMock . getStringProperty (  \"  _  _ typeid _  _  \"  )  )  . willReturn ( Object . class . getName (  )  )  ;", "given ( textMessageMock . getText (  )  )  . willReturn ( text )  ;", "Object   result    =    fromMessage ( textMessageMock )  ;", "assertEquals (  \" Invalid   result \"  ,    result ,    unmarshalled )  ;", "}", "METHOD_END"], "methodName": ["fromTextMessageAsObject"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", ". MyBean   unmarshalled    =    new    . MyBean (  \" bar \"  )  ;", "String   text    =     \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  ,     \\  \" unknownProperty \\  \"  :  \\  \" value \\  \"  }  \"  ;", "given ( textMessageMock . getStringProperty (  \"  _  _ typeid _  _  \"  )  )  . willReturn (  . MyBean . class . getName (  )  )  ;", "given ( textMessageMock . getText (  )  )  . willReturn ( text )  ;", ". MyBean   result    =     (  (  . MyBean )     ( converter . fromMessage ( textMessageMock )  )  )  ;", "assertEquals (  \" Invalid   result \"  ,    result ,    unmarshalled )  ;", "}", "METHOD_END"], "methodName": ["fromTextMessageWithUnknownProperty"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   new   MappingJackson 2 MessageConverterTests . MyAnotherBean (  )  ;", "}", "METHOD_END"], "methodName": ["invalid"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   new   MappingJackson 2 MessageConverterTests . MyAnotherBean (  )  ;", "}", "METHOD_END"], "methodName": ["none"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "sessionMock    =    mock ( Session . class )  ;", "converter    =    new    (  )  ;", "converter . setEncodingPropertyName (  \"  _  _ encoding _  _  \"  )  ;", "converter . setTypeIdPropertyName (  \"  _  _ typeid _  _  \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   new   MappingJackson 2 MessageConverterTests . MyAnotherBean (  )  ;", "}", "METHOD_END"], "methodName": ["summary"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter . setTargetType ( MessageType . TEXT )  ;", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", ". MyAnotherBean   bean    =    new    . MyAnotherBean (  \" test \"  ,     \" lengthy   description \"  )  ;", "given ( sessionMock . createTextMessage ( isA ( String . class )  )  )  . willReturn ( textMessageMock )  ;", "converter . toMessage ( bean ,    sessionMock ,    returnType )  ;", "verify ( textMessageMock )  . setStringProperty (  \"  _  _ typeid _  _  \"  ,     . MyAnotherBean . class . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testToTextMessageWithReturnType"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "BytesMessage   bytesMessageMock    =    mock ( BytesMessage . class )  ;", "Date   toBeMarshalled    =    new   Date (  )  ;", "given ( sessionMock . createBytesMessage (  )  )  . willReturn ( bytesMessageMock )  ;", "toMessage ( toBeMarshalled ,    sessionMock )  ;", "verify ( bytesMessageMock )  . setStringProperty (  \"  _  _ encoding _  _  \"  ,     \" UTF -  8  \"  )  ;", "verify ( bytesMessageMock )  . setStringProperty (  \"  _  _ typeid _  _  \"  ,    Date . class . getName (  )  )  ;", "verify ( bytesMessageMock )  . writeBytes ( isA ( byte [  ]  . class )  )  ;", "}", "METHOD_END"], "methodName": ["toBytesMessage"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter . setTargetType ( MessageType . TEXT )  ;", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", ". MyAnotherBean   bean    =    new    . MyAnotherBean (  \" test \"  ,     \" lengthy   description \"  )  ;", "given ( sessionMock . createTextMessage ( isA ( String . class )  )  )  . willReturn ( textMessageMock )  ;", "converter . toMessage ( bean ,    sessionMock ,     . Full . class )  ;", "verify ( textMessageMock )  . setStringProperty (  \"  _  _ typeid _  _  \"  ,     . MyAnotherBean . class . getName (  )  )  ;", "verify ( sessionMock )  . createTextMessage (  \"  {  \\  \" name \\  \"  :  \\  \" test \\  \"  ,  \\  \" description \\  \"  :  \\  \" lengthy   description \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["toTextMessageWithAnotherJsonViewClass"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter . setTargetType ( MessageType . TEXT )  ;", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", ". MyAnotherBean   bean    =    new    . MyAnotherBean (  \" test \"  ,     \" lengthy   description \"  )  ;", "given ( sessionMock . createTextMessage ( isA ( String . class )  )  )  . willReturn ( textMessageMock )  ;", "converter . toMessage ( bean ,    sessionMock ,     . Summary . class )  ;", "verify ( textMessageMock )  . setStringProperty (  \"  _  _ typeid _  _  \"  ,     . MyAnotherBean . class . getName (  )  )  ;", "verify ( sessionMock )  . createTextMessage (  \"  {  \\  \" name \\  \"  :  \\  \" test \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["toTextMessageWithJsonViewClass"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter . setTargetType ( MessageType . TEXT )  ;", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", "Map < String ,    String >    toBeMarshalled    =    new   HashMap <  >  (  )  ;", "toBeMarshalled . put (  \" foo \"  ,     \" bar \"  )  ;", "given ( sessionMock . createTextMessage ( isA ( String . class )  )  )  . willReturn ( textMessageMock )  ;", "converter . toMessage ( toBeMarshalled ,    sessionMock )  ;", "verify ( textMessageMock )  . setStringProperty (  \"  _  _ typeid _  _  \"  ,    HashMap . class . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["toTextMessageWithMap"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "testToTextMessageWithReturnType ( null )  ;", "verify ( sessionMock )  . createTextMessage (  \"  {  \\  \" name \\  \"  :  \\  \" test \\  \"  ,  \\  \" description \\  \"  :  \\  \" lengthy   description \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["toTextMessageWithNullReturnType"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter . setTargetType ( MessageType . TEXT )  ;", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", "Date   toBeMarshalled    =    new   Date (  )  ;", "given ( sessionMock . createTextMessage ( isA ( String . class )  )  )  . willReturn ( textMessageMock )  ;", "converter . toMessage ( toBeMarshalled ,    sessionMock )  ;", "verify ( textMessageMock )  . setStringProperty (  \"  _  _ typeid _  _  \"  ,    Date . class . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["toTextMessageWithObject"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    this . getClass (  )  . getDeclaredMethod (  \" summary \"  )  ;", "MethodParameter   returnType    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "testToTextWithReturnType ( returnType )  ;", "verify ( sessionMock )  . createText (  \"  {  \\  \" name \\  \"  :  \\  \" test \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["toTextMessageWithReturnType"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    this . getClass (  )  . getDeclaredMethod (  \" invalid \"  )  ;", "MethodParameter   returnType    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "testToTextWithReturnType ( returnType )  ;", "}", "METHOD_END"], "methodName": ["toTextMessageWithReturnTypeAndMultipleJsonViews"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    this . getClass (  )  . getDeclaredMethod (  \" none \"  )  ;", "MethodParameter   returnType    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "testToTextWithReturnType ( returnType )  ;", "verify ( sessionMock )  . createText (  \"  {  \\  \" name \\  \"  :  \\  \" test \\  \"  ,  \\  \" description \\  \"  :  \\  \" lengthy   description \\  \"  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["toTextMessageWithReturnTypeAndNoJsonView"], "fileName": "org.springframework.jms.support.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream (  1  0  2  4  )  ;", "StreamResult   streamResult    =    new   StreamResult ( bos )  ;", "mer . marshal ( object ,    streamResult )  ;", "BytesMessage   message    =    session . createBytesMessage (  )  ;", "message . writeBytes ( bos . toByteArray (  )  )  ;", "return   message ;", "}", "METHOD_END"], "methodName": ["marshalToBytesMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "throw   new   IllegalArgumentException (  (  (  \" Unsupported   message   type    [  \"     +    targetType )     +     \"  ]  .    MarshallingMessageConverter   by   default   only   supports   TextMessages   and   BytesMessages .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["marshalToMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "StringWriter   writer    =    new   StringWriter (  )  ;", "Result   result    =    new   StreamResult ( writer )  ;", "mer . marshal ( object ,    result )  ;", "return   session . createTextMessage ( writer . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["marshalToTextMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( marshaller ,     \" Marshaller   must   not   be   null \"  )  ;", "this . marshaller    =    marshaller ;", "}", "METHOD_END"], "methodName": ["setMarshaller"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( targetType ,     \" MessageType   must   not   be   null \"  )  ;", "this . targetType    =    targetType ;", "}", "METHOD_END"], "methodName": ["setTargetType"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( unmarshaller ,     \" Unmarshaller   must   not   be   null \"  )  ;", "this . unmarshaller    =    unmarshaller ;", "}", "METHOD_END"], "methodName": ["setUnmarshaller"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  (  ( int )     ( message . getBodyLength (  )  )  )  ]  ;", "message . readBytes ( bytes )  ;", "ByteArrayInputStream   bis    =    new   ByteArrayInputStream ( bytes )  ;", "StreamSource   source    =    new   StreamSource ( bis )  ;", "return   unmer . unmarshal ( source )  ;", "}", "METHOD_END"], "methodName": ["unmarshalFromBytesMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "throw   new   IllegalArgumentException (  (  (  \" Unsupported   message   type    [  \"     +     ( message . getClass (  )  )  )     +     \"  ]  .    MarshallingMessageConverter   by   default   only   supports   TextMessages   and   BytesMessages .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["unmarshalFromMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Source   source    =    new   StreamSource ( new   StringReader ( message . getText (  )  )  )  ;", "return   unmer . unmarshal ( source )  ;", "}", "METHOD_END"], "methodName": ["unmarshalFromTextMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "BytesMessage   bytesMessageMock    =    mock ( BytesMessage . class )  ;", "Object   unmarshalled    =    new   Object (  )  ;", "given ( bytesMessageMock . getBodyLength (  )  )  . willReturn (  1  0 L )  ;", "given ( bytesMessageMock . readBytes ( isA ( byte [  ]  . class )  )  )  . willReturn (  0  )  ;", "given ( unmarshallerMock . unmarshal ( isA ( Source . class )  )  )  . willReturn ( unmarshalled )  ;", "Object   result    =    fromMessage ( bytesMessageMock )  ;", "assertEquals (  \" Invalid   result \"  ,    result ,    unmarshalled )  ;", "}", "METHOD_END"], "methodName": ["fromBytesMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", "Object   unmarshalled    =    new   Object (  )  ;", "String   text    =     \" foo \"  ;", "given ( textMessageMock . getText (  )  )  . willReturn ( text )  ;", "given ( unmarshallerMock . unmarshal ( isA ( Source . class )  )  )  . willReturn ( unmarshalled )  ;", "Object   result    =    fromMessage ( textMessageMock )  ;", "assertEquals (  \" Invalid   result \"  ,    result ,    unmarshalled )  ;", "}", "METHOD_END"], "methodName": ["fromTextMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "marshallerMock    =    mock ( Marshaller . class )  ;", "unmarshallerMock    =    mock ( Unmarshaller . class )  ;", "sessionMock    =    mock ( Session . class )  ;", "converter    =    new    ( marshallerMock ,    unmarshallerMock )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "BytesMessage   bytesMessageMock    =    mock ( BytesMessage . class )  ;", "Object   toBeMarshalled    =    new   Object (  )  ;", "given ( sessionMock . createBytesMessage (  )  )  . willReturn ( bytesMessageMock )  ;", "toMessage ( toBeMarshalled ,    sessionMock )  ;", "verify ( marshallerMock )  . marshal ( eq ( toBeMarshalled )  ,    isA ( Result . class )  )  ;", "verify ( bytesMessageMock )  . writeBytes ( isA ( byte [  ]  . class )  )  ;", "}", "METHOD_END"], "methodName": ["toBytesMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "converter . setTargetType ( MessageType . TEXT )  ;", "TextMessage   textMessageMock    =    mock ( TextMessage . class )  ;", "Object   toBeMarshalled    =    new   Object (  )  ;", "given ( sessionMock . createTextMessage ( isA ( String . class )  )  )  . willReturn ( textMessageMock )  ;", "converter . toMessage ( toBeMarshalled ,    sessionMock )  ;", "verify ( marshallerMock )  . marshal ( eq ( toBeMarshalled )  ,    isA ( Result . class )  )  ;", "}", "METHOD_END"], "methodName": ["toTextMessage"], "fileName": "org.springframework.jms.support.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . payloadConverter . toMessage ( payload ,    session )  ;", "}", "METHOD_END"], "methodName": ["createMessageForPayload"], "fileName": "org.springframework.jms.support.converter.MessagingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . headerMapper . toHeaders ( message )  ;", "}", "METHOD_END"], "methodName": ["extractHeaders"], "fileName": "org.springframework.jms.support.converter.MessagingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . payloadConverter . fromMessage ( message )  ;", "}", "METHOD_END"], "methodName": ["extractPayload"], "fileName": "org.springframework.jms.support.converter.MessagingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . headerMapper    =    headerMapper ;", "}", "METHOD_END"], "methodName": ["setHeaderMapper"], "fileName": "org.springframework.jms.support.converter.MessagingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . payloadConverter    =    payloadConverter ;", "}", "METHOD_END"], "methodName": ["setPayloadConverter"], "fileName": "org.springframework.jms.support.converter.MessagingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "TextMessage   jmsMsg    =    new   StubTextMessage (  \"  1  2  2  4  \"  )  ;", "this . converter . setPayloadConverter ( new    . TestMessageConverter (  )  )  ;", "Message <  ?  >    msg    =     (  ( Message <  ?  >  )     ( this . converter . fromMessage ( jmsMsg )  )  )  ;", "assertEquals (  1  2  2  4 L ,    msg . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["customPayloadConverter"], "fileName": "org.springframework.jms.support.converter.MessagingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "thistoMessage ( new   Object (  )  ,    mock ( Session . class )  )  ;", "}", "METHOD_END"], "methodName": ["onlyHandlesMessage"], "fileName": "org.springframework.jms.support.converter.MessagingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "Serializable   payload    =    mock ( Serializable . class )  ;", "ObjectMessage   jmsMessage    =    mock ( ObjectMessage . class )  ;", "given ( session . createObjectMessage ( payload )  )  . willReturn ( jmsMessage )  ;", "thistoMessage ( MessageBuilder . withPayload ( payload )  . build (  )  ,    session )  ;", "verify ( session )  . createObjectMessage ( payload )  ;", "}", "METHOD_END"], "methodName": ["simpleObject"], "fileName": "org.springframework.jms.support.converter.MessagingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "BytesMessage   message    =    session . createBytesMessage (  )  ;", "message . writeBytes ( bytes )  ;", "return   message ;", "}", "METHOD_END"], "methodName": ["createMessageForByteArray"], "fileName": "org.springframework.jms.support.converter.SimpleMessageConverter"}, {"methodBody": ["METHOD_START", "{", "MapMessage   message    =    session . createMapMessage (  )  ;", "for    ( Map . Entry <  ?  ,     ?  >    entry    :    map . entrySet (  )  )     {", "Object   key    =    entry . getKey (  )  ;", "if    (  !  ( key   instanceof   String )  )     {", "throw   new   sionException (  (  (  \" Cannot   convert   non - String   key   of   type    [  \"     +     ( ObjectUtils . nullSafeClassName ( key )  )  )     +     \"  ]    to   JMS   MapMessage   entry \"  )  )  ;", "}", "message . setObject (  (  ( String )     ( key )  )  ,    entry . getValue (  )  )  ;", "}", "return   message ;", "}", "METHOD_END"], "methodName": ["createMessageForMap"], "fileName": "org.springframework.jms.support.converter.SimpleMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   session . createObjectMessage ( object )  ;", "}", "METHOD_END"], "methodName": ["createMessageForSerializable"], "fileName": "org.springframework.jms.support.converter.SimpleMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   session . createTextMessage ( text )  ;", "}", "METHOD_END"], "methodName": ["createMessageForString"], "fileName": "org.springframework.jms.support.converter.SimpleMessageConverter"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  (  ( int )     ( message . getBodyLength (  )  )  )  ]  ;", "message . readBytes ( bytes )  ;", "return   bytes ;", "}", "METHOD_END"], "methodName": ["extractByteArrayFromMessage"], "fileName": "org.springframework.jms.support.converter.SimpleMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "Enumeration < String >    en    =    m . getMapNames (  )  ;", "while    ( en . hasMoreElements (  )  )     {", "String   key    =    en . nextElement (  )  ;", "map . put ( key ,    m . getObject ( key )  )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["extractMapFromMessage"], "fileName": "org.springframework.jms.support.converter.SimpleMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   message . getObject (  )  ;", "}", "METHOD_END"], "methodName": ["extractSerializableFromMessage"], "fileName": "org.springframework.jms.support.converter.SimpleMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   message . getText (  )  ;", "}", "METHOD_END"], "methodName": ["extractStringFromMessage"], "fileName": "org.springframework.jms.support.converter.SimpleMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   session . createQueue ( queueName )  ;", "}", "METHOD_END"], "methodName": ["resolveQueue"], "fileName": "org.springframework.jms.support.destination.DynamicDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "return   session . createTopic ( topicName )  ;", "}", "METHOD_END"], "methodName": ["resolveTopic"], "fileName": "org.springframework.jms.support.destination.DynamicDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "Queue   expectedDestination    =    new   StubQueue (  )  ;", "Session   session    =    mock ( QueueSession . class )  ;", "given ( session . createQueue (  . DESTINATION _ NAME )  )  . willReturn ( expectedDestination )  ;", ". testResolveDestination ( session ,    expectedDestination ,    false )  ;", "}", "METHOD_END"], "methodName": ["resolveWithPointToPointQueueSession"], "fileName": "org.springframework.jms.support.destination.DynamicDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "Queue   expectedDestination    =    new   StubQueue (  )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createQueue (  . DESTINATION _ NAME )  )  . willReturn ( expectedDestination )  ;", ". testResolveDestination ( session ,    expectedDestination ,    false )  ;", "}", "METHOD_END"], "methodName": ["resolveWithPointToPointVanillaSession"], "fileName": "org.springframework.jms.support.destination.DynamicDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "Topic   expectedDestination    =    new   StubTopic (  )  ;", "TopicSession   session    =    mock ( TopicSession . class )  ;", "given ( session . createTopic (  . DESTINATION _ NAME )  )  . willReturn ( expectedDestination )  ;", ". testResolveDestination ( session ,    expectedDestination ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveWithPubSubTopicSession"], "fileName": "org.springframework.jms.support.destination.DynamicDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "Topic   expectedDestination    =    new   StubTopic (  )  ;", "Session   session    =    mock ( Session . class )  ;", "given ( session . createTopic (  . DESTINATION _ NAME )  )  . willReturn ( expectedDestination )  ;", ". testResolveDestination ( session ,    expectedDestination ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolveWithPubSubVanillaSession"], "fileName": "org.springframework.jms.support.destination.DynamicDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "DynamicDestinationResolver   resolver    =    new   DynamicDestinationResolver (  )  ;", "Destination   destination    =    resolver . resolveDestinationName ( session ,     . DESTINATION _ NAME ,    isPubSub )  ;", "assertNotNull ( destination )  ;", "assertSame ( expectedDestination ,    destination )  ;", "}", "METHOD_END"], "methodName": ["testResolveDestination"], "fileName": "org.springframework.jms.support.destination.DynamicDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationResolver ;", "}", "METHOD_END"], "methodName": ["getDestinationResolver"], "fileName": "org.springframework.jms.support.destination.JmsDestinationAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . pubSubDomain ;", "}", "METHOD_END"], "methodName": ["isPubSubDomain"], "fileName": "org.springframework.jms.support.destination.JmsDestinationAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( timeout    >     0  )     {", "return   consumer . receive ( timeout )  ;", "} else", "if    ( timeout    <     0  )     {", "return   consumer . receiveNoWait (  )  ;", "} else    {", "return   consumer . receive (  )  ;", "}", "}", "METHOD_END"], "methodName": ["receiveFromConsumer"], "fileName": "org.springframework.jms.support.destination.JmsDestinationAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getDestinationResolver (  )  . resolveDestinationName ( session ,    destinationName ,    isPubSubDomain (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveDestinationName"], "fileName": "org.springframework.jms.support.destination.JmsDestinationAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNullResolver ,     \" Resolver '    must   not   be   null \"  )  ;", "thisResolver    = Resolver ;", "}", "METHOD_END"], "methodName": ["setDestinationResolver"], "fileName": "org.springframework.jms.support.destination.JmsDestinationAccessor"}, {"methodBody": ["METHOD_START", "{", "this . pubSubDomain    =    pubSubDomain ;", "}", "METHOD_END"], "methodName": ["setPubSubDomain"], "fileName": "org.springframework.jms.support.destination.JmsDestinationAccessor"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "try    {", "JmsDestinationAccessor   accessor    =    new    . StubJmsDestinationAccessor (  )  ;", "accessor . setConnectionFactory ( connectionFactory )  ;", "accessor . setDestinationResolver ( null )  ;", "accessor . afterPropertiesSet (  )  ;", "fail (  \" expected   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testChokesIfDestinationResolverIsetToNullExplcitly"], "fileName": "org.springframework.jms.support.destination.JmsDestinationAccessorTests"}, {"methodBody": ["METHOD_START", "{", "JmsDestinationAccessor   accessor    =    new   JmsDestinationAccessorTests . StubJmsDestinationAccessor (  )  ;", "assertFalse (  (  \" The    [ pubSubDomain ]    property   of   JmsDestinationAccessor   must   default   to    \"     +     (  \" false    ( i . e .    Queues   are   used   by   default )  .    Change   this   test    ( and   the    \"     +     \" attendant   Javadoc )    if   you   have   changed   the   default .  \"  )  )  ,    accessor . isPubSubDomain (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSessionTransactedModeReallyDoesDefaultToFalse"], "fileName": "org.springframework.jms.support.destination.JmsDestinationAccessorTests"}, {"methodBody": ["METHOD_START", "{", "this . cache    =    cache ;", "}", "METHOD_END"], "methodName": ["setCache"], "fileName": "org.springframework.jms.support.destination.JndiDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "this . dynamicDestinationResolver    =    dynamicDestinationResolver ;", "}", "METHOD_END"], "methodName": ["setDynamicDestinationResolver"], "fileName": "org.springframework.jms.support.destination.JndiDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "this . fallbackToDynamicDestination    =    fallbackToDynamicDestination ;", "}", "METHOD_END"], "methodName": ["setFallbackToDynamicDestination"], "fileName": "org.springframework.jms.support.destination.JndiDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetClass    =    Queue . class ;", "if    ( pubSubDomain )     {", "targetClass    =    Topic . class ;", "}", "if    (  !  ( targetClass . isInstance ( destination )  )  )     {", "throw   new   utionException (  (  (  (  (  \" Destination    [  \"     +    destinationName )     +     \"  ]    is   not   of   expected   type    [  \"  )     +     ( targetClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateDestination"], "fileName": "org.springframework.jms.support.destination.JndiDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "DestinationResolver   dynamicResolver    =    mock ( DestinationResolver . class )  ;", "given ( dynamicResolver . resolveDestinationName ( session ,     . DESTINATION _ NAME ,    true )  )  . willReturn (  . DESTINATION )  ;", "JndiDestinationResolver   resolver    =    new   JndiDestinationResolver (  )     {", "@ Override", "protected    < T >    T   lookup ( String   jndiName ,    Class < T >    requiredClass )    throws   NamingException    {", "throw   new   NamingException (  )  ;", "}", "}  ;", "resolver . setFallbackToDynamicDestination ( true )  ;", "resolver . setDynamicDestinationResolver ( dynamicResolver )  ;", "Destination   destination    =    resolver . resolveDestinationName ( session ,     . DESTINATION _ NAME ,    true )  ;", "assertNotNull ( destination )  ;", "assertSame (  . DESTINATION ,    destination )  ;", "}", "METHOD_END"], "methodName": ["testDelegatesToFallbackIfNotResolvedInJndi"], "fileName": "org.springframework.jms.support.destination.JndiDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "final   Session   session    =    mock ( Session . class )  ;", "DestinationResolver   dynamicResolver    =    mock ( DestinationResolver . class )  ;", "final   JndiDestinationResolver   resolver    =    new   JndiDestinationResolver (  )     {", "@ Override", "protected    < T >    T   lookup ( String   jndiName ,    Class < T >    requiredClass )    throws   NamingException    {", "throw   new   NamingException (  )  ;", "}", "}  ;", "resolver . setDynamicDestinationResolver ( dynamicResolver )  ;", "try    {", "resolver . resolveDestinationName ( session ,     . DESTINATION _ NAME ,    true )  ;", "fail (  \" expected   DestinationResolutionException \"  )  ;", "}    catch    ( DestinationResolutionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testDoesNotDelegateToFallbackIfNotResolvedInJndi"], "fileName": "org.springframework.jms.support.destination.JndiDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", ". CountingCannedJndiDestinationResolver   resolver    =    new    . CountingCannedJndiDestinationResolver (  )  ;", "resolver . setCache ( false )  ;", "Destination   destination    =    resolver . resolveDestinationName ( session ,     . DESTINATION _ NAME ,    true )  ;", "assertNotNull ( destination )  ;", "assertSame (  . DESTINATION ,    destination )  ;", "assertEquals (  1  ,    resolver . getCallCount (  )  )  ;", "destination    =    resolver . resolveDestinationName ( session ,     . DESTINATION _ NAME ,    true )  ;", "assertNotNull ( destination )  ;", "assertSame (  . DESTINATION ,    destination )  ;", "assertEquals (  2  ,    resolver . getCallCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotUseCacheIfCachingIsTurnedOff"], "fileName": "org.springframework.jms.support.destination.JndiDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "Session   session    =    mock ( Session . class )  ;", "JndiDestinationResolver   resolver    =    new    . OneTimeLookupJndiDestinationResolver (  )  ;", "Destination   destination    =    resolver . resolveDestinationName ( session ,     . DESTINATION _ NAME ,    true )  ;", "assertNotNull ( destination )  ;", "assertSame (  . DESTINATION ,    destination )  ;", "}", "METHOD_END"], "methodName": ["testHitsCacheSecondTimeThrough"], "fileName": "org.springframework.jms.support.destination.JndiDestinationResolverTests"}]