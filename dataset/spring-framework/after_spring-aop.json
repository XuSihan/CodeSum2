[{"methodBody": ["METHOD_START", "{", "return   TrueClassFilter . INSTANCE ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.springframework.aop.TrueClassFilter"}, {"methodBody": ["METHOD_START", "{", "return   TrueMethodMatcher . INSTANCE ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.springframework.aop.TrueMethodMatcher"}, {"methodBody": ["METHOD_START", "{", "return   TruePointcut . INSTANCE ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.springframework.aop.TruePointcut"}, {"methodBody": ["METHOD_START", "{", "calculateArgumentBindings (  )  ;", "Object [  ]    aInvocationArgs    =    new   Object [ this . parameterTypes . length ]  ;", "int   numBound    =     0  ;", "if    (  ( this . joinPointArgumentIndex )     !  =     (  -  1  )  )     {", "aInvocationArgs [ this . joinPointArgumentIndex ]     =    jp ;", "numBound +  +  ;", "} else", "if    (  ( this . joinPointStaticPartArgumentIndex )     !  =     (  -  1  )  )     {", "aInvocationArgs [ this . joinPointStaticPartArgumentIndex ]     =    jp . getStaticPart (  )  ;", "numBound +  +  ;", "}", "if    (  !  ( CollectionUtils . isEmpty ( this . argumentBindings )  )  )     {", "if    ( jpMatch    !  =    null )     {", "PointcutParameter [  ]    parameterBindings    =    jpMatch . getParameterBindings (  )  ;", "for    ( PointcutParameter   parameter    :    parameterBindings )     {", "String   name    =    parameter . getName (  )  ;", "Integer   index    =    this . argumentBindings . get ( name )  ;", "aInvocationArgs [ index ]     =    parameter . getBinding (  )  ;", "numBound +  +  ;", "}", "}", "if    (  ( this . returningName )     !  =    null )     {", "Integer   index    =    this . argumentBindings . get ( this . returningName )  ;", "aInvocationArgs [ index ]     =    returnValue ;", "numBound +  +  ;", "}", "if    (  ( this . throwingName )     !  =    null )     {", "Integer   index    =    this . argumentBindings . get ( this . throwingName )  ;", "aInvocationArgs [ index ]     =    ex ;", "numBound +  +  ;", "}", "}", "if    ( numBound    !  =     ( this . parameterTypes . length )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Required   to   bind    \"     +     ( this . parameterTypes . length )  )     +     \"    arguments ,    but   only   bound    \"  )     +    numBound )     +     \"     ( JoinPointMatch    \"  )     +     ( jpMatch    =  =    null    ?     \" was   NOT \"     :     \" WAS \"  )  )     +     \"    bound   in   invocation )  \"  )  )  ;", "}", "return   aInvocationArgs ;", "}", "METHOD_END"], "methodName": ["argBinding"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . argumentNames )     =  =    null )     {", "this . argumentNames    =    createParameterNameDiscoverer (  )  . getParameterNames ( this . aMethod )  ;", "}", "if    (  ( this . argumentNames )     !  =    null )     {", "bindExplicitArguments ( numArgumentsExpectingToBind )  ;", "} else    {", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Advice   method    [  \"     +     ( this . aMethod . getName (  )  )  )     +     \"  ]     \"  )     +     \" requires    \"  )     +    numArgumentsExpectingToBind )     +     \"    arguments   to   be   bound   by   name ,    but    \"  )     +     \" the   argument   names   were   not   specified   and   could   not   be   discovered .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["bindArgumentsByName"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . argumentNames )     !  =    null )  ,     \" No   argument   names   available \"  )  ;", "this . argumentBindings    =    new   HashMap <  >  (  )  ;", "int   numExpectedArgumentNames    =    this . aMethod . getParameterCount (  )  ;", "if    (  ( this . argumentNames . length )     !  =    numExpectedArgumentNames )     {", "throw   new   IllegalStateException (  (  (  (  (  \" Expecting   to   find    \"     +    numExpectedArgumentNames )     +     \"    arguments   to   bind   by   name   in   advice ,    but   actually   found    \"  )     +     ( this . argumentNames . length )  )     +     \"    arguments .  \"  )  )  ;", "}", "int   argumentIndexOffset    =     ( this . parameterTypes . length )     -    numArgumentsLeftToBind ;", "for    ( int   i    =    argumentIndexOffset ;    i    <     ( this . argumentNames . length )  ;    i +  +  )     {", "this . argumentBindings . put ( this . argumentNames [ i ]  ,    i )  ;", "}", "if    (  ( this . returningName )     !  =    null )     {", "if    (  !  ( this . argumentBindings . containsKey ( this . returningName )  )  )     {", "throw   new   IllegalStateException (  (  (  \" Returning   argument   name    '  \"     +     ( this . returningName )  )     +     \"  '    was   not   bound   in   advice   arguments \"  )  )  ;", "} else    {", "Integer   index    =    this . argumentBindings . get ( this . returningName )  ;", "this . discoveredReturningType    =    this . aMethod . getParameterTypes (  )  [ index ]  ;", "this . discoveredReturningGenericType    =    this . aMethod . getGenericParameterTypes (  )  [ index ]  ;", "}", "}", "if    (  ( this . throwingName )     !  =    null )     {", "if    (  !  ( this . argumentBindings . containsKey ( this . throwingName )  )  )     {", "throw   new   IllegalStateException (  (  (  \" Throwing   argument   name    '  \"     +     ( this . throwingName )  )     +     \"  '    was   not   bound   in   advice   arguments \"  )  )  ;", "} else    {", "Integer   index    =    this . argumentBindings . get ( this . throwingName )  ;", "this . discoveredThrowingType    =    this . aMethod . getParameterTypes (  )  [ index ]  ;", "}", "}", "configurePointcutParameters ( this . argumentNames ,    argumentIndexOffset )  ;", "}", "METHOD_END"], "methodName": ["bindExplicitArguments"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "Pointcut   pc    =    getPointcut (  )  ;", "MethodMatcher   safeMethodMatcher    =    MethodMatchers . intersection ( new    . AdviceExcludingMethodMatcher ( this . aspectJAdviceMethod )  ,    pc . getMethodMatcher (  )  )  ;", "return   new   ComposablePointcut ( pc . getClassFilter (  )  ,    safeMethodMatcher )  ;", "}", "METHOD_END"], "methodName": ["buildSafePointcut"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . argumentsIntrospected )     |  |     (  ( this . parameterTypes . length )     =  =     0  )  )     {", "return ;", "}", "int   numUnboundArgs    =    this . parameterTypes . length ;", "Class <  ?  >  [  ]    parameterTypes    =    this . aMethod . getParameterTypes (  )  ;", "if    (  (  ( maybeBindJoinPoint ( parameterTypes [  0  ]  )  )     |  |     ( maybeBindProceedingJoinPoint ( parameterTypes [  0  ]  )  )  )     |  |     ( maybeBindJoinPointStaticPart ( parameterTypes [  0  ]  )  )  )     {", "numUnboundArgs -  -  ;", "}", "if    ( numUnboundArgs    >     0  )     {", "bindArgumentsByName ( numUnboundArgs )  ;", "}", "this . argumentsIntrospected    =    true ;", "}", "METHOD_END"], "methodName": ["calculateArgumentBindings"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "int   numParametersToRemove    =    argumentIndexOffset ;", "if    (  ( this . returningName )     !  =    null )     {", "numParametersToRemove +  +  ;", "}", "if    (  ( this . throwingName )     !  =    null )     {", "numParametersToRemove +  +  ;", "}", "String [  ]    pointcutParameterNames    =    new   String [  ( argumentNames . length )     -    numParametersToRemove ]  ;", "Class <  ?  >  [  ]    pointcutParameterTypes    =    new   Class <  ?  >  [ pointcutParameterNames . length ]  ;", "Class <  ?  >  [  ]    methodParameterTypes    =    this . aMethod . getParameterTypes (  )  ;", "int   index    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( argumentNames . length )  ;    i +  +  )     {", "if    ( i    <    argumentIndexOffset )     {", "continue ;", "}", "if    (  ( argumentNames [ i ]  . equals ( this . returningName )  )     |  |     ( argumentNames [ i ]  . equals ( this . throwingName )  )  )     {", "continue ;", "}", "pointcutParameterNames [ index ]     =    argumentNames [ i ]  ;", "pointcutParameterTypes [ index ]     =    methodParameterTypes [ i ]  ;", "index +  +  ;", "}", "this . pointcut . setParameterNames ( pointcutParameterNames )  ;", "this . pointcut . setParameterTypes ( pointcutParameterTypes )  ;", "}", "METHOD_END"], "methodName": ["configurePointcutParameters"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "DefaultParameterNameDiscoverer   discoverer    =    new   DefaultParameterNameDiscoverer (  )  ;", "ParameterNameDiscoverer   adviceParameterNameDiscoverer    =    new   ParameterNameDiscoverer ( this . pointcut . getExpression (  )  )  ;", "adviceParameterNameDiscoverer . setReturningName ( this . returningName )  ;", "adviceParameterNameDiscoverer . setThrowingName ( this . throwingName )  ;", "adviceParameterNameDiscoverer . setRaiseExceptions ( true )  ;", "discoverer . addDiscoverer ( adviceParameterNameDiscoverer )  ;", "return   discoverer ;", "}", "METHOD_END"], "methodName": ["createParameterNameDiscoverer"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   mi    =    ExposeInvocationInterceptor . currentInvocation (  )  ;", "if    (  !  ( mi   instanceof   ProxyMethodInvocation )  )     {", "throw   new   IllegalStateException (  (  \" MethodInvocation   is   not   a   Spring   ProxyMethodInvocation :     \"     +    mi )  )  ;", "}", "ProxyMethodInvocation   pmi    =     (  ( ProxyMethodInvocation )     ( mi )  )  ;", "JoinPoint   jp    =     (  ( JoinPoint )     ( pmi . getUserAttribute (  . JOIN _ POINT _ KEY )  )  )  ;", "if    ( jp    =  =    null )     {", "jp    =    new   MethodInvocationProceedingJoinPoint ( pmi )  ;", "pmi . setUserAttribute (  . JOIN _ POINT _ KEY ,    jp )  ;", "}", "return   jp ;", "}", "METHOD_END"], "methodName": ["currentJoinPoint"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   this . aspectInstanceFactory . getAspectClassLoader (  )  ;", "}", "METHOD_END"], "methodName": ["getAspectClassLoader"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   this . aspectInstanceFactory ;", "}", "METHOD_END"], "methodName": ["getAspectInstanceFactory"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   this . aspectJAdviceMethod ;", "}", "METHOD_END"], "methodName": ["getAspectJAdviceMethod"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   this . discoveredReturningGenericType ;", "}", "METHOD_END"], "methodName": ["getDiscoveredReturningGenericType"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   this . discoveredReturningType ;", "}", "METHOD_END"], "methodName": ["getDiscoveredReturningType"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   this . discoveredThrowingType ;", "}", "METHOD_END"], "methodName": ["getDiscoveredThrowingType"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   AbstractAspectJAdvice . currentJoinPoint (  )  ;", "}", "METHOD_END"], "methodName": ["getJoinPoint"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   mi    =    ExposeInvocationInterceptor . currentInvocation (  )  ;", "if    (  !  ( mi   instanceof   ProxyMethodInvocation )  )     {", "throw   new   IllegalStateException (  (  \" MethodInvocation   is   not   a   S   ProxyMethodInvocation :     \"     +    mi )  )  ;", "}", "return   getJoinPointMatch (  (  ( ProxyMethodInvocation )     ( mi )  )  )  ;", "}", "METHOD_END"], "methodName": ["getJoinPointMatch"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "String   expression    =    this . pointcut . getExpression (  )  ;", "return   expression    !  =    null    ?     (  ( JoinPointMatch )     ( pmi . getUserAttribute ( expression )  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getJoinPointMatch"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "calculateArgumentBindings (  )  ;", "return   this . pointcut ;", "}", "METHOD_END"], "methodName": ["getPointcut"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   invokeAdviceMethodWithGivenArgs ( argBinding ( jp ,    jpMatch ,    returnValue ,    t )  )  ;", "}", "METHOD_END"], "methodName": ["invokeAdviceMethod"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   invokeAdviceMethodWithGivenArgs ( argBinding ( getJoinPoint (  )  ,    jpMatch ,    returnValue ,    ex )  )  ;", "}", "METHOD_END"], "methodName": ["invokeAdviceMethod"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    actualArgs    =    args ;", "if    (  ( this . aMethod . getParameterCount (  )  )     =  =     0  )     {", "actualArgs    =    null ;", "}", "try    {", "ReflectionUtils . makeAccessible ( this . aMethod )  ;", "return   this . aMethod . invoke ( this . aspectInstanceFactory . getAspectInstance (  )  ,    actualArgs )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   AopInvocationException (  (  (  (  (  \" Mismatch   on   arguments   to   advice   method    [  \"     +     ( this . aMethod )  )     +     \"  ]  ;    pointcut   expression    [  \"  )     +     ( this . pointcut . getPointcutExpression (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   ex . getTargetException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeAdviceMethodWithGivenArgs"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "char [  ]    chars    =    name . toCharArray (  )  ;", "if    (  !  ( Chaer . isJavaIdentifierStart ( chars [  0  ]  )  )  )     {", "return   false ;", "}", "for    ( int   i    =     1  ;    i    <     ( chars . length )  ;    i +  +  )     {", "if    (  !  ( Chaer . isJavaIdentifierPart ( chars [ i ]  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isVariableName"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( JoinPoint . class )     =  =    candidateParameterType )     {", "this . joinPointArgumentIndex    =     0  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["maybeBindJoinPoint"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( StaticPart . class )     =  =    candidateParameterType )     {", "this . joinPointStaticPartArgumentIndex    =     0  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["maybeBindJoinPointStaticPart"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ProceedingJoinPoint . class )     =  =    candidateParameterType )     {", "if    (  !  ( supportsProceedingJoinPoint (  )  )  )     {", "throw   new   IllegalArgumentException (  \" ProceedingJoinPoint   is   only   supported   for   around   a \"  )  ;", "}", "this . joinPointArgumentIndex    =     0  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["maybeBindProceedingJoinPoint"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "inputStream . defaultReadObject (  )  ;", "try    {", "this . aMethod    =    this . declaringClass . getMethod ( this . methodName ,    this . parameterTypes )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   IllegalStateException (  \" Failed   to   find   advice   method   on   deserialization \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "String [  ]    tokens    =    StringUtils . commaDelimitedListToStringArray ( argNames )  ;", "setArgumentNamesFromStringArray ( tokens )  ;", "}", "METHOD_END"], "methodName": ["setArgumentNames"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "this . argumentNames    =    new   String [ args . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( args . length )  ;    i +  +  )     {", "this . argumentNames [ i ]     =    StringUtils . trimWhitespace ( args [ i ]  )  ;", "if    (  !  ( isVariableName ( this . argumentNames [ i ]  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \"  ' argumentNames '    property   of      contains   an   argument   name    '  \"     +     ( this . argumentNames [ i ]  )  )     +     \"  '    that   is   not   a   valid   Java   identifier \"  )  )  ;", "}", "}", "if    (  ( this . argumentNames )     !  =    null )     {", "if    (  ( this . aspectJAdviceMethod . getParameterCount (  )  )     =  =     (  ( this . argumentNames . length )     +     1  )  )     {", "Class <  ?  >    firstArgType    =    this . aspectJAdviceMethod . getParameterTypes (  )  [  0  ]  ;", "if    (  (  ( firstArgType    =  =     ( JoinPoint . class )  )     |  |     ( firstArgType    =  =     ( ProceedingJoinPoint . class )  )  )     |  |     ( firstArgType    =  =     ( StaticPart . class )  )  )     {", "String [  ]    oldNames    =    this . argumentNames ;", "this . argumentNames    =    new   String [  ( oldNames . length )     +     1  ]  ;", "this . argumentNames [  0  ]     =     \" THIS _ JOIN _ POINT \"  ;", "System . arraycopy ( oldNames ,     0  ,    this . argumentNames ,     1  ,    oldNames . length )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["setArgumentNamesFromStringArray"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "this . aspectName    =    name ;", "}", "METHOD_END"], "methodName": ["setAspectName"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "this . declarationOrder    =    order ;", "}", "METHOD_END"], "methodName": ["setDeclarationOrder"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Only   afterReturning   advice   can   be   used   to   bind   a   return   value \"  )  ;", "}", "METHOD_END"], "methodName": ["setReturningName"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "if    ( isVariableName ( name )  )     {", "this . returningName    =    name ;", "} else    {", "try    {", "this . discoveredReturningType    =    ClassUtils . forName ( name ,    geClassLoader (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Returning   name    '  \"     +    name )     +     \"  '    is   neither   a   valid   argument   name   nor   the   fully - qualified    \"  )     +     \" name   of   a   Java   type   on   the   classpath .    Root   cause :     \"  )     +    ex )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setReturningNameNoCheck"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Only   afterThrowing   advice   can   be   used   to   bind   a   thrown   exception \"  )  ;", "}", "METHOD_END"], "methodName": ["setThrowingName"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "if    ( isVariableName ( name )  )     {", "this . throwingName    =    name ;", "} else    {", "try    {", "this . discoveredThrowingType    =    ClassUtils . forName ( name ,    geClassLoader (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Throwing   name    '  \"     +    name )     +     \"  '    is   neither   a   valid   argument   name   nor   the   fully - qualified    \"  )     +     \" name   of   a   Java   type   on   the   classpath .    Root   cause :     \"  )     +    ex )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setThrowingNameNoCheck"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["supportsProceedingJoinPoint"], "fileName": "org.springframework.aop.aspectj.AbstractAspectJAdvice"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" pjpAndAnAnnotation \"  )  ,     \" execution (  *     *  (  .  .  )  )     &  &     @ annotation ( ann )  \"  ,    new   String [  ]  {     \" thisJoinPoint \"  ,     \" ann \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationBinding"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( this . parameterNameBindings . length )  ;    i +  +  )     {", "if    (  (  !  ( isUnbound ( i )  )  )     &  &     ( varName . equals ( this . parameterNameBindings [ i ]  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["alreadyBound"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( varNames . isEmpty (  )  )  )     {", "int   numAnnotationSlots    =    countNumberOfUnboundAnnotationArguments (  )  ;", "if    ( numAnnotationSlots    >     1  )     {", "throw   new    . AmbiguousBindingException (  (  (  (  (  \" Found    \"     +     ( varNames . size (  )  )  )     +     \"    potential   annotation   variable ( s )  ,    and    \"  )     +    numAnnotationSlots )     +     \"    potential   argument   slots \"  )  )  ;", "} else", "if    ( numAnnotationSlots    =  =     1  )     {", "if    (  ( varNames . size (  )  )     =  =     1  )     {", "findAndBind ( class ,    varNames . get (  0  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  \" Found    \"     +     ( varNames . size (  )  )  )     +     \"    candidate   annotation   binding   variables \"  )     +     \"    but   only   one   potential   argument   binding   slot \"  )  )  ;", "}", "} else    {", "}", "}", "}", "METHOD_END"], "methodName": ["bindAnnotationsFromVarNames"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "this . parameterNameBindings [ index ]     =    name ;", "( this . numberOfRemainingUnboundArguments )  -  -  ;", "}", "METHOD_END"], "methodName": ["bindParameterName"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( this . argumentTypes . length )  ;    i +  +  )     {", "if    (  ( isUnbound ( i )  )     &  &     ( isSubtypeOf ( Annotation . class ,    i )  )  )     {", "count +  +  ;", "}", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["countNumberOfUnboundAnnotationArguments"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( this . argumentTypes . length )  ;    i +  +  )     {", "if    (  ( isUnbound ( i )  )     &  &     ( this . argumentTypes [ i ]  . isPrimitive (  )  )  )     {", "count +  +  ;", "}", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["countNumberOfUnboundPrimitiveArguments"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( this . argumentTypes . length )  ;    i +  +  )     {", "if    (  ( isUnbound ( i )  )     &  &     ( isSubtypeOf ( argumentType ,    i )  )  )     {", "bind ( i ,    varName )  ;", "return ;", "}", "}", "throw   new   IllegalStateException (  (  (  \" Expected   to   find   an   unbound   argument   of   type    '  \"     +     ( argumentType . getName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findAndBind"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "int   numTokensConsumed    =     0  ;", "String   currentToken    =    tokens [ startIndex ]  ;", "int   bodyStart    =    currentToken . indexOf (  '  (  '  )  ;", "if    (  ( currentToken . charAt (  (  ( currentToken . length (  )  )     -     1  )  )  )     =  =     '  )  '  )     {", "return   new    . PointcutBody (  0  ,    currentToken . substring (  ( bodyStart    +     1  )  ,     (  ( currentToken . length (  )  )     -     1  )  )  )  ;", "} else    {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "if    (  ( bodyStart    >  =     0  )     &  &     ( bodyStart    !  =     (  ( currentToken . length (  )  )     -     1  )  )  )     {", "sb . append ( currentToken . substring (  ( bodyStart    +     1  )  )  )  ;", "sb . append (  \"     \"  )  ;", "}", "numTokensConsumed +  +  ;", "int   currentIndex    =    startIndex    +    numTokensConsumed ;", "while    ( currentIndex    <     ( tokens . length )  )     {", "if    ( tokens [ currentIndex ]  . equals (  \"  (  \"  )  )     {", "currentIndex +  +  ;", "continue ;", "}", "if    ( tokens [ currentIndex ]  . endsWith (  \"  )  \"  )  )     {", "sb . append ( tokens [ currentIndex ]  . substring (  0  ,     (  ( tokens [ currentIndex ]  . length (  )  )     -     1  )  )  )  ;", "return   new    . PointcutBody ( numTokensConsumed ,    sb . toString (  )  . trim (  )  )  ;", "}", "String   toAppend    =    tokens [ currentIndex ]  ;", "if    ( toAppend . startsWith (  \"  (  \"  )  )     {", "toAppend    =    toAppend . substring (  1  )  ;", "}", "sb . append ( toAppend )  ;", "sb . append (  \"     \"  )  ;", "currentIndex +  +  ;", "numTokensConsumed +  +  ;", "}", "}", "return   new    . PointcutBody ( numTokensConsumed ,    null )  ;", "}", "METHOD_END"], "methodName": ["getPointcutBody"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "return   supertype . isAssignableFrom ( this . argumentTypes [ argumentNumber ]  )  ;", "}", "METHOD_END"], "methodName": ["isSubtypeOf"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . parameterNameBindings [ i ]  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isUnbound"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "List < String >    varNames    =    new   ArrayList <  >  (  )  ;", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( this . pointcutExpression ,     \"     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( tokens . length )  ;    i +  +  )     {", "String   toMatch    =    tokens [ i ]  ;", "int   firstParenIndex    =    toMatch . indexOf (  '  (  '  )  ;", "if    ( firstParenIndex    !  =     (  -  1  )  )     {", "toMatch    =    toMatch . substring (  0  ,    firstParenIndex )  ;", "}", "if    (  . singleValuedAnnotationPcds . contains ( toMatch )  )     {", ". PointcutBody   body    =    getPointcutBody ( tokens ,    i )  ;", "i    +  =    body . numTokensConsumed ;", "String   varName    =    maybeExtractVariableName ( body . text )  ;", "if    ( varName    !  =    null )     {", "varNames . add ( varName )  ;", "}", "} else", "if    (  ( tokens [ i ]  . startsWith (  \"  @ args (  \"  )  )     |  |     ( tokens [ i ]  . equals (  \"  @ args \"  )  )  )     {", ". PointcutBody   body    =    getPointcutBody ( tokens ,    i )  ;", "i    +  =    body . numTokensConsumed ;", "maybeExtractVariableNamesFromArgs ( body . text ,    varNames )  ;", "}", "}", "bindAnnotationsFromVarNames ( varNames )  ;", "}", "METHOD_END"], "methodName": ["maybeBindAnnotationsFromPointcutExpression"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "int   numUnboundPrimitives    =    countNumberOfUnboundPrimitiveArguments (  )  ;", "if    ( numUnboundPrimitives    >     1  )     {", "throw   new    . AmbiguousBindingException (  (  (  \" Found    '  \"     +    numUnboundPrimitives )     +     \"  '    unbound   primitive   arguments   with   no   way   to   distinguish   between   them .  \"  )  )  ;", "}", "if    ( numUnboundPrimitives    =  =     1  )     {", "List < String >    varNames    =    new   ArrayList <  >  (  )  ;", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( this . pointcutExpression ,     \"     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( tokens . length )  ;    i +  +  )     {", "if    (  ( tokens [ i ]  . equals (  \" args \"  )  )     |  |     ( tokens [ i ]  . startsWith (  \" args (  \"  )  )  )     {", ". PointcutBody   body    =    getPointcutBody ( tokens ,    i )  ;", "i    +  =    body . numTokensConsumed ;", "maybeExtractVariableNamesFromArgs ( body . text ,    varNames )  ;", "}", "}", "if    (  ( varNames . size (  )  )     >     1  )     {", "throw   new    . AmbiguousBindingException (  (  (  \" Found    \"     +     ( varNames . size (  )  )  )     +     \"    candidate   variable   names   but   only   one   candidate   binding   slot   when   matching   primitive   args \"  )  )  ;", "} else", "if    (  ( varNames . size (  )  )     =  =     1  )     {", "for    ( int   i    =     0  ;    i    <     ( this . argumentTypes . length )  ;    i +  +  )     {", "if    (  ( isUnbound ( i )  )     &  &     ( this . argumentTypes [ i ]  . isPrimitive (  )  )  )     {", "bindParameterName ( i ,    varNames . get (  0  )  )  ;", "break ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["maybeBindPrimitiveArgsFromPointcutExpression"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . numberOfRemainingUnboundArguments )     >     1  )     {", "throw   new    . AmbiguousBindingException (  (  (  \" Still    \"     +     ( this . numberOfRemainingUnboundArguments )  )     +     \"    unbound   args   at   reference   pointcut   binding   stage ,    with   no   way   to   determine   between   them \"  )  )  ;", "}", "List < String >    varNames    =    new   ArrayList <  >  (  )  ;", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( this . pointcutExpression ,     \"     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( tokens . length )  ;    i +  +  )     {", "String   toMatch    =    tokens [ i ]  ;", "if    ( toMatch . startsWith (  \"  !  \"  )  )     {", "toMatch    =    toMatch . substring (  1  )  ;", "}", "int   firstParenIndex    =    toMatch . indexOf (  '  (  '  )  ;", "if    ( firstParenIndex    !  =     (  -  1  )  )     {", "toMatch    =    toMatch . substring (  0  ,    firstParenIndex )  ;", "} else    {", "if    (  ( tokens . length )     <     ( i    +     2  )  )     {", "continue ;", "} else    {", "String   nextToken    =    tokens [  ( i    +     1  )  ]  ;", "if    (  ( nextToken . charAt (  0  )  )     !  =     '  (  '  )     {", "continue ;", "}", "}", "}", ". PointcutBody   body    =    getPointcutBody ( tokens ,    i )  ;", "i    +  =    body . numTokensConsumed ;", "if    (  !  (  . nonReferencePointcutTokens . contains ( toMatch )  )  )     {", "String   varName    =    maybeExtractVariableName ( body . text )  ;", "if    ( varName    !  =    null )     {", "varNames . add ( varName )  ;", "}", "}", "}", "if    (  ( varNames . size (  )  )     >     1  )     {", "throw   new    . AmbiguousBindingException (  (  (  \" Found    \"     +     ( varNames . size (  )  )  )     +     \"    candidate   reference   pointcut   variables   but   only   one   unbound   argument   slot \"  )  )  ;", "} else", "if    (  ( varNames . size (  )  )     =  =     1  )     {", "for    ( int   j    =     0  ;    j    <     ( this . parameterNameBindings . length )  ;    j +  +  )     {", "if    ( isUnbound ( j )  )     {", "bindParameterName ( j ,    varNames . get (  0  )  )  ;", "break ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["maybeBindReferencePointcutParameter"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . numberOfRemainingUnboundArguments )     =  =     0  )     {", "throw   new   IllegalStateException (  \" Algorithm   assumes   that   there   must   be   at   least   one   unbound   parameter   on   entry   to   this   method \"  )  ;", "}", "if    (  ( this . returningName )     !  =    null )     {", "if    (  ( this . numberOfRemainingUnboundArguments )     >     1  )     {", "throw   new    . AmbiguousBindingException (  (  (  (  (  \" Binding   of   returning   parameter    '  \"     +     ( this . returningName )  )     +     \"  '    is   ambiguous ,    there   are    \"  )     +     ( this . numberOfRemainingUnboundArguments )  )     +     \"    candidates .  \"  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( this . parameterNameBindings . length )  ;    i +  +  )     {", "if    (  ( this . parameterNameBindings [ i ]  )     =  =    null )     {", "bindParameterName ( i ,    this . returningName )  ;", "break ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["maybeBindReturningVariable"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . argumentTypes [  0  ]  )     =  =     ( JoinPoint . class )  )     |  |     (  ( this . argumentTypes [  0  ]  )     =  =     ( ProceedingJoinPoint . class )  )  )     {", "bindParameterName (  0  ,     . THIS _ JOIN _ POINT )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["maybeBindThisJoinPoint"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . argumentTypes [  0  ]  )     =  =     ( StaticPart . class )  )     {", "bindParameterName (  0  ,     . THIS _ JOIN _ POINT _ STATIC _ PART )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeBindThisJoinPointStaticPart"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . numberOfRemainingUnboundArguments )     >     1  )     {", "throw   new    . AmbiguousBindingException (  (  (  \" Still    \"     +     ( this . numberOfRemainingUnboundArguments )  )     +     \"    unbound   args   at   this (  )  , target (  )  , args (  )    binding   stage ,    with   no   way   to   determine   between   them \"  )  )  ;", "}", "List < String >    varNames    =    new   ArrayList <  >  (  )  ;", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( this . pointcutExpression ,     \"     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( tokens . length )  ;    i +  +  )     {", "if    (  (  (  ( tokens [ i ]  . equals (  \" this \"  )  )     |  |     ( tokens [ i ]  . startsWith (  \" this (  \"  )  )  )     |  |     ( tokens [ i ]  . equals (  \" target \"  )  )  )     |  |     ( tokens [ i ]  . startsWith (  \" target (  \"  )  )  )     {", ". PointcutBody   body    =    getPointcutBody ( tokens ,    i )  ;", "i    +  =    body . numTokensConsumed ;", "String   varName    =    maybeExtractVariableName ( body . text )  ;", "if    ( varName    !  =    null )     {", "varNames . add ( varName )  ;", "}", "} else", "if    (  ( tokens [ i ]  . equals (  \" args \"  )  )     |  |     ( tokens [ i ]  . startsWith (  \" args (  \"  )  )  )     {", ". PointcutBody   body    =    getPointcutBody ( tokens ,    i )  ;", "i    +  =    body . numTokensConsumed ;", "List < String >    candidateVarNames    =    new   ArrayList <  >  (  )  ;", "maybeExtractVariableNamesFromArgs ( body . text ,    candidateVarNames )  ;", "for    ( String   varName    :    candidateVarNames )     {", "if    (  !  ( alreadyBound ( varName )  )  )     {", "varNames . add ( varName )  ;", "}", "}", "}", "}", "if    (  ( varNames . size (  )  )     >     1  )     {", "throw   new    . AmbiguousBindingException (  (  (  \" Found    \"     +     ( varNames . size (  )  )  )     +     \"    candidate   this (  )  ,    target (  )    or   args (  )    variables   but   only   one   unbound   argument   slot \"  )  )  ;", "} else", "if    (  ( varNames . size (  )  )     =  =     1  )     {", "for    ( int   j    =     0  ;    j    <     ( this . parameterNameBindings . length )  ;    j +  +  )     {", "if    ( isUnbound ( j )  )     {", "bindParameterName ( j ,    varNames . get (  0  )  )  ;", "break ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["maybeBindThisOrTargetOrArgsFromPointcutExpression"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . throwingName )     =  =    null )     {", "return ;", "}", "int   throwableIndex    =     -  1  ;", "for    ( int   i    =     0  ;    i    <     ( this . argumentTypes . length )  ;    i +  +  )     {", "if    (  ( isUnbound ( i )  )     &  &     ( isSubtypeOf ( Throwable . class ,    i )  )  )     {", "if    ( throwableIndex    =  =     (  -  1  )  )     {", "throwableIndex    =    i ;", "} else    {", "throw   new    . AmbiguousBindingException (  (  (  (  (  (  \" Binding   of   throwing   parameter    '  \"     +     ( this . throwingName )  )     +     \"  '    is   ambiguous :    could   be   bound   to   argument    \"  )     +    throwableIndex )     +     \"    or   argument    \"  )     +    i )  )  ;", "}", "}", "}", "if    ( throwableIndex    =  =     (  -  1  )  )     {", "throw   new   IllegalStateException (  (  (  \" Binding   of   throwing   parameter    '  \"     +     ( this . throwingName )  )     +     \"  '    could   not   be   completed   as   no   available   arguments   are   a   subtype   of   Throwable \"  )  )  ;", "} else    {", "bindParameterName ( throwableIndex ,    this . throwingName )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeBindThrowingVariable"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( candidateToken )  )  )     {", "return   null ;", "}", "if    (  ( Character . isJavaIdentifierStart ( candidateToken . charAt (  0  )  )  )     &  &     ( Character . isLowerCase ( candidateToken . charAt (  0  )  )  )  )     {", "char [  ]    tokenChars    =    candidateToken . toCharArray (  )  ;", "for    ( char   tokenChar    :    tokenChars )     {", "if    (  !  ( Character . isJavaIdentifierPart ( tokenChar )  )  )     {", "return   null ;", "}", "}", "return   candidateToken ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["maybeExtractVariableName"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "if    ( argsSpec    =  =    null )     {", "return ;", "}", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( argsSpec ,     \"  ,  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( tokens . length )  ;    i +  +  )     {", "tokens [ i ]     =    StringUtils . trimWhitespace ( tokens [ i ]  )  ;", "String   va    =    maybeExtractVariableName ( tokens [ i ]  )  ;", "if    ( va    !  =    null )     {", "vas . add ( va )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["maybeExtractVariableNamesFromArgs"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "this . raiseExceptions    =    raiseExceptions ;", "}", "METHOD_END"], "methodName": ["setRaiseExceptions"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "this . returningName    =    returningName ;", "}", "METHOD_END"], "methodName": ["setReturningName"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "this . throwingName    =    throwingName ;", "}", "METHOD_END"], "methodName": ["setThrowingName"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "assertException ( method ,    pointcut ,    null ,    null ,    exceptionType ,    message )  ;", "}", "METHOD_END"], "methodName": ["assertException"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "AspectJAdviceParameterNameDiscoverer   discoverer    =    new   AspectJAdviceParameterNameDiscoverer ( pointcut )  ;", "discoverer . setRaiseExceptions ( true )  ;", "discoverer . setReturningName ( returning )  ;", "discoverer . setThrowingName ( throwing )  ;", "try    {", "discoverer . getParameterNames ( method )  ;", "fail (  (  (  (  (  \" Expecting    \"     +     ( exceptionType . getName (  )  )  )     +     \"    with   message    '  \"  )     +    message )     +     \"  '  \"  )  )  ;", "}    catch    ( RuntimeException   expected )     {", "assertEquals (  (  \" Expecting   exception   of   type    \"     +     ( exceptionType . getName (  )  )  )  ,    exceptionType ,    expected . getClass (  )  )  ;", "assertEquals (  \" Exception   message   does   not   match   expected \"  ,    message ,    expected . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertException"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" bad   test   specification ,    must   have   same   number   of   parameter   names   as   method   arguments \"  ,    method . getParameterCount (  )  ,    parameterNames . length )  ;", "AspectJAdviceParameterNameDiscoverer   discoverer    =    new   AspectJAdviceParameterNameDiscoverer ( pointcut )  ;", "discoverer . setRaiseExceptions ( true )  ;", "discoverer . setReturningName ( returning )  ;", "discoverer . setThrowingName ( throwing )  ;", "String [  ]    discoveredNames    =    discoverer . getParameterNames ( method )  ;", "String   formattedExpectedNames    =     . format ( parameterNames )  ;", "String   formattedActualNames    =     . format ( discoveredNames )  ;", "assertEquals (  (  (  (  (  (  (  (  (  \" Expecting    \"     +     ( parameterNames . length )  )     +     \"    parameter   names   in   return   set    '  \"  )     +    formattedExpectedNames )     +     \"  '  ,    but   found    \"  )     +     ( discoveredNames . length )  )     +     \"     '  \"  )     +    formattedActualNames )     +     \"  '  \"  )  ,    parameterNames . length ,    discoveredNames . length )  ;", "for    ( int   i    =     0  ;    i    <     ( discoveredNames . length )  ;    i +  +  )     {", "assertNotNull (  \" Parameter   names   must   never   be   null \"  ,    discoveredNames [ i ]  )  ;", "assertEquals (  (  (  (  (  (  (  \" Expecting   parameter    \"     +    i )     +     \"    to   be   named    '  \"  )     +     ( parameterNames [ i ]  )  )     +     \"  '    but   was    '  \"  )     +     ( discoveredNames [ i ]  )  )     +     \"  '  \"  )  ,    parameterNames [ i ]  ,    discoveredNames [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertParameterNames"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( method ,    pointcut ,    null ,    null ,    parameterNames )  ;", "}", "METHOD_END"], "methodName": ["assertParameterNames"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   sb    =    new   StringBuffer (  )  ;", "sb . append (  \"  (  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( names . length )  ;    i +  +  )     {", "sb . append ( names [ i ]  )  ;", "if    (  ( i    +     1  )     <     ( names . length )  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "}", "sb . append (  \"  )  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    candidates    =    getClass (  )  . getMethods (  )  ;", "for    ( Method   candidate    :    candidates )     {", "if    ( candidate . get (  )  . equals ( name )  )     {", "return   candidate ;", "}", "}", "fail (  (  (  \" Bad   test   specification ,    no   method    '  \"     +    name )     +     \"  '    found   in   test   class \"  )  )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" theBigOne \"  )  ,     \" this ( foo )     &  &    args ( x )  \"  ,    null ,     \" ex \"  ,    new   String [  ]  {     \" thisJoinPoint \"  ,     \" ex \"  ,     \" x \"  ,     \" foo \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAllTogetherNow"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" twoObjects \"  )  ,     \" args ( x , y )  \"  ,    AspectJAdviceParameterNameDiscoverer . AmbiguousBindingException . class ,     \" Still    2    unbound   args   at   this (  )  , target (  )  , args (  )    binding   stage ,    with   no   way   to   determine   between   them \"  )  ;", "}", "METHOD_END"], "methodName": ["testAmbiguousArgsBinding"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" twoObjects \"  )  ,     \" foo (  )  \"  ,     \" obj \"  ,    null ,    AspectJAdviceParameterNameDiscoverer . AmbiguousBindingException . class ,     \" Binding   of   returning   parameter    ' obj '    is   ambiguous ,    there   are    2    candidates .  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAmbiguousReturning"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" args ( x )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testArgsBindingOneObject"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" oneObject \"  )  ,     \" args ( x , y )  \"  ,    AspectJAdviceParameterNameDiscoverer . AmbiguousBindingException . class ,     \" Found    2    candidate   this (  )  ,    target (  )    or   args (  )    variables   but   only   one   unbound   argument   slot \"  )  ;", "}", "METHOD_END"], "methodName": ["testArgsBindingOneObjectTwoCandidates"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" onePrimitive \"  )  ,     \" args ( count )  \"  ,    new   String [  ]  {     \" count \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testArgsOnePrimitive"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" oneObjectOnePrimitive \"  )  ,     \" args ( count , obj )  \"  ,    AspectJAdviceParameterNameDiscoverer . AmbiguousBindingException . class ,     \" Found    2    candidate   variable   names   but   only   one   candidate   binding   slot   when   matching   primitive   args \"  )  ;", "}", "METHOD_END"], "methodName": ["testArgsOnePrimitiveOneObject"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" tjp \"  )  ,     \" execution (  *     *  (  .  .  )  )  \"  ,    new   String [  ]  {     \" thisJoinPoint \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testJoinPointOnly"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" tjpsp \"  )  ,     \" execution (  *     *  (  .  .  )  )  \"  ,    new   String [  ]  {     \" thisJoinPointStaticPart \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testJoinPointStaticPartOnly"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" noArgs \"  )  ,     \" execution (  *     *  (  .  .  )  )  \"  ,    new   String [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testNoArgs"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" jpAndOneThrowable \"  )  ,     \" foo (  )  \"  ,    null ,     \" ex \"  ,    new   String [  ]  {     \" thisJoinPoint \"  ,     \" ex \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testOneJPAndOneThrowable"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" jpAndTwoThrowables \"  )  ,     \" foo (  )  \"  ,    null ,     \" ex \"  ,    AspectJAdviceParameterNameDiscoverer . AmbiguousBindingException . class ,     \" Binding   of   throwing   parameter    ' ex '    is   ambiguous :    could   be   bound   to   argument    1    or   argument    2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testOneJPAndTwoThrowables"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneThrowable \"  )  ,     \" foo (  )  \"  ,    null ,     \" ex \"  ,    new   String [  ]  {     \" ex \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testOneThrowable"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" onePrimitive \"  )  ,     \" somepc ( foo )  \"  ,    new   String [  ]  {     \" foo \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testReferenceBinding"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" onePrimitive \"  )  ,     \" call ( bar    *  )     &  &    somepc ( foo )  \"  ,    new   String [  ]  {     \" foo \"     }  )  ;", "assertParameterNames ( getMethod (  \" onePrimitive \"  )  ,     \" somepc    (    foo    )  \"  ,    new   String [  ]  {     \" foo \"     }  )  ;", "assertParameterNames ( getMethod (  \" onePrimitive \"  )  ,     \" somepc (    foo )  \"  ,    new   String [  ]  {     \" foo \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testReferenceBindingWithAlternateTokenizations"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" foo (  )  \"  ,     \" obj \"  ,    null ,    new   String [  ]  {     \" obj \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testReturning"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" noArgs \"  )  ,     \" foo (  )  \"  ,     \" obj \"  ,    null ,    IllegalStateException . class ,     \" Not   enough   arguments   in   method   to   satisfy   binding   of   returning   and   throwing   variables \"  )  ;", "}", "METHOD_END"], "methodName": ["testReturningNoCandidates"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneObjectOnePrimitive \"  )  ,     \" args ( count )     &  &    target ( obj )  \"  ,    new   String [  ]  {     \" obj \"  ,     \" count \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testTargetAndPrimitive"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" target ( x )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testTargetBindingOneCandidate"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" oneObject \"  )  ,     \" target ( x )     |  |    target ( y )  \"  ,    AspectJAdviceParameterNameDiscoverer . AmbiguousBindingException . class ,     \" Found    2    candidate   this (  )  ,    target (  )    or   args (  )    variables   but   only   one   unbound   argument   slot \"  )  ;", "}", "METHOD_END"], "methodName": ["testTargetBindingTwoCandidates"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" target (    x    )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" target (    x )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" target    ( x    )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" target ( x    )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" foo (  )     &  &    target ( x )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testTargetBindingWithAlternateTokenizations"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" oneObject \"  )  ,     \" target (  \"  ,    IllegalStateException . class ,     \" Failed   to   bind   all   argument   names :     1    argument ( s )    could   not   be   bound \"  )  ;", "assertException ( getMethod (  \" oneObject \"  )  ,     \" target ( x    &  &    foo (  )  \"  ,    IllegalStateException . class ,     \" Failed   to   bind   all   argument   names :     1    argument ( s )    could   not   be   bound \"  )  ;", "}", "METHOD_END"], "methodName": ["testTargetBindingWithBadPointcutExpressions"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneObjectOnePrimitive \"  )  ,     \" args ( count )     &  &    this ( obj )  \"  ,    new   String [  ]  {     \" obj \"  ,     \" count \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testThisAndPrimitive"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" this ( x )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testThisBindingOneCandidate"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" oneObject \"  )  ,     \" this ( x )     |  |    this ( y )  \"  ,    AspectJAdviceParameterNameDiscoverer . AmbiguousBindingException . class ,     \" Found    2    candidate   this (  )  ,    target (  )    or   args (  )    variables   but   only   one   unbound   argument   slot \"  )  ;", "}", "METHOD_END"], "methodName": ["testThisBindingTwoCandidates"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" this (    x    )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" this (    x )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" this    ( x    )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" this ( x    )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "assertParameterNames ( getMethod (  \" oneObject \"  )  ,     \" foo (  )     &  &    this ( x )  \"  ,    new   String [  ]  {     \" x \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testThisBindingWithAlternateTokenizations"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" oneObject \"  )  ,     \" this (  \"  ,    IllegalStateException . class ,     \" Failed   to   bind   all   argument   names :     1    argument ( s )    could   not   be   bound \"  )  ;", "assertException ( getMethod (  \" oneObject \"  )  ,     \" this ( x    &  &    foo (  )  \"  ,    IllegalStateException . class ,     \" Failed   to   bind   all   argument   names :     1    argument ( s )    could   not   be   bound \"  )  ;", "}", "METHOD_END"], "methodName": ["testThisBindingWithBadPointcutExpressions"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" noArgs \"  )  ,     \" foo (  )  \"  ,    null ,     \" ex \"  ,    IllegalStateException . class ,     \" Not   enough   arguments   in   method   to   satisfy   binding   of   returning   and   throwing   variables \"  )  ;", "}", "METHOD_END"], "methodName": ["testThrowableNoCandidates"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneThrowableOnePrimitive \"  )  ,     \" args ( count )  \"  ,    null ,     \" ex \"  ,    new   String [  ]  {     \" ex \"  ,     \" count \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testThrowingAndPrimitive"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" twoJoinPoints \"  )  ,     \" foo (  )  \"  ,    IllegalStateException . class ,     \" Failed   to   bind   all   argument   names :     1    argument ( s )    could   not   be   bound \"  )  ;", "}", "METHOD_END"], "methodName": ["testTwoJoinPoints"], "fileName": "org.springframework.aop.aspectj.AspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "if    ( returnValue    !  =    null )     {", "return   ClassUtils . isAssignableValue ( type ,    returnValue )  ;", "} else", "if    (  (  ( Object . class )     =  =    type )     &  &     (  ( void . class )     =  =     ( method . getType (  )  )  )  )     {", "return   true ;", "} else    {", "return   ClassUtils . isAssignable ( type ,    method . getType (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["matchesReturnValue"], "fileName": "org.springframework.aop.aspectj.AspectJAfterReturningAdvice"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    type    =    getDiscoveredReturningType (  )  ;", "Type   genericType    =    getDiscoveredReturningGenericType (  )  ;", "return    ( matchesReturnValue ( type ,    method ,    returnValue )  )     &  &     (  (  ( genericType    =  =    null )     |  |     ( genericType    =  =    type )  )     |  |     ( TypeUtils . isAssignable ( genericType ,    method . getGenericReturnType (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldInvokeOnReturnValueOf"], "fileName": "org.springframework.aop.aspectj.AspectJAfterReturningAdvice"}, {"methodBody": ["METHOD_START", "{", "return   getDiscoveredThrowingType (  )  . isAssignableFrom ( ex . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldInvokeOnThrowing"], "fileName": "org.springframework.aop.aspectj.AspectJAfterThrowingAdvice"}, {"methodBody": ["METHOD_START", "{", "if    ( anAdvisor   instanceof   AspectJPrecedenceInformation )     {", "return    (  ( AspectJPrecedenceInformation )     ( anAdvisor )  )  ;", "}", "Advice   advice    =    anAdvisor . getAdvice (  )  ;", "if    ( advice   instanceof   AspectJPrecedenceInformation )     {", "return    (  ( AspectJPrecedenceInformation )     ( advice )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAspectJPrecedenceInformationFor"], "fileName": "org.springframework.aop.aspectj.AspectJAopUtils"}, {"methodBody": ["METHOD_START", "{", "AspectJPrecedenceInformation   precedenceInfo    =    AspectJAopUtils . getAspectJPrecedenceInformationFor ( anAdvisor )  ;", "if    ( precedenceInfo    !  =    null )     {", "return   precedenceInfo . isAfterAdvice (  )  ;", "}", "return    ( anAdvisor . getAdvice (  )  )    instanceof   AfterAdvice ;", "}", "METHOD_END"], "methodName": ["isAfterAdvice"], "fileName": "org.springframework.aop.aspectj.AspectJAopUtils"}, {"methodBody": ["METHOD_START", "{", "AspectJPrecedenceInformation   precedenceInfo    =    AspectJAopUtils . getAspectJPrecedenceInformationFor ( anAdvisor )  ;", "if    ( precedenceInfo    !  =    null )     {", "return   precedenceInfo . isBeforeAdvice (  )  ;", "}", "return    ( anAdvisor . getAdvice (  )  )    instanceof   BeforeAdvice ;", "}", "METHOD_END"], "methodName": ["isBeforeAdvice"], "fileName": "org.springframework.aop.aspectj.AspectJAopUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodInvocationProceedingJoinPoint ( rmi )  ;", "}", "METHOD_END"], "methodName": ["lazyGetProceedingJoinPoint"], "fileName": "org.springframework.aop.aspectj.AspectJAroundAdvice"}, {"methodBody": ["METHOD_START", "{", "invocation . setUserAttribute ( resolveExpression (  )  ,    jpm )  ;", "}", "METHOD_END"], "methodName": ["bindParameters"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "PointcutParser   parser    =    initializePointcutParser ( classLoader )  ;", "PointcutParameter [  ]    pointcutParameters    =    new   PointcutParameter [ this . pointcutParameterNames . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( pointcutParameters . length )  ;    i +  +  )     {", "pointcutParameters [ i ]     =    parser . createPointcutParameter ( this . pointcutParameterNames [ i ]  ,    this . pointcutParameterTypes [ i ]  )  ;", "}", "return   parser . parsePointcut ( replaceBooleanOperators ( resolve (  )  )  ,    this . pointcutDeclarationScope ,    pointcutParameters )  ;", "}", "METHOD_END"], "methodName": ["buildPointcutExpression"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )    instanceof   ConfigurableBeanFactory )     {", "return    (  ( ConfigurableBeanFactory )     ( this . beanFactory )  )  . getBeanClassLoader (  )  ;", "}", "if    (  ( this . pDeclarationScope )     !  =    null )     {", "return   this . pDeclarationScope . getClassLoader (  )  ;", "}", "return   ClassUtils . getDefaultClassLoader (  )  ;", "}", "METHOD_END"], "methodName": ["determinePointcutClassLoader"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "return   ProxyCreationContext . getCurrentProxiedBeanName (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentProxiedBeanName"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "try    {", "ClassLoader   classLoader    =    targetClass . getClassLoader (  )  ;", "if    (  ( classLoader    !  =    null )     &  &     ( classLoader    !  =     ( this . pointcutClassLoader )  )  )     {", "return   buildPointcutExpression ( classLoader )  ;", "}", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Failed   to   create   fallback   PointcutExpression \"  ,    ex )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getFallbackPointcutExpression"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "return   obtainPointcutExpression (  )  ;", "}", "METHOD_END"], "methodName": ["getPointcutExpression"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "if    ( shadowMatch   instanceof   AspectJExpressionPointcut . DefensiveShadowMatch )     {", "return   new   RuntimeTestWalker (  (  ( AspectJExpressionPointcut . DefensiveShadowMatch )     ( shadowMatch )  )  . primary )  ;", "}", "return   new   RuntimeTestWalker ( shadowMatch )  ;", "}", "METHOD_END"], "methodName": ["getRuntimeTestWalker"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "ShadowMatch   shadowMatch    =    this . shadowMatchCache . get ( targetMethod )  ;", "if    ( shadowMatch    =  =    null )     {", "synchronized ( this . shadowMatchCache )     {", "PointcutExpression   fallbackExpression    =    null ;", "shadowMatch    =    this . shadowMatchCache . get ( targetMethod )  ;", "if    ( shadowMatch    =  =    null )     {", "Method   methodToMatch    =    targetMethod ;", "try    {", "try    {", "shadowMatch    =    obtainPointcutExpression (  )  . matchesMethodExecution ( methodToMatch )  ;", "}    catch    ( ReflectionWorldException   ex )     {", "try    {", "fallbackExpression    =    getFallbackPointcutExpression ( methodToMatch . getDeclaringClass (  )  )  ;", "if    ( fallbackExpression    !  =    null )     {", "shadowMatch    =    fallbackExpression . matchesMethodExecution ( methodToMatch )  ;", "}", "}    catch    ( ReflectionWorldException   ex 2  )     {", "fallbackExpression    =    null ;", "}", "}", "if    (  ( shadowMatch    =  =    null )     &  &     ( targetMethod    !  =    originalMethod )  )     {", "methodToMatch    =    originalMethod ;", "try    {", "shadowMatch    =    obtainPointcutExpression (  )  . matchesMethodExecution ( methodToMatch )  ;", "}    catch    ( ReflectionWorldException   ex )     {", "try    {", "fallbackExpression    =    getFallbackPointcutExpression ( methodToMatch . getDeclaringClass (  )  )  ;", "if    ( fallbackExpression    !  =    null )     {", "shadowMatch    =    fallbackExpression . matchesMethodExecution ( methodToMatch )  ;", "}", "}    catch    ( ReflectionWorldException   ex 2  )     {", "fallbackExpression    =    null ;", "}", "}", "}", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" PointcutExpression   matching   rejected   target   method \"  ,    ex )  ;", "fallbackExpression    =    null ;", "}", "if    ( shadowMatch    =  =    null )     {", "shadowMatch    =    new   ShadowMatchImpl ( FuzzyBoolean . NO ,    null ,    null ,    null )  ;", "} else", "if    (  ( shadowMatch . maybeMatches (  )  )     &  &     ( fallbackExpression    !  =    null )  )     {", "shadowMatch    =    new    . DefensiveShadowMatch ( shadowMatch ,    fallbackExpression . matchesMethodExecution ( methodToMatch )  )  ;", "}", "this . shadowMatchCache . put ( targetMethod ,    shadowMatch )  ;", "}", "}", "}", "return   shadowMatch ;", "}", "METHOD_END"], "methodName": ["getShadowMatch"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "Method   targetMethod    =    method ;", "if    ( targetClass    !  =    null )     {", "targetMethod    =    ClassUtils . getMostSpecificMethod ( method ,    ClassUtils . getUserClass ( targetClass )  )  ;", "if    ( targetMethod . getDeclaClass (  )  . isInterface (  )  )     {", "Set < Class <  ?  >  >    ifcs    =    ClassUtils . getAllInterfacesForClassAsSet ( targetClass )  ;", "if    (  ( ifcs . size (  )  )     >     1  )     {", "Class <  ?  >    compositeInterface    =    ClassUtils . createCompositeInterface ( ClassUtils . toClassArray ( ifcs )  ,    targetClass . getClassLoader (  )  )  ;", "targetMethod    =    ClassUtils . getMostSpecificMethod ( targetMethod ,    compositeInterface )  ;", "}", "}", "}", "targetMethod    =    BridgeMethodResolver . findBridgedMethod ( targetMethod )  ;", "return   getShadowMatch ( targetMethod ,    method )  ;", "}", "METHOD_END"], "methodName": ["getTargetShadowMatch"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "PointcutParser   parser    =    PointcutParser . getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution ( AspectJExpressionPointcut . SUPPORTED _ PRIMITIVES ,    classLoader )  ;", "parser . registerPointcutDesignatorHandler ( new   AspectJExpressionPointcut . BeanPointcutDesignatorHandler (  )  )  ;", "return   parser ;", "}", "METHOD_END"], "methodName": ["initializePointcutParser"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getExpression (  )  )     =  =    null )     {", "throw   new   IllegalStateException (  \" Must   set   property    ' expression '    before   attempting   to   match \"  )  ;", "}", "if    (  ( this . pointcutExpression )     =  =    null )     {", "this . pointcutClassLoader    =    determinePointcutClassLoader (  )  ;", "this . pointcutExpression    =    buildPointcutExpression ( this . pointcutClassLoader )  ;", "}", "return   this . pointcutExpression ;", "}", "METHOD_END"], "methodName": ["obtainPointcutExpression"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "this . shadowMatchCache    =    new   ConcurrentHashMap (  3  2  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "String   result    =    StringUtils . replace ( pcExpr ,     \"    and    \"  ,     \"     &  &     \"  )  ;", "result    =    StringUtils . replace ( result ,     \"    or    \"  ,     \"     |  |     \"  )  ;", "result    =    StringUtils . replace ( result ,     \"    not    \"  ,     \"     !     \"  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["replaceBooleanOperators"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "String   expression    =    getExpression (  )  ;", "Assert . state (  ( expression    !  =    null )  ,     \" No   expression   set \"  )  ;", "return   expression ;", "}", "METHOD_END"], "methodName": ["resolveExpression"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "this . pointcutParameterNames    =    names ;", "}", "METHOD_END"], "methodName": ["setParameterNames"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "this . pointcutParameterTypes    =    types ;", "}", "METHOD_END"], "methodName": ["setParameterTypes"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "this . pointcutDeclarationScope    =    pointcutDeclarationScope ;", "}", "METHOD_END"], "methodName": ["setPointcutDeclarationScope"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "return   this . pointcut . getExpression (  )  ;", "}", "METHOD_END"], "methodName": ["getExpression"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "return   this . pointcut . getLocation (  )  ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setExpression ( expression )  ;", "}", "METHOD_END"], "methodName": ["setExpression"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setLocation ( location )  ;", "}", "METHOD_END"], "methodName": ["setLocation"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setParameterNames ( names )  ;", "}", "METHOD_END"], "methodName": ["setParameterNames"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setParameterTypes ( types )  ;", "}", "METHOD_END"], "methodName": ["setParameterTypes"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Expression   should   match   getAge (  )    method \"  ,    methodMatcher . matches ( getAge ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["assertMatchesGetAge"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Expression   should   match   TestBean   class \"  ,    classFilter . matches ( TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["assertMatchesTestBeanClass"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "Pointcut   pointcut    =    getPointcut ( pointcut )  ;", "DefaultPointcutAdvisor   advisor    =    new   DefaultPointcutAdvisor (  )  ;", "advisor . setAdvice ( interceptor )  ;", "advisor . setPointcut ( pointcut )  ;", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTarget ( target )  ;", "pf . addAdvisor ( advisor )  ;", "return    (  ( TestBean )     ( pf . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAdvisedProxy"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "AspectJExpressionPointcut   pointcut    =    new   AspectJExpressionPointcut (  )  ;", "pointcut . setExpression ( expression )  ;", "return   pointcut ;", "}", "METHOD_END"], "methodName": ["getPointcut"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "getAge    =    TestBean . class . getMethod (  \" getAge \"  )  ;", "setAge    =    TestBean . class . getMethod (  \" setAge \"  ,    int . class )  ;", "setSomeNumber    =    TestBean . class . getMethod (  \" setSomeNumber \"  ,    Number . class )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "Pointcut   pc    =    getPointcut (  \" execution (  *     *  (  .  .  )  )    and   args ( String )  \"  )  ;", "PointcutExpression   expr    =     (  (  )     ( pc )  )  . getPointcutExpression (  )  ;", "assertEquals (  \" execution (  *     *  (  .  .  )  )     &  &    args ( String )  \"  ,    expr . getPointcutExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAndSubstitution"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" execution ( void   setSomeNumber ( Number )  )     &  &    args ( Double )  \"  ;", "CallCountingInterceptor   interceptor    =    new   CallCountingInterceptor (  )  ;", "TestBean   testBean    =    getAdvisedProxy ( expression ,    interceptor )  ;", "assertEquals (  \" Calls   should   be    0  \"  ,     0  ,    interceptor . getCount (  )  )  ;", "testBean . setSomeNumber ( new   Double (  3  0  )  )  ;", "assertEquals (  \" Calls   should   be    1  \"  ,     1  ,    interceptor . getCount (  )  )  ;", "testBean . setSomeNumber ( new   Integer (  9  0  )  )  ;", "assertEquals (  \" Calls   should   be    1  \"  ,     1  ,    interceptor . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDynamicMatchingProxy"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "AspectJExpressionPointcut   pc    =    new   AspectJExpressionPointcut (  )  ;", "try    {", "pc . matches ( getAge ,    ITestBean . class )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" expression \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testFriendlyErrorOnNoLocation2ArgMatching"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "AspectJExpressionPointcut   pc    =    new   AspectJExpressionPointcut (  )  ;", "try    {", "pc . matches ( getAge ,    ITestBean . class ,     (  ( Object [  ]  )     ( null )  )  )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" expression \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testFriendlyErrorOnNoLocation3ArgMatching"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "AspectJExpressionPointcut   pc    =    new   AspectJExpressionPointcut (  )  ;", "try    {", "pc . matches ( ITestBean . class )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" expression \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testFriendlyErrorOnNoLocationClassMatching"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" execution ( void   setSomeNumber ( Number )     &  &    args ( Double )  \"  ;", "try    {", "getPointcut ( expression )  . getClassFilter (  )  ;", "fail (  \" Invalid   expression   should   throw   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["testInvalidExpression"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" execution ( int   getAge (  )  )  \"  ;", "Pointcut   pointcut    =    getPointcut ( expression )  ;", "ClassFilter   classFilter    =    pointcut . getClassFilter (  )  ;", "MethodMatcher   methodMatcher    =    pointcut . getMethodMatcher (  )  ;", "assertMatchesTestBeanClass ( classFilter )  ;", "assertFalse (  \" Should   not   be   a   runtime   match \"  ,    methodMatcher . isRuntime (  )  )  ;", "assertMatchesGetAge ( methodMatcher )  ;", "assertFalse (  \" Expression   should   match   setAge (  )    method \"  ,    methodMatcher . matches ( setAge ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchExplicit"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" execution ( void   setSomeNumber ( Number )  )     &  &    args ( Double )  \"  ;", "Pointcut   pointcut    =    getPointcut ( expression )  ;", "ClassFilter   classFilter    =    pointcut . getClassFilter (  )  ;", "MethodMatcher   methodMatcher    =    pointcut . getMethodMatcher (  )  ;", "assertMatchesTestBeanClass ( classFilter )  ;", "assertTrue (  \" Should   match   with   setSomeNumber   with   Double   input \"  ,    methodMatcher . matches ( setSomeNumber ,    TestBean . class ,    new   Double (  1  2  )  )  )  ;", "assertFalse (  \" Should   not   match   setSomeNumber   with   Integer   input \"  ,    methodMatcher . matches ( setSomeNumber ,    TestBean . class ,    new   Integer (  1  1  )  )  )  ;", "assertFalse (  \" Should   not   match   getAge \"  ,    methodMatcher . matches ( getAge ,    TestBean . class )  )  ;", "assertTrue (  \" Should   be   a   runtime   match \"  ,    methodMatcher . isRuntime (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchWithArgs"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" execution (  *     *  .  . TestBean .  * Age (  .  .  )  )  \"  ;", "Pointcut   pointcut    =    getPointcut ( expression )  ;", "ClassFilter   classFilter    =    pointcut . getClassFilter (  )  ;", "MethodMatcher   methodMatcher    =    pointcut . getMethodMatcher (  )  ;", "assertMatchesTestBeanClass ( classFilter )  ;", "assertFalse (  \" Should   not   be   a   runtime   match \"  ,    methodMatcher . isRuntime (  )  )  ;", "assertMatchesGetAge ( methodMatcher )  ;", "assertTrue (  \"    should   match   setAge ( int )    method \"  ,    methodMatcher . matches ( setAge ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchWithTypePattern"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "Pointcut   pc    =    getPointcut (  \" execution (  *     *  (  .  .  )  )    and   args ( String )    and   this ( Object )  \"  )  ;", "PointcutExpression   expr    =     (  (  )     ( pc )  )  . getPointcutExpression (  )  ;", "assertEquals (  \" execution (  *     *  (  .  .  )  )     &  &    args ( String )     &  &    this ( Object )  \"  ,    expr . getPointcutExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleAndSubstitutions"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" execution ( int   getAge (  )  )  \"  ;", "CallCountingInterceptor   interceptor    =    new   CallCountingInterceptor (  )  ;", "TestBean   testBean    =    getAdvisedProxy ( expression ,    interceptor )  ;", "assertEquals (  \" Calls   should   be    0  \"  ,     0  ,    interceptor . getCount (  )  )  ;", "testBean . getAge (  )  ;", "assertEquals (  \" Calls   should   be    1  \"  ,     1  ,    interceptor . getCount (  )  )  ;", "testBean . setAge (  9  0  )  ;", "assertEquals (  \" Calls   should   still   be    1  \"  ,     1  ,    interceptor . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleAdvice"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "testThisOrTarget (  \" target \"  )  ;", "}", "METHOD_END"], "methodName": ["testTarget"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "testThisOrTarget (  \" this \"  )  ;", "}", "METHOD_END"], "methodName": ["testThis"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   matchesTestBean    =    which    +     \"  ( TestBean )  \"  ;", "String   matchesIOther    =    which    +     \"  ( IOther )  \"  ;", "AspectJExpressionPointcut   testBeanPc    =    new   AspectJExpressionPointcut (  )  ;", "testBeanPc . setExpression ( matchesTestBean )  ;", "AspectJExpressionPointcut   iOtherPc    =    new   AspectJExpressionPointcut (  )  ;", "iOtherPc . setExpression ( matchesIOther )  ;", "assertTrue ( testBeanPc . matches ( TestBean . class )  )  ;", "assertTrue ( testBeanPc . matches ( getAge ,    TestBean . class )  )  ;", "assertTrue ( iOtherPc . matches (  . OtherIOther . class . getMethod (  \" absquatulate \"  )  ,     . OtherIOther . class )  )  ;", "assertFalse ( testBeanPc . matches (  . OtherIOther . class . getMethod (  \" absquatulate \"  )  ,     . OtherIOther . class )  )  ;", "}", "METHOD_END"], "methodName": ["testThisOrTarget"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" call ( int   getAge (  )  )  \"  ;", "try    {", "getPointcut ( expression )  . getClassFilter (  )  ;", "fail (  \" Should   not   support   call   pointcuts \"  )  ;", "}    catch    ( UnsupportedPointcutPrimitiveException   ex )     {", "assertEquals (  \" Should   not   support   call   pointcut \"  ,    CALL ,    ex . getUnsupportedPrimitive (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithUnsupportedPointcutPrimitive"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   withinBeansPackage    =     \" within ( \"  ;", "if    ( matchSubpackages )     {", "withinBeansPackage    +  =     \"  .  \"  ;", "}", "withinBeansPackage    =    withinBeansPackage    +     \"  *  )  \"  ;", "AspectJExpressionPointcut   withinBeansPc    =    new   AspectJExpressionPointcut (  )  ;", "withinBeansPc . setExpression ( withinBeansPackage )  ;", "assertTrue ( withinBeansPc . matches ( TestBean . class )  )  ;", "assertTrue ( withinBeansPc . matches ( getAge ,    TestBean . class )  )  ;", "assertEquals ( matchSubpackages ,    withinBeansPc . matches ( DeepBean . class )  )  ;", "assertEquals ( matchSubpackages ,    withinBeansPc . matches ( DeepBean . class . getMethod (  \" aMethod \"  ,    String . class )  ,    DeepBean . class )  )  ;", "assertFalse ( withinBeansPc . matches ( String . class )  )  ;", "assertFalse ( withinBeansPc . matches (  . OtherIOther . class . getMethod (  \" absquatulate \"  )  ,     . OtherIOther . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWithinPackage"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "testWithinPackage ( true )  ;", "}", "METHOD_END"], "methodName": ["testWithinRootAndSubpackages"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "testWithinPackage ( false )  ;", "}", "METHOD_END"], "methodName": ["testWithinRootPackage"], "fileName": "org.springframework.aop.aspectj.AspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "return   this . advice . getAspectName (  )  ;", "}", "METHOD_END"], "methodName": ["getAspectName"], "fileName": "org.springframework.aop.aspectj.AspectJPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.aop.aspectj.AspectJPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( advisor   instanceof   InstantiationModelAwarePointcutAdvisor )     |  |     (  ( advisor . getAdvice (  )  )    instanceof   AbstractAspectJAdvice )  )     |  |     (  ( advisor   instanceof   PointcutAdvisor )     &  &     (  (  (  ( PointcutAdvisor )     ( advisor )  )  . getPointcut (  )  )    instanceof   AspectJExpressionPointcut )  )  ;", "}", "METHOD_END"], "methodName": ["isAspectJAdvice"], "fileName": "org.springframework.aop.aspectj.AspectJProxyUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( advisors . isEmpty (  )  )  )     {", "boolean   foundAspectJAdvice    =    false ;", "for    ( Advisor   advisor    :    advisors )     {", "if    (  . isAspectJAdvice ( advisor )  )     {", "foundAspectJAdvice    =    true ;", "}", "}", "if    ( foundAspectJAdvice    &  &     (  !  ( advisors . contains ( ExposeInvocationInterceptor . ADVISOR )  )  )  )     {", "advisors . add (  0  ,    ExposeInvocationInterceptor . ADVISOR )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["makeAdvisorChainAspectJCapableIfNecessary"], "fileName": "org.springframework.aop.aspectj.AspectJProxyUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( AspectJWeaverMessageHandler . AJ _ ID )     +     ( aMessage . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["makeMessageFor"], "fileName": "org.springframework.aop.aspectj.AspectJWeaverMessageHandler"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  (  (  (  \" Unexpected   mismatch   for   bean    \\  \"  \"     +    beanName )     +     \"  \\  \"    for   pcExpression    \\  \"  \"  )     +    pcExpression )     +     \"  \\  \"  \"  )  ,    BeanNamePointcutMatchingTests . matches ( beanName ,    pcExpression )  )  ;", "}", "METHOD_END"], "methodName": ["assertMatch"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutMatchingTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  (  (  (  (  \" Unexpected   match   for   bean    \\  \"  \"     +    beanName )     +     \"  \\  \"    for   pcExpression    \\  \"  \"  )     +    pcExpression )     +     \"  \\  \"  \"  )  ,    BeanNamePointcutMatchingTests . matches ( beanName ,    pcExpression )  )  ;", "}", "METHOD_END"], "methodName": ["assertMisMatch"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutMatchingTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" serial \"  )", "AspectJExpression   pointcut    =    new   AspectJExpression (  )     {", "@ Override", "protected   String   getCurrentProxiedBeanName (  )     {", "return   beanName ;", "}", "}  ;", "pointcut . setExpression ( pcExpression )  ;", "return   pointcut . matches ( TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutMatchingTests"}, {"methodBody": ["METHOD_START", "{", "assertMatch (  \" someName \"  ,     \" bean ( someName )  \"  )  ;", "assertMatch (  \" someName / someOtherName \"  ,     \" bean ( someName / someOtherName )  \"  )  ;", "assertMatch (  \" someName / foo / someOtherName \"  ,     \" bean ( someName /  *  / someOtherName )  \"  )  ;", "assertMatch (  \" someName / foo / bar / someOtherName \"  ,     \" bean ( someName /  *  / someOtherName )  \"  )  ;", "assertMatch (  \" someName /  *  /  *  *  \"  ,     \" bean ( someName /  *  )  \"  )  ;", "assertMatch (  \" service : name = traceService \"  ,     \" bean ( service : name = traceService )  \"  )  ;", "assertMatch (  \" service : name = traceService \"  ,     \" bean ( service : name =  *  )  \"  )  ;", "assertMatch (  \" service : name = traceService \"  ,     \" bean (  *  : name = traceService )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean (  * someName )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean (  * Name )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean (  *  )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean ( someName *  )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean ( some *  )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean ( some * Name )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean (  * some * Name *  )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean (  * s * N *  )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean ( someName )     |  |    bean ( someOtherName )  \"  )  ;", "assertMatch (  \" someOtherName \"  ,     \" bean ( someName )     |  |    bean ( someOtherName )  \"  )  ;", "assertMatch (  \" someName \"  ,     \"  ! bean ( someOtherName )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean ( someName )     |  |     ! bean ( someOtherName )  \"  )  ;", "assertMatch (  \" someName \"  ,     \" bean ( someName )     &  &     ! bean ( someOtherName )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMatchingPointcuts"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutMatchingTests"}, {"methodBody": ["METHOD_START", "{", "assertMisMatch (  \" someName \"  ,     \" bean ( someNamex )  \"  )  ;", "assertMisMatch (  \" someName \"  ,     \" bean ( someX * Name )  \"  )  ;", "assertMisMatch (  \" someName \"  ,     \" bean ( someName )     &  &    bean ( someOtherName )  \"  )  ;", "assertMisMatch (  \" someName \"  ,     \"  ! bean ( someName )  \"  )  ;", "assertMisMatch (  \" someName \"  ,     \"  ! bean ( someName )     &  &    bean ( someOtherName )  \"  )  ;", "assertMisMatch (  \" someName \"  ,     \"  ! bean ( someName )     |  |    bean ( someOtherName )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNonMatchingPointcuts"], "fileName": "org.springframework.aop.aspectj.BeanNamePointcutMatchingTests"}, {"methodBody": ["METHOD_START", "{", "return   count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.aop.aspectj.CallCountingInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . count    =     0  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.aop.aspectj.CallCountingInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   Object   raw    =    new   TestBean (  )  ;", "final   int   newAge    =     2  3  ;", "ProxyFactory   pf    =    new   ProxyFactory ( raw )  ;", "pf . setExposeProxy ( true )  ;", "pf . addAdvisor ( ExposeInterceptor . ADVISOR )  ;", "pf . addAdvice ( new   MethodBeforeAdvice (  )     {", "private   int   depth ;", "@ Override", "public   void   before ( Method   method ,    Object [  ]    args ,     @ Nullable", "Object   target )    throws   Throwable    {", "JoinPoint   jp    =    AbstractAspectJAdvice . currentJoinPoint (  )  ;", "assertTrue (  \" Method   named   in   toString \"  ,    jp . toString (  )  . contains ( method . getName (  )  )  )  ;", "jp . toShortString (  )  ;", "jp . toLongString (  )  ;", "assertSame ( target ,    AbstractAspectJAdvice . currentJoinPoint (  )  . getTarget (  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( AbstractAspectJAdvice . currentJoinPoint (  )  . getTarget (  )  )  )  ;", "ITestBean   thisProxy    =     (  ( ITestBean )     ( AbstractAspectJAdvice . currentJoinPoint (  )  . getThis (  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( AbstractAspectJAdvice . currentJoinPoint (  )  . getThis (  )  )  )  ;", "assertNotSame ( target ,    thisProxy )  ;", "assertSame ( thisProxy ,    AbstractAspectJAdvice . currentJoinPoint (  )  . getThis (  )  )  ;", "if    (  (  ( depth )  +  +  )     =  =     0  )     {", "thisProxy . toString (  )  ;", "thisProxy . setAge ( newAge )  ;", "assertEquals ( newAge ,    thisProxy . getAge (  )  )  ;", "}", "assertSame ( AopContext . currentProxy (  )  ,    thisProxy )  ;", "assertSame ( target ,    raw )  ;", "assertSame ( method . getName (  )  ,    AbstractAspectJAdvice . currentJoinPoint (  )  . getSignature (  )  . getName (  )  )  ;", "assertEquals ( method . getModifiers (  )  ,    AbstractAspectJAdvice . currentJoinPoint (  )  . getSignature (  )  . getModifiers (  )  )  ;", "MethodSignature   msig    =     (  ( MethodSignature )     ( AbstractAspectJAdvice . currentJoinPoint (  )  . getSignature (  )  )  )  ;", "assertSame (  \" Return   same   MethodSignature   repeatedly \"  ,    msig ,    AbstractAspectJAdvice . currentJoinPoint (  )  . getSignature (  )  )  ;", "assertSame (  \" Return   same   JoinPoint   repeatedly \"  ,    AbstractAspectJAdvice . currentJoinPoint (  )  ,    AbstractAspectJAdvice . currentJoinPoint (  )  )  ;", "assertEquals ( method . getDeclaringClass (  )  ,    msig . getDeclaringType (  )  )  ;", "assertTrue ( Arrays . equals ( method . getParameterTypes (  )  ,    msig . getParameterTypes (  )  )  )  ;", "assertEquals ( method . getReturnType (  )  ,    msig . getReturnType (  )  )  ;", "assertTrue ( Arrays . equals ( method . getExceptionTypes (  )  ,    msig . getExceptionTypes (  )  )  )  ;", "msig . toLongString (  )  ;", "msig . toShortString (  )  ;", "}", "}  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "assertEquals (  \" Advice   reentrantly   set   age \"  ,    newAge ,    itb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanGetMethodSignatureFromJoinPoint"], "fileName": "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPointTests"}, {"methodBody": ["METHOD_START", "{", "final   Object   raw    =    new   TestBean (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( raw )  ;", "pf . addAdvisor ( ExposeInterceptor . ADVISOR )  ;", "pf . addAdvice ( new   MethodBeforeAdvice (  )     {", "@ Override", "public   void   before ( Method   method ,    Object [  ]    args ,     @ Nullable", "Object   target )    throws   Throwable    {", "SourceLocation   sloc    =    AbstractAspectJAdvice . currentJoinPoint (  )  . getSourceLocation (  )  ;", "assertEquals (  \" Same   source   location   must   be   returned   on   subsequent   requests \"  ,    sloc ,    AbstractAspectJAdvice . currentJoinPoint (  )  . getSourceLocation (  )  )  ;", "assertEquals ( TestBean . class ,    sloc . getWithinType (  )  )  ;", "try    {", "sloc . getLine (  )  ;", "fail (  \" Can ' t   get   line   number \"  )  ;", "}    catch    ( UnsupportedOperationException   ex )     {", "}", "try    {", "sloc . getFileName (  )  ;", "fail (  \" Can ' t   get   file   name \"  )  ;", "}    catch    ( UnsupportedOperationException   ex )     {", "}", "}", "}  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "itb . getAge (  )  ;", "}", "METHOD_END"], "methodName": ["testCanGetSourceLocationFromJoinPoint"], "fileName": "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPointTests"}, {"methodBody": ["METHOD_START", "{", "final   Object   raw    =    new   TestBean (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( raw )  ;", "pf . addAdvisor ( ExposeInterceptor . ADVISOR )  ;", "pf . addAdvice ( new   MethodBeforeAdvice (  )     {", "@ Override", "public   void   before ( Method   method ,    Object [  ]    args ,     @ Nullable", "Object   target )    throws   Throwable    {", "StaticPart   staticPart    =    AbstractAspectJAdvice . currentJoinPoint (  )  . getStaticPart (  )  ;", "assertEquals (  \" Same   static   part   must   be   returned   on   subsequent   requests \"  ,    staticPart ,    AbstractAspectJAdvice . currentJoinPoint (  )  . getStaticPart (  )  )  ;", "assertEquals ( METHOD _ EXECUTION ,    staticPart . getKind (  )  )  ;", "assertSame ( AbstractAspectJAdvice . currentJoinPoint (  )  . getSignature (  )  ,    staticPart . getSignature (  )  )  ;", "assertEquals ( AbstractAspectJAdvice . currentJoinPoint (  )  . getSourceLocation (  )  ,    staticPart . getSourceLocation (  )  )  ;", "}", "}  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "itb . getAge (  )  ;", "}", "METHOD_END"], "methodName": ["testCanGetStaticPartFromJoinPoint"], "fileName": "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPointTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "AbstractAspectJAdvice . current (  )  ;", "fail (  \" Needs   to   be   bound   by   interceptor   action \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testingBindingWithJoinPoint"], "fileName": "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPointTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "AbstractAspectJAdvice . current (  )  ;", "fail (  \" Needs   to   be   bound   by   interceptor   action \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testingBindingWithProceedingJoinPoint"], "fileName": "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPointTests"}, {"methodBody": ["METHOD_START", "{", "final   Object   raw    =    new   TestBean (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( raw )  ;", "pf . addAdvisor ( ExposeInterceptor . ADVISOR )  ;", "pf . addAdvice ( new   MethodBeforeAdvice (  )     {", "@ Override", "public   void   before ( Method   method ,    Object [  ]    args ,     @ Nullable", "Object   target )    throws   Throwable    {", "JoinPoint . StaticPart   aspectJVersionJp    =    Factory . makeEncSJP ( method )  ;", "JoinPoint   jp    =    AbstractAspectJAdvice . currentJoinPoint (  )  ;", "assertEquals ( aspectJVersionJp . getSignature (  )  . toLongString (  )  ,    jp . getSignature (  )  . toLongString (  )  )  ;", "assertEquals ( aspectJVersionJp . getSignature (  )  . toShortString (  )  ,    jp . getSignature (  )  . toShortString (  )  )  ;", "assertEquals ( aspectJVersionJp . getSignature (  )  . toString (  )  ,    jp . getSignature (  )  . toString (  )  )  ;", "assertEquals ( aspectJVersionJp . toLongString (  )  ,    jp . toLongString (  )  )  ;", "assertEquals ( aspectJVersionJp . toShortString (  )  ,    jp . toShortString (  )  )  ;", "assertEquals ( aspectJVersionJp . toString (  )  ,    jp . toString (  )  )  ;", "}", "}  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "itb . getAge (  )  ;", "itb . setName (  \" foo \"  )  ;", "itb . getDoctor (  )  ;", "itb . getStringArray (  )  ;", "itb . getSpouse (  )  ;", "itb . setSpouse ( new   TestBean (  )  )  ;", "try    {", "itb . unreliableFileOperation (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["toShortAndLongStringFormedCorrectly"], "fileName": "org.springframework.aop.aspectj.MethodInvocationProceedingJoinPointTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . runtimeTest )     !  =    null )     &  &     ( new   RuntimeTestWalker . TargetInstanceOfResidueTestVisitor ( targetClass )  . targetInstanceOfMatches ( this . runtimeTest )  )  ;", "}", "METHOD_END"], "methodName": ["testTargetInstanceOfResidue"], "fileName": "org.springframework.aop.aspectj.RuntimeTestWalker"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . runtimeTest )     !  =    null )     &  &     ( new   RuntimeTestWalker . ThisInstanceOfResidueTestVisitor ( thisClass )  . thisInstanceOfMatches ( this . runtimeTest )  )  ;", "}", "METHOD_END"], "methodName": ["testThisInstanceOfResidue"], "fileName": "org.springframework.aop.aspectj.RuntimeTestWalker"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . runtimeTest )     !  =    null )     &  &     ( new   RuntimeTestWalker . SubtypeSensitiveVarTypeTestVisitor (  )  . testsSubtypeSensitiveVars ( this . runtimeTest )  )  ;", "}", "METHOD_END"], "methodName": ["testsSubtypeSensitiveVars"], "fileName": "org.springframework.aop.aspectj.RuntimeTestWalker"}, {"methodBody": ["METHOD_START", "{", "return   this . aspectClass ;", "}", "METHOD_END"], "methodName": ["getAspectClass"], "fileName": "org.springframework.aop.aspectj.SimpleAspectInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "return   Ordered . LOWEST _ PRECEDENCE ;", "}", "METHOD_END"], "methodName": ["getOrderForAspectClass"], "fileName": "org.springframework.aop.aspectj.SimpleAspectInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "return   Ordered . LOWEST _ PRECEDENCE ;", "}", "METHOD_END"], "methodName": ["getOrderForAspectClass"], "fileName": "org.springframework.aop.aspectj.SingletonAspectInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" oneAnnotation \"  )  ,     \"  @ annotation ( a )     &  &     @ this ( x )  \"  ,    IllegalArgumentException . class ,     \" Found    2    candidate   annotation   binding   variables   but   only   one   potential   argument   binding   slot \"  )  ;", "}", "METHOD_END"], "methodName": ["testAmbiguousAnnotationOneVar"], "fileName": "org.springframework.aop.aspectj.TigerAspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertException ( getMethod (  \" twoAnnotations \"  )  ,     \"  @ annotation ( a )     &  &     @ this ( x )  \"  ,    AspectJAdviceParameterNameDiscoverer . AmbiguousBindingException . class ,     \" Found    2    potential   annotation   variable ( s )  ,    and    2    potential   argument   slots \"  )  ;", "}", "METHOD_END"], "methodName": ["testAmbiguousAnnotationTwoVars"], "fileName": "org.springframework.aop.aspectj.TigerAspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" annotationMedley \"  )  ,     \"  @ annotation ( a )     &  &    args ( count )     &  &    this ( foo )  \"  ,    null ,     \" ex \"  ,    new   String [  ]  {     \" ex \"  ,     \" foo \"  ,     \" count \"  ,     \" a \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationMedley"], "fileName": "org.springframework.aop.aspectj.TigerAspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneAnnotation \"  )  ,     \"  @ annotation ( a )  \"  ,    new   String [  ]  {     \" a \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAtAnnotation"], "fileName": "org.springframework.aop.aspectj.TigerAspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneAnnotation \"  )  ,     \"  @ args ( a )  \"  ,    new   String [  ]  {     \" a \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAtArgs"], "fileName": "org.springframework.aop.aspectj.TigerAspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneAnnotation \"  )  ,     \"  @ target ( a )  \"  ,    new   String [  ]  {     \" a \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAtTarget"], "fileName": "org.springframework.aop.aspectj.TigerAspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneAnnotation \"  )  ,     \"  @ this ( a )  \"  ,    new   String [  ]  {     \" a \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAtThis"], "fileName": "org.springframework.aop.aspectj.TigerAspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneAnnotation \"  )  ,     \"  @ within ( a )  \"  ,    new   String [  ]  {     \" a \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAtWithin"], "fileName": "org.springframework.aop.aspectj.TigerAspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "assertParameterNames ( getMethod (  \" oneAnnotation \"  )  ,     \"  @ withincode ( a )  \"  ,    new   String [  ]  {     \" a \"     }  )  ;", "}", "METHOD_END"], "methodName": ["testAtWithincode"], "fileName": "org.springframework.aop.aspectj.TigerAspectJAdviceParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "getAge    =    TestBean . class . getMethod (  \" getAge \"  )  ;", "for    ( Method   method    :     . HasGeneric . class . getMethods (  )  )     {", "methodsOnHasGeneric . put ( method . getName (  )  ,    method )  ;", "}", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  @ args (  *  ,    test . annotation . EmptySpringAnnotation )  )  \"  ;", "AspectJExpressionPointcut   takesSpringAnnotatedArgument 2     =    new   AspectJExpressionPointcut (  )  ;", "takesSpringAnnotatedArgument 2  . setExpression ( expression )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches ( getAge ,    TestBean . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . HasTransactionalAnnotation . class . getMethod (  \" foo \"  )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . HasTransactionalAnnotation . class . getMethod (  \" bar \"  ,    String . class )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . BeanA . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanA . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . BeanA . class . getMethod (  \" getAge \"  )  ,     . BeanA . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . BeanA . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanA . class )  )  ;", "assertTrue ( takesSpringAnnotatedArgument 2  . matches (  . ProcessesSpringAnnotatedParameters . class . getMethod (  \" takesAnnotatedParameters \"  ,    TestBean . class ,     . SpringAnnotated . class )  ,     . ProcessesSpringAnnotatedParameters . class )  )  ;", "assertTrue ( takesSpringAnnotatedArgument 2  . matches (  . ProcessesSpringAnnotatedParameters . class . getMethod (  \" takesNoAnnotatedParameters \"  ,    TestBean . class ,     . BeanA . class )  ,     . ProcessesSpringAnnotatedParameters . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . ProcessesSpringAnnotatedParameters . class . getMethod (  \" takesNoAnnotatedParameters \"  ,    TestBean . class ,     . BeanA . class )  ,     . ProcessesSpringAnnotatedParameters . class ,    new   TestBean (  )  ,    new    . BeanA (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationOnMethodArgumentsWithFQN"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" execution (  *     *  (  *  ,     @  ( test .  .  *  )     *  )  )  \"  ;", "AspectJExpressionPointcut   takesSpringAnnotatedArgument 2     =    new   AspectJExpressionPointcut (  )  ;", "takesSpringAnnotatedArgument 2  . setExpression ( expression )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches ( getAge ,    TestBean . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . HasTransactionalAnnotation . class . getMethod (  \" foo \"  )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . HasTransactionalAnnotation . class . getMethod (  \" bar \"  ,    String . class )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . BeanA . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanA . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . BeanA . class . getMethod (  \" getAge \"  )  ,     . BeanA . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . BeanA . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanA . class )  )  ;", "assertTrue ( takesSpringAnnotatedArgument 2  . matches (  . ProcessesSpringAnnotatedParameters . class . getMethod (  \" takesAnnotatedParameters \"  ,    TestBean . class ,     . SpringAnnotated . class )  ,     . ProcessesSpringAnnotatedParameters . class )  )  ;", "assertFalse ( takesSpringAnnotatedArgument 2  . matches (  . ProcessesSpringAnnotatedParameters . class . getMethod (  \" takesNoAnnotatedParameters \"  ,    TestBean . class ,     . BeanA . class )  ,     . ProcessesSpringAnnotatedParameters . class )  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationOnMethodArgumentsWithWildcards"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  @ annotation ( test . annotation . transaction . Tx )  \"  ;", "AspectJExpressionPointcut   ajexp    =    new   AspectJExpressionPointcut (  )  ;", "ajexp . setExpression ( expression )  ;", "assertFalse ( ajexp . matches ( getAge ,    TestBean . class )  )  ;", "assertFalse ( ajexp . matches (  . HasTransactionalAnnotation . class . getMethod (  \" foo \"  )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertFalse ( ajexp . matches (  . HasTransactionalAnnotation . class . getMethod (  \" bar \"  ,    String . class )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertFalse ( ajexp . matches (  . BeanA . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanA . class )  )  ;", "assertTrue ( ajexp . matches (  . BeanA . class . getMethod (  \" getAge \"  )  ,     . BeanA . class )  )  ;", "assertFalse ( ajexp . matches (  . BeanA . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanA . class )  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationOnMethodWithFQN"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" execution (  @  ( test . annotation .  .  *  )     *     *  (  .  .  )  )  \"  ;", "AspectJExpressionPointcut   anySpringMethodAnnotation    =    new   AspectJExpressionPointcut (  )  ;", "anySpringMethodAnnotation . setExpression ( expression )  ;", "assertFalse ( anySpringMethodAnnotation . matches ( getAge ,    TestBean . class )  )  ;", "assertFalse ( anySpringMethodAnnotation . matches (  . HasTransactionalAnnotation . class . getMethod (  \" foo \"  )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertFalse ( anySpringMethodAnnotation . matches (  . HasTransactionalAnnotation . class . getMethod (  \" bar \"  ,    String . class )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertFalse ( anySpringMethodAnnotation . matches (  . BeanA . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanA . class )  )  ;", "assertTrue ( anySpringMethodAnnotation . matches (  . BeanA . class . getMethod (  \" getAge \"  )  ,     . BeanA . class )  )  ;", "assertFalse ( anySpringMethodAnnotation . matches (  . BeanA . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanA . class )  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationOnMethodWithWildcard"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "AspectJExpressionPointcut   ajexp    =    new   AspectJExpressionPointcut (  )  ;", "ajexp . setExpression ( expression )  ;", "assertFalse ( ajexp . matches ( getAge ,    TestBean . class )  )  ;", "assertTrue ( ajexp . matches (  . HasTransactionalAnnotation . class . getMethod (  \" foo \"  )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertTrue ( ajexp . matches (  . HasTransactionalAnnotation . class . getMethod (  \" bar \"  ,    String . class )  ,     . HasTransactionalAnnotation . class )  )  ;", "assertTrue ( ajexp . matches (  . BeanB . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanB . class )  )  ;", "assertFalse ( ajexp . matches (  . BeanA . class . getMethod (  \" setName \"  ,    String . class )  ,     . BeanA . class )  )  ;", "return   ajexp ;", "}", "METHOD_END"], "methodName": ["testMatchAnnotationOnClass"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \"  @ within ( test . annotation . transaction . Tx )  \"  ;", "testMatchAnnotationOnClass ( expression )  ;", "}", "METHOD_END"], "methodName": ["testMatchAnnotationOnClassWithAtWithin"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" within (  @  ( test . annotation . transaction .  *  )     *  )  \"  ;", "testMatchAnnotationOnClass ( expression )  ;", "}", "METHOD_END"], "methodName": ["testMatchAnnotationOnClassWithExactPackageWildcard"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" within (  @  ( test . annotation .  .  *  )     *  )  \"  ;", "AspectJExpressionPointcut   springAnnotatedPc    =    testMatchAnnotationOnClass ( expression )  ;", "assertFalse ( springAnnotatedPc . matches ( TestBean . class . getMethod (  \" setName \"  ,    String . class )  ,    TestBean . class )  )  ;", "assertTrue ( springAnnotatedPc . matches (  . SpringAnnotated . class . getMethod (  \" foo \"  )  ,     . SpringAnnotated . class )  )  ;", "expression    =     \" within (  @  ( test . annotation . transaction .  .  *  )     *  )  \"  ;", "AspectJExpressionPointcut   springTxAnnotatedPc    =    testMatchAnnotationOnClass ( expression )  ;", "assertFalse ( springTxAnnotatedPc . matches (  . SpringAnnotated . class . getMethod (  \" foo \"  )  ,     . SpringAnnotated . class )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchAnnotationOnClassWithSubpackageWildcard"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" within (  @ test . annotation . transaction . Tx    *  )  \"  ;", "testMatchAnnotationOnClass ( expression )  ;", "}", "METHOD_END"], "methodName": ["testMatchAnnotationOnClassWithoutBinding"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "String   expression    =     \" execution (  *    set *  ( List < TestBean >  )     )  \"  ;", "AspectJExpressionPointcut   ajexp    =    new   AspectJExpressionPointcut (  )  ;", "ajexp . setExpression ( expression )  ;", "Method   takesGenericList    =    methodsOnHasGeneric . get (  \" setFriends \"  )  ;", "assertTrue ( ajexp . matches ( takesGenericList ,     . HasGeneric . class )  )  ;", "assertTrue ( ajexp . matches ( methodsOnHasGeneric . get (  \" setEnemies \"  )  ,     . HasGeneric . class )  )  ;", "assertFalse ( ajexp . matches ( methodsOnHasGeneric . get (  \" setPartners \"  )  ,     . HasGeneric . class )  )  ;", "assertFalse ( ajexp . matches ( methodsOnHasGeneric . get (  \" setPhoneNumbers \"  )  ,     . HasGeneric . class )  )  ;", "assertFalse ( ajexp . matches ( getAge ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchGenericArgument"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   MyTemplate    {", "public   int   queryForInt ( String   sql ,    Object .  .  .    params )     {", "return    0  ;", "}", "}", "String   expression    =     \" execution ( int    *  .  *  ( String ,    Object .  .  .  )  )  \"  ;", "AspectJExpressionPointcut   jdbcVarArgs    =    new   AspectJExpressionPointcut (  )  ;", "jdbcVarArgs . setExpression ( expression )  ;", "assertTrue ( jdbcVarArgs . matches ( MyTemplate . class . getMethod (  \" queryForInt \"  ,    String . class ,    Object [  ]  . class )  ,    MyTemplate . class )  )  ;", "Method   takesGenericList    =    methodsOnHasGeneric . get (  \" setFriends \"  )  ;", "assertFalse ( jdbcVarArgs . matches ( takesGenericList ,     . HasGeneric . class )  )  ;", "assertFalse ( jdbcVarArgs . matches ( methodsOnHasGeneric . get (  \" setEnemies \"  )  ,     . HasGeneric . class )  )  ;", "assertFalse ( jdbcVarArgs . matches ( methodsOnHasGeneric . get (  \" setPartners \"  )  ,     . HasGeneric . class )  )  ;", "assertFalse ( jdbcVarArgs . matches ( methodsOnHasGeneric . get (  \" setPhoneNumbers \"  )  ,     . HasGeneric . class )  )  ;", "assertFalse ( jdbcVarArgs . matches ( getAge ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchVarargs"], "fileName": "org.springframework.aop.aspectj.TigerAspectJExpressionPointcutTests"}, {"methodBody": ["METHOD_START", "{", "testAdvice ( advisor ,    logAdvice ,    target ,    message ,    false )  ;", "}", "METHOD_END"], "methodName": ["testAdvice"], "fileName": "org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests"}, {"methodBody": ["METHOD_START", "{", "logAdvice . reset (  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( target )  ;", "factory . setProxyTargetClass ( proxyTargetClass )  ;", "factory . addAdvisor ( advisor )  ;", ". TestService   bean    =     (  (  . TestService )     ( factory . getProxy (  )  )  )  ;", "assertEquals (  0  ,    logAdvice . getCountThrows (  )  )  ;", "try    {", "bean . sayHello (  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    (  . TestException   ex )     {", "assertEquals ( message ,    ex . getMessage (  )  )  ;", "}", "assertEquals (  1  ,    logAdvice . getCountThrows (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAdvice"], "fileName": "org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests"}, {"methodBody": ["METHOD_START", "{", "TrickyAspectJPointcutExpressionTests . TestService   target    =    new   TrickyAspectJPointcutExpressionTests . TestServiceImpl (  )  ;", "TrickyAspectJPointcutExpressionTests . LogUserAdvice   logAdvice    =    new   TrickyAspectJPointcutExpressionTests . LogUserAdvice (  )  ;", "AspectJExpressionPointcut   pointcut    =    new   AspectJExpressionPointcut (  )  ;", "pointcut . setExpression ( String . format (  \"  @ within (  % s . Log )  \"  ,    getClass (  )  . getName (  )  )  )  ;", "testAdvice ( new   DefaultPointcutAdvisor ( pointcut ,    logAdvice )  ,    logAdvice ,    target ,     \" TestServiceImpl \"  )  ;", "}", "METHOD_END"], "methodName": ["testManualProxyJavaWithDynamicPointcut"], "fileName": "org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests"}, {"methodBody": ["METHOD_START", "{", "TrickyAspectJPointcutExpressionTests . TestService   target    =    new   TrickyAspectJPointcutExpressionTests . TestServiceImpl (  )  ;", "TrickyAspectJPointcutExpressionTests . LogUserAdvice   logAdvice    =    new   TrickyAspectJPointcutExpressionTests . LogUserAdvice (  )  ;", "AspectJExpressionPointcut   pointcut    =    new   AspectJExpressionPointcut (  )  ;", "pointcut . setExpression ( String . format (  \"  @ within (  % s . Log )  \"  ,    getClass (  )  . getName (  )  )  )  ;", "testAdvice ( new   DefaultPointcutAdvisor ( pointcut ,    logAdvice )  ,    logAdvice ,    target ,     \" TestServiceImpl \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testManualProxyJavaWithDynamicPointcutAndProxyTargetClass"], "fileName": "org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests"}, {"methodBody": ["METHOD_START", "{", "TrickyAspectJPointcutExpressionTests . TestService   target    =    new   TrickyAspectJPointcutExpressionTests . TestServiceImpl (  )  ;", "TrickyAspectJPointcutExpressionTests . LogUserAdvice   logAdvice    =    new   TrickyAspectJPointcutExpressionTests . LogUserAdvice (  )  ;", "AspectJExpressionPointcut   pointcut    =    new   AspectJExpressionPointcut (  )  ;", "pointcut . setExpression ( String . format (  \" execution (  *     % s . TestService .  *  (  .  .  )  )  \"  ,    getClass (  )  . getName (  )  )  )  ;", "testAdvice ( new   DefaultPointcutAdvisor ( pointcut ,    logAdvice )  ,    logAdvice ,    target ,     \" TestServiceImpl \"  )  ;", "}", "METHOD_END"], "methodName": ["testManualProxyJavaWithStaticPointcut"], "fileName": "org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests"}, {"methodBody": ["METHOD_START", "{", "TrickyAspectJPointcutExpressionTests . LogUserAdvice   logAdvice    =    new   TrickyAspectJPointcutExpressionTests . LogUserAdvice (  )  ;", "AspectJExpressionPointcut   pointcut    =    new   AspectJExpressionPointcut (  )  ;", "pointcut . setExpression ( String . format (  \" execution (  *     % s . TestService .  *  (  .  .  )  )  \"  ,    getClass (  )  . getName (  )  )  )  ;", "testAdvice ( new   DefaultPointcutAdvisor ( pointcut ,    logAdvice )  ,    logAdvice ,    new   TrickyAspectJPointcutExpressionTests . TestServiceImpl (  )  ,     \" TestServiceImpl \"  )  ;", "TrickyAspectJPointcutExpressionTests . SimpleThrowawayClassLoader   loader    =    new   TrickyAspectJPointcutExpressionTests . SimpleThrowawayClassLoader ( new   TrickyAspectJPointcutExpressionTests . TestServiceImpl (  )  . getClass (  )  . getClassLoader (  )  )  ;", "loader . excludeClass ( TrickyAspectJPointcutExpressionTests . TestService . class . getName (  )  )  ;", "loader . excludeClass ( TrickyAspectJPointcutExpressionTests . TestException . class . getName (  )  )  ;", "TrickyAspectJPointcutExpressionTests . TestService   other    =     (  ( TrickyAspectJPointcutExpressionTests . TestService )     ( loader . loadClass ( TrickyAspectJPointcutExpressionTests . TestServiceImpl . class . getName (  )  )  . newInstance (  )  )  )  ;", "testAdvice ( new   DefaultPointcutAdvisor ( pointcut ,    logAdvice )  ,    logAdvice ,    other ,     \" TestServiceImpl \"  )  ;", "}", "METHOD_END"], "methodName": ["testManualProxyJavaWithStaticPointcutAndTwoClassLoaders"], "fileName": "org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests"}, {"methodBody": ["METHOD_START", "{", "TrickyAspectJPointcutExpressionTests . TestService   target    =    new   TrickyAspectJPointcutExpressionTests . TestServiceImpl (  )  ;", "TrickyAspectJPointcutExpressionTests . LogUserAdvice   logAdvice    =    new   TrickyAspectJPointcutExpressionTests . LogUserAdvice (  )  ;", "testAdvice ( new   DefaultPointcutAdvisor ( logAdvice )  ,    logAdvice ,    target ,     \" TestServiceImpl \"  )  ;", "}", "METHOD_END"], "methodName": ["testManualProxyJavaWithUnconditionalPointcut"], "fileName": "org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests"}, {"methodBody": ["METHOD_START", "{", "return   this . typePattern ;", "}", "METHOD_END"], "methodName": ["getTypePattern"], "fileName": "org.springframework.aop.aspectj.TypePatternClassFilter"}, {"methodBody": ["METHOD_START", "{", "String   result    =    StringUtils . replace ( pcExpr ,     \"    and    \"  ,     \"     &  &     \"  )  ;", "result    =    StringUtils . replace ( result ,     \"    or    \"  ,     \"     |  |     \"  )  ;", "return   StringUtils . replace ( result ,     \"    not    \"  ,     \"     !     \"  )  ;", "}", "METHOD_END"], "methodName": ["replaceBooleanOperators"], "fileName": "org.springframework.aop.aspectj.TypePatternClassFilter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( typePattern ,     \" Type   pattern   must   not   be   null \"  )  ;", "this . typePattern    =    typePattern ;", "this . aspectJMatcher    =    PointcutParser . getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution (  )  . parse ( replaceBooleanOperators ( typePattern )  )  ;", "}", "METHOD_END"], "methodName": ["setTypePattern"], "fileName": "org.springframework.aop.aspectj.TypePatternClassFilter"}, {"methodBody": ["METHOD_START", "{", "TypePatternClassFilter   tpcf    =    new   TypePatternClassFilter (  \" String \"  )  ;", "assertFalse (  \" matches   Number \"  ,    tpcf . matches ( Number . class )  )  ;", "assertTrue (  \" matches   Object \"  ,    tpcf . matches ( Object . class )  )  ;", "assertTrue (  \" matchesString \"  ,    tpcf . matches ( String . class )  )  ;", "tpcf    =    new   TypePatternClassFilter (  \" Number +    and   Float \"  )  ;", "assertTrue (  \" matches   Float \"  ,    tpcf . matches ( Float . class )  )  ;", "assertFalse (  \" matches   Double \"  ,    tpcf . matches ( Double . class )  )  ;", "tpcf    =    new   TypePatternClassFilter (  \" Number +    and   not   Float \"  )  ;", "assertFalse (  \" matches   Float \"  ,    tpcf . matches ( Float . class )  )  ;", "assertTrue (  \" matches   Double \"  ,    tpcf . matches ( Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["testAndOrNotReplacement"], "fileName": "org.springframework.aop.aspectj.TypePatternClassFilterTests"}, {"methodBody": ["METHOD_START", "{", "new   TypePatternClassFilter (  \"  -  \"  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidPattern"], "fileName": "org.springframework.aop.aspectj.TypePatternClassFilterTests"}, {"methodBody": ["METHOD_START", "{", "new   TypePatternClassFilter (  )  . matches ( String . class )  ;", "}", "METHOD_END"], "methodName": ["testInvocationOfMatchesMethodBlowsUpWhenNoTypePatternHasBeenSet"], "fileName": "org.springframework.aop.aspectj.TypePatternClassFilterTests"}, {"methodBody": ["METHOD_START", "{", "new   TypePatternClassFilter ( null )  ;", "}", "METHOD_END"], "methodName": ["testSetTypePatternWithNullArgument"], "fileName": "org.springframework.aop.aspectj.TypePatternClassFilterTests"}, {"methodBody": ["METHOD_START", "{", "TypePatternClassFilter   tpcf    =    new   TypePatternClassFilter (  \" ITestBean +  \"  )  ;", "assertTrue (  \" Must   match :    in   package \"  ,    tpcf . matches ( TestBean . class )  )  ;", "assertTrue (  \" Must   match :    in   package \"  ,    tpcf . matches ( ITestBean . class )  )  ;", "assertTrue (  \" Must   match :    in   package \"  ,    tpcf . matches ( CountingTestBean . class )  )  ;", "assertFalse (  \" Must   be   excluded :    not   subclass \"  ,    tpcf . matches ( IOther . class )  )  ;", "assertFalse (  \" Must   be   excluded :    not   subclass \"  ,    tpcf . matches ( DefaultListableBeanFactory . class )  )  ;", "}", "METHOD_END"], "methodName": ["testSubclassMatching"], "fileName": "org.springframework.aop.aspectj.TypePatternClassFilterTests"}, {"methodBody": ["METHOD_START", "{", "TypePatternClassFilter   tpcf    =    new   TypePatternClassFilter (  \" *  \"  )  ;", "assertTrue (  \" Must   match :    in   package \"  ,    tpcf . matches ( TestBean . class )  )  ;", "assertTrue (  \" Must   match :    in   package \"  ,    tpcf . matches ( ITestBean . class )  )  ;", "assertTrue (  \" Must   match :    in   package \"  ,    tpcf . matches ( IOther . class )  )  ;", "assertFalse (  \" Must   be   excluded :    in   wrong   package \"  ,    tpcf . matches ( DeepBean . class )  )  ;", "assertFalse (  \" Must   be   excluded :    in   wrong   package \"  ,    tpcf . matches ( BeanFactory . class )  )  ;", "assertFalse (  \" Must   be   excluded :    in   wrong   package \"  ,    tpcf . matches ( DefaultListableBeanFactory . class )  )  ;", "}", "METHOD_END"], "methodName": ["testValidPatternMatching"], "fileName": "org.springframework.aop.aspectj.TypePatternClassFilterTests"}, {"methodBody": ["METHOD_START", "{", "for    ( Field   field    :    clazz . getDeclaredFields (  )  )     {", "if    ( field . getName (  )  . startsWith (  . AJC _ MAGIC )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["compiledByAjc"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory"}, {"methodBody": ["METHOD_START", "{", "A   result    =    AnnotationUtils . findAnnotation ( method ,    toLookFor )  ;", "if    ( result    !  =    null )     {", "return   new    . AspectJAnnotation <  >  ( result )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classesToLookFor    =    new   Class <  ?  >  [  ]  {    Before . class ,    Around . class ,    After . class ,    AfterReturning . class ,    AfterThrowing . class ,    Pointcut . class    }  ;", "for    ( Class <  ?  >    c    :    classesToLookFor )     {", ". AspectJAnnotation <  ?  >    foundAnnotation    =     . findAnnotation ( method ,     (  ( Class < Annotation >  )     ( c )  )  )  ;", "if    ( foundAnnotation    !  =    null )     {", "return   foundAnnotation ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findAspectJAnnotationOnMethod"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( AnnotationUtils . findAnnotation ( clazz ,    Aspect . class )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasAspectAnnotation"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "if    (  (  ( interfaces . length )     >     1  )     |  |     ( interfaces [  0  ]  . isInterface (  )  )  )     {", "pf . setInterfaces ( interfaces )  ;", "} else    {", "pf . setProxyTargetClass ( true )  ;", "}", "pf . addAdvice ( ExposeInvocationInterceptor . INSTANCE )  ;", "pf . addAdvisors ( advisors )  ;", "pf . setExposeProxy ( true )  ;", "return   pf . getProxy (  )  ;", "}", "METHOD_END"], "methodName": ["createProxy"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AbstractAspectJAdvisorFactoryTests . Echo   target    =    new   AbstractAspectJAdvisorFactoryTests . Echo (  )  ;", "AbstractAspectJAdvisorFactoryTests . ExceptionHandling   afterReturningAspect    =    new   AbstractAspectJAdvisorFactoryTests . ExceptionHandling (  )  ;", "List < Advisor >    advisors    =    getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( afterReturningAspect ,     \" someBean \"  )  )  ;", "AbstractAspectJAdvisorFactoryTests . Echo   echo    =     (  ( AbstractAspectJAdvisorFactoryTests . Echo )     ( createProxy ( target ,    advisors ,    AbstractAspectJAdvisorFactoryTests . Echo . class )  )  )  ;", "assertEquals (  0  ,    afterReturningAspect . successCount )  ;", "assertEquals (  \"  \"  ,    echo . echo (  \"  \"  )  )  ;", "assertEquals (  1  ,    afterReturningAspect . successCount )  ;", "assertEquals (  0  ,    afterReturningAspect . failureCount )  ;", "try    {", "echo . echo ( new   FileNotFoundException (  )  )  ;", "fail (  )  ;", "}    catch    ( FileNotFoundException   ex )     {", "}    catch    ( Exception   ex )     {", "fail (  )  ;", "}", "assertEquals (  1  ,    afterReturningAspect . successCount )  ;", "assertEquals (  1  ,    afterReturningAspect . failureCount )  ;", "assertEquals (  (  ( afterReturningAspect . failureCount )     +     ( afterReturningAspect . successCount )  )  ,    afterReturningAspect . afterCount )  ;", "}", "METHOD_END"], "methodName": ["testAfterAdviceTypes"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "RemoteException   expectedException    =    new   RemoteException (  )  ;", "List < Advisor >    advisors    =    getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new    . ExceptionAspect ( expectedException )  ,     \" someBean \"  )  )  ;", "assertEquals (  \" One   advice   method   was   found \"  ,     1  ,    advisors . size (  )  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( createProxy ( target ,    advisors ,    ITestBean . class )  )  )  ;", "try    {", "itb . getAge (  )  ;", "fail (  )  ;", "}    catch    ( UndeclaredThrowableException   ex )     {", "assertSame ( expectedException ,    ex . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAspectMethodThrowsExceptionIllegalOnSignature"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "UnsupportedOperationException   expectedException    =    new   UnsupportedOperationException (  )  ;", "List < Advisor >    advisors    =    getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new    . ExceptionAspect ( expectedException )  ,     \" someBean \"  )  )  ;", "assertEquals (  \" One   advice   method   was   found \"  ,     1  ,    advisors . size (  )  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( createProxy ( target ,    advisors ,    ITestBean . class )  )  )  ;", "try    {", "itb . getAge (  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   ex )     {", "assertSame ( expectedException ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["testAspectMethodThrowsExceptionLegalOnSignature"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AbstractAspectJAdvisorFactoryTests . ManyValuedArgs   target    =    new   AbstractAspectJAdvisorFactoryTests . ManyValuedArgs (  )  ;", "AbstractAspectJAdvisorFactoryTests . ManyValuedArgs   mva    =     (  ( AbstractAspectJAdvisorFactoryTests . ManyValuedArgs )     ( createProxy ( target ,    getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new   AbstractAspectJAdvisorFactoryTests . ManyValuedArgs (  )  ,     \" someBean \"  )  )  ,    AbstractAspectJAdvisorFactoryTests . ManyValuedArgs . class )  )  )  ;", "String   a    =     \" a \"  ;", "int   b    =     1  2  ;", "int   c    =     2  5  ;", "String   d    =     \" d \"  ;", "StringBuffer   e    =    new   StringBuffer (  \" stringbuf \"  )  ;", "String   expectedResult    =     (  (  ( a    +    b )     +    c )     +    d )     +    e ;", "assertEquals ( expectedResult ,    mva . mungeArgs ( a ,    b ,    c ,    d ,    e )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithMultipleArgsDifferentlyOrdered"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( createProxy ( target ,    getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new    . BindingAspectWithSingleArg (  )  ,     \" someBean \"  )  )  ,    ITestBean . class )  )  )  ;", "itb . setAge (  1  0  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     2  0  ,    itb . getAge (  )  )  ;", "assertEquals (  2  0  ,    target . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBindingWithSingleArg"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "MetadataAwareAspectInstanceFactory   aspectInstanceFactory    =    new   SingletonMetadataAwareAspectInstanceFactory ( new    . DeclarePrecedenceShouldSucceed (  )  ,     \" someBean \"  )  ;", "createProxy ( target ,    getFixture (  )  . getAdvisors ( aspectInstanceFactory )  ,    ITestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testDeclarePrecedenceNotSupported"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "MetadataAwareAspectInstanceFactory   aspectInstanceFactory    =    new   SingletonMetadataAwareAspectInstanceFactory ( new    . NoDeclarePrecedenceShouldFail (  )  ,     \" someBean \"  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( createProxy ( target ,    getFixture (  )  . getAdvisors ( aspectInstanceFactory )  ,    ITestBean . class )  )  )  ;", "itb . getAge (  )  ;", "}", "METHOD_END"], "methodName": ["testFailureWithoutExplicitDeclarePrecedence"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AopUtils . findAdvisorsThatCanApply ( getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new   MakeLockable (  )  ,     \" someBean \"  )  )  ,    CannotBeUnlocked . class )  . isEmpty (  )  )  ;", "assertEquals (  2  ,    AopUtils . findAdvisorsThatCanApply ( getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new   MakeLockable (  )  ,     \" someBean \"  )  )  ,    NotLockable . class )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionAdvisorExcludedFromTargetImplementingInterface"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedTarget   target    =    new   AnnotatedTargetImpl (  )  ;", "List <  >    advisors    =    getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( new   MakeAnnotatedTypeModifiable (  )  ,     \" someBean \"  )  )  ;", "Object   proxy    =    createProxy ( target ,    advisors ,    AnnotatedTarget . class )  ;", "System . out . println ( advisors . get (  1  )  )  ;", "assertTrue (  ( proxy   instanceof   Lockable )  )  ;", "Lockable   lockable    =     (  ( Lockable )     ( proxy )  )  ;", "lockable . locked (  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionBasedOnAnnotationMatch_SPR5307"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LinkedList < Object >    target    =    new   LinkedList <  >  (  )  ;", "List <  ?  >    proxy    =     (  ( List <  ?  >  )     ( createProxy ( target ,    AopUtils . findsThatCanApply ( getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( new   MakeLockable (  )  ,     \" someBean \"  )  )  ,    List . class )  ,    List . class )  )  )  ;", "assertFalse (  \" Type   pattern   must   have   excluded   mixin \"  ,     ( proxy   instanceof   Lockable )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionOnTargetExcludedByTypePattern"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "CannotBeUnlocked   target    =    new   CannotBeUnlocked (  )  ;", "Lockable   proxy    =     (  ( Lockable )     ( createProxy ( target ,    AopUtils . findsThatCanApply ( getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( new   MakeLockable (  )  ,     \" someBean \"  )  )  ,    CannotBeUnlocked . class )  ,    CannotBeUnlocked . class )  )  )  ;", "assertThat ( proxy ,    instanceOf ( Lockable . class )  )  ;", "Lockable   lockable    =    proxy ;", "assertTrue (  \" Already   locked \"  ,    lockable . locked (  )  )  ;", "lockable . lock (  )  ;", "assertTrue (  \" Real   target   ignores   locking \"  ,    lockable . locked (  )  )  ;", "try    {", "lockable . unlock (  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testIntroductionOnTargetImplementingInterface"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "NotLockable   notLockableTarget    =    new   NotLockable (  )  ;", "assertFalse (  ( notLockableTarget   instanceof   Lockable )  )  ;", "NotLockable   notLockable 1     =     (  ( NotLockable )     ( createProxy ( notLockableTarget ,    getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( new   MakeLockable (  )  ,     \" someBean \"  )  )  ,    NotLockable . class )  )  )  ;", "assertTrue (  ( notLockable 1    instanceof   Lockable )  )  ;", "Lockable   lockable    =     (  ( Lockable )     ( notLockable 1  )  )  ;", "assertFalse ( lockable . locked (  )  )  ;", "lockable . lock (  )  ;", "assertTrue ( lockable . locked (  )  )  ;", "NotLockable   notLockable 2 Target    =    new   NotLockable (  )  ;", "NotLockable   notLockable 2     =     (  ( NotLockable )     ( createProxy ( notLockable 2 Target ,    getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( new   MakeLockable (  )  ,     \" someBean \"  )  )  ,    NotLockable . class )  )  )  ;", "assertTrue (  ( notLockable 2    instanceof   Lockable )  )  ;", "Lockable   lockable 2     =     (  ( Lockable )     ( notLockable 2  )  )  ;", "assertFalse ( lockable 2  . locked (  )  )  ;", "notLockable 2  . setIntValue (  1  )  ;", "lockable 2  . lock (  )  ;", "try    {", "notLockable 2  . setIntValue (  3  2  )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "assertTrue ( lockable 2  . locked (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionOnTargetNotImplementingInterface"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "List <  >    advisors    =    getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( new   MakeITestBeanModifiable (  )  ,     \" someBean \"  )  )  ;", "advisors . addAll ( getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( new   MakeLockable (  )  ,     \" someBean \"  )  )  )  ;", "Modifiable   modifiable    =     (  ( Modifiable )     ( createProxy ( target ,    advisors ,    ITestBean . class )  )  )  ;", "assertThat ( modifiable ,    instanceOf ( Modifiable . class )  )  ;", "Lockable   lockable    =     (  ( Lockable )     ( modifiable )  )  ;", "assertFalse ( lockable . locked (  )  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( modifiable )  )  ;", "assertFalse ( modifiable . isModified (  )  )  ;", "int   oldAge    =    itb . getAge (  )  ;", "itb . setAge (  ( oldAge    +     1  )  )  ;", "assertTrue ( modifiable . isModified (  )  )  ;", "modifiable . acceptChanges (  )  ;", "assertFalse ( modifiable . isModified (  )  )  ;", "itb . setAge ( itb . getAge (  )  )  ;", "assertFalse (  \" Setting   same   value   does   not   modify \"  ,    modifiable . isModified (  )  )  ;", "itb . setName (  \" And   now   for   something   completely   different \"  )  ;", "assertTrue ( modifiable . isModified (  )  )  ;", "lockable . lock (  )  ;", "assertTrue ( lockable . locked (  )  )  ;", "try    {", "itb . setName (  \" Else \"  )  ;", "fail (  \" Should   be   locked \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "lockable . unlock (  )  ;", "itb . setName (  \" Tony \"  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionWithArgumentBinding"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "int   realAge    =     6  5  ;", "target . setAge ( realAge )  ;", "List <  >    advisors    =    new   LinkedList <  >  (  )  ;", "PerTargetAspect   aspect 1     =    new   PerTargetAspect (  )  ;", "aspect 1  . count    =     1  0  0  ;", "aspect 1  . setOrder (  1  0  )  ;", "advisors . addAll ( getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( aspect 1  ,     \" someBean 1  \"  )  )  )  ;", "PerTargetAspect   aspect 2     =    new   PerTargetAspect (  )  ;", "aspect 2  . setOrder (  5  )  ;", "advisors . addAll ( getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( aspect 2  ,     \" someBean 2  \"  )  )  )  ;", "Collections . sort ( advisors ,    new   OrderComparator (  )  )  ;", "TestBean   itb    =     (  ( TestBean )     ( createProxy ( target ,    advisors ,    TestBean . class )  )  )  ;", "assertEquals (  \" Around   advice   must   NOT   apply \"  ,    realAge ,    itb . getAge (  )  )  ;", "itb . getSpouse (  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     0  ,    itb . getAge (  )  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     1  ,    itb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiplePerTargetAspects"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "int   realAge    =     6  5  ;", "target . setAge ( realAge )  ;", "List < Advisor >    advisors    =    new   LinkedList <  >  (  )  ;", ". PerTargetAspectWithOrderAnnotation 1  0    aspect 1     =    new    . PerTargetAspectWithOrderAnnotation 1  0  (  )  ;", "aspect 1  . count    =     1  0  0  ;", "advisors . addAll ( getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( aspect 1  ,     \" someBean 1  \"  )  )  )  ;", ". PerTargetAspectWithOrderAnnotation 5    aspect 2     =    new    . PerTargetAspectWithOrderAnnotation 5  (  )  ;", "advisors . addAll ( getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( aspect 2  ,     \" someBean 2  \"  )  )  )  ;", "Collections . sort ( advisors ,    new   OrderComparator (  )  )  ;", "TestBean   itb    =     (  ( TestBean )     ( createProxy ( target ,    advisors ,    TestBean . class )  )  )  ;", "assertEquals (  \" Around   advice   must   NOT   apply \"  ,    realAge ,    itb . getAge (  )  )  ;", "itb . getSpouse (  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     0  ,    itb . getAge (  )  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     1  ,    itb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiplePerTargetAspectsWithOrderAnnotation"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "testNamedPointcuts ( new   AbstractAspectJAdvisorFactoryTests . NamedPointcutAspectWithFQN (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamedPointcutAspectWithFQN"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "testNamedPointcuts ( new   AbstractAspectJAdvisorFactoryTests . NamedPointcutAspectWithoutFQN (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamedPointcutAspectWithoutFQN"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "testNamedPointcuts ( new   AbstractAspectJAdvisorFactoryTests . NamedPointcutAspectFromLibrary (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamedPointcutFromAspectLibrary"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( createProxy ( target ,    getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new    . NamedPointcutAspectFromLibraryWithBinding (  )  ,     \" someBean \"  )  )  ,    ITestBean . class )  )  )  ;", "itb . setAge (  1  0  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     2  0  ,    itb . getAge (  )  )  ;", "assertEquals (  2  0  ,    target . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamedPointcutFromAspectLibraryWithBinding"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "int   realAge    =     6  5  ;", "target . setAge ( realAge )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( createProxy ( target ,    getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( aspectInstance ,     \" someBean \"  )  )  ,    ITestBean . class )  )  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     (  -  1  )  ,    itb . getAge (  )  )  ;", "assertEquals ( realAge ,    target . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNamedPointcuts"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "int   realAge    =     6  5  ;", "target . setAge ( realAge )  ;", "TestBean   itb    =     (  ( TestBean )     ( createProxy ( target ,    getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new   PerTargetAspect (  )  ,     \" someBean \"  )  )  ,    TestBean . class )  )  )  ;", "assertEquals (  \" Around   advice   must   NOT   apply \"  ,    realAge ,    itb . getAge (  )  )  ;", "Advised   advised    =     (  ( Advised )     ( itb )  )  ;", "Reflective . SyntheticInstantiationAdvisor   sia    =     (  ( Reflective . SyntheticInstantiationAdvisor )     ( advised . getAdvisors (  )  [  1  ]  )  )  ;", "assertTrue ( sia . getPointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getSpouse \"  )  ,    null )  )  ;", "InstantiationModelAwarePointcutAdvisorImpl   imapa    =     (  ( InstantiationModelAwarePointcutAdvisorImpl )     ( advised . getAdvisors (  )  [  3  ]  )  )  ;", "LazySingletonAspectInstanceFactoryDecorator   maaif    =     (  ( LazySingletonAspectInstanceFactoryDecorator )     ( imapa . getAspectInstanceFactory (  )  )  )  ;", "assertFalse ( maaif . isMaterialized (  )  )  ;", "assertTrue ( maaif . getAspectMetadata (  )  . getPerClausePointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getSpouse \"  )  ,    null )  )  ;", "assertNotSame ( imapa . getDeclaredPointcut (  )  ,    imapa . getPointcut (  )  )  ;", "itb . getSpouse (  )  ;", "assertTrue ( maaif . isMaterialized (  )  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     0  ,    itb . getAge (  )  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     1  ,    itb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerTargetAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "int   realAge    =     6  5  ;", "target . setAge ( realAge )  ;", "TestBean   itb    =     (  ( TestBean )     ( createProxy ( target ,    getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new   PerThisAspect (  )  ,     \" someBean \"  )  )  ,    TestBean . class )  )  )  ;", "assertEquals (  \" Around   advice   must   NOT   apply \"  ,    realAge ,    itb . getAge (  )  )  ;", "Advised   advised    =     (  ( Advised )     ( itb )  )  ;", "assertEquals (  4  ,    advised . getAdvisors (  )  . length )  ;", "Reflective . SyntheticInstantiationAdvisor   sia    =     (  ( Reflective . SyntheticInstantiationAdvisor )     ( advised . getAdvisors (  )  [  1  ]  )  )  ;", "assertTrue ( sia . getPointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getSpouse \"  )  ,    null )  )  ;", "InstantiationModelAwarePointcutAdvisorImpl   imapa    =     (  ( InstantiationModelAwarePointcutAdvisorImpl )     ( advised . getAdvisors (  )  [  2  ]  )  )  ;", "LazySingletonAspectInstanceFactoryDecorator   maaif    =     (  ( LazySingletonAspectInstanceFactoryDecorator )     ( imapa . getAspectInstanceFactory (  )  )  )  ;", "assertFalse ( maaif . isMaterialized (  )  )  ;", "assertTrue ( maaif . getAspectMetadata (  )  . getPerClausePointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getSpouse \"  )  ,    null )  )  ;", "assertNotSame ( imapa . getDeclaredPointcut (  )  ,    imapa . getPointcut (  )  )  ;", "itb . getSpouse (  )  ;", "assertTrue ( maaif . isMaterialized (  )  )  ;", "assertTrue ( imapa . getDeclaredPointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getAge \"  )  ,    null )  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     0  ,    itb . getAge (  )  )  ;", "assertEquals (  \" Around   advice   must   apply \"  ,     1  ,    itb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerThisAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "int   realAge    =     6  5  ;", "target . setAge ( realAge )  ;", ". PerTypeWithinAspectInstanceFactory   aif    =    new    . PerTypeWithinAspectInstanceFactory (  )  ;", "TestBean   itb    =     (  ( TestBean )     ( createProxy ( target ,    getFixture (  )  . getAdvisors ( aif )  ,    TestBean . class )  )  )  ;", "assertEquals (  \" No   method   calls \"  ,     0  ,    aif . getInstantiationCount (  )  )  ;", "assertEquals (  \" Around   advice   must   now   apply \"  ,     0  ,    itb . getAge (  )  )  ;", "Advised   advised    =     (  ( Advised )     ( itb )  )  ;", "assertEquals (  4  ,    advised . getAdvisors (  )  . length )  ;", "ReflectiveAspectJAdvisorFactory . SyntheticInstantiationAdvisor   sia    =     (  ( ReflectiveAspectJAdvisorFactory . SyntheticInstantiationAdvisor )     ( advised . getAdvisors (  )  [  1  ]  )  )  ;", "assertTrue ( sia . getPointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getSpouse \"  )  ,    null )  )  ;", "InstantiationModelAwarePointcutAdvisorImpl   imapa    =     (  ( InstantiationModelAwarePointcutAdvisorImpl )     ( advised . getAdvisors (  )  [  2  ]  )  )  ;", "LazySingletonAspectInstanceFactoryDecorator   maaif    =     (  ( LazySingletonAspectInstanceFactoryDecorator )     ( imapa . getAspectInstanceFactory (  )  )  )  ;", "assertTrue ( maaif . isMaterialized (  )  )  ;", "assertTrue ( maaif . getAspectMetadata (  )  . getPerClausePointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getSpouse \"  )  ,    null )  )  ;", "assertNotSame ( imapa . getDeclaredPointcut (  )  ,    imapa . getPointcut (  )  )  ;", "itb . getSpouse (  )  ;", "assertTrue ( maaif . isMaterialized (  )  )  ;", "assertTrue ( imapa . getDeclaredPointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getAge \"  )  ,    null )  )  ;", "assertEquals (  \" Around   advice   must   still   apply \"  ,     1  ,    itb . getAge (  )  )  ;", "assertEquals (  \" Around   advice   must   still   apply \"  ,     2  ,    itb . getAge (  )  )  ;", "TestBean   itb 2     =     (  ( TestBean )     ( createProxy ( target ,    getFixture (  )  . getAdvisors ( aif )  ,    TestBean . class )  )  )  ;", "assertEquals (  1  ,    aif . getInstantiationCount (  )  )  ;", "assertEquals (  \" Around   advice   be   independent   for   second   instance \"  ,     0  ,    itb 2  . getAge (  )  )  ;", "assertEquals (  2  ,    aif . getInstantiationCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerTypeWithinAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new    . PerCflowAspect (  )  ,     \" someBean \"  )  )  ;", "fail (  \" Cannot   accept   cflow \"  )  ;", "}    catch    ( AopConfigException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" PERCFLOW \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRejectsPerCflowAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "getFixture (  )  . getAdvisors ( new   SingletonMetadataAwareAspectInstanceFactory ( new    . PerCflowBelowAspect (  )  ,     \" someBean \"  )  )  ;", "fail (  \" Cannot   accept   cflowbelow \"  )  ;", "}    catch    ( AopConfigException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" PERCFLOWBELOW \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRejectsPerCflowBelowAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "TwoAdviceAspect   twoAdviceAspect    =    new   TwoAdviceAspect (  )  ;", "List <  >    advisors    =    getFixture (  )  . gets ( new   SingletonMetadataAwareAspectInstanceFactory ( twoAdviceAspect ,     \" someBean \"  )  )  ;", "assertEquals (  \" Two   advice   methods   found \"  ,     2  ,    advisors . size (  )  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( createProxy ( target ,    advisors ,    ITestBean . class )  )  )  ;", "itb . setName (  \"  \"  )  ;", "assertEquals (  0  ,    itb . getAge (  )  )  ;", "int   newAge    =     3  2  ;", "itb . setAge ( newAge )  ;", "assertEquals (  1  ,    itb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTwoAdvicesOnOneAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   getterName    =    setter . getName (  )  . replaceFirst (  \" set \"  ,     \" get \"  )  ;", "try    {", "return   setter . getDeclaringClass (  )  . getMethod ( getterName )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getGetterFromSetter"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractMakeModifiable"}, {"methodBody": ["METHOD_START", "{", "if    ( mixin . isModified (  )  )     {", "return ;", "}", "Method   correspondingGetter    =    getGetterFromSetter (  (  ( MethodSignature )     ( jp . getSignature (  )  )  )  . getMethod (  )  )  ;", "boolean   modified    =    true ;", "if    ( correspondingGetter    !  =    null )     {", "try    {", "Object   oldValue    =    correspondingGetter . invoke ( jp . getTarget (  )  )  ;", "modified    =     !  ( ObjectUtils . nullSafeEquals ( oldValue ,    newValue )  )  ;", "}    catch    ( Exception   ex )     {", "ex . printStackTrace (  )  ;", "}", "} else    {", "}", "if    ( modified )     {", "mixin . markDirty (  )  ;", "}", "}", "METHOD_END"], "methodName": ["recordModificationIfSetterArgumentDiffersFromOldValue"], "fileName": "org.springframework.aop.aspectj.annotation.AbstractMakeModifiable"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . includePatterns )     =  =    null )     {", "return   true ;", "} else    {", "for    ( Pattern   pattern    :    this . includePatterns )     {", "if    ( pattern . matcher ( beanN )  . matches (  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isEligibleAspectBean"], "fileName": "org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( aspectJAdvisorFactory ,     \" AspectJAdvisorFactory   must   not   be   null \"  )  ;", "this . aspectJAdvisorFactory    =    aspectJAdvisorFactory ;", "}", "METHOD_END"], "methodName": ["setAspectJAdvisorFactory"], "fileName": "org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "this . includePatterns    =    new   ArrayList <  >  ( patterns . size (  )  )  ;", "for    ( St   patternText    :    patterns )     {", "this . includePatterns . add ( Pattern . compile ( patternText )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setIncludePatterns"], "fileName": "org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "ArgumentBindingTests . TransactionalBean   tb    =    new   ArgumentBindingTests . TransactionalBean (  )  ;", "AspectJProxyFactory   proxyFactory    =    new   AspectJProxyFactory ( tb )  ;", "proxyFactory . addAspect ( PointcutWithAnnotationArgument . class )  ;", "ArgumentBindingTests . ITransactionalBean   proxiedTestBean    =    proxyFactory . getProxy (  )  ;", "proxiedTestBean . doInTransaction (  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationArgumentNameBinding"], "fileName": "org.springframework.aop.aspectj.annotation.ArgumentBindingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "AJProxyFactory   proxyFactory    =    new   AJProxyFactory ( tb )  ;", "proxyFactory . addA ( NamedPointcutWithArgs . class )  ;", "ITestBean   proxiedTestBean    =    proxyFactory . getProxy (  )  ;", "proxiedTestBean . setName (  \" Supercalifragalisticexpialidocious \"  )  ;", "}", "METHOD_END"], "methodName": ["testBindingInPointcutUsedByAdvice"], "fileName": "org.springframework.aop.aspectj.annotation.ArgumentBindingTests"}, {"methodBody": ["METHOD_START", "{", "AspectJAdviceParameterNameDiscoverer   discoverer    =    new   AspectJAdviceParameterNameDiscoverer (  \" somepc ( formal )     &  &    set (  *     *  )  \"  )  ;", "discoverer . setRaiseExceptions ( true )  ;", "Method   methodUsedForParameterTypeDiscovery    =    getClass (  )  . getMethod (  \" methodWithOneParam \"  ,    String . class )  ;", "String [  ]    pnames    =    discoverer . getParameterNames ( methodUsedForParameterTypeDiscovery )  ;", "assertEquals (  \" one   parameter   name \"  ,     1  ,    pnames . length )  ;", "assertEquals (  \" formal \"  ,    pnames [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testParameterNameDiscoverWithReferencePointcut"], "fileName": "org.springframework.aop.aspectj.annotation.ArgumentBindingTests"}, {"methodBody": ["METHOD_START", "{", "new   AspectMetadata ( c ,     \" someBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testIllegalInstantiationModel"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJPointcutAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "testIllegalInstantiationModel ( AbstractAspectJAdvisorFactoryTests . PerCflowBelowAspect . class )  ;", "}", "METHOD_END"], "methodName": ["testPerCflowBelowTarget"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJPointcutAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "testIllegalInstantiationModel ( AbstractAspectJAdvisorFactoryTests . PerCflowAspect . class )  ;", "}", "METHOD_END"], "methodName": ["testPerCflowTarget"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJPointcutAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "AspectJExpressionPointcut   ajexp    =    new   AspectJExpressionPointcut (  )  ;", "ajexp . setExpression ( AspectJExpressionPointcutTests . MATCH _ ALL _ METHODS )  ;", "InstantiationModelAwareImpl   ajpa    =    new   InstantiationModelAwareImpl ( ajexp ,    TestBean . class . getMethod (  \" getAge \"  )  ,    af ,    new   SingletonMetadataAwareAspectInstanceFactory ( new   PerTargetAspect (  )  ,     \" someBean \"  )  ,     1  ,     \" someBean \"  )  ;", "assertNotSame ( Pointcut . TRUE ,    ajpa . getAspectMetadata (  )  . getPerClausePointcut (  )  )  ;", "assertTrue (  (  ( ajpa . getAspectMetadata (  )  . getPerClausePointcut (  )  )    instanceof   AspectJExpressionPointcut )  )  ;", "assertTrue ( ajpa . isPerInstance (  )  )  ;", "assertTrue ( ajpa . getAspectMetadata (  )  . getPerClausePointcut (  )  . getClassFilter (  )  . matches ( TestBean . class )  )  ;", "assertFalse ( ajpa . getAspectMetadata (  )  . getPerClausePointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getAge \"  )  ,    TestBean . class )  )  ;", "assertTrue ( ajpa . getAspectMetadata (  )  . getPerClausePointcut (  )  . getMethodMatcher (  )  . matches ( TestBean . class . getMethod (  \" getSpouse \"  )  ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testPerTarget"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJPointcutAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "AspectJExpressionPointcut   ajexp    =    new   AspectJExpressionPointcut (  )  ;", "ajexp . setExpression ( AspectJExpressionPointcutTests . MATCH _ ALL _ METHODS )  ;", "InstantiationModelAwareImpl   ajpa    =    new   InstantiationModelAwareImpl ( ajexp ,    TestBean . class . getMethod (  \" getAge \"  )  ,    af ,    new   SingletonMetadataAwareAspectInstanceFactory ( new   AbstractAspectJAdvisorFactoryTests . ExceptionAspect ( null )  ,     \" someBean \"  )  ,     1  ,     \" someBean \"  )  ;", "assertSame ( Pointcut . TRUE ,    ajpa . getAspectMetadata (  )  . getPerClausePointcut (  )  )  ;", "assertFalse ( ajpa . isPerInstance (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSingleton"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJPointcutAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "List < Advisor >    advisors    =    this . aspectFactory . getAdvisors ( instanceFactory )  ;", "Class <  ?  >    targetClass    =    getTargetClass (  )  ;", "Assert . state (  ( targetClass    !  =    null )  ,     \" Unresolvable   target   class \"  )  ;", "advisors    =    AopUtils . findAdvisorsThatCanApply ( advisors ,    targetClass )  ;", "Utils . makeAdvisorChainAspectJCapableIfNecessary ( advisors )  ;", "AnnotationAwareOrderComparator . sort ( advisors )  ;", "addAdvisors ( advisors )  ;", "}", "METHOD_END"], "methodName": ["addAdvisorsFromAspectInstanceFactory"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJProxyFactory"}, {"methodBody": ["METHOD_START", "{", "String   aspectName    =    aspectClass . getName (  )  ;", "AspectMetadata   am    =    createAspectMetadata ( aspectClass ,    aspectName )  ;", "MetadataAwareAspectInstance   instance    =    createAspectInstance ( am ,    aspectClass ,    aspectName )  ;", "addAdvisorsFromAspectInstance ( instance )  ;", "}", "METHOD_END"], "methodName": ["addAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJProxyFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    aspectClass    =    aspectInstance . getClass (  )  ;", "String   aspectName    =    aspectClass . getName (  )  ;", "AspectMetadata   am    =    createAspectMetadata ( aspectClass ,    aspectName )  ;", "if    (  ( am . getAjType (  )  . getPerClause (  )  . getKind (  )  )     !  =     ( PerClauseKind . SINGLETON )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Aspect   class    [  \"     +     ( aspectClass . getName (  )  )  )     +     \"  ]    does   not   define   a   singleton   aspect \"  )  )  ;", "}", "addAdvisorsFromAspectInstance ( new   SingletonMetadataAwareAspectInstance ( aspectInstance ,    aspectName )  )  ;", "}", "METHOD_END"], "methodName": ["addAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJProxyFactory"}, {"methodBody": ["METHOD_START", "{", "MetadataAwareAspectInstanceFactory   instanceFactory ;", "if    (  ( am . getAjType (  )  . getPerClause (  )  . getKind (  )  )     =  =     ( PerClauseKind . SINGLETON )  )     {", "Object   instance    =    getSingletonAspectInstance ( aspectClass )  ;", "instanceFactory    =    new   SingletonMetadataAwareAspectInstanceFactory ( instance ,    aspectName )  ;", "} else    {", "instanceFactory    =    new   SimpleMetadataAwareAspectInstanceFactory ( aspectClass ,    aspectName )  ;", "}", "return   instanceFactory ;", "}", "METHOD_END"], "methodName": ["createAspectInstanceFactory"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJProxyFactory"}, {"methodBody": ["METHOD_START", "{", "AspectMetadata   am    =    new   AspectMetadata ( aspectClass ,    aspectName )  ;", "if    (  !  ( am . getAjType (  )  . isAspect (  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Class    [  \"     +     ( aspectClass . getName (  )  )  )     +     \"  ]    is   not   a   valid   aspect   type \"  )  )  ;", "}", "return   am ;", "}", "METHOD_END"], "methodName": ["createAspectMetadata"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJProxyFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( createAopProxy (  )  . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJProxyFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( createAopProxy (  )  . getProxy ( classLoader )  )  )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJProxyFactory"}, {"methodBody": ["METHOD_START", "{", "Object   instance    =    AspectJProxyFactory . aspectCache . get ( aspectClass )  ;", "if    ( instance    =  =    null )     {", "synchronized ( AspectJProxyFactory . aspectCache )     {", "instance    =    AspectJProxyFactory . aspectCache . get ( aspectClass )  ;", "if    ( instance    =  =    null )     {", "instance    =    new   SimpleAspectInstanceFactory ( aspectClass )  . getAspectInstance (  )  ;", "AspectJProxyFactory . aspectCache . put ( aspectClass ,    instance )  ;", "}", "}", "}", "return   instance ;", "}", "METHOD_END"], "methodName": ["getSingletonAspectInstance"], "fileName": "org.springframework.aop.aspectj.annotation.AspectJProxyFactory"}, {"methodBody": ["METHOD_START", "{", "String   str    =    aspectClass . getAnnotation ( Aspect . class )  . value (  )  ;", "str    =    str . substring (  (  ( str . indexOf (  '  (  '  )  )     +     1  )  )  ;", "str    =    str . substring (  0  ,     (  ( str . length (  )  )     -     1  )  )  ;", "return   str ;", "}", "METHOD_END"], "methodName": ["findPerClause"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadata"}, {"methodBody": ["METHOD_START", "{", "return   this . ajType ;", "}", "METHOD_END"], "methodName": ["getAjType"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadata"}, {"methodBody": ["METHOD_START", "{", "return   this . aspectClass ;", "}", "METHOD_END"], "methodName": ["getAspectClass"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadata"}, {"methodBody": ["METHOD_START", "{", "return   this . aspectName ;", "}", "METHOD_END"], "methodName": ["getAspectName"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadata"}, {"methodBody": ["METHOD_START", "{", "return   this . perClausePointcut ;", "}", "METHOD_END"], "methodName": ["getPerClausePointcut"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadata"}, {"methodBody": ["METHOD_START", "{", "return    ( isPerThisOrPerTarget (  )  )     |  |     ( isPerTypeWithin (  )  )  ;", "}", "METHOD_END"], "methodName": ["isLazilyInstantiated"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadata"}, {"methodBody": ["METHOD_START", "{", "PerClauseKind   kind    =    getAjType (  )  . getPerClause (  )  . getKind (  )  ;", "return    ( kind    =  =     ( PerClauseKind . PERTARGET )  )     |  |     ( kind    =  =     ( PerClauseKind . PERTHIS )  )  ;", "}", "METHOD_END"], "methodName": ["isPerThisOrPerTarget"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadata"}, {"methodBody": ["METHOD_START", "{", "PerClauseKind   kind    =    getAjType (  )  . getPerClause (  )  . getKind (  )  ;", "return   kind    =  =     ( PerClauseKind . PERTYPEWITHIN )  ;", "}", "METHOD_END"], "methodName": ["isPerTypeWithin"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadata"}, {"methodBody": ["METHOD_START", "{", "inputStream . defaultReadObject (  )  ;", "this . ajType    =    AjTypeSystem . getAjType ( thisClass )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadata"}, {"methodBody": ["METHOD_START", "{", "new   AspectMetadata ( String . class ,     \" someBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testNotAnAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AspectMetadata   am    =    new   AspectMetadata ( PerTargetAspect . class ,     \" someBean \"  )  ;", "assertTrue ( am . isPerThisOrPerTarget (  )  )  ;", "assertNotSame ( Pointcut . TRUE ,    am . getPerClausePointcut (  )  )  ;", "assertEquals ( PERTARGET ,    am . getAjType (  )  . getPerClause (  )  . getKind (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerTargetAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AspectMetadata   am    =    new   AspectMetadata ( PerThisAspect . class ,     \" someBean \"  )  ;", "assertTrue ( am . isPerThisOrPerTarget (  )  )  ;", "assertNotSame ( Pointcut . TRUE ,    am . getPerClausePointcut (  )  )  ;", "assertEquals ( PERTHIS ,    am . getAjType (  )  . getPerClause (  )  . getKind (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerThisAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AspectMetadata   am    =    new   AspectMetadata ( AbstractAspectJAdvisorFactoryTests . ExceptionAspect . class ,     \" someBean \"  )  ;", "assertFalse ( am . isPerThisOrPerTarget (  )  )  ;", "assertSame ( Pointcut . TRUE ,    am . getPerClausePointcut (  )  )  ;", "assertEquals ( SINGLETON ,    am . getAjType (  )  . getPerClause (  )  . getKind (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSingletonAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AspectJProxyFactory   proxyFactory    =    new   AspectJProxyFactory ( new   AspectProxyFactoryTests . TestBean (  )  )  ;", "proxyFactory . addAspect ( AspectProxyFactoryTests . LoggingAspectOnVarargs . class )  ;", "AspectProxyFactoryTests . ITestBean   proxy    =    proxyFactory . getProxy (  )  ;", "assertTrue ( proxy . doWithVarargs ( AspectProxyFactoryTests . MyEnum . A ,    AspectProxyFactoryTests . MyOtherEnum . C )  )  ;", "}", "METHOD_END"], "methodName": ["testProxiedVarargsWithEnumArray"], "fileName": "org.springframework.aop.aspectj.annotation.AspectProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AspectJProxyFactory   proxyFactory    =    new   AspectJProxyFactory ( new   AspectProxyFactoryTests . TestBean (  )  )  ;", "proxyFactory . addAspect ( AspectProxyFactoryTests . LoggingAspectOnVarargs . class )  ;", "AspectProxyFactoryTests . ITestBean   proxy    =    proxyFactory . getProxy (  )  ;", "assertTrue ( proxy . doWithVarargs ( AspectProxyFactoryTests . MyEnum . A ,    AspectProxyFactoryTests . MyOtherEnum . C )  )  ;", "AspectProxyFactoryTests . ITestBean   tb    =     (  ( AspectProxyFactoryTests . ITestBean )     ( SerializationTestUtils . serializeAndDeserialize ( proxy )  )  )  ;", "assertTrue ( tb . doWithVarargs ( AspectProxyFactoryTests . MyEnum . A ,    AspectProxyFactoryTests . MyOtherEnum . C )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializable"], "fileName": "org.springframework.aop.aspectj.annotation.AspectProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AspectJProxyFactory   proxyFactory    =    new   AspectJProxyFactory ( new   AspectProxyFactoryTests . TestBean (  )  )  ;", "proxyFactory . addAspect ( AspectProxyFactoryTests . LoggingAspectOnSetter . class )  ;", "AspectProxyFactoryTests . ITestBean   proxy    =    proxyFactory . getProxy (  )  ;", "assertTrue ( proxy . doWithVarargs ( AspectProxyFactoryTests . MyEnum . A ,    AspectProxyFactoryTests . MyOtherEnum . C )  )  ;", "}", "METHOD_END"], "methodName": ["testUnproxiedVarargsWithEnumArray"], "fileName": "org.springframework.aop.aspectj.annotation.AspectProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "MultiplyReturnValue   aspect    =    new   MultiplyReturnValue (  )  ;", "int   multiple    =     3  ;", "aspect . setMultiple ( multiple )  ;", ". TestBean   target    =    new    . TestBean (  )  ;", "target . setAge (  2  4  )  ;", "AspectJProxyFactory   proxyFactory    =    new   AspectJProxyFactory ( target )  ;", "proxyFactory . addAspect ( aspect )  ;", ". ITestBean   proxy    =    proxyFactory . getProxy (  )  ;", "assertEquals (  (  ( target . getAge (  )  )     *    multiple )  ,    proxy . getAge (  )  )  ;", ". ITestBean   serializedProxy    =     (  (  . ITestBean )     ( SerializationTestUtils . serializeAndDeserialize ( proxy )  )  )  ;", "assertEquals (  (  ( target . getAge (  )  )     *    multiple )  ,    serializedProxy . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithInstance"], "fileName": "org.springframework.aop.aspectj.annotation.AspectProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AspectJProxyFactory   pf    =    new   AspectJProxyFactory (  )  ;", "pf . addAspect ( new    . TestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithInstanceWithNonAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AspectJProxyFactory   proxyFactory    =    new   AspectJProxyFactory ( new   AspectProxyFactoryTests . TestBean (  )  )  ;", "proxyFactory . addAspect ( AspectProxyFactoryTests . TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testWithNonAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AspectJProxyFactory   pf    =    new   AspectJProxyFactory (  )  ;", "pf . addAspect ( new   PerThisAspect (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithNonSingletonAspectInstance"], "fileName": "org.springframework.aop.aspectj.annotation.AspectProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AspectProxyFactoryTests . TestBean   bean 1     =    new   AspectProxyFactoryTests . TestBean (  )  ;", "AspectProxyFactoryTests . TestBean   bean 2     =    new   AspectProxyFactoryTests . TestBean (  )  ;", "AspectJProxyFactory   pf 1     =    new   AspectJProxyFactory ( bean 1  )  ;", "pf 1  . addAspect ( PerThisAspect . class )  ;", "AspectJProxyFactory   pf 2     =    new   AspectJProxyFactory ( bean 2  )  ;", "pf 2  . addAspect ( PerThisAspect . class )  ;", "AspectProxyFactoryTests . ITestBean   proxy 1     =    pf 1  . getProxy (  )  ;", "AspectProxyFactoryTests . ITestBean   proxy 2     =    pf 2  . getProxy (  )  ;", "assertEquals (  0  ,    proxy 1  . getAge (  )  )  ;", "assertEquals (  1  ,    proxy 1  . getAge (  )  )  ;", "assertEquals (  0  ,    proxy 2  . getAge (  )  )  ;", "assertEquals (  2  ,    proxy 1  . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithPerThisAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "AspectProxyFactoryTests . TestBean   bean    =    new   AspectProxyFactoryTests . TestBean (  )  ;", "bean . setAge (  2  )  ;", "AspectJProxyFactory   proxyFactory    =    new   AspectJProxyFactory ( bean )  ;", "proxyFactory . addAspect ( MultiplyReturnValue . class )  ;", "AspectProxyFactoryTests . ITestBean   proxy    =    proxyFactory . getProxy (  )  ;", "assertEquals (  \" Multiplication   did   not   occur \"  ,     (  ( bean . getAge (  )  )     *     2  )  ,    proxy . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithSimpleAspect"], "fileName": "org.springframework.aop.aspectj.annotation.AspectProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    aspectNames    =    this . aspectBeanNames ;", "if    ( aspectNames    =  =    null )     {", "synchronized ( this )     {", "aspectNames    =    this . aspectBeanNames ;", "if    ( aspectNames    =  =    null )     {", "List < Advisor >    advisors    =    new   LinkedList <  >  (  )  ;", "aspectNames    =    new   LinkedList <  >  (  )  ;", "String [  ]    beanNames    =    BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( this . beanFactory ,    Object . class ,    true ,    false )  ;", "for    ( String   beanName    :    beanNames )     {", "if    (  !  ( isEligibleBean ( beanName )  )  )     {", "continue ;", "}", "Class <  ?  >    beanType    =    this . beanFactory . getType ( beanName )  ;", "if    ( beanType    =  =    null )     {", "continue ;", "}", "if    ( this . advisorFactory . isAspect ( beanType )  )     {", "aspectNames . add ( beanName )  ;", "AspectMetadata   amd    =    new   AspectMetadata ( beanType ,    beanName )  ;", "if    (  ( amd . getAjType (  )  . getPerClause (  )  . getKind (  )  )     =  =     ( PerClauseKind . SINGLETON )  )     {", "MetadataAwareAspectInstanceFactory   factory    =    new   InstanceFactory ( this . beanFactory ,    beanName )  ;", "List < Advisor >    classAdvisors    =    this . advisorFactory . getAdvisors ( factory )  ;", "if    ( this . beanFactory . isSingleton ( beanName )  )     {", "this . advisorsCache . put ( beanName ,    classAdvisors )  ;", "} else    {", "this . aspectFactoryCache . put ( beanName ,    factory )  ;", "}", "advisors . addAll ( classAdvisors )  ;", "} else    {", "if    ( this . beanFactory . isSingleton ( beanName )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Bean   with   name    '  \"     +    beanName )     +     \"  '    is   a   singleton ,    but   aspect   instantiation   model   is   not   singleton \"  )  )  ;", "}", "MetadataAwareAspectInstanceFactory   factory    =    new   PrototypeAspectInstanceFactory ( this . beanFactory ,    beanName )  ;", "this . aspectFactoryCache . put ( beanName ,    factory )  ;", "advisors . addAll ( this . advisorFactory . getAdvisors ( factory )  )  ;", "}", "}", "}", "this . aspectBeanNames    =    aspectNames ;", "return   advisors ;", "}", "}", "}", "if    ( aspectNames . isEmpty (  )  )     {", "return   Collections . emptyList (  )  ;", "}", "List < Advisor >    advisors    =    new   LinkedList <  >  (  )  ;", "for    ( String   aspectName    :    aspectNames )     {", "List < Advisor >    cachedAdvisors    =    this . advisorsCache . get ( aspectName )  ;", "if    ( cachedAdvisors    !  =    null )     {", "advisors . addAll ( cachedAdvisors )  ;", "} else    {", "MetadataAwareAspectInstanceFactory   factory    =    this . aspectFactoryCache . get ( aspectName )  ;", "advisors . addAll ( this . advisorFactory . getAdvisors ( factory )  )  ;", "}", "}", "return   advisors ;", "}", "METHOD_END"], "methodName": ["buildAspectJAdvisors"], "fileName": "org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isEligibleBean"], "fileName": "org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder"}, {"methodBody": ["METHOD_START", "{", "AbstractAspectJAdvisorFactory . AspectJA ?  >    aspectJA =    AbstractAspectJAdvisorFactory . findAspectJAnMethod ( this . aspectJAdviceMethod )  ;", "if    ( aspectJA =  =    null )     {", "this . isBeforeAdvice    =    false ;", "this . isAfterAdvice    =    false ;", "} else    {", "switch    ( aspectJAgetAype (  )  )     {", "case   AtAfter    :", "case   AtAfterReturning    :", "case   AtAfterThrowing    :", "this . isAfterAdvice    =    true ;", "this . isBeforeAdvice    =    false ;", "break ;", "case   AtAround    :", "case   AtPointcut    :", "this . isAfterAdvice    =    false ;", "this . isBeforeAdvice    =    false ;", "break ;", "case   AtBefore    :", "this . isAfterAdvice    =    false ;", "this . isBeforeAdvice    =    true ;", "}", "}", "}", "METHOD_END"], "methodName": ["determineAdviceType"], "fileName": "org.springframework.aop.aspectj.annotation.InstantiationModelAwarePointcutAdvisorImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . aspectInstanceFactory ;", "}", "METHOD_END"], "methodName": ["getAspectInstanceFactory"], "fileName": "org.springframework.aop.aspectj.annotation.InstantiationModelAwarePointcutAdvisorImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . aspectInstanceFactory . getAspectMetadata (  )  ;", "}", "METHOD_END"], "methodName": ["getAspectMetadata"], "fileName": "org.springframework.aop.aspectj.annotation.InstantiationModelAwarePointcutAdvisorImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . declaredPointcut ;", "}", "METHOD_END"], "methodName": ["getDeclaredPointcut"], "fileName": "org.springframework.aop.aspectj.annotation.InstantiationModelAwarePointcutAdvisorImpl"}, {"methodBody": ["METHOD_START", "{", "Advice   advice    =    this . aspectJAdvisorFactory . getAdvice ( this . aspectJAdviceMethod ,    pointcut ,    this . aspectInstanceFactory ,    this . declarationOrder ,    this . aspectName )  ;", "return   advice    !  =    null    ?    advice    :     . EMPTY _ ADVICE ;", "}", "METHOD_END"], "methodName": ["instantiateAdvice"], "fileName": "org.springframework.aop.aspectj.annotation.InstantiationModelAwarePointcutAdvisorImpl"}, {"methodBody": ["METHOD_START", "{", "inputStream . defaultReadObject (  )  ;", "try    {", "thisJAdviceMethod    =    this . declaringClass . getMethod ( this . methodName ,    this . parameterTypes )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   IllegalStateException (  \" Failed   to   find   advice   method   on   deserialization \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.aop.aspectj.annotation.InstantiationModelAwarePointcutAdvisorImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( this . materialized )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isMaterialized"], "fileName": "org.springframework.aop.aspectj.annotation.LazySingletonAspectInstanceFactoryDecorator"}, {"methodBody": ["METHOD_START", "{", "if    ( mixin . locked (  )  )     {", "throw   new   IllegalStateExcep (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkNotLocked"], "fileName": "org.springframework.aop.aspectj.annotation.MakeLockable"}, {"methodBody": ["METHOD_START", "{", "+  +  ( this . invocations )  ;", "int   result    =     (  ( Integer )     ( pjp . proceed (  )  )  )  ;", "return   result    *     ( this . me )  ;", "}", "METHOD_END"], "methodName": ["doubleReturnValue"], "fileName": "org.springframework.aop.aspectj.annotation.MultiplyReturnValue"}, {"methodBody": ["METHOD_START", "{", "return   this . multiple ;", "}", "METHOD_END"], "methodName": ["getMultiple"], "fileName": "org.springframework.aop.aspectj.annotation.MultiplyReturnValue"}, {"methodBody": ["METHOD_START", "{", "this . multiple    =    multiple ;", "}", "METHOD_END"], "methodName": ["setMultiple"], "fileName": "org.springframework.aop.aspectj.annotation.MultiplyReturnValue"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  (  (  (  \" got    '  \"     +    aString )     +     \"  '    at    '  \"  )     +    pjp )     +     \"  '  \"  )  )  ;", "throw   new   IllegalArgumentException ( aString )  ;", "}", "METHOD_END"], "methodName": ["doAround"], "fileName": "org.springframework.aop.aspectj.annotation.NamedPointcutWithArgs"}, {"methodBody": ["METHOD_START", "{", "return   this . nonAspectClass ;", "}", "METHOD_END"], "methodName": ["getNonAspectClass"], "fileName": "org.springframework.aop.aspectj.annotation.NotAnAtAspectException"}, {"methodBody": ["METHOD_START", "{", "return   intValue ;", "}", "METHOD_END"], "methodName": ["getIntValue"], "fileName": "org.springframework.aop.aspectj.annotation.NotLockable"}, {"methodBody": ["METHOD_START", "{", "this . intValue    =    intValue ;", "}", "METHOD_END"], "methodName": ["setIntValue"], "fileName": "org.springframework.aop.aspectj.annotation.NotLockable"}, {"methodBody": ["METHOD_START", "{", "+  +  ( count )  ;", "}", "METHOD_END"], "methodName": ["countSetter"], "fileName": "org.springframework.aop.aspectj.annotation.PerThisAspect"}, {"methodBody": ["METHOD_START", "{", "return    ( count )  +  +  ;", "}", "METHOD_END"], "methodName": ["returnCountAsAge"], "fileName": "org.springframework.aop.aspectj.annotation.PerThisAspect"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  \" Invoked   with   transaction    \"     +    transaction )  )  ;", "throw   new   IllegalStateException (  )  ;", "}", "METHOD_END"], "methodName": ["around"], "fileName": "org.springframework.aop.aspectj.annotation.PointcutWithAnnotationArgument"}, {"methodBody": ["METHOD_START", "{", "final   List < Method >    methods    =    new   LinkedList <  >  (  )  ;", "ReflectionUtils . doWithMethods ( aspectClass ,     (    method )     -  >     {", "if    (  ( AnnotationUtils . getAnnotation ( method ,     . class )  )     =  =    null )     {", "methods . add ( method )  ;", "}", "}  )  ;", "methods . sort (  . METHOD _ COMPARATOR )  ;", "return   methods ;", "}", "METHOD_END"], "methodName": ["getAdvisorMethods"], "fileName": "org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory"}, {"methodBody": ["METHOD_START", "{", "DeclareParents   declareParents    =    introductionField . getAnnotation ( DeclareParents . class )  ;", "if    ( declareParents    =  =    null )     {", "return   null ;", "}", "if    (  ( DeclareParents . class )     =  =     ( declareParents . defaultImpl (  )  )  )     {", "throw   new   IllegalStateException (  \"  ' defaultImpl '    attribute   must   be   set   on   DeclareParents \"  )  ;", "}", "return   new   DeclareParentsAdvisor ( introductionField . getType (  )  ,    declareParents . value (  )  ,    declareParents . defaultImpl (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDeclareParentsAdvisor"], "fileName": "org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory"}, {"methodBody": ["METHOD_START", "{", "AbstractAspectJAdvisorFactory . AspectJAnnotation <  ?  >    aspectJAnnotation    =    AbstractAspectJAdvisorFactory . findAspectJAnnotationOnMethod ( candidateAdviceMethod )  ;", "if    ( aspectJAnnotation    =  =    null )     {", "return   null ;", "}", "AspectJExpressionPointcut   ajexp    =    new   AspectJExpressionPointcut ( candidateAspectClass ,    new   String [  0  ]  ,    new   Class <  ?  >  [  0  ]  )  ;", "ajexp . setExpression ( aspectJAnnotation . getPointcutExpression (  )  )  ;", "if    (  ( this . beanFactory )     !  =    null )     {", "ajexp . setBeanFactory ( this . beanFactory )  ;", "}", "return   ajexp ;", "}", "METHOD_END"], "methodName": ["getPointcut"], "fileName": "org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory"}, {"methodBody": ["METHOD_START", "{", "SourceExtractor   sourceExtractor    =    new   PassThroughSourceExtractor (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . registry )  ;", "XmlReaderContext   readerContext    =    new   XmlReaderContext ( null ,    null ,    this . readerEventListener ,    sourceExtractor ,    reader ,    null )  ;", "this . parserContext    =    new   beans . factory . xml . ParserContext ( readerContext ,    null )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AopNamespaceUtils . registerAspectJAutoProxyCreatorIfNecessary ( this . parserContext ,    null )  ;", "assertEquals (  \" Incorrect   number   of   definitions   registered \"  ,     1  ,    registry . getBeanDefinitionCount (  )  )  ;", "AopNamespaceUtils . registerAspectJAutoProxyCreatorIfNecessary ( this . parserContext ,    null )  ;", "assertEquals (  \" Incorrect   number   of   definitions   registered \"  ,     1  ,    registry . getBeanDefinitionCount (  )  )  ;", "BeanDefinition   definition    =    registry . getBeanDefinition ( AopConfigUtils . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  ;", "assertEquals (  \" Incorrect   APC   class \"  ,    AspectJAwareAdvisorAutoProxyCreator . class . getName (  )  ,    definition . getBeanClassName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterAspectJAutoProxyCreator"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AopNamespaceUtils . registerAutoProxyCreatorIfNecessary ( this . parserContext ,    null )  ;", "assertEquals (  1  ,    registry . getBeanDefinitionCount (  )  )  ;", "AopNamespaceUtils . registerAspectJAutoProxyCreatorIfNecessary ( this . parserContext ,    null )  ;", "assertEquals (  \" Incorrect   definition   count \"  ,     1  ,    registry . getBeanDefinitionCount (  )  )  ;", "BeanDefinition   definition    =    registry . getBeanDefinition ( AopConfigUtils . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  ;", "assertEquals (  \" APC   class   not   switched \"  ,    AspectJAwareAdvisorAutoProxyCreator . class . getName (  )  ,    definition . getBeanClassName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterAspectJAutoProxyCreatorWithExistingAutoProxyCreator"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AopNamespaceUtils . registerAutoProxyCreatorIfNecessary ( this . parserContext ,    null )  ;", "assertEquals (  \" Incorrect   number   of   definitions   registered \"  ,     1  ,    registry . getBeanDefinitionCount (  )  )  ;", "AopNamespaceUtils . registerAspectJAutoProxyCreatorIfNecessary ( this . parserContext ,    null )  ;", "assertEquals (  \" Incorrect   number   of   definitions   registered \"  ,     1  ,    registry . getBeanDefinitionCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterAutoProxyCreator"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AopNamespaceUtils . registerAspectJAutoProxyCreatorIfNecessary ( this . parserContext ,    null )  ;", "assertEquals (  1  ,    registry . getBeanDefinitionCount (  )  )  ;", "AopNamespaceUtils . registerAutoProxyCreatorIfNecessary ( this . parserContext ,    null )  ;", "assertEquals (  \" Incorrect   definition   count \"  ,     1  ,    registry . getBeanDefinitionCount (  )  )  ;", "BeanDefinition   definition    =    registry . getBeanDefinition ( AopConfigUtils . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  ;", "assertEquals (  \" Incorrect   APC   class \"  ,    AspectJAwareAdvisorAutoProxyCreator . class . getName (  )  ,    definition . getBeanClassName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterAutoProxyCreatorWhenAspectJAutoProxyCreatorAlreadyExists"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "boolean   oneOrOtherIsAfterAdvice    =     ( AspectJAopUtils . isAfterAdvice ( advisor 1  )  )     |  |     ( AspectJAopUtils . isAfterAdvice ( advisor 2  )  )  ;", "int   adviceDeclarationOrderDelta    =     ( getAspectDeclarationOrder ( advisor 1  )  )     -     ( getAspectDeclarationOrder ( advisor 2  )  )  ;", "if    ( oneOrOtherIsAfterAdvice )     {", "if    ( adviceDeclarationOrderDelta    <     0  )     {", "return    . LOWER _ PRECEDENCE ;", "} else", "if    ( adviceDeclarationOrderDelta    =  =     0  )     {", "return    . SAME _ PRECEDENCE ;", "} else    {", "return    . HIGHER _ PRECEDENCE ;", "}", "} else    {", "if    ( adviceDeclarationOrderDelta    <     0  )     {", "return    . HIGHER _ PRECEDENCE ;", "} else", "if    ( adviceDeclarationOrderDelta    =  =     0  )     {", "return    . SAME _ PRECEDENCE ;", "} else    {", "return    . LOWER _ PRECEDENCE ;", "}", "}", "}", "METHOD_END"], "methodName": ["comparePrecedenceWithinAspect"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparator"}, {"methodBody": ["METHOD_START", "{", "return    (  ( hasAspectName ( advisor 1  )  )     &  &     ( hasAspectName ( advisor 2  )  )  )     &  &     ( getAspectName ( advisor 1  )  . equals ( getAspectName ( advisor 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["declaredInSameAspect"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparator"}, {"methodBody": ["METHOD_START", "{", "AspectJPrecedenceInformation   precedenceInfo    =    AspectJAopUtils . getAspectJPrecedenceInformationFor ( anAdvisor )  ;", "if    ( precedenceInfo    !  =    null )     {", "return   precedenceInfo . getDeclarationOrder (  )  ;", "} else    {", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["getAspectDeclarationOrder"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparator"}, {"methodBody": ["METHOD_START", "{", "AspectJPrecedenceInformation   pi    =    AspectJAopUtils . getAspectJPrecedenceInformationFor ( anAdvisor )  ;", "Assert . state (  ( pi    !  =    null )  ,     \" Unresolvable   precedence   information \"  )  ;", "return   pi . getAspectName (  )  ;", "}", "METHOD_END"], "methodName": ["getAspectName"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparator"}, {"methodBody": ["METHOD_START", "{", "return    ( anAdvisor   instanceof   AspectJPrecedenceInformation )     |  |     (  ( anAdvisor . getAdvice (  )  )    instanceof   AspectJPrecedenceInformation )  ;", "}", "METHOD_END"], "methodName": ["hasAspectName"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparator"}, {"methodBody": ["METHOD_START", "{", "advice . setDeclarationOrder ( adviceDeclarationOrder )  ;", "advice . setAspectName ( aspectName )  ;", "ointcutAdvisor   advisor    =    new   ointcutAdvisor ( advice )  ;", "advisor . setOrder ( advisorOrder )  ;", "return   advisor ;", "}", "METHOD_END"], "methodName": ["createAspectJAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "AspectJAfterAdvice   advice    =    new   AspectJAfterAdvice ( this . anyOldMethod ,    this . anyOldPointcut ,    null )  ;", "return   createAspectJAdvice ( advisorOrder ,    adviceDeclarationOrder ,    aspectName ,    advice )  ;", "}", "METHOD_END"], "methodName": ["createAspectJAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "AspectJAfterReturningAdvice   advice    =    new   AspectJAfterReturningAdvice ( this . anyOldMethod ,    this . anyOldPointcut ,    null )  ;", "return   createAspectJAdvice ( advisorOrder ,    adviceDeclarationOrder ,    aspectName ,    advice )  ;", "}", "METHOD_END"], "methodName": ["createAspectJAfterReturningAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "AspectJAfterThrowingAdvice   advice    =    new   AspectJAfterThrowingAdvice ( this . anyOldMethod ,    this . anyOldPointcut ,    null )  ;", "return   createAspectJAdvice ( advisorOrder ,    adviceDeclarationOrder ,    aspectName ,    advice )  ;", "}", "METHOD_END"], "methodName": ["createAspectJAfterThrowingAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "AspectJAroundAdvice   advice    =    new   AspectJAroundAdvice ( this . anyOldMethod ,    this . anyOldPointcut ,    null )  ;", "return   createAspectJAdvice ( advisorOrder ,    adviceDeclarationOrder ,    aspectName ,    advice )  ;", "}", "METHOD_END"], "methodName": ["createAspectJAroundAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "AspectJMethodBeforeAdvice   advice    =    new   AspectJMethodBeforeAdvice ( this . anyOldMethod ,    this . anyOldPointcut ,    null )  ;", "return   createAspectJAdvice ( advisorOrder ,    adviceDeclarationOrder ,    aspectName ,    advice )  ;", "}", "METHOD_END"], "methodName": ["createAspectJBeforeAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "AfterReturningAdvice   advice    =    new   AfterReturningAdvice (  )     {", "@ Override", "public   void   afterReturning (  @ Nullable", "Object   returnValue ,    Method   method ,    Object [  ]    args ,     @ Nullable", "Object   target )    throws   Throwable    {", "}", "}  ;", "DefaultPointcutAdvisor   advisor    =    new   DefaultPointcutAdvisor ( this . anyOldPointcut ,    advice )  ;", "advisor . setOrder ( order )  ;", "return   advisor ;", "}", "METHOD_END"], "methodName": ["createSpringAOPAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "BeforeAdvice   advice    =    new   BeforeAdvice (  )     {  }  ;", "DefaultPointcutAdvisor   advisor    =    new   DefaultPointcutAdvisor ( this . anyOldPointcut ,    advice )  ;", "advisor . setOrder ( order )  ;", "return   advisor ;", "}", "METHOD_END"], "methodName": ["createSpringAOPBeforeAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "this . comparator    =    new   AspectJPrecedenceComparator (  )  ;", "this . anyOldMethod    =    getClass (  )  . getMethods (  )  [  0  ]  ;", "this . anyOldPointcut    =    new   AspectJExpressionPointcut (  )  ;", "this . anyOldPointcut . setExpression (  \" execution (  *     *  (  .  .  )  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor 1     =    createAspectJAfterAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "Advisor   advisor 2     =    createAspectJAroundAdvice ( AspectJPrecedenceComparatorTests . LOW _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" advisor 1    sorted   before   advisor 2  \"  ,     (  -  1  )  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "advisor 1     =    createAspectJAfterReturningAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "advisor 2     =    createAspectJAfterThrowingAdvice ( AspectJPrecedenceComparatorTests . LOW _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" advisor 2    sorted   after   advisor 1  \"  ,     (  -  1  )  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testHigherAdvisorPrecedenceAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor 1     =    createSpringAOPBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER )  ;", "Advisor   advisor 2     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . LOW _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" advisor 1    sorted   before   advisor 2  \"  ,     (  -  1  )  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "advisor 1     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "advisor 2     =    createAspectJAroundAdvice ( AspectJPrecedenceComparatorTests . LOW _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" advisor 1    sorted   before   advisor 2  \"  ,     (  -  1  )  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testHigherAdvisorPrecedenceNoAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor 1     =    createAspectJAfterAdvice ( AspectJPrecedenceComparatorTests . LOW _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "Advisor   advisor 2     =    createAspectJAroundAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" advisor 1    sorted   after   advisor 2  \"  ,     1  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "advisor 1     =    createSpringAOPAfterAdvice ( AspectJPrecedenceComparatorTests . LOW _ PRECEDENCE _ ADVISOR _ ORDER )  ;", "advisor 2     =    createAspectJAfterThrowingAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" advisor 1    sorted   after   advisor 2  \"  ,     1  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testLowerAdvisorPrecedenceAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor 1     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . LOW _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "Advisor   advisor 2     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" advisor 1    sorted   after   advisor 2  \"  ,     1  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "advisor 1     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . LOW _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "advisor 2     =    createAspectJAroundAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" advisor 1    sorted   after   advisor 2  \"  ,     1  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testLowerAdvisorPrecedenceNoAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor 1     =    createAspectJAfterAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "Advisor   advisor 2     =    createAspectJAroundAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" nothing   to   say   about   order   here \"  ,     0  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "advisor 1     =    createAspectJAfterReturningAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "advisor 2     =    createAspectJAfterThrowingAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" nothing   to   say   about   order   here \"  ,     0  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSameAdvisorPrecedenceDifferentAspectAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor 1     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "Advisor   advisor 2     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" nothing   to   say   about   order   here \"  ,     0  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "advisor 1     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "advisor 2     =    createAspectJAroundAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someOtherAspect \"  )  ;", "assertEquals (  \" nothing   to   say   about   order   here \"  ,     0  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSameAdvisorPrecedenceDifferentAspectNoAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor 1     =    createAspectJAfterAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "Advisor   advisor 2     =    createAspectJAroundAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "assertEquals (  \" advisor 2    sorted   before   advisor 1  \"  ,     1  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "advisor 1     =    createAspectJAfterReturningAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "advisor 2     =    createAspectJAfterThrowingAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "assertEquals (  \" advisor 1    sorted   before   advisor 2  \"  ,     (  -  1  )  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSameAspectAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor 1     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "Advisor   advisor 2     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "assertEquals (  \" advisor 1    sorted   before   advisor 2  \"  ,     (  -  1  )  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "advisor 1     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "advisor 2     =    createAspectJAroundAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "assertEquals (  \" advisor 2    sorted   before   advisor 1  \"  ,     1  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSameAspectNoAfterAdvice"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor 1     =    createAspectJAfterAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . EARLY _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "Advisor   advisor 2     =    createAspectJBeforeAdvice ( AspectJPrecedenceComparatorTests . HIGH _ PRECEDENCE _ ADVISOR _ ORDER ,    AspectJPrecedenceComparatorTests . LATE _ ADVICE _ DECLARATION _ ORDER ,     \" someAspect \"  )  ;", "assertEquals (  \" advisor 1    and   advisor 2    not   comparable \"  ,     1  ,    this . comparator . compare ( advisor 1  ,    advisor 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSameAspectOneOfEach"], "fileName": "org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =     (  ( List < String >  )     ( beanDefinition . getPropertyValues (  )  . get (  \" interceptorNames \"  )  )  )  ;", "Assert . state (  ( list    !  =    null )  ,     \" Missing    ' interceptorNames '    property \"  )  ;", "list . add ( interceptorName )  ;", "}", "METHOD_END"], "methodName": ["addInterceptorNameToList"], "fileName": "org.springframework.aop.config.AbstractInterceptorDrivenBeanDefinitionDecorator"}, {"methodBody": ["METHOD_START", "{", "String   beanClassName    =    interceptorDefinition . getBeanClassName (  )  ;", "return   StringUtils . hasLength ( beanClassName )     ?    StringUtils . uncapitalize ( ClassUtils . getShortName ( beanClassName )  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getInterceptorNameSuffix"], "fileName": "org.springframework.aop.config.AbstractInterceptorDrivenBeanDefinitionDecorator"}, {"methodBody": ["METHOD_START", "{", "return   ProxyFactoryBean . class . getName (  )  . equals ( existingDefinition . getBeanClassName (  )  )  ;", "}", "METHOD_END"], "methodName": ["isProxyFactoryBeanDefinition"], "fileName": "org.springframework.aop.config.AbstractInterceptorDrivenBeanDefinitionDecorator"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" Advisor    < advice ( ref )  =  '  \"     +     ( adviceReference . getBeanName (  )  )  )     +     \"  '  ,    pointcut ( expression )  =  [  \"  )     +     ( pointcutDefinition . getPropertyValues (  )  . get (  \" expression \"  )  )  )     +     \"  ]  >  \"  ;", "}", "METHOD_END"], "methodName": ["buildDescription"], "fileName": "org.springframework.aop.config.AdvisorComponentDefinition"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" Advisor    < advice ( ref )  =  '  \"     +     ( adviceReference . getBeanName (  )  )  )     +     \"  '  ,    pointcut ( ref )  =  '  \"  )     +     ( pointcutReference . getBeanName (  )  )  )     +     \"  '  >  \"  ;", "}", "METHOD_END"], "methodName": ["buildDescription"], "fileName": "org.springframework.aop.config.AdvisorComponentDefinition"}, {"methodBody": ["METHOD_START", "{", "return   AopConfigUtils . APC _ PRIORITY _ LIST . indexOf ( clazz )  ;", "}", "METHOD_END"], "methodName": ["findPriorityForClass"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( AopConfigUtils . APC _ PRIORITY _ LIST . size (  )  )  ;    i +  +  )     {", "Class <  ?  >    clazz    =    AopConfigUtils . APC _ PRIORITY _ LIST . get ( i )  ;", "if    ( clazz . getName (  )  . equals ( className )  )     {", "return   i ;", "}", "}", "throw   new   IllegalArgumentException (  (  (  \" Class   name    [  \"     +    className )     +     \"  ]    is   not   a   known   auto - proxy   creator   class \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findPriorityForClass"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( registry . containsBeanDefinition ( AopConfigUtils . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  )     {", "BeanDefinition   definition    =    registry . getBeanDefinition ( AopConfigUtils . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  ;", "definition . getPropertyValues (  )  . add (  \" exposeProxy \"  ,    Boolean . TRUE )  ;", "}", "}", "METHOD_END"], "methodName": ["forceAutoProxyCreatorToExposeProxy"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( registry . containsBeanDefinition ( AopConfigUtils . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  )     {", "BeanDefinition   definition    =    registry . getBeanDefinition ( AopConfigUtils . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  ;", "definition . getPropertyValues (  )  . add (  \" proxyTargetClass \"  ,    Boolean . TRUE )  ;", "}", "}", "METHOD_END"], "methodName": ["forceAutoProxyCreatorToUseClassProxying"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "return   AopConfigUtils . registerAspectJAnnotationAutoProxyCreatorIfNecessary ( registry ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerAspectJAnnotationAutoProxyCreatorIfNecessary"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "return   AopConfigUtils . registerOrEscalateApcAsRequired ( AnnotationAwareAspectJAutoProxyCreator . class ,    registry ,    source )  ;", "}", "METHOD_END"], "methodName": ["registerAspectJAnnotationAutoProxyCreatorIfNecessary"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "return   AopConfigUtils . registerAspectJAutoProxyCreatorIfNecessary ( registry ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerAspectJAutoProxyCreatorIfNecessary"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "return   AopConfigUtils . registerOrEscalateApcAsRequired ( AspectJAwareAdvisorAutoProxyCreator . class ,    registry ,    source )  ;", "}", "METHOD_END"], "methodName": ["registerAspectJAutoProxyCreatorIfNecessary"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "return   AopConfigUtils . registerAutoProxyCreatorIfNecessary ( registry ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerAutoProxyCreatorIfNecessary"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "return   AopConfigUtils . registerOrEscalateApcAsRequired ( InfrastructureAdvisorAutoProxyCreator . class ,    registry ,    source )  ;", "}", "METHOD_END"], "methodName": ["registerAutoProxyCreatorIfNecessary"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( registry ,     \" BeanDefinitionRegistry   must   not   be   null \"  )  ;", "if    ( registry . containsBeanDefinition (  . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  )     {", "BeanDefinition   apcDefinition    =    registry . getBeanDefinition (  . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  ;", "if    (  !  ( cls . getName (  )  . equals ( apcDefinition . getBeanClassName (  )  )  )  )     {", "int   currentPriority    =     . findPriorityForClass ( apcDefinition . getBeanClassName (  )  )  ;", "int   requiredPriority    =     . findPriorityForClass ( cls )  ;", "if    ( currentPriority    <    requiredPriority )     {", "apcDefinition . setBeanClassName ( cls . getName (  )  )  ;", "}", "}", "return   null ;", "}", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( cls )  ;", "beanDefinition . setSource ( source )  ;", "beanDefinition . getPropertyValues (  )  . add (  \" order \"  ,    HIGHEST _ PRECEDENCE )  ;", "beanDefinition . setRole ( ROLE _ INFRASTRUCTURE )  ;", "registry . registerBeanDefinition (  . AUTO _ PROXY _ CREATOR _ BEAN _ NAME ,    beanDefinition )  ;", "return   beanDefinition ;", "}", "METHOD_END"], "methodName": ["registerOrEscalateApcAsRequired"], "fileName": "org.springframework.aop.config.AopConfigUtils"}, {"methodBody": ["METHOD_START", "{", "this . reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "this . reader . setEventListener ( this . eventListener )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( AopNamespaceHandlerEventTests . DIRECT _ POINTCUT _ EVENTS _ CONTEXT )  ;", "ComponentDefinition [  ]    componentDefinitions    =    this . eventListener . getComponentDefinitions (  )  ;", "assertEquals (  \" Incorrect   number   of   events   fired \"  ,     2  ,    componentDefinitions . length )  ;", "assertTrue (  \" No   holder   with   nested   components \"  ,     (  ( componentDefinitions [  0  ]  )    instanceof   CompositeComponentDefinition )  )  ;", "CompositeComponentDefinition   compositeDef    =     (  ( CompositeComponentDefinition )     ( componentDefinitions [  0  ]  )  )  ;", "assertEquals (  \" aop : config \"  ,    compositeDef . getName (  )  )  ;", "ComponentDefinition [  ]    nestedComponentDefs    =    compositeDef . getNestedComponents (  )  ;", "assertEquals (  \" Incorrect   number   of   inner   components \"  ,     2  ,    nestedComponentDefs . length )  ;", "AdvisorComponentDefinition   acd    =    null ;", "for    ( int   i    =     0  ;    i    <     ( nestedComponentDefs . length )  ;    i +  +  )     {", "ComponentDefinition   componentDefinition    =    nestedComponentDefs [ i ]  ;", "if    ( componentDefinition   instanceof   AdvisorComponentDefinition )     {", "acd    =     (  ( AdvisorComponentDefinition )     ( componentDefinition )  )  ;", "break ;", "}", "}", "assertNotNull (  \" AdvisorComponentDefinition   not   found \"  ,    acd )  ;", "assertEquals (  2  ,    acd . getBeanDefinitions (  )  . length )  ;", "assertEquals (  1  ,    acd . getBeanReferences (  )  . length )  ;", "assertTrue (  \" No   advice   bean   found \"  ,     (  ( componentDefinitions [  1  ]  )    instanceof   BeanComponentDefinition )  )  ;", "BeanComponentDefinition   adviceDef    =     (  ( BeanComponentDefinition )     ( componentDefinitions [  1  ]  )  )  ;", "assertEquals (  \" countingAdvice \"  ,    adviceDef . getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAdvisorEventsWithDirectPointcut"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( AopNamespaceHandlerEventTests . POINTCUT _ REF _ CONTEXT )  ;", "ComponentDefinition [  ]    componentDefinitions    =    this . eventListener . getComponentDefinitions (  )  ;", "assertEquals (  \" Incorrect   number   of   events   fired \"  ,     2  ,    componentDefinitions . length )  ;", "assertTrue (  \" No   holder   with   nested   components \"  ,     (  ( componentDefinitions [  0  ]  )    instanceof   CompositeComponentDefinition )  )  ;", "CompositeComponentDefinition   compositeDef    =     (  ( CompositeComponentDefinition )     ( componentDefinitions [  0  ]  )  )  ;", "assertEquals (  \" aop : config \"  ,    compositeDef . getName (  )  )  ;", "ComponentDefinition [  ]    nestedComponentDefs    =    compositeDef . getNestedComponents (  )  ;", "assertEquals (  \" Incorrect   number   of   inner   components \"  ,     3  ,    nestedComponentDefs . length )  ;", "AdvisorComponentDefinition   acd    =    null ;", "for    ( int   i    =     0  ;    i    <     ( nestedComponentDefs . length )  ;    i +  +  )     {", "ComponentDefinition   componentDefinition    =    nestedComponentDefs [ i ]  ;", "if    ( componentDefinition   instanceof   AdvisorComponentDefinition )     {", "acd    =     (  ( AdvisorComponentDefinition )     ( componentDefinition )  )  ;", "break ;", "}", "}", "assertNotNull (  \" AdvisorComponentDefinition   not   found \"  ,    acd )  ;", "assertEquals (  1  ,    acd . getBeanDefinitions (  )  . length )  ;", "assertEquals (  2  ,    acd . getBeanReferences (  )  . length )  ;", "assertTrue (  \" No   advice   bean   found \"  ,     (  ( componentDefinitions [  1  ]  )    instanceof   BeanComponentDefinition )  )  ;", "BeanComponentDefinition   adviceDef    =     (  ( BeanComponentDefinition )     ( componentDefinitions [  1  ]  )  )  ;", "assertEquals (  \" countingAdvice \"  ,    adviceDef . getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAdvisorEventsWithPointcutRef"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( AopNamespaceHandlerEventTests . CONTEXT )  ;", "ComponentDefinition [  ]    componentDefinitions    =    this . eventListener . getComponentDefinitions (  )  ;", "assertEquals (  \" Incorrect   number   of   events   fired \"  ,     5  ,    componentDefinitions . length )  ;", "assertTrue (  \" No   holder   with   nested   components \"  ,     (  ( componentDefinitions [  0  ]  )    instanceof   CompositeComponentDefinition )  )  ;", "CompositeComponentDefinition   compositeDef    =     (  ( CompositeComponentDefinition )     ( componentDefinitions [  0  ]  )  )  ;", "assertEquals (  \" aop : config \"  ,    compositeDef . getName (  )  )  ;", "ComponentDefinition [  ]    nestedComponentDefs    =    compositeDef . getNestedComponents (  )  ;", "assertEquals (  \" Incorrect   number   of   inner   components \"  ,     2  ,    nestedComponentDefs . length )  ;", "AspectComponentDefinition   acd    =    null ;", "for    ( ComponentDefinition   componentDefinition    :    nestedComponentDefs )     {", "if    ( componentDefinition   instanceof   AspectComponentDefinition )     {", "acd    =     (  ( AspectComponentDefinition )     ( componentDefinition )  )  ;", "break ;", "}", "}", "assertNotNull (  \" AspectComponentDefinition   not   found \"  ,    acd )  ;", "BeanDefinition [  ]    beanDefinitions    =    acd . getBeanDefinitions (  )  ;", "assertEquals (  5  ,    beanDefinitions . length )  ;", "BeanReference [  ]    beanReferences    =    acd . getBeanReferences (  )  ;", "assertEquals (  6  ,    beanReferences . length )  ;", "Set < String >    expectedReferences    =    new   HashSet <  >  (  )  ;", "expectedReferences . add (  \" pc \"  )  ;", "expectedReferences . add (  \" countingAdvice \"  )  ;", "for    ( BeanReference   beanReference    :    beanReferences )     {", "expectedReferences . remove ( beanReference . getBeanName (  )  )  ;", "}", "assertEquals (  \" Incorrect   references   found \"  ,     0  ,    expectedReferences . size (  )  )  ;", "for    ( int   i    =     1  ;    i    <     ( componentDefinitions . length )  ;    i +  +  )     {", "assertTrue (  (  ( componentDefinitions [ i ]  )    instanceof   BeanComponentDefinition )  )  ;", "}", "ComponentDefinition [  ]    nestedComponentDefs 2     =    acd . getNestedComponents (  )  ;", "assertEquals (  \" Inner   PointcutComponentDefinition   not   found \"  ,     1  ,    nestedComponentDefs 2  . length )  ;", "assertTrue (  (  ( nestedComponentDefs 2  [  0  ]  )    instanceof   PointcutComponentDefinition )  )  ;", "PointcutComponentDefinition   pcd    =     (  ( PointcutComponentDefinition )     ( nestedComponentDefs 2  [  0  ]  )  )  ;", "assertEquals (  \" Incorrect   number   of   BeanDefinitions \"  ,     1  ,    pcd . getBeanDefinitions (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testAspectEvent"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( AopNamespaceHandlerEventTests . POINTCUT _ EVENTS _ CONTEXT )  ;", "ComponentDefinition [  ]    componentDefinitions    =    this . eventListener . getComponentDefinitions (  )  ;", "assertEquals (  \" Incorrect   number   of   events   fired \"  ,     1  ,    componentDefinitions . length )  ;", "assertTrue (  \" No   holder   with   nested   components \"  ,     (  ( componentDefinitions [  0  ]  )    instanceof   CompositeComponentDefinition )  )  ;", "CompositeComponentDefinition   compositeDef    =     (  ( CompositeComponentDefinition )     ( componentDefinitions [  0  ]  )  )  ;", "assertEquals (  \" aop : config \"  ,    compositeDef . getName (  )  )  ;", "ComponentDefinition [  ]    nestedComponentDefs    =    compositeDef . getNestedComponents (  )  ;", "assertEquals (  \" Incorrect   number   of   inner   components \"  ,     2  ,    nestedComponentDefs . length )  ;", "PointcutComponentDefinition   pcd    =    null ;", "for    ( ComponentDefinition   componentDefinition    :    nestedComponentDefs )     {", "if    ( componentDefinition   instanceof   PointcutComponentDefinition )     {", "pcd    =     (  ( PointcutComponentDefinition )     ( componentDefinition )  )  ;", "break ;", "}", "}", "assertNotNull (  \" PointcutComponentDefinition   not   found \"  ,    pcd )  ;", "assertEquals (  \" Incorrect   number   of   BeanDefinitions \"  ,     1  ,    pcd . getBeanDefinitions (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testPointcutEvents"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( qualifiedResource ( getClass (  )  ,     \" pointcutDuplication . xml \"  )  )  ;", "fail (  \" parsing   should   have   caused   a   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue ( ex . contains ( BeanDefinitionParsingException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDuplicatePointcutConfig"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerPointcutErrorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( qualifiedResource ( getClass (  )  ,     \" pointcutMissing . xml \"  )  )  ;", "fail (  \" parsing   should   have   caused   a   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue ( ex . contains ( BeanDefinitionParsingException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMissingPointcutConfig"], "fileName": "org.springframework.aop.config.AopNamespaceHandlerPointcutErrorTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    AopConfigUtils . registerAspectJAnnotationAutoProxyCreatorIfNecessary ( parserContext . getRegistry (  )  ,    parserContext . extractSource ( sourceElement )  )  ;", ". useClassProxyingIfNecessary ( parserContext . getRegistry (  )  ,    sourceElement )  ;", ". registerComponentIfNecessary ( beanDefinition ,    parserContext )  ;", "}", "METHOD_END"], "methodName": ["registerAspectJAnnotationAutoProxyCreatorIfNecessary"], "fileName": "org.springframework.aop.config.AopNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    AopConfigUtils . registerAspectJAutoProxyCreatorIfNecessary ( parserContext . getRegistry (  )  ,    parserContext . extractSource ( sourceElement )  )  ;", ". useClassProxyingIfNecessary ( parserContext . getRegistry (  )  ,    sourceElement )  ;", ". registerComponentIfNecessary ( beanDefinition ,    parserContext )  ;", "}", "METHOD_END"], "methodName": ["registerAspectJAutoProxyCreatorIfNecessary"], "fileName": "org.springframework.aop.config.AopNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    AopConfigUtils . registerAutoProxyCreatorIfNecessary ( parserContext . getRegistry (  )  ,    parserContext . extractSource ( sourceElement )  )  ;", ". useClassProxyingIfNecessary ( parserContext . getRegistry (  )  ,    sourceElement )  ;", ". registerComponentIfNecessary ( beanDefinition ,    parserContext )  ;", "}", "METHOD_END"], "methodName": ["registerAutoProxyCreatorIfNecessary"], "fileName": "org.springframework.aop.config.AopNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( beanDefinition    !  =    null )     {", "BeanComponentDefinition   componentDefinition    =    new   BeanComponentDefinition ( beanDefinition ,    AopCUtils . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  ;", "parserContext . registerComponent ( componentDefinition )  ;", "}", "}", "METHOD_END"], "methodName": ["registerComponentIfNecessary"], "fileName": "org.springframework.aop.config.AopNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( sourceElement    !  =    null )     {", "boolean   proxyTargetClass    =    Boolean . parseBoolean ( sourceElement . getAttribute (  . PROXY _ TARGET _ CLASS _ ATTRIBUTE )  )  ;", "if    ( proxyTargetClass )     {", "AopConfigUtils . forceAutoProxyCreatorToUseClassProxying ( registry )  ;", "}", "boolean   exposeProxy    =    Boolean . parseBoolean ( sourceElement . getAttribute (  . EXPOSE _ PROXY _ ATTRIBUTE )  )  ;", "if    ( exposeProxy )     {", "AopConfigUtils . forceAutoProxyCreatorToExposeProxy ( registry )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["useClassProxyingIfNecessary"], "fileName": "org.springframework.aop.config.AopNamespaceUtils"}, {"methodBody": ["METHOD_START", "{", "ManagedList < TypedStringValue >    includePatterns    =    new   ManagedList (  )  ;", "NodeList   childNodes    =    element . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( childNodes . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    childNodes . item ( i )  ;", "if    ( node   instanceof   Element )     {", "Element   includeElement    =     (  ( Element )     ( node )  )  ;", "TypedStringValue   valueHolder    =    new   TypedStringValue ( includeElement . getAttribute (  \" name \"  )  )  ;", "valueHolder . setSource ( parserContext . extractSource ( includeElement )  )  ;", "includePatterns . add ( valueHolder )  ;", "}", "}", "if    (  !  ( includePatterns . isEmpty (  )  )  )     {", "includePatterns . setSource ( parserContext . extractSource ( element )  )  ;", "b . getPropertyValues (  )  . add (  \" includePatterns \"  ,    includePatterns )  ;", "}", "}", "METHOD_END"], "methodName": ["addIncludePatterns"], "fileName": "org.springframework.aop.config.AspectJAutoProxyBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDef    =    parserContext . getRegistry (  )  . getBeanDefinition ( AopConfigUtils . AUTO _ PROXY _ CREATOR _ BEAN _ NAME )  ;", "if    ( element . hasChildNodes (  )  )     {", "addIncludePatterns ( element ,    parserContext ,    beanDef )  ;", "}", "}", "METHOD_END"], "methodName": ["extendBeanDefinition"], "fileName": "org.springframework.aop.config.AspectJAutoProxyBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "AopNamespaceUtils . registerAspectJAutoProxyCreatorIfNecessary ( parserContext ,    element )  ;", "}", "METHOD_END"], "methodName": ["configureAutoProxyCreator"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   adviceDefinition    =    new   RootBeanDefinition ( getAdviceClass ( adviceElement ,    parserContext )  )  ;", "adviceDefinition . setSource ( parserContext . extractSource ( adviceElement )  )  ;", "adviceDefinition . getPropertyValues (  )  . add (  . ASPECT _ NAME _ PROPERTY ,    aspectName )  ;", "adviceDefinition . getPropertyValues (  )  . add (  . DECLARATION _ ORDER _ PROPERTY ,    order )  ;", "if    ( adviceElement . hasAttribute (  . RETURNING )  )     {", "adviceDefinition . getPropertyValues (  )  . add (  . RETURNING _ PROPERTY ,    adviceElement . getAttribute (  . RETURNING )  )  ;", "}", "if    ( adviceElement . hasAttribute (  . THROWING )  )     {", "adviceDefinition . getPropertyValues (  )  . add (  . THROWING _ PROPERTY ,    adviceElement . getAttribute (  . THROWING )  )  ;", "}", "if    ( adviceElement . hasAttribute (  . ARG _ NAMES )  )     {", "adviceDefinition . getPropertyValues (  )  . add (  . ARG _ NAMES _ PROPERTY ,    adviceElement . getAttribute (  . ARG _ NAMES )  )  ;", "}", "ConstructorArgumentValues   cav    =    adviceDefinition . getConstructorArgumentValues (  )  ;", "cav . addIndexedArgumentValue (  . METHOD _ INDEX ,    methodDef )  ;", "Object   pointcut    =    parsePointcutProperty ( adviceElement ,    parserContext )  ;", "if    ( pointcut   instanceof   BeanDefinition )     {", "cav . addIndexedArgumentValue (  . POINTCUT _ INDEX ,    pointcut )  ;", "beanDefinitions . add (  (  ( BeanDefinition )     ( pointcut )  )  )  ;", "} else", "if    ( pointcut   instanceof   String )     {", "RuntimeBeanReference   pointcutRef    =    new   RuntimeBeanReference (  (  ( String )     ( pointcut )  )  )  ;", "cav . addIndexedArgumentValue (  . POINTCUT _ INDEX ,    pointcutRef )  ;", "beanReferences . add ( pointcutRef )  ;", "}", "cav . addIndexedArgumentValue (  . ASPECT _ INSTANCE _ FACTORY _ INDEX ,    aspectFactoryDef )  ;", "return   adviceDefinition ;", "}", "METHOD_END"], "methodName": ["createAdviceDefinition"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   advisorDefinition    =    new   RootBeanDefinition ( DefaultBeanFactoryPointcutAdvisor . class )  ;", "advisorDefinition . setSource ( parserContext . extractSource ( advisorElement )  )  ;", "String   adviceRef    =    advisorElement . getAttribute (  . ADVICE _ REF )  ;", "if    (  !  ( StringUtils . hasText ( adviceRef )  )  )     {", "parserContext . getReaderContext (  )  . error (  \"  ' advice - ref '    attribute   contains   empty   value .  \"  ,    advisorElement ,    this . parseState . snapshot (  )  )  ;", "} else    {", "advisorDefinition . getPropertyValues (  )  . add (  . ADVICE _ BEAN _ NAME ,    new   RuntimeBeanNameReference ( adviceRef )  )  ;", "}", "if    ( advisorElement . hasAttribute (  . ORDER _ PROPERTY )  )     {", "advisorDefinition . getPropertyValues (  )  . add (  . ORDER _ PROPERTY ,    advisorElement . getAttribute (  . ORDER _ PROPERTY )  )  ;", "}", "return   advisorDefinition ;", "}", "METHOD_END"], "methodName": ["createAdvisorBeanDefinition"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition [  ]    beanDefArray    =    beanDefs . toArray ( new   BeanDefinition [  0  ]  )  ;", "BeanReference [  ]    beanRefArray    =    beanRefs . toArray ( new   BeanReference [  0  ]  )  ;", "Object   source    =    parserContext . extractSource ( aspectElement )  ;", "return   new   AspectComponentDefinition ( aspectId ,    beanDefArray ,    beanRefArray ,    source )  ;", "}", "METHOD_END"], "methodName": ["createAspectComponentDefinition"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   beanDefinition    =    new   RootBeanDefinition ( AspectJExpressionPointcut . class )  ;", "beanDefinition . setScope ( SCOPE _ PROTOTYPE )  ;", "beanDefinition . setSynthetic ( true )  ;", "beanDefinition . getPropertyValues (  )  . add (  . EXPRESSION ,    expression )  ;", "return   beanDefinition ;", "}", "METHOD_END"], "methodName": ["createPointcutDefinition"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String   elementName    =    parserContext . getDelegate (  )  . getLocalName ( adviceElement )  ;", "if    (  . BEFORE . equals ( elementName )  )     {", "return   AspectJMethodBeforeAdvice . class ;", "} else", "if    (  . AFTER . equals ( elementName )  )     {", "return   class ;", "} else", "if    (  . AFTER _ RETURNING _ ELEMENT . equals ( elementName )  )     {", "return   class ;", "} else", "if    (  . AFTER _ THROWING _ ELEMENT . equals ( elementName )  )     {", "return   class ;", "} else", "if    (  . AROUND . equals ( elementName )  )     {", "return   class ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Unknown   advice   kind    [  \"     +    elementName )     +     \"  ]  .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAdviceClass"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( aNode   instanceof   Element )  )     {", "return   false ;", "} else    {", "String   name    =    parserContext . getDelegate (  )  . getLocalName ( aNode )  ;", "return    (  (  (  (  . BEFORE . equals ( name )  )     |  |     (  . AFTER . equals ( name )  )  )     |  |     (  . AFTER _ RETURNING _ ELEMENT . equals ( name )  )  )     |  |     (  . AFTER _ THROWING _ ELEMENT . equals ( name )  )  )     |  |     (  . AROUND . equals ( name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isAdviceNode"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . parseState . push ( new   AdviceEntry ( parserContext . getDelegate (  )  . getLocalName ( adviceElement )  )  )  ;", "RootBeanDefinition   methodDefinition    =    new   RootBeanDefinition ( MethodLocatingFactoryBean . class )  ;", "methodDefinition . getPropertyValues (  )  . add (  \" targetBeanName \"  ,    aspectName )  ;", "methodDefinition . getPropertyValues (  )  . add (  \" methodName \"  ,    adviceElement . getAttribute (  \" method \"  )  )  ;", "methodDefinition . setSynthetic ( true )  ;", "RootBeanDefinition   aspectFactoryDef    =    new   RootBeanDefinition ( SimpleBeanFactoryAwareAspectInstanceFactory . class )  ;", "aspectFactoryDef . getPropertyValues (  )  . add (  \" aspectBeanName \"  ,    aspectName )  ;", "aspectFactoryDef . setSynthetic ( true )  ;", "AbstractBeanDefinition   adviceDef    =    createAdviceDefinition ( adviceElement ,    parserContext ,    aspectName ,    order ,    methodDefinition ,    aspectFactoryDef ,    beanDefinitions ,    beanReferences )  ;", "RootBeanDefinition   advisorDefinition    =    new   RootBeanDefinition ( AspectJPointcutAdvisor . class )  ;", "advisorDefinition . setSource ( parserContext . extractSource ( adviceElement )  )  ;", "advisorDefinition . getConstructorArgumentValues (  )  . addGenericArgumentValue ( adviceDef )  ;", "if    ( aspectElement . hasAttribute (  . ORDER _ PROPERTY )  )     {", "advisorDefinition . getPropertyValues (  )  . add (  . ORDER _ PROPERTY ,    aspectElement . getAttribute (  . ORDER _ PROPERTY )  )  ;", "}", "parserContext . getReaderContext (  )  . registerWithGeneratedName ( advisorDefinition )  ;", "return   advisorDefinition ;", "}    finally    {", "this . parseState . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAdvice"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "AbstractBeanDefinition   advisorDef    =    createAdvisorBeanDefinition ( advisorElement ,    parserContext )  ;", "String   id    =    advisorElement . getAttribute (  . ID )  ;", "try    {", "this . parseState . push ( new   AdvisorEntry ( id )  )  ;", "String   advisorBeanName    =    id ;", "if    ( StringUtils . hasText ( advisorBeanName )  )     {", "parserContext . getRegistry (  )  . registerBeanDefinition ( advisorBeanName ,    advisorDef )  ;", "} else    {", "advisorBeanName    =    parserContext . getReaderContext (  )  . registerWithGeneratedName ( advisorDef )  ;", "}", "Object   pointcut    =    parsePointcutProperty ( advisorElement ,    parserContext )  ;", "if    ( pointcut   instanceof   BeanDefinition )     {", "advisorDef . getPropertyValues (  )  . add (  . POINTCUT ,    pointcut )  ;", "parserContext . registerComponent ( new   AdvisorComponentDefinition ( advisorBeanName ,    advisorDef ,     (  ( BeanDefinition )     ( pointcut )  )  )  )  ;", "} else", "if    ( pointcut   instanceof   String )     {", "advisorDef . getPropertyValues (  )  . add (  . POINTCUT ,    new   RuntimeBeanReference (  (  ( String )     ( pointcut )  )  )  )  ;", "parserContext . registerComponent ( new   AdvisorComponentDefinition ( advisorBeanName ,    advisorDef )  )  ;", "}", "}    finally    {", "this . parseState . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAdvisor"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String   aspectId    =    aspectElement . getAttribute ( ConfigBeanDefinitionParser . ID )  ;", "String   aspectName    =    aspectElement . getAttribute ( ConfigBeanDefinitionParser . REF )  ;", "try    {", "this . parseState . push ( new   AspectEntry ( aspectId ,    aspectName )  )  ;", "List < BeanDefinition >    beanDefinitions    =    new   ArrayList <  >  (  )  ;", "List < BeanReference >    beanReferences    =    new   ArrayList <  >  (  )  ;", "List < Element >    declareParents    =    DomUtils . getChildElementsByTagName ( aspectElement ,    ConfigBeanDefinitionParser . DECLARE _ PARENTS )  ;", "for    ( int   i    =    ConfigBeanDefinitionParser . METHOD _ INDEX ;    i    <     ( declareParents . size (  )  )  ;    i +  +  )     {", "Element   declareParentsElement    =    declareParents . get ( i )  ;", "beanDefinitions . add ( parseDeclareParents ( declareParentsElement ,    parserContext )  )  ;", "}", "NodeList   nodeList    =    aspectElement . getChildNodes (  )  ;", "boolean   adviceFoundAlready    =    false ;", "for    ( int   i    =     0  ;    i    <     ( nodeList . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nodeList . item ( i )  ;", "if    ( isAdviceNode ( node ,    parserContext )  )     {", "if    (  ! adviceFoundAlready )     {", "adviceFoundAlready    =    true ;", "if    (  !  ( StringUtils . hasText ( aspectName )  )  )     {", "parserContext . getReaderContext (  )  . error (  \"  < aspect >    tag   needs   aspect   bean   reference   via    ' ref '    attribute   when   declaring   advices .  \"  ,    aspectElement ,    this . parseState . snapshot (  )  )  ;", "return ;", "}", "beanReferences . add ( new   RuntimeBeanReference ( aspectName )  )  ;", "}", "AbstractBeanDefinition   advisorDefinition    =    parseAdvice ( aspectName ,    i ,    aspectElement ,     (  ( Element )     ( node )  )  ,    parserContext ,    beanDefinitions ,    beanReferences )  ;", "beanDefinitions . add ( advisorDefinition )  ;", "}", "}", "AspectComponentDefinition   aspectComponentDefinition    =    createAspectComponentDefinition ( aspectElement ,    aspectId ,    beanDefinitions ,    beanReferences ,    parserContext )  ;", "parserContext . pushContainingComponent ( aspectComponentDefinition )  ;", "List < Element >    pointcuts    =    DomUtils . getChildElementsByTagName ( aspectElement ,    ConfigBeanDefinitionParser . POINTCUT )  ;", "for    ( Element   pointcutElement    :    pointcuts )     {", "parsePointcut ( pointcutElement ,    parserContext )  ;", "}", "parserContext . popAndRegisterContainingComponent (  )  ;", "}    finally    {", "this . parseState . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAspect"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( DeclareParentsAdvisor . class )  ;", "builder . addConstructorArgValue ( declareParentsElement . getAttribute (  . IMPLEMENT _ INTERFACE )  )  ;", "builder . addConstructorArgValue ( declareParentsElement . getAttribute (  . TYPE _ PATTERN )  )  ;", "String   defaultImpl    =    declareParentsElement . getAttribute (  . DEFAULT _ IMPL )  ;", "String   delegateRef    =    declareParentsElement . getAttribute (  . DELEGATE _ REF )  ;", "if    (  ( StringUtils . hasText ( defaultImpl )  )     &  &     (  !  ( StringUtils . hasText ( delegateRef )  )  )  )     {", "builder . addConstructorArgValue ( defaultImpl )  ;", "} else", "if    (  ( StringUtils . hasText ( delegateRef )  )     &  &     (  !  ( StringUtils . hasText ( defaultImpl )  )  )  )     {", "builder . addConstructorArgReference ( delegateRef )  ;", "} else    {", "parserContext . getReaderContext (  )  . error (  (  (  (  (  \" Exactly   one   of   the    \"     +     (  . DEFAULT _ IMPL )  )     +     \"    or    \"  )     +     (  . DELEGATE _ REF )  )     +     \"    attributes   must   be   specified \"  )  ,    declareParentsElement ,    this . parseState . snapshot (  )  )  ;", "}", "AbstractBeanDefinition   definition    =    builder . getBeanDefinition (  )  ;", "definition . setSource ( parserContext . extractSource ( declareParentsElement )  )  ;", "parserContext . getReaderContext (  )  . registerWithGeneratedName ( definition )  ;", "return   definition ;", "}", "METHOD_END"], "methodName": ["parseDeclareParents"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String   id    =    pointcutElement . getAttribute ( ConfigBeanDefinitionParser . ID )  ;", "String   expression    =    pointcutElement . getAttribute ( ConfigBeanDefinitionParser . EXPRESSION )  ;", "AbstractBeanDefinition   pointcutDefinition    =    null ;", "try    {", "this . parseState . push ( new   PointcutEntry ( id )  )  ;", "pointcutDefinition    =    createPointcutDefinition ( expression )  ;", "pointcutDefinition . setSource ( parserContext . extractSource ( pointcutElement )  )  ;", "String   pointcutBeanName    =    id ;", "if    ( StringUtils . hasText ( pointcutBeanName )  )     {", "parserContext . getRegistry (  )  . registerBeanDefinition ( pointcutBeanName ,    pointcutDefinition )  ;", "} else    {", "pointcutBeanName    =    parserContext . getReaderContext (  )  . registerWithGeneratedName ( pointcutDefinition )  ;", "}", "parserContext . registerComponent ( new   PointcutComponentDefinition ( pointcutBeanName ,    pointcutDefinition ,    expression )  )  ;", "}    finally    {", "this . parseState . pop (  )  ;", "}", "return   pointcutDefinition ;", "}", "METHOD_END"], "methodName": ["parsePointcut"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( element . hasAttribute ( ConfigBeanDefinitionParser . POINTCUT )  )     &  &     ( element . hasAttribute ( ConfigBeanDefinitionParser . POINTCUT _ REF )  )  )     {", "parserContext . getReaderContext (  )  . error (  \" Cannot   define   both    ' pointcut '    and    ' pointcut - ref '    on    < advisor >    tag .  \"  ,    element ,    this . parseState . snapshot (  )  )  ;", "return   null ;", "} else", "if    ( element . hasAttribute ( ConfigBeanDefinitionParser . POINTCUT )  )     {", "String   expression    =    element . getAttribute ( ConfigBeanDefinitionParser . POINTCUT )  ;", "AbstractBeanDefinition   pointcutDefinition    =    createPointcutDefinition ( expression )  ;", "pointcutDefinition . setSource ( parserContext . extractSource ( element )  )  ;", "return   pointcutDefinition ;", "} else", "if    ( element . hasAttribute ( ConfigBeanDefinitionParser . POINTCUT _ REF )  )     {", "String   pointcutRef    =    element . getAttribute ( ConfigBeanDefinitionParser . POINTCUT _ REF )  ;", "if    (  !  ( hasText ( pointcutRef )  )  )     {", "parserContext . getReaderContext (  )  . error (  \"  ' pointcut - ref '    attribute   contains   empty   value .  \"  ,    element ,    this . parseState . snapshot (  )  )  ;", "return   null ;", "}", "return   pointcutRef ;", "} else    {", "parserContext . getReaderContext (  )  . error (  \" Must   define   one   of    ' pointcut '    or    ' pointcut - ref '    on    < advisor >    tag .  \"  ,    element ,    this . parseState . snapshot (  )  )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["parsePointcutProperty"], "fileName": "org.springframework.aop.config.ConfigBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "this . methodName    =    methodName ;", "}", "METHOD_END"], "methodName": ["setMethodName"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanName    =    targetBeanName ;", "}", "METHOD_END"], "methodName": ["setTargetBeanName"], "fileName": "org.springframework.aop.config.MethodLocatingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . aspectBeanName    =    aspectBeanName ;", "}", "METHOD_END"], "methodName": ["setAspectBeanName"], "fileName": "org.springframework.aop.config.SimpleBeanFactoryAwareAspectInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( beanFactory )  ;", "reader . loadBeanDefinitions (  . CONTEXT )  ;", "assertTrue ( beanFactory . containsBeanDefinition (  \" testPointcut \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testParse"], "fileName": "org.springframework.aop.config.TopLevelAopTagTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   eligible    =    this . eligibleBeans . get ( targetClass )  ;", "if    ( eligible    !  =    null )     {", "return   eligible ;", "}", "if    (  ( this . advisor )     =  =    null )     {", "return   false ;", "}", "eligible    =    AopUtils . canApply ( this . advisor ,    targetClass )  ;", "this . eligibleBeans . put ( targetClass ,    eligible )  ;", "return   eligible ;", "}", "METHOD_END"], "methodName": ["isEligible"], "fileName": "org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   isEligible ( bean . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEligible"], "fileName": "org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . copyFrom ( this )  ;", "proxyFactory . setTarget ( bean )  ;", "return   proxyFactory ;", "}", "METHOD_END"], "methodName": ["prepareProxyFactory"], "fileName": "org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . beforeExistingAdvisors    =    beforeExistingAdvisors ;", "}", "METHOD_END"], "methodName": ["setBeforeExistingAdvisors"], "fileName": "org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( target   instanceof   TargetSource )     {", "return    (  ( TargetSource )     ( target )  )  ;", "} else    {", "return   new   TargetSource ( target )  ;", "}", "}", "METHOD_END"], "methodName": ["createTargetSource"], "fileName": "org.springframework.aop.framework.AbstractSingletonProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . advisorAdapterRegistry    =    advisorAdapterRegistry ;", "}", "METHOD_END"], "methodName": ["setAdvisorAdapterRegistry"], "fileName": "org.springframework.aop.framework.AbstractSingletonProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . postInterceptors    =    postInterceptors ;", "}", "METHOD_END"], "methodName": ["setPostInterceptors"], "fileName": "org.springframework.aop.framework.AbstractSingletonProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . preInterceptors    =    preInterceptors ;", "}", "METHOD_END"], "methodName": ["setPreInterceptors"], "fileName": "org.springframework.aop.framework.AbstractSingletonProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . proxyClassLoader    =    classLoader ;", "}", "METHOD_END"], "methodName": ["setProxyClassLoader"], "fileName": "org.springframework.aop.framework.AbstractSingletonProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . proxyInterfaces    =    proxyInterfaces ;", "}", "METHOD_END"], "methodName": ["setProxyInterfaces"], "fileName": "org.springframework.aop.framework.AbstractSingletonProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . target    =    target ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "org.springframework.aop.framework.AbstractSingletonProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( advisor ,     \" Advisor   must   not   be   null \"  )  ;", "if    ( isFrozen (  )  )     {", "throw   new   AopConfigException (  \" Cannot   add   advisor :    Configuration   is   frozen .  \"  )  ;", "}", "if    ( pos    >     ( this . advisors . size (  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Illegal   position    \"     +    pos )     +     \"    in   advisor   list   with   size    \"  )     +     ( this . advisors . size (  )  )  )  )  ;", "}", "this . advisors . add ( pos ,    advisor )  ;", "updateAdvisorArray (  )  ;", "adviceChanged (  )  ;", "}", "METHOD_END"], "methodName": ["addAdvisorInternal"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( isFrozen (  )  )     {", "throw   new   AopConfigException (  \" Cannot   add   advisor :    Configuration   is   frozen .  \"  )  ;", "}", "if    (  !  ( CollectionUtils . isEmpty ( advisors )  )  )     {", "for    ( or   advisor    :    advisors )     {", "if    ( advisor   instanceof   Introductionor )     {", "validateIntroductionor (  (  ( Introductionor )     ( advisor )  )  )  ;", "}", "Assert . notNull ( advisor ,     \" or   must   not   be   null \"  )  ;", "this . advisors . add ( advisor )  ;", "}", "updateorArray (  )  ;", "adviceChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addAdvisors"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "addAdvisors ( Arrays . asList ( advisors )  )  ;", "}", "METHOD_END"], "methodName": ["addAdvisors"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( intf ,     \" Interface   must   not   be   null \"  )  ;", "if    (  !  ( intf . isInterface (  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \"  [  \"     +     ( intf . getN (  )  )  )     +     \"  ]    is   not   an   interface \"  )  )  ;", "}", "if    (  !  ( this . interfaces . contains ( intf )  )  )     {", "this . interfaces . add ( intf )  ;", "adviceChanged (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addInterface"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "this . methodCache . clear (  )  ;", "}", "METHOD_END"], "methodName": ["adviceChanged"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( advice    !  =    null )     {", "for    ( or   advisor    :    this . advisors )     {", "if    (  ( advisor . getAdvice (  )  )     =  =    advice )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["adviceIncluded"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "copyConfigurationFrom ( other ,    other . targetSource ,    new   ArrayList <  >  ( other . advisors )  )  ;", "}", "METHOD_END"], "methodName": ["copyConfigurationFrom"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "copyFrom ( other )  ;", "this . targetSource    =    targetSource ;", "this . advisorChainFactory    =    other . advisorChainFactory ;", "this . interfaces    =    new   ArrayList <  >  ( other . interfaces )  ;", "for    ( or   advisor    :    advisors )     {", "if    ( advisor   instanceof   Introductionor )     {", "validateIntroductionor (  (  ( Introductionor )     ( advisor )  )  )  ;", "}", "Assert . notNull ( advisor ,     \" or   must   not   be   null \"  )  ;", "this . advisors . add ( advisor )  ;", "}", "updateorArray (  )  ;", "adviceChanged (  )  ;", "}", "METHOD_END"], "methodName": ["copyConfigurationFrom"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "if    ( adviceClass    !  =    null )     {", "for    ( or   advisor    :    this . advisors )     {", "if    ( adviceClass . isInstance ( advisor . getAdvice (  )  )  )     {", "count +  +  ;", "}", "}", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["countAdvicesOfType"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . advisorChainFactory ;", "}", "METHOD_END"], "methodName": ["getAdvisorChainFactory"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . advisors ;", "}", "METHOD_END"], "methodName": ["getAdvisorsInternal"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport   copy    =    new   AdvisedSupport (  )  ;", "copy . copyFrom ( this )  ;", "copy . targetSource    =    EmptyTargetSource . forClass ( getTargetClass (  )  ,    getTargetSource (  )  . isStatic (  )  )  ;", "copy . advisorChainFactory    =    this . advisorChainFactory ;", "copy . interfaces    =    this . interfaces ;", "copy . advisors    =    this . advisors ;", "copy . updateAdvisorArray (  )  ;", "return   copy ;", "}", "METHOD_END"], "methodName": ["getConfigurationOnlyCopy"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport . MethodCacheKey   cacheKey    =    new   AdvisedSupport . MethodCacheKey ( method )  ;", "List < Object >    cached    =    this . methodCache . get ( cacheKey )  ;", "if    ( cached    =  =    null )     {", "cached    =    this . advisorChainFactory . getInterceptorsAndDynamicInterceptionAdvice ( this ,    method ,    targetClass )  ;", "this . methodCache . put ( cacheKey ,    cached )  ;", "}", "return   cached ;", "}", "METHOD_END"], "methodName": ["getInterceptorsAndDynamicInterceptionAdvice"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "this . methodCache    =    new   ConcurrentHashMap <  >  (  3  2  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . interfaces . remove ( intf )  ;", "}", "METHOD_END"], "methodName": ["removeInterface"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( advisorChainFactory ,     \" AdvisorChainFactory   must   not   be   null \"  )  ;", "this . advisorChainFactory    =    advisorChainFactory ;", "}", "METHOD_END"], "methodName": ["setAdvisorChainFactory"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( interfaces ,     \" Interfaces   must   not   be   null \"  )  ;", "this . interfaces . clear (  )  ;", "for    ( Class <  ?  >    ifc    :    interfaces )     {", "addInterface ( ifc )  ;", "}", "}", "METHOD_END"], "methodName": ["setInterfaces"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "setTargetSource ( new   SingletonTargetSource ( target )  )  ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "this . targetSource    =    EmptyTargetSource . forClass ( targetClass )  ;", "}", "METHOD_END"], "methodName": ["setTargetClass"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "this . advisorArray    =    this . advisors . toArray ( new   Advisor [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["updateAdvisorArray"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "advisor . validateInterfaces (  )  ;", "Class <  ?  >  [  ]    ifcs    =    advisor . getInterfaces (  )  ;", "for    ( Class <  ?  >    ifc    :    ifcs )     {", "addInterface ( ifc )  ;", "}", "}", "METHOD_END"], "methodName": ["validateIntroductionAdvisor"], "fileName": "org.springframework.aop.framework.AdvisedSupport"}, {"methodBody": ["METHOD_START", "{", "Object   proxy    =    AopContext . currentProxy . get (  )  ;", "if    ( proxy    =  =    null )     {", "throw   new   IllegalStateException (  \" Cannot   find   current   proxy :    Set    ' exposeProxy '    property   on   Advised   to    ' true '    to   make   it   available .  \"  )  ;", "}", "return   proxy ;", "}", "METHOD_END"], "methodName": ["currentProxy"], "fileName": "org.springframework.aop.framework.AopContext"}, {"methodBody": ["METHOD_START", "{", "Object   old    =    AopContext . currentProxy . get (  )  ;", "if    ( proxy    !  =    null )     {", "AopContext . currentProxy . set ( proxy )  ;", "} else    {", "AopContext . currentProxy . remove (  )  ;", "}", "return   old ;", "}", "METHOD_END"], "methodName": ["setCurrentProxy"], "fileName": "org.springframework.aop.framework.AopContext"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( arguments )  )     {", "return   new   Object [  0  ]  ;", "}", "if    ( method . isVarArgs (  )  )     {", "Class <  ?  >  [  ]    paramTypes    =    method . getParameterTypes (  )  ;", "if    (  ( paramTypes . length )     =  =     ( arguments . length )  )     {", "int   varargIndex    =     ( paramTypes . length )     -     1  ;", "Class <  ?  >    varargType    =    paramTypes [ varargIndex ]  ;", "if    ( varargType . isArray (  )  )     {", "Object   varargArray    =    arguments [ varargIndex ]  ;", "if    (  ( varargArray   instanceof   Object [  ]  )     &  &     (  !  ( varargType . isInstance ( varargArray )  )  )  )     {", "Object [  ]    newArguments    =    new   Object [ arguments . length ]  ;", "System . arraycopy ( arguments ,     0  ,    newArguments ,     0  ,    varargIndex )  ;", "Class <  ?  >    targetElementType    =    varargType . getComponentType (  )  ;", "int   varargLength    =    Array . getLength ( varargArray )  ;", "Object   newVarargArray    =    Array . newInstance ( targetElementType ,    varargLength )  ;", "System . arraycopy ( varargArray ,     0  ,    newVarargArray ,     0  ,    varargLength )  ;", "newArguments [ varargIndex ]     =    newVarargArray ;", "return   newArguments ;", "}", "}", "}", "}", "return   arguments ;", "}", "METHOD_END"], "methodName": ["adaptArgumentsIfNecessary"], "fileName": "org.springframework.aop.framework.AopProxyUtils"}, {"methodBody": ["METHOD_START", "{", "return   AopProxyUtils . completeProxiedInterfaces ( advised ,    false )  ;", "}", "METHOD_END"], "methodName": ["completeProxiedInterfaces"], "fileName": "org.springframework.aop.framework.AopProxyUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    specifiedInterfaces    =    advised . getProxiedInterfaces (  )  ;", "if    (  ( specifiedInterfaces . length )     =  =     0  )     {", "Class <  ?  >    targetClass    =    advised . getTargetClass (  )  ;", "if    ( targetClass    !  =    null )     {", "if    ( targetClass . isInterface (  )  )     {", "advised . setInterfaces ( targetClass )  ;", "} else", "if    ( isClass ( targetClass )  )     {", "advised . setInterfaces ( targetClass . getInterfaces (  )  )  ;", "}", "specifiedInterfaces    =    advised . getProxiedInterfaces (  )  ;", "}", "}", "boolean   addSpring    =     !  ( advised . isInterfaceProxied ( Spring . class )  )  ;", "boolean   addAdvised    =     (  !  ( advised . isOpaque (  )  )  )     &  &     (  !  ( advised . isInterfaceProxied ( Advised . class )  )  )  ;", "boolean   addDecorating    =    decorating    &  &     (  !  ( advised . isInterfaceProxied ( Decorating . class )  )  )  ;", "int   nonUserIfcCount    =     0  ;", "if    ( addSpring )     {", "nonUserIfcCount +  +  ;", "}", "if    ( addAdvised )     {", "nonUserIfcCount +  +  ;", "}", "if    ( addDecorating )     {", "nonUserIfcCount +  +  ;", "}", "Class <  ?  >  [  ]    proxiedInterfaces    =    new   Class <  ?  >  [  ( specifiedInterfaces . length )     +    nonUserIfcCount ]  ;", "System . arraycopy ( specifiedInterfaces ,     0  ,    proxiedInterfaces ,     0  ,    specifiedInterfaces . length )  ;", "int   index    =    specifiedInterfaces . length ;", "if    ( addSpring )     {", "proxiedInterfaces [ index ]     =    Spring . class ;", "index +  +  ;", "}", "if    ( addAdvised )     {", "proxiedInterfaces [ index ]     =    Advised . class ;", "index +  +  ;", "}", "if    ( addDecorating )     {", "proxiedInterfaces [ index ]     =    Decorating . class ;", "}", "return   proxiedInterfaces ;", "}", "METHOD_END"], "methodName": ["completeProxiedInterfaces"], "fileName": "org.springframework.aop.framework.AopProxyUtils"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . equals ( a . getAdvisors (  )  ,    b . getAdvisors (  )  )  ;", "}", "METHOD_END"], "methodName": ["equalsAdvisors"], "fileName": "org.springframework.aop.framework.AopProxyUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( a    =  =    b )     |  |     (  (  ( AopProxyUtils . equalsProxiedInterfaces ( a ,    b )  )     &  &     ( AopProxyUtils . equalsAdvisors ( a ,    b )  )  )     &  &     ( a . getTargetSource (  )  . equals ( b . getTargetSource (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equalsInProxy"], "fileName": "org.springframework.aop.framework.AopProxyUtils"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . equals ( a . getProxiedInterfaces (  )  ,    b . getProxiedInterfaces (  )  )  ;", "}", "METHOD_END"], "methodName": ["equalsProxiedInterfaces"], "fileName": "org.springframework.aop.framework.AopProxyUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( candidate   instanceof   Advised )     {", "TargetSource   targetSource    =     (  ( Advised )     ( candidate )  )  . getTargetSource (  )  ;", "if    ( targetSource   instanceof   SletonTargetSource )     {", "return    (  ( SletonTargetSource )     ( targetSource )  )  . getTarget (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSingletonTarget"], "fileName": "org.springframework.aop.framework.AopProxyUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    proxyInterfaces    =    proxy . getClass (  )  . getInterfaces (  )  ;", "int   nonUserIfcCount    =     0  ;", "if    ( proxy   instanceof   SProxy )     {", "nonUserIfcCount +  +  ;", "}", "if    ( proxy   instanceof   Advised )     {", "nonUserIfcCount +  +  ;", "}", "if    ( proxy   instanceof   DecoratingProxy )     {", "nonUserIfcCount +  +  ;", "}", "Class <  ?  >  [  ]    userInterfaces    =    new   Class <  ?  >  [  ( proxyInterfaces . length )     -    nonUserIfcCount ]  ;", "System . arraycopy ( proxyInterfaces ,     0  ,    userInterfaces ,     0  ,    userInterfaces . length )  ;", "Assert . notEmpty ( userInterfaces ,     \" JDK   proxy   must   implement   one   or   more   interfaces \"  )  ;", "return   userInterfaces ;", "}", "METHOD_END"], "methodName": ["proxiedUserInterfaces"], "fileName": "org.springframework.aop.framework.AopProxyUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( candidate ,     \" Candidate   object   must   not   be   null \"  )  ;", "Object   current    =    candidate ;", "Class <  ?  >    result    =    null ;", "while    ( current   instanceof   TargetClassAware )     {", "result    =     (  ( TargetClassAware )     ( current )  )  . getTargetClass (  )  ;", "current    =     . getSingletonTarget ( current )  ;", "}", "if    ( result    =  =    null )     {", "result    =     ( AopUtils . isCglibProxy ( candidate )  )     ?    candidate . getClass (  )  . getSuperclass (  )     :    candidate . getClass (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["ultimateTargetClass"], "fileName": "org.springframework.aop.framework.AopProxyUtils"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . addInterface ( ITestBean . class )  ;", "as . addInterface ( Comparable . class )  ;", "as . addInterface ( Advised . class )  ;", "Class <  ?  >  [  ]    completedInterfaces    =     . completeProxiedInterfaces ( as )  ;", "assertEquals (  4  ,    completedInterfaces . length )  ;", "List <  ?  >    l    =    Arrays . asList ( completedInterfaces )  ;", "assertTrue ( l . contains ( Advised . class )  )  ;", "assertTrue ( l . contains ( ITestBean . class )  )  ;", "assertTrue ( l . contains ( Comparable . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteProxiedInterfacesAdvisedIncluded"], "fileName": "org.springframework.aop.framework.AopProxyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . addInterface ( ITestBean . class )  ;", "as . addInterface ( Comparable . class )  ;", "Class <  ?  >  [  ]    completedInterfaces    =     . completeProxiedInterfaces ( as )  ;", "assertEquals (  4  ,    completedInterfaces . length )  ;", "List <  ?  >    l    =    Arrays . asList ( completedInterfaces )  ;", "assertTrue ( l . contains ( Advised . class )  )  ;", "assertTrue ( l . contains ( ITestBean . class )  )  ;", "assertTrue ( l . contains ( Comparable . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteProxiedInterfacesAdvisedNotIncluded"], "fileName": "org.springframework.aop.framework.AopProxyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . setOpaque ( true )  ;", "as . addInterface ( ITestBean . class )  ;", "as . addInterface ( Comparable . class )  ;", "Class <  ?  >  [  ]    completedInterfaces    =     . completeProxiedInterfaces ( as )  ;", "assertEquals (  3  ,    completedInterfaces . length )  ;", "List <  ?  >    l    =    Arrays . asList ( completedInterfaces )  ;", "assertFalse ( l . contains ( Advised . class )  )  ;", "assertTrue ( l . contains ( ITestBean . class )  )  ;", "assertTrue ( l . contains ( Comparable . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteProxiedInterfacesAdvisedNotIncludedOpaque"], "fileName": "org.springframework.aop.framework.AopProxyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "Class <  ?  >  [  ]    completedInterfaces    =     . completeProxiedInterfaces ( as )  ;", "assertEquals (  2  ,    completedInterfaces . length )  ;", "List <  ?  >    ifaces    =    Arrays . asList ( completedInterfaces )  ;", "assertTrue ( ifaces . contains ( Advised . class )  )  ;", "assertTrue ( ifaces . contains ( SpringProxy . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCompleteProxiedInterfacesWorksWithNull"], "fileName": "org.springframework.aop.framework.AopProxyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AdvisedSupport   as    =    new   AdvisedSupport (  )  ;", "as . setOpaque ( true )  ;", "Class <  ?  >  [  ]    completedInterfaces    =     . completeProxiedInterfaces ( as )  ;", "assertEquals (  1  ,    completedInterfaces . length )  ;", "}", "METHOD_END"], "methodName": ["testCompleteProxiedInterfacesWorksWithNullOpaque"], "fileName": "org.springframework.aop.framework.AopProxyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTarget ( new   TestBean (  )  )  ;", "pf . addInterface ( ITestBean . class )  ;", "pf . addInterface ( Comparable . class )  ;", "Object   proxy    =    pf . getProxy (  )  ;", "Class <  ?  >  [  ]    userInterfaces    =     . proxiedUserInterfaces ( proxy )  ;", "assertEquals (  2  ,    userInterfaces . length )  ;", "assertEquals ( ITestBean . class ,    userInterfaces [  0  ]  )  ;", "assertEquals ( Comparable . class ,    userInterfaces [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testProxiedUserInterfacesWithMultipleInterfaces"], "fileName": "org.springframework.aop.framework.AopProxyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   proxy    =    Proxy . newProxyInstance ( getClass (  )  . getClassLoader (  )  ,    new   Class [  0  ]  ,     (    proxy 1  ,    method ,    args )     -  >    null )  ;", ". proxiedUserInterfaces ( proxy )  ;", "}", "METHOD_END"], "methodName": ["testProxiedUserInterfacesWithNoInterface"], "fileName": "org.springframework.aop.framework.AopProxyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTarget ( new   TestBean (  )  )  ;", "pf . addInterface ( ITestBean . class )  ;", "Object   proxy    =    pf . getProxy (  )  ;", "Class <  ?  >  [  ]    userInterfaces    =     . proxiedUserInterfaces ( proxy )  ;", "assertEquals (  1  ,    userInterfaces . length )  ;", "assertEquals ( ITestBean . class ,    userInterfaces [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testProxiedUserInterfacesWithSingleInterface"], "fileName": "org.springframework.aop.framework.AopProxyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Enhancer (  )  ;", "}", "METHOD_END"], "methodName": ["createEnhancer"], "fileName": "org.springframework.aop.framework.CglibAopProxy"}, {"methodBody": ["METHOD_START", "{", "enhancer . setInterceptDuringConstruction ( false )  ;", "enhancer . setCallbacks ( callbacks )  ;", "return    (  ( this . constructorArgs )     !  =    null )     &  &     (  ( this . constructorArgTypes )     !  =    null )     ?    enhancer . create ( this . constructorArgTypes ,    this . constructorArgs )     :    enhancer . create (  )  ;", "}", "METHOD_END"], "methodName": ["createProxyClassAndInstance"], "fileName": "org.springframework.aop.framework.CglibAopProxy"}, {"methodBody": ["METHOD_START", "{", "if    ( proxySuperClass    !  =     ( Object . class )  )     {", "Method [  ]    methods    =    proxySuperClass . getDeclaredMethods (  )  ;", "for    ( Method   method    :    methods )     {", "int   mod    =    method . getModifiers (  )  ;", "if    (  (  !  ( Modifier . isStatic ( mod )  )  )     &  &     (  !  ( Modifier . isPrivate ( mod )  )  )  )     {", "if    ( Modifier . isFinal ( mod )  )     {", "if    (  . implementsInterface ( method ,    ifcs )  )     {", ". logger . warn (  (  (  (  \" Unable   to   proxy   interface - implementing   method    [  \"     +    method )     +     \"  ]    because    \"  )     +     \" it   is   marked   as   final :    Consider   using   interface - based   JDK   proxies   instead !  \"  )  )  ;", "}", ". logger . info (  (  (  (  (  \" Final   method    [  \"     +    method )     +     \"  ]    cannot   get   proxied   via   CGLIB :     \"  )     +     \" Calls   to   this   method   will   NOT   be   routed   to   the   target   instance   and    \"  )     +     \" might   lead   to   NPEs   against   uninitialized   fields   in   the   proxy   instance .  \"  )  )  ;", "} else", "if    (  (  (  (  !  ( Modifier . isPublic ( mod )  )  )     &  &     (  !  ( Modifier . isProtected ( mod )  )  )  )     &  &     ( proxyClassLoader    !  =    null )  )     &  &     (  ( proxySuperClass . getClassLoader (  )  )     !  =    proxyClassLoader )  )     {", ". logger . info (  (  (  (  (  \" Method    [  \"     +    method )     +     \"  ]    is   package - visible   across   different   ClassLoaders    \"  )     +     \" and   cannot   get   proxied   via   CGLIB :    Declare   this   method   as   public   or   protected    \"  )     +     \" if   you   need   to   support   invocations   through   the   proxy .  \"  )  )  ;", "}", "}", "}", "doValidateClass ( proxySuperClass . getSuperclass (  )  ,    proxyClassLoader ,    ifcs )  ;", "}", "}", "METHOD_END"], "methodName": ["doValidateClass"], "fileName": "org.springframework.aop.framework.CglibAopProxy"}, {"methodBody": ["METHOD_START", "{", "boolean   exposeProxy    =    this . advised . isExposeProxy (  )  ;", "boolean   isFrozen    =    this . advised . isFrozen (  )  ;", "boolean   isStatic    =    this . advised . getTargetSource (  )  . isStatic (  )  ;", "Callback   aopInterceptor    =    new    . DynamicAdvisedInterceptor ( this . advised )  ;", "Callback   targetInterceptor ;", "if    ( exposeProxy )     {", "targetInterceptor    =     ( isStatic )     ?    new    . StaticUnadvisedExposedInterceptor ( this . advised . getTargetSource (  )  . getTarget (  )  )     :    new    . DynamicUnadvisedExposedInterceptor ( this . advised . getTargetSource (  )  )  ;", "} else    {", "targetInterceptor    =     ( isStatic )     ?    new    . StaticUnadvisedInterceptor ( this . advised . getTargetSource (  )  . getTarget (  )  )     :    new    . DynamicUnadvisedInterceptor ( this . advised . getTargetSource (  )  )  ;", "}", "Callback   targetDispatcher    =     ( isStatic )     ?    new    . StaticDispatcher ( this . advised . getTargetSource (  )  . getTarget (  )  )     :    new    . SerializableNoOp (  )  ;", "Callback [  ]    mainCallbacks    =    new   Callback [  ]  {    aopInterceptor ,    targetInterceptor ,    new    . SerializableNoOp (  )  ,    targetDispatcher ,    this . advisedDispatcher ,    new    . EqualsInterceptor ( this . advised )  ,    new    . HashCodeInterceptor ( this . advised )     }  ;", "Callback [  ]    callbacks ;", "if    ( isStatic    &  &    isFrozen )     {", "Method [  ]    methods    =    rootClass . getMethods (  )  ;", "Callback [  ]    fixedCallbacks    =    new   Callback [ methods . length ]  ;", "this . fixedInterceptorMap    =    new   HashMap <  >  ( methods . length )  ;", "for    ( int   x    =     0  ;    x    <     ( methods . length )  ;    x +  +  )     {", "List < Object >    chain    =    this . advised . getInterceptorsAndDynamicInterceptionAdvice ( methods [ x ]  ,    rootClass )  ;", "fixedCallbacks [ x ]     =    new    . FixedChainStaticTargetInterceptor ( chain ,    this . advised . getTargetSource (  )  . getTarget (  )  ,    this . advised . getTargetClass (  )  )  ;", "this . fixedInterceptorMap . put ( methods [ x ]  . toString (  )  ,    x )  ;", "}", "callbacks    =    new   Callback [  ( mainCallbacks . length )     +     ( fixedCallbacks . length )  ]  ;", "System . arraycopy ( mainCallbacks ,     0  ,    callbacks ,     0  ,    mainCallbacks . length )  ;", "System . arraycopy ( fixedCallbacks ,     0  ,    callbacks ,    mainCallbacks . length ,    fixedCallbacks . length )  ;", "this . fixedInterceptorOffset    =    mainCallbacks . length ;", "} else    {", "callbacks    =    mainCallbacks ;", "}", "return   callbacks ;", "}", "METHOD_END"], "methodName": ["getCallbacks"], "fileName": "org.springframework.aop.framework.CglibAopProxy"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    ifc    :    ifcs )     {", "if    ( ClassUtils . hasMethod ( ifc ,    method . getName (  )  ,    method . getPaterTypes (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["implementsInterface"], "fileName": "org.springframework.aop.framework.CglibAopProxy"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( returnValue    !  =    null )     &  &     ( returnValue    =  =    target )  )     &  &     (  !  ( RawTargetAccess . class . isAssignableFrom ( method . getDeclaringClass (  )  )  )  )  )     {", "returnValue    =    proxy ;", "}", "Class <  ?  >    returnType    =    method . getReturnType (  )  ;", "if    (  (  ( returnValue    =  =    null )     &  &     ( returnType    !  =     ( Void . TYPE )  )  )     &  &     ( returnType . isPrimitive (  )  )  )     {", "throw   new   AopInvocationException (  (  \" Null   return   value   from   advice   does   not   match   primitive   return   type   for :     \"     +    method )  )  ;", "}", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["processReturnType"], "fileName": "org.springframework.aop.framework.CglibAopProxy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( constructorArgs    =  =    null )     |  |     ( constructorArgTypes    =  =    null )  )     {", "throw   new   IllegalArgumentException (  \" Both    ' constructorArgs '    and    ' constructorArgTypes '    need   to   be   specified \"  )  ;", "}", "if    (  ( constructorArgs . length )     !  =     ( constructorArgTypes . length )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Number   of    ' constructorArgs '     (  \"     +     ( constructorArgs . length )  )     +     \"  )    must   match   number   of    ' constructorArgTypes '     (  \"  )     +     ( constructorArgTypes . length )  )     +     \"  )  \"  )  )  ;", "}", "this . constructorArgs    =    constructorArgs ;", "this . constructorArgTypes    =    constructorArgTypes ;", "}", "METHOD_END"], "methodName": ["setConstructorArguments"], "fileName": "org.springframework.aop.framework.CglibAopProxy"}, {"methodBody": ["METHOD_START", "{", "if    ( CglibAopProxy . logger . isWarnEnabled (  )  )     {", "synchronized ( CglibAopProxy . validatedClasses )     {", "if    (  !  ( CglibAopProxy . validatedClasses . containsKey ( proxySuperClass )  )  )     {", "doValidateClass ( proxySuperClass ,    proxyClassLoader ,    ClassUtils . getAllInterfacesForClassAsSet ( proxySuperClass )  )  ;", "CglibAopProxy . validatedClasses . put ( proxySuperClass ,    Boolean . TRUE )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["validateClassIfNecessary"], "fileName": "org.springframework.aop.framework.CglibAopProxy"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( config . getAdvisors (  )  . length )  ;    i +  +  )     {", "Advisor   advisor    =    config . getAdvisors (  )  [ i ]  ;", "if    ( advisor   instanceof   IntroductionAdvisor )     {", "IntroductionAdvisor   ia    =     (  ( IntroductionAdvisor )     ( advisor )  )  ;", "if    ( ia . getClassFilter (  )  . matches ( actualClass )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasMatchingIntroductions"], "fileName": "org.springframework.aop.framework.DefaultAdvisorChainFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    ifcs    =    config . getProxiedInterfaces (  )  ;", "return    (  ( ifcs . length )     =  =     0  )     |  |     (  (  ( ifcs . length )     =  =     1  )     &  &     ( SProxy . class . isAssignableFrom ( ifcs [  0  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasNoUserSuppliedProxyInterfaces"], "fileName": "org.springframework.aop.framework.DefaultAopProxyFactory"}, {"methodBody": ["METHOD_START", "{", "StopWatch   sw    =    new   StopWatch (  )  ;", "TestBean   target    =    new   TestBean (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "pf . setProxyTargetClass ( false )  ;", "pf . addAdvice ( new    . SimpleCounterIntroduction (  )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", ". Counter   counter    =     (  (  . Counter )     ( proxy )  )  ;", "sw . start (  (  (  . INVOCATIONS )     +     \"    invocations   on   proxy ,    not   hitting   introduction \"  )  )  ;", "for    ( int   i    =     0  ;    i    <     (  . INVOCATIONS )  ;    i +  +  )     {", "proxy . getAge (  )  ;", "}", "sw . stop (  )  ;", "sw . start (  (  (  . INVOCATIONS )     +     \"    invocations   on   proxy ,    hitting   introduction \"  )  )  ;", "for    ( int   i    =     0  ;    i    <     (  . INVOCATIONS )  ;    i +  +  )     {", "counter . getCount (  )  ;", "}", "sw . stop (  )  ;", "sw . start (  (  (  . INVOCATIONS )     +     \"    invocations   on   target \"  )  )  ;", "for    ( int   i    =     0  ;    i    <     (  . INVOCATIONS )  ;    i +  +  )     {", "target . getAge (  )  ;", "}", "sw . stop (  )  ;", "System . out . println ( sw . prettyPrint (  )  )  ;", "}", "METHOD_END"], "methodName": ["timeManyInvocations"], "fileName": "org.springframework.aop.framework.IntroductionBenchmarkTests"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    proxiedInterface    :    proxiedInterfaces )     {", "Method [  ]    methods    =    proxiedInterface . getDeclaredMethods (  )  ;", "for    ( Method   method    :    methods )     {", "if    ( AopUtils . isEqualsMethod ( method )  )     {", "this . equalsDefined    =    true ;", "}", "if    ( AopUtils . isHashCodeMethod ( method )  )     {", "this . hashCodeDefined    =    true ;", "}", "if    (  ( this . equalsDefined )     &  &     ( this . hashCodeDefined )  )     {", "return ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["findDefinedEqualsAndHashCodeMethods"], "fileName": "org.springframework.aop.framework.JdkDynamicAopProxy"}, {"methodBody": ["METHOD_START", "{", "Object   target    =    new   TestBean (  )     {", "@ Override", "public   String   toString (  )     {", "throw   new   UnsupportedOperationException (  \" toString \"  )  ;", "}", "}  ;", "List < Object >    is    =    new   LinkedList <  >  (  )  ;", "Method   m    =    Object . class . getMethod (  \" hashCode \"  )  ;", "Object   proxy    =    new   Object (  )  ;", "Reflective   invocation    =    new   Reflective ( proxy ,    target ,    m ,    null ,    null ,    is )  ;", "invocation . toString (  )  ;", "}", "METHOD_END"], "methodName": ["testToStringDoesntHitTarget"], "fileName": "org.springframework.aop.framework.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    Object . class . getMethod (  \" hashCode \"  )  ;", "Object   proxy    =    new   Object (  )  ;", "final   Object   returnValue    =    new   Object (  )  ;", "List < Object >    is    =    new   LinkedList <  >  (  )  ;", "is . add ( new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke (    invocation )    throws   Throwable    {", "return   returnValue ;", "}", "}  )  ;", "Reflective   invocation    =    new   Reflective ( proxy ,    null ,    m ,    null ,    null ,    is )  ;", "Object   rv    =    invocation . proceed (  )  ;", "assertTrue (  \" correct   response \"  ,     ( rv    =  =    returnValue )  )  ;", "}", "METHOD_END"], "methodName": ["testValidInvocation"], "fileName": "org.springframework.aop.framework.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "NullPrimitiveTests . Bar   target    =    new   NullPrimitiveTests . Bar (  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( target )  ;", "factory . addAdvice ( new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "return   null ;", "}", "}  )  ;", "NullPrimitiveTests . Bar   bar    =     (  ( NullPrimitiveTests . Bar )     ( factory . getProxy (  )  )  )  ;", "thrown . expect ( AopInvocationException . class )  ;", "thrown . expectMessage (  \" Bar . getValue (  )  \"  )  ;", "assertEquals (  0  ,    bar . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNullPrimitiveWithCglibProxy"], "fileName": "org.springframework.aop.framework.NullPrimitiveTests"}, {"methodBody": ["METHOD_START", "{", "class   SimpleFoo   implements   NullPrimitiveTests . Foo    {", "@ Override", "public   int   getValue (  )     {", "return    1  0  0  ;", "}", "}", "SimpleFoo   target    =    new   SimpleFoo (  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( target )  ;", "factory . addAdvice ( new   MethodInterceptor (  )     {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "return   null ;", "}", "}  )  ;", "NullPrimitiveTests . Foo   foo    =     (  ( NullPrimitiveTests . Foo )     ( factory . getProxy (  )  )  )  ;", "thrown . expect ( AopInvocationException . class )  ;", "thrown . expectMessage (  \" Foo . getValue (  )  \"  )  ;", "assertEquals (  0  ,    foo . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNullPrimitiveWithJdkProxy"], "fileName": "org.springframework.aop.framework.NullPrimitiveTests"}, {"methodBody": ["METHOD_START", "{", "PrototypeTargetTests . TestBeanImpl . constructionCount    =     0  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( PrototypeTargetTests . CONTEXT )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "PrototypeTargetTests . TestBean   tb    =     (  ( PrototypeTargetTests . TestBean )     ( bf . getBean (  \" testBeanPrototype \"  )  )  )  ;", "tb . doSomething (  )  ;", "}", "PrototypeTargetTests . TestInterceptor   interceptor    =     (  ( PrototypeTargetTests . TestInterceptor )     ( bf . getBean (  \" testInterceptor \"  )  )  )  ;", "assertEquals (  1  0  ,    PrototypeTargetTests . TestBeanImpl . constructionCount )  ;", "assertEquals (  1  0  ,    interceptor . invocationCount )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeProxyWithPrototypeTarget"], "fileName": "org.springframework.aop.framework.PrototypeTargetTests"}, {"methodBody": ["METHOD_START", "{", "PrototypeTargetTests . TestBeanImpl . constructionCount    =     0  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( PrototypeTargetTests . CONTEXT )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "PrototypeTargetTests . TestBean   tb    =     (  ( PrototypeTargetTests . TestBean )     ( bf . getBean (  \" testBeanSingleton \"  )  )  )  ;", "tb . doSomething (  )  ;", "}", "PrototypeTargetTests . TestInterceptor   interceptor    =     (  ( PrototypeTargetTests . TestInterceptor )     ( bf . getBean (  \" testInterceptor \"  )  )  )  ;", "assertEquals (  1  ,    PrototypeTargetTests . TestBeanImpl . constructionCount )  ;", "assertEquals (  1  0  ,    interceptor . invocationCount )  ;", "}", "METHOD_END"], "methodName": ["testSingletonProxyWithPrototypeTarget"], "fileName": "org.springframework.aop.framework.PrototypeTargetTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \" Other   ProxyConfig   object   must   not   be   null \"  )  ;", "this . proxyTargetClass    =    other . proxyTargetClass ;", "this . optimize    =    other . optimize ;", "this . exposeProxy    =    other . exposeProxy ;", "this . frozen    =    other . frozen ;", "this . opaque    =    other . opaque ;", "}", "METHOD_END"], "methodName": ["copyFrom"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . exposeProxy ;", "}", "METHOD_END"], "methodName": ["isExposeProxy"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . frozen ;", "}", "METHOD_END"], "methodName": ["isFrozen"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . opaque ;", "}", "METHOD_END"], "methodName": ["isOpaque"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . optimize ;", "}", "METHOD_END"], "methodName": ["isOptimize"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . proxyTargetClass ;", "}", "METHOD_END"], "methodName": ["isProxyTargetClass"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "this . exposeProxy    =    exposeProxy ;", "}", "METHOD_END"], "methodName": ["setExposeProxy"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "this . frozen    =    frozen ;", "}", "METHOD_END"], "methodName": ["setFrozen"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "this . opaque    =    opaque ;", "}", "METHOD_END"], "methodName": ["setOpaque"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "this . optimize    =    optimize ;", "}", "METHOD_END"], "methodName": ["setOptimize"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "this . proxyTargetClass    =    proxyTargetClass ;", "}", "METHOD_END"], "methodName": ["setProxyTargetClass"], "fileName": "org.springframework.aop.framework.ProxyConfig"}, {"methodBody": ["METHOD_START", "{", "this . active    =    true ;", "for    ( AdvisedListener   listener    :    this . listeners )     {", "listener . activated ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["activate"], "fileName": "org.springframework.aop.framework.ProxyCreatorSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( listener ,     \" AdvisedSupportListener   must   not   be   null \"  )  ;", "this . listeners . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.springframework.aop.framework.ProxyCreatorSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . active )  )     {", "activate (  )  ;", "}", "return   getAopFactory (  )  . createAop ( this )  ;", "}", "METHOD_END"], "methodName": ["createAopProxy"], "fileName": "org.springframework.aop.framework.ProxyCreatorSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . aopProxyFactory ;", "}", "METHOD_END"], "methodName": ["getAopProxyFactory"], "fileName": "org.springframework.aop.framework.ProxyCreatorSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . active ;", "}", "METHOD_END"], "methodName": ["isActive"], "fileName": "org.springframework.aop.framework.ProxyCreatorSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( listener ,     \" AdvisedSupportListener   must   not   be   null \"  )  ;", "this . listeners . remove ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "org.springframework.aop.framework.ProxyCreatorSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( aopProxyFactory ,     \" AopProxyFactory   must   not   be   null \"  )  ;", "this . aopProxyFactory    =    aopProxyFactory ;", "}", "METHOD_END"], "methodName": ["setAopProxyFactory"], "fileName": "org.springframework.aop.framework.ProxyCreatorSupport"}, {"methodBody": ["METHOD_START", "{", "return   createAopProxy (  )  . getProxy (  )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.aop.framework.ProxyFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( new   ProxyFactory ( proxyInterface ,    interceptor )  . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.aop.framework.ProxyFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( new   ProxyFactory ( proxyInterface ,    targetSource )  . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.aop.framework.ProxyFactory"}, {"methodBody": ["METHOD_START", "{", "return   createAopProxy (  )  . getProxy ( classLoader )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.aop.framework.ProxyFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( targetSource . getTargetClass (  )  )     =  =    null )     {", "throw   new   IllegalArgumentException (  \" Cannot   create   class   proxy   for   TargetSource   with   null   target   class \"  )  ;", "}", "proxyFactory    =    new    (  )  ;", "proxyFactory . setTargetSource ( targetSource )  ;", "proxyFactory . setProxyTargetClass ( true )  ;", "return   proxyFactory . getProxy (  )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.aop.framework.ProxyFactory"}, {"methodBody": ["METHOD_START", "{", "Advisor   advisor    =    namedBeanToAdvisor ( next )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" Adding   advisor   with   name    '  \"     +    name )     +     \"  '  \"  )  )  ;", "}", "addAdvisor ( advisor )  ;", "}", "METHOD_END"], "methodName": ["addAdvisorOnChainCreation"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "String [  ]    globalAdvisorNames    =    BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( beanFactory ,    Advisor . class )  ;", "String [  ]    globalInterceptorNames    =    BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( beanFactory ,    Interceptor . class )  ;", "List < Object >    beans    =    new   ArrayList <  >  (  (  ( globalAdvisorNames . length )     +     ( globalInterceptorNames . length )  )  )  ;", "Map < Object ,    String >    names    =    new   HashMap <  >  ( beans . size (  )  )  ;", "for    ( String   name    :    globalAdvisorNames )     {", "Object   bean    =    beanFactory . getBean ( name )  ;", "beans . add ( bean )  ;", "names . put ( bean ,    name )  ;", "}", "for    ( String   name    :    globalInterceptorNames )     {", "Object   bean    =    beanFactory . getBean ( name )  ;", "beans . add ( bean )  ;", "names . put ( bean ,    name )  ;", "}", "AnnotationAwareOrderComparator . sort ( beans )  ;", "for    ( Object   bean    :    beans )     {", "String   name    =    names . get ( bean )  ;", "if    ( name . startsWith ( prefix )  )     {", "addAdvisorOnChainCreation ( bean ,    name )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addGlobalAdvisor"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ObjectUtils . isEmpty ( this . interceptorNames )  )  )     {", "String   finalName    =    this . interceptorNames [  (  ( this . interceptorNames . length )     -     1  )  ]  ;", "if    (  (  ( this . targetName )     =  =    null )     &  &     (  ( this . targetSource )     =  =     ( AdvisedSupport . EMPTY _ TARGET _ SOURCE )  )  )     {", "if    (  (  !  ( finalName . endsWith (  . GLOBAL _ SUFFIX )  )  )     &  &     (  !  ( isNamedBeanAnAdvisorOrAdvice ( finalName )  )  )  )     {", "this . targetName    =    finalName ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Bean   with   name    '  \"     +    finalName )     +     \"  '    concluding   interceptor   chain    \"  )     +     \" is   not   an   advisor   class :    treating   it   as   a   target   or   TargetSource \"  )  )  ;", "}", "String [  ]    newNames    =    new   String [  ( this . interceptorNames . length )     -     1  ]  ;", "System . arraycopy ( this . interceptorNames ,     0  ,    newNames ,     0  ,    newNames . length )  ;", "this . interceptorNames    =    newNames ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkInterceptorNames"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . createCompositeInterface ( interfaces ,    this . proxyClassLoader )  ;", "}", "METHOD_END"], "methodName": ["createCompositeInterface"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Advisor [  ]    advisors    =    getAdvisors (  )  ;", "List < Advisor >    freshAdvisors    =    new   ArrayList <  >  ( advisors . length )  ;", "for    ( Advisor   advisor    :    advisors )     {", "if    ( advisor   instanceof    . PrototypePlaceholderAdvisor )     {", ". PrototypePlaceholderAdvisor   pa    =     (  (  . PrototypePlaceholderAdvisor )     ( advisor )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Refreshing   bean   named    '  \"     +     ( pa . getBeanName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "if    (  ( this . beanFactory )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  \" No   BeanFactory   available   anymore    ( probably   due   to   serialization )     \"     +     \"  -    cannot   resolve   prototype   advisor    '  \"  )     +     ( pa . getBeanName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "Object   bean    =    this . beanFactory . getBean ( pa . getBeanName (  )  )  ;", "Advisor   refreshedAdvisor    =    namedBeanToAdvisor ( bean )  ;", "freshAdvisors . add ( refreshedAdvisor )  ;", "} else    {", "freshAdvisors . add ( advisor )  ;", "}", "}", "return   freshAdvisors ;", "}", "METHOD_END"], "methodName": ["freshAdvisorChain"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . targetName )     =  =    null )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  \" Not   refreshing   target :    Bean   name   not   specified   in    ' interceptorNames '  .  \"  )  ;", "}", "return   this . targetSource ;", "} else    {", "if    (  ( this . bean )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  \" No   Bean   available   anymore    ( probably   due   to   serialization )     \"     +     \"  -    cannot   resolve   target   with   name    '  \"  )     +     ( this . targetName )  )     +     \"  '  \"  )  )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Refreshing   target   with   name    '  \"     +     ( this . targetName )  )     +     \"  '  \"  )  )  ;", "}", "Object   target    =    this . bean . getBean ( this . targetName )  ;", "return   target   instanceof   TargetSource    ?     (  ( TargetSource )     ( target )  )     :    new   SingletonTargetSource ( target )  ;", "}", "}", "METHOD_END"], "methodName": ["freshTargetSource"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   aopProxy . getProxy ( this . proxyClassLoader )  ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . singletonInstance )     =  =    null )     {", "this . targetSource    =    freshTargetSource (  )  ;", "if    (  (  ( this . autodetectInterfaces )     &  &     (  ( getProxiedInterfaces (  )  . length )     =  =     0  )  )     &  &     (  !  ( isProxyTargetClass (  )  )  )  )     {", "Class <  ?  >    targetClass    =    getTargetClass (  )  ;", "if    ( targetClass    =  =    null )     {", "throw   new   NotInitializedException (  \" Cannot   determine   target   class   for   proxy \"  )  ;", "}", "setInterfaces ( ClassUtils . getAllInterfacesForClass ( targetClass ,    this . proxyClassLoader )  )  ;", "}", "super . setFrozen ( this . freezeProxy )  ;", "this . singletonInstance    =    getProxy ( createAopProxy (  )  )  ;", "}", "return   this . singletonInstance ;", "}", "METHOD_END"], "methodName": ["getSingletonInstance"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( this . advisorChainInitialized )     {", "return ;", "}", "if    (  !  ( ObjectUtils . isEmpty ( this . interceptorNames )  )  )     {", "if    (  ( this . beanFactory )     =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No   BeanFactory   available   anymore    ( probably   due   to   serialization )     \"     +     \"  -    cannot   resolve   interceptor   names    \"  )     +     ( Arrays . asList ( this . interceptorNames )  )  )  )  ;", "}", "if    (  (  ( this . interceptorNames [  (  ( this . interceptorNames . length )     -     1  )  ]  . endsWith (  . GLOBAL _ SUFFIX )  )     &  &     (  ( this . targetName )     =  =    null )  )     &  &     (  ( this . targetSource )     =  =     ( AdvisedSupport . EMPTY _ TARGET _ SOURCE )  )  )     {", "throw   new   AopConfigException (  \" Target   required   after   globals \"  )  ;", "}", "for    ( String   name    :    this . interceptorNames )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" Configuring   advisor   or   advice    '  \"     +    name )     +     \"  '  \"  )  )  ;", "}", "if    ( name . endsWith (  . GLOBAL _ SUFFIX )  )     {", "if    (  !  (  ( this . beanFactory )    instanceof   ListableBeanFactory )  )     {", "throw   new   AopConfigException (  \" Can   only   use   global   advisors   or   interceptors   with   a   ListableBeanFactory \"  )  ;", "}", "addGlobalAdvisor (  (  ( ListableBeanFactory )     ( this . beanFactory )  )  ,    name . substring (  0  ,     (  ( name . length (  )  )     -     (  . GLOBAL _ SUFFIX . length (  )  )  )  )  )  ;", "} else    {", "Object   advice ;", "if    (  ( this . singleton )     |  |     ( this . beanFactory . isSingleton ( name )  )  )     {", "advice    =    this . beanFactory . getBean ( name )  ;", "} else    {", "advice    =    new    . PrototypePlaceholderAdvisor ( name )  ;", "}", "addAdvisorOnChainCreation ( advice ,    name )  ;", "}", "}", "}", "this . advisorChainInitialized    =    true ;", "}", "METHOD_END"], "methodName": ["initializeAdvisorChain"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" No   BeanFactory   set \"  )  ;", "Class <  ?  >    namedBeanClass    =    this . beanFactory . getType ( beanName )  ;", "if    ( namedBeanClass    !  =    null )     {", "return    ( Advisor . class . isAssignableFrom ( namedBeanClass )  )     |  |     ( Advice . class . isAssignableFrom ( namedBeanClass )  )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Could   not   determine   type   of   bean   with   name    '  \"     +    beanName )     +     \"  '     -    assuming   it   is   neither   an   Advisor   nor   an   Advice \"  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isNamedBeanAnAdvisorOrAdvice"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   this . advisorAdapterRegistry . wrap ( next )  ;", "}    catch    ( UnknownAdviceTypeException   ex )     {", "throw   new   AopConfigException (  (  (  (  \" Unknown   advisor   type    \"     +     ( next . getClass (  )  )  )     +     \"  ;    Can   only   include   Advisor   or   Advice   type   beans   in   interceptorNs   chain   except   for   last   entry ,  \"  )     +     \" which   may   also   be   target   or   TargetSource \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["namedBeanToAdvisor"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Creating   copy   of   prototype      config :     \"     +     ( this )  )  )  ;", "}", "ProxyCreatorSupport   copy    =    new   ProxyCreatorSupport ( getAopProxyFactory (  )  )  ;", "TargetSource   targetSource    =    freshTargetSource (  )  ;", "copy . copyConfigurationFrom ( this ,    targetSource ,    freshAdvisorChain (  )  )  ;", "if    (  (  ( this . autodetectInterfaces )     &  &     (  ( getProxiedInterfaces (  )  . length )     =  =     0  )  )     &  &     (  !  ( isProxyTargetClass (  )  )  )  )     {", "Class <  ?  >    targetClass    =    targetSource . getTargetClass (  )  ;", "if    ( targetClass    !  =    null )     {", "copy . setInterfaces ( ClassUtils . getAllInterfacesForClass ( targetClass ,    this . proxyClassLoader )  )  ;", "}", "}", "copy . setFrozen ( this . freezeProxy )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  \" Using   ProxyCreatorSupport   copy :     \"     +    copy )  )  ;", "}", "return   getProxy ( copy . createAopProxy (  )  )  ;", "}", "METHOD_END"], "methodName": ["newPrototypeInstance"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "this . pClassLoader    =    ClassUtils . getDefaultClassLoader (  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . advisorAdapterRegistry    =    advisorAdapterRegistry ;", "}", "METHOD_END"], "methodName": ["setAdvisorAdapterRegistry"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . autodetectInterfaces    =    autodetectInterfaces ;", "}", "METHOD_END"], "methodName": ["setAutodetectInterfaces"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . interceptorNames    =    interceptorNames ;", "}", "METHOD_END"], "methodName": ["setInterceptorNames"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . proxyClassLoader    =    classLoader ;", "this . classLoaderConfigured    =    classLoader    !  =    null ;", "}", "METHOD_END"], "methodName": ["setProxyClassLoader"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "setInterfaces ( proxyInterfaces )  ;", "}", "METHOD_END"], "methodName": ["setProxyInterfaces"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . singleton    =    singleton ;", "}", "METHOD_END"], "methodName": ["setSingleton"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . targetName    =    targetName ;", "}", "METHOD_END"], "methodName": ["setTargetName"], "fileName": "org.springframework.aop.framework.ProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "TimeStamped   tst    =    new   TimeStamped (  )     {", "@ Override", "public   long   getTimeStamp (  )     {", "throw   new   UnsupportedOperationException (  \" getTimeStamp \"  )  ;", "}", "}  ;", "pf    =    new    ( tst )  ;", "pf . addInterface ( TimeStamped . class )  ;", "assertThat ( pf . getProxy (  )  ,    instanceOf ( TimeStamped . class )  )  ;", "}", "METHOD_END"], "methodName": ["testAddRepeatedInterface"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   config    =    new   ProxyFactory ( new   TestBean (  )  )  ;", "assertFalse (  \" Shouldn ' t   implement   TimeStamped   before   manipulation \"  ,     (  ( config . getProxy (  )  )    instanceof   TimeStamped )  )  ;", "long   time    =     6  6  6 L ;", ". TimestampIntroductionInterceptor   ti    =    new    . TimestampIntroductionInterceptor (  )  ;", "ti . setTime ( time )  ;", "int   oldCount    =    config . getAdvisors (  )  . length ;", "config . addAdvisor (  0  ,    new   DefaultIntroductionAdvisor ( ti ,    TimeStamped . class )  )  ;", "assertTrue (  (  ( config . getAdvisors (  )  . length )     =  =     ( oldCount    +     1  )  )  )  ;", "TimeStamped   ts    =     (  ( TimeStamped )     ( config . getProxy (  )  )  )  ;", "assertTrue (  (  ( ts . getTimeStamp (  )  )     =  =    time )  )  ;", "config . removeAdvice ( ti )  ;", "assertTrue (  (  ( config . getAdvisors (  )  . length )     =  =    oldCount )  )  ;", "try    {", "ts . getTimeStamp (  )  ;", "fail (  \" Existing   object   won ' t   implement   this   interface   any   more \"  )  ;", "}    catch    ( RuntimeException   ex )     {", "}", "assertFalse (  \" Should   no   longer   implement   TimeStamped \"  ,     (  ( config . getProxy (  )  )    instanceof   TimeStamped )  )  ;", "config . removeAdvice ( new   DebugInterceptor (  )  )  ;", "assertTrue (  (  ( config . getAdvisors (  )  . length )     =  =    oldCount )  )  ;", "ITestBean   it    =     (  ( ITestBean )     ( ts )  )  ;", "DebugInterceptor   debugInterceptor    =    new   DebugInterceptor (  )  ;", "config . addAdvice (  0  ,    debugInterceptor )  ;", "it . getSpouse (  )  ;", "assertEquals (  1  ,    debugInterceptor . getCount (  )  )  ;", "config . removeAdvice ( debugInterceptor )  ;", "it . getSpouse (  )  ;", "assertTrue (  (  ( debugInterceptor . getCount (  )  )     =  =     1  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanAddAndRemoveAspectInterfacesOnSingleton"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "JFrame   frame    =    new   JFrame (  )  ;", "proxyFactory    =    new    ( frame )  ;", "Object   proxy    =    proxyFactory . getProxy (  )  ;", "assertTrue (  ( proxy   instanceof   RootPaneContainer )  )  ;", "assertTrue (  ( proxy   instanceof   Accessible )  )  ;", "}", "METHOD_END"], "methodName": ["testExclusionOfNonPublicInterfaces"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "class   TestBeanSubclass   extends   TestBean   implements   Comparable < Object >     {", "@ Override", "public   int   compareTo ( Object   arg 0  )     {", "throw   new   UnsupportedOperationException (  \" compareTo \"  )  ;", "}", "}", "TestBeanSubclass   raw    =    new   TestBeanSubclass (  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( raw )  ;", "assertEquals (  \" Found   correct   number   of   interfaces \"  ,     5  ,    factory . getProxiedInterfaces (  )  . length )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( factory . getProxy (  )  )  )  ;", "assertThat (  \" Picked   up   secondary   interface \"  ,    tb ,    instanceOf ( IOther . class )  )  ;", "raw . setAge (  2  5  )  ;", "assertTrue (  (  ( tb . getAge (  )  )     =  =     ( raw . getAge (  )  )  )  )  ;", "long   t    =     5  5  5  5  5  5 L ;", ". TimestampIntroductionInterceptor   ti    =    new    . TimestampIntroductionInterceptor ( t )  ;", "Class <  ?  >  [  ]    oldProxiedInterfaces    =    factory . getProxiedInterfaces (  )  ;", "factory . addAdvisor (  0  ,    new   DefaultIntroductionAdvisor ( ti ,    TimeStamped . class )  )  ;", "Class <  ?  >  [  ]    newProxiedInterfaces    =    factory . getProxiedInterfaces (  )  ;", "assertEquals (  \" Advisor   proxies   one   more   interface   after   introduction \"  ,     (  ( oldProxiedInterfaces . length )     +     1  )  ,    newProxiedInterfaces . length )  ;", "TimeStamped   ts    =     (  ( TimeStamped )     ( factory . getProxy (  )  )  )  ;", "assertTrue (  (  ( ts . getTimeStamp (  )  )     =  =    t )  )  ;", "(  ( IOther )     ( ts )  )  . absquatulate (  )  ;", "}", "METHOD_END"], "methodName": ["testGetsAllInterfaces"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "pf    =    new    ( target )  ;", "NopInterceptor   nop    =    new   NopInterceptor (  )  ;", "Advisor   advisor    =    new   DefaultPointcutAdvisor ( new   CountingBeforeAdvice (  )  )  ;", "Advised   advised    =     (  ( Advised )     ( pf . getProxy (  )  )  )  ;", "advised . addAdvice ( nop )  ;", "pf . addAdvisor ( advisor )  ;", "assertEquals (  (  -  1  )  ,    pf . indexOf ( new   NopInterceptor (  )  )  )  ;", "assertEquals (  0  ,    pf . indexOf ( nop )  )  ;", "assertEquals (  1  ,    pf . indexOf ( advisor )  )  ;", "assertEquals (  (  -  1  )  ,    advised . indexOf ( new   DefaultPointcutAdvisor ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexOfMethods"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "class   MyInterceptor   implements   MethodInterceptor    {", "@ Override", "public   Object   invoke ( MethodInvocation   invocation )    throws   Throwable    {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}", "NopInterceptor   di    =    new   NopInterceptor (  )  ;", "NopInterceptor   diUnused    =    new   NopInterceptor (  )  ;", "factory    =    new    ( new   TestBean (  )  )  ;", "factory . addAdvice (  0  ,    di )  ;", "assertThat ( factory . getProxy (  )  ,    instanceOf ( ITestBean . class )  )  ;", "assertTrue ( factory . adviceIncluded ( di )  )  ;", "assertTrue (  (  !  ( factory . adviceIncluded ( diUnused )  )  )  )  ;", "assertTrue (  (  ( factory . countAdvicesOfType ( NopInterceptor . class )  )     =  =     1  )  )  ;", "assertTrue (  (  ( factory . countAdvicesOfType ( MyInterceptor . class )  )     =  =     0  )  )  ;", "factory . addAdvice (  0  ,    diUnused )  ;", "assertTrue ( factory . adviceIncluded ( diUnused )  )  ;", "assertTrue (  (  ( factory . countAdvicesOfType ( NopInterceptor . class )  )     =  =     2  )  )  ;", "}", "METHOD_END"], "methodName": ["testInterceptorInclusionMethods"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "final   TestBean   target    =    new   TestBean (  \" tb \"  )  ;", "ITestBean   proxy    =     . getProxy ( ITestBean . class ,     (  ( MethodInterceptor )     (  (    invocation )     -  >     {", "assertNull ( invocation . getThis (  )  )  ;", "return   invocation . getMethod (  )  . invoke ( target ,    invocation . getArguments (  )  )  ;", "}  )  )  )  ;", "assertEquals (  \" tb \"  ,    proxy . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInterceptorWithoutJoinpoint"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Object   proxy 1     =    new   ProxyFactory ( new   ProxyFactoryTests . A (  )  )  . getProxy (  )  ;", "Object   proxy 2     =    new   ProxyFactory ( new   ProxyFactoryTests . B (  )  )  . getProxy (  )  ;", "List < Object >    list    =    new   ArrayList <  >  (  2  )  ;", "list . add ( proxy 1  )  ;", "list . add ( proxy 2  )  ;", "AnnotationAwareOrderComparator . sort ( list )  ;", "assertSame ( proxy 2  ,    list . get (  0  )  )  ;", "assertSame ( proxy 1  ,    list . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testInterfaceProxiesCanBeOrderedThroughAnnotations"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTargetClass ( TestBean . class )  ;", "Object   proxy    =    pf . getProxy (  )  ;", "assertTrue (  \" Proxy   is   a   CGLIB   proxy \"  ,    AopUtils . isCglibProxy ( proxy )  )  ;", "assertTrue (  ( proxy   instanceof   TestBean )  )  ;", "assertEquals ( TestBean . class ,    AopProxyUtils . ultimateTargetClass ( proxy )  )  ;", "ProxyFactory   pf 2     =    new   ProxyFactory ( proxy )  ;", "pf 2  . setProxyTargetClass ( true )  ;", "Object   proxy 2     =    pf 2  . getProxy (  )  ;", "assertTrue (  \" Proxy   is   a   CGLIB   proxy \"  ,    AopUtils . isCglibProxy ( proxy 2  )  )  ;", "assertTrue (  ( proxy 2    instanceof   TestBean )  )  ;", "assertEquals ( TestBean . class ,    AopProxyUtils . ultimateTargetClass ( proxy 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyTargetClassWithConcreteClassAsTarget"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTargetClass ( ITestBean . class )  ;", "Object   proxy    =    pf . getProxy (  )  ;", "assertTrue (  \" Proxy   is   a   JDK   proxy \"  ,    AopUtils . isJdkDynamicProxy ( proxy )  )  ;", "assertTrue (  ( proxy   instanceof   ITestBean )  )  ;", "assertEquals ( ITestBean . class ,    AopProxyUtils . ultimateTargetClass ( proxy )  )  ;", "ProxyFactory   pf 2     =    new   ProxyFactory ( proxy )  ;", "Object   proxy 2     =    pf 2  . getProxy (  )  ;", "assertTrue (  \" Proxy   is   a   JDK   proxy \"  ,    AopUtils . isJdkDynamicProxy ( proxy 2  )  )  ;", "assertTrue (  ( proxy 2    instanceof   ITestBean )  )  ;", "assertEquals ( ITestBean . class ,    AopProxyUtils . ultimateTargetClass ( proxy 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyTargetClassWithInterfaceAsTarget"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "pf    =    new    ( target )  ;", "NopInterceptor   nop    =    new   NopInterceptor (  )  ;", "CountingBeforeAdvice   cba    =    new   CountingBeforeAdvice (  )  ;", "Advisor   advisor    =    new   DefaultPointcutAdvisor ( cba )  ;", "pf . addAdvice ( nop )  ;", "pf . addAdvisor ( advisor )  ;", "NopInterceptor   nop 2     =    new   NopInterceptor (  )  ;", "pf . addAdvice ( nop 2  )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "proxied . setAge (  5  )  ;", "assertEquals (  1  ,    cba . getCalls (  )  )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "assertEquals (  1  ,    nop 2  . getCount (  )  )  ;", "pf . removeAdvisor (  1  )  ;", "assertEquals (  5  ,    proxied . getAge (  )  )  ;", "assertEquals (  1  ,    cba . getCalls (  )  )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "assertEquals (  2  ,    nop 2  . getCount (  )  )  ;", "pf . removeAdvisor (  0  )  ;", "assertEquals (  5  ,    proxied . getAge (  )  )  ;", "assertEquals (  1  ,    cba . getCalls (  )  )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "assertEquals (  3  ,    nop 2  . getCount (  )  )  ;", "try    {", "pf . removeAdvisor (  (  -  1  )  )  ;", "}    catch    ( AopConfigException   ex )     {", "}", "try    {", "pf . removeAdvisor (  2  )  ;", "}    catch    ( AopConfigException   ex )     {", "}", "assertEquals (  5  ,    proxied . getAge (  )  )  ;", "assertEquals (  4  ,    nop 2  . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveAdvisorByIndex"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "pf    =    new    ( target )  ;", "NopInterceptor   nop    =    new   NopInterceptor (  )  ;", "CountingBeforeAdvice   cba    =    new   CountingBeforeAdvice (  )  ;", "Advisor   advisor    =    new   DefaultPointcutAdvisor ( cba )  ;", "pf . addAdvice ( nop )  ;", "pf . addAdvisor ( advisor )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "proxied . setAge (  5  )  ;", "assertEquals (  1  ,    cba . getCalls (  )  )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "assertTrue ( pf . removeAdvisor ( advisor )  )  ;", "assertEquals (  5  ,    proxied . getAge (  )  )  ;", "assertEquals (  1  ,    cba . getCalls (  )  )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "assertFalse ( pf . removeAdvisor ( new   DefaultPointcutAdvisor ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveAdvisorByReference"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "pf    =    new    ( target )  ;", "NopInterceptor   nop    =    new   NopInterceptor (  )  ;", "CountingBeforeAdvice   cba 1     =    new   CountingBeforeAdvice (  )  ;", "CountingBeforeAdvice   cba 2     =    new   CountingBeforeAdvice (  )  ;", "Advisor   advisor 1     =    new   DefaultPointcutAdvisor ( cba 1  )  ;", "Advisor   advisor 2     =    new   DefaultPointcutAdvisor ( cba 2  )  ;", "pf . addAdvisor ( advisor 1  )  ;", "pf . addAdvice ( nop )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "Advised   advised    =     (  ( Advised )     ( proxied )  )  ;", "proxied . setAge (  5  )  ;", "assertEquals (  1  ,    cba 1  . getCalls (  )  )  ;", "assertEquals (  0  ,    cba 2  . getCalls (  )  )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "assertFalse ( advised . replaceAdvisor ( new   DefaultPointcutAdvisor ( new   NopInterceptor (  )  )  ,    advisor 2  )  )  ;", "assertTrue ( advised . replaceAdvisor ( advisor 1  ,    advisor 2  )  )  ;", "assertEquals ( advisor 2  ,    pf . getAdvisors (  )  [  0  ]  )  ;", "assertEquals (  5  ,    proxied . getAge (  )  )  ;", "assertEquals (  1  ,    cba 1  . getCalls (  )  )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "assertEquals (  1  ,    cba 2  . getCalls (  )  )  ;", "assertFalse ( pf . replaceAdvisor ( new   DefaultPointcutAdvisor ( null )  ,    advisor 1  )  )  ;", "}", "METHOD_END"], "methodName": ["testReplaceAdvisor"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf 1     =    new   ProxyFactory ( new   ProxyFactoryTests . A (  )  )  ;", "pf 1  . setProxyTargetClass ( true )  ;", "ProxyFactory   pf 2     =    new   ProxyFactory ( new   ProxyFactoryTests . B (  )  )  ;", "pf 2  . setProxyTargetClass ( true )  ;", "Object   proxy 1     =    pf 1  . getProxy (  )  ;", "Object   proxy 2     =    pf 2  . getProxy (  )  ;", "List < Object >    list    =    new   ArrayList <  >  (  2  )  ;", "list . add ( proxy 1  )  ;", "list . add ( proxy 2  )  ;", "AnnotationAwareOrderComparator . sort ( list )  ;", "assertSame ( proxy 2  ,    list . get (  0  )  )  ;", "assertSame ( proxy 1  ,    list . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testTargetClassProxiesCanBeOrderedThroughAnnotations"], "fileName": "org.springframework.aop.framework.ProxyFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    targetInterfaces    =    ClassUtils . getAllInterfacesForClass ( beanClass ,    getProxyClassLoader (  )  )  ;", "boolean   hasReasonableProxyInterface    =    false ;", "for    ( Class <  ?  >    ifc    :    targetInterfaces )     {", "if    (  (  (  !  ( isConfigurationCallbackInterface ( ifc )  )  )     &  &     (  !  ( isInternalLanguageInterface ( ifc )  )  )  )     &  &     (  ( ifc . getMethods (  )  . length )     >     0  )  )     {", "hasReasonableProxyInterface    =    true ;", "break ;", "}", "}", "if    ( hasReasonableProxyInterface )     {", "for    ( Class <  ?  >    ifc    :    targetInterfaces )     {", "proxyFactory . addInterface ( ifc )  ;", "}", "} else    {", "proxyFactory . setProxyTargetClass ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluateProxyInterfaces"], "fileName": "org.springframework.aop.framework.ProxyProcessorSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . proxyClassLoader ;", "}", "METHOD_END"], "methodName": ["getProxyClassLoader"], "fileName": "org.springframework.aop.framework.ProxyProcessorSupport"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( InitializingBean . class )     =  =    ifc )     |  |     (  ( DisposableBean . class )     =  =    ifc )  )     |  |     (  ( Closeable . class )     =  =    ifc )  )     |  |     (  ( AutoCloseable . class )     =  =    ifc )  )     |  |     ( ObjectUtils . containsElement ( ifc . getInterfaces (  )  ,    Aware . class )  )  ;", "}", "METHOD_END"], "methodName": ["isConfigurationCallbackInterface"], "fileName": "org.springframework.aop.framework.ProxyProcessorSupport"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ifc . getName (  )  . equals (  \" groovy . lang . GroovyObject \"  )  )     |  |     ( ifc . getName (  )  . endsWith (  \"  . cglib . proxy . Factory \"  )  )  )     |  |     ( ifc . getName (  )  . endsWith (  \"  . bytebuddy . MockAccess \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isInternalLanguageInterface"], "fileName": "org.springframework.aop.framework.ProxyProcessorSupport"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.aop.framework.ProxyProcessorSupport"}, {"methodBody": ["METHOD_START", "{", "this . proxyClassLoader    =    classLoader ;", "this . classLoaderConfigured    =    classLoader    !  =    null ;", "}", "METHOD_END"], "methodName": ["setProxyClassLoader"], "fileName": "org.springframework.aop.framework.ProxyProcessorSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . userAttributes )     =  =    null )     {", "this . userAttributes    =    new   HashMap <  >  (  )  ;", "}", "return   this . userAttributes ;", "}", "METHOD_END"], "methodName": ["getUserAttributes"], "fileName": "org.springframework.aop.framework.ReflectiveMethodInvocation"}, {"methodBody": ["METHOD_START", "{", "return   AopUtils . invokeJoinpointUsingReflection ( this . target ,    this . method ,    this . arguments )  ;", "}", "METHOD_END"], "methodName": ["invokeJoinpoint"], "fileName": "org.springframework.aop.framework.ReflectiveMethodInvocation"}, {"methodBody": ["METHOD_START", "{", "this . advisorAdapterRegistry    =    advisorAdapterRegistry ;", "}", "METHOD_END"], "methodName": ["setAdvisorAdapterRegistry"], "fileName": "org.springframework.aop.framework.adapter.AdvisorAdapterRegistrationManager"}, {"methodBody": ["METHOD_START", "{", "return   GlobalAdvisorAdapterRegistry . instance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.aop.framework.adapter.GlobalAdvisorAdapterRegistry"}, {"methodBody": ["METHOD_START", "{", "GlobalAdvisorAdapterRegistry . instance    =    new   DefaultAdvisorAdapterRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.aop.framework.adapter.GlobalAdvisorAdapterRegistry"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    exceptionClass    =    exception . getClass (  )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Trying   to   find   handler   for   exception   of   type    [  \"     +     ( exceptionClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "Method   handler    =    this . exceptionHandlerMap . get ( exceptionClass )  ;", "while    (  ( handler    =  =    null )     &  &     ( exceptionClass    !  =     ( Throwable . class )  )  )     {", "exceptionClass    =    exceptionClass . getSuperclass (  )  ;", "handler    =    this . exceptionHandlerMap . get ( exceptionClass )  ;", "}", "if    (  ( handler    !  =    null )     &  &     (  . logger . isDebugEnabled (  )  )  )     {", ". logger . debug (  (  (  (  \" Found   handler   for   exception   of   type    [  \"     +     ( exceptionClass . getName (  )  )  )     +     \"  ]  :     \"  )     +    handler )  )  ;", "}", "return   handler ;", "}", "METHOD_END"], "methodName": ["getExceptionHandler"], "fileName": "org.springframework.aop.framework.adapter.ThrowsAdviceInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . exceptionHandlerMap . size (  )  ;", "}", "METHOD_END"], "methodName": ["getHandlerMethodCount"], "fileName": "org.springframework.aop.framework.adapter.ThrowsAdviceInterceptor"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    handlerArgs ;", "if    (  ( method . getParameterCount (  )  )     =  =     1  )     {", "handlerArgs    =    new   Object [  ]  {    ex    }  ;", "} else    {", "handlerArgs    =    new   Object [  ]  {    mi . getMethod (  )  ,    mi . getArguments (  )  ,    mi . getThis (  )  ,    ex    }  ;", "}", "try    {", "method . invoke ( this . t ,    handlerArgs )  ;", "}    catch    ( InvocationTargetException   targetEx )     {", "throw   targetEx . getTargetException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeHandlerMethod"], "fileName": "org.springframework.aop.framework.adapter.ThrowsAdviceInterceptor"}, {"methodBody": ["METHOD_START", "{", "ThrowsAdviceInterceptorTests . MyThrowsHandler   th    =    new   ThrowsAdviceInterceptorTests . MyThrowsHandler (  )  ;", "ThrowsAdviceInterceptor   ti    =    new   ThrowsAdviceInterceptor ( th )  ;", "FileNotFoundException   ex    =    new   FileNotFoundException (  )  ;", "MethodInvocation   mi    =    mock ( MethodInvocation . class )  ;", "given ( mi . getMethod (  )  )  . willReturn ( Object . class . getMethod (  \" hashCode \"  )  )  ;", "given ( mi . getThis (  )  )  . willReturn ( new   Object (  )  )  ;", "given ( mi . proceed (  )  )  . willThrow ( ex )  ;", "try    {", "ti . invoke ( mi )  ;", "fail (  )  ;", "}    catch    ( Exception   caught )     {", "assertEquals ( ex ,    caught )  ;", "}", "assertEquals (  1  ,    th . getCalls (  )  )  ;", "assertEquals (  1  ,    th . getCalls (  \" ioException \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectHandlerUsed"], "fileName": "org.springframework.aop.framework.adapter.ThrowsAdviceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ThrowsAdviceInterceptorTests . MyThrowsHandler   th    =    new   ThrowsAdviceInterceptorTests . MyThrowsHandler (  )  ;", "ThrowsAdviceInterceptor   ti    =    new   ThrowsAdviceInterceptor ( th )  ;", "ConnectException   ex    =    new   ConnectException (  \"  \"  )  ;", "MethodInvocation   mi    =    mock ( MethodInvocation . class )  ;", "given ( mi . proceed (  )  )  . willThrow ( ex )  ;", "try    {", "ti . invoke ( mi )  ;", "fail (  )  ;", "}    catch    ( Exception   caught )     {", "assertEquals ( ex ,    caught )  ;", "}", "assertEquals (  1  ,    th . getCalls (  )  )  ;", "assertEquals (  1  ,    th . getCalls (  \" remoteException \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectHandlerUsedForSubclass"], "fileName": "org.springframework.aop.framework.adapter.ThrowsAdviceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   Throwable   t    =    new   Throwable (  )  ;", "@ SuppressWarnings (  \" serial \"  )", ". MyThrowsHandler   th    =    new    . MyThrowsHandler (  )     {", "@ Override", "public   void   afterThrowing ( RemoteException   ex )    throws   Throwable    {", "super . afterThrowing ( ex )  ;", "throw   t ;", "}", "}  ;", "ThrowsAdviceInterceptor   ti    =    new   ThrowsAdviceInterceptor ( th )  ;", "ConnectException   ex    =    new   ConnectException (  \"  \"  )  ;", "MethodInvocation   mi    =    mock ( MethodInvocation . class )  ;", "given ( mi . proceed (  )  )  . willThrow ( ex )  ;", "try    {", "ti . invoke ( mi )  ;", "fail (  )  ;", "}    catch    ( Throwable   caught )     {", "assertEquals ( t ,    caught )  ;", "}", "assertEquals (  1  ,    th . getCalls (  )  )  ;", "assertEquals (  1  ,    th . getCalls (  \" remoteException \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHandlerMethodThrowsException"], "fileName": "org.springframework.aop.framework.adapter.ThrowsAdviceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ThrowsAdviceInterceptorTests . MyThrowsHandler   th    =    new   ThrowsAdviceInterceptorTests . MyThrowsHandler (  )  ;", "ThrowsAdviceInterceptor   ti    =    new   ThrowsAdviceInterceptor ( th )  ;", "assertEquals (  2  ,    ti . getHandlerMethodCount (  )  )  ;", "Exception   ex    =    new   Exception (  )  ;", "MethodInvocation   mi    =    mock ( MethodInvocation . class )  ;", "given ( mi . proceed (  )  )  . willThrow ( ex )  ;", "try    {", "ti . invoke ( mi )  ;", "fail (  )  ;", "}    catch    ( Exception   caught )     {", "assertEquals ( ex ,    caught )  ;", "}", "assertEquals (  0  ,    th . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoHandlerMethodForThrowable"], "fileName": "org.springframework.aop.framework.adapter.ThrowsAdviceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   ThrowsAdviceInterceptor ( new   Object (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoHandlerMethods"], "fileName": "org.springframework.aop.framework.adapter.ThrowsAdviceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ThrowsAdviceInterceptorTests . MyThrowsHandler   th    =    new   ThrowsAdviceInterceptorTests . MyThrowsHandler (  )  ;", "ThrowsAdviceInterceptor   ti    =    new   ThrowsAdviceInterceptor ( th )  ;", "Object   ret    =    new   Object (  )  ;", "MethodInvocation   mi    =    mock ( MethodInvocation . class )  ;", "given ( mi . proceed (  )  )  . willReturn ( ret )  ;", "assertEquals ( ret ,    ti . invoke ( mi )  )  ;", "assertEquals (  0  ,    th . getCalls (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNotInvoked"], "fileName": "org.springframework.aop.framework.adapter.ThrowsAdviceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ProxyCreationContext . setCurrentProxiedBeanName ( beanName )  ;", "try    {", "return   AopUtils . findAdvisorsThatCanApply ( candidateAdvisors ,    beanClass )  ;", "}    finally    {", "ProxyCreationContext . setCurrentProxiedBeanName ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["findAdvisorsThatCanApply"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . advisorRetrievalHelper )     !  =    null )  ,     \" No   BeanFactoryAdvisorRetrievalHelper   available \"  )  ;", "return   this . advisorRetrievalHelper . findAdvisorBeans (  )  ;", "}", "METHOD_END"], "methodName": ["findCandidateAdvisors"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "List < Advisor >    candidateAdvisors    =    findCandidateAdvisors (  )  ;", "List < Advisor >    eligibleAdvisors    =    findAdvisorsThatCanApply ( candidateAdvisors ,    beanClass ,    beanName )  ;", "extendAdvisors ( eligibleAdvisors )  ;", "if    (  !  ( eligibleAdvisors . isEmpty (  )  )  )     {", "eligibleAdvisors    =    sors ( eligibleAdvisors )  ;", "}", "return   eligibleAdvisors ;", "}", "METHOD_END"], "methodName": ["findEligibleAdvisors"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "this . advisorRetrievalHelper    =    new   AbstractAdvisorAutoProxyCreator . BeanFactoryAdvisorRetrievalHelperAdapter ( beanFactory )  ;", "}", "METHOD_END"], "methodName": ["initBeanFactory"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isEligibleAdvisorBean"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "AnnotationAwareOrderComparator . sort ( advisors )  ;", "return   advisors ;", "}", "METHOD_END"], "methodName": ["sortAdvisors"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["advisorsPreFiltered"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "Advisor [  ]    commonInterceptors    =    resolveInterceptorNames (  )  ;", "List < Object >    allInterceptors    =    new   ArrayList <  >  (  )  ;", "if    ( specificInterceptors    !  =    null )     {", "allInterceptors . addAll ( Arrays . asList ( specificInterceptors )  )  ;", "if    (  ( commonInterceptors . length )     >     0  )     {", "if    ( this . applyCommonInterceptorsFirst )     {", "allInterceptors . addAll (  0  ,    Arrays . asList ( commonInterceptors )  )  ;", "} else    {", "allInterceptors . addAll ( Arrays . asList ( commonInterceptors )  )  ;", "}", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "int   nrOfCommonInterceptors    =    commonInterceptors . length ;", "int   nrOfSpecificInterceptors    =     ( specificInterceptors    !  =    null )     ?    specificInterceptors . length    :     0  ;", "logger . debug (  (  (  (  (  (  (  \" Creating   implicit      for   bean    '  \"     +    beanName )     +     \"  '    with    \"  )     +    nrOfCommonInterceptors )     +     \"    common   interceptors   and    \"  )     +    nrOfSpecificInterceptors )     +     \"    specific   interceptors \"  )  )  ;", "}", "Advisor [  ]    advisors    =    new   Advisor [ allInterceptors . size (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( allInterceptors . size (  )  )  ;    i +  +  )     {", "advisors [ i ]     =    this . advisorAdapterRegistry . wrap ( allInterceptors . get ( i )  )  ;", "}", "return   advisors ;", "}", "METHOD_END"], "methodName": ["buildAdvisors"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )    instanceof   ConfigurableListableBeanFactory )     {", "Utils . exposeTargetClass (  (  ( ConfigurableListableBeanFactory )     ( this . beanFactory )  )  ,    beanName ,    beanClass )  ;", "}", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . copyFrom ( this )  ;", "if    (  !  ( proxyFactory . isProxyTargetClass (  )  )  )     {", "if    ( shouldProxyTargetClass ( beanClass ,    beanName )  )     {", "proxyFactory . setProxyTargetClass ( true )  ;", "} else    {", "evaluateProxyInterfaces ( beanClass ,    proxyFactory )  ;", "}", "}", "Advisor [  ]    advisors    =    buildAdvisors ( beanName ,    specificInterceptors )  ;", "proxyFactory . addAdvisors ( advisors )  ;", "proxyFactory . setTargetSource ( targetSource )  ;", "customizeProxyFactory ( proxyFactory )  ;", "proxyFactory . setFrozen ( this . freezeProxy )  ;", "if    ( advisorsPreFiltered (  )  )     {", "proxyFactory . setPreFiltered ( true )  ;", "}", "return   proxyFactory . getProxy ( getProxyClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["createProxy"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasLength ( beanName )  )     {", "return   FactoryBean . class . isAssignableFrom ( beanClass )     ?     ( BeanFactory . FACTORY _ BEAN _ PREFIX )     +    beanName    :    beanName ;", "} else    {", "return   beanClass ;", "}", "}", "METHOD_END"], "methodName": ["getCacheKey"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( this . customTargetSourceCreators )     !  =    null )     &  &     (  ( this . beanFactory )     !  =    null )  )     &  &     ( this . beanFactory . containsBean ( beanName )  )  )     {", "for    ( TargetSourceCreator   tsc    :    this . customTargetSourceCreators )     {", "TargetSource   ts    =    tsc . getTargetSource ( beanClass ,    beanName )  ;", "if    ( ts    !  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" TargetSourceCreator    [  \"     +    tsc )     +     \"    found   custom   TargetSource   for   bean   with   name    '  \"  )     +    beanName )     +     \"  '  \"  )  )  ;", "}", "return   ts ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCustomTargetSource"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "boolean   retVal    =     (  (  ( Advice . class . isAssignableFrom ( beanClass )  )     |  |     ( Pointcut . class . isAssignableFrom ( beanClass )  )  )     |  |     ( Advisor . class . isAssignableFrom ( beanClass )  )  )     |  |     ( AopInfrastructureBean . class . isAssignableFrom ( beanClass )  )  ;", "if    ( retVal    &  &     ( logger . isTraceEnabled (  )  )  )     {", "logger . trace (  (  (  \" Did   not   attempt   to   auto -    infrastructure   class    [  \"     +     ( beanClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return   retVal ;", "}", "METHOD_END"], "methodName": ["isInfrastructureClass"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   bf    =    this . beanFactory ;", "ConfigurableBeanFactory   cbf    =     ( bf   instanceof   ConfigurableBeanFactory )     ?     (  ( ConfigurableBeanFactory )     ( bf )  )     :    null ;", "List < Advisor >    advisors    =    new   ArrayList <  >  (  )  ;", "for    ( String   beanName    :    this . interceptorNames )     {", "if    (  ( cbf    =  =    null )     |  |     (  !  ( cbf . isCurrentlyInion ( beanName )  )  )  )     {", "Assert . state (  ( bf    !  =    null )  ,     \" BeanFactory   required   for   resolving   interceptor   names \"  )  ;", "Object   next    =    bf . getBean ( beanName )  ;", "advisors . add ( this . advisorAdapterRegistry . wrap ( next )  )  ;", "}", "}", "return   advisors . toArray ( new   Advisor [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["resolveInterceptorNames"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "this . advisorAdapterRegistry    =    advisorAdapterRegistry ;", "}", "METHOD_END"], "methodName": ["setAdvisorAdapterRegistry"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "this . applyCommonInterceptorsFirst    =    applyCommonInterceptorsFirst ;", "}", "METHOD_END"], "methodName": ["setApplyCommonInterceptorsFirst"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "this . customTargetSourceCreators    =    targetSourceCreators ;", "}", "METHOD_END"], "methodName": ["setCustomTargetSourceCreators"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "this . interceptorNames    =    interceptorNames ;", "}", "METHOD_END"], "methodName": ["setInterceptorNames"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . beanFactory )    instanceof   ConfigurableListableBeanFactory )     &  &     ( AutoProxyUtils . shouldProxyTargetClass (  (  ( ConfigurableListableBeanFactory )     ( this . beanFactory )  )  ,    beanName )  )  ;", "}", "METHOD_END"], "methodName": ["shouldProxyTargetClass"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldSkip"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( StringUtils . hasLength ( beanName )  )     &  &     ( this . targetSourcedBeans . contains ( beanName )  )  )     {", "return   bean ;", "}", "if    ( Boolean . FALSE . equals ( this . advisedBeans . get ( cacheKey )  )  )     {", "return   bean ;", "}", "if    (  ( isInfrastructureClass ( bean . getClass (  )  )  )     |  |     ( shouldSkip ( bean . getClass (  )  ,    beanName )  )  )     {", "this . advisedBeans . put ( cacheKey ,    Boolean . FALSE )  ;", "return   bean ;", "}", "Object [  ]    specificInterceptors    =    getAdvicesAndAdvisorsForBean ( bean . getClass (  )  ,    beanName ,    null )  ;", "if    ( specificInterceptors    !  =     (  . DO _ NOT _ PROXY )  )     {", "this . advisedBeans . put ( cacheKey ,    Boolean . TRUE )  ;", "Object   proxy    =    createProxy ( bean . getClass (  )  ,    beanName ,    specificInterceptors ,    new   SingletonTargetSource ( bean )  )  ;", "this . proxyTypes . put ( cacheKey ,    proxy . getClass (  )  )  ;", "return   proxy ;", "}", "this . advisedBeans . put ( cacheKey ,    Boolean . FALSE )  ;", "return   bean ;", "}", "METHOD_END"], "methodName": ["wrapIfNecessary"], "fileName": "org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "if    ( beanName    =  =    null )     {", "return   null ;", "}", "if    ( beanFactory . containsBeanDefinition ( beanName )  )     {", "BeanDefinition   bd    =    beanFactory . getMergedBeanDefinition ( beanName )  ;", "Class <  ?  >    targetClass    =     (  ( Class <  ?  >  )     ( bd . getAttribute (  . ORIGINAL _ TARGET _ CLASS _ ATTRIBUTE )  )  )  ;", "if    ( targetClass    !  =    null )     {", "return   targetClass ;", "}", "}", "return   beanFactory . getType ( beanName )  ;", "}", "METHOD_END"], "methodName": ["determineTargetClass"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( beanName    !  =    null )     &  &     ( beanFactory . containsBeanDefinition ( beanName )  )  )     {", "beanFactory . getMergedBeanDefinition ( beanName )  . setAttribute (  . ORIGINAL _ TARGET _ CLASS _ ATTRIBUTE ,    targetClass )  ;", "}", "}", "METHOD_END"], "methodName": ["exposeTargetClass"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( beanName    !  =    null )     &  &     ( beanFactory . containsBeanDefinition ( beanName )  )  )     {", "BeanDefinition   bd    =    beanFactory . getBeanDefinition ( beanName )  ;", "return   Boolean . TRUE . equals ( bd . getAttribute (  . PRESERVE _ TARGET _ CLASS _ ATTRIBUTE )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldProxyTargetClass"], "fileName": "org.springframework.aop.framework.autoproxy.AutoProxyUtils"}, {"methodBody": ["METHOD_START", "{", "String [  ]    advisorNames    =    null ;", "synchronized ( this )     {", "advisorNames    =    this . cachedAdvisorBeanNames ;", "if    ( advisorNames    =  =    null )     {", "advisorNames    =    BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( this . beanFactory ,    Advisor . class ,    true ,    false )  ;", "this . cachedAdvisorBeanNames    =    advisorNames ;", "}", "}", "if    (  ( advisorNames . length )     =  =     0  )     {", "return   new   LinkedList <  >  (  )  ;", "}", "List < Advisor >    advisors    =    new   LinkedList <  >  (  )  ;", "for    ( String   name    :    advisorNames )     {", "if    ( isEligibleBean ( name )  )     {", "if    ( this . beanFactory . isCurrentlyInCreation ( name )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Skipping   currently   created   advisor    '  \"     +    name )     +     \"  '  \"  )  )  ;", "}", "} else    {", "try    {", "advisors . add ( this . beanFactory . getBean ( name ,    Advisor . class )  )  ;", "}    catch    ( BeanCreationException   ex )     {", "Throwable   rootCause    =    ex . getMostSpecificCause (  )  ;", "if    ( rootCause   instanceof   BeanCurrentlyInCreationException )     {", "BeanCreationException   bce    =     (  ( BeanCreationException )     ( rootCause )  )  ;", "String   bceBeanName    =    bce . getBeanName (  )  ;", "if    (  ( bceBeanName    !  =    null )     &  &     ( this . beanFactory . isCurrentlyInCreation ( bceBeanName )  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Skipping   advisor    '  \"     +    name )     +     \"  '    with   dependency   on   currently   created   bean :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "continue ;", "}", "}", "throw   ex ;", "}", "}", "}", "}", "return   advisors ;", "}", "METHOD_END"], "methodName": ["findAdvisorBeans"], "fileName": "org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isEligibleBean"], "fileName": "org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper"}, {"methodBody": ["METHOD_START", "{", "return   PatternMatchUtils . simpleMatch ( mappedName ,    beanName )  ;", "}", "METHOD_END"], "methodName": ["isMatch"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( beanNames ,     \"  ' beanNames '    must   not   be   empty \"  )  ;", "this . beanNames    =    new   ArrayList <  >  ( beanNames . length )  ;", "for    ( String   mappedName    :    beanNames )     {", "this . beanNames . add ( StringUtils . trimWhitespace ( mappedName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setBeanNames"], "fileName": "org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return   this . advisorBeanNamePrefix ;", "}", "METHOD_END"], "methodName": ["getAdvisorBeanNamePrefix"], "fileName": "org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return   this . usePrefix ;", "}", "METHOD_END"], "methodName": ["isUsePrefix"], "fileName": "org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "this . advisorBeanNamePrefix    =    advisorBeanNamePrefix ;", "}", "METHOD_END"], "methodName": ["setAdvisorBeanNamePrefix"], "fileName": "org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "this . usePrefix    =    usePrefix ;", "}", "METHOD_END"], "methodName": ["setUsePrefix"], "fileName": "org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"}, {"methodBody": ["METHOD_START", "{", "return   ProxyCreationContext . currentProxiedBeanName . get (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentProxiedBeanName"], "fileName": "org.springframework.aop.framework.autoproxy.ProxyCreationContext"}, {"methodBody": ["METHOD_START", "{", "if    ( beanName    !  =    null )     {", ". currentProxiedBeanName . set ( beanName )  ;", "} else    {", ". currentProxiedBeanName . remove (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setCurrentProxiedBeanName"], "fileName": "org.springframework.aop.framework.autoproxy.ProxyCreationContext"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   internalBeanFactory    =    new   DefaultListableBeanFactory ( containingFactory )  ;", "internalBeanFactory . copyConfigurationFrom ( containingFactory )  ;", "internalBeanFactory . getBeanPostProcessors (  )  . removeIf (  (    beanPostProcessor )     -  >    beanPostProcessor   instanceof   AopInfrastructureBean )  ;", "return   internalBeanFactory ;", "}", "METHOD_END"], "methodName": ["buildInternalBeanFactory"], "fileName": "org.springframework.aop.framework.autoproxy.target.AbstractBeanFactoryBasedTargetSourceCreator"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.aop.framework.autoproxy.target.AbstractBeanFactoryBasedTargetSourceCreator"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . internalBeanFactories )     {", "DefaultListable   internal    =    this . internalBeanFactories . get ( beanName )  ;", "if    ( internal    =  =    null )     {", "internal    =    buildInternal ( this . beanFactory )  ;", "this . internalBeanFactories . put ( beanName ,    internal )  ;", "}", "return   internal ;", "}", "}", "METHOD_END"], "methodName": ["getInternalBeanFactoryForBean"], "fileName": "org.springframework.aop.framework.autoproxy.target.AbstractBeanFactoryBasedTargetSourceCreator"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isPrototypeBased"], "fileName": "org.springframework.aop.framework.autoproxy.target.AbstractBeanFactoryBasedTargetSourceCreator"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( getPrefix (  )  )  ;", "Method   method    =    invocation . getMethod (  )  ;", "Class <  ?  >    clazz    =    method . getDeclaringClass (  )  ;", "if    (  ( this . logTargetClassInvocation )     &  &     ( clazz . isInstance ( invocation . getThis (  )  )  )  )     {", "clazz    =    invocation . getThis (  )  . getClass (  )  ;", "}", "sb . append ( clazz . getName (  )  )  ;", "sb . append (  '  .  '  )  . append ( method . getName (  )  )  ;", "sb . append ( getSuffix (  )  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createInvocationTraceName"], "fileName": "org.springframework.aop.interceptor.AbstractMonitoringInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . prefix ;", "}", "METHOD_END"], "methodName": ["getPrefix"], "fileName": "org.springframework.aop.interceptor.AbstractMonitoringInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . suffix ;", "}", "METHOD_END"], "methodName": ["getSuffix"], "fileName": "org.springframework.aop.interceptor.AbstractMonitoringInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . logTargetClassInvocation    =    logTargetClassInvocation ;", "}", "METHOD_END"], "methodName": ["setLogTargetClassInvocation"], "fileName": "org.springframework.aop.interceptor.AbstractMonitoringInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . prefix    =     ( prefix    !  =    null )     ?    prefix    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setPrefix"], "fileName": "org.springframework.aop.interceptor.AbstractMonitoringInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . suffix    =     ( suffix    !  =    null )     ?    suffix    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setSuffix"], "fileName": "org.springframework.aop.interceptor.AbstractMonitoringInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . hideProxyClassNames    ?    AopUtils . getTargetClass ( target )     :    target . getClass (  )  ;", "}", "METHOD_END"], "methodName": ["getClassForLogging"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . defaultLogger )     !  =    null )     {", "return   this . defaultLogger ;", "} else    {", "Object   target    =    invocation . getThis (  )  ;", "return   LogFactory . getLog ( getClassForLogg ( target )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getLoggerForInvocation"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   isLogEnabled ( logger )  ;", "}", "METHOD_END"], "methodName": ["isInterceptorEnabled"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   logger . isTraceEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isLogEnabled"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . hideProxyClassNames    =    hideProxyClassNames ;", "}", "METHOD_END"], "methodName": ["setHideProxyClassNames"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . logExceptionStackTrace    =    logExceptionStackTrace ;", "}", "METHOD_END"], "methodName": ["setLogExceptionStackTrace"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . defaultLogger    =    LogFactory . getLog ( loggerName )  ;", "}", "METHOD_END"], "methodName": ["setLoggerName"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . defaultLogger    =     ( useDynamicLogger )     ?    null    :    LogFactory . getLog ( getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUseDynamicLogger"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "writeToLog ( logger ,    message ,    null )  ;", "}", "METHOD_END"], "methodName": ["writeToLog"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ex    !  =    null )     &  &     ( this . logExceptionStackTrace )  )     {", "logger . trace ( message ,    ex )  ;", "} else    {", "logger . trace ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["writeToLog"], "fileName": "org.springframework.aop.interceptor.AbstractTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "AsyncTaskExecutor   executor    =    this . executors . get ( method )  ;", "if    ( executor    =  =    null )     {", "Executor   targetExecutor ;", "String   qualifier    =    getExecutorQualifier ( method )  ;", "if    ( StringUtils . hasLength ( qualifier )  )     {", "targetExecutor    =    findQualifiedExecutor ( this . beanFactory ,    qualifier )  ;", "} else    {", "targetExecutor    =    this . defaultExecutor ;", "if    ( targetExecutor    =  =    null )     {", "synchronized ( this . executors )     {", "if    (  ( this . defaultExecutor )     =  =    null )     {", "this . defaultExecutor    =    getDefaultExecutor ( this . beanFactory )  ;", "}", "targetExecutor    =    this . defaultExecutor ;", "}", "}", "}", "if    ( targetExecutor    =  =    null )     {", "return   null ;", "}", "executor    =     ( targetExecutor   instanceof   AsyncListenableTaskExecutor )     ?     (  ( AsyncListenableTaskExecutor )     ( targetExecutor )  )     :    new   TaskExecutorAdapter ( targetExecutor )  ;", "this . executors . put ( method ,    executor )  ;", "}", "return   executor ;", "}", "METHOD_END"], "methodName": ["determineAsyncExecutor"], "fileName": "org.springframework.aop.interceptor.AsyncExecutionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( CompletableFuture . class . isAssignableFrom ( returnType )  )     {", "return   CompletableFuture . supplyAsync (  (  )     -  >     {", "try    {", "return   task . call (  )  ;", "}    catch    (    ex )     {", "throw   new    < ex > CompletionException (  )  ;", "}", "}  ,    executor )  ;", "} else", "if    ( util . concurrent . ListenableFuture . class . isAssignableFrom ( returnType )  )     {", "return    (  ( core . task . AsyncListenableTaskExecutor )     ( executor )  )  . submitListenable ( task )  ;", "} else", "if    ( isAssignableFrom ( returnType )  )     {", "return   executor . submit ( task )  ;", "} else    {", "executor . submit ( task )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["doSubmit"], "fileName": "org.springframework.aop.interceptor.AsyncExecutionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( beanFactory    =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  (  \" BeanFactory   must   be   set   on    \"     +     ( getClass (  )  . getSimpleName (  )  )  )     +     \"    to   access   qualified   executor    '  \"  )     +    qualifier )     +     \"  '  \"  )  )  ;", "}", "return   BeanFactoryAnnotationUtils . qualifiedBeanOfType ( beanFactory ,    or . class ,    qualifier )  ;", "}", "METHOD_END"], "methodName": ["findQualifiedExecutor"], "fileName": "org.springframework.aop.interceptor.AsyncExecutionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( beanFactory    !  =    null )     {", "try    {", "return   beanFactory . getBean ( TaskExecutor . class )  ;", "}    catch    ( NoUniqueBeanDefinitionException   ex )     {", "logger . debug (  \" Could   not   find   unique   TaskExecutor   bean \"  ,    ex )  ;", "try    {", "return   beanFactory . getBean (  . DEFAULT _ TASK _ EXECUTOR _ BEAN _ NAME ,    Executor . class )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex 2  )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" More   than   one   TaskExecutor   bean   found   within   the   context ,    and   none   is   named    \"     +     (  \"  ' taskExecutor '  .    Mark   one   of   them   as   primary   or   name   it    ' taskExecutor '     ( possibly    \"     +     \" as   an   alias )    in   order   to   use   it   for   async   processing :     \"  )  )     +     ( ex . getBeanNamesFound (  )  )  )  )  ;", "}", "}", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "logger . debug (  \" Could   not   find   default   TaskExecutor   bean \"  ,    ex )  ;", "try    {", "return   beanFactory . getBean (  . DEFAULT _ TASK _ EXECUTOR _ BEAN _ NAME ,    Executor . class )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex 2  )     {", "logger . info (  (  \" No   task   executor   bean   found   for   async   processing :     \"     +     \" no   bean   of   type   TaskExecutor   and   no   bean   named    ' taskExecutor '    either \"  )  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultExecutor"], "fileName": "org.springframework.aop.interceptor.AsyncExecutionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( Future . class . isAssignableFrom ( method . getReturnType (  )  )  )     {", "ReflecUtils . rethrowExcep ( ex )  ;", "} else    {", "try    {", "this . excepHandler . handleUncaughtExcep ( ex ,    method ,    params )  ;", "}    catch    ( Throwable   ex 2  )     {", "logger . error (  (  (  \" Excep   handler   for   async   method    '  \"     +     ( method . toGenericString (  )  )  )     +     \"  '    threw   unexpected   excep   itself \"  )  ,    ex 2  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleError"], "fileName": "org.springframework.aop.interceptor.AsyncExecutionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . exceptionHandler    =    exceptionHandler ;", "}", "METHOD_END"], "methodName": ["setExceptionHandler"], "fileName": "org.springframework.aop.interceptor.AsyncExecutionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . defaultExecutor    =    defaultExecutor ;", "}", "METHOD_END"], "methodName": ["setExecutor"], "fileName": "org.springframework.aop.interceptor.AsyncExecutionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setInterfaces ( ITestBean . class )  ;", "ConcurrencyThrottleInterceptor   cti    =    new   ConcurrencyThrottleInterceptor (  )  ;", "cti . setConcurrencyLimit ( concurrencyLimit )  ;", "proxyFactory . addAdvice ( cti )  ;", "proxyFactory . setTarget ( tb )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( proxyFactory . getProxy (  )  )  )  ;", "Thread [  ]    threads    =    new   Thread [  . NR _ OF _ THREADS ]  ;", "for    ( int   i    =     0  ;    i    <     (  . NR _ OF _ THREADS )  ;    i +  +  )     {", "threads [ i ]     =    new    . ConcurrencyThread ( proxy ,    null )  ;", "threads [ i ]  . start (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     (  (  . NR _ OF _ THREADS )     /     1  0  )  ;    i +  +  )     {", "try    {", "Thread . sleep (  5  )  ;", "}    catch    ( InterruptedException   ex )     {", "ex . printStackTrace (  )  ;", "}", "threads [ i ]     =    new    . ConcurrencyThread ( proxy ,     (  ( i    %     2  )     =  =     0     ?    new   OutOfMemoryError (  )     :    new   IllegalStateException (  )  )  )  ;", "threads [ i ]  . start (  )  ;", "}", "for    ( int   i    =     0  ;    i    <     (  . NR _ OF _ THREADS )  ;    i +  +  )     {", "try    {", "threads [ i ]  . join (  )  ;", "}    catch    ( InterruptedException   ex )     {", "ex . printStackTrace (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testMultipleThreads"], "fileName": "org.springframework.aop.interceptor.ConcurrencyThrottleInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "testMultipleThreads (  1  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleThreadsWithLimit1"], "fileName": "org.springframework.aop.interceptor.ConcurrencyThrottleInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "testMultipleThreads (  1  0  )  ;", "}", "METHOD_END"], "methodName": ["testMultipleThreadsWithLimit10"], "fileName": "org.springframework.aop.interceptor.ConcurrencyThrottleInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "DerivedTestBean   tb    =    new   DerivedTestBean (  )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setInterfaces ( ITestBean . class )  ;", "cti    =    new    (  )  ;", "proxyFactory . addAdvice ( cti )  ;", "proxyFactory . setTarget ( tb )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( proxyFactory . getProxy (  )  )  )  ;", "proxy . getAge (  )  ;", "ITestBean   serializedProxy    =     (  ( ITestBean )     ( SerializationTestUtils . serializeAndDeserialize ( proxy )  )  )  ;", "Advised   advised    =     (  ( Advised )     ( serializedProxy )  )  ;", "serializedCti    =     (  (  )     ( advised . getAdvisors (  )  [  0  ]  . getAdvice (  )  )  )  ;", "assertEquals ( cti . getConcurrencyLimit (  )  ,    serializedCti . getConcurrencyLimit (  )  )  ;", "serializedProxy . getAge (  )  ;", "}", "METHOD_END"], "methodName": ["testSerializable"], "fileName": "org.springframework.aop.interceptor.ConcurrencyThrottleInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    argumentTypes    =    methodInvocation . getMethod (  )  . getParameterTypes (  )  ;", "String [  ]    argumentTypeShortNames    =    new   String [ argumentTypes . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( argumentTypeShortNames . length )  ;    i +  +  )     {", "argumentTypeShortNames [ i ]     =    ClassUtils . getShortName ( argumentTypes [ i ]  )  ;", "}", "matcher . appendReplacement ( output ,    Matcher . quoteReplacement ( StringUtils . arrayToCommaDelimitedString ( argumentTypeShortNames )  )  )  ;", "}", "METHOD_END"], "methodName": ["appendArgumentTypes"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( methodInvocation . getMethod (  )  . getReturnType (  )  )     =  =     ( void . class )  )     {", "matcher . appendReplacement ( output ,     \" void \"  )  ;", "} else", "if    ( returnValue    =  =    null )     {", "matcher . appendReplacement ( output ,     \" null \"  )  ;", "} else    {", "matcher . appendReplacement ( output ,    Matcher . quoteReplacement ( returnValue . toSt (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["appendReturnValue"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "Matcher   matcher    =    CustomizableTraceInterceptor . PATTERN . matcher ( message )  ;", "while    ( matcher . find (  )  )     {", "String   match    =    matcher . group (  )  ;", "if    (  !  ( CustomizableTraceInterceptor . ALLOWED _ PLACEHOLDERS . contains ( match )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Placeholder    [  \"     +    match )     +     \"  ]    is   not   valid \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkForInvalidPlaceholders"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "Matcher   matcher    =    CustomizableTraceInterceptor . PATTERN . matcher ( message )  ;", "StringBuffer   output    =    new   StringBuffer (  )  ;", "while    ( matcher . find (  )  )     {", "String   match    =    matcher . group (  )  ;", "if    ( CustomizableTraceInterceptor . PLACEHOLDER _ METHOD _ NAME . equals ( match )  )     {", "matcher . appendReplacement ( output ,    Matcher . quoteReplacement ( methodInvocation . getMethod (  )  . getName (  )  )  )  ;", "} else", "if    ( CustomizableTraceInterceptor . PLACEHOLDER _ TARGET _ CLASS _ NAME . equals ( match )  )     {", "String   className    =    getClassForLogging ( methodInvocation . getThis (  )  )  . getName (  )  ;", "matcher . appendReplacement ( output ,    Matcher . quoteReplacement ( className )  )  ;", "} else", "if    ( CustomizableTraceInterceptor . PLACEHOLDER _ TARGET _ CLASS _ SHORT _ NAME . equals ( match )  )     {", "String   shortName    =    getShortName ( getClassForLogging ( methodInvocation . getThis (  )  )  )  ;", "matcher . appendReplacement ( output ,    Matcher . quoteReplacement ( shortName )  )  ;", "} else", "if    ( CustomizableTraceInterceptor . PLACEHOLDER _ ARGUMENTS . equals ( match )  )     {", "matcher . appendReplacement ( output ,    Matcher . quoteReplacement ( arrayToCommaDelimitedString ( methodInvocation . getArguments (  )  )  )  )  ;", "} else", "if    ( CustomizableTraceInterceptor . PLACEHOLDER _ ARGUMENT _ TYPES . equals ( match )  )     {", "appendArgumentTypes ( methodInvocation ,    matcher ,    output )  ;", "} else", "if    ( CustomizableTraceInterceptor . PLACEHOLDER _ RETURN _ VALUE . equals ( match )  )     {", "appendReturnValue ( methodInvocation ,    matcher ,    output ,    returnValue )  ;", "} else", "if    (  ( throwable    !  =    null )     &  &     ( CustomizableTraceInterceptor . PLACEHOLDER _ EXCEPTION . equals ( match )  )  )     {", "matcher . appendReplacement ( output ,    Matcher . quoteReplacement ( throwable . toString (  )  )  )  ;", "} else", "if    ( CustomizableTraceInterceptor . PLACEHOLDER _ INVOCATION _ TIME . equals ( match )  )     {", "matcher . appendReplacement ( output ,    Long . toString ( invocationTime )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Unknown   placeholder    [  \"     +    match )     +     \"  ]  \"  )  )  ;", "}", "}", "matcher . appendTail ( output )  ;", "return   output . toString (  )  ;", "}", "METHOD_END"], "methodName": ["replacePlaceholders"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( enterMessage ,     \" enterMessage   must   not   be   empty \"  )  ;", "checkForInvalidPlaceholders ( enterMessage )  ;", "Assert . doesNotContain ( enterMessage ,     . PLACEHOLDER _ RETURN _ VALUE ,     (  \" enterMessage   cannot   contain   placeholder    \"     +     (  . PLACEHOLDER _ RETURN _ VALUE )  )  )  ;", "Assert . doesNotContain ( enterMessage ,     . PLACEHOLDER _ EXCEPTION ,     (  \" enterMessage   cannot   contain   placeholder    \"     +     (  . PLACEHOLDER _ EXCEPTION )  )  )  ;", "Assert . doesNotContain ( enterMessage ,     . PLACEHOLDER _ INVOCATION _ TIME ,     (  \" enterMessage   cannot   contain   placeholder    \"     +     (  . PLACEHOLDER _ INVOCATION _ TIME )  )  )  ;", "this . enterMessage    =    enterMessage ;", "}", "METHOD_END"], "methodName": ["setEnterMessage"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( exceptionMessage ,     \" exceptionMessage   must   not   be   empty \"  )  ;", "checkForInvalidPlaceholders ( exceptionMessage )  ;", "Assert . doesNotContain ( exceptionMessage ,     . PLACEHOLDER _ RETURN _ VALUE ,     (  \" exceptionMessage   cannot   contain   placeholder    \"     +     (  . PLACEHOLDER _ RETURN _ VALUE )  )  )  ;", "this . exceptionMessage    =    exceptionMessage ;", "}", "METHOD_END"], "methodName": ["setExceptionMessage"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( exitMessage ,     \" exitMessage   must   not   be   empty \"  )  ;", "checkForInvalidPlaceholders ( exitMessage )  ;", "Assert . doesNotContain ( exitMessage ,     . PLACEHOLDER _ EXCEPTION ,     (  \" exitMessage   cannot   contain   placeholder \"     +     (  . PLACEHOLDER _ EXCEPTION )  )  )  ;", "this . exitMessage    =    exitMessage ;", "}", "METHOD_END"], "methodName": ["setExitMessage"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   methodInvocation    =    mock ( MethodInvocation . class )  ;", "IllegalArgumentException   exception    =    new   IllegalArgumentException (  )  ;", "given ( methodInvocation . getMethod (  )  )  . willReturn ( String . class . getMethod (  \" toString \"  )  )  ;", "given ( methodInvocation . getThis (  )  )  . willReturn ( this )  ;", "given ( methodInvocation . proceed (  )  )  . willThrow ( exception )  ;", "Log   log    =    mock ( Log . class )  ;", "given ( log . isTraceEnabled (  )  )  . willReturn ( true )  ;", "CustomizableTraceInterceptor   interceptor    =    new    . StubCustomizableTraceInterceptor ( log )  ;", "try    {", "interceptor . invoke ( methodInvocation )  ;", "fail (  \" Must   have   propagated   the   IllegalArgumentException .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "verify ( log )  . trace ( anyString (  )  )  ;", "verify ( log )  . trace ( anyString (  )  ,    eq ( exception )  )  ;", "}", "METHOD_END"], "methodName": ["testExceptionPathLogsCorrectly"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   CustomizableTraceInterceptor (  )  . setEnterMessage (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetEmptyEnterMessage"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   CustomizableTraceInterceptor (  )  . setExceptionMessage (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetEmptyExceptionMessage"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   CustomizableTraceInterceptor (  )  . setExitMessage (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetEmptyExitMessage"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   CustomizableTraceInterceptor (  )  . setEnterMessage ( CustomizableTraceInterceptor . PLACEHOLDER _ EXCEPTION )  ;", "}", "METHOD_END"], "methodName": ["testSetEnterMessageWithExceptionPlaceholder"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   CustomizableTraceInterceptor (  )  . setEnterMessage ( CustomizableTraceInterceptor . PLACEHOLDER _ INVOCATION _ TIME )  ;", "}", "METHOD_END"], "methodName": ["testSetEnterMessageWithInvocationTimePlaceholder"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   CustomizableTraceInterceptor (  )  . setEnterMessage ( CustomizableTraceInterceptor . PLACEHOLDER _ RETURN _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testSetEnterMessageWithReturnValuePlaceholder"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   CustomizableTraceInterceptor (  )  . setExceptionMessage ( CustomizableTraceInterceptor . PLACEHOLDER _ RETURN _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testSetExceptionMethodWithReturnValuePlaceholder"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   CustomizableTraceInterceptor (  )  . setExitMessage ( CustomizableTraceInterceptor . PLACEHOLDER _ EXCEPTION )  ;", "}", "METHOD_END"], "methodName": ["testSetExitMessageWithExceptionPlaceholder"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   methodInvocation    =    mock ( MethodInvocation . class )  ;", "given ( methodInvocation . getMethod (  )  )  . willReturn ( String . class . getMethod (  \" toString \"  )  )  ;", "given ( methodInvocation . getThis (  )  )  . willReturn ( this )  ;", "Log   log    =    mock ( Log . class )  ;", "given ( log . isTraceEnabled (  )  )  . willReturn ( true )  ;", "CustomizableTraceInterceptor   interceptor    =    new    . StubCustomizableTraceInterceptor ( log )  ;", "interceptor . invoke ( methodInvocation )  ;", "verify ( log ,    times (  2  )  )  . trace ( anyString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDayPathLogsCorrectly"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   methodInvocation    =    mock ( MethodInvocation . class )  ;", "given ( methodInvocation . getMethod (  )  )  . willReturn ( String . class . getMethod (  \" toString \"  ,    new   Class [  0  ]  )  )  ;", "given ( methodInvocation . getThis (  )  )  . willReturn ( this )  ;", "given ( methodInvocation . getArguments (  )  )  . willReturn ( new   Object [  ]  {     \"  $    One    \\  \\  $  \"  ,    new   Long (  2  )     }  )  ;", "given ( methodInvocation . proceed (  )  )  . willReturn (  \" Hello !  \"  )  ;", "Log   log    =    mock ( Log . class )  ;", "given ( log . isTraceEnabled (  )  )  . willReturn ( true )  ;", "CustomizableTraceInterceptor   interceptor    =    new    . StubCustomizableTraceInterceptor ( log )  ;", "interceptor . setEnterMessage ( new   StringBuffer (  )  . append (  \" Entering   the    '  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ METHOD _ NAME )  . append (  \"  '    method   of   the    [  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ TARGET _ CLASS _ NAME )  . append (  \"  ]    class   with   the   following   args    (  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ ARGUMENTS )  . append (  \"  )    and   arg   types    (  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ ARGUMENT _ TYPES )  . append (  \"  )  .  \"  )  . toString (  )  )  ;", "interceptor . setExitMessage ( new   StringBuffer (  )  . append (  \" Exiting   the    '  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ METHOD _ NAME )  . append (  \"  '    method   of   the    [  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ TARGET _ CLASS _ SHORT _ NAME )  . append (  \"  ]    class   with   the   following   args    (  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ ARGUMENTS )  . append (  \"  )    and   arg   types    (  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ ARGUMENT _ TYPES )  . append (  \"  )  ,    returning    '  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ RETURN _ VALUE )  . append (  \"  '    and   taking    '  \"  )  . append ( CustomizableTraceInterceptor . PLACEHOLDER _ INVOCATION _ TIME )  . append (  \"  '    this   long .  \"  )  . toString (  )  )  ;", "interceptor . invoke ( methodInvocation )  ;", "verify ( log ,    times (  2  )  )  . trace ( anyString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDayPathLogsCorrectlyWithPrettyMuchAllPlaceholdersMatching"], "fileName": "org.springframework.aop.interceptor.CustomizableTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.aop.interceptor.DebugInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . count    =     0  ;", "}", "METHOD_END"], "methodName": ["resetCount"], "fileName": "org.springframework.aop.interceptor.DebugInterceptor"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Intercepted   call   count   not   being   incremented   correctly \"  ,     1  ,    interceptor . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkCallCountTotal"], "fileName": "org.springframework.aop.interceptor.DebugInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   methodInvocation    =    mock ( MethodInvocation . class )  ;", "IllegalArgumentException   exception    =    new   IllegalArgumentException (  )  ;", "given ( methodInvocation . proceed (  )  )  . willThrow ( exception )  ;", "Log   log    =    mock ( Log . class )  ;", "given ( log . isTraceEnabled (  )  )  . willReturn ( true )  ;", "DebugInterceptor   interceptor    =    new    . StubDebugInterceptor ( log )  ;", "try    {", "interceptor . invoke ( methodInvocation )  ;", "fail (  \" Must   have   propagated   the   IllegalArgumentException .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "checkCallCountTotal ( interceptor )  ;", "verify ( log )  . trace ( anyString (  )  )  ;", "verify ( log )  . trace ( anyString (  )  ,    eq ( exception )  )  ;", "}", "METHOD_END"], "methodName": ["testExceptionPathStillLogsCorrectly"], "fileName": "org.springframework.aop.interceptor.DebugInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   methodInvocation    =    mock ( MethodInvocation . class )  ;", "Log   log    =    mock ( Log . class )  ;", "given ( log . isTraceEnabled (  )  )  . willReturn ( true )  ;", "DebugInterceptor   interceptor    =    new    . StubDebugInterceptor ( log )  ;", "interceptor . invoke ( methodInvocation )  ;", "checkCallCountTotal ( interceptor )  ;", "verify ( log ,    times (  2  )  )  . trace ( anyString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDayPathLogsCorrectly"], "fileName": "org.springframework.aop.interceptor.DebugInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultIntroductionAdvisor ( new   ExposeBeanNameAdvisors . ExposeBeanNameIntroduction ( beanName )  )  ;", "}", "METHOD_END"], "methodName": ["createAdvisorIntroducingNamedBean"], "fileName": "org.springframework.aop.interceptor.ExposeBeanNameAdvisors"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPointcutAdvisor ( new   ExposeBeanNameAdvisors . ExposeBeanNameInterceptor ( beanName )  )  ;", "}", "METHOD_END"], "methodName": ["createAdvisorWithoutIntroduction"], "fileName": "org.springframework.aop.interceptor.ExposeBeanNameAdvisors"}, {"methodBody": ["METHOD_START", "{", "return   ExposeBeanNameAdvisors . getBeanName ( ExposeInvocationInterceptor . currentInvocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.aop.interceptor.ExposeBeanNameAdvisors"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( mi   instanceof   ProxyMethodInvocation )  )     {", "throw   new   IllegalArgumentException (  (  \" MethodInvocation   is   not   a   Spring   ProxyMethodInvocation :     \"     +    mi )  )  ;", "}", "ProxyMethodInvocation   pmi    =     (  ( ProxyMethodInvocation )     ( mi )  )  ;", "String   beanName    =     (  ( String )     ( pmi . getUserAttribute (  . BEAN _ NAME _ ATTRIBUTE )  )  )  ;", "if    ( beanName    =  =    null )     {", "throw   new   IllegalStateException (  (  \" Cannot   get   bean   name ;    not   set   on   MethodInvocation :     \"     +    mi )  )  ;", "}", "return   beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.aop.interceptor.ExposeBeanNameAdvisors"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" foo \"  ;", "TestBean   target    =    new    . RequiresBeanNameBoundTestBean ( beanName )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "pf . addAdvisor ( ExposeInvocationInterceptor . ADVISOR )  ;", "pf . addAdvisor ( ExposeBeanNameAdvisors . createAdvisorWithoutIntroduction ( beanName )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "assertFalse (  \" No   introduction \"  ,     ( proxy   instanceof   NamedBean )  )  ;", "proxy . getAge (  )  ;", "}", "METHOD_END"], "methodName": ["testNoIntroduction"], "fileName": "org.springframework.aop.interceptor.ExposeBeanNameAdvisorsTests"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =     \" foo \"  ;", "TestBean   target    =    new    . RequiresBeanNameBoundTestBean ( beanName )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "pf . addAdvisor ( ExposeInvocationInterceptor . ADVISOR )  ;", "pf . addAdvisor ( ExposeBeanNameAdvisors . createAdvisorIntroducingNamedBean ( beanName )  )  ;", "ITestBean   proxy    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "assertTrue (  \" Introduction   was   made \"  ,     ( proxy   instanceof   NamedBean )  )  ;", "proxy . getAge (  )  ;", "NamedBean   nb    =     (  ( NamedBean )     ( proxy )  )  ;", "assertEquals (  \" Name   returned   correctly \"  ,    beanName ,    nb . getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithIntroduction"], "fileName": "org.springframework.aop.interceptor.ExposeBeanNameAdvisorsTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   mi    =    ExposeInvocationInterceptor . invocation . get (  )  ;", "if    ( mi    =  =    null )", "throw   new   IllegalStateException (  (  \" No   MethodInvocation   found :    Check   that   an   AOP   invocation   is   in   progress ,    and   that   the    \"     +     (  \" ExposeInvocationInterceptor   is   upfront   in   the   interceptor   chain .    Specifically ,    note   that    \"     +     \" advices   with   order   HIGHEST _ PRECEDENCE   will   execute   before   ExposeInvocationInterceptor !  \"  )  )  )  ;", "return   mi ;", "}", "METHOD_END"], "methodName": ["currentInvocation"], "fileName": "org.springframework.aop.interceptor.ExposeInvocationInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   ExposeInvocationInterceptor . INSTANCE ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.springframework.aop.interceptor.ExposeInvocationInterceptor"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . CONTEXT )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" proxy \"  )  )  )  ;", "String   name    =     \" tony \"  ;", "tb . setName ( name )  ;", "assertEquals ( name ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testXmlConfig"], "fileName": "org.springframework.aop.interceptor.ExposeInvocationInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . trackAllInvocations    =    trackAllInvocations ;", "}", "METHOD_END"], "methodName": ["setTrackAllInvocations"], "fileName": "org.springframework.aop.interceptor.JamonPerformanceMonitorInterceptor"}, {"methodBody": ["METHOD_START", "{", "String   stackTrace    =     \" stackTrace =  \"     +     ( Misc . getExceptionTrace ( ex )  )  ;", "key . setDetails ( stackTrace )  ;", "Factory . add ( new   MonKeyImp ( ex . getClass (  )  . getName (  )  ,    stackTrace ,     \" Exception \"  )  ,     1  )  ;", "Factory . add ( new   MonKeyImp ( Factory . EXCEPTIONS _ LABEL ,    stackTrace ,     \" Exception \"  )  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["trackException"], "fileName": "org.springframework.aop.interceptor.JamonPerformanceMonitorInterceptor"}, {"methodBody": ["METHOD_START", "{", "MonitorFactory . reset (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.interceptor.JamonPerformanceMonitorInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "MonitorFactory . reset (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.aop.interceptor.JamonPerformanceMonitorInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "given ( mi . getMethod (  )  )  . willReturn ( String . class . getMethod (  \" toString \"  )  )  ;", "given ( mi . proceed (  )  )  . willThrow ( new   IllegalArgumentException (  )  )  ;", "try    {", "invokeUnderTrace ( mi ,    log )  ;", "fail (  \" Must   have   propagated   the   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "assertEquals (  \" Monitors   must   exist   for   the   method   invocation   and    2    exceptions \"  ,     3  ,    MonitorFactory . getNumRows (  )  )  ;", "assertTrue (  \" The   jamon   report   must   contain   the   toString   method   that   was   invoked \"  ,    MonitorFactory . getReport (  )  . contains (  \" toString \"  )  )  ;", "assertTrue (  (  \" The   jamon   report   must   contain   the   generic   exception :     \"     +     ( MonitorFactory . EXCEPTIONS _ LABEL )  )  ,    MonitorFactory . getReport (  )  . contains ( EXCEPTIONS _ LABEL )  )  ;", "assertTrue (  \" The   jamon   report   must   contain   the   specific   exception :    IllegalArgumentException '  \"  ,    MonitorFactory . getReport (  )  . contains (  \" IllegalArgumentException \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testInvokeUnderTraceWithExceptionTracking"], "fileName": "org.springframework.aop.interceptor.JamonPerformanceMonitorInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "given ( mi . getMethod (  )  )  . willReturn ( String . class . getMethod (  \" toString \"  )  )  ;", "invokeUnderTrace ( mi ,    log )  ;", "assertTrue (  \" jamon   must   track   the   method   being   invoked \"  ,     (  ( MonitorFactory . getNumRows (  )  )     >     0  )  )  ;", "assertTrue (  \" The   jamon   report   must   contain   the   toString   method   that   was   invoked \"  ,    MonitorFactory . getReport (  )  . contains (  \" toString \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testInvokeUnderTraceWithNormalProcessing"], "fileName": "org.springframework.aop.interceptor.JamonPerformanceMonitorInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   mi    =    mock ( MethodInvocation . class )  ;", "given ( mi . getMethod (  )  )  . willReturn ( String . class . getMethod (  \" toString \"  ,    new   Class [  0  ]  )  )  ;", "given ( mi . proceed (  )  )  . willThrow ( new   IllegalArgumentException (  )  )  ;", "Log   log    =    mock ( Log . class )  ;", "interceptor    =    new    ( true )  ;", "try    {", "interceptor . invokeUnderTrace ( mi ,    log )  ;", "fail (  \" Must   have   propagated   the   IllegalArgumentException .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "verify ( log )  . trace ( anyString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExceptionPathStillLogsPerformanceMetricsCorrectly"], "fileName": "org.springframework.aop.interceptor.PerformanceMonitorInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "PerformanceMonitorInterceptor   interceptor    =    new   PerformanceMonitorInterceptor (  )  ;", "assertNotNull ( interceptor . getPrefix (  )  )  ;", "assertNotNull ( interceptor . getSuffix (  )  )  ;", "interceptor . setPrefix ( null )  ;", "interceptor . setSuffix ( null )  ;", "assertNotNull ( interceptor . getPrefix (  )  )  ;", "assertNotNull ( interceptor . getSuffix (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSuffixAndPrefixAssignment"], "fileName": "org.springframework.aop.interceptor.PerformanceMonitorInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   mi    =    mock ( MethodInvocation . class )  ;", "given ( mi . getMethod (  )  )  . willReturn ( String . class . getMethod (  \" toString \"  ,    new   Class [  0  ]  )  )  ;", "Log   log    =    mock ( Log . class )  ;", "interceptor    =    new    ( true )  ;", "interceptor . invokeUnderTrace ( mi ,    log )  ;", "verify ( log )  . trace ( anyString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDayPathLogsPerformanceMetricsCorrectly"], "fileName": "org.springframework.aop.interceptor.PerformanceMonitorInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" method    '  \"     +     ( invocation . getMethod (  )  . getName (  )  )  )     +     \"  '    of   class    [  \"  )     +     ( invocation . getThis (  )  . getClass (  )  . getName (  )  )  )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["getInvocationDescription"], "fileName": "org.springframework.aop.interceptor.SimpleTraceInterceptor"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   mi    =    mock ( MethodInvocation . class )  ;", "given ( mi . getMethod (  )  )  . willReturn ( String . class . getMethod (  \" toString \"  )  )  ;", "given ( mi . getThis (  )  )  . willReturn ( this )  ;", "IllegalArgumentException   exception    =    new   IllegalArgumentException (  )  ;", "given ( mi . proceed (  )  )  . willThrow ( exception )  ;", "Log   log    =    mock ( Log . class )  ;", "final      interceptor    =    new    ( true )  ;", "try    {", "interceptor . invokeUnderTrace ( mi ,    log )  ;", "fail (  \" Must   have   propagated   the   IllegalArgumentException .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "verify ( log )  . trace ( anyString (  )  )  ;", "verify ( log )  . trace ( anyString (  )  ,    eq ( exception )  )  ;", "}", "METHOD_END"], "methodName": ["testExceptionPathStillLogsCorrectly"], "fileName": "org.springframework.aop.interceptor.SimpleTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvocation   mi    =    mock ( MethodInvocation . class )  ;", "given ( mi . getMethod (  )  )  . willReturn ( String . class . getMethod (  \" toString \"  )  )  ;", "given ( mi . getThis (  )  )  . willReturn ( this )  ;", "Log   log    =    mock ( Log . class )  ;", "interceptor    =    new    ( true )  ;", "interceptor . invokeUnderTrace ( mi ,    log )  ;", "verify ( log ,    times (  2  )  )  . trace ( anyString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDayPathLogsCorrectly"], "fileName": "org.springframework.aop.interceptor.SimpleTraceInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableBeanFactory   factory    =    mock ( ConfigurableBeanFactory . class )  ;", "new    ( factory ,    badTargetBeanName )  ;", "}", "METHOD_END"], "methodName": ["testBadTargetBeanName"], "fileName": "org.springframework.aop.scope.DefaultScopedObjectTests"}, {"methodBody": ["METHOD_START", "{", "DefaultScopedObjectTests . testBadTargetBeanName (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithEmptyTargetBeanName"], "fileName": "org.springframework.aop.scope.DefaultScopedObjectTests"}, {"methodBody": ["METHOD_START", "{", "DefaultScopedObjectTests . testBadTargetBeanName (  \"           \"  )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithJustWhitespacedTargetBeanName"], "fileName": "org.springframework.aop.scope.DefaultScopedObjectTests"}, {"methodBody": ["METHOD_START", "{", "new   DefaultScopedObject ( null ,    DefaultScopedObjectTests . GOOD _ BEAN _ NAME )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullBeanFactory"], "fileName": "org.springframework.aop.scope.DefaultScopedObjectTests"}, {"methodBody": ["METHOD_START", "{", "DefaultScopedObjectTests . testBadTargetBeanName ( null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullTargetBeanName"], "fileName": "org.springframework.aop.scope.DefaultScopedObjectTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . SCOPED _ AUTOWIRE _ FALSE _ CONTEXT )  ;", "assertTrue ( Arrays . asList ( bf . getBeanNamesForType (  . TestBean . class ,    false ,    false )  )  . contains (  \" scoped \"  )  )  ;", "assertTrue ( Arrays . asList ( bf . getBeanNamesForType (  . TestBean . class ,    true ,    false )  )  . contains (  \" scoped \"  )  )  ;", "assertFalse ( bf . containsSingleton (  \" scoped \"  )  )  ;", ". TestBean   autowired    =     (  (  . TestBean )     ( bf . getBean (  \" autowired \"  )  )  )  ;", ". TestBean   unscoped    =     (  (  . TestBean )     ( bf . getBean (  \" unscoped \"  )  )  )  ;", "assertSame ( unscoped ,    autowired . getChild (  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedProxyInheritsAutowireCandidateFalse"], "fileName": "org.springframework.aop.scope.ScopedProxyAutowireTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . SCOPED _ AUTOWIRE _ TRUE _ CONTEXT )  ;", "assertTrue ( Arrays . asList ( bf . getBeanNamesForType (  . TestBean . class ,    true ,    false )  )  . contains (  \" scoped \"  )  )  ;", "assertTrue ( Arrays . asList ( bf . getBeanNamesForType (  . TestBean . class ,    false ,    false )  )  . contains (  \" scoped \"  )  )  ;", "assertFalse ( bf . containsSingleton (  \" scoped \"  )  )  ;", ". TestBean   autowired    =     (  (  . TestBean )     ( bf . getBean (  \" autowired \"  )  )  )  ;", ". TestBean   scoped    =     (  (  . TestBean )     ( bf . getBean (  \" scoped \"  )  )  )  ;", "assertSame ( scoped ,    autowired . getChild (  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedProxyReplacesAutowireCandidateTrue"], "fileName": "org.springframework.aop.scope.ScopedProxyAutowireTests"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanName    =    targetBeanName ;", "thisdTargetSource . setTargetBeanName ( targetBeanName )  ;", "}", "METHOD_END"], "methodName": ["setTargetBeanName"], "fileName": "org.springframework.aop.scope.ScopedProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "String   originalBeanName    =    definition . getBeanName (  )  ;", "BeanDefinition   targetDefinition    =    definition . getBeanDefinition (  )  ;", "String   targetBeanName    =     . getTargetBeanName ( originalBeanName )  ;", "RootBeanDefinition   proxyDefinition    =    new   RootBeanDefinition ( ScopedProxyFactoryBean . class )  ;", "proxyDefinition . setDecoratedDefinition ( new   BeanDefinitionHolder ( targetDefinition ,    targetBeanName )  )  ;", "proxyDefinition . setOriginatingBeanDefinition ( targetDefinition )  ;", "proxyDefinition . setSource ( definition . getSource (  )  )  ;", "proxyDefinition . setRole ( targetDefinition . getRole (  )  )  ;", "proxyDefinition . getPropertyValues (  )  . add (  \" targetBeanName \"  ,    targetBeanName )  ;", "if    ( proxyTargetClass )     {", "targetDefinition . setAttribute ( AutoProxyUtils . PRESERVE _ TARGET _ CLASS _ ATTRIBUTE ,    Boolean . TRUE )  ;", "} else    {", "proxyDefinition . getPropertyValues (  )  . add (  \" proxyTargetClass \"  ,    Boolean . FALSE )  ;", "}", "proxyDefinition . setAutowireCandidate ( targetDefinition . isAutowireCandidate (  )  )  ;", "proxyDefinition . setPrimary ( targetDefinition . isPrimary (  )  )  ;", "if    ( targetDefinition   instanceof   AbstractBeanDefinition )     {", "proxyDefinition . copyQualifiersFrom (  (  ( AbstractBeanDefinition )     ( targetDefinition )  )  )  ;", "}", "targetDefinition . setAutowireCandidate ( false )  ;", "targetDefinition . setPrimary ( false )  ;", "registry . registerBeanDefinition ( targetBeanName ,    targetDefinition )  ;", "return   new   BeanDefinitionHolder ( proxyDefinition ,    originalBeanName ,    definition . getAliases (  )  )  ;", "}", "METHOD_END"], "methodName": ["createScopedProxy"], "fileName": "org.springframework.aop.scope.ScopedProxyUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( ScopedProxyUtils . TARGET _ NAME _ PREFIX )     +    originalBeanName ;", "}", "METHOD_END"], "methodName": ["getTargetBeanName"], "fileName": "org.springframework.aop.scope.ScopedProxyUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( beanName    !  =    null )     &  &     ( beanName . startsWith ( ScopedProxyUtils . TARGET _ NAME _ PREFIX )  )  ;", "}", "METHOD_END"], "methodName": ["isScopedTarget"], "fileName": "org.springframework.aop.scope.ScopedProxyUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . adviceBeanName ;", "}", "METHOD_END"], "methodName": ["getAdviceBeanName"], "fileName": "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "reseceMonitor (  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )    instanceof   ConfigurableBeanFactory )     {", "this . adviceMonitor    =     (  ( ConfigurableBeanFactory )     ( this . beanFactory )  )  . getSingletonMutex (  )  ;", "} else    {", "this . adviceMonitor    =    new   Object (  )  ;", "}", "}", "METHOD_END"], "methodName": ["resetAdviceMonitor"], "fileName": "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . adviceMonitor )     {", "this . advice    =    advice ;", "}", "}", "METHOD_END"], "methodName": ["setAdvice"], "fileName": "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . adviceBeanName    =    adviceBeanName ;", "}", "METHOD_END"], "methodName": ["setAdviceBeanName"], "fileName": "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "return   this . location ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "org.springframework.aop.support.AbstractExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "this . expression    =    expression ;", "try    {", "onSe ( expression )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "if    (  ( this . location )     !  =    null )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Invalid   expression   at   location    [  \"     +     ( this . location )  )     +     \"  ]  :     \"  )     +    ex )  )  ;", "} else    {", "throw   ex ;", "}", "}", "}", "METHOD_END"], "methodName": ["setExpression"], "fileName": "org.springframework.aop.support.AbstractExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "this . location    =    location ;", "}", "METHOD_END"], "methodName": ["setLocation"], "fileName": "org.springframework.aop.support.AbstractExpressionPointcut"}, {"methodBody": ["METHOD_START", "{", "this . advice    =    advice ;", "}", "METHOD_END"], "methodName": ["setAdvice"], "fileName": "org.springframework.aop.support.AbstractGenericPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.aop.support.AbstractPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "return   this . excludedPatterns ;", "}", "METHOD_END"], "methodName": ["getExcludedPatterns"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "return   this . patterns ;", "}", "METHOD_END"], "methodName": ["getPatterns"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( this . patterns . length )  ;    i +  +  )     {", "boolean   matched    =    matches ( signatureSt ,    i )  ;", "if    ( matched )     {", "for    ( int   j    =     0  ;    j    <     ( this . excludedPatterns . length )  ;    j +  +  )     {", "boolean   excluded    =    matchesExclusion ( signatureSt ,    j )  ;", "if    ( excluded )     {", "return   false ;", "}", "}", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matchesPattern"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "setExcludedPatterns ( excludedPattern )  ;", "}", "METHOD_END"], "methodName": ["setExcludedPattern"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( excludedPatterns ,     \"  ' excludedPatterns '    must   not   be   empty \"  )  ;", "this . excludedPatterns    =    new   St [ excludedPatterns . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( excludedPatterns . length )  ;    i +  +  )     {", "this . excludedPatterns [ i ]     =    StUtils . trimWhitespace ( excludedPatterns [ i ]  )  ;", "}", "initExcludedPatternRepresentation ( this . excludedPatterns )  ;", "}", "METHOD_END"], "methodName": ["setExcludedPatterns"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "setPatterns ( pattern )  ;", "}", "METHOD_END"], "methodName": ["setPattern"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( patterns ,     \"  ' patterns '    must   not   be   empty \"  )  ;", "this . patterns    =    new   St [ patterns . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( patterns . length )  ;    i +  +  )     {", "this . patterns [ i ]     =    StUtils . trimWhitespace ( patterns [ i ]  )  ;", "}", "initPatternRepresentation ( this . patterns )  ;", "}", "METHOD_END"], "methodName": ["setPatterns"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( rpc . matches ( Object . class . getMethod (  \" hashCode \"  )  ,    String . class )  )  ;", "assertTrue ( rpc . matches ( Object . class . getMethod (  \" hashCode \"  )  ,    Object . class )  )  ;", "assertFalse ( rpc . matches ( Object . class . getMethod (  \" wait \"  )  ,    Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["exactMatchTests"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( rpc . matches ( Object . class . getMethod (  \" hashCode \"  )  ,    String . class )  )  ;", "assertFalse ( rpc . matches ( Object . class . getMethod (  \" wait \"  )  ,    Object . class )  )  ;", "assertEquals (  0  ,    rpc . getPatterns (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["noPatternSuppliedTests"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "rpc    =    getRegexpMethodPointcut (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "rpc . setPattern (  \" hashCode \"  )  ;", "exactMatchTests ( rpc )  ;", "rpc    =     (  (  )     ( SerializationTestUtils . serializeAndDeserialize ( rpc )  )  )  ;", "exactMatchTests ( rpc )  ;", "}", "METHOD_END"], "methodName": ["testExactMatch"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "rpc . setPattern (  \" *  \"  )  ;", "assertTrue ( rpc . matches ( Exception . class . get (  \" hashCode \"  )  ,    IOException . class )  )  ;", "assertFalse ( rpc . matches ( Exception . class . get (  \" getMessage \"  )  ,    Exception . class )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchesObjectClass"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "noPatternSuppliedTests ( rpc )  ;", "}", "METHOD_END"], "methodName": ["testNoPatternSupplied"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "rpc    =     (  ( AbstractRegexpMethodPointcut )     ( SerializationTestUtils . serializeAndDeserialize ( rpc )  )  )  ;", "noPatternSuppliedTests ( rpc )  ;", "}", "METHOD_END"], "methodName": ["testSerializationWithNoPatternSupplied"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "rpc . setPattern (  \" hashCode \"  )  ;", "assertTrue ( rpc . matches ( Object . class . get (  \" hashCode \"  )  ,    String . class )  )  ;", "assertFalse ( rpc . matches ( Object . class . get (  \" hashCode \"  )  ,    Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["testSpecificMatch"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "rpc . setPattern (  \"  .  * Object . hashCode \"  )  ;", "assertTrue ( rpc . matches ( Object . class . get (  \" hashCode \"  )  ,    Object . class )  )  ;", "assertFalse ( rpc . matches ( Object . class . get (  \" wait \"  )  ,    Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWildcard"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "rpc . setPattern (  \" *  \"  )  ;", "assertTrue ( rpc . matches ( Object . class . get (  \" hashCode \"  )  ,    String . class )  )  ;", "assertTrue ( rpc . matches ( Object . class . get (  \" wait \"  )  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWildcardForOneClass"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "this . rpc . setPattern (  \"  .  * get .  *  \"  )  ;", "this . rpc . setExcludedPattern (  \"  .  * Age .  *  \"  )  ;", "assertTrue ( this . rpc . matches ( TestBean . class . get (  \" getName \"  )  ,    TestBean . class )  )  ;", "assertFalse ( this . rpc . matches ( TestBean . class . get (  \" getAge \"  )  ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWithExclusion"], "fileName": "org.springframework.aop.support.AbstractRegexpMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "return   AopUtils . canApply ( advisor ,    targetClass ,    false )  ;", "}", "METHOD_END"], "methodName": ["canApply"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( advisor   instanceof   IntroductionAdvisor )     {", "return    (  ( IntroductionAdvisor )     ( advisor )  )  . getClassFilter (  )  . matches ( targetClass )  ;", "} else", "if    ( advisor   instanceof   PointcutAdvisor )     {", "PointcutAdvisor   pca    =     (  ( PointcutAdvisor )     ( advisor )  )  ;", "return   AopUtils . canApply ( pca . getPointcut (  )  ,    targetClass ,    hasIntroductions )  ;", "} else    {", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["canApply"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "return   AopUtils . canApply ( pc ,    targetClass ,    false )  ;", "}", "METHOD_END"], "methodName": ["canApply"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( pc ,     \" Pointcut   must   not   be   null \"  )  ;", "if    (  !  ( pc . getClassFilter (  )  . matches ( targetClass )  )  )     {", "return   false ;", "}", "MethodMatcher   methodMatcher    =    pc . getMethodMatcher (  )  ;", "if    ( methodMatcher    =  =     ( MethodMatcher . TRUE )  )     {", "return   true ;", "}", "IntroductionAwareMethodMatcher   introductionAwareMethodMatcher    =    null ;", "if    ( methodMatcher   instanceof   IntroductionAwareMethodMatcher )     {", "introductionAwareMethodMatcher    =     (  ( IntroductionAwareMethodMatcher )     ( methodMatcher )  )  ;", "}", "Set < Class <  ?  >  >    classes    =    new   LinkedHashSet <  >  (  )  ;", "if    (  !  ( Proxy . isProxyClass ( targetClass )  )  )     {", "classes . add ( Class . getUserClass ( targetClass )  )  ;", "}", "classes . addAll ( Class . getAllInterfacesForClassAsSet ( targetClass )  )  ;", "for    ( Class <  ?  >    clazz    :    classes )     {", "Method [  ]    methods    =    Reflection . getAllDeclaredMethods ( clazz )  ;", "for    ( Method   method    :    methods )     {", "if    (  (  ( introductionAwareMethodMatcher    !  =    null )     &  &     ( introductionAwareMethodMatcher . matches ( method ,    targetClass ,    hasIntroductions )  )  )     |  |     ( methodMatcher . matches ( method ,    targetClass )  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["canApply"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( candidateAdvisors . isEmpty (  )  )     {", "return   candidateAdvisors ;", "}", "List < Advisor >    eligibleAdvisors    =    new   LinkedList <  >  (  )  ;", "for    ( Advisor   candidate    :    candidateAdvisors )     {", "if    (  ( candidate   instanceof   IntroductionAdvisor )     &  &     (  . canApply ( candidate ,    clazz )  )  )     {", "eligibleAdvisors . add ( candidate )  ;", "}", "}", "boolean   hasIntroductions    =     !  ( eligibleAdvisors . isEmpty (  )  )  ;", "for    ( Advisor   candidate    :    candidateAdvisors )     {", "if    ( candidate   instanceof   IntroductionAdvisor )     {", "continue ;", "}", "if    (  . canApply ( candidate ,    clazz ,    hasIntroductions )  )     {", "eligibleAdvisors . add ( candidate )  ;", "}", "}", "return   eligibleAdvisors ;", "}", "METHOD_END"], "methodName": ["findAdvisorsThatCanApply"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    specificTargetClass    =     (  ( targetClass    !  =    null )     &  &     (  !  ( Proxy . isProxyClass ( targetClass )  )  )  )     ?    ClassUtils . getUserClass ( targetClass )     :    null ;", "Method   resolvedMethod    =    ClassUtils . getMostSpecificMethod ( method ,    specificTargetClass )  ;", "return   BridgeMethodResolver . findBridgedMethod ( resolvedMethod )  ;", "}", "METHOD_END"], "methodName": ["getMostSpecificMethod"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( candidate ,     \" Candidate   object   must   not   be   null \"  )  ;", "Class <  ?  >    result    =    null ;", "if    ( candidate   instanceof   TargetClassAware )     {", "result    =     (  ( TargetClassAware )     ( candidate )  )  . getTargetClass (  )  ;", "}", "if    ( result    =  =    null )     {", "result    =     (  . isCglibProxy ( candidate )  )     ?    candidate . getClass (  )  . getSuperclass (  )     :    candidate . getClass (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getTargetClass"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "Reflection . makeAccessible ( method )  ;", "return   method . invoke ( target ,    args )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   ex . getTargetException (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   AopInvocationException (  (  (  (  (  \" AOP   configuration   seems   to   be   invalid :    tried   calling   method    [  \"     +    method )     +     \"  ]    on   target    [  \"  )     +    target )     +     \"  ]  \"  )  ,    ex )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   AopInvocationException (  (  (  \" Could   not   access   method    [  \"     +    method )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeJoinpointUsingReflection"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( object   instanceof   SpringProxy )     &  &     (  ( Proxy . isProxyClass ( object . getClass (  )  )  )     |  |     ( ClassUtils . isCglibProxyClass ( object . getClass (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAopProxy"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( object   instanceof   SpringProxy )     &  &     ( ClassUtils . isCglibProxy ( object )  )  ;", "}", "METHOD_END"], "methodName": ["isCglibProxy"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtils . isEqualsMethod ( method )  ;", "}", "METHOD_END"], "methodName": ["isEqualsMethod"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( method    !  =    null )     &  &     ( method . getName (  )  . equals (  \" finalize \"  )  )  )     &  &     (  ( method . getParameterCount (  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isFinalizeMethod"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtils . isHashCodeMethod ( method )  ;", "}", "METHOD_END"], "methodName": ["isHashCodeMethod"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( object   instanceof   SpringProxy )     &  &     ( Proxy . isProxyClass ( object . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isJdkDynamicProxy"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtils . isToStringMethod ( method )  ;", "}", "METHOD_END"], "methodName": ["isToStringMethod"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( targetType    =  =    null )     {", "return   method ;", "}", "Method   methodToUse    =    MethodIntrospector . selectInvocableMethod ( method ,    targetType )  ;", "if    (  (  ( Modifier . isPrivate ( methodToUse . getModifiers (  )  )  )     &  &     (  !  ( Modifier . isStatic ( methodToUse . getModifiers (  )  )  )  )  )     &  &     ( SProxy . class . isAssignableFrom ( targetType )  )  )     {", "throw   new   IllegalStateException ( String . format (  (  \" Need   to   invoke   method    '  % s '    found   on   proxy   for   target   class    '  % s '    but   cannot    \"     +     \" be   delegated   to   target   bean .    Switch   its   visibility   to   package   or   protected .  \"  )  ,    method . getName (  )  ,    method . getDeclaringClass (  )  . getSimpleName (  )  )  )  ;", "}", "return   methodToUse ;", "}", "METHOD_END"], "methodName": ["selectInvocableMethod"], "fileName": "org.springframework.aop.support.AopUtils"}, {"methodBody": ["METHOD_START", "{", "assertSame ( MethodMatcher . TRUE ,    SerializationTestUtils . serializeAndDeserialize ( MethodMatcher . TRUE )  )  ;", "assertSame ( ClassFilter . TRUE ,    SerializationTestUtils . serializeAndDeserialize ( ClassFilter . TRUE )  )  ;", "assertSame ( Pointcut . TRUE ,    SerializationTestUtils . serializeAndDeserialize ( Pointcut . TRUE )  )  ;", "assertSame ( EmptyTargetSource . INSTANCE ,    SerializationTestUtils . serializeAndDeserialize ( EmptyTargetSource . INSTANCE )  )  ;", "assertSame ( Pointcuts . SETTERS ,    SerializationTestUtils . serializeAndDeserialize ( Pointcuts . SETTERS )  )  ;", "assertSame ( Pointcuts . GETTERS ,    SerializationTestUtils . serializeAndDeserialize ( Pointcuts . GETTERS )  )  ;", "assertSame ( ExposeInvocationInterceptor . INSTANCE ,    SerializationTestUtils . serializeAndDeserialize ( ExposeInvocationInterceptor . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["testCanonicalFrameworkClassesStillCanonicalOnDeserialization"], "fileName": "org.springframework.aop.support.AopUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AopUtils . canApply ( new   DefaultPointcutAdvisor ( new   NopInterceptor (  )  )  ,    Object . class )  )  ;", "assertTrue ( AopUtils . canApply ( new   DefaultPointcutAdvisor ( new   NopInterceptor (  )  )  ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testPointcutAlwaysApplies"], "fileName": "org.springframework.aop.support.AopUtilsTests"}, {"methodBody": ["METHOD_START", "{", "class   TestPointcut   extends   StaticMethodMatcherPointcut    {", "@ Override", "public   boolean   matches ( Method   method ,     @ Nullable", "Class <  ?  >    clazz )     {", "return   method . getName (  )  . equals (  \" hashCode \"  )  ;", "}", "}", "Pointcut   pc    =    new   TestPointcut (  )  ;", "assertTrue (  . canApply ( pc ,    Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["testPointcutAppliesToOneMethodOnObject"], "fileName": "org.springframework.aop.support.AopUtilsTests"}, {"methodBody": ["METHOD_START", "{", "class   TestPointcut   extends   StaticMethodMatcherPointcut    {", "@ Override", "public   boolean   matches ( Method   method ,     @ Nullable", "Class <  ?  >    clazzy )     {", "return   false ;", "}", "}", "Pointcut   no    =    new   TestPointcut (  )  ;", "assertFalse (  . canApply ( no ,    Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["testPointcutCanNeverApply"], "fileName": "org.springframework.aop.support.AopUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cf 1  ,     \" First   ClassFilter   must   not   be   null \"  )  ;", "Assert . notNull ( cf 2  ,     \" Second   ClassFilter   must   not   be   null \"  )  ;", "return   new    . IntersectionClassFilter ( new   ClassFilter [  ]  {    cf 1  ,    cf 2     }  )  ;", "}", "METHOD_END"], "methodName": ["intersection"], "fileName": "org.springframework.aop.support.ClassFilters"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( classFilters ,     \" ClassFilter   array   must   not   be   empty \"  )  ;", "return   new    . IntersectionClassFilter ( classFilters )  ;", "}", "METHOD_END"], "methodName": ["intersection"], "fileName": "org.springframework.aop.support.ClassFilters"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cf 1  ,     \" First   ClassFilter   must   not   be   null \"  )  ;", "Assert . notNull ( cf 2  ,     \" Second   ClassFilter   must   not   be   null \"  )  ;", "return   new    . UnionClassFilter ( new   ClassFilter [  ]  {    cf 1  ,    cf 2     }  )  ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.springframework.aop.support.ClassFilters"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( classFilters ,     \" ClassFilter   array   must   not   be   empty \"  )  ;", "return   new    . UnionClassFilter ( classFilters )  ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.springframework.aop.support.ClassFilters"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( exceptionFilter . matches ( RuntimeException . class )  )  ;", "assertTrue ( hasRootCauseFilter . matches ( NestedRuntimeException . class )  )  ;", "ClassFilter   intersection    =     . intersection ( exceptionFilter ,    hasRootCauseFilter )  ;", "assertFalse ( intersection . matches ( RuntimeException . class )  )  ;", "assertFalse ( intersection . matches ( TestBean . class )  )  ;", "assertTrue ( intersection . matches ( NestedRuntimeException . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIntersection"], "fileName": "org.springframework.aop.support.ClassFiltersTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( exceptionFilter . matches ( RuntimeException . class )  )  ;", "assertFalse ( exceptionFilter . matches ( TestBean . class )  )  ;", "assertFalse ( itbFilter . matches ( Exception . class )  )  ;", "assertTrue ( itbFilter . matches ( TestBean . class )  )  ;", "ClassFilter   union    =     . union ( exceptionFilter ,    itbFilter )  ;", "assertTrue ( union . matches ( RuntimeException . class )  )  ;", "assertTrue ( union . matches ( TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testUnion"], "fileName": "org.springframework.aop.support.ClassFiltersTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . setTarget ( tb )  ;", "pf . setProxyTargetClass ( true )  ;", "TestBean   proxy    =     (  ( TestBean )     ( pf . getProxy (  )  )  )  ;", "String   className    =     . getShortName ( proxy . getClass (  )  )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" TestBean \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["getShortNameForCglibClass"], "fileName": "org.springframework.aop.support.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "this . classFilter    =    ClassFilters . intersection ( this . classFilter ,    other )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["intersection"], "fileName": "org.springframework.aop.support.ComposablePointcut"}, {"methodBody": ["METHOD_START", "{", "this . methodMatcher    =    MethodMatchers . intersection ( this . methodMatcher ,    other )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["intersection"], "fileName": "org.springframework.aop.support.ComposablePointcut"}, {"methodBody": ["METHOD_START", "{", "this . classFilter    =    ClassFilters . intersection ( this . classFilter ,    other . getClassFilter (  )  )  ;", "this . methodMatcher    =    MethodMatchers . intersection ( this . methodMatcher ,    other . getMethodMatcher (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["intersection"], "fileName": "org.springframework.aop.support.ComposablePointcut"}, {"methodBody": ["METHOD_START", "{", "this . classFilter    =    ClassFilters . union ( this . classFilter ,    other )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.springframework.aop.support.ComposablePointcut"}, {"methodBody": ["METHOD_START", "{", "this . methodMatcher    =    MethodMatchers . union ( this . methodMatcher ,    other )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.springframework.aop.support.ComposablePointcut"}, {"methodBody": ["METHOD_START", "{", "this . methodMatcher    =    MethodMatchers . union ( this . methodMatcher ,    this . classFilter ,    other . getMethodMatcher (  )  ,    other . getClassFilter (  )  )  ;", "this . classFilter    =    ClassFilters . union ( this . classFilter ,    other . getClassFilter (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.springframework.aop.support.ComposablePointcut"}, {"methodBody": ["METHOD_START", "{", "ComposablePointcut   pc 1     =    new   ComposablePointcut (  )  ;", "ComposablePointcut   pc 2     =    new   ComposablePointcut (  )  ;", "assertEquals ( pc 1  ,    pc 2  )  ;", "assertEquals ( pc 1  . hashCode (  )  ,    pc 2  . hashCode (  )  )  ;", "pc 1  . intersection (  . GETTER _ METHOD _ MATCHER )  ;", "assertFalse ( pc 1  . equals ( pc 2  )  )  ;", "assertFalse (  (  ( pc 1  . hashCode (  )  )     =  =     ( pc 2  . hashCode (  )  )  )  )  ;", "pc 2  . intersection (  . GETTER _ METHOD _ MATCHER )  ;", "assertEquals ( pc 1  ,    pc 2  )  ;", "assertEquals ( pc 1  . hashCode (  )  ,    pc 2  . hashCode (  )  )  ;", "pc 1  . union (  . GET _ AGE _ METHOD _ MATCHER )  ;", "pc 2  . union (  . GET _ AGE _ METHOD _ MATCHER )  ;", "assertEquals ( pc 1  ,    pc 2  )  ;", "assertEquals ( pc 1  . hashCode (  )  ,    pc 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEqualsAndHashCode"], "fileName": "org.springframework.aop.support.ComposablePointcutTests"}, {"methodBody": ["METHOD_START", "{", "ComposablePointcut   pc    =    new   ComposablePointcut (  )  ;", "assertTrue ( pc . getClassFilter (  )  . matches ( Object . class )  )  ;", "ClassFilter   cf    =    new   RootClassFilter ( Exception . class )  ;", "pc . intersection ( cf )  ;", "assertFalse ( pc . getClassFilter (  )  . matches ( Object . class )  )  ;", "assertTrue ( pc . getClassFilter (  )  . matches ( Exception . class )  )  ;", "pc . intersection ( new   RootClassFilter ( NestedRuntimeException . class )  )  ;", "assertFalse ( pc . getClassFilter (  )  . matches ( Exception . class )  )  ;", "assertTrue ( pc . getClassFilter (  )  . matches ( NestedRuntimeException . class )  )  ;", "assertFalse ( pc . getClassFilter (  )  . matches ( String . class )  )  ;", "pc . union ( new   RootClassFilter ( String . class )  )  ;", "assertFalse ( pc . getClassFilter (  )  . matches ( Exception . class )  )  ;", "assertTrue ( pc . getClassFilter (  )  . matches ( String . class )  )  ;", "assertTrue ( pc . getClassFilter (  )  . matches ( NestedRuntimeException . class )  )  ;", "}", "METHOD_END"], "methodName": ["testFilterByClass"], "fileName": "org.springframework.aop.support.ComposablePointcutTests"}, {"methodBody": ["METHOD_START", "{", "ComposablePointcut   pc    =    new   ComposablePointcut (  )  ;", "assertTrue ( pc . getMethodMatcher (  )  . matches ( PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertTrue ( pc . getMethodMatcher (  )  . matches ( PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertTrue ( pc . getMethodMatcher (  )  . matches ( PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "pc . intersection (  . GETTER _ METHOD _ MATCHER )  ;", "assertFalse ( pc . getMethodMatcher (  )  . matches ( PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertTrue ( pc . getMethodMatcher (  )  . matches ( PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertTrue ( pc . getMethodMatcher (  )  . matches ( PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "pc . intersection (  . GET _ AGE _ METHOD _ MATCHER )  ;", "assertFalse ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIntersectionMethodMatcher"], "fileName": "org.springframework.aop.support.ComposablePointcutTests"}, {"methodBody": ["METHOD_START", "{", "Pointcut   pc    =    new   ComposablePointcut (  )  ;", "assertTrue ( pc . getClassFilter (  )  . matches ( Object . class )  )  ;", "assertTrue ( pc . getMethodMatcher (  )  . matches ( Object . class . getMethod (  \" hashCode \"  )  ,    Exception . class )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchAll"], "fileName": "org.springframework.aop.support.ComposablePointcutTests"}, {"methodBody": ["METHOD_START", "{", "ComposablePointcut   pc    =    new   ComposablePointcut ( ClassFilter . TRUE ,    ComposablePointcutTests . GET _ AGE _ METHOD _ MATCHER )  ;", "assertFalse ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "pc . union ( ComposablePointcutTests . GETTER _ METHOD _ MATCHER )  ;", "assertFalse ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "pc . union ( ComposablePointcutTests . ABSQUATULATE _ METHOD _ MATCHER )  ;", "assertTrue ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( pc ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testUnionMethodMatcher"], "fileName": "org.springframework.aop.support.ComposablePointcutTests"}, {"methodBody": ["METHOD_START", "{", "return   this . evaluations ;", "}", "METHOD_END"], "methodName": ["getEvaluations"], "fileName": "org.springframework.aop.support.ControlFlowPointcut"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class )  ,    new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class )  )  ;", "assertEquals ( new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class ,     \" getAge \"  )  ,    new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class ,     \" getAge \"  )  )  ;", "assertFalse ( new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class ,     \" getAge \"  )  . equals ( new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class )  )  )  ;", "assertEquals ( new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class )  . hashCode (  )  ,    new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class )  . hashCode (  )  )  ;", "assertEquals ( new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class ,     \" getAge \"  )  . hashCode (  )  ,    new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class ,     \" getAge \"  )  . hashCode (  )  )  ;", "assertFalse (  (  ( new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class ,     \" getAge \"  )  . hashCode (  )  )     =  =     ( new   ControlFlowPointcut ( ControlFlowPointcutTests . One . class )  . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEqualsAndHashCode"], "fileName": "org.springframework.aop.support.ControlFlowPointcutTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  7  )  ;", "NopInterceptor   nop    =    new   NopInterceptor (  )  ;", "ControlFlowPointcut   cflow    =    new   ControlFlowPointcut (  . One . class ,     \" getAge \"  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "pf . addAdvisor ( new   DefaultPointcutAdvisor ( cflow ,    nop )  )  ;", "assertEquals ( target . getAge (  )  ,    proxied . getAge (  )  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "assertEquals ( target . getAge (  )  ,    new    . One (  )  . getAge ( proxied )  )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "assertEquals ( target . getAge (  )  ,    new    . One (  )  . nomatch ( proxied )  )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "assertEquals (  3  ,    cflow . getEvaluations (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatches"], "fileName": "org.springframework.aop.support.ControlFlowPointcutTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setAge (  2  7  )  ;", "NopInterceptor   nop    =    new   NopInterceptor (  )  ;", "ControlFlowPointcut   cflow    =    new   ControlFlowPointcut (  . One . class )  ;", "Pointcut   settersUnderOne    =    Pointcuts . intersection ( Pointcuts . SETTERS ,    cflow )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "ITestBean   proxied    =     (  ( ITestBean )     ( pf . getProxy (  )  )  )  ;", "pf . addAdvisor ( new   DefaultPointcutAdvisor ( settersUnderOne ,    nop )  )  ;", "target . setAge (  1  6  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "assertEquals (  1  6  ,    new    . One (  )  . getAge ( proxied )  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "new    . One (  )  . set ( proxied )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "assertEquals (  1  ,    cflow . getEvaluations (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSelectiveApplication"], "fileName": "org.springframework.aop.support.ControlFlowPointcutTests"}, {"methodBody": ["METHOD_START", "{", "this . pointcut    =     ( pointcut    !  =    null )     ?    pointcut    :    Pointcut . TRUE ;", "}", "METHOD_END"], "methodName": ["setPointcut"], "fileName": "org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( intf ,     \" Interface   must   not   be   null \"  )  ;", "if    (  !  ( intf . isInterface (  )  )  )     {", "throw   new   IllegalArgumentExcep (  (  (  \" Specified   class    [  \"     +     ( intf . getName (  )  )  )     +     \"  ]    must   be   an   interface \"  )  )  ;", "}", "this . interfaces . add ( intf )  ;", "}", "METHOD_END"], "methodName": ["addInterface"], "fileName": "org.springframework.aop.support.DefaultIntroductionAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.aop.support.DefaultIntroductionAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut    =     ( pointcut    !  =    null )     ?    pointcut    :    Pointcut . TRUE ;", "}", "METHOD_END"], "methodName": ["setPointcut"], "fileName": "org.springframework.aop.support.DefaultPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   RefleUtils . accessibleConstructor ( this . defaultImplType )  . newInstance (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Cannot   create   default   implementation   for    '  \"     +     ( this . interfaceType . getName (  )  )  )     +     \"  '    mixin    (  \"  )     +     ( this . defaultImplType . getName (  )  )  )     +     \"  )  :     \"  )     +    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createNewDelegate"], "fileName": "org.springframework.aop.support.DelegatePerTargetObjectIntroductionInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   mi . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["doProceed"], "fileName": "org.springframework.aop.support.DelegatePerTargetObjectIntroductionInterceptor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . delegateMap )     {", "if    ( this . delegateMap . containsKey ( t )  )     {", "return   this . delegateMap . get ( t )  ;", "} else    {", "Object   delegate    =    createNewDelegate (  )  ;", "this . delegateMap . put ( t ,    delegate )  ;", "return   delegate ;", "}", "}", "}", "METHOD_END"], "methodName": ["getIntroductionDelegateFor"], "fileName": "org.springframework.aop.support.DelegatePerTargetObjectIntroductionInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   mi . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["doProceed"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( delegate ,     \" Delegate   must   not   be   null \"  )  ;", "this . delegate    =    delegate ;", "implementInterfacesOnObject ( delegate )  ;", "suppressInterface (  . class )  ;", "suppressInterface ( DynamicIntroductionAdvice . class )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   long   t    =     1  0  0  1 L ;", "class   Tester   implements    . ITester    ,    TimeStamped    {", "@ Override", "public   void   foo (  )    throws   Exception    {", "}", "@ Override", "public   long   getTimeStamp (  )     {", "return   t ;", "}", "}", "DelegatingIntroductionInterceptor   ii    =    new   DelegatingIntroductionInterceptor ( new   Tester (  )  )  ;", "TestBean   target    =    new   TestBean (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "pf . addAdvisor (  0  ,    new   DefaultIntroductionAdvisor ( ii )  )  ;", "TimeStamped   ts    =     (  ( TimeStamped )     ( pf . getProxy (  )  )  )  ;", "assertTrue (  (  ( ts . getTimeStamp (  )  )     =  =    t )  )  ;", "(  (  . ITester )     ( ts )  )  . foo (  )  ;", "(  ( ITestBean )     ( ts )  )  . getAge (  )  ;", "}", "METHOD_END"], "methodName": ["testAutomaticInterfaceRecognitionInDelegate"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   long   t    =     1  0  0  1 L ;", "@ SuppressWarnings (  \" serial \"  )", "class   TestII   extends   DelegatingIntroductionInterceptor   implements    . ITester    ,    TimeStamped    {", "@ Override", "public   void   foo (  )    throws   Exception    {", "}", "@ Override", "public   long   getTimeStamp (  )     {", "return   t ;", "}", "}", "DelegatingIntroductionInterceptor   ii    =    new   TestII (  )  ;", "TestBean   target    =    new   TestBean (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "IntroductionAdvisor   ia    =    new   DefaultIntroductionAdvisor ( ii )  ;", "assertTrue ( ia . isPerInstance (  )  )  ;", "pf . addAdvisor (  0  ,    ia )  ;", "TimeStamped   ts    =     (  ( TimeStamped )     ( pf . getProxy (  )  )  )  ;", "assertThat ( ts ,    instanceOf ( TimeStamped . class )  )  ;", "assertTrue (  (  !  ( ts   instanceof   MethodInterceptor )  )  )  ;", "assertTrue (  (  !  ( ts   instanceof   IntroductionInterceptor )  )  )  ;", "assertTrue (  (  ( ts . getTimeStamp (  )  )     =  =    t )  )  ;", "(  (  . ITester )     ( ts )  )  . foo (  )  ;", "(  ( ITestBean )     ( ts )  )  . getAge (  )  ;", "ii . suppressInterface ( TimeStamped . class )  ;", "pf    =    new   ProxyFactory ( target )  ;", "pf . addAdvisor (  0  ,    new   DefaultIntroductionAdvisor ( ii )  )  ;", "Object   o    =    pf . getProxy (  )  ;", "assertTrue (  (  !  ( o   instanceof   TimeStamped )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutomaticInterfaceRecognitionInSubclass"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "NestedTestBean   target    =    new   NestedTestBean (  )  ;", "String   company    =     \" Interface 2  1  \"  ;", "target . setCompany ( company )  ;", "TestBean   delegate    =    new   TestBean (  )     {", "@ Override", "public   ITestBean   getSpouse (  )     {", "return   this ;", "}", "}  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "pf . addAdvice ( new    ( delegate )  )  ;", "INestedTestBean   proxy    =     (  ( INestedTestBean )     ( pf . getProxy (  )  )  )  ;", "assertEquals ( company ,    proxy . getCompany (  )  )  ;", "ITestBean   introduction    =     (  ( ITestBean )     ( proxy )  )  ;", "assertSame (  \" Introduced   method   returning   delegate   returns   proxy \"  ,    introduction ,    introduction . getSpouse (  )  )  ;", "assertTrue (  \" Introduced   method   returning   delegate   returns   proxy \"  ,    AopUtils . isAopProxy ( introduction . getSpouse (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDelegateReturnsThisIsMassagedToReturnProxy"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   raw    =    new   TestBean (  )  ;", "assertTrue (  (  !  ( raw   instanceof   TimeStamped )  )  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( raw )  ;", "TimeStamped   ts    =    new    . SerializableTimeStamped (  0  )  ;", "factory . addAdvisor (  0  ,    new   DefaultIntroductionAdvisor ( new   DelegatingIntroductionInterceptor ( ts )     {", "@ Override", "public   String   toString (  )     {", "throw   new   UnsupportedOperationException (  \" Shouldn ' t   be   invoked \"  )  ;", "}", "}  )  )  ;", "TimeStamped   tsp    =     (  ( TimeStamped )     ( factory . getProxy (  )  )  )  ;", "assertEquals (  0  ,    tsp . getTimeStamp (  )  )  ;", "assertEquals ( raw . toString (  )  ,    tsp . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionInterceptorDoesntReplaceToString"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   raw    =    new   TestBean (  )  ;", "assertTrue (  (  !  ( raw   instanceof   TimeStamped )  )  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( raw )  ;", "TimeStamped   ts    =    mock ( TimeStamped . class )  ;", "long   timestamp    =     1  1  1 L ;", "given ( ts . getTimeStamp (  )  )  . willReturn ( timestamp )  ;", "factory . addAdvisor (  0  ,    new   DefaultIntroductionAdvisor ( new    ( ts )  )  )  ;", "TimeStamped   tsp    =     (  ( TimeStamped )     ( factory . getProxy (  )  )  )  ;", "assertTrue (  (  ( tsp . getTimeStamp (  )  )     =  =    timestamp )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionInterceptorWithDelegation"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   raw    =    new   TestBean (  )  ;", "assertTrue (  (  !  ( raw   instanceof    . SubTimeStamped )  )  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( raw )  ;", "TimeStamped   ts    =    mock (  . SubTimeStamped . class )  ;", "long   timestamp    =     1  1  1 L ;", "given ( ts . getTimeStamp (  )  )  . willReturn ( timestamp )  ;", "factory . addAdvisor (  0  ,    new   DefaultIntroductionAdvisor ( new   DelegatingIntroductionInterceptor ( ts )  ,     . SubTimeStamped . class )  )  ;", ". SubTimeStamped   tsp    =     (  (  . SubTimeStamped )     ( factory . getProxy (  )  )  )  ;", "assertTrue (  (  ( tsp . getTimeStamp (  )  )     =  =    timestamp )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionInterceptorWithInterfaceHierarchy"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   raw    =    new   TestBean (  )  ;", "assertTrue (  (  !  ( raw   instanceof   TimeStamped )  )  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( raw )  ;", "TimeStamped   ts    =    mock (  . SubTimeStamped . class )  ;", "long   timestamp    =     1  1  1 L ;", "given ( ts . getTimeStamp (  )  )  . willReturn ( timestamp )  ;", "factory . addAdvisor (  0  ,    new   DefaultIntroductionAdvisor ( new   DelegatingIntroductionInterceptor ( ts )  ,    TimeStamped . class )  )  ;", "TimeStamped   tsp    =     (  ( TimeStamped )     ( factory . getProxy (  )  )  )  ;", "assertTrue (  (  !  ( tsp   instanceof    . SubTimeStamped )  )  )  ;", "assertTrue (  (  ( tsp . getTimeStamp (  )  )     =  =    timestamp )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionInterceptorWithSuperInterface"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   long   t    =     1  0  0  1 L ;", "@ SuppressWarnings (  \" serial \"  )", "class   TestII   extends   DelegatingIntroductionInterceptor   implements   TimeStamped    {", "@ Override", "public   long   getTimeStamp (  )     {", "return   t ;", "}", "}", "DelegatingIntroductionInterceptor   ii    =    new   TestII (  )  ;", "TestBean   target    =    new    . TargetClass (  ( t    +     1  )  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "pf . addAdvisor (  0  ,    new   DefaultIntroductionAdvisor ( ii )  )  ;", "TimeStamped   ts    =     (  ( TimeStamped )     ( pf . getProxy (  )  )  )  ;", "assertTrue (  (  ( ts . getTimeStamp (  )  )     =  =    t )  )  ;", "}", "METHOD_END"], "methodName": ["testIntroductionMasksTargetImplementation"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "new   DelegatingIntroductionInterceptor ( null )  ;", "}", "METHOD_END"], "methodName": ["testNullTarget"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "SerializablePerson   serializableTarget    =    new   SerializablePerson (  )  ;", "String   name    =     \" Tony \"  ;", "serializableTarget . setName (  \" Tony \"  )  ;", "ProxyFactory   factory    =    new   ProxyFactory ( serializableTarget )  ;", "factory . addInterface ( Person . class )  ;", "long   time    =     1  0  0  0  ;", "TimeStamped   ts    =    new    . SerializableTimeStamped ( time )  ;", "factory . addAdvisor ( new   DefaultIntroductionAdvisor ( new   DelegatingIntroductionInterceptor ( ts )  )  )  ;", "factory . addAdvice ( new   SerializableNopInterceptor (  )  )  ;", "Person   p    =     (  ( Person )     ( factory . getProxy (  )  )  )  ;", "assertEquals ( name ,    p . getName (  )  )  ;", "assertEquals ( time ,     (  ( TimeStamped )     ( p )  )  . getTimeStamp (  )  )  ;", "Person   p 1     =     (  ( Person )     ( SerializationTestUtils . serializeAndDeserialize ( p )  )  )  ;", "assertEquals ( name ,    p 1  . getName (  )  )  ;", "assertEquals ( time ,     (  ( TimeStamped )     ( p 1  )  )  . getTimeStamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializableDelegatingIntroductionInterceptorSerializable"], "fileName": "org.springframework.aop.support.DelegatingIntroductionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . publishedInterfaces . addAll ( ClassUtils . getAllInterfacesAsSet ( delegate )  )  ;", "}", "METHOD_END"], "methodName": ["implementInterfacesOnObject"], "fileName": "org.springframework.aop.support.IntroductionInfoSupport"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    pubIfc    :    this . publishedInterfaces )     {", "if    (  ( ifc . isInterface (  )  )     &  &     ( ifc . isAssignableFrom ( pubIfc )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["implementsInterface"], "fileName": "org.springframework.aop.support.IntroductionInfoSupport"}, {"methodBody": ["METHOD_START", "{", "Boolean   rememberedResult    =    this . rememberedMethods . get ( mi . getMethod (  )  )  ;", "if    ( rememberedResult    !  =    null )     {", "return   rememberedResult ;", "} else    {", "boolean   result    =    implementsInterface ( mi . getMethod (  )  . getDeclaClass (  )  )  ;", "this . rememberedMethods . put ( mi . getMethod (  )  ,    result )  ;", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["isMethodOnIntroducedInterface"], "fileName": "org.springframework.aop.support.IntroductionInfoSupport"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "this . rememberedMethods    =    new   ConcurrentHashMap <  >  (  3  2  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.aop.support.IntroductionInfoSupport"}, {"methodBody": ["METHOD_START", "{", "this . publishedInterfaces . remove ( ifc )  ;", "}", "METHOD_END"], "methodName": ["suppressInterface"], "fileName": "org.springframework.aop.support.IntroductionInfoSupport"}, {"methodBody": ["METHOD_START", "{", "Pattern [  ]    destination    =    new   Pattern [ source . length ]  ;", "for    (    i    =     0  ;    i    <     ( source . length )  ;    i +  +  )     {", "destination [ i ]     =    Pattern . compile ( source [ i ]  )  ;", "}", "return   destination ;", "}", "METHOD_END"], "methodName": ["compilePatterns"], "fileName": "org.springframework.aop.support.JdkRegexpMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodMatchers . IntersectionMethodMatcher ( mm 1  ,    mm 2  )  ;", "}", "METHOD_END"], "methodName": ["intersection"], "fileName": "org.springframework.aop.support.MethodMatchers"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mm ,     \" MethodMatcher   must   not   be   null \"  )  ;", "return   mm   instanceof   IntroductionAwareMethodMatcher    ?     (  ( IntroductionAwareMethodMatcher )     ( mm )  )  . matches ( method ,    targetClass ,    hasIntroductions )     :    mm . matches ( method ,    targetClass )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.springframework.aop.support.MethodMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodMatchers . ClassFilterAwareUnionMethodMatcher ( mm 1  ,    cf 1  ,    mm 2  ,    cf 2  )  ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.springframework.aop.support.MethodMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodMatchers . UnionMethodMatcher ( mm 1  ,    mm 2  )  ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.springframework.aop.support.MethodMatchers"}, {"methodBody": ["METHOD_START", "{", "MethodMatcher   defaultMm    =    MethodMatcher . TRUE ;", "assertTrue ( defaultMm . matches ( EXCEPTION _ GETMESSAGE ,    Exception . class )  )  ;", "assertTrue ( defaultMm . matches ( ITESTBEAN _ SETAGE ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultMatchesAll"], "fileName": "org.springframework.aop.support.MethodMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MethodMatcher   mm 1     =    MethodMatcher . TRUE ;", "MethodMatcher   mm 2     =    new    . TestDynamicMethodMatcherWhichMatches (  )  ;", "MethodMatcher   intersection    =    MethodMatchers . intersection ( mm 1  ,    mm 2  )  ;", "assertTrue (  \" Intersection   is   a   dynamic   matcher \"  ,    intersection . isRuntime (  )  )  ;", "assertTrue (  \"  2 Matched   setAge   method \"  ,    intersection . matches ( ITESTBEAN _ SETAGE ,    TestBean . class )  )  ;", "assertTrue (  \"  3 Matched   setAge   method \"  ,    intersection . matches ( ITESTBEAN _ SETAGE ,    TestBean . class ,    new   Integer (  5  )  )  )  ;", "intersection    =    MethodMatchers . intersection ( intersection ,    new    . TestDynamicMethodMatcherWhichDoesNotMatch (  )  )  ;", "assertTrue (  \" Intersection   is   a   dynamic   matcher \"  ,    intersection . isRuntime (  )  )  ;", "assertTrue (  \"  2 Matched   setAge   method \"  ,    intersection . matches ( ITESTBEAN _ SETAGE ,    TestBean . class )  )  ;", "assertFalse (  \"  3     -    not   Matched   setAge   method \"  ,    intersection . matches ( ITESTBEAN _ SETAGE ,    TestBean . class ,    new   Integer (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDynamicAndStaticMethodMatcherIntersection"], "fileName": "org.springframework.aop.support.MethodMatchersTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( SerializationTestUtils . serializeAndDeserialize ( MethodMatcher . TRUE )  ,    MethodMatcher . TRUE )  ;", "}", "METHOD_END"], "methodName": ["testMethodMatcherTrueSerializable"], "fileName": "org.springframework.aop.support.MethodMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MethodMatcher   defaultMm    =    MethodMatcher . TRUE ;", "assertTrue ( defaultMm . matches ( EXCEPTION _ GETMESSAGE ,    Exception . class )  )  ;", "assertTrue ( defaultMm . matches ( ITESTBEAN _ SETAGE ,    TestBean . class )  )  ;", "defaultMm    =    MethodMatchers . intersection ( defaultMm ,    new    . StartsWithMatcher (  \" get \"  )  )  ;", "assertTrue ( defaultMm . matches ( EXCEPTION _ GETMESSAGE ,    Exception . class )  )  ;", "assertFalse ( defaultMm . matches ( ITESTBEAN _ SETAGE ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testSingle"], "fileName": "org.springframework.aop.support.MethodMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MethodMatcher   getterMatcher    =    new   MethodMatchersTests . StartsWithMatcher (  \" get \"  )  ;", "MethodMatcher   setterMatcher    =    new   MethodMatchersTests . StartsWithMatcher (  \" set \"  )  ;", "MethodMatcher   union    =    MethodMatchers . union ( getterMatcher ,    setterMatcher )  ;", "assertFalse (  \" Union   is   a   static   matcher \"  ,    union . isRuntime (  )  )  ;", "assertTrue (  \" Matched   setAge   method \"  ,    union . matches ( ITESTBEAN _ SETAGE ,    TestBean . class )  )  ;", "assertTrue (  \" Matched   getAge   method \"  ,    union . matches ( ITESTBEAN _ GETAGE ,    TestBean . class )  )  ;", "assertFalse (  \" Didn ' t   matched   absquatulate   method \"  ,    union . matches ( IOTHER _ ABSQUATULATE ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticMethodMatcherUnion"], "fileName": "org.springframework.aop.support.MethodMatchersTests"}, {"methodBody": ["METHOD_START", "{", "MethodMatcher   first    =    MethodMatchers . union ( MethodMatcher . TRUE ,    MethodMatcher . TRUE )  ;", "MethodMatcher   second    =    new   ComposablePointcut ( MethodMatcher . TRUE )  . union ( new   ComposablePointcut ( MethodMatcher . TRUE )  )  . getMethodMatcher (  )  ;", "assertTrue ( first . equals ( second )  )  ;", "assertTrue ( second . equals ( first )  )  ;", "}", "METHOD_END"], "methodName": ["testUnionEquals"], "fileName": "org.springframework.aop.support.MethodMatchersTests"}, {"methodBody": ["METHOD_START", "{", "this . mappedNames . add ( name )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addMethodName"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "return   PatternMatchUtils . simpleMatch ( mappedName ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["isMatch"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "setMappedNames ( mappedName )  ;", "}", "METHOD_END"], "methodName": ["setMappedName"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "this . mappedNames    =    new   LinkedList <  >  (  )  ;", "if    ( mappedNames    !  =    null )     {", "this . mappedNames . addAll ( Arrays . asList ( mappedNames )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setMappedNames"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcut"}, {"methodBody": ["METHOD_START", "{", "return   this . pointcut . addMethodName ( name )  ;", "}", "METHOD_END"], "methodName": ["addMethodName"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setClassFilter ( classFilter )  ;", "}", "METHOD_END"], "methodName": ["setClassFilter"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setMappedName ( mappedName )  ;", "}", "METHOD_END"], "methodName": ["setMappedName"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setMappedNames ( mappedNames )  ;", "}", "METHOD_END"], "methodName": ["setMappedNames"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   pf    =    new   ProxyFactory ( new   SerializablePerson (  )  )  ;", "nop    =    new   SerializableNopInterceptor (  )  ;", "pc    =    new    (  )  ;", "pf . addAdvisor ( new   DefaultPointcutAdvisor ( pc ,    nop )  )  ;", "proxied    =     (  ( Person )     ( pf . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "proxied . get (  )  ;", "proxied . set (  \"  \"  )  ;", "proxied . echo ( null )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmpty"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "NameMatchMethodPointcut   pc 1     =    new   NameMatchMethodPointcut (  )  ;", "NameMatchMethodPointcut   pc 2     =    new   NameMatchMethodPointcut (  )  ;", "String   foo    =     \" foo \"  ;", "assertEquals ( pc 1  ,    pc 2  )  ;", "assertEquals ( pc 1  . hashCode (  )  ,    pc 2  . hashCode (  )  )  ;", "pc 1  . setMappedName ( foo )  ;", "assertFalse ( pc 1  . equals ( pc 2  )  )  ;", "assertTrue (  (  ( pc 1  . hashCode (  )  )     !  =     ( pc 2  . hashCode (  )  )  )  )  ;", "pc 2  . setMappedName ( foo )  ;", "assertEquals ( pc 1  ,    pc 2  )  ;", "assertEquals ( pc 1  . hashCode (  )  ,    pc 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEqualsAndHashCode"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "pc . addMethodName (  \" echo \"  )  ;", "pc . addMethodName (  \" set *  \"  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "proxied . getName (  )  ;", "proxied . getName (  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "proxied . echo ( null )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "proxied . setName (  \"  \"  )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "proxied . setAge (  2  5  )  ;", "assertEquals (  2  5  ,    proxied . getAge (  )  )  ;", "assertEquals (  3  ,    nop . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchOneMethod"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( pc . isMatch (  \" echo \"  ,     \" ech *  \"  )  )  ;", "assertTrue ( pc . isMatch (  \" setName \"  ,     \" setN *  \"  )  )  ;", "assertTrue ( pc . isMatch (  \" setName \"  ,     \" set *  \"  )  )  ;", "assertFalse ( pc . isMatch (  \" getName \"  ,     \" set *  \"  )  )  ;", "assertFalse ( pc . isMatch (  \" setName \"  ,     \" set \"  )  )  ;", "assertTrue ( pc . isMatch (  \" testing \"  ,     \"  * ing \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchingOnly"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "testSets (  )  ;", "Person   p 2     =     (  ( Person )     ( SerializationUtils . serializeAndDeserialize ( proxied )  )  )  ;", "NopInterceptor   nop 2     =     (  ( NopInterceptor )     (  (  ( Advised )     ( p 2  )  )  . getAdvisors (  )  [  0  ]  . getAdvice (  )  )  )  ;", "p 2  . getName (  )  ;", "assertEquals (  2  ,    nop 2  . getCount (  )  )  ;", "p 2  . echo ( null )  ;", "assertEquals (  3  ,    nop 2  . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializable"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "pc . setMappedNames ( new   String [  ]  {     \" set *  \"  ,     \" echo \"     }  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "proxied . getName (  )  ;", "proxied . setName (  \"  \"  )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "proxied . echo ( null )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSets"], "fileName": "org.springframework.aop.support.NameMatchMethodPointcutTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ComposablePointcut ( pc 1  )  . intersection ( pc 2  )  ;", "}", "METHOD_END"], "methodName": ["intersection"], "fileName": "org.springframework.aop.support.Pointcuts"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( pointcut ,     \" Pointcut   must   not   be   null \"  )  ;", "if    ( pointcut    =  =     ( Pointcut . TRUE )  )     {", "return   true ;", "}", "if    ( pointcut . getClassFilter (  )  . matches ( targetClass )  )     {", "MethodMatcher   mm    =    pointcut . getMethodMatcher (  )  ;", "if    ( mm . matches ( method ,    targetClass )  )     {", "return    (  !  ( mm . isRuntime (  )  )  )     |  |     ( mm . matches ( method ,    targetClass ,    args )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.springframework.aop.support.Pointcuts"}, {"methodBody": ["METHOD_START", "{", "return   new   ComposablePointcut ( pc 1  )  . union ( pc 2  )  ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.springframework.aop.support.Pointcuts"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( Pointcuts . matches ( PointcutsTests . allClassGetAgePointcut ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( PointcutsTests . allClassGetAgePointcut ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    PointcutsTests . MyTestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( PointcutsTests . myTestBeanGetterPointcut ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( PointcutsTests . myTestBeanGetterPointcut ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( PointcutsTests . myTestBeanGetterPointcut ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    PointcutsTests . MyTestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( PointcutsTests . myTestBeanGetterPointcut ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    PointcutsTests . MyTestBean . class )  )  ;", "Pointcut   intersection    =    Pointcuts . intersection ( PointcutsTests . allClassGetAgePointcut ,    PointcutsTests . myTestBeanGetterPointcut )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    PointcutsTests . MyTestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    PointcutsTests . MyTestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    PointcutsTests . MyTestBeanSubclass . class )  )  ;", "assertTrue ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    PointcutsTests . MyTestBeanSubclass . class )  )  ;", "intersection    =    Pointcuts . intersection ( intersection ,    PointcutsTests . myTestBeanSubclassGetterPointcut )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    PointcutsTests . MyTestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    PointcutsTests . MyTestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    PointcutsTests . MyTestBeanSubclass . class )  )  ;", "assertTrue ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    PointcutsTests . MyTestBeanSubclass . class )  )  ;", "Pointcut   union    =    Pointcuts . union ( intersection ,    PointcutsTests . allTestBeanMethodsPointcut )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    PointcutsTests . MyTestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    PointcutsTests . MyTestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    PointcutsTests . MyTestBeanSubclass . class )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    PointcutsTests . MyTestBeanSubclass . class )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    PointcutsTests . MyTestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIntersectionOfSpecificGettersAndSubclassGetters"], "fileName": "org.springframework.aop.support.PointcutsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( Pointcuts . matches ( PointcutsTests . allClassSetterPointcut ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "assertFalse ( Pointcuts . matches ( PointcutsTests . allClassSetterPointcut ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( PointcutsTests . allClassSetterPointcut ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( PointcutsTests . allClassGetterPointcut ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "assertTrue ( Pointcuts . matches ( PointcutsTests . allClassGetterPointcut ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( PointcutsTests . allClassGetterPointcut ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testMatches"], "fileName": "org.springframework.aop.support.PointcutsTests"}, {"methodBody": ["METHOD_START", "{", "Pointcut   intersection    =    Pointcuts . intersection ( PointcutsTests . allClassGetterPointcut ,    PointcutsTests . allClassSetterPointcut )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( intersection ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleIntersection"], "fileName": "org.springframework.aop.support.PointcutsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( Pointcuts . matches ( Pointcut . TRUE ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "assertTrue ( Pointcuts . matches ( Pointcut . TRUE ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( Pointcut . TRUE ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( Pointcut . TRUE ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "assertTrue ( Pointcuts . matches ( Pointcut . TRUE ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( Pointcut . TRUE ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testTrue"], "fileName": "org.springframework.aop.support.PointcutsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( Pointcuts . matches ( PointcutsTests . myTestBeanSetterPointcut ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "assertTrue ( Pointcuts . matches ( PointcutsTests . myTestBeanSetterPointcut ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    PointcutsTests . MyTestBean . class ,    new   Integer (  6  )  )  )  ;", "assertFalse ( Pointcuts . matches ( PointcutsTests . myTestBeanSetterPointcut ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "Pointcut   union    =    Pointcuts . union ( PointcutsTests . myTestBeanSetterPointcut ,    PointcutsTests . allClassGetterPointcut )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    PointcutsTests . MyTestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    PointcutsTests . MyTestBean . class ,    new   Integer (  6  )  )  )  ;", "assertFalse ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnionOfAllSettersAndSubclassSetters"], "fileName": "org.springframework.aop.support.PointcutsTests"}, {"methodBody": ["METHOD_START", "{", "Pointcut   union    =    Pointcuts . union ( PointcutsTests . allClassGetterPointcut ,    PointcutsTests . allClassSetterPointcut )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testUnionOfSettersAndGetters"], "fileName": "org.springframework.aop.support.PointcutsTests"}, {"methodBody": ["METHOD_START", "{", "Pointcut   union    =    Pointcuts . union ( PointcutsTests . allClassGetAgePointcut ,    PointcutsTests . allClassGetNamePointcut )  ;", "assertFalse ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( PointcutsTests . allClassGetAgePointcut ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "union    =    Pointcuts . union ( union ,    PointcutsTests . allClassSetterPointcut )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ AGE ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( PointcutsTests . allClassGetAgePointcut ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ GET _ NAME ,    TestBean . class )  )  ;", "assertFalse ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ ABSQUATULATE ,    TestBean . class )  )  ;", "assertTrue ( Pointcuts . matches ( union ,    PointcutsTests . TEST _ BEAN _ SET _ AGE ,    TestBean . class ,    new   Integer (  6  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnionOfSpecificGetters"], "fileName": "org.springframework.aop.support.PointcutsTests"}, {"methodBody": ["METHOD_START", "{", "return   new   JdkRegexpMethodPointcut (  )  ;", "}", "METHOD_END"], "methodName": ["createPointcut"], "fileName": "org.springframework.aop.support.RegexpMethodPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "setPatterns ( pattern )  ;", "}", "METHOD_END"], "methodName": ["setPattern"], "fileName": "org.springframework.aop.support.RegexpMethodPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . patterns    =    patterns ;", "}", "METHOD_END"], "methodName": ["setPatterns"], "fileName": "org.springframework.aop.support.RegexpMethodPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . CONTEXT )  ;", "TestBean   advised    =     (  ( TestBean )     ( bf . getBean (  \" settersAndAbsquatulateAdvised \"  )  )  )  ;", "NopInterceptor   nop    =     (  ( NopInterceptor )     ( bf . getBean (  \" nopInterceptor \"  )  )  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "int   newAge    =     1  2  ;", "advised . exceptional ( null )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "advised . absquatulate (  )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "advised . setAge ( newAge )  ;", "assertEquals ( newAge ,    advised . getAge (  )  )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiplePatterns"], "fileName": "org.springframework.aop.support.RegexpMethodPointcutAdvisorIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . CONTEXT )  ;", "Person   p    =     (  ( Person )     ( bf . getBean (  \" serializableSettersAdvised \"  )  )  )  ;", "NopInterceptor   nop    =     (  ( NopInterceptor )     ( bf . getBean (  \" nopInterceptor \"  )  )  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "int   newAge    =     1  2  ;", "assertEquals (  0  ,    p . getAge (  )  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "p . setAge ( newAge )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "p . setAge ( newAge )  ;", "assertEquals ( newAge ,    p . getAge (  )  )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "p    =     (  ( Person )     ( SerializationTestUtils . serializeAndDeserialize ( p )  )  )  ;", "assertEquals ( newAge ,    p . getAge (  )  )  ;", "nop    =     (  ( SerializableNopInterceptor )     (  (  ( Advised )     ( p )  )  . getAdvisors (  )  [  0  ]  . getAdvice (  )  )  )  ;", "assertEquals (  2  ,    nop . getCount (  )  )  ;", "assertEquals (  \" serializableSettersAdvised \"  ,    p . getName (  )  )  ;", "p . setAge (  ( newAge    +     1  )  )  ;", "assertEquals (  3  ,    nop . getCount (  )  )  ;", "assertEquals (  ( newAge    +     1  )  ,    p . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerialization"], "fileName": "org.springframework.aop.support.RegexpMethodPointcutAdvisorIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . CONTEXT )  ;", "ITestBean   advised    =     (  ( ITestBean )     ( bf . getBean (  \" settersAdvised \"  )  )  )  ;", "NopInterceptor   nop    =     (  ( NopInterceptor )     ( bf . getBean (  \" nopInterceptor \"  )  )  )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "int   newAge    =     1  2  ;", "advised . exceptional ( null )  ;", "assertEquals (  0  ,    nop . getCount (  )  )  ;", "advised . setAge ( newAge )  ;", "assertEquals ( newAge ,    advised . getAge (  )  )  ;", "assertEquals (  1  ,    nop . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSinglePattern"], "fileName": "org.springframework.aop.support.RegexpMethodPointcutAdvisorIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . classFilter    =    classFilter ;", "}", "METHOD_END"], "methodName": ["setClassFilter"], "fileName": "org.springframework.aop.support.StaticMethodMatcherPointcut"}, {"methodBody": ["METHOD_START", "{", "this . advice    =    advice ;", "}", "METHOD_END"], "methodName": ["setAdvice"], "fileName": "org.springframework.aop.support.StaticMethodMatcherPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.aop.support.StaticMethodMatcherPointcutAdvisor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( annotationType ,     \" Annotation   type   must   not   be   null \"  )  ;", "return   new    ( annotationType )  ;", "}", "METHOD_END"], "methodName": ["forClassAnnotation"], "fileName": "org.springframework.aop.support.annotation.AnnotationMatchingPointcut"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( annotationType ,     \" Annotation   type   must   not   be   null \"  )  ;", "return   new    ( null ,    annotationType )  ;", "}", "METHOD_END"], "methodName": ["forMethodAnnotation"], "fileName": "org.springframework.aop.support.annotation.AnnotationMatchingPointcut"}, {"methodBody": ["METHOD_START", "{", "return   this . checkInherited    ?     ( AnnotationUtils . findAnnotation ( method ,    this . annotationType )  )     !  =    null    :    method . isAnnotationPresent ( this . annotationType )  ;", "}", "METHOD_END"], "methodName": ["matchesMethod"], "fileName": "org.springframework.aop.support.annotation.AnnotationMethodMatcher"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanName    =    other . targetBeanName ;", "this . targetClass    =    other . targetClass ;", "this . b    =    other . b ;", "}", "METHOD_END"], "methodName": ["copyFrom"], "fileName": "org.springframework.aop.target.AbstractBeanFactoryBasedTargetSource"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.aop.target.AbstractBeanFactoryBasedTargetSource"}, {"methodBody": ["METHOD_START", "{", "return   this . targetBeanName ;", "}", "METHOD_END"], "methodName": ["getTargetBeanName"], "fileName": "org.springframework.aop.target.AbstractBeanFactoryBasedTargetSource"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanName    =    targetBeanName ;", "}", "METHOD_END"], "methodName": ["setTargetBeanName"], "fileName": "org.springframework.aop.target.AbstractBeanFactoryBasedTargetSource"}, {"methodBody": ["METHOD_START", "{", "this . targetClass    =    targetClass ;", "}", "METHOD_END"], "methodName": ["setTargetClass"], "fileName": "org.springframework.aop.target.AbstractBeanFactoryBasedTargetSource"}, {"methodBody": ["METHOD_START", "{", "return    ( this . lazyTarget )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isInitialized"], "fileName": "org.springframework.aop.target.AbstractLazyCreationTargetSource"}, {"methodBody": ["METHOD_START", "{", "DelegatingIntroductionInterceptor   dii    =    new   DelegatingIntroductionInterceptor ( this )  ;", "return   new   DefaultIntroductionAdvisor ( dii ,    Config . class )  ;", "}", "METHOD_END"], "methodName": ["getPoolingConfigMixin"], "fileName": "org.springframework.aop.target.AbstractPoolingTargetSource"}, {"methodBody": ["METHOD_START", "{", "this . maxSize    =    maxSize ;", "}", "METHOD_END"], "methodName": ["setMaxSize"], "fileName": "org.springframework.aop.target.AbstractPoolingTargetSource"}, {"methodBody": ["METHOD_START", "{", "if    ( this . logger . isDebugEnabled (  )  )     {", "this . logger . debug (  (  (  \" Destroying   instance   of   bean    '  \"     +     ( getTargetBeanName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "if    (  ( getBeanFactory (  )  )    instanceof   ConfigurableBeanFactory )     {", "(  ( ConfigurableBeanFactory )     ( getBeanFactory (  )  )  )  . destroyBean ( getTargetBeanName (  )  ,    target )  ;", "} else", "if    ( target   instanceof   beans . factory . DisposableBean )     {", "try    {", "(  ( beans . factory . DisposableBean )     ( target )  )  . destroy (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . error (  (  (  \" Couldn ' t   invoke   destroy   method   of   bean   with   name    '  \"     +     ( getTargetBeanName (  )  )  )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["destroyPrototypeInstance"], "fileName": "org.springframework.aop.target.AbstractPrototypeBasedTargetSource"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Creating   new   instance   of   bean    '  \"     +     ( getBeanName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "return   getBeanFactory (  )  . getBean ( getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["newPrototypeInstance"], "fileName": "org.springframework.aop.target.AbstractPrototypeBasedTargetSource"}, {"methodBody": ["METHOD_START", "{", "throw   new   NotSerializableException (  (  \" A   prototype - based   TargetSource   itself   is   not   deserializable    -     \"     +     \" just   a   disconnected   SingletonTargetSource   or   EmptyTargetSource   is \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.aop.target.AbstractPrototypeBasedTargetSource"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Disconnecting       [  \"     +     ( this )  )     +     \"  ]  \"  )  )  ;", "}", "try    {", "Object   target    =    getTarget (  )  ;", "return   target    !  =    null    ?    new   Singleton ( target )     :    Empty . forClass ( getTargetClass (  )  )  ;", "}    catch    ( Exception   ex )     {", "String   msg    =     (  \" Cannot   get   target   for   disconnecting       [  \"     +     ( this )  )     +     \"  ]  \"  ;", "logger . error ( msg ,    ex )  ;", "throw   new   NotSerializableException (  (  ( msg    +     \"  :     \"  )     +    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeReplace"], "fileName": "org.springframework.aop.target.AbstractPrototypeBasedTargetSource"}, {"methodBody": ["METHOD_START", "{", "GenericObjectPoolConfig   config    =    new   GenericObjectPoolConfig (  )  ;", "config . setMaxTotal ( getMaxSize (  )  )  ;", "config . setMaxIdle ( getMaxIdle (  )  )  ;", "config . setMinIdle ( getMinIdle (  )  )  ;", "config . setMaxWaitMillis ( getMaxWait (  )  )  ;", "config . setTimeBetweenEvictionRunsMillis ( getTimeBetweenEvictionRunsMillis (  )  )  ;", "config . setMinEvictableIdleTimeMillis ( getMinEvictableIdleTimeMillis (  )  )  ;", "config . setBlockWhenExhausted ( isBlockWhenExhausted (  )  )  ;", "return   new   GenericObjectPool ( this ,    config )  ;", "}", "METHOD_END"], "methodName": ["createObjectPool"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "return   this . maxIdle ;", "}", "METHOD_END"], "methodName": ["getMaxIdle"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "return   this . maxWait ;", "}", "METHOD_END"], "methodName": ["getMaxWait"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "return   this . minEvictableIdleTimeMillis ;", "}", "METHOD_END"], "methodName": ["getMinEvictableIdleTimeMillis"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "return   this . minIdle ;", "}", "METHOD_END"], "methodName": ["getMinIdle"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "return   this . timeBetweenEvictionRunsMillis ;", "}", "METHOD_END"], "methodName": ["getTimeBetweenEvictionRunsMillis"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "return   this . blockWhenExhausted ;", "}", "METHOD_END"], "methodName": ["isBlockWhenExhausted"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "this . blockWhenExhausted    =    blockWhenExhausted ;", "}", "METHOD_END"], "methodName": ["setBlockWhenExhausted"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "this . maxIdle    =    maxIdle ;", "}", "METHOD_END"], "methodName": ["setMaxIdle"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "this . maxWait    =    maxWait ;", "}", "METHOD_END"], "methodName": ["setMaxWait"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "this . minEvictableIdleTimeMillis    =    minEvictableIdleTimeMillis ;", "}", "METHOD_END"], "methodName": ["setMinEvictableIdleTimeMillis"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "this . minIdle    =    minIdle ;", "}", "METHOD_END"], "methodName": ["setMinIdle"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "this . timeBetweenEvictionRunsMillis    =    timeBetweenEvictionRunsMillis ;", "}", "METHOD_END"], "methodName": ["setTimeBetweenEvictionRunsMillis"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSource"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( beanFactory )  ;", "reader . loadBeanDefinitions (  . CONTEXT )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "ITestBean   bean    =     (  ( ITestBean )     ( beanFactory . getBean (  \" testBean \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( bean )  )  ;", "}", "METHOD_END"], "methodName": ["testProxy"], "fileName": "org.springframework.aop.target.CommonsPool2TargetSourceProxyTests"}, {"methodBody": ["METHOD_START", "{", "return   EmptyTargetSource . forClass ( targetClass ,    true )  ;", "}", "METHOD_END"], "methodName": ["forClass"], "fileName": "org.springframework.aop.target.EmptyTargetSource"}, {"methodBody": ["METHOD_START", "{", "return    ( targetClass    =  =    null )     &  &    isStatic    ?    EmptyTargetSource . INSTANCE    :    new   EmptyTargetSource ( targetClass ,    isStatic )  ;", "}", "METHOD_END"], "methodName": ["forClass"], "fileName": "org.springframework.aop.target.EmptyTargetSource"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . targetClass )     =  =    null )     &  &     ( this . isStatic )     ?    EmptyTargetSource . INSTANCE    :    this ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.springframework.aop.target.EmptyTargetSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( newTarget ,     \" Target   object   must   not   be   null \"  )  ;", "Object   old    =    this ;", "this    =    newTarget ;", "return   old ;", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "org.springframework.aop.target.HotSwappableTargetSource"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( this . beanFactory )  . loadBeanDefinitions (  . CONTEXT )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.target.HotSwappableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.aop.target.HotSwappableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "SideEffectBean   proxied    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" swappable \"  )  )  )  ;", "assertEquals (  . INITIAL _ COUNT ,    proxied . getCount (  )  )  ;", "proxied . doWork (  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     1  )  ,    proxied . getCount (  )  )  ;", "proxied    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" swappable \"  )  )  )  ;", "proxied . doWork (  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     2  )  ,    proxied . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBasicFunctionality"], "fileName": "org.springframework.aop.target.HotSwappableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "HotSwappableTargetSource   swapper    =     (  ( HotSwappableTargetSource )     ( beanFactory . getBean (  \" swapper \"  )  )  )  ;", "IllegalArgumentException   aopex    =    null ;", "try    {", "swapper . swap ( invalid )  ;", "fail (  (  (  \" Shouldn ' t   be   able   to   swap   to   invalid   value    [  \"     +    invalid )     +     \"  ]  \"  )  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "aopex    =    ex ;", "}", "testBasicFunctionality (  )  ;", "return   aopex ;", "}", "METHOD_END"], "methodName": ["testRejectsSwapToInvalidValue"], "fileName": "org.springframework.aop.target.HotSwappableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "IllegalArgumentException   ex    =    testRejectsSwapToInvalidValue ( null )  ;", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" null \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRejectsSwapToNull"], "fileName": "org.springframework.aop.target.HotSwappableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "SerializablePerson   sp 1     =    new   SerializablePerson (  )  ;", "sp 1  . setName (  \" Tony \"  )  ;", "SerializablePerson   sp 2     =    new   SerializablePerson (  )  ;", "sp 1  . setName (  \" Gordon \"  )  ;", "hts    =    new    ( sp 1  )  ;", "ProxyFactory   pf    =    new   ProxyFactory (  )  ;", "pf . addInterface ( Person . class )  ;", "pf . setTargetSource ( hts )  ;", "pf . addAdvisor ( new   DefaultPointcutAdvisor ( new   SerializableNopInterceptor (  )  )  )  ;", "Person   p    =     (  ( Person )     ( pf . getProxy (  )  )  )  ;", "assertEquals ( sp 1  . getName (  )  ,    p . getName (  )  )  ;", "hts . swap ( sp 2  )  ;", "assertEquals ( sp 2  . getName (  )  ,    p . getName (  )  )  ;", "p    =     (  ( Person )     ( SerializationTestUtils . serializeAndDeserialize ( p )  )  )  ;", "hts    =     (  (  )     (  (  ( Advised )     ( p )  )  . getTargetSource (  )  )  )  ;", "assertEquals ( sp 2  . getName (  )  ,    p . getName (  )  )  ;", "hts . swap ( sp 1  )  ;", "assertEquals ( sp 1  . getName (  )  ,    p . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerialization"], "fileName": "org.springframework.aop.target.HotSwappableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "SideEffectBean   target 1     =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" target 1  \"  )  )  )  ;", "SideEffectBean   target 2     =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" target 2  \"  )  )  )  ;", "SideEffectBean   proxied    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" swappable \"  )  )  )  ;", "assertEquals ( target 1  . getCount (  )  ,    proxied . getCount (  )  )  ;", "proxied . doWork (  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     1  )  ,    proxied . getCount (  )  )  ;", "HotSwappableTargetSource   swapper    =     (  ( HotSwappableTargetSource )     ( beanFactory . getBean (  \" swapper \"  )  )  )  ;", "Object   old    =    swapper . swap ( target 2  )  ;", "assertEquals (  \" Correct   old   target   was   returned \"  ,    target 1  ,    old )  ;", "assertEquals (  2  0  ,    proxied . getCount (  )  )  ;", "proxied . doWork (  )  ;", "assertEquals (  2  1  ,    target 2  . getCount (  )  )  ;", "swapper . swap ( target 1  )  ;", "assertEquals ( target 1  . getCount (  )  ,    proxied . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidSwaps"], "fileName": "org.springframework.aop.target.HotSwappableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "TargetSource   targetSource    =    new   AbstractLazyCreationTargetSource (  )     {", "@ Override", "protected   Object   createObject (  )     {", "return   new    . InitCountingBean (  )  ;", "}", "@ Override", "public   Class <  ?  >    getTargetClass (  )     {", "return    . InitCountingBean . class ;", "}", "}  ;", ". InitCountingBean   proxy    =     (  (  . InitCountingBean )     ( ProxyFactory . getProxy ( targetSource )  )  )  ;", "assertEquals (  \" Init   count   should   be    0  \"  ,     0  ,     . InitCountingBean . initCount )  ;", "assertEquals (  \" Target   class   incorrect \"  ,     . InitCountingBean . class ,    targetSource . getTargetClass (  )  )  ;", "assertEquals (  \" Init   count   should   still   be    0    after   getTargetClass (  )  \"  ,     0  ,     . InitCountingBean . initCount )  ;", "proxy . doSomething (  )  ;", "assertEquals (  \" Init   count   should   now   be    1  \"  ,     1  ,     . InitCountingBean . initCount )  ;", "proxy . doSomething (  )  ;", "assertEquals (  \" Init   count   should   still   be    1  \"  ,     1  ,     . InitCountingBean . initCount )  ;", "}", "METHOD_END"], "methodName": ["testCreateLazy"], "fileName": "org.springframework.aop.target.LazyCreationTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . CUSTOM _ TARGET _ CONTEXT )  ;", "bf . preInstantiateSingletons (  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" proxy \"  )  )  )  ;", "assertFalse ( bf . containsSingleton (  \" target \"  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    tb . getName (  )  )  ;", "assertTrue ( bf . containsSingleton (  \" target \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomLazyInitSingletonTargetSource"], "fileName": "org.springframework.aop.target.LazyInitTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . FACTORY _ BEAN _ CONTEXT )  ;", "bf . preInstantiateSingletons (  )  ;", "Set <  ?  >    set 1     =     (  ( Set <  ?  >  )     ( bf . getBean (  \" proxy 1  \"  )  )  )  ;", "assertFalse ( bf . containsSingleton (  \" target 1  \"  )  )  ;", "assertTrue ( set 1  . contains (  \"  1  0  \"  )  )  ;", "assertTrue ( bf . containsSingleton (  \" target 1  \"  )  )  ;", "Set <  ?  >    set 2     =     (  ( Set <  ?  >  )     ( bf . getBean (  \" proxy 2  \"  )  )  )  ;", "assertFalse ( bf . containsSingleton (  \" target 2  \"  )  )  ;", "assertTrue ( set 2  . contains (  \"  2  0  \"  )  )  ;", "assertTrue ( bf . containsSingleton (  \" target 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLazyInitFactoryBeanTargetSource"], "fileName": "org.springframework.aop.target.LazyInitTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . SINGLETON _ CONTEXT )  ;", "bf . preInstantiateSingletons (  )  ;", "ITestBean   tb    =     (  ( ITestBean )     ( bf . getBean (  \" proxy \"  )  )  )  ;", "assertFalse ( bf . containsSingleton (  \" target \"  )  )  ;", "assertEquals (  1  0  ,    tb . getAge (  )  )  ;", "assertTrue ( bf . containsSingleton (  \" target \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLazyInitSingletonTargetSource"], "fileName": "org.springframework.aop.target.LazyInitTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   tsPvs    =    new   MutablePropertyValues (  )  ;", "tsPvs . add (  \" targetBeanName \"  ,     \" person \"  )  ;", "RootBeanDefinition   tsBd    =    new   RootBeanDefinition (  . TestTargetSource . class )  ;", "tsBd . setPropertyValues ( tsPvs )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( SerializablePerson . class )  ;", "bd . setPropertyValues ( pvs )  ;", "bd . setScope ( SCOPE _ PROTOTYPE )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" ts \"  ,    tsBd )  ;", "bf . registerBeanDefinition (  \" person \"  ,    bd )  ;", ". TestTargetSource   cpts    =     (  (  . TestTargetSource )     ( bf . getBean (  \" ts \"  )  )  )  ;", "TargetSource   serialized    =     (  ( TargetSource )     ( SerializationTestUtils . serializeAndDeserialize ( cpts )  )  )  ;", "assertTrue (  \" Changed   to   SingletonTargetSource   on   deserialization \"  ,     ( serialized   instanceof   SingletonTargetSource )  )  ;", "SingletonTargetSource   sts    =     (  ( SingletonTargetSource )     ( serialized )  )  ;", "assertNotNull ( sts . getTarget (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSerializability"], "fileName": "org.springframework.aop.target.PrototypeBasedTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader (  (  ( BeanDefinitionRegistry )     ( this . beanFactory )  )  )  . loadBeanDefinitions (  . CONTEXT )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.target.PrototypeTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "SideEffectBean   singleton    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" singleton \"  )  )  )  ;", "assertEquals (  . INITIAL _ COUNT ,    singleton . getCount (  )  )  ;", "singleton . doWork (  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     1  )  ,    singleton . getCount (  )  )  ;", "SideEffectBean   prototype    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" prototype \"  )  )  )  ;", "assertEquals (  . INITIAL _ COUNT ,    prototype . getCount (  )  )  ;", "prototype . doWork (  )  ;", "assertEquals (  . INITIAL _ COUNT ,    prototype . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeAndSingletonBehaveDifferently"], "fileName": "org.springframework.aop.target.PrototypeTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "DelegatingIntroductionInterceptor   dii    =    new   DelegatingIntroductionInterceptor ( this )  ;", "return   new   DefaultIntroductionAdvisor ( dii ,    Stats . class )  ;", "}", "METHOD_END"], "methodName": ["getStatsMixin"], "fileName": "org.springframework.aop.target.ThreadLocalTargetSource"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( this . beanFactory )  . loadBeanDefinitions (  . CONTEXT )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.aop.target.ThreadLocalTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.aop.target.ThreadLocalTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "ThreadLocalTargetSourceStats   stats    =     (  ( ThreadLocalTargetSourceStats )     ( beanFactory . getBean (  \" apartment \"  )  )  )  ;", "assertEquals (  1  ,    stats . getInvocationCount (  )  )  ;", "SideEffectBean   apartment    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" apartment \"  )  )  )  ;", "apartment . doWork (  )  ;", "assertEquals (  3  ,    stats . getInvocationCount (  )  )  ;", "assertEquals (  3  ,    stats . getHitCount (  )  )  ;", "apartment . doWork (  )  ;", "assertEquals (  6  ,    stats . getInvocationCount (  )  )  ;", "assertEquals (  6  ,    stats . getHitCount (  )  )  ;", "assertEquals (  1  ,    stats . getObjectCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanGetStatsViaMixin"], "fileName": "org.springframework.aop.target.ThreadLocalTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "SideEffectBean   apartment    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" apartment \"  )  )  )  ;", "assertEquals (  . INITIAL _ COUNT ,    apartment . getCount (  )  )  ;", "apartment . doWork (  )  ;", "apartment . doWork (  )  ;", "apartment . doWork (  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     3  )  ,    apartment . getCount (  )  )  ;", "class   Runner   implements   Runnable    {", "public   SideEffectBean   mine ;", "@ Override", "public   void   run (  )     {", "this . mine    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" apartment \"  )  )  )  ;", "assertEquals (  . INITIAL _ COUNT ,    mine . getCount (  )  )  ;", "mine . doWork (  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     1  )  ,    mine . getCount (  )  )  ;", "}", "}", "Runner   r    =    new   Runner (  )  ;", "Thread   t    =    new   Thread ( r )  ;", "t . start (  )  ;", "t . join (  )  ;", "assertNotNull ( r )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     3  )  ,    apartment . getCount (  )  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     3  )  ,    r . mine . getCount (  )  )  ;", "assertEquals (  2  ,     (  ( ThreadLocalTargetSourceStats )     ( apartment )  )  . getObjectCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNewThreadHasOwnInstance"], "fileName": "org.springframework.aop.target.ThreadLocalTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "ThreadLocalTargetSource   source    =     (  ( ThreadLocalTargetSource )     ( this . beanFactory . getBean (  \" threadLocalTs \"  )  )  )  ;", "source . getTarget (  )  ;", "source . destroy (  )  ;", "try    {", "source . getTarget (  )  ;", "}    catch    ( NullPointerException   ex )     {", "fail (  \" Should   not   throw   NPE \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testReuseDestroyedTarget"], "fileName": "org.springframework.aop.target.ThreadLocalTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "SideEffectBean   apartment    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" apartment \"  )  )  )  ;", "assertEquals (  . INITIAL _ COUNT ,    apartment . getCount (  )  )  ;", "apartment . doWork (  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     1  )  ,    apartment . getCount (  )  )  ;", "apartment    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" apartment \"  )  )  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     1  )  ,    apartment . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReuseInSameThread"], "fileName": "org.springframework.aop.target.ThreadLocalTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "SideEffectBean   apartment    =     (  ( SideEffectBean )     ( beanFactory . getBean (  \" apartment \"  )  )  )  ;", "assertEquals (  . INITIAL _ COUNT ,    apartment . getCount (  )  )  ;", "apartment . doWork (  )  ;", "assertEquals (  (  (  . INITIAL _ COUNT )     +     1  )  ,    apartment . getCount (  )  )  ;", "ITestBean   test    =     (  ( ITestBean )     ( beanFactory . getBean (  \" threadLocal 2  \"  )  )  )  ;", "assertEquals (  \" Rod \"  ,    test . getName (  )  )  ;", "assertEquals (  \" Kerry \"  ,    test . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUseDifferentManagedInstancesInSameThread"], "fileName": "org.springframework.aop.target.ThreadLocalTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . refreshCheckDelay )     <     0  )     {", "return   false ;", "}", "long   currentTimeMillis    =    System . currentTimeMillis (  )  ;", "if    (  (  ( this . lasCheck )     <     0  )     |  |     (  ( currentTimeMillis    -     ( this . lasCheck )  )     >     ( this . refreshCheckDelay )  )  )     {", "this . lasCheck    =    currentTimeMillis ;", "logger . debug (  \" Refresh   check   delay   elapsed    -    checking   whether   refresh   is   required \"  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["refreshCheckDelayElapsed"], "fileName": "org.springframework.aop.target.dynamic.AbstractRefreshableTargetSource"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["requiresRefresh"], "fileName": "org.springframework.aop.target.dynamic.AbstractRefreshableTargetSource"}, {"methodBody": ["METHOD_START", "{", "this . refreshCheckDelay    =    refreshCheckDelay ;", "}", "METHOD_END"], "methodName": ["setRefreshCheckDelay"], "fileName": "org.springframework.aop.target.dynamic.AbstractRefreshableTargetSource"}, {"methodBody": ["METHOD_START", "{", "return   beanFactory . getBean ( beanName )  ;", "}", "METHOD_END"], "methodName": ["obtainFreshBean"], "fileName": "org.springframework.aop.target.dynamic.BeanFactoryRefreshableTargetSource"}, {"methodBody": ["METHOD_START", "{", "RefreshableTargetSourceTests . CountingRefreshableTargetSource   ts    =    new   RefreshableTargetSourceTests . CountingRefreshableTargetSource (  )  ;", "ts . setRefreshCheckDelay (  0  )  ;", "Object   a    =    ts . getTarget (  )  ;", "Thread . sleep (  1  )  ;", "Object   b    =    ts . getTarget (  )  ;", "assertEquals (  \" Should   be   one   call   to   freshTarget   to   get   initial   target \"  ,     1  ,    ts . getCallCount (  )  )  ;", "assertSame (  \" Returned   objects   should   be   the   same    -    no   refresh   should   occur \"  ,    a ,    b )  ;", "}", "METHOD_END"], "methodName": ["testRefreshCheckWithNonRefresh"], "fileName": "org.springframework.aop.target.dynamic.RefreshableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "RefreshableTargetSourceTests . CountingRefreshableTargetSource   ts    =    new   RefreshableTargetSourceTests . CountingRefreshableTargetSource ( true )  ;", "ts . setRefreshCheckDelay (  0  )  ;", "Object   a    =    ts . getTarget (  )  ;", "Thread . sleep (  1  0  0  )  ;", "Object   b    =    ts . getTarget (  )  ;", "assertEquals (  \" Should   have   called   freshTarget   twice \"  ,     2  ,    ts . getCallCount (  )  )  ;", "assertNotSame (  \" Should   be   different   objects \"  ,    a ,    b )  ;", "}", "METHOD_END"], "methodName": ["testRefreshCheckWithRefresh"], "fileName": "org.springframework.aop.target.dynamic.RefreshableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", ". CountingRefreshableTargetSource   ts    =    new    . CountingRefreshableTargetSource ( true )  ;", "ts . setRefreshCheckDelay (  1  0  0  )  ;", "Object   a    =    ts . getTarget (  )  ;", "Object   b    =    ts . getTarget (  )  ;", "assertEquals (  \" Objects   should   be   same \"  ,    a ,    b )  ;", "Thread . sleep (  5  0  )  ;", "Object   c    =    ts . getTarget (  )  ;", "assertEquals (  \" A   and   C   should   be   same \"  ,    a ,    c )  ;", "Thread . sleep (  6  0  )  ;", "Object   d    =    ts . getTarget (  )  ;", "assertNotNull (  \" D   should   not   be   null \"  ,    d )  ;", "assertFalse (  \" A   and   D   should   not   be   equal \"  ,    a . equals ( d )  )  ;", "Object   e    =    ts . getTarget (  )  ;", "assertEquals (  \" D   and   E   should   be   equal \"  ,    d ,    e )  ;", "Thread . sleep (  1  1  0  )  ;", "Object   f    =    ts . getTarget (  )  ;", "assertFalse (  \" E   and   F   should   be   different \"  ,    e . equals ( f )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshOverTime"], "fileName": "org.springframework.aop.target.dynamic.RefreshableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "RefreshableTargetSourceTests . CountingRefreshableTargetSource   ts    =    new   RefreshableTargetSourceTests . CountingRefreshableTargetSource ( true )  ;", "ts . setRefreshCheckDelay (  (  -  1  )  )  ;", "Object   a    =    ts . getTarget (  )  ;", "Object   b    =    ts . getTarget (  )  ;", "assertEquals (  \" Refresh   target   should   only   be   called   once \"  ,     1  ,    ts . getCallCount (  )  )  ;", "assertSame (  \" Objects   should   be   the   same    -    refresh   check   delay   not   elapsed \"  ,    a ,    b )  ;", "}", "METHOD_END"], "methodName": ["testWithNoRefreshCheck"], "fileName": "org.springframework.aop.target.dynamic.RefreshableTargetSourceTests"}, {"methodBody": ["METHOD_START", "{", "Integer   i    =    map . get ( methodName )  ;", "i    =     ( i    !  =    null )     ?    new   Integer (  (  ( i . intValue (  )  )     +     1  )  )     :    new   Integer (  1  )  ;", "map . put ( methodName ,    i )  ;", "+  +  ( allCount )  ;", "}", "METHOD_END"], "methodName": ["count"], "fileName": "org.springframework.tests.aop.advice.MethodCounter"}, {"methodBody": ["METHOD_START", "{", "count ( m . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["count"], "fileName": "org.springframework.tests.aop.advice.MethodCounter"}, {"methodBody": ["METHOD_START", "{", "return   allCount ;", "}", "METHOD_END"], "methodName": ["getCalls"], "fileName": "org.springframework.tests.aop.advice.MethodCounter"}, {"methodBody": ["METHOD_START", "{", "Integer   i    =    map . get ( methodName )  ;", "return   i    !  =    null    ?    i . intValue (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getCalls"], "fileName": "org.springframework.tests.aop.advice.MethodCounter"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Shouldn ' t   be   called \"  )  ;", "}", "METHOD_END"], "methodName": ["afterThrowing"], "fileName": "org.springframework.tests.aop.advice.MyThrowsHandler"}, {"methodBody": ["METHOD_START", "{", "count (  \" ioException \"  )  ;", "}", "METHOD_END"], "methodName": ["afterThrowing"], "fileName": "org.springframework.tests.aop.advice.MyThrowsHandler"}, {"methodBody": ["METHOD_START", "{", "count (  \" remoteException \"  )  ;", "}", "METHOD_END"], "methodName": ["afterThrowing"], "fileName": "org.springframework.tests.aop.advice.MyThrowsHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.tests.aop.interceptor.NopInterceptor"}, {"methodBody": ["METHOD_START", "{", "( this . count )  +  +  ;", "}", "METHOD_END"], "methodName": ["increment"], "fileName": "org.springframework.tests.aop.interceptor.NopInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . ts    =    ts ;", "}", "METHOD_END"], "methodName": ["setTime"], "fileName": "org.springframework.tests.aop.interceptor.TimestampIntroductionInterceptor"}, {"methodBody": ["METHOD_START", "{", "+  +  ( count )  ;", "}", "METHOD_END"], "methodName": ["countSetter"], "fileName": "test.aop.PerTargetAspect"}, {"methodBody": ["METHOD_START", "{", "return    ( count )  +  +  ;", "}", "METHOD_END"], "methodName": ["returnCountAsAge"], "fileName": "test.aop.PerTargetAspect"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "test.aop.PerTargetAspect"}, {"methodBody": ["METHOD_START", "{", "return    ( invocations )  +  +  ;", "}", "METHOD_END"], "methodName": ["changeAge"], "fileName": "test.aop.PerThisAspect"}, {"methodBody": ["METHOD_START", "{", "return   this . invocations ;", "}", "METHOD_END"], "methodName": ["getInvocations"], "fileName": "test.aop.PerThisAspect"}, {"methodBody": ["METHOD_START", "{", "+  +  ( totalCalls )  ;", "}", "METHOD_END"], "methodName": ["countSet"], "fileName": "test.aop.TwoAdviceAspect"}, {"methodBody": ["METHOD_START", "{", "return   totalCalls ;", "}", "METHOD_END"], "methodName": ["returnCallCount"], "fileName": "test.aop.TwoAdviceAspect"}]