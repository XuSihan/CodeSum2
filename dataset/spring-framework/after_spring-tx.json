[{"methodBody": ["METHOD_START", "{", "return   this . actualSize ;", "}", "METHOD_END"], "methodName": ["getActualSize"], "fileName": "org.springframework.dao.IncorrectResultSizeDataAccessException"}, {"methodBody": ["METHOD_START", "{", "return   this . expectedSize ;", "}", "METHOD_END"], "methodName": ["getExpectedSize"], "fileName": "org.springframework.dao.IncorrectResultSizeDataAccessException"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["wasDataUpdated"], "fileName": "org.springframework.dao.IncorrectUpdateSemanticsDataAccessException"}, {"methodBody": ["METHOD_START", "{", "pf . addAdvisor ( new   PersistenceExceptionTranslationAdvisor ( pet ,    Repository . class )  )  ;", "}", "METHOD_END"], "methodName": ["addPersistenceExceptionTranslation"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "DataAccessUtilsTests . MapPersistenceExceptionTranslator   mpet    =    new   DataAccessUtilsTests . MapPersistenceExceptionTranslator (  )  ;", "mpet . addTranslation ( persistenceException 1  ,    new   InvalidDataAccessApiUsageException (  \"  \"  ,    persistenceException 1  )  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( target )  ;", "pf . addInterface (  . RepositoryInterface . class )  ;", "addPersistenceExceptionTranslation ( pf ,    mpet )  ;", "return    (  (  . RepositoryInterface )     ( pf . getProxy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createProxy"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "PersistenceExceptionTranslationAdvisorTests . RepositoryInterface   ri    =    createProxy ( target )  ;", "target . setBehavior ( persistenceException 1  )  ;", "try    {", "ri . noThrowsClause (  )  ;", "fail (  )  ;", "}    catch    ( DataAccessException   ex )     {", "assertSame ( persistenceException 1  ,    ex . getCause (  )  )  ;", "}    catch    ( PersistenceException   ex )     {", "fail (  \" Should   have   been   translated \"  )  ;", "}", "try    {", "ri . throwsPersistenceException (  )  ;", "fail (  )  ;", "}    catch    ( PersistenceException   ex )     {", "assertSame ( persistenceException 1  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestTranslationNeededForTheseExceptions"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "PersistenceExceptionTranslationAdvisorTests . RepositoryInterfaceImpl   target    =    new   PersistenceExceptionTranslationAdvisorTests . RepositoryInterfaceImpl (  )  ;", "PersistenceExceptionTranslationAdvisorTests . RepositoryInterface   ri    =    createProxy ( target )  ;", "ri . noThrowsClause (  )  ;", "ri . throwsPersistenceException (  )  ;", "target . setBehavior ( persistenceException 1  )  ;", "try    {", "ri . noThrowsClause (  )  ;", "fail (  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertSame ( persistenceException 1  ,    ex )  ;", "}", "try    {", "ri . throwsPersistenceException (  )  ;", "fail (  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertSame ( persistenceException 1  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["noTranslationNeeded"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "doTestTranslationNeededForTheseExceptions ( new   PersistenceExceptionTranslationAdvisorTests . StereotypedRepositoryInterfaceImpl (  )  )  ;", "}", "METHOD_END"], "methodName": ["translationNeededForTheseExceptions"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "doTestTranslationNeededForTheseExceptions ( new   PersistenceExceptionTranslationAdvisorTests . MyInterfaceInheritedStereotypedRepositoryInterfaceImpl (  )  )  ;", "}", "METHOD_END"], "methodName": ["translationNeededForTheseExceptionsOnInheritedInterface"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "doTestTranslationNeededForTheseExceptions ( new   PersistenceExceptionTranslationAdvisorTests . MyInterfaceStereotypedRepositoryInterfaceImpl (  )  )  ;", "}", "METHOD_END"], "methodName": ["translationNeededForTheseExceptionsOnInterface"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "doTestTranslationNeededForTheseExceptions ( new   PersistenceExceptionTranslationAdvisorTests . MyStereotypedRepositoryInterfaceImpl (  )  )  ;", "}", "METHOD_END"], "methodName": ["translationNeededForTheseExceptionsOnSuperclass"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "doTestTranslationNeededForTheseExceptions ( new   PersistenceExceptionTranslationAdvisorTests . CustomStereotypedRepositoryInterfaceImpl (  )  )  ;", "}", "METHOD_END"], "methodName": ["translationNeededForTheseExceptionsWithCustomStereotype"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "PersistenceExceptionTranslationAdvisorTests . RepositoryInterfaceImpl   target    =    new   PersistenceExceptionTranslationAdvisorTests . StereotypedRepositoryInterfaceImpl (  )  ;", "PersistenceExceptionTranslationAdvisorTests . RepositoryInterface   ri    =    createProxy ( target )  ;", "ri . noThrowsClause (  )  ;", "ri . throwsPersistenceException (  )  ;", "target . setBehavior ( doNotTranslate )  ;", "try    {", "ri . noThrowsClause (  )  ;", "fail (  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertSame ( doNotTranslate ,    ex )  ;", "}", "try    {", "ri . throwsPersistenceException (  )  ;", "fail (  )  ;", "}    catch    ( RuntimeException   ex )     {", "assertSame ( doNotTranslate ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["translationNotNeededForTheseExceptions"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( repositoryAnnotationType ,     \"  ' repositoryAnnotationType '    must   not   be   null \"  )  ;", "this . repositoryAnnotationType    =    repositoryAnnotationType ;", "}", "METHOD_END"], "methodName": ["setRepositoryAnnotationType"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  ( o   instanceof   Advised )  )  ;", "Advised   a    =     (  ( Advised )     ( o )  )  ;", "for    ( Advisor   advisor    :    a . getAdvisors (  )  )     {", "if    ( advisor   instanceof   Advisor )     {", "return ;", "}", "}", "fail (  \" No   translation \"  )  ;", "}", "METHOD_END"], "methodName": ["checkWillTranslateExceptions"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   gac    =    new   GenericApplicationContext (  )  ;", "gac . registerBeanDefinition (  \" translator \"  ,    new   RootBeanDefinition ( PersistenceExceptionTranslationPostProcessor . class )  )  ;", "gac . registerBeanDefinition (  \" notProxied \"  ,    new   RootBeanDefinition ( PersistenceExceptionTranslationAdvisorTests . RepositoryInterfaceImpl . class )  )  ;", "gac . registerBeanDefinition (  \" proxied \"  ,    new   RootBeanDefinition ( PersistenceExceptionTranslationAdvisorTests . StereotypedRepositoryInterfaceImpl . class )  )  ;", "gac . registerBeanDefinition (  \" classProxied \"  ,    new   RootBeanDefinition (  . RepositoryWithoutInterface . class )  )  ;", "gac . registerBeanDefinition (  \" classProxiedAndAdvised \"  ,    new   RootBeanDefinition (  . RepositoryWithoutInterfaceAndOtherwiseAdvised . class )  )  ;", "gac . registerBeanDefinition (  \" myTranslator \"  ,    new   RootBeanDefinition (  . MyPersistenceExceptionTranslator . class )  )  ;", "gac . registerBeanDefinition (  \" proxyCreator \"  ,    BeanDefinitionBuilder . rootBeanDefinition ( AnnotationAwareAspectJAutoProxyCreator . class )  . addPropertyValue (  \" order \"  ,     5  0  )  . getBeanDefinition (  )  )  ;", "gac . registerBeanDefinition (  \" logger \"  ,    new   RootBeanDefinition (  . LogAllAspect . class )  )  ;", "gac . refresh (  )  ;", "PersistenceExceptionTranslationAdvisorTests . RepositoryInterface   shouldNotBeProxied    =     (  ( PersistenceExceptionTranslationAdvisorTests . RepositoryInterface )     ( gac . getBean (  \" notProxied \"  )  )  )  ;", "assertFalse ( AopUtils . isAopProxy ( shouldNotBeProxied )  )  ;", "PersistenceExceptionTranslationAdvisorTests . RepositoryInterface   shouldBeProxied    =     (  ( PersistenceExceptionTranslationAdvisorTests . RepositoryInterface )     ( gac . getBean (  \" proxied \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( shouldBeProxied )  )  ;", ". RepositoryWithoutInterface   rwi    =     (  (  . RepositoryWithoutInterface )     ( gac . getBean (  \" classProxied \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( rwi )  )  ;", "checkWillTranslateExceptions ( rwi )  ;", ". Additional   rwi 2     =     (  (  . Additional )     ( gac . getBean (  \" classProxiedAndAdvised \"  )  )  )  ;", "assertTrue ( AopUtils . isAopProxy ( rwi 2  )  )  ;", "rwi 2  . additionalMethod ( false )  ;", "checkWillTranslateExceptions ( rwi 2  )  ;", "try    {", "rwi 2  . additionalMethod ( true )  ;", "fail (  \" Should   have   thrown   DataAccessResourceFailureException \"  )  ;", "}    catch    ( DataAccessResourceFailureException   ex )     {", "assertEquals (  \" my   failure \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["proxiesCorrectly"], "fileName": "org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( pet ,     \" PersistenceExceptionTranslator   must   not   be   null \"  )  ;", "this . delegates . add ( pet )  ;", "}", "METHOD_END"], "methodName": ["addDelegate"], "fileName": "org.springframework.dao.support.ChainedPersistenceExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "return   this . delegates . toArray ( new   PersistenceExceptionTranslator [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getDelegates"], "fileName": "org.springframework.dao.support.ChainedPersistenceExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "ChainedPersistenceExceptionTranslator   pet    =    new   ChainedPersistenceExceptionTranslator (  )  ;", "RuntimeException   in    =    new   RuntimeException (  \" in \"  )  ;", "assertSame ( in ,    DataAccessUtils . translateIfNecessary ( in ,    pet )  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.springframework.dao.support.ChainedPersistenceExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "DataAccessUtilsTests . MapPersistenceExceptionTranslator   mpet 1     =    new   DataAccessUtilsTests . MapPersistenceExceptionTranslator (  )  ;", "RuntimeException   in 1     =    new   RuntimeException (  \" in \"  )  ;", "InvalidDataAccessApiUsageException   out 1     =    new   InvalidDataAccessApiUsageException (  \" out \"  )  ;", "InvalidDataAccessApiUsageException   out 2     =    new   InvalidDataAccessApiUsageException (  \" out \"  )  ;", "mpet 1  . addTranslation ( in 1  ,    out 1  )  ;", "chainedPet 1     =    new    (  )  ;", "assertSame (  \" Should   not   translate   yet \"  ,    in 1  ,    DataAccessUtils . translateIfNecessary ( in 1  ,    chainedPet 1  )  )  ;", "chainedPet 1  . addDelegate ( mpet 1  )  ;", "assertSame (  \" Should   now   translate \"  ,    out 1  ,    DataAccessUtils . translateIfNecessary ( in 1  ,    chainedPet 1  )  )  ;", "DataAccessUtilsTests . MapPersistenceExceptionTranslator   mpet 2     =    new   DataAccessUtilsTests . MapPersistenceExceptionTranslator (  )  ;", "mpet 2  . addTranslation ( in 1  ,    out 2  )  ;", "chainedPet 1  . addDelegate ( mpet 2  )  ;", "assertSame (  \" Should   still   translate   the   same   due   to   ordering \"  ,    out 1  ,    DataAccessUtils . translateIfNecessary ( in 1  ,    chainedPet 1  )  )  ;", "chainedPet 2     =    new    (  )  ;", "chainedPet 2  . addDelegate ( mpet 2  )  ;", "chainedPet 2  . addDelegate ( mpet 1  )  ;", "assertSame (  \" Should   translate   differently   due   to   ordering \"  ,    out 2  ,    DataAccessUtils . translateIfNecessary ( in 1  ,    chainedPet 2  )  )  ;", "RuntimeException   in 2     =    new   RuntimeException (  \" in 2  \"  )  ;", "OptimisticLockingFailureException   out 3     =    new   OptimisticLockingFailureException (  \" out 2  \"  )  ;", "assertNull ( chainedPet 2  . translateExceptionIfPossible ( in 2  )  )  ;", "DataAccessUtilsTests . MapPersistenceExceptionTranslator   mpet 3     =    new   DataAccessUtilsTests . MapPersistenceExceptionTranslator (  )  ;", "mpet 3  . addTranslation ( in 2  ,    out 3  )  ;", "chainedPet 2  . addDelegate ( mpet 3  )  ;", "assertSame ( out 3  ,    chainedPet 2  . translateExceptionIfPossible ( in 2  )  )  ;", "}", "METHOD_END"], "methodName": ["exceptionTranslationWithTranslation"], "fileName": "org.springframework.dao.support.ChainedPersistenceExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "return   DataAccessUtils . objectResult ( results ,    Number . class )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["intResult"], "fileName": "org.springframework.dao.support.DataAccessUtils"}, {"methodBody": ["METHOD_START", "{", "return   DataAccessUtils . objectResult ( results ,    Number . class )  . longValue (  )  ;", "}", "METHOD_END"], "methodName": ["longResult"], "fileName": "org.springframework.dao.support.DataAccessUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( results )  )     {", "throw   new   EmptyResultException (  1  )  ;", "}", "if    (  ( results . size (  )  )     >     1  )     {", "throw   new   IncorrectResultSizeException (  1  ,    results . size (  )  )  ;", "}", "return   results . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["nullableSingleResult"], "fileName": "org.springframework.dao.support.DataAccessUtils"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    DataAccessUtils . requiredUniqueResult ( results )  ;", "if    (  ( requiredType    !  =    null )     &  &     (  !  ( requiredType . isInstance ( result )  )  )  )     {", "if    (  ( String . class )     =  =    requiredType )     {", "result    =    result . toString (  )  ;", "} else", "if    (  ( Number . class . isAssignableFrom ( requiredType )  )     &  &     ( Number . class . isInstance ( result )  )  )     {", "try    {", "result    =    convertNumberToTargetClass (  (  ( Number )     ( result )  )  ,     (  ( Class <  ?    extends   Number >  )     ( requiredType )  )  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   TypeMismatchDataAccessException ( ex . getMessage (  )  )  ;", "}", "} else    {", "throw   new   TypeMismatchDataAccessException (  (  (  (  (  \" Result   object   is   of   type    [  \"     +     ( result . getClass (  )  . getName (  )  )  )     +     \"  ]    and   could   not   be   converted   to   required   type    [  \"  )     +     ( requiredType . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "return    (  ( T )     ( result )  )  ;", "}", "METHOD_END"], "methodName": ["objectResult"], "fileName": "org.springframework.dao.support.DataAccessUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( results )  )     {", "throw   new   EmptyResultException (  1  )  ;", "}", "if    (  ( results . size (  )  )     >     1  )     {", "throw   new   IncorrectResultSizeException (  1  ,    results . size (  )  )  ;", "}", "return   results . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["requiredSingleResult"], "fileName": "org.springframework.dao.support.DataAccessUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( results )  )     {", "throw   new   EmptyResultException (  1  )  ;", "}", "if    (  !  ( CollectionUtils . hasUniqueObject ( results )  )  )     {", "throw   new   IncorrectResultSizeException (  1  ,    results . size (  )  )  ;", "}", "return   results . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["requiredUniqueResult"], "fileName": "org.springframework.dao.support.DataAccessUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( results )  )     {", "return   null ;", "}", "if    (  ( results . size (  )  )     >     1  )     {", "throw   new   IncorrectResultSizeException (  1  ,    results . size (  )  )  ;", "}", "return   results . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["singleResult"], "fileName": "org.springframework.dao.support.DataAccessUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( pet ,     \" PersistenceExceptionTranslator   must   not   be   null \"  )  ;", "Exception   dex    =    pet . translateExceptionIfPossible ( rawException )  ;", "return   dex    !  =    null    ?    dex    :    rawException ;", "}", "METHOD_END"], "methodName": ["translateIfNecessary"], "fileName": "org.springframework.dao.support.DataAccessUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( results )  )     {", "return   null ;", "}", "if    (  !  ( CollectionUtils . hasUniqueObject ( results )  )  )     {", "throw   new   IncorrectResultSizeException (  1  ,    results . size (  )  )  ;", "}", "return   results . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["uniqueResult"], "fileName": "org.springframework.dao.support.DataAccessUtils"}, {"methodBody": ["METHOD_START", "{", "DataAccessUtilsTests . MapPersistenceExceptionTranslator   mpet    =    new   DataAccessUtilsTests . MapPersistenceExceptionTranslator (  )  ;", "RuntimeException   in    =    new   RuntimeException (  )  ;", "assertSame ( in ,    DataAccessUtils . translateIfNecessary ( in ,    mpet )  )  ;", "}", "METHOD_END"], "methodName": ["exceptionTranslationWithNoTranslation"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataAccessUtilsTests . MapPersistenceExceptionTranslator   mpet    =    new   DataAccessUtilsTests . MapPersistenceExceptionTranslator (  )  ;", "RuntimeException   in    =    new   RuntimeException (  \" in \"  )  ;", "InvalidDataAccessApiUsageException   out    =    new   InvalidDataAccessApiUsageException (  \" out \"  )  ;", "mpet . addTranslation ( in ,    out )  ;", "assertSame ( out ,    DataAccessUtils . translateIfNecessary ( in ,    mpet )  )  ;", "}", "METHOD_END"], "methodName": ["exceptionTranslationWithTranslation"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Date   date    =    new   Date (  )  ;", "Collection < Date >    col    =    new   HashSet <  >  (  1  )  ;", "col . add ( date )  ;", "assertEquals ( date ,     . uniqueResult ( col )  )  ;", "assertEquals ( date ,     . requiredUniqueResult ( col )  )  ;", "assertEquals ( date ,     . objectResult ( col ,    Date . class )  )  ;", "assertEquals ( date . toString (  )  ,     . objectResult ( col ,    String . class )  )  ;", "try    {", ". intResult ( col )  ;", "fail (  \" Should   have   thrown   TypeMismatchDataAccessException \"  )  ;", "}    catch    ( TypeMismatchDataAccessException   ex )     {", "}", "try    {", ". longResult ( col )  ;", "fail (  \" Should   have   thrown   TypeMismatchDataAccessException \"  )  ;", "}    catch    ( TypeMismatchDataAccessException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["withDate"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    col    =    new   HashSet <  >  (  )  ;", "assertNull (  . uniqueResult ( col )  )  ;", "try    {", ". requiredUniqueResult ( col )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  0  ,    ex . getActualSize (  )  )  ;", "}", "try    {", ". objectResult ( col ,    String . class )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  0  ,    ex . getActualSize (  )  )  ;", "}", "try    {", ". intResult ( col )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  0  ,    ex . getActualSize (  )  )  ;", "}", "try    {", ". longResult ( col )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  0  ,    ex . getActualSize (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["withEmptyCollection"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Collection < Integer >    col    =    new   ArrayList <  >  (  2  )  ;", "col . add ( new   Integer (  5  )  )  ;", "col . add ( new   Integer (  5  )  )  ;", "try    {", ". uniqueResult ( col )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  2  ,    ex . getActualSize (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["withEquivalentIntegerInstanceTwice"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Collection < Integer >    col    =    new   HashSet <  >  (  1  )  ;", "col . add (  5  )  ;", "assertEquals ( Integer . valueOf (  5  )  ,     . uniqueResult ( col )  )  ;", "assertEquals ( Integer . valueOf (  5  )  ,     . requiredUniqueResult ( col )  )  ;", "assertEquals ( Integer . valueOf (  5  )  ,     . objectResult ( col ,    Integer . class )  )  ;", "assertEquals (  \"  5  \"  ,     . objectResult ( col ,    String . class )  )  ;", "assertEquals (  5  ,     . intResult ( col )  )  ;", "assertEquals (  5  ,     . longResult ( col )  )  ;", "}", "METHOD_END"], "methodName": ["withInteger"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Collection < Long >    col    =    new   HashSet <  >  (  1  )  ;", "col . add (  5 L )  ;", "assertEquals ( Long . valueOf (  5 L )  ,     . uniqueResult ( col )  )  ;", "assertEquals ( Long . valueOf (  5 L )  ,     . requiredUniqueResult ( col )  )  ;", "assertEquals ( Long . valueOf (  5 L )  ,     . objectResult ( col ,    Long . class )  )  ;", "assertEquals (  \"  5  \"  ,     . objectResult ( col ,    String . class )  )  ;", "assertEquals (  5  ,     . intResult ( col )  )  ;", "assertEquals (  5  ,     . longResult ( col )  )  ;", "}", "METHOD_END"], "methodName": ["withLong"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Integer   i    =     5  ;", "Collection < Integer >    col    =    new   ArrayList <  >  (  1  )  ;", "col . add ( i )  ;", "col . add ( i )  ;", "assertEquals ( Integer . valueOf (  5  )  ,     . uniqueResult ( col )  )  ;", "assertEquals ( Integer . valueOf (  5  )  ,     . requiredUniqueResult ( col )  )  ;", "assertEquals ( Integer . valueOf (  5  )  ,     . objectResult ( col ,    Integer . class )  )  ;", "assertEquals (  \"  5  \"  ,     . objectResult ( col ,    String . class )  )  ;", "assertEquals (  5  ,     . intResult ( col )  )  ;", "assertEquals (  5  ,     . longResult ( col )  )  ;", "}", "METHOD_END"], "methodName": ["withSameIntegerInstanceTwice"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    col    =    new   HashSet <  >  (  1  )  ;", "col . add (  \" test 1  \"  )  ;", "assertEquals (  \" test 1  \"  ,     . uniqueResult ( col )  )  ;", "assertEquals (  \" test 1  \"  ,     . requiredUniqueResult ( col )  )  ;", "assertEquals (  \" test 1  \"  ,     . objectResult ( col ,    String . class )  )  ;", "try    {", ". intResult ( col )  ;", "fail (  \" Should   have   thrown   TypeMismatchDataAccessException \"  )  ;", "}    catch    ( TypeMismatchDataAccessException   ex )     {", "}", "try    {", ". longResult ( col )  ;", "fail (  \" Should   have   thrown   TypeMismatchDataAccessException \"  )  ;", "}    catch    ( TypeMismatchDataAccessException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["withString"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    col    =    new   HashSet <  >  (  2  )  ;", "col . add (  \" test 1  \"  )  ;", "col . add (  \" test 2  \"  )  ;", "try    {", ". uniqueResult ( col )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  2  ,    ex . getActualSize (  )  )  ;", "}", "try    {", ". requiredUniqueResult ( col )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  2  ,    ex . getActualSize (  )  )  ;", "}", "try    {", ". objectResult ( col ,    String . class )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  2  ,    ex . getActualSize (  )  )  ;", "}", "try    {", ". intResult ( col )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  2  ,    ex . getActualSize (  )  )  ;", "}", "try    {", ". longResult ( col )  ;", "fail (  \" Should   have   thrown   IncorrectResultSizeDataAccessException \"  )  ;", "}    catch    ( IncorrectResultSizeDataAccessException   ex )     {", "assertEquals (  1  ,    ex . getExpectedSize (  )  )  ;", "assertEquals (  2  ,    ex . getActualSize (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["withTooLargeCollection"], "fileName": "org.springframework.dao.support.DataAccessUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    PersistenceExceptionTranslator >    pets    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( beanFactory ,    PersistenceExceptionTranslator . class ,    false ,    false )  ;", "ChainedPersistenceExceptionTranslator   cpet    =    new   ChainedPersistenceExceptionTranslator (  )  ;", "for    ( PersistenceExceptionTranslator   pet    :    pets . values (  )  )     {", "cpet . addDelegate ( pet )  ;", "}", "return   cpet ;", "}", "METHOD_END"], "methodName": ["detectPersistenceExceptionTranslators"], "fileName": "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . alwaysTranslate    =    alwaysTranslate ;", "}", "METHOD_END"], "methodName": ["setAlwaysTranslate"], "fileName": "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor"}, {"methodBody": ["METHOD_START", "{", "this . persistenceExceptionTranslator    =    pet ;", "}", "METHOD_END"], "methodName": ["setPersistenceExceptionTranslator"], "fileName": "org.springframework.dao.support.PersistenceExceptionTranslationInterceptor"}, {"methodBody": ["METHOD_START", "{", "final   ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "LocalTransaction   localTransaction    =    mock ( LocalTransaction . class )  ;", "final   Record   record    =    mock ( Record . class )  ;", "final   InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . getLocalTransaction (  )  )  . willReturn ( localTransaction )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    record ,    record )  )  . willReturn ( true )  ;", "given ( connection . getLocalTransaction (  )  )  . willReturn ( localTransaction )  ;", "Manager   tm    =    new   Manager (  )  ;", "tm . setConnectionFactory ( connectionFactory )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( connectionFactory )  )  ;", "CciTemplate   ct    =    new   CciTemplate ( connectionFactory )  ;", "ct . execute ( interactionSpec ,    record ,    record )  ;", "}", "}  )  ;", "verify ( localTransaction )  . begin (  )  ;", "verify ( interaction )  . close (  )  ;", "verify ( localTransaction )  . commit (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testLocalTransactionCommit"], "fileName": "org.springframework.jca.cci.CciLocalTransactionTests"}, {"methodBody": ["METHOD_START", "{", "final   ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "LocalTransaction   localTransaction    =    mock ( LocalTransaction . class )  ;", "final   Record   record    =    mock ( Record . class )  ;", "final   InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . getLocalTransaction (  )  )  . willReturn ( localTransaction )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    record ,    record )  )  . willReturn ( true )  ;", "given ( connection . getLocalTransaction (  )  )  . willReturn ( localTransaction )  ;", "Manager   tm    =    new   Manager (  )  ;", "tm . setConnectionFactory ( connectionFactory )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "try    {", "tt . execute ( new   TransactionCallback < Void >  (  )     {", "@ Override", "public   Void   doInTransaction ( TransactionStatus   status )     {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( connectionFactory )  )  ;", "CciTemplate   ct    =    new   CciTemplate ( connectionFactory )  ;", "ct . execute ( interactionSpec ,    record ,    record )  ;", "throw   new   DataRetrievalFailureException (  \" error \"  )  ;", "}", "}  )  ;", "}    catch    ( Exception   ex )     {", "}", "verify ( localTransaction )  . begin (  )  ;", "verify ( interaction )  . close (  )  ;", "verify ( localTransaction )  . rollback (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testLocalTransactionRollback"], "fileName": "org.springframework.jca.cci.CciLocalTransactionTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "IndexedRecord   indexedRecord    =    mock ( IndexedRecord . class )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( recordFactory . createIndexedRecord (  \" name \"  )  )  . willReturn ( indexedRecord )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . createIndexedRecord (  \" name \"  )  ;", "verify ( recordFactory )  . createIndexedRecord (  \" name \"  )  ;", "}", "METHOD_END"], "methodName": ["testCreateIndexedRecord"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "MappedRecord   mappedRecord    =    mock ( MappedRecord . class )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( recordFactory . createMappedRecord (  \" name \"  )  )  . willReturn ( mappedRecord )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . createMappedRecord (  \" name \"  )  ;", "verify ( recordFactory )  . createMappedRecord (  \" name \"  )  ;", "}", "METHOD_END"], "methodName": ["testCreateMappedRecord"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "ConnectionCallback < Object >    connectionCallback    =    mock ( ConnectionCallback . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connectionCallback . doInConnection ( connection ,    connectionFactory )  )  . willReturn ( new   Object (  )  )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . execute ( connectionCallback )  ;", "verify ( connectionCallback )  . doInConnection ( connection ,    connectionFactory )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteConnectionCallback"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordExtractor < Object >    extractor    =    mock ( RecordExtractor . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord )  )  . willReturn ( outputRecord )  ;", "given ( extractor . extractData ( outputRecord )  )  . willReturn ( new   Object (  )  )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . execute ( interactionSpec ,    inputRecord ,    extractor )  ;", "verify ( extractor )  . extractData ( outputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputExtractorFalse"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordExtractor < Object >    extractor    =    mock ( RecordExtractor . class )  ;", "RecordCreator   creator    =    mock ( RecordCreator . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( creator . createRecord ( recordFactory )  )  . willReturn ( outputRecord )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord ,    outputRecord )  )  . willReturn ( true )  ;", "given ( extractor . extractData ( outputRecord )  )  . willReturn ( new   Object (  )  )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . setOutputRecordCreator ( creator )  ;", "ct . execute ( interactionSpec ,    inputRecord ,    extractor )  ;", "verify ( extractor )  . extractData ( outputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputExtractorTrueWithCreator"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord )  )  . willReturn ( outputRecord )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . execute ( interactionSpec ,    inputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputFalse"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   inputOutputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputOutputRecord )  )  . willReturn ( null )  ;", "ct    =    new    ( connectionFactory )  ;", "Record   tmpOutputRecord    =    ct . execute ( interactionSpec ,    inputOutputRecord )  ;", "assertNull ( tmpOutputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputOutputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputFalseTrue"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordCreator   generator    =    mock ( RecordCreator . class )  ;", "RecordExtractor < Object >    extractor    =    mock ( RecordExtractor . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( generator . createRecord ( recordFactory )  )  . willReturn ( inputRecord )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord )  )  . willReturn ( outputRecord )  ;", "given ( extractor . extractData ( outputRecord )  )  . willReturn ( new   Object (  )  )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . execute ( interactionSpec ,    generator ,    extractor )  ;", "verify ( extractor )  . extractData ( outputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputGeneratorExtractorFalse"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordCreator   generator    =    mock ( RecordCreator . class )  ;", "RecordExtractor < Object >    extractor    =    mock ( RecordExtractor . class )  ;", "RecordCreator   creator    =    mock ( RecordCreator . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "Object   obj    =    new   Object (  )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( creator . createRecord ( recordFactory )  )  . willReturn ( outputRecord )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( generator . createRecord ( recordFactory )  )  . willReturn ( inputRecord )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord ,    outputRecord )  )  . willReturn ( true )  ;", "given ( extractor . extractData ( outputRecord )  )  . willReturn ( obj )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . setOutputRecordCreator ( creator )  ;", "assertEquals ( obj ,    ct . execute ( interactionSpec ,    generator ,    extractor )  )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputGeneratorExtractorTrueWithCreator"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordCreator   generator    =    mock ( RecordCreator . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( generator . createRecord ( recordFactory )  )  . willReturn ( inputRecord )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord )  )  . willReturn ( outputRecord )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . execute ( interactionSpec ,    generator )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputGeneratorFalse"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordCreator   generator    =    mock ( RecordCreator . class )  ;", "RecordCreator   creator    =    mock ( RecordCreator . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( generator . createRecord ( recordFactory )  )  . willReturn ( inputRecord )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( creator . createRecord ( recordFactory )  )  . willReturn ( outputRecord )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord ,    outputRecord )  )  . willReturn ( true )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . setOutputRecordCreator ( creator )  ;", "ct . execute ( interactionSpec ,    generator )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputRecord ,    outputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputGeneratorTrueWithCreator"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord ,    outputRecord )  )  . willReturn ( true )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . execute ( interactionSpec ,    inputRecord ,    outputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputRecord ,    outputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputOutput"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "ConnectionSpec   connectionSpec    =    mock ( ConnectionSpec . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection ( connectionSpec )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord ,    outputRecord )  )  . willReturn ( true )  ;", "ConnectionSpecConnectionFactoryAdapter   adapter    =    new   ConnectionSpecConnectionFactoryAdapter (  )  ;", "adapter . setTargetConnectionFactory ( connectionFactory )  ;", "adapter . setConnectionSpec ( connectionSpec )  ;", "ct    =    new    ( adapter )  ;", "ct . execute ( interactionSpec ,    inputRecord ,    outputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputRecord ,    outputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputOutputConnectionSpec"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   record    =    mock ( Record . class )  ;", "ResultSet   resultset    =    mock ( ResultSet . class )  ;", "RecordCreator   generator    =    mock ( RecordCreator . class )  ;", "RecordExtractor < Object >    extractor    =    mock ( RecordExtractor . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( generator . createRecord ( recordFactory )  )  . willReturn ( record )  ;", "given ( interaction . execute ( interactionSpec ,    record )  )  . willReturn ( resultset )  ;", "given ( extractor . extractData ( resultset )  )  . willReturn ( new   Object (  )  )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . execute ( interactionSpec ,    generator ,    extractor )  ;", "verify ( extractor )  . extractData ( resultset )  ;", "verify ( resultset )  . close (  )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputOutputResultsSetFalse"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   inputOutputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputOutputRecord ,    inputOutputRecord )  )  . willReturn ( true )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . execute ( interactionSpec ,    inputOutputRecord ,    inputOutputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputOutputRecord ,    inputOutputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputTrueTrue"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordCreator   creator    =    mock ( RecordCreator . class )  ;", "Record   inputOutputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputOutputRecord ,    inputOutputRecord )  )  . willReturn ( true )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . setOutputRecordCreator ( creator )  ;", "ct . execute ( interactionSpec ,    inputOutputRecord ,    inputOutputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputOutputRecord ,    inputOutputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputTrueTrueWithCreator"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordCreator   creator    =    mock ( RecordCreator . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "final   Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( creator . createRecord ( recordFactory )  )  . willReturn ( outputRecord )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord ,    outputRecord )  )  . willReturn ( true )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . setOutputRecordCreator ( creator )  ;", "ct . execute ( interactionSpec ,    inputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputRecord ,    outputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInputTrueWithCreator2"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "InteractionCallback < Object >    interactionCallback    =    mock ( InteractionCallback . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interactionCallback . doInInteraction ( interaction ,    connectionFactory )  )  . willReturn ( new   Object (  )  )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . execute ( interactionCallback )  ;", "verify ( interactionCallback )  . doInInteraction ( interaction ,    connectionFactory )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteInteractionCallback"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "final   Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willThrow ( new   NotSupportedException (  \" not   supported \"  )  )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord ,    outputRecord )  )  . willReturn ( true )  ;", "ct    =    new    ( connectionFactory )  ;", "ct . setOutputRecordCreator ( new   RecordCreator (  )     {", "@ Override", "public   Record   createRecord ( RecordFactory   recordFactory )     {", "assertTrue (  ( recordFactory   instanceof   NotSupportedRecordFactory )  )  ;", "return   outputRecord ;", "}", "}  )  ;", "ct . execute ( interactionSpec ,    inputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputRecord ,    outputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateExecuteWithCreatorAndRecordFactoryNotSupported"], "fileName": "org.springframework.jca.cci.CciTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", ". QueryCallDetector   callDetector    =    mock (  . QueryCallDetector . class )  ;", ". MappingRecordOperationImpl   query    =    new    . MappingRecordOperationImpl ( connectionFactory ,    interactionSpec )  ;", "query . setCallDetector ( callDetector )  ;", "Object   inObj    =    new   Object (  )  ;", "Object   outObj    =    new   Object (  )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( callDetector . callCreateInputRecord ( recordFactory ,    inObj )  )  . willReturn ( inputRecord )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord )  )  . willReturn ( outputRecord )  ;", "given ( callDetector . callExtractOutputData ( outputRecord )  )  . willReturn ( outObj )  ;", "assertSame ( outObj ,    query . execute ( inObj )  )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testMappingRecordOperation"], "fileName": "org.springframework.jca.cci.EisOperationTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "RecordFactory   recordFactory    =    mock ( RecordFactory . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "RecordCreator   outputCreator    =    mock ( RecordCreator . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", ". QueryCallDetector   callDetector    =    mock (  . QueryCallDetector . class )  ;", ". MappingRecordOperationImpl   query    =    new    . MappingRecordOperationImpl ( connectionFactory ,    interactionSpec )  ;", "query . setOutputRecordCreator ( outputCreator )  ;", "query . setCallDetector ( callDetector )  ;", "Object   inObj    =    new   Object (  )  ;", "Object   outObj    =    new   Object (  )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( callDetector . callCreateInputRecord ( recordFactory ,    inObj )  )  . willReturn ( inputRecord )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( connectionFactory . getRecordFactory (  )  )  . willReturn ( recordFactory )  ;", "given ( outputCreator . createRecord ( recordFactory )  )  . willReturn ( outputRecord )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord ,    outputRecord )  )  . willReturn ( true )  ;", "given ( callDetector . callExtractOutputData ( outputRecord )  )  . willReturn ( outObj )  ;", "assertSame ( outObj ,    query . execute ( inObj )  )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testMappingRecordOperationWithOutputRecordCreator"], "fileName": "org.springframework.jca.cci.EisOperationTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "SimpleRecord   query    =    new   SimpleRecord ( connectionFactory ,    interactionSpec )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord )  )  . willReturn ( outputRecord )  ;", "query . execute ( inputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleRecordOperation"], "fileName": "org.springframework.jca.cci.EisOperationTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   inputRecord    =    mock ( Record . class )  ;", "Record   outputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "SimpleRecord   operation    =    new   SimpleRecord ( connectionFactory ,    interactionSpec )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputRecord ,    outputRecord )  )  . willReturn ( true )  ;", "operation . execute ( inputRecord ,    outputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputRecord ,    outputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleRecordOperationWithExplicitOutputRecord"], "fileName": "org.springframework.jca.cci.EisOperationTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    mock ( ConnectionFactory . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "Interaction   interaction    =    mock ( Interaction . class )  ;", "Record   inputOutputRecord    =    mock ( Record . class )  ;", "InteractionSpec   interactionSpec    =    mock ( InteractionSpec . class )  ;", "SimpleRecord   query    =    new   SimpleRecord ( connectionFactory ,    interactionSpec )  ;", "given ( connectionFactory . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createInteraction (  )  )  . willReturn ( interaction )  ;", "given ( interaction . execute ( interactionSpec ,    inputOutputRecord ,    inputOutputRecord )  )  . willReturn ( true )  ;", "query . execute ( inputOutputRecord ,    inputOutputRecord )  ;", "verify ( interaction )  . execute ( interactionSpec ,    inputOutputRecord ,    inputOutputRecord )  ;", "verify ( interaction )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleRecordOperationWithInputOutputRecord"], "fileName": "org.springframework.jca.cci.EisOperationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . connectionFactory ;", "}", "METHOD_END"], "methodName": ["getConnectionFactory"], "fileName": "org.springframework.jca.cci.connection.CciLocalTransactionManager"}, {"methodBody": ["METHOD_START", "{", "CciLocalTransactionManager . CciLocalTransactionObject   txObject    =     (  ( CciLocalTransactionManager . CciLocalTransactionObject )     ( transaction )  )  ;", "return   txObject . getConnectionHolder (  )  . isRollbackOnly (  )  ;", "}", "METHOD_END"], "methodName": ["isRollbackOnly"], "fileName": "org.springframework.jca.cci.connection.CciLocalTransactionManager"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getConnectionFactory (  )  ;", "Assert . state (  ( connectionFactory    !  =    null )  ,     \" No   ConnectionFactory   set \"  )  ;", "return   connectionFactory ;", "}", "METHOD_END"], "methodName": ["obtainConnectionFactory"], "fileName": "org.springframework.jca.cci.connection.CciLocalTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( cf   instanceof   TransactionAwareConnectionFactoryProxy )     {", "this . connectionFactory    =     (  ( TransactionAwareConnectionFactoryProxy )     ( cf )  )  . getTargetConnectionFactory (  )  ;", "} else    {", "this . connectionFactory    =    cf ;", "}", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jca.cci.connection.CciLocalTransactionManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cf ,     \" No   ConnectionFactory   specified \"  )  ;", "ConnectionHolder   conHolder    =     (  ( ConnectionHolder )     ( TransactionSynchronizationManager . getResource ( cf )  )  )  ;", "if    ( conHolder    !  =    null )     {", "return   conHolder . getConnection (  )  ;", "}", ". logger . debug (  \" Opening   CCI   Connection \"  )  ;", "Connection   con    =    cf . getConnection (  )  ;", "if    ( TransactionSynchronizationManager . isSynchronizationActive (  )  )     {", ". logger . debug (  \" Registering   transaction   synchronization   for   CCI   Connection \"  )  ;", "conHolder    =    new   ConnectionHolder ( con )  ;", "conHolder . setSynchronizedWithTransaction ( true )  ;", "TransactionSynchronizationManager . registerSynchronization ( new    . ConnectionSynchronization ( conHolder ,    cf )  )  ;", "TransactionSynchronizationManager . bindResource ( cf ,    conHolder )  ;", "}", "return   con ;", "}", "METHOD_END"], "methodName": ["doGetConnection"], "fileName": "org.springframework.jca.cci.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( con    =  =    null )     |  |     ( ConnectionFactoryUtils . isConnectionTransactional ( con ,    cf )  )  )     {", "return ;", "}", "con . close (  )  ;", "}", "METHOD_END"], "methodName": ["doReleaseConnection"], "fileName": "org.springframework.jca.cci.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return   ConnectionFactoryUtils . getConnection ( cf ,    null )  ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jca.cci.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( spec    !  =    null )     {", "Assert . notNull ( cf ,     \" No   ConnectionFactory   specified \"  )  ;", "return   cf . getConnection ( spec )  ;", "} else    {", "return    . doGetConnection ( cf )  ;", "}", "}    catch    ( ResourceException   ex )     {", "throw   new   CannotGetCciConnectionException (  \" Could   not   get   CCI   Connection \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jca.cci.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( cf    =  =    null )     {", "return   false ;", "}", "Holder   conHolder    =     (  ( Holder )     ( TransactionSynchronizationManager . getResource ( cf )  )  )  ;", "return    ( conHolder    !  =    null )     &  &     (  ( conHolder . get (  )  )     =  =    con )  ;", "}", "METHOD_END"], "methodName": ["isConnectionTransactional"], "fileName": "org.springframework.jca.cci.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", ". doReleaseConnection ( con ,    cf )  ;", "}    catch    ( ResourceException   ex )     {", ". logger . debug (  \" Could   not   close   CCI   Connection \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Unexpected   exception   on   closing   CCI   Connection \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["releaseConnection"], "fileName": "org.springframework.jca.cci.connection.ConnectionFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . connection ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jca.cci.connection.ConnectionHolder"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getTargetConnectionFactory (  )  ;", "Assert . state (  ( connectionFactory    !  =    null )  ,     \" No    ' targetConnectionFactory '    set \"  )  ;", "return   spec    !  =    null    ?    connectionFactory . getConnection ( spec )     :    connectionFactory . getConnection (  )  ;", "}", "METHOD_END"], "methodName": ["doGetConnection"], "fileName": "org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "this . threadBoundSpec . remove (  )  ;", "}", "METHOD_END"], "methodName": ["removeConnectionSpecFromCurrentThread"], "fileName": "org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "this . connectionSpec    =    connectionSpec ;", "}", "METHOD_END"], "methodName": ["setConnectionSpec"], "fileName": "org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "this . threadBoundSpec . set ( spec )  ;", "}", "METHOD_END"], "methodName": ["setConnectionSpecForCurrentThread"], "fileName": "org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . targetConnectionFactory ;", "}", "METHOD_END"], "methodName": ["getTargetConnectionFactory"], "fileName": "org.springframework.jca.cci.connection.DelegatingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getTargetConnectionFactory (  )  ;", "Assert . state (  ( connectionFactory    !  =    null )  ,     \" No    ' targetConnectionFactory '    set \"  )  ;", "return   connectionFactory ;", "}", "METHOD_END"], "methodName": ["obtainTargetConnectionFactory"], "fileName": "org.springframework.jca.cci.connection.DelegatingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "this . targetConnectionFactory    =    targetConnectionFactory ;", "}", "METHOD_END"], "methodName": ["setTargetConnectionFactory"], "fileName": "org.springframework.jca.cci.connection.DelegatingConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "con . close (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . warn (  \" Could   not   close   shared   CCI    \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["closeConnection"], "fileName": "org.springframework.jca.cci.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getTargetConnectionFactory (  )  ;", "Assert . state (  ( connectionFactory    !  =    null )  ,     \" No    ' targetConnectionFactory '    set \"  )  ;", "return   connectionFactory . getConnection (  )  ;", "}", "METHOD_END"], "methodName": ["doCreateConnection"], "fileName": "org.springframework.jca.cci.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Connection )     ( Proxy . newProxyInstance ( Connection . class . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    Connection . class    }  ,    new   SingleConnectionFactory . CloseSuppressingInvocationHandler ( target )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCloseSuppressingConnectionProxy"], "fileName": "org.springframework.jca.cci.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getTargetConnectionFactory (  )  )     =  =    null )     {", "throw   new   IllegalStateException (  \"  ' targetConnectionFactory '    is   required   for   lazily   initializing   a   Connection \"  )  ;", "}", "synchronized ( this . connectionMonitor )     {", "if    (  ( this . target )     !  =    null )     {", "closeConnection ( this . target )  ;", "}", "this . target    =    doCreateConnection (  )  ;", "prepareConnection ( this . target )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Established   shared   CCI   Connection :     \"     +     ( this . target )  )  )  ;", "}", "this . connection    =    getCloseSuppressingConnectionProxy ( this . target )  ;", "}", "}", "METHOD_END"], "methodName": ["initConnection"], "fileName": "org.springframework.jca.cci.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . connectionMonitor )     {", "if    (  ( this . target )     !  =    null )     {", "closeConnection ( this . target )  ;", "}", "this . target    =    null ;", "this . connection    =    null ;", "}", "}", "METHOD_END"], "methodName": ["resetConnection"], "fileName": "org.springframework.jca.cci.connection.SingleConnectionFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Connection )     ( Proxy . newProxyInstance ( Connection . class . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    Connection . class    }  ,    new   TransactionAwareConnectionFactoryProxy . TransactionAwareInvocationHandler ( target ,    cf )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionAwareConnectionProxy"], "fileName": "org.springframework.jca.cci.connection.TransactionAwareConnectionFactoryProxy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getConnectionFactory (  )  )     =  =    null )     {", "throw   new   IllegalArgumentException (  \" Property    ' connectionFactory '    is   required \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["afterPropertiesSet"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( interaction    !  =    null )     {", "try    {", "interaction . close (  )  ;", "}    catch    ( ResourceException   ex )     {", "logger . trace (  \" Could   not   close   CCI   Interaction \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", "logger . trace (  \" Unexpected   exception   on   clos   CCI   Interaction \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeInteraction"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( resultSet    !  =    null )     {", "try    {", "resultSet . close (  )  ;", "}    catch    ( SQLException   ex )     {", "logger . trace (  \" Could   not   close   CCI   ResultSet \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", "logger . trace (  \" Unexpected   exception   on   clos   CCI   ResultSet \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeResultSet"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "try    {", "RedFactory   redFactory    =    getRedFactory ( obtainConnectionFactory (  )  )  ;", "return   redFactory . createIndexedRed ( name )  ;", "}    catch    ( NotSupportedException   ex )     {", "throw   new   RedTypeNotSupportedException (  \" Creation   of   indexed   Red   not   supported   by   connector \"  ,    ex )  ;", "}    catch    ( ResourceException   ex )     {", "throw   new   CannotCreateRedException (  \" Creation   of   indexed   Red   failed \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createIndexedRecord"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "try    {", "RedFactory   redFactory    =    getRedFactory ( obtainConnectionFactory (  )  )  ;", "return   redFactory . createMappedRed ( name )  ;", "}    catch    ( NotSupportedException   ex )     {", "throw   new   RedTypeNotSupportedException (  \" Creation   of   mapped   Red   not   supported   by   connector \"  ,    ex )  ;", "}    catch    ( ResourceException   ex )     {", "throw   new   CannotCreateRedException (  \" Creation   of   mapped   Red   failed \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createMappedRecord"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "try    {", "RedFactory   redFactory    =    getRedFactory ( obtainConnectionFactory (  )  )  ;", "return   redCreator . createRed ( redFactory )  ;", "}    catch    ( NotSupportedException   ex )     {", "throw   new   RedTypeNotSupportedException (  \" Creation   of   the   desired   Red   type   not   supported   by   connector \"  ,    ex )  ;", "}    catch    ( ResourceException   ex )     {", "throw   new   CannotCreateRedException (  \" Creation   of   the   desired   Red   failed \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createRecord"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "return   execute (  (  ( InteractionCallback < T >  )     (  (    interaction ,    connectionFactory )     -  >     {", "Red   outputRedToUse    =    outputRed ;", "try    {", "if    (  ( outputRed    !  =    null )     |  |     (  ( getOutputRedCreator (  )  )     !  =    null )  )     {", "if    ( outputRed    =  =    null )     {", "RedFactory   redFactory    =    getRedFactory ( connectionFactory )  ;", "outputRedToUse    =    getOutputRedCreator (  )  . createRed ( redFactory )  ;", "}", "interaction . execute ( spec ,    inputRed ,    outputRedToUse )  ;", "} else    {", "outputRedToUse    =    interaction . execute ( spec ,    inputRed )  ;", "}", "return   outputExtractor    !  =    null    ?    outputExtractor . extractData ( outputRedToUse )     :    null ;", "}    finally    {", "if    ( outputRedToUse   instanceof   ResultSet )     {", "closeResultSet (  (  ( ResultSet )     ( outputRedToUse )  )  )  ;", "}", "}", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . connectionFactory ;", "}", "METHOD_END"], "methodName": ["getConnectionFactory"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . connectionSpec ;", "}", "METHOD_END"], "methodName": ["getConnectionSpec"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "CciTemplate   derived    =    new   CciTemplate ( obtainConnectionFactory (  )  ,    connectionSpec )  ;", "RecordCreator   recordCreator    =    getOutputRecordCreator (  )  ;", "if    ( recordCreator    !  =    null )     {", "derived . setOutputRecordCreator ( recordCreator )  ;", "}", "return   derived ;", "}", "METHOD_END"], "methodName": ["getDerivedTemplate"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . outputRecordCreator ;", "}", "METHOD_END"], "methodName": ["getOutputRecordCreator"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   connectionFactory . getRedFactory (  )  ;", "}    catch    ( NotSupportedException   ex )     {", "return   new   NotSupportedRedFactory (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getRecordFactory"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getConnectionFactory (  )  ;", "Assert . st (  ( connectionFactory    !  =    null )  ,     \" No   ConnectionFactory   set \"  )  ;", "return   connectionFactory ;", "}", "METHOD_END"], "methodName": ["obtainConnectionFactory"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "this . connectionFactory    =    connectionFactory ;", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "this . connectionSpec    =    connectionSpec ;", "}", "METHOD_END"], "methodName": ["setConnectionSpec"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "this . outputRecordCreator    =    creator ;", "}", "METHOD_END"], "methodName": ["setOutputRecordCreator"], "fileName": "org.springframework.jca.cci.core.CciTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   CciTemplate ( connectionFactory )  ;", "}", "METHOD_END"], "methodName": ["createCciTemplate"], "fileName": "org.springframework.jca.cci.core.support.CciDaoSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . cciTemplate ;", "}", "METHOD_END"], "methodName": ["getCciTemplate"], "fileName": "org.springframework.jca.cci.core.support.CciDaoSupport"}, {"methodBody": ["METHOD_START", "{", "CciTemplate   cciTemplate    =    getCciTemplate (  )  ;", "Assert . state (  ( cciTemplate    !  =    null )  ,     \" No   CciTemplate   set \"  )  ;", "return   cciTemplate . getDerivedTemplate ( connectionSpec )  ;", "}", "METHOD_END"], "methodName": ["getCciTemplate"], "fileName": "org.springframework.jca.cci.core.support.CciDaoSupport"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactory   connectionFactory    =    getConnectionFactory (  )  ;", "Assestate (  ( connectionFactory    !  =    null )  ,     \" No   ConnectionFactory   set \"  )  ;", "return   ConnectionFactoryUtils . getConnection ( connectionFactory )  ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jca.cci.core.support.CciDaoSupport"}, {"methodBody": ["METHOD_START", "{", "return    ( this . cciTemplate )     !  =    null    ?    this . cciTemplate . getConnectionFactory (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getConnectionFactory"], "fileName": "org.springframework.jca.cci.core.support.CciDaoSupport"}, {"methodBody": ["METHOD_START", "{", "ConnectionFactoryUtils . releaseConnection ( con ,    getConnectionFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["releaseConnection"], "fileName": "org.springframework.jca.cci.core.support.CciDaoSupport"}, {"methodBody": ["METHOD_START", "{", "this . cciTemplate    =    cciTemplate ;", "}", "METHOD_END"], "methodName": ["setCciTemplate"], "fileName": "org.springframework.jca.cci.core.support.CciDaoSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . cciTemplate )     =  =    null )     |  |     ( connectionFactory    !  =     ( this . cciTemplate . getConnectionFactory (  )  )  )  )     {", "this . cciTemplate    =    createCciTemplate ( connectionFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jca.cci.core.support.CciDaoSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . bytes ;", "}", "METHOD_END"], "methodName": ["toByteArray"], "fileName": "org.springframework.jca.cci.core.support.CommAreaRecord"}, {"methodBody": ["METHOD_START", "{", "return   this . cciTemplate ;", "}", "METHOD_END"], "methodName": ["getCciTemplate"], "fileName": "org.springframework.jca.cci.object.EisOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . interactionSpec ;", "}", "METHOD_END"], "methodName": ["getInteractionSpec"], "fileName": "org.springframework.jca.cci.object.EisOperation"}, {"methodBody": ["METHOD_START", "{", "Assert . notNullTemplate ,     \" CciTemplate   must   not   be   null \"  )  ;", "thisTemplate    = Template ;", "}", "METHOD_END"], "methodName": ["setCciTemplate"], "fileName": "org.springframework.jca.cci.object.EisOperation"}, {"methodBody": ["METHOD_START", "{", "this . cciTemplate . setConnectionFactory ( connectionFactory )  ;", "}", "METHOD_END"], "methodName": ["setConnectionFactory"], "fileName": "org.springframework.jca.cci.object.EisOperation"}, {"methodBody": ["METHOD_START", "{", "this . interactionSpec    =    interactionSpec ;", "}", "METHOD_END"], "methodName": ["setInteractionSpec"], "fileName": "org.springframework.jca.cci.object.EisOperation"}, {"methodBody": ["METHOD_START", "{", "InteractionSpec   interactionSpec    =    getInteractionSpec (  )  ;", "Assert . state (  ( interactionSpec    !  =    null )  ,     \" No   InteractionSpec   set \"  )  ;", "return   getCciTemplate (  )  . execute ( interactionSpec ,    new    . RecordCreatorImpl ( inputObject )  ,    new    . RecordExtractorImpl (  )  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jca.cci.object.MappingRecordOperation"}, {"methodBody": ["METHOD_START", "{", "getCciTemplate (  )  . setOutputRecordCreator ( creator )  ;", "}", "METHOD_END"], "methodName": ["setOutputRecordCreator"], "fileName": "org.springframework.jca.cci.object.MappingRecordOperation"}, {"methodBody": ["METHOD_START", "{", "InteractionSpec   interactionSpec    =    getInteractionSpec (  )  ;", "Assert . state (  ( interactionSpec    !  =    null )  ,     \" No   InteractionSpec   set \"  )  ;", "return   getCciTemplate (  )  . execute ( interactionSpec ,    input )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jca.cci.object.SimpleRecordOperation"}, {"methodBody": ["METHOD_START", "{", "InteractionSpec   interactionSpec    =    getInteractionSpec (  )  ;", "Assert . state (  ( interactionSpec    !  =    null )  ,     \" No   InteractionSpec   set \"  )  ;", "getCciTemplate (  )  . execute ( interactionSpec ,    input ,    output )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jca.cci.object.SimpleRecordOperation"}, {"methodBody": ["METHOD_START", "{", "ResourceAdapterApplicationContext   applicationContext    =    new   ResourceAdapterApplicationContext ( bootstrapContext )  ;", "applicationContext . setClassLoader ( getClass (  )  . getClassLoader (  )  )  ;", "String [  ]    configLocations    =    StringUtils . tokenizeToStringArray ( getContextConfigLocation (  )  ,     . CONFIG _ LOCATION _ DELIMITERS )  ;", "loadBeanDefinitions ( applicationContext ,    configLocations )  ;", "applicationContext . refresh (  )  ;", "return   applicationContext ;", "}", "METHOD_END"], "methodName": ["createApplicationContext"], "fileName": "org.springframework.jca.context.SpringContextResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   StandardEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["createEnvironment"], "fileName": "org.springframework.jca.context.SpringContextResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . contextConfigLocation ;", "}", "METHOD_END"], "methodName": ["getContextConfigLocation"], "fileName": "org.springframework.jca.context.SpringContextResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "new   XmlBeanDefinitionReader ( registry )  . loadBeanDefinitions ( configLocations )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.jca.context.SpringContextResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "this . contextConfigLocation    =    contextConfigLocation ;", "}", "METHOD_END"], "methodName": ["setContextConfigLocation"], "fileName": "org.springframework.jca.context.SpringContextResourceAdapter"}, {"methodBody": ["METHOD_START", "{", "this . transactionFactory    =    transactionFactory ;", "}", "METHOD_END"], "methodName": ["setTransactionFactory"], "fileName": "org.springframework.jca.endpoint.AbstractMessageEndpointFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( transactionManager   instanceof   TransactionFactory )     {", "this . transactionFactory    =     (  ( TransactionFactory )     ( transactionManager )  )  ;", "} else", "if    ( transactionManager   instanceof   TransactionManager )     {", "this . transactionFactory    =    new   transaction . jta . SimpleTransactionFactory (  (  ( TransactionManager )     ( transactionManager )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  \" Transaction   manager    [  \"     +    transactionManager )     +     \"  ]    is   neither   a    [ transaction . jta . TransactionFactory }    nor   a    \"  )     +     \"  [ TransactionManager ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.jca.endpoint.AbstractMessageEndpointFactory"}, {"methodBody": ["METHOD_START", "{", "this . transactionName    =    transactionName ;", "}", "METHOD_END"], "methodName": ["setTransactionName"], "fileName": "org.springframework.jca.endpoint.AbstractMessageEndpointFactory"}, {"methodBody": ["METHOD_START", "{", "this . transactionTimeout    =    transactionTimeout ;", "}", "METHOD_END"], "methodName": ["setTransactionTimeout"], "fileName": "org.springframework.jca.endpoint.AbstractMessageEndpointFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . messageListener )     !  =    null )  ,     \" No   message   listener   set \"  )  ;", "return   this . messageListener ;", "}", "METHOD_END"], "methodName": ["getMessageListener"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointFactory"}, {"methodBody": ["METHOD_START", "{", "this . messageListener    =    messageListener ;", "}", "METHOD_END"], "methodName": ["setMessageListener"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . activationSpec ;", "}", "METHOD_END"], "methodName": ["getActivationSpec"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "return   this . messageEndpointFactory ;", "}", "METHOD_END"], "methodName": ["getMessageEndpointFactory"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceAdapter ;", "}", "METHOD_END"], "methodName": ["getResourceAdapter"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . activationSpec    =    activationSpec ;", "}", "METHOD_END"], "methodName": ["setActivationSpec"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . messageEndpointFactory    =    messageEndpointFactory ;", "}", "METHOD_END"], "methodName": ["setMessageEndpointFactory"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . phase    =    phase ;", "}", "METHOD_END"], "methodName": ["setPhase"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . resourceAdapter    =    resourceAdapter ;", "}", "METHOD_END"], "methodName": ["setResourceAdapter"], "fileName": "org.springframework.jca.endpoint.GenericMessageEndpointManager"}, {"methodBody": ["METHOD_START", "{", "this . connectionManager    =    connectionManager ;", "}", "METHOD_END"], "methodName": ["setConnectionManager"], "fileName": "org.springframework.jca.support.LocalConnectionFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . managedConnectionFactory    =    managedConnectionFactory ;", "}", "METHOD_END"], "methodName": ["setManagedConnectionFactory"], "fileName": "org.springframework.jca.support.LocalConnectionFactoryBean"}, {"methodBody": ["METHOD_START", "{", "ManagedConnectionFactory   managedConnectionFactory    =    mock ( ManagedConnectionFactory . class )  ;", "ConnectionManager   connectionManager    =    mock ( ConnectionManager . class )  ;", "factory    =    new    (  )  ;", "factory . setManagedConnectionFactory ( managedConnectionFactory )  ;", "factory . setConnectionManager ( connectionManager )  ;", "factory . afterPropertiesSet (  )  ;", "verify ( managedConnectionFactory )  . createConnectionFactory ( connectionManager )  ;", "}", "METHOD_END"], "methodName": ["testCreatesManagedConnectionFactoryIfAConnectionManagerHasBeenConfigured"], "fileName": "org.springframework.jca.support.LocalConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   Object   CONNECTION _ FACTORY    =    new   Object (  )  ;", "ManagedConnectionFactory   managedConnectionFactory    =    mock ( ManagedConnectionFactory . class )  ;", "given ( managedConnectionFactory . createConnectionFactory (  )  )  . willReturn ( CONNECTION _ FACTORY )  ;", "factory    =    new    (  )  ;", "factory . setManagedConnectionFactory ( managedConnectionFactory )  ;", "factory . afterPropertiesSet (  )  ;", "assertEquals ( CONNECTION _ FACTORY ,    factory . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCreatesVanillaConnectionFactoryIfNoConnectionManagerHasBeenConfigured"], "fileName": "org.springframework.jca.support.LocalConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "LocalConnectionFactoryBean   factory    =    new   LocalConnectionFactoryBean (  )  ;", "assertNull ( factory . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetObjectTypeIsNullIfConnectionFactoryHasNotBeenConfigured"], "fileName": "org.springframework.jca.support.LocalConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "LocalConnectionFactoryBean   factory    =    new   LocalConnectionFactoryBean (  )  ;", "assertTrue ( factory . isSingleton (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsSingleton"], "fileName": "org.springframework.jca.support.LocalConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "new   LocalConnectionFactoryBean (  )  . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testManagedConnectionFactoryIsRequired"], "fileName": "org.springframework.jca.support.LocalConnectionFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . bootstrapContext    =    bootstrapContext ;", "}", "METHOD_END"], "methodName": ["setBootstrapContext"], "fileName": "org.springframework.jca.support.ResourceAdapterFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . resourceAdapter    =    resourceAdapter ;", "}", "METHOD_END"], "methodName": ["setResourceAdapter"], "fileName": "org.springframework.jca.support.ResourceAdapterFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . resourceAdapter    =    BeanUtils . instantiateClass ( resourceAdapterClass )  ;", "}", "METHOD_END"], "methodName": ["setResourceAdapterClass"], "fileName": "org.springframework.jca.support.ResourceAdapterFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . workManager    =    workManager ;", "}", "METHOD_END"], "methodName": ["setWorkManager"], "fileName": "org.springframework.jca.support.ResourceAdapterFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . xaTerminator    =    xaTerminator ;", "}", "METHOD_END"], "methodName": ["setXaTerminator"], "fileName": "org.springframework.jca.support.ResourceAdapterFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.jca.work.DelegatingWork"}, {"methodBody": ["METHOD_START", "{", "if    (  ( executionContext    !  =    null )     &  &     (  ( executionContext . getXid (  )  )     !  =    null )  )     {", "throw   new   WorkException (  (  \"    does   not   supported   imported   XIDs :     \"     +     ( executionContext . getXid (  )  )  )  )  ;", "}", "WorkListener   workListenerToUse    =    workListener ;", "if    ( workListenerToUse    =  =    null )     {", "workListenerToUse    =    new   WorkAdapter (  )  ;", "}", "boolean   isAsync    =    taskExecutor   instanceof   AsyncTaskExecutor ;", ". DelegatingWorkAdapter   workHandle    =    new    . DelegatingWorkAdapter ( work ,    workListenerToUse ,     (  ! isAsync )  )  ;", "try    {", "if    ( isAsync )     {", "(  ( AsyncTaskExecutor )     ( taskExecutor )  )  . execute ( workHandle ,    startTimeout )  ;", "} else    {", "taskExecutor . execute ( workHandle )  ;", "}", "}    catch    ( TaskTimeoutException   ex )     {", "WorkException   wex    =    new   WorkRejectedException (  (  \" TaskExecutor   rejected   Work   because   of   timeout :     \"     +    work )  ,    ex )  ;", "wex . setErrorCode ( START _ TIMED _ OUT )  ;", "workListenerToUse . workRejected ( new   WorkEvent ( this ,    WorkEvent . WORK _ REJECTED ,    work ,    wex )  )  ;", "throw   wex ;", "}    catch    ( TaskRejectedException   ex )     {", "WorkException   wex    =    new   WorkRejectedException (  (  \" TaskExecutor   rejected   Work :     \"     +    work )  ,    ex )  ;", "wex . setErrorCode ( INTERNAL )  ;", "workListenerToUse . workRejected ( new   WorkEvent ( this ,    WorkEvent . WORK _ REJECTED ,    work ,    wex )  )  ;", "throw   wex ;", "}    catch    ( Throwable   ex )     {", "WorkException   wex    =    new   WorkException (  (  \" TaskExecutor   failed   to   execute   Work :     \"     +    work )  ,    ex )  ;", "wex . setErrorCode ( INTERNAL )  ;", "throw   wex ;", "}", "if    ( isAsync )     {", "workListenerToUse . workAccepted ( new   WorkEvent ( this ,    WorkEvent . WORK _ ACCEPTED ,    work ,    null )  )  ;", "}", "if    ( blockUntilStarted )     {", "long   acceptanceTime    =    System . currentTimeMillis (  )  ;", "synchronized ( workHandle . monitor )     {", "try    {", "while    (  !  ( workHandle . started )  )     {", "workHandle . monitor . wait (  )  ;", "}", "}    catch    ( InterruptedException   ex )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "return    ( System . currentTimeMillis (  )  )     -    acceptanceTime ;", "} else    {", "return   WorkManager . UNKNOWN ;", "}", "}", "METHOD_END"], "methodName": ["executeWork"], "fileName": "org.springframework.jca.work.SimpleTaskWorkManager"}, {"methodBody": ["METHOD_START", "{", "this . asyncTaskExecutor    =    asyncTaskExecutor ;", "}", "METHOD_END"], "methodName": ["setAsyncTaskExecutor"], "fileName": "org.springframework.jca.work.SimpleTaskWorkManager"}, {"methodBody": ["METHOD_START", "{", "this . syncTaskExecutor    =    syncTaskExecutor ;", "}", "METHOD_END"], "methodName": ["setSyncTaskExecutor"], "fileName": "org.springframework.jca.work.SimpleTaskWorkManager"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleTaskWorkManager (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultWorkManager"], "fileName": "org.springframework.jca.work.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . workManager )     !  =    null )  ,     \" No   WorkManager   specified \"  )  ;", "return   this . workManager ;", "}", "METHOD_END"], "methodName": ["obtainWorkManager"], "fileName": "org.springframework.jca.work.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . blockUntilCompleted    =    blockUntilCompleted ;", "}", "METHOD_END"], "methodName": ["setBlockUntilCompleted"], "fileName": "org.springframework.jca.work.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . blockUntilStarted    =    blockUntilStarted ;", "}", "METHOD_END"], "methodName": ["setBlockUntilStarted"], "fileName": "org.springframework.jca.work.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . taskDecorator    =    taskDecorator ;", "}", "METHOD_END"], "methodName": ["setTaskDecorator"], "fileName": "org.springframework.jca.work.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . workListener    =    workListener ;", "}", "METHOD_END"], "methodName": ["setWorkListener"], "fileName": "org.springframework.jca.work.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( workManager ,     \" WorkManager   must   not   be   null \"  )  ;", "this . workManager    =    workManager ;", "}", "METHOD_END"], "methodName": ["setWorkManager"], "fileName": "org.springframework.jca.work.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . workManagerName    =    workManagerName ;", "}", "METHOD_END"], "methodName": ["setWorkManagerName"], "fileName": "org.springframework.jca.work.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "begun    =    commits    =    rollbacks    =    inflight    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.tests.transaction.CallCountingTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   synchronization ;", "}", "METHOD_END"], "methodName": ["getSynchronization"], "fileName": "org.springframework.tests.transaction.MockJtaTransaction"}, {"methodBody": ["METHOD_START", "{", "return   outcomeState ;", "}", "METHOD_END"], "methodName": ["getOutcomeState"], "fileName": "org.springframework.transaction.HeuristicCompletionException"}, {"methodBody": ["METHOD_START", "{", "switch    ( state )     {", "case    . STATE _ COMMITTED    :", "return    \" committed \"  ;", "case    . STATE _ ROLLED _ BACK    :", "return    \" rolled   back \"  ;", "case    . STATE _ MIXED    :", "return    \" mixed \"  ;", "default    :", "return    \" unknown \"  ;", "}", "}", "METHOD_END"], "methodName": ["getStateString"], "fileName": "org.springframework.transaction.HeuristicCompletionException"}, {"methodBody": ["METHOD_START", "{", "return   timeout ;", "}", "METHOD_END"], "methodName": ["getTimeout"], "fileName": "org.springframework.transaction.InvalidTimeoutException"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "if    ( defaultUt )     {", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "} else    {", "given ( tm . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "}", "ptm    =    new    (  )  ;", "ExpectedLookupTemplate   jndiTemplate    =    new   ExpectedLookupTemplate (  )  ;", "if    ( defaultUt )     {", "jndiTemplate . addObject (  \" java : comp / UserTransaction \"  ,    ut )  ;", "}", "jndiTemplate . addObject ( tmName ,    tm )  ;", "ptm . setJndiTemplate ( jndiTemplate )  ;", "ptm . afterPropertiesSet (  )  ;", "if    ( tmFound )     {", "assertEquals ( tm ,    ptm . getTransactionManager (  )  )  ;", "} else    {", "assertNull ( ptm . getTransactionManager (  )  )  ;", "}", "if    ( defaultUt )     {", "assertEquals ( ut ,    ptm . getUserTransaction (  )  )  ;", "} else    {", "assertTrue (  (  ( ptm . getUserTransaction (  )  )    instanceof   UserTransactionAdapter )  )  ;", "UserTransactionAdapter   uta    =     (  ( UserTransactionAdapter )     ( ptm . getUserTransaction (  )  )  )  ;", "assertEquals ( tm ,    uta . getTransactionManager (  )  )  ;", "}", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertTrue (  (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "}", "}  )  ;", "assertTrue (  (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "if    ( defaultUt )     {", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "} else    {", "verify ( tm )  . begin (  )  ;", "verify ( tm )  . commit (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestJtaTransactionManagerWithDefaultJndiLookups"], "fileName": "org.springframework.transaction.JndiJtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "ptm    =    new    (  )  ;", "ptm . setUserTransactionName (  \" jndi - ut \"  )  ;", "ptm . setTransactionManagerName (  \" jndi - tm \"  )  ;", "ExpectedLookupTemplate   jndiTemplate    =    new   ExpectedLookupTemplate (  )  ;", "jndiTemplate . addObject (  \" jndi - ut \"  ,    ut )  ;", "jndiTemplate . addObject (  \" jndi - tm \"  ,    tm )  ;", "ptm . setJndiTemplate ( jndiTemplate )  ;", "ptm . afterPropertiesSet (  )  ;", "assertEquals ( ut ,    ptm . getUserTransaction (  )  )  ;", "assertEquals ( tm ,    ptm . getTransactionManager (  )  )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertTrue (  (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "}", "}  )  ;", "assertTrue (  (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithCustomJndiLookups"], "fileName": "org.springframework.transaction.JndiJtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionManagerWithDefaultJndiLookups (  \" java : comp / TransactionManager \"  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithDefaultJndiLookups1"], "fileName": "org.springframework.transaction.JndiJtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionManagerWithDefaultJndiLookups (  \" java :  / TransactionManager \"  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithDefaultJndiLookups2"], "fileName": "org.springframework.transaction.JndiJtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionManagerWithDefaultJndiLookups (  \" java :  / tm \"  ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithDefaultJndiLookupsAndNoTmFound"], "fileName": "org.springframework.transaction.JndiJtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionManagerWithDefaultJndiLookups (  \" java :  / TransactionManager \"  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithDefaultJndiLookupsAndNoUtFound"], "fileName": "org.springframework.transaction.JndiJtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "UserTransaction   ut 2     =    mock ( UserTransaction . class )  ;", "given ( ut 2  . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "ptm    =    new    (  )  ;", "ptm . setJndiTemplate ( new   ExpectedLookupTemplate (  \" java : comp / UserTransaction \"  ,    ut )  )  ;", "ptm . setCacheUserTransaction ( false )  ;", "ptm . afterPropertiesSet (  )  ;", "assertEquals ( ut ,    ptm . getUserTransaction (  )  )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertEquals (  . SYNCHRONIZATION _ ALWAYS ,    ptm . getTransactionSynchronization (  )  )  ;", "assertTrue (  (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "}", "}  )  ;", "ptm . setJndiTemplate ( new   ExpectedLookupTemplate (  \" java : comp / UserTransaction \"  ,    ut 2  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "}", "}  )  ;", "assertTrue (  (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "verify ( ut 2  )  . begin (  )  ;", "verify ( ut 2  )  . commit (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithNotCacheUserTransaction"], "fileName": "org.springframework.transaction.JndiJtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TransactionSynchronizationManager . getResourceMap (  )  . isEmpty (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertNull ( TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.transaction.JndiJtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ MARKED _ ROLLBACK ,    STATUS _ MARKED _ ROLLBACK ,    STATUS _ MARKED _ ROLLBACK )  ;", "tm    =    new ( ut )  ;", "if    ( failEarly )     {", "tm . setFailEarlyOnGlobalRollbackOnly ( true )  ;", "}", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "boolean   outerTransactionBoundaryReached    =    false ;", "try    {", "assertTrue (  \" Is   new   transaction \"  ,    ts . isNewTransaction (  )  )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionSynchronizationAdapter (  )     {", "@ Override", "public   void   afterCompletion ( int   status )     {", "assertTrue (  \" Correct   completion   status \"  ,     ( status    =  =     ( TransactionSynchronization . STATUS _ ROLLED _ BACK )  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "outerTransactionBoundaryReached    =    true ;", "tm . commit ( ts )  ;", "fail (  \" Should   have   thrown   UnexpectedRollbackException \"  )  ;", "}    catch    ( UnexpectedRollbackException   ex )     {", "if    (  ! outerTransactionBoundaryReached )     {", "tm . rollback ( ts )  ;", "}", "if    ( failEarly )     {", "assertFalse ( outerTransactionBoundaryReached )  ;", "} else    {", "assertTrue ( outerTransactionBoundaryReached )  ;", "}", "}", "verify ( ut )  . begin (  )  ;", "if    ( failEarly )     {", "verify ( ut )  . rollback (  )  ;", "} else    {", "verify ( ut )  . commit (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestJtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setName (  \" txName \"  )  ;", "assertEquals (  . SYNCHRONIZATION _ ALWAYS ,    ptm . getTransactionSynchronization (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertNull ( TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "assertEquals (  \" txName \"  ,    TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertNull ( TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "verify ( synch )  . beforeCommit ( false )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCommit (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ COMMITTED )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithCommit"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "ptm . setTransactionSynchronization (  . SYNCHRONIZATION _ NEVER )  ;", "ptm . afterPropertiesSet (  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithCommitAndSynchronizationNever"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "ptm . setTransactionSynchronization (  . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "verify ( synch )  . beforeCommit ( false )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCommit (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ COMMITTED )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithCommitAndSynchronizationOnActual"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "ptm    =    new ( ut )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionStatus   status    =    ptm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "ptm . commit ( status )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "try    {", "ptm . commit ( status )  ;", "fail (  \" Should   have   thrown   IllegalTransactionStateException \"  )  ;", "}    catch    ( IllegalTransactionStateException   ex )     {", "}", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithDoubleCommit"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE )  ;", "ptm    =    new ( ut )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionStatus   status    =    ptm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "ptm . rollback ( status )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "try    {", "ptm . rollback ( status )  ;", "fail (  \" Should   have   thrown   IllegalTransactionStateException \"  )  ;", "}    catch    ( IllegalTransactionStateException   ex )     {", "}", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . rollback (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithDoubleRollback"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . setRollbackOnly (  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithExistingAndPropagationSupports"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "willThrow ( new   OptimisticLockingFailureException (  \"  \"  )  )  . given ( synch )  . beforeCommit ( false )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   OptimisticLockingFailureException \"  )  ;", "}    catch    ( OptimisticLockingFailureException   ex )     {", "}", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . setRollbackOnly (  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithExistingTransactionAndCommitException"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "throw   new   IllegalStateException (  \" I   want   a   rollback \"  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . setRollbackOnly (  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithExistingTransactionAndException"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "ptm . setGlobalRollbackOnParticipationFailure ( false )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "throw   new   IllegalStateException (  \" I   want   a   rollback \"  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithExistingTransactionAndExceptionAndNoGlobalRollback"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "MockJtaTransaction   tx    =    new   MockJtaTransaction (  )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "given ( tm . getTransaction (  )  )  . willReturn ( tx )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut ,    tm )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertNotNull ( tx . getSynchronization (  )  )  ;", "tx . getSynchronization (  )  . beforeCompletion (  )  ;", "tx . getSynchronization (  )  . afterCompletion ( STATUS _ ROLLEDBACK )  ;", "verify ( ut )  . setRollbackOnly (  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ ROLLED _ BACK )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithExistingTransactionAndJtaSynchronization"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . setRollbackOnly (  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithExistingTransactionAndRollbackOnly"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "ptm . setGlobalRollbackOnParticipationFailure ( false )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . setRollbackOnly (  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithExistingTransactionAndRollbackOnlyAndNoGlobalRollback"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "ptm . setTransactionSynchronization (  . SYNCHRONIZATION _ NEVER )  ;", "ptm . afterPropertiesSet (  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . setRollbackOnly (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithExistingTransactionAndSynchronizationNever"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "ptm . setTransactionSynchronization (  . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . setRollbackOnly (  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithExistingTransactionAndSynchronizationOnActual"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "willThrow ( new   HeuristicMixedException (  \" heuristic   exception \"  )  )  . given ( ut )  . commit (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionSynchronizationAdapter (  )     {", "@ Override", "public   void   afterCompletion ( int   status )     {", "assertTrue (  \" Correct   completion   status \"  ,     ( status    =  =     ( TransactionSynchronization . STATUS _ UNKNOWN )  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   HeuristicCompletionException \"  )  ;", "}    catch    ( HeuristicCompletionException   ex )     {", "assertTrue (  (  ( ex . getOutcomeState (  )  )     =  =     ( HeuristicCompletionException . STATE _ MIXED )  )  )  ;", "}", "verify ( ut )  . begin (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithHeuristicMixedExceptionOnCommit"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "willThrow ( new   HeuristicRollbackException (  \" heuristic   exception \"  )  )  . given ( ut )  . commit (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionSynchronizationAdapter (  )     {", "@ Override", "public   void   afterCompletion ( int   status )     {", "assertTrue (  \" Correct   completion   status \"  ,     ( status    =  =     ( TransactionSynchronization . STATUS _ UNKNOWN )  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   HeuristicCompletionException \"  )  ;", "}    catch    ( HeuristicCompletionException   ex )     {", "assertTrue (  (  ( ex . getOutcomeState (  )  )     =  =     ( HeuristicCompletionException . STATE _ ROLLED _ BACK )  )  )  ;", "}", "verify ( ut )  . begin (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithHeuristicRollbackExceptionOnCommit"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "willThrow ( new   IllegalStateException (  \" no   existing   transaction \"  )  )  . given ( ut )  . setRollbackOnly (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   TransactionSystemException \"  )  ;", "}    catch    ( TransactionSystemException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithIllegalStateExceptionOnRollbackOnly"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setIsolationLevel ( TransactionDefinition . ISOLATION _ SERIALIZABLE )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "}", "}  )  ;", "fail (  \" Should   have   thrown   InvalidIsolationLevelException \"  )  ;", "}    catch    ( InvalidIsolationLevelException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithIsolationLevel"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ NESTED )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "}", "}  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithNestedBegin"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly ( false )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly ( true )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithNoExceptionOnGlobalRollbackOnlyAndFailEarly"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "willThrow ( new   NotSupportedException (  \" not   supported \"  )  )  . given ( ut )  . begin (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ NESTED )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "}", "}  )  ;", "fail (  \" Should   have   thrown   NestedTransactionNotSupportedException \"  )  ;", "}    catch    ( NestedTransactionNotSupportedException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithNotSupportedExceptionOnNestedBegin"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "Transaction   tx    =    mock ( Transaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "given ( tm . suspend (  )  )  . willReturn ( tx )  ;", "ptm    =    new ( ut ,    tm )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ NOT _ SUPPORTED )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( tm )  . resume ( tx )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationNotSupported"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "Transaction   tx    =    mock ( Transaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "given ( tm . suspend (  )  )  . willReturn ( tx )  ;", "final      ptm    =    new ( ut ,    tm )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  ;", "tt . setName (  \" txName \"  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertEquals (  \" txName \"  ,    TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "TransactionTemplate   tt 2     =    new   TransactionTemplate ( ptm )  ;", "tt 2  . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  ;", "tt 2  . setReadOnly ( true )  ;", "tt 2  . setName (  \" txName 2  \"  )  ;", "tt 2  . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertEquals (  \" txName 2  \"  ,    TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "}", "}  )  ;", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertEquals (  \" txName \"  ,    TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut ,    times (  2  )  )  . begin (  )  ;", "verify ( ut ,    times (  2  )  )  . commit (  )  ;", "verify ( tm )  . resume ( tx )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationRequiresNew"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "Transaction   tx    =    mock ( Transaction . class )  ;", "given ( tm . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "given ( tm . suspend (  )  )  . willReturn ( tx )  ;", "ptm    =    new ( tm )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( tm )  . begin (  )  ;", "verify ( tm )  . commit (  )  ;", "verify ( tm )  . resume ( tx )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationRequiresNewAndAdapter"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "Transaction   tx    =    mock ( Transaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "given ( tm . suspend (  )  )  . willReturn ( tx )  ;", "ptm    =    new ( ut ,    tm )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "verify ( tm )  . resume ( tx )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationRequiresNewAndExisting"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "Transaction   tx    =    mock ( Transaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "given ( tm . suspend (  )  )  . willReturn ( tx )  ;", "willThrow ( new   SystemException (  )  )  . given ( ut )  . begin (  )  ;", "ptm    =    new ( ut ,    tm )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   CannotCreateTransactionException \"  )  ;", "}    catch    ( CannotCreateTransactionException   ex )     {", "}", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( tm )  . resume ( tx )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationRequiresNewAndExistingWithBeginException"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "willThrow ( new   SystemException (  )  )  . given ( tm )  . suspend (  )  ;", "ptm    =    new ( ut ,    tm )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   TransactionSystemException \"  )  ;", "}    catch    ( TransactionSystemException   ex )     {", "}", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationRequiresNewAndExistingWithSuspendException"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "}", "}  )  ;", "fail (  \" Should   have   thrown   TransactionSuspensionNotSupportedException \"  )  ;", "}    catch    ( TransactionSuspensionNotSupportedException   ex )     {", "}", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationRequiresNewAndSuspensionNotSupported"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "final      ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "TransactionTemplate   tt 2     =    new   TransactionTemplate ( ptm )  ;", "tt 2  . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  ;", "tt 2  . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "}  )  ;", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationRequiresNewWithinSupports"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ ROLLED _ BACK )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationSupports"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "ptm . setTransactionSynchronization (  . SYNCHRONIZATION _ NEVER )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "ptm . afterPropertiesSet (  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationSupportsAndSynchronizationNever"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "ptm . setTransactionSynchronization (  . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "ptm . afterPropertiesSet (  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithPropagationSupportsAndSynchronizationOnActual"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setTimeout (  1  0  )  ;", "tt . setName (  \" txName \"  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertNull ( TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "assertEquals (  \" txName \"  ,    TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertNull ( TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "verify ( ut )  . setTransactionTimeout (  1  0  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . rollback (  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ ROLLED _ BACK )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithRollback"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE )  ;", "ptm    =    new ( ut )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionStatus   status    =    ptm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "ptm . rollback ( status )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "try    {", "ptm . commit ( status )  ;", "fail (  \" Should   have   thrown   IllegalTransactionStateException \"  )  ;", "}    catch    ( IllegalTransactionStateException   ex )     {", "}", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . rollback (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithRollbackAndCommit"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "ptm . setTransactionSynchronizationName (  \" SYNCHRONIZATION _ NEVER \"  )  ;", "tt . setTimeout (  1  0  )  ;", "ptm . afterPropertiesSet (  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . setTransactionTimeout (  1  0  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut ,    atLeastOnce (  )  )  . getStatus (  )  ;", "verify ( ut )  . rollback (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithRollbackAndSynchronizationNever"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE )  ;", "final   TransactionSynchronization   synch    =    mock ( TransactionSynchronization . class )  ;", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "ptm . setTransactionSynchronization (  . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "tt . setTimeout (  1  0  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( ut )  . setTransactionTimeout (  1  0  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . rollback (  )  ;", "verify ( synch )  . beforeCompletion (  )  ;", "verify ( synch )  . afterCompletion ( TransactionSynchronization . STATUS _ ROLLED _ BACK )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithRollbackAndSynchronizationOnActual"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "willThrow ( new   RollbackException (  \" unexpected   rollback \"  )  )  . given ( ut )  . commit (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionSynchronizationAdapter (  )     {", "@ Override", "public   void   afterCompletion ( int   status )     {", "assertTrue (  \" Correct   completion   status \"  ,     ( status    =  =     ( TransactionSynchronization . STATUS _ ROLLED _ BACK )  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   UnexpectedRollbackException \"  )  ;", "}    catch    ( UnexpectedRollbackException   ex )     {", "}", "verify ( ut )  . begin (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithRollbackExceptionOnCommit"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION )  ;", "willThrow ( new   SystemException (  \" system   exception \"  )  )  . given ( ut )  . begin (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "}", "}  )  ;", "fail (  \" Should   have   thrown   CannotCreateTransactionException \"  )  ;", "}    catch    ( CannotCreateTransactionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithSystemExceptionOnBegin"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "willThrow ( new   SystemException (  \" system   exception \"  )  )  . given ( ut )  . commit (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionSynchronizationAdapter (  )     {", "@ Override", "public   void   afterCompletion ( int   status )     {", "assertTrue (  \" Correct   completion   status \"  ,     ( status    =  =     ( TransactionSynchronization . STATUS _ UNKNOWN )  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   TransactionSystemException \"  )  ;", "}    catch    ( TransactionSystemException   ex )     {", "}", "verify ( ut )  . begin (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithSystemExceptionOnCommit"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willThrow ( new   SystemException (  \" system   exception \"  )  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "}", "}  )  ;", "fail (  \" Should   have   thrown   TransactionSystemException \"  )  ;", "}    catch    ( TransactionSystemException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithSystemExceptionOnIsExisting"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE )  ;", "willThrow ( new   SystemException (  \" system   exception \"  )  )  . given ( ut )  . rollback (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionSynchronizationAdapter (  )     {", "@ Override", "public   void   afterCompletion ( int   status )     {", "assertTrue (  \" Correct   completion   status \"  ,     ( status    =  =     ( TransactionSynchronization . STATUS _ UNKNOWN )  )  )  ;", "}", "}  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   TransactionSystemException \"  )  ;", "}    catch    ( TransactionSystemException   ex )     {", "}", "verify ( ut )  . begin (  )  ;", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithSystemExceptionOnRollback"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "willThrow ( new   SystemException (  \" system   exception \"  )  )  . given ( ut )  . setRollbackOnly (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "status . setRollbackOnly (  )  ;", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionSynchronizationAdapter (  )     {", "@ Override", "public   void   afterCompletion ( int   status )     {", "assertTrue (  \" Correct   completion   status \"  ,     ( status    =  =     ( TransactionSynchronization . STATUS _ UNKNOWN )  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   TransactionSystemException \"  )  ;", "}    catch    ( TransactionSystemException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithSystemExceptionOnRollbackOnly"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "willThrow ( new   UnsupportedOperationException (  \" not   supported \"  )  )  . given ( ut )  . begin (  )  ;", "try    {", "ptm    =    new ( ut )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ NESTED )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "}", "}  )  ;", "fail (  \" Should   have   thrown   NestedTransactionNotSupportedException \"  )  ;", "}    catch    ( NestedTransactionNotSupportedException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["jtaTransactionManagerWithUnsupportedOperationExceptionOnNestedBegin"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   JtaTransactionManager ( tm )  ;", "}", "METHOD_END"], "methodName": ["newJtaTransactionManager"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   JtaTransactionManager ( ut )  ;", "}", "METHOD_END"], "methodName": ["newJtaTransactionManager"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   JtaTransactionManager ( ut ,    tm )  ;", "}", "METHOD_END"], "methodName": ["newJtaTransactionManager"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TransactionSynchronizationManager . getResourceMap (  )  . isEmpty (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertNull ( TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertNull ( TransactionSynchronizationManager . getCurrentTransactionIsolationLevel (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.transaction.JtaTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . definition ;", "}", "METHOD_END"], "methodName": ["getDefinition"], "fileName": "org.springframework.transaction.MockCallbackPreferringTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . status ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.springframework.transaction.MockCallbackPreferringTransactionManager"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TransactionSynchronizationManager . getResourceMap (  )  . isEmpty (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( true ,    true )  ;", "tatus   status    =    tm . getTransaction ( null )  ;", "tm . commit ( status )  ;", "assertTrue (  \" no   begin \"  ,     (  !  ( tm . begin )  )  )  ;", "assertTrue (  \" no   commit \"  ,     (  !  ( tm . commit )  )  )  ;", "assertTrue (  \" no   rollback \"  ,     (  !  ( tm . rollback )  )  )  ;", "assertTrue (  \" no   rollbackOnly \"  ,     (  !  ( tm . rollbackOnly )  )  )  ;", "}", "METHOD_END"], "methodName": ["commitWithExistingTransaction"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( false ,    true )  ;", "tatus   status    =    tm . getTransaction ( null )  ;", "tm . commit ( status )  ;", "assertTrue (  \" triggered   begin \"  ,    tm . begin )  ;", "assertTrue (  \" triggered   commit \"  ,    tm . commit )  ;", "assertTrue (  \" no   rollback \"  ,     (  !  ( tm . rollback )  )  )  ;", "assertTrue (  \" no   rollbackOnly \"  ,     (  !  ( tm . rollbackOnly )  )  )  ;", "}", "METHOD_END"], "methodName": ["commitWithoutExistingTransaction"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "PlatformTransactionManager   tm    =    new   TestTransactionManager ( true ,    true )  ;", "Defaulttatus   status 1     =     (  ( Defaulttatus )     ( tm . getTransaction ( new   DefaultTransactionDefinition ( TransactionDefinition . PROPAGATION _ SUPPORTS )  )  )  )  ;", "assertTrue (  \" Must   have   transaction \"  ,     (  ( status 1  . getTransaction (  )  )     !  =    null )  )  ;", "assertTrue (  \" Must   not   be   new   transaction \"  ,     (  !  ( status 1  . isNewTransaction (  )  )  )  )  ;", "Defaulttatus   status 2     =     (  ( Defaulttatus )     ( tm . getTransaction ( new   DefaultTransactionDefinition ( TransactionDefinition . PROPAGATION _ REQUIRED )  )  )  )  ;", "assertTrue (  \" Must   have   transaction \"  ,     (  ( status 2  . getTransaction (  )  )     !  =    null )  )  ;", "assertTrue (  \" Must   not   be   new   transaction \"  ,     (  !  ( status 2  . isNewTransaction (  )  )  )  )  ;", "try    {", "Defaulttatus   status 3     =     (  ( Defaulttatus )     ( tm . getTransaction ( new   DefaultTransactionDefinition ( TransactionDefinition . PROPAGATION _ MANDATORY )  )  )  )  ;", "assertTrue (  \" Must   have   transaction \"  ,     (  ( status 3  . getTransaction (  )  )     !  =    null )  )  ;", "assertTrue (  \" Must   not   be   new   transaction \"  ,     (  !  ( status 3  . isNewTransaction (  )  )  )  )  ;", "}    catch    ( NoTransactionException   ex )     {", "fail (  \" Should   not   have   thrown   NoTransactionException \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["existingTransaction"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "PlatformTransactionManager   tm    =    new   TestTransactionManager ( false ,    true )  ;", "Defaulttatus   status 1     =     (  ( Defaulttatus )     ( tm . getTransaction ( new   DefaultTransactionDefinition ( TransactionDefinition . PROPAGATION _ SUPPORTS )  )  )  )  ;", "assertFalse (  \" Must   not   have   transaction \"  ,    status 1  . hasTransaction (  )  )  ;", "Defaulttatus   status 2     =     (  ( Defaulttatus )     ( tm . getTransaction ( new   DefaultTransactionDefinition ( TransactionDefinition . PROPAGATION _ REQUIRED )  )  )  )  ;", "assertTrue (  \" Must   have   transaction \"  ,    status 2  . hasTransaction (  )  )  ;", "assertTrue (  \" Must   be   new   transaction \"  ,    status 2  . isNewTransaction (  )  )  ;", "try    {", "tm . getTransaction ( new   DefaultTransactionDefinition ( TransactionDefinition . PROPAGATION _ MANDATORY )  )  ;", "fail (  \" Should   not   have   thrown   NoTransactionException \"  )  ;", "}    catch    ( IllegaltateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["noExistingTransaction"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( true ,    true )  ;", "tatus   status    =    tm . getTransaction ( null )  ;", "status . setRollbackOnly (  )  ;", "tm . commit ( status )  ;", "assertTrue (  \" no   begin \"  ,     (  !  ( tm . begin )  )  )  ;", "assertTrue (  \" no   commit \"  ,     (  !  ( tm . commit )  )  )  ;", "assertTrue (  \" no   rollback \"  ,     (  !  ( tm . rollback )  )  )  ;", "assertTrue (  \" triggered   rollbackOnly \"  ,    tm . rollbackOnly )  ;", "}", "METHOD_END"], "methodName": ["rollbackOnlyWithExistingTransaction"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( false ,    true )  ;", "tatus   status    =    tm . getTransaction ( null )  ;", "status . setRollbackOnly (  )  ;", "tm . commit ( status )  ;", "assertTrue (  \" triggered   begin \"  ,    tm . begin )  ;", "assertTrue (  \" no   commit \"  ,     (  !  ( tm . commit )  )  )  ;", "assertTrue (  \" triggered   rollback \"  ,    tm . rollback )  ;", "assertTrue (  \" no   rollbackOnly \"  ,     (  !  ( tm . rollbackOnly )  )  )  ;", "}", "METHOD_END"], "methodName": ["rollbackOnlyWithoutExistingTransaction"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( true ,    true )  ;", "tatus   status    =    tm . getTransaction ( null )  ;", "tm . rollback ( status )  ;", "assertTrue (  \" no   begin \"  ,     (  !  ( tm . begin )  )  )  ;", "assertTrue (  \" no   commit \"  ,     (  !  ( tm . commit )  )  )  ;", "assertTrue (  \" no   rollback \"  ,     (  !  ( tm . rollback )  )  )  ;", "assertTrue (  \" triggered   rollbackOnly \"  ,    tm . rollbackOnly )  ;", "}", "METHOD_END"], "methodName": ["rollbackWithExistingTransaction"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( false ,    true )  ;", "tatus   status    =    tm . getTransaction ( null )  ;", "tm . rollback ( status )  ;", "assertTrue (  \" triggered   begin \"  ,    tm . begin )  ;", "assertTrue (  \" no   commit \"  ,     (  !  ( tm . commit )  )  )  ;", "assertTrue (  \" triggered   rollback \"  ,    tm . rollback )  ;", "assertTrue (  \" no   rollbackOnly \"  ,     (  !  ( tm . rollbackOnly )  )  )  ;", "}", "METHOD_END"], "methodName": ["rollbackWithoutExistingTransaction"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( false ,    true )  ;", "TransactionTemplate   template    =    new   TransactionTemplate ( tm )  ;", "template . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( tatus   status )     {", "}", "}  )  ;", "assertTrue (  \" triggered   begin \"  ,    tm . begin )  ;", "assertTrue (  \" triggered   commit \"  ,    tm . commit )  ;", "assertTrue (  \" no   rollback \"  ,     (  !  ( tm . rollback )  )  )  ;", "assertTrue (  \" no   rollbackOnly \"  ,     (  !  ( tm . rollbackOnly )  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionTemplate"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm 1     =    new   TestTransactionManager ( false ,    true )  ;", "TestTransactionManager   tm 2     =    new   TestTransactionManager ( false ,    true )  ;", "TransactionTemplate   template 1     =    new   TransactionTemplate ( tm 1  )  ;", "TransactionTemplate   template 2     =    new   TransactionTemplate ( tm 2  )  ;", "TransactionTemplate   template 3     =    new   TransactionTemplate ( tm 2  )  ;", "assertNotEquals ( template 1  ,    template 2  )  ;", "assertNotEquals ( template 1  ,    template 3  )  ;", "assertEquals ( template 2  ,    template 3  )  ;", "}", "METHOD_END"], "methodName": ["transactionTemplateEquality"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( false ,    true )  ;", "TransactionTemplate   template    =    new   TransactionTemplate (  )  ;", "template . setTransactionManager ( tm )  ;", "assertTrue (  \" correct   transaction   manager   set \"  ,     (  ( template . getTransactionManager (  )  )     =  =    tm )  )  ;", "try    {", "template . setPropagationBehaviorName (  \" TIMEOUT _ DEFAULT \"  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "template . setPropagationBehaviorName (  \" PROPAGATION _ SUPPORTS \"  )  ;", "assertTrue (  \" Correct   propagation   behavior   set \"  ,     (  ( template . getPropagationBehavior (  )  )     =  =     ( TransactionDefinition . PROPAGATION _ SUPPORTS )  )  )  ;", "try    {", "template . setPropagationBehavior (  9  9  9  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "template . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ MANDATORY )  ;", "assertTrue (  \" Correct   propagation   behavior   set \"  ,     (  ( template . getPropagationBehavior (  )  )     =  =     ( TransactionDefinition . PROPAGATION _ MANDATORY )  )  )  ;", "try    {", "template . setIsolationLevelName (  \" TIMEOUT _ DEFAULT \"  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "template . setIsolationLevelName (  \" ISOLATION _ SERIALIZABLE \"  )  ;", "assertTrue (  \" Correct   isolation   level   set \"  ,     (  ( template . getIsolationLevel (  )  )     =  =     ( TransactionDefinition . ISOLATION _ SERIALIZABLE )  )  )  ;", "try    {", "template . setIsolationLevel (  9  9  9  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "template . setIsolationLevel ( TransactionDefinition . ISOLATION _ REPEATABLE _ READ )  ;", "assertTrue (  \" Correct   isolation   level   set \"  ,     (  ( template . getIsolationLevel (  )  )     =  =     ( TransactionDefinition . ISOLATION _ REPEATABLE _ READ )  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionTemplateInitialization"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "MockCallbackPreferringTransactionManager   ptm    =    new   MockCallbackPreferringTransactionManager (  )  ;", "TransactionTemplate   template    =    new   TransactionTemplate ( ptm )  ;", "template . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( tatus   status )     {", "}", "}  )  ;", "assertSame ( template ,    ptm . getDefinition (  )  )  ;", "assertFalse ( ptm . getStatus (  )  . isRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionTemplateWithCallbackPreference"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( false ,    true )  ;", "TransactionTemplate   template    =    new   TransactionTemplate ( tm )  ;", "try    {", "template . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( tatus   status )     {", "throw   new   Error (  \" Some   application   error \"  )  ;", "}", "}  )  ;", "fail (  \" Should   have   propagated   Error \"  )  ;", "}    catch    ( Error   err )     {", "assertTrue (  \" triggered   begin \"  ,    tm . begin )  ;", "assertTrue (  \" no   commit \"  ,     (  !  ( tm . commit )  )  )  ;", "assertTrue (  \" triggered   rollback \"  ,    tm . rollback )  ;", "assertTrue (  \" no   rollbackOnly \"  ,     (  !  ( tm . rollbackOnly )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["transactionTemplateWithError"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestTransactionManager   tm    =    new   TestTransactionManager ( false ,    true )  ;", "TransactionTemplate   template    =    new   TransactionTemplate ( tm )  ;", "final   RuntimeException   ex    =    new   RuntimeException (  \" Some   application   exception \"  )  ;", "try    {", "template . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( tatus   status )     {", "throw   ex ;", "}", "}  )  ;", "fail (  \" Should   have   propagated   RuntimeException \"  )  ;", "}    catch    ( RuntimeException   caught )     {", "assertTrue (  \" Correct   exception \"  ,     ( caught    =  =    ex )  )  ;", "assertTrue (  \" triggered   begin \"  ,    tm . begin )  ;", "assertTrue (  \" no   commit \"  ,     (  !  ( tm . commit )  )  )  ;", "assertTrue (  \" triggered   rollback \"  ,    tm . rollback )  ;", "assertTrue (  \" no   rollbackOnly \"  ,     (  !  ( tm . rollbackOnly )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["transactionTemplateWithException"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "final   TransactionSystemException   tex    =    new   TransactionSystemException (  \" system   exception \"  )  ;", "TestTransactionManager   tm    =    new   TestTransactionManager ( false ,    true )     {", "@ Override", "protected   void   doRollback ( DefaultTransactionStatus   status )     {", "super . doRollback ( status )  ;", "throw   tex ;", "}", "}  ;", "TransactionTemplate   template    =    new   TransactionTemplate ( tm )  ;", "final   RuntimeException   ex    =    new   RuntimeException (  \" Some   application   exception \"  )  ;", "try    {", "template . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "throw   ex ;", "}", "}  )  ;", "fail (  \" Should   have   propagated   RuntimeException \"  )  ;", "}    catch    ( RuntimeException   caught )     {", "assertTrue (  \" Correct   exception \"  ,     ( caught    =  =    tex )  )  ;", "assertTrue (  \" triggered   begin \"  ,    tm . begin )  ;", "assertTrue (  \" no   commit \"  ,     (  !  ( tm . commit )  )  )  ;", "assertTrue (  \" triggered   rollback \"  ,    tm . rollback )  ;", "assertTrue (  \" no   rollbackOnly \"  ,     (  !  ( tm . rollbackOnly )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["transactionTemplateWithRollbackException"], "fileName": "org.springframework.transaction.TransactionSupportTests"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationException ;", "}", "METHOD_END"], "methodName": ["getApplicationException"], "fileName": "org.springframework.transaction.TransactionSystemException"}, {"methodBody": ["METHOD_START", "{", "return    ( this . applicationException )     !  =    null    ?    this . applicationException    :    getCause (  )  ;", "}", "METHOD_END"], "methodName": ["getOriginalException"], "fileName": "org.springframework.transaction.TransactionSystemException"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( ex ,     \" Application   exception   must   not   be   null \"  )  ;", "if    (  ( this . application )     !  =    null )     {", "throw   new   IllegalState (  (  \" Already   holding   an   application   exception :     \"     +     ( this . application )  )  )  ;", "}", "this . application    =    ex ;", "}", "METHOD_END"], "methodName": ["initApplicationException"], "fileName": "org.springframework.transaction.TransactionSystemException"}, {"methodBody": ["METHOD_START", "{", "ComponentDefinicomponent    =    this . eventListener . getComponentDefini \" txAdvice \"  )  ;", "assertThat ( component ,    instanceOf ( BeanComponentDefiniclass )  )  ;", "}", "METHOD_END"], "methodName": ["componentEventReceived"], "fileName": "org.springframework.transaction.TxNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "reader . setEventListener ( this . eventListener )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" tTests . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.transaction.TxNamespaceHandlerEventTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ITestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTestBean"], "fileName": "org.springframework.transaction.TxNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   testBean    =    getTestBean (  )  ;", "CallCountingTransactionManager   ptm    =     (  ( CallCountingTransactionManager )     ( context . getBean (  \" Manager \"  )  )  )  ;", "assertEquals (  \" Should   not   have   any   started   s \"  ,     0  ,    ptm . begun )  ;", "testBean . getName (  )  ;", "assertTrue ( ptm . lastDefinition . isReadOnly (  )  )  ;", "assertEquals (  \" Should   have    1    started    \"  ,     1  ,    ptm . begun )  ;", "assertEquals (  \" Should   have    1    committed    \"  ,     1  ,    ptm . commits )  ;", "testBean . haveBirthday (  )  ;", "assertEquals (  \" Should   not   have   started   another    \"  ,     1  ,    ptm . begun )  ;", "try    {", "testBean . exceptional ( new   IllegalArgumentException (  \" foo \"  )  )  ;", "fail (  \" Should   NEVER   get   here \"  )  ;", "}    catch    ( Throwable   throwable )     {", "assertEquals (  \" Should   have   another   started    \"  ,     2  ,    ptm . begun )  ;", "assertEquals (  \" Should   have    1    rolled   back    \"  ,     1  ,    ptm . rollbacks )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeTransactional"], "fileName": "org.springframework.transaction.TxNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   bean    =    getTestBean (  )  ;", "assertTrue (  \" testBean   is   not   a   proxy \"  ,    AopUtils . isAopProxy ( bean )  )  ;", "}", "METHOD_END"], "methodName": ["isProxy"], "fileName": "org.springframework.transaction.TxNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionInterceptor   txInterceptor    =     (  ( TransactionInterceptor )     ( context . getBean (  \" txRollbackAdvice \"  )  )  )  ;", "TransactionAttributeSource   txAttrSource    =    txInterceptor . getTransactionAttributeSource (  )  ;", "TransactionAttribute   txAttr    =    txAttrSource . getTransactionAttribute ( getAgeMethod ,    ITestBean . class )  ;", "assertTrue (  \" should   be   configured   to   rollback   on   Exception \"  ,    txAttr . rollbackOn ( new   Exception (  )  )  )  ;", "txAttr    =    txAttrSource . getTransactionAttribute ( setAgeMethod ,    ITestBean . class )  ;", "assertFalse (  \" should   not   rollback   on   RuntimeException \"  ,    txAttr . rollbackOn ( new   RuntimeException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["rollbackRules"], "fileName": "org.springframework.transaction.TxNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   ClassPathXmlApplicationContext (  \" txNamespaceHandlerTests . xml \"  ,    getClass (  )  )  ;", "this . getAgeMethod    =    ITestBean . class . getMethod (  \" getAge \"  )  ;", "this . setAgeMethod    =    ITestBean . class . getMethod (  \" setAge \"  ,    int . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.transaction.TxNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( configurers )  )     {", "return ;", "}", "if    (  ( configurers . size (  )  )     >     1  )     {", "throw   new   IllegalStateException (  \" Only   one   er   may   exist \"  )  ;", "}", "er   configurer    =    configurers . iterator (  )  . next (  )  ;", "this . txManager    =    configurer . annotationDrivenTransactionManager (  )  ;", "}", "METHOD_END"], "methodName": ["setConfigurers"], "fileName": "org.springframework.transaction.annotation.AbstractTransactionManagementConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   TransactionalEventListenerFactory (  )  ;", "}", "METHOD_END"], "methodName": ["transactionalEventListenerFactory"], "fileName": "org.springframework.transaction.annotation.AbstractTransactionManagementConfiguration"}, {"methodBody": ["METHOD_START", "{", "for    ( TransactionAnnotationParser   annotationParser    :    this . annotationParsers )     {", "attr    =    annotationParser . parseTransactionAnnotation ( ae )  ;", "if    ( attr    !  =    null )     {", "return   attr ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["determineTransactionAttribute"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationTransactionAttributeSourceTests . TestBean 5  . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( method ,    AnnotationTransactionAttributeSourceTests . TestBean 5  . class )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "}", "METHOD_END"], "methodName": ["customClassAttributeDetected"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationTransactionAttributeSourceTests . TestBean 7  . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( method ,    AnnotationTransactionAttributeSourceTests . TestBean 7  . class )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "assertTrue ( actual . isReadOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["customClassAttributeWithReadOnlyOverrideDetected"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationTransactionAttributeSourceTests . TestInterface 9  . class . getMethod (  \" getAge \"  )  ;", "Transactional   annotation    =    AnnotationUtils . findAnnotation ( method ,    Transactional . class )  ;", "assertNull (  \" AnnotationUtils . findAnnotation   should   not   find    @ Transactional   for   TestBean 9  . getAge (  )  \"  ,    annotation )  ;", "annotation    =    AnnotationUtils . findAnnotation ( AnnotationTransactionAttributeSourceTests . TestBean 9  . class ,    Transactional . class )  ;", "assertNotNull (  \" AnnotationUtils . findAnnotation   failed   to   find    @ Transactional   for   TestBean 9  \"  ,    annotation )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( method ,    AnnotationTransactionAttributeSourceTests . TestBean 9  . class )  ;", "assertNotNull (  \" Failed   to   retrieve   TransactionAttribute   for   TestBean 9  . getAge (  )  \"  ,    actual )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "assertTrue ( actual . isReadOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["customClassAttributeWithReadOnlyOverrideOnInterface"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationTransactionAttributeSourceTests . TestBean 6  . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( method ,    AnnotationTransactionAttributeSourceTests . TestBean 6  . class )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "}", "METHOD_END"], "methodName": ["customMethodAttributeDetected"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationTransactionAttributeSourceTests . TestBean 8  . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( method ,    AnnotationTransactionAttributeSourceTests . TestBean 8  . class )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "assertTrue ( actual . isReadOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["customMethodAttributeWithReadOnlyOverrideDetected"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationTransactionAttributeSourceTests . TestInterface 1  0  . class . getMethod (  \" getAge \"  )  ;", "Transactional   annotation    =    AnnotationUtils . findAnnotation ( method ,    Transactional . class )  ;", "assertNotNull (  \" AnnotationUtils . findAnnotation   failed   to   find    @ Transactional   for   TestBean 1  0  . getAge (  )  \"  ,    annotation )  ;", "annotation    =    AnnotationUtils . findAnnotation ( AnnotationTransactionAttributeSourceTests . TestBean 1  0  . class ,    Transactional . class )  ;", "assertNull (  \" AnnotationUtils . findAnnotation   should   not   find    @ Transactional   for   TestBean 1  0  \"  ,    annotation )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( method ,    AnnotationTransactionAttributeSourceTests . TestBean 1  0  . class )  ;", "assertNotNull (  \" Failed   to   retrieve   TransactionAttribute   for   TestBean 1  0  . getAge (  )  \"  ,    actual )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "assertTrue ( actual . isReadOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["customMethodAttributeWithReadOnlyOverrideOnInterface"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationTransactionAttributeSourceTests . TestBean 4  . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( method ,    AnnotationTransactionAttributeSourceTests . TestBean 4  . class )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultsToClassTransactionAttribute"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationTransactionAttributeSourceTests . Empty . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "assertNull ( atas . getTransactionAttribute ( method ,    null )  )  ;", "assertNull ( atas . getTransactionAttribute ( method ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["nullOrEmpty"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationTransactionAttributeSourceTests . TestBean 3  . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( method ,    AnnotationTransactionAttributeSourceTests . TestBean 3  . class )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute (  \" Exception \"  )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "assertTrue ( actual . rollbackOn ( new   Exception (  )  )  )  ;", "assertFalse ( actual . rollbackOn ( new   IOException (  )  )  )  ;", "actual    =    atas . getTransactionAttribute ( method ,    method . getDeclaringClass (  )  )  ;", "rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute (  \" Exception \"  )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "assertTrue ( actual . rollbackOn ( new   Exception (  )  )  )  ;", "assertFalse ( actual . rollbackOn ( new   IOException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["rollbackRulesAreApplied"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationTransactionAttributeSourceTests . TestBean 1    tb    =    new   AnnotationTransactionAttributeSourceTests . TestBean 1  (  )  ;", "CallCountingTransactionManager   ptm    =    new   CallCountingTransactionManager (  )  ;", "AnnotationTransactionAttributeSource   tas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionInterceptor   ti    =    new   TransactionInterceptor ( ptm ,    tas )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setInterfaces ( AnnotationTransactionAttributeSourceTests . ITestBean 1  . class )  ;", "proxyFactory . addAdvice ( ti )  ;", "proxyFactory . setTarget ( tb )  ;", "AnnotationTransactionAttributeSourceTests . ITestBean 1    proxy    =     (  ( AnnotationTransactionAttributeSourceTests . ITestBean 1  )     ( proxyFactory . getProxy (  )  )  )  ;", "proxy . getAge (  )  ;", "assertEquals (  1  ,    ptm . commits )  ;", "AnnotationTransactionAttributeSourceTests . ITestBean 1    serializedProxy    =     (  ( AnnotationTransactionAttributeSourceTests . ITestBean 1  )     ( SerializationTestUtils . serializeAndDeserialize ( proxy )  )  )  ;", "serializedProxy . getAge (  )  ;", "Advised   advised    =     (  ( Advised )     ( serializedProxy )  )  ;", "TransactionInterceptor   serializedTi    =     (  ( TransactionInterceptor )     ( advised . getAdvisors (  )  [  0  ]  . getAdvice (  )  )  )  ;", "CallCountingTransactionManager   serializedPtm    =     (  ( CallCountingTransactionManager )     ( serializedTi . getTransactionManager (  )  )  )  ;", "assertEquals (  2  ,    serializedPtm . commits )  ;", "}", "METHOD_END"], "methodName": ["serializable"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   classMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSourceTests . TestBean 1    tb    =    new   AnnotationTransactionAttributeSourceTests . TestBean 1  (  )  ;", "ProxyFactory   pf    =    new   ProxyFactory ( tb )  ;", "pf . setProxyTargetClass ( true )  ;", "Object   proxy    =    pf . getProxy (  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( classMethod ,    proxy . getClass (  )  )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnCglibClassMethod"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   classMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( classMethod ,    AnnotationTransactionAttributeSourceTests . TestBean 1  . class )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnClassMethod"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   getAgeMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getAge \"  )  ;", "Method   getNameMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getName \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   getAgeAttr    =    atas . getTransactionAttribute ( getAgeMethod ,    AnnotationTransactionAttributeSourceTests . Ejb 3 AnnotatedBean 1  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRED ,    getAgeAttr . getPropagationBehavior (  )  )  ;", "TransactionAttribute   getNameAttr    =    atas . getTransactionAttribute ( getNameMethod ,    AnnotationTransactionAttributeSourceTests . Ejb 3 AnnotatedBean 1  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ SUPPORTS ,    getNameAttr . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnClassMethodWithEjb3"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   getAgeMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getAge \"  )  ;", "Method   getNameMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getName \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   getAgeAttr    =    atas . getTransactionAttribute ( getAgeMethod ,    AnnotationTransactionAttributeSourceTests . JtaAnnotatedBean 1  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRED ,    getAgeAttr . getPropagationBehavior (  )  )  ;", "TransactionAttribute   getNameAttr    =    atas . getTransactionAttribute ( getNameMethod ,    AnnotationTransactionAttributeSourceTests . JtaAnnotatedBean 1  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ SUPPORTS ,    getNameAttr . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnClassMethodWithJta"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   getAgeMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getAge \"  )  ;", "Method   getNameMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getName \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   getAgeAttr    =    atas . getTransactionAttribute ( getAgeMethod ,    AnnotationTransactionAttributeSourceTests . Ejb 3 AnnotatedBean 2  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRED ,    getAgeAttr . getPropagationBehavior (  )  )  ;", "TransactionAttribute   getNameAttr    =    atas . getTransactionAttribute ( getNameMethod ,    AnnotationTransactionAttributeSourceTests . Ejb 3 AnnotatedBean 2  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ SUPPORTS ,    getNameAttr . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnClassWithEjb3"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   getAgeMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getAge \"  )  ;", "Method   getNameMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getName \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   getAgeAttr    =    atas . getTransactionAttribute ( getAgeMethod ,    AnnotationTransactionAttributeSourceTests . JtaAnnotatedBean 2  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRED ,    getAgeAttr . getPropagationBehavior (  )  )  ;", "TransactionAttribute   getNameAttr    =    atas . getTransactionAttribute ( getNameMethod ,    AnnotationTransactionAttributeSourceTests . JtaAnnotatedBean 2  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ SUPPORTS ,    getNameAttr . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnClassWithJta"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   getAgeMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getAge \"  )  ;", "Method   getNameMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 1  . class . getMethod (  \" getName \"  )  ;", "Method   getMetaClassMethod    =    GroovyObject . class . getMethod (  \" getMetaClass \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   getAgeAttr    =    atas . getTransactionAttribute ( getAgeMethod ,    AnnotationTransactionAttributeSourceTests . GroovyTestBean . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRED ,    getAgeAttr . getPropagationBehavior (  )  )  ;", "TransactionAttribute   getNameAttr    =    atas . getTransactionAttribute ( getNameMethod ,    AnnotationTransactionAttributeSourceTests . GroovyTestBean . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRED ,    getNameAttr . getPropagationBehavior (  )  )  ;", "assertNull ( atas . getTransactionAttribute ( getMetaClassMethod ,    AnnotationTransactionAttributeSourceTests . GroovyTestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnGroovyClass"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   interfaceMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 2  . class . getMethod (  \" getAge \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( interfaceMethod ,    AnnotationTransactionAttributeSourceTests . TestBean 2  . class )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnInterfaceMethodOnly"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   getAgeMethod    =    AnnotationTransactionAttributeSourceTests . ITestEjb . class . getMethod (  \" getAge \"  )  ;", "Method   getNameMethod    =    AnnotationTransactionAttributeSourceTests . ITestEjb . class . getMethod (  \" getName \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   getAgeAttr    =    atas . getTransactionAttribute ( getAgeMethod ,    AnnotationTransactionAttributeSourceTests . Ejb 3 AnnotatedBean 3  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRED ,    getAgeAttr . getPropagationBehavior (  )  )  ;", "TransactionAttribute   getNameAttr    =    atas . getTransactionAttribute ( getNameMethod ,    AnnotationTransactionAttributeSourceTests . Ejb 3 AnnotatedBean 3  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ SUPPORTS ,    getNameAttr . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnInterfaceWithEjb3"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   getAgeMethod    =    AnnotationTransactionAttributeSourceTests . ITestEjb . class . getMethod (  \" getAge \"  )  ;", "Method   getNameMethod    =    AnnotationTransactionAttributeSourceTests . ITestEjb . class . getMethod (  \" getName \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   getAgeAttr    =    atas . getTransactionAttribute ( getAgeMethod ,    AnnotationTransactionAttributeSourceTests . JtaAnnotatedBean 3  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRED ,    getAgeAttr . getPropagationBehavior (  )  )  ;", "TransactionAttribute   getNameAttr    =    atas . getTransactionAttribute ( getNameMethod ,    AnnotationTransactionAttributeSourceTests . JtaAnnotatedBean 3  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ SUPPORTS ,    getNameAttr . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeDeclaredOnInterfaceWithJta"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   interfaceMethod    =    AnnotationTransactionAttributeSourceTests . ITestBean 3  . class . getMethod (  \" getAge \"  )  ;", "Method   interfaceMethod 2     =    AnnotationTransactionAttributeSourceTests . ITestBean 3  . class . getMethod (  \" getName \"  )  ;", "AnnotationTransactionAttributeSource   atas    =    new   AnnotationTransactionAttributeSource (  )  ;", "TransactionAttribute   actual    =    atas . getTransactionAttribute ( interfaceMethod ,    AnnotationTransactionAttributeSourceTests . TestBean 3  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRES _ NEW ,    actual . getPropagationBehavior (  )  )  ;", "assertEquals ( TransactionAttribute . ISOLATION _ REPEATABLE _ READ ,    actual . getIsolationLevel (  )  )  ;", "assertEquals (  5  ,    actual . getTimeout (  )  )  ;", "assertTrue ( actual . isReadOnly (  )  )  ;", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . getRollbackRules (  )  . add ( new   RollbackRuleAttribute ( Exception . class )  )  ;", "rbta . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute ( IOException . class )  )  ;", "assertEquals ( rbta . getRollbackRules (  )  ,     (  ( RuleBasedTransactionAttribute )     ( actual )  )  . getRollbackRules (  )  )  ;", "TransactionAttribute   actual 2     =    atas . getTransactionAttribute ( interfaceMethod 2  ,    AnnotationTransactionAttributeSourceTests . TestBean 3  . class )  ;", "assertEquals ( TransactionAttribute . PROPAGATION _ REQUIRED ,    actual 2  . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeOnTargetClassMethodOverridesAttributeOnInterfaceMethod"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( expectedCount ,    this . ptm . begun )  ;", "assertEquals ( expectedCount ,    this . ptm . commits )  ;", "}", "METHOD_END"], "methodName": ["assertGetTransactionAndCommitCount"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( expectedCount ,    this . ptm . begun )  ;", "assertEquals ( expectedCount ,    this . ptm . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["assertGetTransactionAndRollbackCount"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTarget ( new    . TestClassLevelOnly (  )  )  ;", "proxyFactory . addAdvice ( this . ti )  ;", ". TestClassLevelOnly   proxy    =     (  (  . TestClassLevelOnly )     ( proxyFactory . getProxy (  )  )  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  1  )  ;", "proxy . doSomethingElse (  )  ;", "assertGetTransactionAndCommitCount (  2  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  3  )  ;", "proxy . doSomethingElse (  )  ;", "assertGetTransactionAndCommitCount (  4  )  ;", "}", "METHOD_END"], "methodName": ["classLevelOnly"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTarget ( new    . SomeServiceImpl (  )  )  ;", "proxyFactory . addInterface (  . SomeService . class )  ;", "proxyFactory . addAdvice ( this . ti )  ;", ". SomeService   someService    =     (  (  . SomeService )     ( proxyFactory . getProxy (  )  )  )  ;", "someService . bar (  )  ;", "assertGetTransactionAndCommitCount (  1  )  ;", "someService . foo (  )  ;", "assertGetTransactionAndCommitCount (  2  )  ;", "someService . fooBar (  )  ;", "assertGetTransactionAndCommitCount (  3  )  ;", "}", "METHOD_END"], "methodName": ["crossClassInterfaceMethodLevelOnJdkProxy"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTarget ( new    . OtherServiceImpl (  )  )  ;", "proxyFactory . addInterface (  . OtherService . class )  ;", "proxyFactory . addAdvice ( this . ti )  ;", ". OtherService   otherService    =     (  (  . OtherService )     ( proxyFactory . getProxy (  )  )  )  ;", "otherService . foo (  )  ;", "assertGetTransactionAndCommitCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["crossClassInterfaceOnJdkProxy"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTarget ( new    . TestWithInterfaceImpl (  )  )  ;", "proxyFactory . addInterface (  . TestWithInterface . class )  ;", "proxyFactory . addAdvice ( this . ti )  ;", ". TestWithInterface   proxy    =     (  (  . TestWithInterface )     ( proxyFactory . getProxy (  )  )  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  1  )  ;", "proxy . doSomethingElse (  )  ;", "assertGetTransactionAndCommitCount (  2  )  ;", "proxy . doSomethingElse (  )  ;", "assertGetTransactionAndCommitCount (  3  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  4  )  ;", "}", "METHOD_END"], "methodName": ["withInterface"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTarget ( new    . TestWithMultiMethodOverride (  )  )  ;", "proxyFactory . addAdvice ( this . ti )  ;", ". TestWithMultiMethodOverride   proxy    =     (  (  . TestWithMultiMethodOverride )     ( proxyFactory . getProxy (  )  )  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  1  )  ;", "proxy . doSomethingElse (  )  ;", "assertGetTransactionAndCommitCount (  2  )  ;", "proxy . doSomethingCompletelyElse (  )  ;", "assertGetTransactionAndCommitCount (  3  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  4  )  ;", "}", "METHOD_END"], "methodName": ["withMultiMethodOverride"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTarget ( new    . TestWithRollback (  )  )  ;", "proxyFactory . addAdvice ( this . ti )  ;", ". TestWithRollback   proxy    =     (  (  . TestWithRollback )     ( proxyFactory . getProxy (  )  )  )  ;", "try    {", "proxy . doSomethingErroneous (  )  ;", "fail (  \" Should   throw   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertGetTransactionAndRollbackCount (  1  )  ;", "}", "try    {", "proxy . doSomethingElseErroneous (  )  ;", "fail (  \" Should   throw   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertGetTransactionAndRollbackCount (  2  )  ;", "}", "}", "METHOD_END"], "methodName": ["withRollback"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTarget ( new    . TestWithSingleMethodOverride (  )  )  ;", "proxyFactory . addAdvice ( this . ti )  ;", ". TestWithSingleMethodOverride   proxy    =     (  (  . TestWithSingleMethodOverride )     ( proxyFactory . getProxy (  )  )  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  1  )  ;", "proxy . doSomethingElse (  )  ;", "assertGetTransactionAndCommitCount (  2  )  ;", "proxy . doSomethingCompletelyElse (  )  ;", "assertGetTransactionAndCommitCount (  3  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  4  )  ;", "}", "METHOD_END"], "methodName": ["withSingleMethodOverride"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ProxyFactory   proxyFactory    =    new   ProxyFactory (  )  ;", "proxyFactory . setTarget ( new    . TestWithSingleMethodOverrideInverted (  )  )  ;", "proxyFactory . addAdvice ( this . ti )  ;", ". TestWithSingleMethodOverrideInverted   proxy    =     (  (  . TestWithSingleMethodOverrideInverted )     ( proxyFactory . getProxy (  )  )  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  1  )  ;", "proxy . doSomethingElse (  )  ;", "assertGetTransactionAndCommitCount (  2  )  ;", "proxy . doSomethingCompletelyElse (  )  ;", "assertGetTransactionAndCommitCount (  3  )  ;", "proxy . doSomething (  )  ;", "assertGetTransactionAndCommitCount (  4  )  ;", "}", "METHOD_END"], "methodName": ["withSingleMethodOverrideInverted"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( AnnotationTransactionNamespaceHandlerTests . TransactionalTestBean )     ( context . getBean (  \" testBean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTestBean"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationTransactionNamespaceHandlerTests . TransactionalTestBean   testBean    =    getTestBean (  )  ;", "CallCountingTransactionManager   ptm    =     (  ( CallCountingTransactionManager )     ( context . getBean (  \" transactionManager \"  )  )  )  ;", "assertEquals (  \" Should   not   have   any   started   transactions \"  ,     0  ,    ptm . begun )  ;", "testBean . findAllFoos (  )  ;", "assertEquals (  \" Should   have    1    started   transaction \"  ,     1  ,    ptm . begun )  ;", "assertEquals (  \" Should   have    1    committed   transaction \"  ,     1  ,    ptm . commits )  ;", "testBean . doSomething (  )  ;", "assertEquals (  \" Should   not   have   started   another   transaction \"  ,     1  ,    ptm . begun )  ;", "try    {", "testBean . exceptional ( new   IllegalArgumentException (  \" foo \"  )  )  ;", "fail (  \" Should   NEVER   get   here \"  )  ;", "}    catch    ( Throwable   throwable )     {", "assertEquals (  \" Should   have   another   started   transaction \"  ,     2  ,    ptm . begun )  ;", "assertEquals (  \" Should   have    1    rolled   back   transaction \"  ,     1  ,    ptm . rollbacks )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeTransactional"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationTransactionNamespaceHandlerTests . TransactionalTestBean   bean    =    getTestBean (  )  ;", "assertTrue (  \" testBean   is   not   a   proxy \"  ,    AopUtils . isAopProxy ( bean )  )  ;", "Map < String ,    Object >    services    =    this . context . getBeansWithAnnotation ( Service . class )  ;", "assertTrue (  \" Stereotype   annotation   not   visible \"  ,    services . containsKey (  \" testBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isProxy"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MBeanServer   server    =    ManagementFactory . getPlatformMBeanServer (  )  ;", "assertEquals (  \" done \"  ,    server . invoke ( ObjectName . getInstance (  \" test : type = TestBean \"  )  ,     \" doSomething \"  ,    new   Object [  0  ]  ,    new   St [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["mBeanExportAlsoWorks"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationTransactionNamespaceHandlerTests . TransactionalTestBean   testBean    =    getTestBean (  )  ;", "CallCountingTransactionManager   ptm    =     (  ( CallCountingTransactionManager )     ( context . getBean (  \" transactionManager \"  )  )  )  ;", "assertEquals (  \" Should   not   have   any   started   transactions \"  ,     0  ,    ptm . begun )  ;", "testBean . annotationsOnProtectedAreIgnored (  )  ;", "assertEquals (  \" Should   not   have   any   started   transactions \"  ,     0  ,    ptm . begun )  ;", "}", "METHOD_END"], "methodName": ["nonPublicMethodsNotAdvised"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . context . close (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . context . containsBean ( TransactionManagementConfigUtils . TRANSACTIONAL _ EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "assertEquals (  1  ,    this . context . getBeansOfType ( TransactionalEventListenerFactory . class )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionalEventListenerRegisteredProperly"], "fileName": "org.springframework.transaction.annotation.AnnotationTransactionNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Ejb 3 TransactionAnnotationParser . Ejb 3 TransactionAttribute ( ann . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseTransactionAnnotation"], "fileName": "org.springframework.transaction.annotation.Ejb3TransactionAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   AnnotationConfigApplicationContext (  . EnableAspectjTxConfig . class ,     . TxManagerConfig . class )  ;", "fail (  (  \" should   have   thrown   CNFE   when   trying   to   load   AnnotationTransactionAspect .     \"     +     \" Do   you   actually   have   aspects   on   the   classpath ?  \"  )  )  ;", "}    catch    ( Exception   ex )     {", "assertThat ( ex . getMessage (  )  ,    containsString (  \" AspectJTransactionManagementConfiguration \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["proxyTypeAspectJCausesRegistrationOfAnnotationTransactionAspect"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableTransactionManagementTests . Spr 1  1  9  1  5 Config . class )  ;", "EnableTransactionManagementTests . TransactionalTestBean   bean    =    ctx . getBean ( EnableTransactionManagementTests . TransactionalTestBean . class )  ;", "CallCountingTransactionManager   txManager    =    ctx . getBean (  \" qualifiedTransactionManager \"  ,    CallCountingTransactionManager . class )  ;", "bean . saveQualifiedFoo (  )  ;", "assertThat ( txManager . begun ,    equalTo (  1  )  )  ;", "assertThat ( txManager . commits ,    equalTo (  1  )  )  ;", "assertThat ( txManager . rollbacks ,    equalTo (  0  )  )  ;", "bean . saveQualifiedFooWithAttributeAlias (  )  ;", "assertThat ( txManager . begun ,    equalTo (  2  )  )  ;", "assertThat ( txManager . commits ,    equalTo (  2  )  )  ;", "assertThat ( txManager . rollbacks ,    equalTo (  0  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr11915TransactionManagerAsManualSingleton"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableTransactionManagementTests . Spr 1  4  3  2  2 ConfigB . class )  ;", "EnableTransactionManagementTests . TransactionalTestInterface   bean    =    ctx . getBean ( EnableTransactionManagementTests . TransactionalTestInterface . class )  ;", "CallCountingTransactionManager   txManager    =    ctx . getBean ( CallCountingTransactionManager . class )  ;", "bean . saveFoo (  )  ;", "bean . saveBar (  )  ;", "assertThat ( txManager . begun ,    equalTo (  2  )  )  ;", "assertThat ( txManager . commits ,    equalTo (  2  )  )  ;", "assertThat ( txManager . rollbacks ,    equalTo (  0  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr14322FindsOnInterfaceWithCglibProxy"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableTransactionManagementTests . Spr 1  4  3  2  2 ConfigA . class )  ;", "EnableTransactionManagementTests . TransactionalTestInterface   bean    =    ctx . getBean ( EnableTransactionManagementTests . TransactionalTestInterface . class )  ;", "CallCountingTransactionManager   txManager    =    ctx . getBean ( CallCountingTransactionManager . class )  ;", "bean . saveFoo (  )  ;", "bean . saveBar (  )  ;", "assertThat ( txManager . begun ,    equalTo (  2  )  )  ;", "assertThat ( txManager . commits ,    equalTo (  2  )  )  ;", "assertThat ( txManager . rollbacks ,    equalTo (  0  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["spr14322FindsOnInterfaceWithInterfaceProxy"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableTransactionManagementTests . EnableTxConfig . class ,    EnableTransactionManagementTests . TxManagerConfig . class )  ;", "EnableTransactionManagementTests . TransactionalTestBean   bean    =    ctx . getBean ( EnableTransactionManagementTests . TransactionalTestBean . class )  ;", "assertTrue (  \" testBean   is   not   a   proxy \"  ,    AopUtils . isAopProxy ( bean )  )  ;", "Map <  ?  ,     ?  >    services    =    ctx . getBeansWithAnnotation ( Service . class )  ;", "assertTrue (  \" Stereotype   annotation   not   visible \"  ,    services . containsKey (  \" testBean \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["transactionProxyIsCreated"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableTransactionManagementTests . ParentEnableTxConfig . class ,    EnableTransactionManagementTests . ChildEnableTxConfig . class ,    EnableTransactionManagementTests . TxManagerConfig . class )  ;", "EnableTransactionManagementTests . TransactionalTestBean   bean    =    ctx . getBean ( EnableTransactionManagementTests . TransactionalTestBean . class )  ;", "assertTrue (  \" testBean   is   not   a   proxy \"  ,    AopUtils . isAopProxy ( bean )  )  ;", "Map <  ?  ,     ?  >    services    =    ctx . getBeansWithAnnotation ( Service . class )  ;", "assertTrue (  \" Stereotype   annotation   not   visible \"  ,    services . containsKey (  \" testBean \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["transactionProxyIsCreatedWithEnableOnExcludedSuperclass"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableTransactionManagementTests . InheritedEnableTxConfig . class ,    EnableTransactionManagementTests . TxManagerConfig . class )  ;", "EnableTransactionManagementTests . TransactionalTestBean   bean    =    ctx . getBean ( EnableTransactionManagementTests . TransactionalTestBean . class )  ;", "assertTrue (  \" testBean   is   not   a   proxy \"  ,    AopUtils . isAopProxy ( bean )  )  ;", "Map <  ?  ,     ?  >    services    =    ctx . getBeansWithAnnotation ( Service . class )  ;", "assertTrue (  \" Stereotype   annotation   not   visible \"  ,    services . containsKey (  \" testBean \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["transactionProxyIsCreatedWithEnableOnSuperclass"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableTransactionManagementTests . EnableTxConfig . class )  ;", "assertTrue ( ctx . containsBean ( TransactionManagementConfigUtils . TRANSACTIONAL _ EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "assertEquals (  1  ,    ctx . getBeansOfType ( TransactionalEventListenerFactory . class )  . size (  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["transactionalEventListenerRegisteredProperly"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableTransactionManagementTests . EnableTxConfig . class ,    EnableTransactionManagementTests . MultiTxManagerConfig . class )  ;", "EnableTransactionManagementTests . TransactionalTestBean   bean    =    ctx . getBean ( EnableTransactionManagementTests . TransactionalTestBean . class )  ;", "bean . findAllFoos (  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["txManagerIsResolvedCorrectlyWhenMultipleManagersArePresent"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( EnableTransactionManagementTests . EnableTxConfig . class ,    EnableTransactionManagementTests . TxManagerConfig . class )  ;", "EnableTransactionManagementTests . TransactionalTestBean   bean    =    ctx . getBean ( EnableTransactionManagementTests . TransactionalTestBean . class )  ;", "bean . findAllFoos (  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["txManagerIsResolvedOnInvocationOfTransactionalMethod"], "fileName": "org.springframework.transaction.annotation.EnableTransactionManagementTests"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.transaction.annotation.Isolation"}, {"methodBody": ["METHOD_START", "{", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "rbta . setPropagationBehaviorName (  (  ( RuleBasedTransactionAttribute . PREFIX _ PROPAGATION )     +     ( attributes . getEnum (  \" value \"  )  . toString (  )  )  )  )  ;", "ArrayList < RollbackRuleAttribute >    rollBackRules    =    new   ArrayList <  >  (  )  ;", "Class <  ?  >  [  ]    rbf    =    attributes . getClassArray (  \" rollbackOn \"  )  ;", "for    ( Class <  ?  >    rbRule    :    rbf )     {", "RollbackRuleAttribute   rule    =    new   RollbackRuleAttribute ( rbRule )  ;", "rollBackRules . add ( rule )  ;", "}", "Class <  ?  >  [  ]    nrbf    =    attributes . getClassArray (  \" dontRollbackOn \"  )  ;", "for    ( Class <  ?  >    rbRule    :    nrbf )     {", "NoRollbackRuleAttribute   rule    =    new   NoRollbackRuleAttribute ( rbRule )  ;", "rollBackRules . add ( rule )  ;", "}", "rbta . getRollbackRules (  )  . addAll ( rollBackRules )  ;", "return   rbta ;", "}", "METHOD_END"], "methodName": ["parseTransactionAnnotation"], "fileName": "org.springframework.transaction.annotation.JtaTransactionAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "return   parseTransactionAnnotation ( AnnotationUtils . getAnnotationAttributes ( ann ,    false ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["parseTransactionAnnotation"], "fileName": "org.springframework.transaction.annotation.JtaTransactionAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.transaction.annotation.Propagation"}, {"methodBody": ["METHOD_START", "{", "BeanFactoryTransactionAttributeSourceAdvisor   advisor    =    new   BeanFactoryTransactionAttributeSourceAdvisor (  )  ;", "advisor . setTransactionAttributeSource ( transactionAttributeSource (  )  )  ;", "advisor . setAdvice ( transactionInterceptor (  )  )  ;", "if    (  ( this . enableTx )     !  =    null )     {", "advisor . setOrder ( this . enableTx .  < Integer > getNumber (  \" order \"  )  )  ;", "}", "return   advisor ;", "}", "METHOD_END"], "methodName": ["transactionAdvisor"], "fileName": "org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   AnnotationTransactionAttributeSource (  )  ;", "}", "METHOD_END"], "methodName": ["transactionAttributeSource"], "fileName": "org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration"}, {"methodBody": ["METHOD_START", "{", "TransactionInterceptor   interceptor    =    new   TransactionInterceptor (  )  ;", "interceptor . setTransactionAttributeSource ( transactionAttributeSource (  )  )  ;", "if    (  ( this . txManager )     !  =    null )     {", "interceptor . setr ( this . txManager )  ;", "}", "return   interceptor ;", "}", "METHOD_END"], "methodName": ["transactionInterceptor"], "fileName": "org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration"}, {"methodBody": ["METHOD_START", "{", "RuleBasedTransactionAttribute   rbta    =    new   RuleBasedTransactionAttribute (  )  ;", "Propagation   propagation    =    attributes . getEnum (  \" propagation \"  )  ;", "rbta . setPropagationBehavior ( propagation . value (  )  )  ;", "Isolation   isolation    =    attributes . getEnum (  \" isolation \"  )  ;", "rbta . setIsolationLevel ( isolation . value (  )  )  ;", "rbta . setTimeout ( attributes . getNumber (  \" timeout \"  )  . intValue (  )  )  ;", "rbta . setReadOnly ( attributes . getBoolean (  \" readOnly \"  )  )  ;", "rbta . setQualifier ( attributes . getString (  \" value \"  )  )  ;", "ArrayList < RollbackRuleAttribute >    rollBackRules    =    new   ArrayList <  >  (  )  ;", "Class <  ?  >  [  ]    rbf    =    attributes . getClassArray (  \" rollbackFor \"  )  ;", "for    ( Class <  ?  >    rbRule    :    rbf )     {", "RollbackRuleAttribute   rule    =    new   RollbackRuleAttribute ( rbRule )  ;", "rollBackRules . add ( rule )  ;", "}", "String [  ]    rbfc    =    attributes . getStringArray (  \" rollbackForClassName \"  )  ;", "for    ( String   rbRule    :    rbfc )     {", "RollbackRuleAttribute   rule    =    new   RollbackRuleAttribute ( rbRule )  ;", "rollBackRules . add ( rule )  ;", "}", "Class <  ?  >  [  ]    nrbf    =    attributes . getClassArray (  \" noRollbackFor \"  )  ;", "for    ( Class <  ?  >    rbRule    :    nrbf )     {", "NoRollbackRuleAttribute   rule    =    new   NoRollbackRuleAttribute ( rbRule )  ;", "rollBackRules . add ( rule )  ;", "}", "String [  ]    nrbfc    =    attributes . getStringArray (  \" noRollbackForClassName \"  )  ;", "for    ( String   rbRule    :    nrbfc )     {", "NoRollbackRuleAttribute   rule    =    new   NoRollbackRuleAttribute ( rbRule )  ;", "rollBackRules . add ( rule )  ;", "}", "rbta . getRollbackRules (  )  . addAll ( rollBackRules )  ;", "return   rbta ;", "}", "METHOD_END"], "methodName": ["parseTransactionAnnotation"], "fileName": "org.springframework.transaction.annotation.SpringTransactionAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "return   parseTransactionAnnotation ( AnnotationUtils . getAnnotationAttributes ( ann ,    false ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["parseTransactionAnnotation"], "fileName": "org.springframework.transaction.annotation.SpringTransactionAnnotationParser"}, {"methodBody": ["METHOD_START", "{", "String   txAspectBeanName    =    TransactionManagementConfigUtils . TRANSACTION _ ASPECT _ BEAN _ NAME ;", "String   txAspectClassName    =    TransactionManagementConfigUtils . TRANSACTION _ ASPECT _ CLASS _ NAME ;", "if    (  !  ( parserContext . getRegistry (  )  . containsBeanDefinition ( txAspectBeanName )  )  )     {", "RootBeanDefinition   def    =    new   RootBeanDefinition (  )  ;", "def . setBeanClassName ( txAspectClassName )  ;", "def . setFactoryMethodName (  \" aspectOf \"  )  ;", ". registerTransactionManager ( element ,    def )  ;", "parserContext . registerBeanComponent ( new   BeanComponentDefinition ( def ,    txAspectBeanName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerTransactionAspect"], "fileName": "org.springframework.transaction.config.AnnotationDrivenBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "def . getPropertyValues (  )  . add (  \" transactionManagerBeanName \"  ,    TxNamespaceHandler . getTransactionManagerName ( element )  )  ;", "}", "METHOD_END"], "methodName": ["registerTransactionManager"], "fileName": "org.springframework.transaction.config.AnnotationDrivenBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   def    =    new   RootBeanDefinition (  )  ;", "def . setBeanClass ( TransactionalEventListenerFactory . class )  ;", "parserContext . registerBeanComponent ( new   beans . factory . parsing . BeanComponentDefinition ( def ,    TransactionManagementConfigUtils . TRANSACTIONAL _ EVENT _ LISTENER _ FACTORY _ BEAN _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["registerTransactionalEventListenerFactory"], "fileName": "org.springframework.transaction.config.AnnotationDrivenBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "CallCountingTransactionManager   tm 1     =    context . getBean (  \" transactionManager 1  \"  ,    CallCountingTransactionManager . class )  ;", "CallCountingTransactionManager   tm 2     =    context . getBean (  \" transactionManager 2  \"  ,    CallCountingTransactionManager . class )  ;", "TransactionalService   service    =    context . getBean (  \" service \"  ,    TransactionalService . class )  ;", "assertTrue ( AopUtils . isCglibProxy ( service )  )  ;", "service . setSomething (  \" someName \"  )  ;", "assertEquals (  1  ,    tm 1  . commits )  ;", "assertEquals (  0  ,    tm 2  . commits )  ;", "service . doSomething (  )  ;", "assertEquals (  1  ,    tm 1  . commits )  ;", "assertEquals (  1  ,    tm 2  . commits )  ;", "service . setSomething (  \" someName \"  )  ;", "assertEquals (  2  ,    tm 1  . commits )  ;", "assertEquals (  1  ,    tm 2  . commits )  ;", "service . doSomething (  )  ;", "assertEquals (  2  ,    tm 1  . commits )  ;", "assertEquals (  2  ,    tm 2  . commits )  ;", "}", "METHOD_END"], "methodName": ["doTestWithMultipleTransactionManagers"], "fileName": "org.springframework.transaction.config.AnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" annotationDrivenProxyTargetClassTests . xml \"  ,    getClass (  )  )  ;", "TransactionalService   service    =    context . getBean (  \" service \"  ,    TransactionalService . class )  ;", "service . setSomething (  \" someName \"  )  ;", "service    =     (  ( TransactionalService )     ( SerializationTestUtils . serializeAndDeserialize ( service )  )  )  ;", "service . setSomething (  \" someName \"  )  ;", "}", "METHOD_END"], "methodName": ["serializableWithPreviousUsage"], "fileName": "org.springframework.transaction.config.AnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" annotationDrivenProxyTargetClassTests . xml \"  ,    getClass (  )  )  ;", "TransactionalService   service    =    context . getBean (  \" service \"  ,    TransactionalService . class )  ;", "service    =     (  ( TransactionalService )     ( SerializationTestUtils . serializeAndDeserialize ( service )  )  )  ;", "service . setSomething (  \" someName \"  )  ;", "}", "METHOD_END"], "methodName": ["serializableWithoutPreviousUsage"], "fileName": "org.springframework.transaction.config.AnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   parent    =    new   AnnotationConfigApplicationContext (  )  ;", "parent . registerBeanDefinition (  \" transactionManager 1  \"  ,    new   RootBeanDefinition ( SynchTransactionManager . class )  )  ;", "parent . registerBeanDefinition (  \" transactionManager 2  \"  ,    new   RootBeanDefinition ( NoSynchTransactionManager . class )  )  ;", "parent . refresh (  )  ;", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext ( new   String [  ]  {     \" aConfigurationClassTests . xml \"     }  ,    getClass (  )  ,    parent )  ;", "doTestWithMultipleTransactionManagers ( context )  ;", "}", "METHOD_END"], "methodName": ["withAnnotatedTransactionManagers"], "fileName": "org.springframework.transaction.config.AnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   parent    =    new   AnnotationConfigApplicationContext ( TransactionManagerConfiguration . class )  ;", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext ( new   String [  ]  {     \" aConfigurationClassTests . xml \"     }  ,    getClass (  )  ,    parent )  ;", "doTestWithMultipleTransactionManagers ( context )  ;", "}", "METHOD_END"], "methodName": ["withConfigurationClass"], "fileName": "org.springframework.transaction.config.AnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" annotationDrivenProxyTargetClassTests . xml \"  ,    getClass (  )  )  ;", "doTestWithMultipleTransactionManagers ( context )  ;", "}", "METHOD_END"], "methodName": ["withProxyTargetClass"], "fileName": "org.springframework.transaction.config.AnnotationDrivenTests"}, {"methodBody": ["METHOD_START", "{", "if    ( JtaTransactionManagerFactoryBean . weblogicPresent )     {", "return   JtaTransactionManagerFactoryBean . WEBLOGIC _ JTA _ TRANSACTION _ MANAGER _ CLASS _ NAME ;", "} else", "if    ( JtaTransactionManagerFactoryBean . webspherePresent )     {", "return   JtaTransactionManagerFactoryBean . WEBSPHERE _ TRANSACTION _ MANAGER _ CLASS _ NAME ;", "} else    {", "return   JtaTransactionManagerFactoryBean . JTA _ TRANSACTION _ MANAGER _ CLASS _ NAME ;", "}", "}", "METHOD_END"], "methodName": ["resolveJtaTransactionManagerClassName"], "fileName": "org.springframework.transaction.config.JtaTransactionManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   new   CallCountingTransactionManager (  )  ;", "}", "METHOD_END"], "methodName": ["transactionManager1"], "fileName": "org.springframework.transaction.config.TransactionManagerConfiguration"}, {"methodBody": ["METHOD_START", "{", "CallCountingTransactionManager   tm    =    new   CallCountingTransactionManager (  )  ;", "tm . setTransactionSynchronization ( CallCountingTransactionManager . SYNCHRONIZATION _ NEVER )  ;", "return   tm ;", "}", "METHOD_END"], "methodName": ["transactionManager2"], "fileName": "org.springframework.transaction.config.TransactionManagerConfiguration"}, {"methodBody": ["METHOD_START", "{", "String [  ]    exceptionTypeNames    =    StringUtils . commaDelimitedListToStringArray ( noRollbackForValue )  ;", "for    ( String   typeName    :    exceptionTypeNames )     {", "rollbackRules . add ( new   NoRollbackRuleAttribute ( StringUtils . trimWhitespace ( typeName )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addNoRollbackRuleAttributesTo"], "fileName": "org.springframework.transaction.config.TxAdviceBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String [  ]    exceptionTypeNames    =    StringUtils . commaDelimitedListToStringArray ( rollbackForValue )  ;", "for    ( String   typeName    :    exceptionTypeNames )     {", "rollbackRules . add ( new   RollbackRuleAttribute ( StringUtils . trimWhitespace ( typeName )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addRollbackRuleAttributesTo"], "fileName": "org.springframework.transaction.config.TxAdviceBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "List < Element >    methods    =    DomUtils . getChildElementsByTagName ( attrEle ,    TxAdviceBeanDefinitionParser . METHOD _ ELEMENT )  ;", "ManagedMap < TypedStringValue ,    RuleBasedTransactionAttribute >    transactionAttributeMap    =    new   ManagedMap ( methods . size (  )  )  ;", "transactionAttributeMap . setSource ( parserContext . extractSource ( attrEle )  )  ;", "for    ( Element   methodEle    :    methods )     {", "String   name    =    methodEle . getAttribute ( TxAdviceBeanDefinitionParser . METHOD _ NAME _ ATTRIBUTE )  ;", "TypedStringValue   nameHolder    =    new   TypedStringValue ( name )  ;", "nameHolder . setSource ( parserContext . extractSource ( methodEle )  )  ;", "RuleBasedTransactionAttribute   attribute    =    new   RuleBasedTransactionAttribute (  )  ;", "String   propagation    =    methodEle . getAttribute ( TxAdviceBeanDefinitionParser . PROPAGATION _ ATTRIBUTE )  ;", "String   isolation    =    methodEle . getAttribute ( TxAdviceBeanDefinitionParser . ISOLATION _ ATTRIBUTE )  ;", "String   timeout    =    methodEle . getAttribute ( TxAdviceBeanDefinitionParser . TIMEOUT _ ATTRIBUTE )  ;", "String   readOnly    =    methodEle . getAttribute ( TxAdviceBeanDefinitionParser . READ _ ONLY _ ATTRIBUTE )  ;", "if    ( StringUtils . hasText ( propagation )  )     {", "attribute . setPropagationBehaviorName (  (  ( RuleBasedTransactionAttribute . PREFIX _ PROPAGATION )     +    propagation )  )  ;", "}", "if    ( StringUtils . hasText ( isolation )  )     {", "attribute . setIsolationLevelName (  (  ( RuleBasedTransactionAttribute . PREFIX _ ISOLATION )     +    isolation )  )  ;", "}", "if    ( StringUtils . hasText ( timeout )  )     {", "try    {", "attribute . setTimeout ( Integer . parseInt ( timeout )  )  ;", "}    catch    ( NumberFormatException   ex )     {", "parserContext . getReaderContext (  )  . error (  (  (  \" Timeout   must   be   an   integer   value :     [  \"     +    timeout )     +     \"  ]  \"  )  ,    methodEle )  ;", "}", "}", "if    ( StringUtils . hasText ( readOnly )  )     {", "attribute . setReadOnly ( Boolean . valueOf ( methodEle . getAttribute ( TxAdviceBeanDefinitionParser . READ _ ONLY _ ATTRIBUTE )  )  )  ;", "}", "List < RollbackRuleAttribute >    rollbackRules    =    new   LinkedList <  >  (  )  ;", "if    ( methodEle . hasAttribute ( TxAdviceBeanDefinitionParser . ROLLBACK _ FOR _ ATTRIBUTE )  )     {", "String   rollbackForValue    =    methodEle . getAttribute ( TxAdviceBeanDefinitionParser . ROLLBACK _ FOR _ ATTRIBUTE )  ;", "addRollbackRuleAttributesTo ( rollbackRules ,    rollbackForValue )  ;", "}", "if    ( methodEle . hasAttribute ( TxAdviceBeanDefinitionParser . NO _ ROLLBACK _ FOR _ ATTRIBUTE )  )     {", "String   noRollbackForValue    =    methodEle . getAttribute ( TxAdviceBeanDefinitionParser . NO _ ROLLBACK _ FOR _ ATTRIBUTE )  ;", "addNoRollbackRuleAttributesTo ( rollbackRules ,    noRollbackForValue )  ;", "}", "attribute . setRollbackRules ( rollbackRules )  ;", "transactionAttributeMap . put ( nameHolder ,    attribute )  ;", "}", "RootBeanDefinition   attributeSourceDefinition    =    new   RootBeanDefinition ( NameMatchTransactionAttributeSource . class )  ;", "attributeSourceDefinition . setSource ( parserContext . extractSource ( attrEle )  )  ;", "attributeSourceDefinition . getPropertyValues (  )  . add (  \" nameMap \"  ,    transactionAttributeMap )  ;", "return   attributeSourceDefinition ;", "}", "METHOD_END"], "methodName": ["parseAttributeSource"], "fileName": "org.springframework.transaction.config.TxAdviceBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   element . hasAttribute ( TxNamespaceHandler . TRANSACTION _ MANAGER _ ATTRIBUTE )     ?    element . getAttribute ( TxNamespaceHandler . TRANSACTION _ MANAGER _ ATTRIBUTE )     :    TxNamespaceHandler . DEFAULT _ TRANSACTION _ MANAGER _ BEAN _ NAME ;", "}", "METHOD_END"], "methodName": ["getTransactionManagerName"], "fileName": "org.springframework.transaction.config.TxNamespaceHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   ApplicationListenerMethodTransactionalAdapter . TransactionSynchronizationEventAdapter ( this ,    event ,    this . annotation . phase (  )  )  ;", "}", "METHOD_END"], "methodName": ["createTransactionSynchronization"], "fileName": "org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapter"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Method   must   not   be   null \"  ,    method )  ;", "EventListener   annotation    =    AnnotatedElementUtils . findMergedAnnotation ( method ,    EventListener . class )  ;", "assertEquals (  (  (  \" Wrong   phase   for    '  \"     +    method )     +     \"  '  \"  )  ,    expected ,    annotation . phase (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertPhase"], "fileName": "org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapterTests"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forClassWithGenerics ( PayloadApplicationEvent . class ,    payloadType )  ;", "}", "METHOD_END"], "methodName": ["createGenericEventType"], "fileName": "org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapterTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ApplicationListenerMethodTransactionalAdapter (  \" test \"  ,    ApplicationListenerMethodTransactionalAdapterTests . SampleEvents . class ,    m )  ;", "}", "METHOD_END"], "methodName": ["createTestInstance"], "fileName": "org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( ApplicationListenerMethodTransactionalAdapterTests . SampleEvents . class ,     \" defaultPhase \"  ,    String . class )  ;", "assertPhase ( m ,    TransactionPhase . AFTER _ COMMIT )  ;", "}", "METHOD_END"], "methodName": ["defaultPhase"], "fileName": "org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( ApplicationListenerMethodTransactionalAdapterTests . SampleEvents . class ,     \" phaseAndClassesSet \"  )  ;", "assertPhase ( m ,    TransactionPhase . AFTER _ COMPLETION )  ;", "supportsEventType ( true ,    m ,    createGenericEventType ( String . class )  )  ;", "supportsEventType ( true ,    m ,    createGenericEventType ( Integer . class )  )  ;", "supportsEventType ( false ,    m ,    createGenericEventType ( Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["phaseAndClassesSet"], "fileName": "org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( ApplicationListenerMethodTransactionalAdapterTests . SampleEvents . class ,     \" phaseSet \"  ,    String . class )  ;", "assertPhase ( m ,    TransactionPhase . AFTER _ ROLLBACK )  ;", "}", "METHOD_END"], "methodName": ["phaseSet"], "fileName": "org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapterTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationListenerMethodAdapter   adapter    =    createTestInstance ( method )  ;", "assertEquals (  (  (  (  \" Wrong   match   for   event    '  \"     +    eventType )     +     \"  '    on    \"  )     +    method )  ,    match ,    adapter . supportsEventType ( eventType )  )  ;", "}", "METHOD_END"], "methodName": ["supportsEventType"], "fileName": "org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectionUtils . findMethod ( ApplicationListenerMethodTransactionalAdapterTests . SampleEvents . class ,     \" valueSet \"  )  ;", "assertPhase ( m ,    TransactionPhase . AFTER _ COMMIT )  ;", "supportsEventType ( true ,    m ,    createGenericEventType ( String . class )  )  ;", "supportsEventType ( false ,    m ,    createGenericEventType ( Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["valueSet"], "fileName": "org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapterTests"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerFactory"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . AfterCompletionExplicitTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . AFTER _ COMMIT ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["afterCommit"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . AfterCommitMetaAnnotationTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . AFTER _ COMMIT ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["afterCommitMetaAnnotation"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . TransactionalConfiguration . class ,    TransactionalEventListenerTests . TransactionalComponentTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" SKIP \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "}", "METHOD_END"], "methodName": ["afterCommitWithTransactionalComponentListenerProxiedViaDynamicProxy"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . AfterCompletionTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . AFTER _ COMPLETION ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["afterCompletionCommit"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . AfterCompletionTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "status . setRollbackOnly (  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . AFTER _ COMPLETION ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["afterCompletionRollback"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . AfterCompletionExplicitTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "status . setRollbackOnly (  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . AFTER _ ROLLBACK ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["afterRollback"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . BeforeCommitTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionalEventListenerTests . EventTransactionSynchronization (  1  0  )     {", "@ Override", "public   void   beforeCommit ( boolean   readOnly )     {", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "}", "}  )  ;", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionalEventListenerTests . EventTransactionSynchronization (  2  0  )     {", "@ Override", "public   void   beforeCommit ( boolean   readOnly )     {", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . BEFORE _ COMMIT ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "}", "}  )  ;", "getContext (  )  . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . BEFORE _ COMMIT ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["beforeCommit"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . BeforeCommitTestListener . class )  ;", "try    {", "this . transactionTemplate . execute (  (    status )     -  >     {", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionalEventListenerTests . EventTransactionSynchronization (  1  0  )     {", "@ Override", "public   void   beforeCommit ( boolean   readOnly )     {", "throw   new   IllegalStateException (  \" test \"  )  ;", "}", "}  )  ;", "getContext (  )  . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "return   null ;", "}  )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "}", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "}", "METHOD_END"], "methodName": ["beforeCommitWithException"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . context )     !  =    null )     {", "this . context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeContext"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . AfterCommitMetaAnnotationTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" SKIP \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "}", "METHOD_END"], "methodName": ["conditionFoundOnMetaAnnotation"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . ImmediateTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" SKIP \"  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertNoEventReceived (  )  ;", "}", "METHOD_END"], "methodName": ["conditionFoundOnTransactionalEventListener"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   AnnotationConfigApplicationContext ( classes )  ;", "this . eventCollector    =    this . context . getBean (  . EventCollector . class )  ;", "}", "METHOD_END"], "methodName": ["doLoad"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "return   context ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "return   eventCollector ;", "}", "METHOD_END"], "methodName": ["getEventCollector"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . ImmediateTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . IMMEDIATELY ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . IMMEDIATELY ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["immediately"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . ImmediateTestListener . class ,    TransactionalEventListenerTests . BeforeCommitTestListener . class )  ;", "try    {", "this . transactionTemplate . execute (  (    status )     -  >     {", "getContext (  )  . publishEvent (  \" FAIL \"  )  ;", "fail (  \" Should   have   thrown   an   exception   at   this   point \"  )  ;", "return   null ;", "}  )  ;", "}    catch    ( IllegalStateException   e )     {", "assertTrue ( e . getMessage (  )  . contains (  \" Test   exception \"  )  )  ;", "assertTrue ( e . getMessage (  )  . contains ( TransactionalEventListenerTests . EventCollector . IMMEDIATELY )  )  ;", "}", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . IMMEDIATELY ,     \" FAIL \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "}", "METHOD_END"], "methodName": ["immediatelyImpactsCurrentTransaction"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    allClasses    =    new   ArrayList <  >  (  )  ;", "allClasses . add (  . BasicConfiguration . class )  ;", "allClasses . addAll ( Arrays . asList ( classes )  )  ;", "doLoad ( allClasses . toArray ( new   Class <  ?  >  [ allClasses . size (  )  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . BeforeCommitTestListener . class ,    TransactionalEventListenerTests . AfterCompletionTestListener . class ,    TransactionalEventListenerTests . AfterCompletionExplicitTestListener . class )  ;", "this . context . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  0  )  ;", "}", "METHOD_END"], "methodName": ["noTransaction"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . FallbackExecutionTestListener . class )  ;", "this . context . publishEvent (  \" test \"  )  ;", "this . eventCollector . assertEvents ( TransactionalEventListenerTests . EventCollector . BEFORE _ COMMIT ,     \" test \"  )  ;", "this . eventCollector . assertEvents ( TransactionalEventListenerTests . EventCollector . AFTER _ COMMIT ,     \" test \"  )  ;", "this . eventCollector . assertEvents ( TransactionalEventListenerTests . EventCollector . AFTER _ ROLLBACK ,     \" test \"  )  ;", "this . eventCollector . assertEvents ( TransactionalEventListenerTests . EventCollector . AFTER _ COMPLETION ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  4  )  ;", "}", "METHOD_END"], "methodName": ["noTransactionWithFallbackExecution"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "load ( TransactionalEventListenerTests . ImmediateTestListener . class ,    TransactionalEventListenerTests . BeforeCommitTestListener . class ,    TransactionalEventListenerTests . AfterCompletionExplicitTestListener . class )  ;", "this . transactionTemplate . execute (  (    status )     -  >     {", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionalEventListenerTests . EventTransactionSynchronization (  1  0  )     {", "@ Override", "public   void   beforeCommit ( boolean   readOnly )     {", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . IMMEDIATELY ,     \" test \"  )  ;", "}", "}  )  ;", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionalEventListenerTests . EventTransactionSynchronization (  2  0  )     {", "@ Override", "public   void   beforeCommit ( boolean   readOnly )     {", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . BEFORE _ COMMIT ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  2  )  ;", "}", "}  )  ;", "getContext (  )  . publishEvent (  \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  1  )  ;", "return   null ;", "}  )  ;", "getEventCollector (  )  . assertEvents ( TransactionalEventListenerTests . EventCollector . AFTER _ COMMIT ,     \" test \"  )  ;", "getEventCollector (  )  . assertTotalEventsCount (  3  )  ;", "}", "METHOD_END"], "methodName": ["regularTransaction"], "fileName": "org.springframework.transaction.event.TransactionalEventListenerTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["allowPublicMethodsOnly"], "fileName": "org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( allowPublicMethodsOnly (  )  )     &  &     (  !  ( Modifier . isPublic ( method . getModifiers (  )  )  )  )  )     {", "return   null ;", "}", "Method   specificMethod    =    AopUtils . getMostSpecificMethod ( method ,    targetClass )  ;", "txAttr    =    find ( specificMethod )  ;", "if    ( txAttr    !  =    null )     {", "return   txAttr ;", "}", "txAttr    =    find ( specificMethod . getDeclaringClass (  )  )  ;", "if    (  ( txAttr    !  =    null )     &  &     ( ClassUtils . isUserLevelMethod ( method )  )  )     {", "return   txAttr ;", "}", "if    ( specificMethod    !  =    method )     {", "txAttr    =    find ( method )  ;", "if    ( txAttr    !  =    null )     {", "return   txAttr ;", "}", "txAttr    =    find ( method . getDeclaringClass (  )  )  ;", "if    (  ( txAttr    !  =    null )     &  &     ( ClassUtils . isUserLevelMethod ( method )  )  )     {", "return   txAttr ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["computeTransactionAttribute"], "fileName": "org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodClassKey ( method ,    targetClass )  ;", "}", "METHOD_END"], "methodName": ["getCacheKey"], "fileName": "org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "return   advised ( target ,    ptm ,    new   CompositeTransactionAttributeSource ( tas )  )  ;", "}", "METHOD_END"], "methodName": ["advised"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )  ;", "Method   m    =    setNameMethod ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( m ,    txatt )  ;", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "TransactionStatus   status    =    mock ( TransactionStatus . class )  ;", "given ( ptm . getTransaction ( txatt )  )  . willReturn ( status )  ;", "UnexpectedRollbackException   ex    =    new   UnexpectedRollbackException (  \" foobar \"  ,    null )  ;", "willThrow ( ex )  . given ( ptm )  . commit ( status )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    tas )  )  )  ;", "String   name    =     \" new   name \"  ;", "try    {", "itb . setName ( name )  ;", "fail (  \" Shouldn ' t   have   succeeded \"  )  ;", "}    catch    ( UnexpectedRollbackException   thrown )     {", "assertTrue (  ( thrown    =  =    ex )  )  ;", "}", "assertTrue (  (  ( itb . getName (  )  )     =  =    name )  )  ;", "}", "METHOD_END"], "methodName": ["cannotCommitTransaction"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )  ;", "Method   m    =    getNameMethod ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( m ,    txatt )  ;", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "CannotCreateTransactionException   ex    =    new   CannotCreateTransactionException (  \" foobar \"  ,    null )  ;", "given ( ptm . getTransaction ( txatt )  )  . willThrow ( ex )  ;", "TestBean   tb    =    new   TestBean (  )     {", "@ Override", "public   String   getName (  )     {", "throw   new   UnsupportedOperationException (  \" Shouldn ' t   have   invoked   target   method   when   couldn ' t   create   transaction   for   transactional   method \"  )  ;", "}", "}  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    tas )  )  )  ;", "try    {", "itb . getName (  )  ;", "fail (  \" Shouldn ' t   have   invoked   method \"  )  ;", "}    catch    ( CannotCreateTransactionException   thrown )     {", "assertTrue (  ( thrown    =  =    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cannotCreateTransaction"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "TransactionInterceptor . currenStatus (  )  ;", "if    (  ! expected )     {", "fail (  \" Should   have   thrown   NoTransactionException \"  )  ;", "}", "}    catch    ( NoTransactionException   ex )     {", "if    ( expected )     {", "fail (  \" Should   have   current   TransactionStatus \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkTransactionStatus"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )     {", "@ Override", "public   boolean   rollbackOn ( Throwable   t )     {", "assertTrue (  ( t    =  =    ex )  )  ;", "return   shouldRollback ;", "}", "}  ;", "Method   m    =    exceptionalMethod ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( m ,    txatt )  ;", "TransactionStatus   status    =    mock ( TransactionStatus . class )  ;", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "given ( ptm . getTransaction ( txatt )  )  . willReturn ( status )  ;", "TransactionSystemException   tex    =    new   TransactionSystemException (  \" system   exception \"  )  ;", "if    ( rollbackException )     {", "if    ( shouldRollback )     {", "willThrow ( tex )  . given ( ptm )  . rollback ( status )  ;", "} else    {", "willThrow ( tex )  . given ( ptm )  . commit ( status )  ;", "}", "}", "TestBean   tb    =    new   TestBean (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    tas )  )  )  ;", "try    {", "itb . exceptional ( ex )  ;", "fail (  \" Should   have   thrown   exception \"  )  ;", "}    catch    ( Throwable   t )     {", "if    ( rollbackException )     {", "assertEquals (  \" Caught   wrong   exception \"  ,    tex ,    t )  ;", "} else    {", "assertEquals (  \" Caught   wrong   exception \"  ,    ex ,    t )  ;", "}", "}", "if    (  ! rollbackException )     {", "if    ( shouldRollback )     {", "verify ( ptm )  . rollback ( status )  ;", "} else    {", "verify ( ptm )  . commit ( status )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doTestRollbackOnException"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "final   TransactionAttribute   outerTxatt    =    new   DefaultTransactionAttribute (  )  ;", "final   TransactionAttribute   innerTxatt    =    new   DefaultTransactionAttribute ( TransactionDefinition . PROPAGATION _ NESTED )  ;", "Method   outerMethod    =    exceptionalMethod ;", "Method   innerMethod    =    getNameMethod ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( outerMethod ,    outerTxatt )  ;", "tas . register ( innerMethod ,    innerTxatt )  ;", "TransactionStatus   outerStatus    =    mock ( TransactionStatus . class )  ;", "TransactionStatus   innerStatus    =    mock ( TransactionStatus . class )  ;", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "given ( ptm . getTransaction ( outerTxatt )  )  . willReturn ( outerStatus )  ;", "given ( ptm . getTransaction ( innerTxatt )  )  . willReturn ( innerStatus )  ;", "final   String   spouseName    =     \" innerName \"  ;", "TestBean   outer    =    new   TestBean (  )     {", "@ Override", "public   void   exceptional ( Throwable   t )    throws   Throwable    {", "Support . TransactionInfo   ti    =    Support . currentTransactionInfo (  )  ;", "assertTrue ( ti . hasTransaction (  )  )  ;", "assertEquals ( outerTxatt ,    ti . getTransactionAttribute (  )  )  ;", "assertEquals ( spouseName ,    getSpouse (  )  . getName (  )  )  ;", "}", "}  ;", "TestBean   inner    =    new   TestBean (  )     {", "@ Override", "public   String   getName (  )     {", "Support . TransactionInfo   ti    =    Support . currentTransactionInfo (  )  ;", "assertTrue ( ti . hasTransaction (  )  )  ;", "assertEquals ( innerTxatt ,    ti . getTransactionAttribute (  )  )  ;", "return   spouseName ;", "}", "}  ;", "ITestBean   outerProxy    =     (  ( ITestBean )     ( advised ( outer ,    ptm ,    tas )  )  )  ;", "ITestBean   innerProxy    =     (  ( ITestBean )     ( advised ( inner ,    ptm ,    tas )  )  )  ;", "outer . setSpouse ( innerProxy )  ;", "checkTransactionStatus ( false )  ;", "outerProxy . exceptional ( null )  ;", "checkTransactionStatus ( false )  ;", "verify ( ptm )  . commit ( innerStatus )  ;", "verify ( ptm )  . commit ( outerStatus )  ;", "}", "METHOD_END"], "methodName": ["enclosingTransactionWithNestedTransactionOnAdvisedInside"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )  ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( exceptionalMethod ,    txatt )  ;", "TransactionStatus   status    =    mock ( TransactionStatus . class )  ;", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "given ( ptm . getTransaction ( txatt )  )  . willReturn ( status )  ;", "final   String   spouseName    =     \" innerName \"  ;", "TestBean   outer    =    new   TestBean (  )     {", "@ Override", "public   void   exceptional ( Throwable   t )    throws   Throwable    {", "Support . TransactionInfo   ti    =    Support . currentTransactionInfo (  )  ;", "assertTrue ( ti . hasTransaction (  )  )  ;", "assertEquals ( spouseName ,    getSpouse (  )  . getName (  )  )  ;", "}", "}  ;", "TestBean   inner    =    new   TestBean (  )     {", "@ Override", "public   String   getName (  )     {", "Support . TransactionInfo   ti    =    Support . currentTransactionInfo (  )  ;", "assertFalse ( ti . hasTransaction (  )  )  ;", "return   spouseName ;", "}", "}  ;", "ITestBean   outerProxy    =     (  ( ITestBean )     ( advised ( outer ,    ptm ,    tas )  )  )  ;", "ITestBean   innerProxy    =     (  ( ITestBean )     ( advised ( inner ,    ptm ,    tas )  )  )  ;", "outer . setSpouse ( innerProxy )  ;", "checkTransactionStatus ( false )  ;", "outerProxy . exceptional ( null )  ;", "checkTransactionStatus ( false )  ;", "verify ( ptm )  . commit ( status )  ;", "}", "METHOD_END"], "methodName": ["enclosingTransactionWithNonTransactionMethodOnAdvisedInside"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "doTestRollbackOnException ( new   Exception (  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["noRollbackOnCheckedException"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "doTestRollbackOnException ( new   Exception (  )  ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["noRollbackOnCheckedExceptionWithRollbackException"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "doTestRollbackOnException ( new   RuntimeException (  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["noRollbackOnUncheckedException"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "doTestRollbackOnException ( new   RuntimeException (  )  ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["noRollbackOnUncheckedExceptionWithRollbackException"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "ttributeSource   tas    =    new   MapttributeSource (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    tas )  )  )  ;", "checkTransactionStatus ( false )  ;", "itb . getName (  )  ;", "checkTransactionStatus ( false )  ;", "verifyZeroInteractions ( ptm )  ;", "}", "METHOD_END"], "methodName": ["noTransaction"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )  ;", "Method   m    =    getNameMethod ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( m ,    txatt )  ;", "TransactionStatus   status    =    mock ( TransactionStatus . class )  ;", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "given ( ptm . getTransaction ( txatt )  )  . willReturn ( status )  ;", "final   String   name    =     \" jenny \"  ;", "TestBean   tb    =    new   TestBean (  )     {", "@ Override", "public   String   getName (  )     {", "TransactionStatus   txStatus    =    TransactionInterceptor . currentTransactionStatus (  )  ;", "txStatus . setRollbackOnly (  )  ;", "return   name ;", "}", "}  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    tas )  )  )  ;", "assertTrue ( name . equals ( itb . getName (  )  )  )  ;", "verify ( ptm )  . commit ( status )  ;", "}", "METHOD_END"], "methodName": ["programmaticRollback"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "doTestRollbackOnException ( new   Exception (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["rollbackOnCheckedException"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "doTestRollbackOnException ( new   Exception (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["rollbackOnCheckedExceptionWithRollbackException"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "doTestRollbackOnException ( new   RuntimeException (  )  ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["rollbackOnUncheckedException"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "doTestRollbackOnException ( new   RuntimeException (  )  ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["rollbackOnUncheckedExceptionWithRollbackException"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "exceptionalMethod    =    ITestBean . class . getMethod (  \" exceptional \"  ,    Throwable . class )  ;", "getNameMethod    =    ITestBean . class . getMethod (  \" getName \"  )  ;", "setNameMethod    =    ITestBean . class . getMethod (  \" setName \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )  ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( exceptionalMethod ,    txatt )  ;", "MockCallbackPreferringTransactionManager   ptm    =    new   MockCallbackPreferringTransactionManager (  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    tas )  )  )  ;", "checkTransactionStatus ( false )  ;", "try    {", "itb . exceptional ( new   OptimisticLockingFailureException (  \"  \"  )  )  ;", "fail (  \" Should   have   thrown   OptimisticLockingFailureException \"  )  ;", "}    catch    ( OptimisticLockingFailureException   ex )     {", "}", "checkTransactionStatus ( false )  ;", "assertSame ( txatt ,    ptm . getDefinition (  )  )  ;", "assertFalse ( ptm . getStatus (  )  . isRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionExceptionPropagatedWithCallbackPreference"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )  ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( getNameMethod ,    txatt )  ;", "TransactionStatus   status    =    mock ( TransactionStatus . class )  ;", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "given ( ptm . getTransaction ( txatt )  )  . willReturn ( status )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    tas )  )  )  ;", "checkTransactionStatus ( false )  ;", "itb . getName (  )  ;", "checkTransactionStatus ( false )  ;", "verify ( ptm )  . commit ( status )  ;", "}", "METHOD_END"], "methodName": ["transactionShouldSucceed"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )  ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( getNameMethod ,    txatt )  ;", "MockCallbackPreferringTransactionManager   ptm    =    new   MockCallbackPreferringTransactionManager (  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    tas )  )  )  ;", "checkTransactionStatus ( false )  ;", "itb . getName (  )  ;", "checkTransactionStatus ( false )  ;", "assertSame ( txatt ,    ptm . getDefinition (  )  )  ;", "assertFalse ( ptm . getStatus (  )  . isRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["transactionShouldSucceedWithCallbackPreference"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )  ;", "MapTransactionAttributeSource   tas    =    new   MapTransactionAttributeSource (  )  ;", "tas . register ( getNameMethod ,    txatt )  ;", "TransactionStatus   status    =    mock ( TransactionStatus . class )  ;", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "given ( ptm . getTransaction ( txatt )  )  . willReturn ( status )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    tas )  )  )  ;", "checkTransactionStatus ( false )  ;", "itb . getName (  )  ;", "checkTransactionStatus ( false )  ;", "verify ( ptm )  . commit ( status )  ;", "}", "METHOD_END"], "methodName": ["transactionShouldSucceedWithNotNew"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   txatt    =    new   DefaultTransactionAttribute (  )  ;", "MapTransactionAttributeSource   tas 1     =    new   MapTransactionAttributeSource (  )  ;", "tas 1  . register ( getNameMethod ,    txatt )  ;", "MapTransactionAttributeSource   tas 2     =    new   MapTransactionAttributeSource (  )  ;", "tas 2  . register ( setNameMethod ,    txatt )  ;", "TransactionStatus   status    =    mock ( TransactionStatus . class )  ;", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "given ( ptm . getTransaction ( txatt )  )  . willReturn ( status )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "ITestBean   itb    =     (  ( ITestBean )     ( advised ( tb ,    ptm ,    new   TransactionAttributeSource [  ]  {    tas 1  ,    tas 2     }  )  )  )  ;", "checkTransactionStatus ( false )  ;", "itb . getName (  )  ;", "checkTransactionStatus ( false )  ;", "itb . setName (  \" myName \"  )  ;", "checkTransactionStatus ( false )  ;", "verify ( ptm ,    times (  2  )  )  . commit ( status )  ;", "}", "METHOD_END"], "methodName": ["twoTransactionsShouldSucceed"], "fileName": "org.springframework.transaction.interceptor.AbstractTransactionAspectTests"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setClassFilter ( classFilter )  ;", "}", "METHOD_END"], "methodName": ["setClassFilter"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . transactionAttributeSource    =    transactionAttributeSource ;", "}", "METHOD_END"], "methodName": ["setTransactionAttributeSource"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor"}, {"methodBody": ["METHOD_START", "{", "PlatformTransactionManager   ptm    =    mock ( PlatformTransactionManager . class )  ;", "PlatformTransactionManagerFacade . delegate    =    ptm ;", "assertTrue (  (  \" Age   should   not   be    \"     +     ( testBean . getAge (  )  )  )  ,     (  ( testBean . getAge (  )  )     =  =     6  6  6  )  )  ;", "verifyZeroInteractions ( ptm )  ;", "final   TransactionStatus   ts    =    mock ( TransactionStatus . class )  ;", "ptm    =    new   PlatformTransactionManager (  )     {", "private   boolean   invoked ;", "@ Override", "public   TransactionStatus   getTransaction (  @ Nullable", "TransactionDefinition   def )    throws   TransactionException    {", "if    ( invoked )     {", "throw   new   IllegalStateException (  \" getTransaction   should   not   get   invoked   more   than   once \"  )  ;", "}", "invoked    =    true ;", "if    (  !  (  ( def . getName (  )  . contains ( DerivedTestBean . class . getName (  )  )  )     &  &     ( def . getName (  )  . contains (  \" setAge \"  )  )  )  )     {", "throw   new   IllegalStateException (  (  \" transaction   name   should   contain   class   and   method   name :     \"     +     ( def . getName (  )  )  )  )  ;", "}", "return   ts ;", "}", "@ Override", "public   void   commit ( TransactionStatus   status )    throws   TransactionException    {", "assertTrue (  ( status    =  =    ts )  )  ;", "}", "@ Override", "public   void   rollback ( TransactionStatus   status )    throws   TransactionException    {", "throw   new   IllegalStateException (  \" rollback   should   not   get   invoked \"  )  ;", "}", "}  ;", "PlatformTransactionManagerFacade . delegate    =    ptm ;", "int   age    =     6  6  6  ;", "testBean . setAge ( age )  ;", "assertTrue (  (  ( testBean . getAge (  )  )     =  =    age )  )  ;", "}", "METHOD_END"], "methodName": ["doTestGetsAreNotTransactional"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "this . factory    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( this . factory )  . loadBeanDefinitions ( new   ClassPathResource (  \" transactionalBeanFactory . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "ImplementsNoInterfaces   ini    =     (  ( ImplementsNoInterfaces )     ( factory . getBean (  \" cglibNoInterfaces \"  )  )  )  ;", "assertTrue (  \" testBean   is   CGLIB   advised \"  ,    AopUtils . isCglibProxy ( ini )  )  ;", "assertTrue (  ( ini   instanceof   alProxy )  )  ;", "String   newName    =     \" Gordon \"  ;", "CallCountingManager   ptm    =    new   CallCountingManager (  )  ;", "PlatformManagerFacade . delegate    =    ptm ;", "ini . setName ( newName )  ;", "assertEquals ( newName ,    ini . getName (  )  )  ;", "assertEquals (  2  ,    ptm . commits )  ;", "}", "METHOD_END"], "methodName": ["testCglibTransactionProxyImplementsNoInterfaces"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "CallCountingTransactionManager   txMan    =    new   CallCountingTransactionManager (  )  ;", "PlatformTransactionManagerFacade . delegate    =    txMan ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" hotSwapped \"  )  )  )  ;", "assertEquals (  6  6  6  ,    tb . getAge (  )  )  ;", "int   newAge    =     5  5  7  ;", "tb . setAge ( newAge )  ;", "assertEquals ( newAge ,    tb . getAge (  )  )  ;", "TestBean   target 2     =    new   TestBean (  )  ;", "target 2  . setAge (  6  5  )  ;", "HotSwappableTargetSource   ts    =     (  ( HotSwappableTargetSource )     ( factory . getBean (  \" swapper \"  )  )  )  ;", "ts . swap ( target 2  )  ;", "assertEquals ( target 2  . getAge (  )  ,    tb . getAge (  )  )  ;", "tb . setAge ( newAge )  ;", "assertEquals ( newAge ,    target 2  . getAge (  )  )  ;", "assertEquals (  0  ,    txMan . inflight )  ;", "assertEquals (  2  ,    txMan . commits )  ;", "assertEquals (  0  ,    txMan . rollbacks )  ;", "}", "METHOD_END"], "methodName": ["testDynamicTargetSource"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ITestBean >    beansOfType    =    factory . getBeansOfType ( ITestBean . class ,    true ,    true )  ;", "assertNotNull ( beansOfType )  ;", "}", "METHOD_END"], "methodName": ["testGetBeansOfTypeWithAbstract"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   testBean    =     (  ( ITestBean )     ( factory . getBean (  \" proxyFactory 1  \"  )  )  )  ;", "assertTrue (  \" testBean   is   a   dynamic   proxy \"  ,    Proxy . isProxyClass ( testBean . getClass (  )  )  )  ;", "assertFalse (  ( testBean   instanceof   alProxy )  )  ;", "doTestGetsAreNotal ( testBean )  ;", "}", "METHOD_END"], "methodName": ["testGetsAreNotTransactionalWithProxyFactory1"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   testBean    =     (  ( ITestBean )     ( factory . getBean (  \" proxyFactory 2 Cglib \"  )  )  )  ;", "assertTrue (  \" testBean   is   CGLIB   advised \"  ,    AopUtils . isCglibProxy ( testBean )  )  ;", "assertTrue (  ( testBean   instanceof   alProxy )  )  ;", "doTestGetsAreNotal ( testBean )  ;", "}", "METHOD_END"], "methodName": ["testGetsAreNotTransactionalWithProxyFactory2Cglib"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . preInstantiateSingletons (  )  ;", "ITestBean   testBean    =     (  ( ITestBean )     ( factory . getBean (  \" proxyFactory 2 DynamicProxy \"  )  )  )  ;", "assertTrue (  \" testBean   is   a   dynamic   proxy \"  ,    Proxy . isProxyClass ( testBean . getClass (  )  )  )  ;", "assertTrue (  ( testBean   instanceof   alProxy )  )  ;", "doTestGetsAreNotal ( testBean )  ;", "}", "METHOD_END"], "methodName": ["testGetsAreNotTransactionalWithProxyFactory2DynamicProxy"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   testBean    =     (  ( ITestBean )     ( factory . getBean (  \" proxyFactory 3  \"  )  )  )  ;", "assertTrue (  \" testBean   is   a   full   proxy \"  ,     ( testBean   instanceof   DerivedTestBean )  )  ;", "assertTrue (  ( testBean   instanceof   TransactionalProxy )  )  ;", ". InvocationCounterPointcut   txnCounter    =     (  (  . InvocationCounterPointcut )     ( factory . getBean (  \" txnInvocationCounterPointcut \"  )  )  )  ;", ". InvocationCounterInterceptor   preCounter    =     (  (  . InvocationCounterInterceptor )     ( factory . getBean (  \" preInvocationCounterInterceptor \"  )  )  )  ;", ". InvocationCounterInterceptor   postCounter    =     (  (  . InvocationCounterInterceptor )     ( factory . getBean (  \" postInvocationCounterInterceptor \"  )  )  )  ;", "txnCounter . counter    =     0  ;", "preCounter . counter    =     0  ;", "postCounter . counter    =     0  ;", "doTestGetsAreNotTransactional ( testBean )  ;", "assertTrue (  (  (  0     <     ( txnCounter . counter )  )     &  &     (  ( txnCounter . counter )     <  =     4  )  )  )  ;", "assertEquals (  4  ,    preCounter . counter )  ;", "assertEquals (  4  ,    postCounter . counter )  ;", "}", "METHOD_END"], "methodName": ["testGetsAreNotTransactionalWithProxyFactory3"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" noTransactionAttributeSource . xml \"  ,    getClass (  )  )  )  ;", "bf . getBean (  \" noTransactionAttributeSource \"  )  ;", "fail (  \" Should   require   TransactionAttributeSource   to   be   set \"  )  ;", "}    catch    ( FatalBeanException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testNoTransactionAttributeSource"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   testBean    =     (  ( ITestBean )     ( factory . getBean (  \" proxyFactory 2 Lazy \"  )  )  )  ;", "assertFalse ( factory . containsSingleton (  \" target \"  )  )  ;", "assertEquals (  6  6  6  ,    testBean . getAge (  )  )  ;", "assertTrue ( factory . containsSingleton (  \" target \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testProxyFactory2Lazy"], "fileName": "org.springframework.transaction.interceptor.BeanFactoryTransactionTests"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionAttributeSources ;", "}", "METHOD_END"], "methodName": ["getTransactionAttributeSources"], "fileName": "org.springframework.transaction.interceptor.CompositeTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    getDefinitionDescription (  )  ;", "if    (  ( this . qualifier )     !  =    null )     {", "result . append (  \"  ;     '  \"  )  . append ( this . qualifier )  . append (  \"  '  \"  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAttributeDescription"], "fileName": "org.springframework.transaction.interceptor.DefaultTransactionAttribute"}, {"methodBody": ["METHOD_START", "{", "return   this . descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.springframework.transaction.interceptor.DefaultTransactionAttribute"}, {"methodBody": ["METHOD_START", "{", "this . descriptor    =    descriptor ;", "}", "METHOD_END"], "methodName": ["setDescriptor"], "fileName": "org.springframework.transaction.interceptor.DefaultTransactionAttribute"}, {"methodBody": ["METHOD_START", "{", "this . qualifier    =    qualifier ;", "}", "METHOD_END"], "methodName": ["setQualifier"], "fileName": "org.springframework.transaction.interceptor.DefaultTransactionAttribute"}, {"methodBody": ["METHOD_START", "{", "return   testBean . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.transaction.interceptor.ImplementsNoInterfaces"}, {"methodBody": ["METHOD_START", "{", "this . testBean    =    testBean ;", "}", "METHOD_END"], "methodName": ["setDependency"], "fileName": "org.springframework.transaction.interceptor.ImplementsNoInterfaces"}, {"methodBody": ["METHOD_START", "{", "testBean . setName ( name )  ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.transaction.interceptor.ImplementsNoInterfaces"}, {"methodBody": ["METHOD_START", "{", "this . attributeMap . put ( clazz ,    txAttr )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.springframework.transaction.interceptor.MapTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "this . attributeMap . put ( method ,    txAttr )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.springframework.transaction.interceptor.MapTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "this . transactionAttribute    =    transactionAttribute ;", "}", "METHOD_END"], "methodName": ["setTransactionAttribute"], "fileName": "org.springframework.transaction.interceptor.MatchAlwaysTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( mappedName ,     \" Mapped   name   must   not   be   null \"  )  ;", "String   name    =     (  ( clazz . getName (  )  )     +     '  .  '  )     +    mappedName ;", "Method [  ]    methods    =    clazz . getDeclaredMethods (  )  ;", "List < Method >    matchingMethods    =    new   ArrayList <  >  (  )  ;", "for    ( Method   method    :    methods )     {", "if    ( isMatch ( method . getName (  )  ,    mappedName )  )     {", "matchingMethods . add ( method )  ;", "}", "}", "if    ( matchingMethods . isEmpty (  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Couldn ' t   find   method    '  \"     +    mappedName )     +     \"  '    on   class    [  \"  )     +     ( clazz . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "for    ( Method   method    :    matchingMethods )     {", "String   regMethodName    =    this . methodNameMap . get ( method )  ;", "if    (  ( regMethodName    =  =    null )     |  |     (  (  !  ( regMethodName . equals ( name )  )  )     &  &     (  ( regMethodName . length (  )  )     <  =     ( name . length (  )  )  )  )  )     {", "if    (  ( logger . isDebugEnabled (  )  )     &  &     ( regMethodName    !  =    null )  )     {", "logger . debug (  (  (  (  (  (  (  \" Replacing   attribute   for   al   method    [  \"     +    method )     +     \"  ]  :    current   name    '  \"  )     +    name )     +     \"  '    is   more   specific   than    '  \"  )     +    regMethodName )     +     \"  '  \"  )  )  ;", "}", "this . methodNameMap . put ( method ,    name )  ;", "addTransactionalMethod ( method ,    attr )  ;", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  (  \" Keeping   attribute   for   al   method    [  \"     +    method )     +     \"  ]  :    current   name    '  \"  )     +    name )     +     \"  '    is   not   more   specific   than    '  \"  )     +    regMethodName )     +     \"  '  \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addTransactionalMethod"], "fileName": "org.springframework.transaction.interceptor.MethodMapTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Name   must   not   be   null \"  )  ;", "int   lastDotIndex    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( lastDotIndex    =  =     (  -  1  )  )     {", "throw   new   IllegalArgumentException (  (  (  \"  '  \"     +    name )     +     \"  '    is   not   a   valid   method   name :    format   is   FQN . methodName \"  )  )  ;", "}", "String   className    =    name . substring (  0  ,    lastDotIndex )  ;", "String   methodName    =    name . substring (  ( lastDotIndex    +     1  )  )  ;", "Class <  ?  >    clazz    =    ClassUtils . resolveClassName ( className ,    this . beanClassLoader )  ;", "addalMethod ( clazz ,    methodName ,    attr )  ;", "}", "METHOD_END"], "methodName": ["addTransactionalMethod"], "fileName": "org.springframework.transaction.interceptor.MethodMapTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "Assert . notNull ( attr ,     \"    must   not   be   null \"  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Adding   transactional   method    [  \"     +    method )     +     \"  ]    with   attribute    [  \"  )     +    attr )     +     \"  ]  \"  )  )  ;", "}", "this . transactionAttributeMap . put ( method ,    attr )  ;", "}", "METHOD_END"], "methodName": ["addTransactionalMethod"], "fileName": "org.springframework.transaction.interceptor.MethodMapTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "if    ( methodMap    !  =    null )     {", "methodMap . forEach ( this :  : addalMethod )  ;", "}", "}", "METHOD_END"], "methodName": ["initMethodMap"], "fileName": "org.springframework.transaction.interceptor.MethodMapTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "return   PatternMatchUtils . simpleMatch ( mappedName ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["isMatch"], "fileName": "org.springframework.transaction.interceptor.MethodMapTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "this . methodMap    =    methodMap ;", "}", "METHOD_END"], "methodName": ["setMethodMap"], "fileName": "org.springframework.transaction.interceptor.MethodMapTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "if    ( NameMatchTransactionAttributeSource . logger . isDebugEnabled (  )  )     {", "NameMatchTransactionAttributeSource . logger . debug (  (  (  (  (  \" Adding   transactional   method    [  \"     +    methodName )     +     \"  ]    with   attribute    [  \"  )     +    attr )     +     \"  ]  \"  )  )  ;", "}", "this . nameMap . put ( methodName ,    attr )  ;", "}", "METHOD_END"], "methodName": ["addTransactionalMethod"], "fileName": "org.springframework.transaction.interceptor.NameMatchTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "return   PatternMatchUtils . simpleMatch ( mappedName ,    methodName )  ;", "}", "METHOD_END"], "methodName": ["isMatch"], "fileName": "org.springframework.transaction.interceptor.NameMatchTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "nameMap . forEach ( this :  : addTransactionalMethod )  ;", "}", "METHOD_END"], "methodName": ["setNameMap"], "fileName": "org.springframework.transaction.interceptor.NameMatchTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeEditor   tae    =    new   TransactionAttributeEditor (  )  ;", "Enumeration <  ?  >    propNames    =    transactionAttributes . propertyNames (  )  ;", "while    ( propNames . hasMoreElements (  )  )     {", "String   methodName    =     (  ( String )     ( propNames . nextElement (  )  )  )  ;", "String   value    =    transactionAttributes . getProperty ( methodName )  ;", "tae . setAsText ( value )  ;", "TransactionAttribute   attr    =     (  ( TransactionAttribute )     ( tae . getValue (  )  )  )  ;", "addTransactionalMethod ( methodName ,    attr )  ;", "}", "}", "METHOD_END"], "methodName": ["setProperties"], "fileName": "org.springframework.transaction.interceptor.NameMatchTransactionAttributeSource"}, {"methodBody": ["METHOD_START", "{", "if    ( exceptionClass . getName (  )  . contains ( this . exceptionName )  )     {", "return   depth ;", "}", "if    ( exceptionClass    =  =     ( Throwable . class )  )     {", "return    -  1  ;", "}", "return   getDepth ( exceptionClass . getSuperclass (  )  ,     ( depth    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getDepth"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleAttribute"}, {"methodBody": ["METHOD_START", "{", "return   getDepth ( ex . getClass (  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getDepth"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleAttribute"}, {"methodBody": ["METHOD_START", "{", "return   exceptionName ;", "}", "METHOD_END"], "methodName": ["getExceptionName"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleAttribute"}, {"methodBody": ["METHOD_START", "{", "RollbackRuleAttribute   rr    =    new   RollbackRuleAttribute ( Throwable . class . getName (  )  )  ;", "assertTrue (  (  ( rr . getDepth ( new   MyRuntimeException (  \"  \"  )  )  )     >     0  )  )  ;", "assertTrue (  (  ( rr . getDepth ( new   IOException (  )  )  )     >     0  )  )  ;", "assertTrue (  (  ( rr . getDepth ( new   FatalBeanException ( null ,    null )  )  )     >     0  )  )  ;", "assertTrue (  (  ( rr . getDepth ( new   RuntimeException (  )  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["alwaysTrueForThrowable"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleTests"}, {"methodBody": ["METHOD_START", "{", "RollbackRuleAttribute   rr    =    new   RollbackRuleAttribute ( Exception . class . getName (  )  )  ;", "assertThat ( rr . getDepth ( new   MyRuntimeException (  \"  \"  )  )  ,    equalTo (  3  )  )  ;", "}", "METHOD_END"], "methodName": ["ancestry"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleTests"}, {"methodBody": ["METHOD_START", "{", "new   RollbackRuleAttribute (  (  ( String )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["ctorArgExceptionStringNameVersionWithNull"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleTests"}, {"methodBody": ["METHOD_START", "{", "new   RollbackRuleAttribute ( StringBuffer . class )  ;", "}", "METHOD_END"], "methodName": ["ctorArgMustBeAThrowableClassWithNonThrowableType"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleTests"}, {"methodBody": ["METHOD_START", "{", "new   RollbackRuleAttribute (  (  ( Class <  ?  >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["ctorArgMustBeAThrowableClassWithNullThrowableType"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleTests"}, {"methodBody": ["METHOD_START", "{", "RollbackRuleAttribute   rr    =    new   RollbackRuleAttribute ( Exception . class )  ;", "assertEquals (  0  ,    rr . getDepth ( new   Exception (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["foundImmediatelyWithClass"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleTests"}, {"methodBody": ["METHOD_START", "{", "RollbackRuleAttribute   rr    =    new   RollbackRuleAttribute ( Exception . class . getName (  )  )  ;", "assertEquals (  0  ,    rr . getDepth ( new   Exception (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["foundImmediatelyWithString"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleTests"}, {"methodBody": ["METHOD_START", "{", "RollbackRuleAttribute   rr    =    new   RollbackRuleAttribute ( IOException . class . getName (  )  )  ;", "assertEquals (  (  -  1  )  ,    rr . getDepth ( new   MyRuntimeException (  \"  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["notFound"], "fileName": "org.springframework.transaction.interceptor.RollbackRuleTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . rollbackRules )     =  =    null )     {", "this . rollbackRules    =    new   LinkedList <  >  (  )  ;", "}", "return   this . rollbackRules ;", "}", "METHOD_END"], "methodName": ["getRollbackRules"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttribute"}, {"methodBody": ["METHOD_START", "{", "this . rollbackRules    =    rollbackRules ;", "}", "METHOD_END"], "methodName": ["setRollbackRules"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttribute"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( rta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   Exception (  )  )  )  ;", "assertTrue ( rta . rollbackOn ( new   RemoteException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestRuleForSelectiveRollbackOnChecked"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "List < RollbackRuleAttribute >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   NoRollbackRuleAttribute (  . MyBusinessWarningException . class )  )  ;", "list . add ( new   RollbackRuleAttribute (  . MyBusinessException . class )  )  ;", "RuleBasedTransactionAttribute   rta    =    new   RuleBasedTransactionAttribute ( TransactionDefinition . PROPAGATION _ REQUIRED ,    list )  ;", "assertTrue ( rta . rollbackOn ( new    . MyBusinessException (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new    . MyBusinessWarningException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testConflictingRulesToDetermineExactContract"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "RuleBasedTransactionAttribute   rta    =    new   RuleBasedTransactionAttribute (  )  ;", "assertTrue ( rta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertTrue ( rta . rollbackOn ( new   MyRuntimeException (  \"  \"  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   Exception (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   IOException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultRule"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "List < RollbackRuleAttribute >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   NoRollbackRuleAttribute (  \" Throwable \"  )  )  ;", "rta    =    new    ( TransactionDefinition . PROPAGATION _ REQUIRED ,    list )  ;", "assertFalse ( rta . rollbackOn ( new   Throwable (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   MyRuntimeException (  \"  \"  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   Exception (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   IOException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRollbackNever"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "List < RollbackRuleAttribute >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   RollbackRuleAttribute (  \" Exception \"  )  )  ;", "list . add ( new   NoRollbackRuleAttribute (  \" IOException \"  )  )  ;", "rta    =    new    ( TransactionDefinition . PROPAGATION _ REQUIRED ,    list )  ;", "assertTrue ( rta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertTrue ( rta . rollbackOn ( new   Exception (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   IOException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRuleForCommitOnSubclassOfChecked"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "List < RollbackRuleAttribute >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   NoRollbackRuleAttribute ( MyRuntimeException . class . getName (  )  )  )  ;", "list . add ( new   RollbackRuleAttribute ( IOException . class . getName (  )  )  )  ;", "rta    =    new    ( TransactionDefinition . PROPAGATION _ REQUIRED ,    list )  ;", "assertTrue ( rta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   MyRuntimeException (  \"  \"  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   Exception (  )  )  )  ;", "assertTrue ( rta . rollbackOn ( new   IOException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRuleForCommitOnUnchecked"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "List < RollbackRuleAttribute >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   RollbackRuleAttribute ( IOException . class . getName (  )  )  )  ;", "rta    =    new    ( TransactionDefinition . PROPAGATION _ REQUIRED ,    list )  ;", "assertTrue ( rta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertTrue ( rta . rollbackOn ( new   MyRuntimeException (  \"  \"  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   Exception (  )  )  )  ;", "assertTrue ( rta . rollbackOn ( new   IOException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRuleForRollbackOnChecked"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "List < RollbackRuleAttribute >    l    =    Collections . singletonList ( new   RollbackRuleAttribute ( RemoteException . class )  )  ;", "rta    =    new    ( TransactionDefinition . PROPAGATION _ REQUIRED ,    l )  ;", "doTestRuleForSelectiveRollbackOnChecked ( rta )  ;", "}", "METHOD_END"], "methodName": ["testRuleForSelectiveRollbackOnCheckedWithClass"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "List < RollbackRuleAttribute >    l    =    new   LinkedList <  >  (  )  ;", "l . add ( new   RollbackRuleAttribute ( RemoteException . class . getName (  )  )  )  ;", "rta    =    new    ( TransactionDefinition . PROPAGATION _ REQUIRED ,    l )  ;", "doTestRuleForSelectiveRollbackOnChecked ( rta )  ;", "}", "METHOD_END"], "methodName": ["testRuleForSelectiveRollbackOnCheckedWithString"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "List < RollbackRuleAttribute >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   NoRollbackRuleAttribute (  \" Throwable \"  )  )  ;", "rta    =    new    ( TransactionDefinition . PROPAGATION _ REQUIRED ,    list )  ;", "TransactionAttributeEditor   tae    =    new   TransactionAttributeEditor (  )  ;", "tae . setAsText ( rta . toString (  )  )  ;", "rta    =     (  (  )     ( tae . getValue (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   Throwable (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   MyRuntimeException (  \"  \"  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   Exception (  )  )  )  ;", "assertFalse ( rta . rollbackOn ( new   IOException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testToStringMatchesEditor"], "fileName": "org.springframework.transaction.interceptor.RuleBasedTransactionAttributeTests"}, {"methodBody": ["METHOD_START", "{", "if    ( txInfo    !  =    null )     {", "txInfo . reseThreadLocalStatus (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupTransactionInfo"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . transactionManagerCache . clear (  )  ;", "this . beanFactory    =    null ;", "}", "METHOD_END"], "methodName": ["clearTransactionManagerCache"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( txInfo    !  =    null )     &  &     (  ( txInfo . getTransactionStatus (  )  )     !  =    null )  )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" Completing   transaction   for    [  \"     +     ( txInfo . getJoinpointIdentification (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "txInfo . getTransactionManager (  )  . commit ( txInfo . getTransactionStatus (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["commitTransactionAfterReturning"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( txInfo    !  =    null )     &  &     (  ( txInfo . getTransactionStatus (  )  )     !  =    null )  )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Completing   for    [  \"     +     ( txInfo . getJoinpointIdentification (  )  )  )     +     \"  ]    after   exception :     \"  )     +    ex )  )  ;", "}", "if    (  (  ( txInfoAttribute )     !  =    null )     &  &     ( txInfoAttribute . rollbackOn ( ex )  )  )     {", "try    {", "txInfo . getTransactionManager (  )  . rollback ( txInfo . getTransactionStatus (  )  )  ;", "}    catch    ( TransactionSystemException   ex 2  )     {", "logger . error (  \" Application   exception   overridden   by   rollback   exception \"  ,    ex )  ;", "ex 2  . initApplicationException ( ex )  ;", "throw   ex 2  ;", "}    catch    ( RuntimeException    |    Error   ex 2  )     {", "logger . error (  \" Application   exception   overridden   by   rollback   exception \"  ,    ex )  ;", "throw   ex 2  ;", "}", "} else    {", "try    {", "txInfo . getTransactionManager (  )  . commit ( txInfo . getTransactionStatus (  )  )  ;", "}    catch    ( TransactionSystemException   ex 2  )     {", "logger . error (  \" Application   exception   overridden   by   commit   exception \"  ,    ex )  ;", "ex 2  . initApplicationException ( ex )  ;", "throw   ex 2  ;", "}    catch    ( RuntimeException    |    Error   ex 2  )     {", "logger . error (  \" Application   exception   overridden   by   commit   exception \"  ,    ex )  ;", "throw   ex 2  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["completeTransactionAfterThrowing"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( txAttr    !  =    null )     &  &     (  ( txAttr . getName (  )  )     =  =    null )  )     {", "txAttr    =    new   Delegatingttribute ( txAttr )     {", "@ Override", "public   String   getName (  )     {", "return   joinpointIdentification ;", "}", "}  ;", "}", "TransactionStatus   status    =    null ;", "if    ( txAttr    !  =    null )     {", "if    ( tm    !  =    null )     {", "status    =    tm . getTransaction ( txAttr )  ;", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Skipping   transactional   joinpoint    [  \"     +    joinpointIdentification )     +     \"  ]    because   no   transaction   manager   has   been   configured \"  )  )  ;", "}", "}", "}", "return   prepareTransactionInfo ( tm ,    txAttr ,    joinpointIdentification ,    status )  ;", "}", "METHOD_END"], "methodName": ["createTransactionIfNecessary"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   TransactionAspectSupport . transactionInfoHolder . get (  )  ;", "}", "METHOD_END"], "methodName": ["currentTransactionInfo"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "TransactionAspectSupport . TransactionInfo   info    =    TransactionAspectSupport . currentTransactionInfo (  )  ;", "if    (  ( info    =  =    null )     |  |     (  ( info . transactionStatus )     =  =    null )  )     {", "throw   new   NoTransactionException (  \" No   transaction   aspect - managed   TransactionStatus   in   scope \"  )  ;", "}", "return   info . transactionStatus ;", "}", "METHOD_END"], "methodName": ["currentTransactionStatus"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "PlatformTransactionManager   txManager    =    this . transactionManagerCache . get ( qualifier )  ;", "if    ( txManager    =  =    null )     {", "txManager    =    BeanFactoryAnnotationUtils . qualifiedBeanOfType ( beanFactory ,    PlatformTransactionManager . class ,    qualifier )  ;", "this . transactionManagerCache . putIfAbsent ( qualifier ,    txManager )  ;", "}", "return   txManager ;", "}", "METHOD_END"], "methodName": ["determineQualifiedTransactionManager"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( txAttr    =  =    null )     |  |     (  ( this . beanFactory )     =  =    null )  )     {", "return   getTransactionManager (  )  ;", "}", "String   qualifier    =    txAttr . getQualifier (  )  ;", "if    ( StringUtils . hasText ( qualifier )  )     {", "return   determineQualifiedTransactionManager ( this . beanFactory ,    qualifier )  ;", "} else", "if    ( StringUtils . hasText ( this . transactionManagerBeanName )  )     {", "return   determineQualifiedTransactionManager ( this . beanFactory ,    this . transactionManagerBeanName )  ;", "} else    {", "PlatformTransactionManager   defaultTransactionManager    =    getTransactionManager (  )  ;", "if    ( defaultTransactionManager    =  =    null )     {", "defaultTransactionManager    =    this . transactionManagerCache . get ( TransactionAspectSupport . DEFAULT _ TRANSACTION _ MANAGER _ KEY )  ;", "if    ( defaultTransactionManager    =  =    null )     {", "defaultTransactionManager    =    this . beanFactory . getBean ( PlatformTransactionManager . class )  ;", "this . transactionManagerCache . putIfAbsent ( TransactionAspectSupport . DEFAULT _ TRANSACTION _ MANAGER _ KEY ,    defaultTransactionManager )  ;", "}", "}", "return   defaultTransactionManager ;", "}", "}", "METHOD_END"], "methodName": ["determineTransactionManager"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionAttributeSource ;", "}", "METHOD_END"], "methodName": ["getTransactionAttributeSource"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionManagerBeanName ;", "}", "METHOD_END"], "methodName": ["getTransactionManagerBeanName"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeSource   tas    =    getTransactionAttributeSource (  )  ;", "final   TransactionAttribute   txAttr    =     ( tas    !  =    null )     ?    tas . getTransactionAttribute ( method ,    targetClass )     :    null ;", "final   PlatformTransactionManager   tm    =    determineTransactionManager ( txAttr )  ;", "final   String   joinpointIdentification    =    methodIdentification ( method ,    targetClass ,    txAttr )  ;", "if    (  ( txAttr    =  =    null )     |  |     (  !  ( tm   instanceof   CallbackPreferringPlatformTransactionManager )  )  )     {", ". TransactionInfo   txInfo    =    createTransactionIfNecessary ( tm ,    txAttr ,    joinpointIdentification )  ;", "Object   retVal    =    null ;", "try    {", "retVal    =    invocation . proceedWithInvocation (  )  ;", "}    catch    ( Throwable   ex )     {", "completeTransactionAfterThrowing ( txInfo ,    ex )  ;", "throw   ex ;", "}    finally    {", "cleanupTransactionInfo ( txInfo )  ;", "}", "commitTransactionAfterReturning ( txInfo )  ;", "return   retVal ;", "} else    {", "final    . ThrowableHolder   throwableHolder    =    new    . ThrowableHolder (  )  ;", "try    {", "Object   result    =     (  ( CallbackPreferringPlatformTransactionManager )     ( tm )  )  . execute ( txAttr ,     (    status )     -  >     {", ". TransactionInfo   txInfo    =    prepareTransactionInfo ( tm ,    txAttr ,    joinpointIdentification ,    status )  ;", "try    {", "return   invocation . proceedWithInvocation (  )  ;", "}    catch    ( Throwable   ex )     {", "if    ( txAttr . rollbackOn ( ex )  )     {", "if    ( ex   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( ex )  )  ;", "} else    {", "throw   new    . ThrowableHolderException ( ex )  ;", "}", "} else    {", "throwableHolder . throwable    =    ex ;", "return   null ;", "}", "}    finally    {", "cleanupTransactionInfo ( txInfo )  ;", "}", "}  )  ;", "if    (  ( throwableHolder . throwable )     !  =    null )     {", "throw   throwableHolder . throwable ;", "}", "return   result ;", "}    catch    (  . ThrowableHolderException   ex )     {", "throw   ex . getCause (  )  ;", "}    catch    ( TransactionSystemException   ex 2  )     {", "if    (  ( throwableHolder . throwable )     !  =    null )     {", "logger . error (  \" Application   exception   overridden   by   commit   exception \"  ,    throwableHolder . throwable )  ;", "ex 2  . initApplicationException ( throwableHolder . throwable )  ;", "}", "throw   ex 2  ;", "}    catch    ( Throwable   ex 2  )     {", "if    (  ( throwableHolder . throwable )     !  =    null )     {", "logger . error (  \" Application   exception   overridden   by   commit   exception \"  ,    throwableHolder . throwable )  ;", "}", "throw   ex 2  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invokeWithinTransaction"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["methodIdentification"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "String   methodIdentification    =    methodIdentification ( method ,    targetClass )  ;", "if    ( methodIdentification    =  =    null )     {", "if    ( txAttr   instanceof   Defaultttribute )     {", "methodIdentification    =     (  ( Defaultttribute )     ( txAttr )  )  . getDescriptor (  )  ;", "}", "if    ( methodIdentification    =  =    null )     {", "methodIdentification    =    ClassUtils . getQualifiedMethodName ( method ,    targetClass )  ;", "}", "}", "return   methodIdentification ;", "}", "METHOD_END"], "methodName": ["methodIdentification"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "TransactionAspectSupport . TransactionInfo   txInfo    =    new   TransactionAspectSupport . TransactionInfo ( tm ,    txAttr ,    joinpointIdentification )  ;", "if    ( txAttr    !  =    null )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \" Getting   transaction   for    [  \"     +     ( txInfo . getJoinpointIdentification (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "txInfo . newTransactionStatus ( status )  ;", "} else    {", "if    ( logger . isTraceEnabled (  )  )", "logger . trace (  (  (  \" Don ' t   need   to   create   transaction   for    [  \"     +    joinpointIdentification )     +     \"  ]  :    This   method   isn ' t   transactional .  \"  )  )  ;", "}", "txInfo . bindToThread (  )  ;", "return   txInfo ;", "}", "METHOD_END"], "methodName": ["prepareTransactionInfo"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . transactionAttributeSource    =    transactionAttributeSource ;", "}", "METHOD_END"], "methodName": ["setTransactionAttributeSource"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . transactionAttributeSource    =    new   CompositeTransactionAttributeSource ( transactionAttributeSources )  ;", "}", "METHOD_END"], "methodName": ["setTransactionAttributeSources"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "NameMatchTransactionAttributeSource   tas    =    new   NameMatchTransactionAttributeSource (  )  ;", "tas . setProperties ( transactionAttributes )  ;", "this . transactionAttributeSource    =    tas ;", "}", "METHOD_END"], "methodName": ["setTransactionAttributes"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . transactionManager    =    transactionManager ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "this . transactionManagerBeanName    =    transactionManagerBeanName ;", "}", "METHOD_END"], "methodName": ["setTransactionManagerBeanName"], "fileName": "org.springframework.transaction.interceptor.TransactionAspectSupport"}, {"methodBody": ["METHOD_START", "{", "DefaultTransactionAttribute   source    =    new   DefaultTransactionAttribute (  )  ;", "source . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "source . setIsolationLevel ( TransactionDefinition . ISOLATION _ REPEATABLE _ READ )  ;", "source . setTimeout (  1  0  )  ;", "source . setReadOnly ( true )  ;", "pe    =    new    (  )  ;", "pe . setAsText ( source . toString (  )  )  ;", "TransactionAttribute   ta    =     (  ( TransactionAttribute )     ( pe . getValue (  )  )  )  ;", "assertEquals ( ta ,    source )  ;", "assertEquals ( TransactionDefinition . PROPAGATION _ SUPPORTS ,    ta . getPropagationBehavior (  )  )  ;", "assertEquals ( TransactionDefinition . ISOLATION _ REPEATABLE _ READ ,    ta . getIsolationLevel (  )  )  ;", "assertEquals (  1  0  ,    ta . getTimeout (  )  )  ;", "assertTrue ( ta . isReadOnly (  )  )  ;", "assertTrue ( ta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertFalse ( ta . rollbackOn ( new   Exception (  )  )  )  ;", "source . setTimeout (  9  )  ;", "assertNotSame ( ta ,    source )  ;", "source . setTimeout (  1  0  )  ;", "assertEquals ( ta ,    source )  ;", "}", "METHOD_END"], "methodName": ["testDefaultTransactionAttributeToString"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeEditor   pe    =    new   TransactionAttributeEditor (  )  ;", "pe . setAsText (  \"  \"  )  ;", "TransactionAttribute   ta    =     (  ( TransactionAttribute )     ( pe . getValue (  )  )  )  ;", "assertTrue (  ( ta    =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyString"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeEditor   pe    =    new   TransactionAttributeEditor (  )  ;", "pe . setAsText (  \" XXPROPAGATION _ REQUIRED \"  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidPropagationCodeOnly"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeEditor   pe    =    new   TransactionAttributeEditor (  )  ;", "pe . setAsText ( null )  ;", "TransactionAttribute   ta    =     (  ( TransactionAttribute )     ( pe . getValue (  )  )  )  ;", "assertTrue (  ( ta    =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["testNull"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "RuleBasedTransactionAttribute   source    =    new   RuleBasedTransactionAttribute (  )  ;", "source . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "source . setIsolationLevel ( TransactionDefinition . ISOLATION _ REPEATABLE _ READ )  ;", "source . setTimeout (  1  0  )  ;", "source . setReadOnly ( true )  ;", "source . getRollbackRules (  )  . add ( new   RollbackRuleAttribute (  \" IllegalArgumentException \"  )  )  ;", "source . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute (  \" IllegalStateException \"  )  )  ;", "pe    =    new    (  )  ;", "pe . setAsText ( source . toString (  )  )  ;", "TransactionAttribute   ta    =     (  ( TransactionAttribute )     ( pe . getValue (  )  )  )  ;", "assertEquals ( ta ,    source )  ;", "assertEquals ( TransactionDefinition . PROPAGATION _ SUPPORTS ,    ta . getPropagationBehavior (  )  )  ;", "assertEquals ( TransactionDefinition . ISOLATION _ REPEATABLE _ READ ,    ta . getIsolationLevel (  )  )  ;", "assertEquals (  1  0  ,    ta . getTimeout (  )  )  ;", "assertTrue ( ta . isReadOnly (  )  )  ;", "assertTrue ( ta . rollbackOn ( new   IllegalArgumentException (  )  )  )  ;", "assertFalse ( ta . rollbackOn ( new   IllegalStateException (  )  )  )  ;", "source . getRollbackRules (  )  . clear (  )  ;", "assertNotSame ( ta ,    source )  ;", "source . getRollbackRules (  )  . add ( new   RollbackRuleAttribute (  \" IllegalArgumentException \"  )  )  ;", "source . getRollbackRules (  )  . add ( new   NoRollbackRuleAttribute (  \" IllegalStateException \"  )  )  ;", "assertEquals ( ta ,    source )  ;", "}", "METHOD_END"], "methodName": ["testRuleBasedTransactionAttributeToString"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeEditor   pe    =    new   TransactionAttributeEditor (  )  ;", "pe . setAsText (  \" PROPAGATION _ REQUIRED , ISOLATION _ READ _ UNCOMMITTED , XXX \"  )  ;", "}", "METHOD_END"], "methodName": ["testValidPropagationAndIsolationCodesAndInvalidRollbackRule"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeEditor   pe    =    new   TransactionAttributeEditor (  )  ;", "pe . setAsText (  \" PROPAGATION _ REQUIRED ,    ISOLATION _ READ _ UNCOMMITTED \"  )  ;", "TransactionAttribute   ta    =     (  ( TransactionAttribute )     ( pe . getValue (  )  )  )  ;", "assertTrue (  ( ta    !  =    null )  )  ;", "assertTrue (  (  ( ta . getPropagationBehavior (  )  )     =  =     ( TransactionDefinition . PROPAGATION _ REQUIRED )  )  )  ;", "assertTrue (  (  ( ta . getIsolationLevel (  )  )     =  =     ( TransactionDefinition . ISOLATION _ READ _ UNCOMMITTED )  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidPropagationCodeAndIsolationCode"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeEditor   pe    =    new   TransactionAttributeEditor (  )  ;", "pe . setAsText (  \" PROPAGATION _ MANDATORY , ISOLATION _ REPEATABLE _ READ , timeout _  1  0  ,  - IOException ,  + MyRuntimeException \"  )  ;", "TransactionAttribute   ta    =     (  ( TransactionAttribute )     ( pe . getValue (  )  )  )  ;", "assertNotNull ( ta )  ;", "assertEquals ( TransactionDefinition . PROPAGATION _ MANDATORY ,    ta . getPropagationBehavior (  )  )  ;", "assertEquals ( TransactionDefinition . ISOLATION _ REPEATABLE _ READ ,    ta . getIsolationLevel (  )  )  ;", "assertEquals (  1  0  ,    ta . getTimeout (  )  )  ;", "assertFalse ( ta . isReadOnly (  )  )  ;", "assertTrue ( ta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertFalse ( ta . rollbackOn ( new   Exception (  )  )  )  ;", "assertTrue ( ta . rollbackOn ( new   IOException (  )  )  )  ;", "assertTrue (  (  !  ( ta . rollbackOn ( new   MyRuntimeException (  \"  \"  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidPropagationCodeAndIsolationCodeAndRollbackRules1"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeEditor   pe    =    new   TransactionAttributeEditor (  )  ;", "pe . setAsText (  \"  + IOException , readOnly , ISOLATION _ READ _ COMMITTED ,  - MyRuntimeException , PROPAGATION _ SUPPORTS \"  )  ;", "TransactionAttribute   ta    =     (  ( TransactionAttribute )     ( pe . getValue (  )  )  )  ;", "assertNotNull ( ta )  ;", "assertEquals ( TransactionDefinition . PROPAGATION _ SUPPORTS ,    ta . getPropagationBehavior (  )  )  ;", "assertEquals ( TransactionDefinition . ISOLATION _ READ _ COMMITTED ,    ta . getIsolationLevel (  )  )  ;", "assertEquals ( TransactionDefinition . TIMEOUT _ DEFAULT ,    ta . getTimeout (  )  )  ;", "assertTrue ( ta . isReadOnly (  )  )  ;", "assertTrue ( ta . rollbackOn ( new   RuntimeException (  )  )  )  ;", "assertFalse ( ta . rollbackOn ( new   Exception (  )  )  )  ;", "assertFalse ( ta . rollbackOn ( new   IOException (  )  )  )  ;", "assertTrue ( ta . rollbackOn ( new   MyRuntimeException (  \"  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidPropagationCodeAndIsolationCodeAndRollbackRules2"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttributeEditor   pe    =    new   TransactionAttributeEditor (  )  ;", "pe . setAsText (  \" PROPAGATION _ REQUIRED \"  )  ;", "TransactionAttribute   ta    =     (  ( TransactionAttribute )     ( pe . getValue (  )  )  )  ;", "assertTrue (  ( ta    !  =    null )  )  ;", "assertTrue (  (  ( ta . getPropagationBehavior (  )  )     =  =     ( TransactionDefinition . PROPAGATION _ REQUIRED )  )  )  ;", "assertTrue (  (  ( ta . getIsolationLevel (  )  )     =  =     ( TransactionDefinition . ISOLATION _ DEFAULT )  )  )  ;", "assertTrue (  (  !  ( ta . isReadOnly (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidPropagationCodeOnly"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeEditorTests"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setClassFilter ( classFilter )  ;", "}", "METHOD_END"], "methodName": ["setClassFilter"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . transactionInterceptor    =    interceptor ;", "}", "METHOD_END"], "methodName": ["setTransactionInterceptor"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"}, {"methodBody": ["METHOD_START", "{", "TransactionInterceptor   ti    =    new   TransactionInterceptor (  )  ;", "ti . setTransactionAttributes ( new   Properties (  )  )  ;", "tas    =    new    ( ti )  ;", "SerializationTestUtils . serializeAndDeserialize ( tas )  ;", "}", "METHOD_END"], "methodName": ["serializability"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionAttribute   ta    =    tas . getTransactionAttribute ( method ,    null )  ;", "if    ( propagationBehavior    >  =     0  )     {", "assertNotNull ( ta )  ;", "assertEquals ( TransactionDefinition . ISOLATION _ DEFAULT ,    ta . getIsolationLevel (  )  )  ;", "assertEquals ( propagationBehavior ,    ta . getPropagationBehavior (  )  )  ;", "} else    {", "assertNull ( ta )  ;", "}", "}", "METHOD_END"], "methodName": ["checkTransactionProperties"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText (  \" foo = bar \"  )  ;", "}", "METHOD_END"], "methodName": ["invalidFormat"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText (  \" *  = PROPAGATION _ REQUIRED \"  )  ;", "tas    =     (  (  )     ( editor . getValue (  )  )  )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" hashCode \"  )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" equals \"  ,    Object . class )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" wait \"  )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" wait \"  ,    long . class )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" wait \"  ,    long . class ,    int . class )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" notify \"  )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" notifyAll \"  )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" toString \"  )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "}", "METHOD_END"], "methodName": ["matchesAll"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText (  (  \" hashCode = PROPAGATION _ REQUIRED \\ n \"     +     (  (  (  \" equals = PROPAGATION _ MANDATORY \\ n \"     +     \" * it = PROPAGATION _ SUPPORTS \\ n \"  )     +     \" notify = PROPAGATION _ SUPPORTS \\ n \"  )     +     \" not *  = PROPAGATION _ REQUIRED \"  )  )  )  ;", "tas    =     (  (  )     ( editor . getValue (  )  )  )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" hashCode \"  )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" equals \"  ,    Object . class )  ,    TransactionDefinition . PROPAGATION _ MANDATORY )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" wait \"  )  ,    TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" wait \"  ,    long . class )  ,    TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" wait \"  ,    long . class ,    int . class )  ,    TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" notify \"  )  ,    TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" notifyAll \"  )  ,    TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "checkTransactionProperties ( tas ,    Object . class . getMethod (  \" toString \"  )  ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["matchesSpecific"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText ( null )  ;", "tas    =     (  (  )     ( editor . getValue (  )  )  )  ;", "Method   m    =    Object . class . getMethod (  \" hashCode \"  )  ;", "assertNull ( tas . getTransactionAttribute ( m ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["nullValue"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "MatchAlwaysTransactionAttributeSource   tas    =    new   MatchAlwaysTransactionAttributeSource (  )  ;", "TransactionAttribute   ta    =    tas . getTransactionAttribute ( Object . class . getMethod (  \" hashCode \"  )  ,    null )  ;", "assertNotNull ( ta )  ;", "assertTrue (  (  ( TransactionDefinition . PROPAGATION _ REQUIRED )     =  =     ( ta . getPropagationBehavior (  )  )  )  )  ;", "tas . setTransactionAttribute ( new   DefaultTransactionAttribute ( TransactionDefinition . PROPAGATION _ SUPPORTS )  )  ;", "ta    =    tas . getTransactionAttribute ( IOException . class . getMethod (  \" getMessage \"  )  ,    IOException . class )  ;", "assertNotNull ( ta )  ;", "assertTrue (  (  ( TransactionDefinition . PROPAGATION _ SUPPORTS )     =  =     ( ta . getPropagationBehavior (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["matchAlwaysTransactionAttributeSource"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "NameMatchTransactionAttributeSource   tas    =    new   NameMatchTransactionAttributeSource (  )  ;", "Properties   attributes    =    new   Properties (  )  ;", "attributes . put (  \"  *  \"  ,     \" PROPAGATION _ REQUIRED \"  )  ;", "attributes . put (  \" hashCode \"  ,     \" PROPAGATION _ MANDATORY \"  )  ;", "tas . setProperties ( attributes )  ;", "TransactionAttribute   ta    =    tas . getTransactionAttribute ( Object . class . getMethod (  \" hashCode \"  )  ,    null )  ;", "assertNotNull ( ta )  ;", "assertEquals ( TransactionDefinition . PROPAGATION _ MANDATORY ,    ta . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["nameMatchTransactionAttributeSourceMostSpecificMethodNameIsDefinitelyMatched"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "NameMatchTransactionAttributeSource   tas    =    new   NameMatchTransactionAttributeSource (  )  ;", "Properties   attributes    =    new   Properties (  )  ;", "attributes . put (  \"  \"  ,     \" PROPAGATION _ MANDATORY \"  )  ;", "tas . setProperties ( attributes )  ;", "TransactionAttribute   ta    =    tas . getTransactionAttribute ( Object . class . getMethod (  \" hashCode \"  )  ,    null )  ;", "assertNull ( ta )  ;", "}", "METHOD_END"], "methodName": ["nameMatchTransactionAttributeSourceWithEmptyMethodName"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "NameMatchTransactionAttributeSource   tas    =    new   NameMatchTransactionAttributeSource (  )  ;", "Properties   attributes    =    new   Properties (  )  ;", "attributes . put (  \" hashCod *  \"  ,     \" PROPAGATION _ REQUIRED \"  )  ;", "tas . setProperties ( attributes )  ;", "TransactionAttribute   ta    =    tas . getTransactionAttribute ( Object . class . getMethod (  \" hashCode \"  )  ,    null )  ;", "assertNotNull ( ta )  ;", "assertEquals ( TransactionDefinition . PROPAGATION _ REQUIRED ,    ta . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["nameMatchTransactionAttributeSourceWithStarAtEndOfMethodName"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "NameMatchTransactionAttributeSource   tas    =    new   NameMatchTransactionAttributeSource (  )  ;", "Properties   attributes    =    new   Properties (  )  ;", "attributes . put (  \"  * ashCode \"  ,     \" PROPAGATION _ REQUIRED \"  )  ;", "tas . setProperties ( attributes )  ;", "TransactionAttribute   ta    =    tas . getTransactionAttribute ( Object . class . getMethod (  \" hashCode \"  )  ,    null )  ;", "assertNotNull ( ta )  ;", "assertEquals ( TransactionDefinition . PROPAGATION _ REQUIRED ,    ta . getPropagationBehavior (  )  )  ;", "}", "METHOD_END"], "methodName": ["nameMatchTransactionAttributeSourceWithStarAtStartOfMethodName"], "fileName": "org.springframework.transaction.interceptor.TransactionAttributeSourceTests"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "setManagerBeanName (  (  ( String )     ( ois . readObject (  )  )  )  )  ;", "setManager (  (  ( PlatformManager )     ( ois . readObject (  )  )  )  )  ;", "setAttributeSource (  (  ( AttributeSource )     ( ois . readObject (  )  )  )  )  ;", "setBeanFactory (  (  ( BeanFactory )     ( ois . readObject (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptor"}, {"methodBody": ["METHOD_START", "{", "oos . defaultWriteObject (  )  ;", "oos . writeObject ( getManagerBeanName (  )  )  ;", "oos . writeObject ( getManager (  )  )  ;", "oos . writeObject ( getAttributeSource (  )  )  ;", "oos . writeObject ( getBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptor"}, {"methodBody": ["METHOD_START", "{", "PlatformTransactionManager   transactionManager    =    mock ( PlatformTransactionManager . class )  ;", "given ( beanFactory . containsBean ( name )  )  . willReturn ( true )  ;", "given ( beanFactory . getBean ( name ,    PlatformTransactionManager . class )  )  . willReturn ( transactionManager )  ;", "return   transactionManager ;", "}", "METHOD_END"], "methodName": ["associateTransactionManager"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionInterceptor   ti    =    new   TransactionInterceptor (  )  ;", "if    ( beanFactory    !  =    null )     {", "ti . setBeanFactory ( beanFactory )  ;", "}", "if    ( transactionManagerName    !  =    null )     {", "ti . setTransactionManagerBeanName ( transactionManagerName )  ;", "}", "if    ( transactionManager    !  =    null )     {", "ti . setTransactionManager ( transactionManager )  ;", "}", "ti . setTransactionAttributeSource ( new   NameMatchTransactionAttributeSource (  )  )  ;", "ti . afterPropertiesSet (  )  ;", "return   ti ;", "}", "METHOD_END"], "methodName": ["createTransactionInterceptor"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "ti    =    simple ( beanFactory )  ;", "PlatformTransactionManager   txManager    =    mock ( PlatformTransactionManager . class )  ;", "given ( beanFactory . getBean ( PlatformTransactionManager . class )  )  . willReturn ( txManager )  ;", "DefaultTransactionAttribute   attribute    =    new   DefaultTransactionAttribute (  )  ;", "PlatformTransactionManager   actual    =    ti . determineTransactionManager ( attribute )  ;", "assertSame ( txManager ,    actual )  ;", "PlatformTransactionManager   actual 2     =    ti . determineTransactionManager ( attribute )  ;", "assertSame ( txManager ,    actual 2  )  ;", "verify ( beanFactory ,    times (  1  )  )  . getBean ( PlatformTransactionManager . class )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerDefaultSeveralTimes"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "ti    =    transactionInterceptorWithTransactionManagerName (  \" fooTransactionManager \"  ,    beanFactory )  ;", "PlatformTransactionManager   txManager    =    associateTransactionManager ( beanFactory ,     \" fooTransactionManager \"  )  ;", "DefaultTransactionAttribute   attribute    =    new   DefaultTransactionAttribute (  )  ;", "PlatformTransactionManager   actual    =    ti . determineTransactionManager ( attribute )  ;", "assertSame ( txManager ,    actual )  ;", "PlatformTransactionManager   actual 2     =    ti . determineTransactionManager ( attribute )  ;", "assertSame ( txManager ,    actual 2  )  ;", "verify ( beanFactory ,    times (  1  )  )  . getBean (  \" fooTransactionManager \"  ,    PlatformTransactionManager . class )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerWithBeanNameSeveralTimes"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "PlatformTransactionManager   defaultTransactionManager    =    associateTransactionManager ( beanFactory ,     \" defaultTransactionManager \"  )  ;", "ti    =    transactionInterceptorWithTransactionManagerName (  \" defaultTransactionManager \"  ,    beanFactory )  ;", "DefaultTransactionAttribute   attribute    =    new   DefaultTransactionAttribute (  )  ;", "attribute . setQualifier (  \"  \"  )  ;", "assertSame ( defaultTransactionManager ,    ti . determineTransactionManager ( attribute )  )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerWithEmptyQualifierAndDefaultName"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "PlatformTransactionManager   transactionManager    =    mock ( PlatformTransactionManager . class )  ;", "ti    =    transactionInterceptorWithTransactionManager ( transactionManager ,    null )  ;", "assertSame ( transactionManager ,    ti . determineTransactionManager ( new   DefaultTransactionAttribute (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerWithNoBeanFactory"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "PlatformTransactionManager   transactionManager    =    mock ( PlatformTransactionManager . class )  ;", "ti    =    transactionInterceptorWithTransactionManager ( transactionManager ,    null )  ;", "assertSame ( transactionManager ,    ti . determineTransactionManager ( null )  )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerWithNoBeanFactoryAndNoTransactionAttribute"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "ti    =    simple ( beanFactory )  ;", "assertNull ( ti . determineTransactionManager ( null )  )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerWithNoTransactionAttribute"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "PlatformTransactionManager   transactionManager    =    mock ( PlatformTransactionManager . class )  ;", "ti    =    transactionInterceptorWithTransactionManager ( transactionManager ,    beanFactory )  ;", "PlatformTransactionManager   fooTransactionManager    =    associateTransactionManager ( beanFactory ,     \" fooTransactionManager \"  )  ;", "DefaultTransactionAttribute   attribute    =    new   DefaultTransactionAttribute (  )  ;", "attribute . setQualifier (  \" fooTransactionManager \"  )  ;", "assertSame ( fooTransactionManager ,    ti . determineTransactionManager ( attribute )  )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerWithQualifierAndDefault"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "associateTransactionManager ( beanFactory ,     \" defaultTransactionManager \"  )  ;", "ti    =    transactionInterceptorWithTransactionManagerName (  \" defaultTransactionManager \"  ,    beanFactory )  ;", "PlatformTransactionManager   fooTransactionManager    =    associateTransactionManager ( beanFactory ,     \" fooTransactionManager \"  )  ;", "DefaultTransactionAttribute   attribute    =    new   DefaultTransactionAttribute (  )  ;", "attribute . setQualifier (  \" fooTransactionManager \"  )  ;", "assertSame ( fooTransactionManager ,    ti . determineTransactionManager ( attribute )  )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerWithQualifierAndDefaultName"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "ti    =    simple ( beanFactory )  ;", "PlatformTransactionManager   txManager    =    associateTransactionManager ( beanFactory ,     \" fooTransactionManager \"  )  ;", "DefaultTransactionAttribute   attribute    =    new   DefaultTransactionAttribute (  )  ;", "attribute . setQualifier (  \" fooTransactionManager \"  )  ;", "PlatformTransactionManager   actual    =    ti . determineTransactionManager ( attribute )  ;", "assertSame ( txManager ,    actual )  ;", "PlatformTransactionManager   actual 2     =    ti . determineTransactionManager ( attribute )  ;", "assertSame ( txManager ,    actual 2  )  ;", "verify ( beanFactory ,    times (  1  )  )  . containsBean (  \" fooTransactionManager \"  )  ;", "verify ( beanFactory ,    times (  1  )  )  . getBean (  \" fooTransactionManager \"  ,    PlatformTransactionManager . class )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerWithQualifierSeveralTimes"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "ti    =    simple ( beanFactory )  ;", "DefaultTransactionAttribute   attribute    =    new   DefaultTransactionAttribute (  )  ;", "attribute . setQualifier (  \" fooTransactionManager \"  )  ;", "thrown . expect ( NoSuchBeanDefinitionException . class )  ;", "thrown . expectMessage (  \"  ' fooTransactionManager '  \"  )  ;", "ti . determineTransactionManager ( attribute )  ;", "}", "METHOD_END"], "methodName": ["determineTransactionManagerWithQualifierUnknown"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionInterceptor   ti    =    new   TransactionInterceptor (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" methodName \"  ,     \" PROPAGATION _ REQUIRED \"  )  ;", "ti . setTransactionAttributes ( props )  ;", "PlatformTransactionManager   ptm    =    new    . SerializableTransactionManager (  )  ;", "ti . setTransactionManager ( ptm )  ;", "ti    =     (  ( TransactionInterceptor )     ( SerializationTestUtils . serializeAndDeserialize ( ti )  )  )  ;", "assertNotNull ( ti . logger )  ;", "assertTrue (  (  ( ti . getTransactionManager (  )  )    instanceof    . SerializableTransactionManager )  )  ;", "assertNotNull ( ti . getTransactionAttributeSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["serializableWithAttributeProperties"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "NameMatchTransactionAttributeSource   tas 1     =    new   NameMatchTransactionAttributeSource (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" methodName \"  ,     \" PROPAGATION _ REQUIRED \"  )  ;", "tas 1  . setProperties ( props )  ;", "NameMatchTransactionAttributeSource   tas 2     =    new   NameMatchTransactionAttributeSource (  )  ;", "props    =    new   Properties (  )  ;", "props . setProperty (  \" otherMethodName \"  ,     \" PROPAGATION _ REQUIRES _ NEW \"  )  ;", "tas 2  . setProperties ( props )  ;", "TransactionInterceptor   ti    =    new   TransactionInterceptor (  )  ;", "ti . setTransactionAttributeSources ( tas 1  ,    tas 2  )  ;", "PlatformTransactionManager   ptm    =    new    . SerializableTransactionManager (  )  ;", "ti . setTransactionManager ( ptm )  ;", "ti    =     (  ( TransactionInterceptor )     ( SerializationTestUtils . serializeAndDeserialize ( ti )  )  )  ;", "assertTrue (  (  ( ti . getTransactionManager (  )  )    instanceof    . SerializableTransactionManager )  )  ;", "assertTrue (  (  ( ti . getTransactionAttributeSource (  )  )    instanceof   CompositeTransactionAttributeSource )  )  ;", "CompositeTransactionAttributeSource   ctas    =     (  ( CompositeTransactionAttributeSource )     ( ti . getTransactionAttributeSource (  )  )  )  ;", "assertTrue (  (  ( ctas . getTransactionAttributeSources (  )  [  0  ]  )    instanceof   NameMatchTransactionAttributeSource )  )  ;", "assertTrue (  (  ( ctas . getTransactionAttributeSources (  )  [  1  ]  )    instanceof   NameMatchTransactionAttributeSource )  )  ;", "}", "METHOD_END"], "methodName": ["serializableWithCompositeSource"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   createTransactionInterceptor ( beanFactory ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["simpleTransactionInterceptor"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   createTransactionInterceptor ( beanFactory ,    null ,    transactionManager )  ;", "}", "METHOD_END"], "methodName": ["transactionInterceptorWithTransactionManager"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   createTransactionInterceptor ( beanFactory ,    transactionManagerName ,    null )  ;", "}", "METHOD_END"], "methodName": ["transactionInterceptorWithTransactionManagerName"], "fileName": "org.springframework.transaction.interceptor.TransactionInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . pointcut    =    pointcut ;", "}", "METHOD_END"], "methodName": ["setPointcut"], "fileName": "org.springframework.transaction.interceptor.TransactionProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . transactionInterceptor . setTransactionAttributeSource ( transactionAttributeSource )  ;", "}", "METHOD_END"], "methodName": ["setTransactionAttributeSource"], "fileName": "org.springframework.transaction.interceptor.TransactionProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . transactionInterceptor . setTransactionAttributes ( transactionAttributes )  ;", "}", "METHOD_END"], "methodName": ["setTransactionAttributes"], "fileName": "org.springframework.transaction.interceptor.TransactionProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . transactionInterceptor . setTransactionManager ( transactionManager )  ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.transaction.interceptor.TransactionProxyFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( this . allowCustomIsolationLevels )  )     &  &     ( isolationLevel    !  =     ( TransactionDefinition . ISOLATION _ DEFAULT )  )  )     {", "throw   new   InvalidIsolationLevelException (  (  \"    does   not   support   custom   isolation   levels   by   default    -     \"     +     \" switch    ' allowCustomIsolationLevels '    to    ' true '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyIsolationLevel"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( timeout    >     ( TransactionDefinition . TIMEOUT _ DEFAULT )  )     {", "txObject . getUserTransaction (  )  . setTransactionTimeout ( timeout )  ;", "if    ( timeout    >     0  )     {", "txObject . resetTransactionTimeout    =    true ;", "}", "}", "}", "METHOD_END"], "methodName": ["applyTimeout"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( transactionManager   instanceof   UserTransaction )     {", "return    (  ( UserTransaction )     ( transactionManager )  )  ;", "} else    {", "return   new   UserTransactionAdapter ( transactionManager )  ;", "}", "}", "METHOD_END"], "methodName": ["buildUserTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . userTransaction )     !  =    null )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Using   JTA   UserTransaction :     \"     +     ( this . userTransaction )  )  )  ;", "}", "} else    {", "throw   new   IllegalStateException (  (  \" No   JTA   UserTransaction   available    -    specify   either    \"     +     \"  ' userTransaction '    or    ' userTransactionName '    or    ' transactionManager '    or    ' transactionManagerName '  \"  )  )  ;", "}", "if    (  ( this . transactionManager )     !  =    null )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Using   JTA    :     \"     +     ( this . transactionManager )  )  )  ;", "}", "} else    {", "logger . warn (  \" No   JTA      found :    transaction   suspension   not   available \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkUserTransactionAndTransactionManager"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   new   JtaTransactionObject ( ut )  ;", "}", "METHOD_END"], "methodName": ["doGetJtaTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "applyIsolationLevel ( txObject ,    definition . getIsolationLevel (  )  )  ;", "int   timeout    =    determineTimeout ( definition )  ;", "applyTimeout ( txObject ,    timeout )  ;", "txObject . getUser (  )  . begin (  )  ;", "}", "METHOD_END"], "methodName": ["doJtaBegin"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getTransactionManager (  )  )     =  =    null )     {", "throw   new   TransactionSuspensionNotSupportedException (  (  \"    needs   a   JTA   TransactionManager   for   suspending   a   transaction :     \"     +     \" specify   the    ' transactionManager '    or    ' transactionManagerName '    property \"  )  )  ;", "}", "getTransactionManager (  )  . resume (  (  ( Transaction )     ( suspendedTransaction )  )  )  ;", "}", "METHOD_END"], "methodName": ["doJtaResume"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getTransactionManager (  )  )     =  =    null )     {", "throw   new   TransactionSuspensionNotSupportedException (  (  \"    needs   a   JTA   TransactionManager   for   suspending   a   transaction :     \"     +     \" specify   the    ' transactionManager '    or    ' transactionManagerName '    property \"  )  )  ;", "}", "return   getTransactionManager (  )  . suspend (  )  ;", "}", "METHOD_END"], "methodName": ["doJtaSuspend"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "int   jtaStatus    =    txObject . getUserTransaction (  )  . getStatus (  )  ;", "if    ( jtaStatus    =  =     ( Status . STATUS _ NO _ TRANSACTION )  )     {", "throw   new   RollbackException (  \" JTA   transaction   already   completed    -    probably   rolled   back \"  )  ;", "}", "if    ( jtaStatus    =  =     ( Status . STATUS _ ROLLEDBACK )  )     {", "throw   new   RollbackException (  \" JTA   transaction   already   rolled   back    ( probably   due   to   a   timeout )  \"  )  ;", "}", "if    (  ( this . transactionSynchronizationRegistry )     !  =    null )     {", "this . transactionSynchronizationRegistry . registerInterposedSynchronization ( new   JtaAfterCompletionSynchronization ( synchronizations )  )  ;", "} else", "if    (  ( get (  )  )     !  =    null )     {", "Transaction   transaction    =    get (  )  . getTransaction (  )  ;", "if    ( transaction    =  =    null )     {", "throw   new   IllegalStateException (  \" No   JTA   Transaction   available \"  )  ;", "}", "transaction . registerSynchronization ( new   JtaAfterCompletionSynchronization ( synchronizations )  )  ;", "} else    {", "logger . warn (  (  \" Participating   in   existing   JTA   transaction ,    but   no   JTA      available :     \"     +     (  \" cannot   register   Spring   after - completion   callbacks   with   outer   JTA   transaction    -     \"     +     \" processing   Spring   after - completion   callbacks   with   outcome   status    ' unknown '  \"  )  )  )  ;", "invokeAfterCompletion ( synchronizations ,    TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "}", "METHOD_END"], "methodName": ["doRegisterAfterCompletionWithJtaTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( ut   instanceof   TransactionManager )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" JTA   UserTransaction   object    [  \"     +    ut )     +     \"  ]    implements   TransactionManager \"  )  )  ;", "}", "return    (  ( TransactionManager )     ( ut )  )  ;", "}", "for    ( String   jndiName    :     . FALLBACK _ TRANSACTION _ MANAGER _ NAMES )     {", "try    {", "TransactionManager   tm    =    getJndiTemplate (  )  . lookup ( jndiName ,    TransactionManager . class )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" JTA   TransactionManager   found   at   fallback   JNDI   location    [  \"     +    jndiName )     +     \"  ]  \"  )  )  ;", "}", "return   tm ;", "}    catch    ( NamingException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" No   JTA   TransactionManager   found   at   fallback   JNDI   location    [  \"     +    jndiName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findTransactionManager"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( this . userTransactionObtainedFromJndi )     {", "String   jndiName    =     . DEFAULT _ TRANSACTION _ SYNCHRONIZATION _ REGISTRY _ NAME ;", "try    {", "TransactionSynchronizationRegistry   tsr    =    getJndiTemplate (  )  . lookup ( jndiName ,    TransactionSynchronizationRegistry . class )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" JTA   TransactionSynchronizationRegistry   found   at   default   JNDI   location    [  \"     +    jndiName )     +     \"  ]  \"  )  )  ;", "}", "return   tsr ;", "}    catch    ( NamingException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" No   JTA   TransactionSynchronizationRegistry   found   at   default   JNDI   location    [  \"     +    jndiName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "if    ( ut   instanceof   TransactionSynchronizationRegistry )     {", "return    (  ( TransactionSynchronizationRegistry )     ( ut )  )  ;", "}", "if    ( tm   instanceof   TransactionSynchronizationRegistry )     {", "return    (  ( TransactionSynchronizationRegistry )     ( tm )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findTransactionSynchronizationRegistry"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "String   jndiName    =    JtaTransactionManager . DEFAULT _ USER _ TRANSACTION _ NAME ;", "try    {", "UserTransaction   ut    =    getJndiTemplate (  )  . lookup ( jndiName ,    UserTransaction . class )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" JTA   UserTransaction   found   at   default   JNDI   location    [  \"     +    jndiName )     +     \"  ]  \"  )  )  ;", "}", "this . userTransactionObtainedFromJndi    =    true ;", "return   ut ;", "}    catch    ( NamingException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" No   JTA   UserTransaction   found   at   default   JNDI   location    [  \"     +    jndiName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["findUserTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . jndiTemplate . getEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["getJndiEnvironment"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . jndiTemplate ;", "}", "METHOD_END"], "methodName": ["getJndiTemplate"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionSynchronizationRegistry ;", "}", "METHOD_END"], "methodName": ["getTransactionSynchronizationRegistry"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . userTransaction ;", "}", "METHOD_END"], "methodName": ["getUserTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . transactionSynchronizationRegistry )     =  =    null )     {", "if    ( StringUtils . hasLength ( this . transactionSynchronizationRegistryName )  )     {", "this . transactionSynchronizationRegistry    =    lookupTransactionSynchronizationRegistry ( this . transactionSynchronizationRegistryName )  ;", "} else    {", "this . transactionSynchronizationRegistry    =    retrieveTransactionSynchronizationRegistry (  )  ;", "if    (  (  ( this . transactionSynchronizationRegistry )     =  =    null )     &  &     ( this . autodetectTransactionSynchronizationRegistry )  )     {", "this . transactionSynchronizationRegistry    =    findTransactionSynchronizationRegistry ( this . userTransaction ,    this . t )  ;", "}", "}", "}", "if    (  ( this . transactionSynchronizationRegistry )     !  =    null )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Using   JTA   TransactionSynchronizationRegistry :     \"     +     ( this . transactionSynchronizationRegistry )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initTransactionSynchronizationRegistry"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . userTransaction )     =  =    null )     {", "if    ( StringUtils . hasLength ( this . userTransactionName )  )     {", "this . userTransaction    =    lookupUserTransaction ( this . userTransactionName )  ;", "this . userTransactionObtainedFromJndi    =    true ;", "} else    {", "this . userTransaction    =    retrieveUserTransaction (  )  ;", "if    (  (  ( this . userTransaction )     =  =    null )     &  &     ( this . autodetectUserTransaction )  )     {", "this . userTransaction    =    findUserTransaction (  )  ;", "}", "}", "}", "if    (  ( this . transactionManager )     =  =    null )     {", "if    ( StringUtils . hasLength ( this . transactionManagerName )  )     {", "this . transactionManager    =    lookup ( this . transactionManagerName )  ;", "} else    {", "this . transactionManager    =    retrieve (  )  ;", "if    (  (  ( this . transactionManager )     =  =    null )     &  &     ( this . autodetect )  )     {", "this . transactionManager    =    find ( this . userTransaction )  ;", "}", "}", "}", "if    (  (  ( this . userTransaction )     =  =    null )     &  &     (  ( this . transactionManager )     !  =    null )  )     {", "this . userTransaction    =    buildUserTransaction ( this . transactionManager )  ;", "}", "}", "METHOD_END"], "methodName": ["initUserTransactionAndTransactionManager"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Retrieving   JTA      from   JNDI   location    [  \"     +    transactionManagerName )     +     \"  ]  \"  )  )  ;", "}", "return   getJndiTemplate (  )  . lookup ( transactionManagerName ,     . class )  ;", "}    catch    ( NamingException   ex )     {", "throw   new   TransactionSystemException (  (  (  \" JTA      is   not   available   at   JNDI   location    [  \"     +    transactionManagerName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupTransactionManager"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Retrieving   JTA   SynchronizationRegistry   from   JNDI   location    [  \"     +    registryName )     +     \"  ]  \"  )  )  ;", "}", "return   getJndiTemplate (  )  . lookup ( registryName ,    SynchronizationRegistry . class )  ;", "}    catch    ( NamingException   ex )     {", "throw   new   SystemException (  (  (  \" JTA   SynchronizationRegistry   is   not   available   at   JNDI   location    [  \"     +    registryName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupTransactionSynchronizationRegistry"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Retrieving   JTA   User   from   JNDI   location    [  \"     +    userName )     +     \"  ]  \"  )  )  ;", "}", "return   getJndiTemplate (  )  . lookup ( userName ,    User . class )  ;", "}    catch    ( NamingException   ex )     {", "throw   new   SystemException (  (  (  \" JTA   User   is   not   available   at   JNDI   location    [  \"     +    userName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupUserTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "this . jndiTemplate    =    new   JndiTemplate (  )  ;", "initUserTransactionAnd (  )  ;", "initTransactionSynchronizationRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["retrieveTransactionManager"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["retrieveTransactionSynchronizationRegistry"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["retrieveUserTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . allowCustomIsolationLevels    =    allowCustomIsolationLevels ;", "}", "METHOD_END"], "methodName": ["setAllowCustomIsolationLevels"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . autodetectTransactionManager    =    autodetectTransactionManager ;", "}", "METHOD_END"], "methodName": ["setAutodetectTransactionManager"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . autodetectTransactionSynchronizationRegistry    =    autodetectTransactionSynchronizationRegistry ;", "}", "METHOD_END"], "methodName": ["setAutodetectTransactionSynchronizationRegistry"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . autodetectUserTransaction    =    autodetectUserTransaction ;", "}", "METHOD_END"], "methodName": ["setAutodetectUserTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . cacheUserTransaction    =    cacheUserTransaction ;", "}", "METHOD_END"], "methodName": ["setCacheUserTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . jndiTemplate    =    new   JndiTemplate ( jndiEnvironment )  ;", "}", "METHOD_END"], "methodName": ["setJndiEnvironment"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( jndiTemplate ,     \" JndiTemplate   must   not   be   null \"  )  ;", "this . jndiTemplate    =    jndiTemplate ;", "}", "METHOD_END"], "methodName": ["setJndiTemplate"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . transactionManager    =    transactionManager ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . transactionManagerName    =    transactionManagerName ;", "}", "METHOD_END"], "methodName": ["setTransactionManagerName"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . transactionSynchronizationRegistry    =    transactionSynchronizationRegistry ;", "}", "METHOD_END"], "methodName": ["setTransactionSynchronizationRegistry"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . transactionSynchronizationRegistryName    =    transactionSynchronizationRegistryName ;", "}", "METHOD_END"], "methodName": ["setTransactionSynchronizationRegistryName"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . userTransaction    =    userTransaction ;", "}", "METHOD_END"], "methodName": ["setUserTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . userTransactionName    =    userTransactionName ;", "}", "METHOD_END"], "methodName": ["setUserTransactionName"], "fileName": "org.springframework.transaction.jta.JtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . userTransaction ;", "}", "METHOD_END"], "methodName": ["getUserTransaction"], "fileName": "org.springframework.transaction.jta.JtaTransactionObject"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.springframework.transaction.jta.ManagedTransactionAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . joined ;", "}", "METHOD_END"], "methodName": ["getJoined"], "fileName": "org.springframework.transaction.jta.MockUOWManager"}, {"methodBody": ["METHOD_START", "{", "return   this . synchronizations ;", "}", "METHOD_END"], "methodName": ["getSynchronizations"], "fileName": "org.springframework.transaction.jta.MockUOWManager"}, {"methodBody": ["METHOD_START", "{", "this . status    =    status ;", "}", "METHOD_END"], "methodName": ["setUOWStatus"], "fileName": "org.springframework.transaction.jta.MockUOWManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . jtaTransaction )     !  =    null )     {", "try    {", "this . jtaTransaction . setRollbackOnly (  )  ;", "}    catch    ( UnsupportedOperationException   ex )     {", ". logger . debug (  (  \" JTA   transaction   handle   does   not   support   setRollbackOnly   method    -     \"     +     (  \" relying   on   JTA   provider   to   mark   the   transaction   as   rollback - only   based   on    \"     +     \" the   exception   thrown   from   beforeCompletion \"  )  )  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . error (  \" Could   not   set   JTA   transaction   rollback - only \"  ,    ex )  ;", "}", "} else    {", ". logger . debug (  (  \" No   JTA   transaction   handle   available   and / or   running   on   WebLogic    -     \"     +     (  \" relying   on   JTA   provider   to   mark   the   transaction   as   rollback - only   based   on    \"     +     \" the   exception   thrown   from   beforeCompletion \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRollbackOnlyIfPossible"], "fileName": "org.springframework.transaction.jta.SpringJtaSynchronizationAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.springframework.transaction.jta.UserTransactionAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?  >    userTransactionClass    =    getClass (  )  . getClassLoader (  )  . loadClass (  . USER _ TRANSACTION _ CLASS _ NAME )  ;", "this . weblogicUserTransactionAvailable    =    userTransactionClass . isInstance ( getUserTransaction (  )  )  ;", "if    ( this . weblogicUserTransactionAvailable )     {", "this . beginWithNameMethod    =    userTransactionClass . getMethod (  \" begin \"  ,    String . class )  ;", "this . beginWithNameAndTimeoutMethod    =    userTransactionClass . getMethod (  \" begin \"  ,    String . class ,    int . class )  ;", "logger . info (  \" Support   for   WebLogic   transaction   names   available \"  )  ;", "} else    {", "logger . info (  \" Support   for   WebLogic   transaction   names   not   available \"  )  ;", "}", "Class <  ?  >    transactionManagerClass    =    getClass (  )  . getClassLoader (  )  . loadClass (  . CLIENT _ TRANSACTION _ MANAGER _ CLASS _ NAME )  ;", "logger . debug (  \" WebLogic   ClientTransactionManager   found \"  )  ;", "this . weblogicTransactionManagerAvailable    =    transactionManagerClass . isInstance ( getTransactionManager (  )  )  ;", "if    ( this . weblogicTransactionManagerAvailable )     {", "Class <  ?  >    transactionClass    =    getClass (  )  . getClassLoader (  )  . loadClass (  . TRANSACTION _ CLASS _ NAME )  ;", "this . forceResumeMethod    =    transactionManagerClass . getMethod (  \" forceResume \"  ,    Transaction . class )  ;", "this . setPropertyMethod    =    transactionClass . getMethod (  \" setProperty \"  ,    String . class ,    Serializable . class )  ;", "logger . debug (  \" Support   for   WebLogic   forceResume   available \"  )  ;", "} else    {", "logger . warn (  \" Support   for   WebLogic   forceResume   not   available \"  )  ;", "}", "}    catch    ( Exception   ex )     {", "throw   new   TransactionSystemException (  \" Could   not   initialize      because   WebLogic   API   classes   are   not   available \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["loadWebLogicTransactionClasses"], "fileName": "org.springframework.transaction.jta.WebLogicJtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "Object   helper    =    this . transactionHelper ;", "if    ( helper    =  =    null )     {", "try    {", "Class <  ?  >    transactionHelperClass    =    getClass (  )  . getClassLoader (  )  . loadClass (  . TRANSACTION _ HELPER _ CLASS _ NAME )  ;", "Method   getTransactionHelperMethod    =    transactionHelperClass . getMethod (  \" getTransactionHelper \"  )  ;", "helper    =    getTransactionHelperMethod . invoke ( null )  ;", "this . transactionHelper    =    helper ;", "logger . debug (  \" WebLogic   TransactionHelper   found \"  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   TransactionSystemException (  \" WebLogic ' s   TransactionHelper . getTransactionHelper (  )    method   failed \"  ,    ex . getTargetException (  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   TransactionSystemException (  \" Could   not   initialize      because   WebLogic   API   classes   are   not   available \"  ,    ex )  ;", "}", "}", "return   helper ;", "}", "METHOD_END"], "methodName": ["loadWebLogicTransactionHelper"], "fileName": "org.springframework.transaction.jta.WebLogicJtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "TransactionManager   tm    =    getTransactionManager (  )  ;", "Assert . state (  ( tm    !  =    null )  ,     \" No   TransactionManager   set \"  )  ;", "return   tm ;", "}", "METHOD_END"], "methodName": ["obtainTransactionManager"], "fileName": "org.springframework.transaction.jta.WebLogicJtaTransactionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "logger . debug (  (  (  \" Retrieving   WebSphere   UOWManager   from   default   JNDI   location    [  \"     +     (  . DEFAULT _ UOW _ MANAGER _ NAME )  )     +     \"  ]  \"  )  )  ;", "return   getJndiTemplate (  )  . lookup (  . DEFAULT _ UOW _ MANAGER _ NAME ,    UOWManager . class )  ;", "}    catch    ( NamingException   ex )     {", "logger . debug (  (  (  \" WebSphere   UOWManager   is   not   available   at   default   JNDI   location    [  \"     +     (  . DEFAULT _ UOW _ MANAGER _ NAME )  )     +     \"  ]     -    falling   back   to   UOWManagerFactory   lookup \"  )  )  ;", "return   UOWManagerFactory . getUOWManager (  )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupDefaultUowManager"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Retrieving   WebSphere   UOWManager   from   JNDI   location    [  \"     +    uowManagerName )     +     \"  ]  \"  )  )  ;", "}", "return   getJndiTemplate (  )  . lookup ( uowManagerName ,    UOWManager . class )  ;", "}    catch    ( NamingException   ex )     {", "throw   new   SystemException (  (  (  \" WebSphere   UOWManager   is   not   available   at   JNDI   location    [  \"     +    uowManagerName )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["lookupUowManager"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManager"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . uowManager )     !  =    null )  ,     \" No   UOWManager   set \"  )  ;", "return   this . uowManager ;", "}", "METHOD_END"], "methodName": ["obtainUOWManager"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . uowManager    =    uowManager ;", "}", "METHOD_END"], "methodName": ["setUowManager"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . uowManagerName    =    uowManagerName ;", "}", "METHOD_END"], "methodName": ["setUowManagerName"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManager"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "final      ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "final   DefaultTransactionDefinition   definition 2     =    new   DefaultTransactionDefinition (  )  ;", "definition 2  . setPropagationBehavior ( propagationBehavior )  ;", "definition 2  . setReadOnly ( true )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result 2  \"  ,    ptm . execute ( definition 2  ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "return    \" result 2  \"  ;", "}", "}  )  )  ;", "return    \" result \"  ;", "}", "}  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  0  ,    manager . getUOWTimeout (  )  )  ;", "assertEquals ( UOW _ TYPE _ GLOBAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertTrue ( manager . getJoined (  )  )  ;", "assertFalse ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestExistingTransactionWithParticipation"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "final      ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "final   DefaultTransactionDefinition   definition 2     =    new   DefaultTransactionDefinition (  )  ;", "definition 2  . setPropagationBehavior ( propagationBehavior )  ;", "definition 2  . setReadOnly ( true )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result 2  \"  ,    ptm . execute ( definition 2  ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertEquals (  ( propagationBehavior    =  =     ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  )  ,    TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "return    \" result 2  \"  ;", "}", "}  )  )  ;", "return    \" result \"  ;", "}", "}  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  0  ,    manager . getUOWTimeout (  )  )  ;", "if    ( propagationBehavior    =  =     ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  )     {", "assertEquals ( UOW _ TYPE _ GLOBAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "} else    {", "assertEquals ( UOW _ TYPE _ LOCAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "}", "assertFalse ( manager . getJoined (  )  )  ;", "assertFalse ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestExistingTransactionWithSuspension"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "ptm    =    new    ( manager )  ;", "ptm . setTransactionSynchronization ( synchMode )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "definition . setPropagationBehavior ( propagationBehavior )  ;", "definition . setReadOnly ( true )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "if    ( synchMode    =  =     (  . SYNCHRONIZATION _ ALWAYS )  )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "} else    {", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "}", "return    \" result \"  ;", "}", "}  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  0  ,    manager . getUOWTimeout (  )  )  ;", "assertEquals ( UOW _ TYPE _ LOCAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertFalse ( manager . getJoined (  )  )  ;", "assertFalse ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestNewTransactionSynchronization"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "ptm    =    new    ( manager )  ;", "ptm . setTransactionSynchronization ( synchMode )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "definition . setPropagationBehavior ( propagationBehavior )  ;", "definition . setReadOnly ( true )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "if    ( synchMode    !  =     (  . SYNCHRONIZATION _ NEVER )  )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "} else    {", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "}", "return    \" result \"  ;", "}", "}  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  0  ,    manager . getUOWTimeout (  )  )  ;", "assertEquals ( UOW _ TYPE _ GLOBAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertFalse ( manager . getJoined (  )  )  ;", "assertFalse ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestNewTransactionWithCommit"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "manager . setUOWStatus ( UOW _ STATUS _ ACTIVE )  ;", "ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "return    \" result \"  ;", "}", "}  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  0  ,    manager . getUOWTimeout (  )  )  ;", "assertEquals ( UOW _ TYPE _ GLOBAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertTrue ( manager . getJoined (  )  )  ;", "assertFalse ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["existingNonSpringTransaction"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "final      ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "final   DefaultTransactionDefinition   definition 2     =    new   DefaultTransactionDefinition (  )  ;", "definition 2  . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ NOT _ SUPPORTED )  ;", "definition 2  . setReadOnly ( true )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result 2  \"  ,    ptm . execute ( definition 2  ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "return    \" result 2  \"  ;", "}", "}  )  )  ;", "return    \" result \"  ;", "}", "}  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  0  ,    manager . getUOWTimeout (  )  )  ;", "assertEquals ( UOW _ TYPE _ LOCAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertFalse ( manager . getJoined (  )  )  ;", "assertFalse ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["existingTransactionUsingPropagationNotSupported"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestExistingTransactionWithParticipation ( TransactionDefinition . PROPAGATION _ MANDATORY )  ;", "}", "METHOD_END"], "methodName": ["existingTransactionWithParticipationUsingPropagationMandatory"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestExistingTransactionWithParticipation ( TransactionDefinition . PROPAGATION _ REQUIRED )  ;", "}", "METHOD_END"], "methodName": ["existingTransactionWithParticipationUsingPropagationRequired"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestExistingTransactionWithParticipation ( TransactionDefinition . PROPAGATION _ SUPPORTS )  ;", "}", "METHOD_END"], "methodName": ["existingTransactionWithParticipationUsingPropagationSupports"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestExistingTransactionWithSuspension ( TransactionDefinition . PROPAGATION _ NOT _ SUPPORTED )  ;", "}", "METHOD_END"], "methodName": ["existingTransactionWithSuspensionUsingPropagationNotSupported"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestExistingTransactionWithSuspension ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  ;", "}", "METHOD_END"], "methodName": ["existingTransactionWithSuspensionUsingPropagationRequiresNew"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionSynchronization ( TransactionDefinition . PROPAGATION _ NEVER ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ALWAYS )  ;", "}", "METHOD_END"], "methodName": ["newTransactionSynchronizationUsingPropagationNever"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionSynchronization ( TransactionDefinition . PROPAGATION _ NEVER ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ NEVER )  ;", "}", "METHOD_END"], "methodName": ["newTransactionSynchronizationUsingPropagationNeverAndSynchNever"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionSynchronization ( TransactionDefinition . PROPAGATION _ NEVER ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "}", "METHOD_END"], "methodName": ["newTransactionSynchronizationUsingPropagationNeverAndSynchOnActual"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionSynchronization ( TransactionDefinition . PROPAGATION _ NOT _ SUPPORTED ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ALWAYS )  ;", "}", "METHOD_END"], "methodName": ["newTransactionSynchronizationUsingPropagationNotSupported"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionSynchronization ( TransactionDefinition . PROPAGATION _ NOT _ SUPPORTED ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ NEVER )  ;", "}", "METHOD_END"], "methodName": ["newTransactionSynchronizationUsingPropagationNotSupportedAndSynchNever"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionSynchronization ( TransactionDefinition . PROPAGATION _ NOT _ SUPPORTED ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "}", "METHOD_END"], "methodName": ["newTransactionSynchronizationUsingPropagationNotSupportedAndSynchOnActual"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionSynchronization ( TransactionDefinition . PROPAGATION _ SUPPORTS ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ALWAYS )  ;", "}", "METHOD_END"], "methodName": ["newTransactionSynchronizationUsingPropagationSupports"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionSynchronization ( TransactionDefinition . PROPAGATION _ SUPPORTS ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ NEVER )  ;", "}", "METHOD_END"], "methodName": ["newTransactionSynchronizationUsingPropagationSupportsAndSynchNever"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionSynchronization ( TransactionDefinition . PROPAGATION _ SUPPORTS ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "}", "METHOD_END"], "methodName": ["newTransactionSynchronizationUsingPropagationSupportsAndSynchOnActual"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "definition . setTimeout (  1  0  )  ;", "definition . setReadOnly ( true )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "return    \" result \"  ;", "}", "}  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  1  0  ,    manager . getUOWTimeout (  )  )  ;", "assertEquals ( UOW _ TYPE _ GLOBAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertFalse ( manager . getJoined (  )  )  ;", "assertFalse ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitAndTimeout"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   RollbackException   rex    =    new   RollbackException (  )  ;", "MockUOWManager   manager    =    new   MockUOWManager (  )     {", "@ Override", "public   void   runUnderUOW ( int   type ,    boolean   join ,    UOWAction   action )    throws   UOWException    {", "throw   new   UOWException ( rex )  ;", "}", "}  ;", "ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "try    {", "ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "return    \" result \"  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   TransactionSystemException \"  )  ;", "}    catch    ( TransactionSystemException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   UOWException )  )  ;", "assertSame ( rex ,    ex . getRootCause (  )  )  ;", "assertSame ( rex ,    ex . getMostSpecificCause (  )  )  ;", "}", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  0  ,    manager . getUOWTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitException"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionWithCommit ( TransactionDefinition . PROPAGATION _ NESTED ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ALWAYS )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitUsingPropagationNested"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionWithCommit ( TransactionDefinition . PROPAGATION _ NESTED ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ NEVER )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitUsingPropagationNestedAndSynchNever"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionWithCommit ( TransactionDefinition . PROPAGATION _ NESTED ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitUsingPropagationNestedAndSynchOnActual"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionWithCommit ( TransactionDefinition . PROPAGATION _ REQUIRED ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ALWAYS )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitUsingPropagationRequired"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionWithCommit ( TransactionDefinition . PROPAGATION _ REQUIRED ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ NEVER )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitUsingPropagationRequiredAndSynchNever"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionWithCommit ( TransactionDefinition . PROPAGATION _ REQUIRED ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitUsingPropagationRequiredAndSynchOnActual"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionWithCommit ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ALWAYS )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitUsingPropagationRequiresNew"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionWithCommit ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ NEVER )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitUsingPropagationRequiresNewAndSynchNever"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestNewTransactionWithCommit ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW ,    WebSphereUowTransactionManager . SYNCHRONIZATION _ ON _ ACTUAL _ TRANSACTION )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithCommitUsingPropagationRequiresNewAndSynchOnActual"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "try    {", "ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "throw   new   OptimisticLockingFailureException (  \"  \"  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   OptimisticLockingFailureException \"  )  ;", "}    catch    ( OptimisticLockingFailureException   ex )     {", "}", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  0  ,    manager . getUOWTimeout (  )  )  ;", "assertEquals ( UOW _ TYPE _ GLOBAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertFalse ( manager . getJoined (  )  )  ;", "assertTrue ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithRollback"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "status . setRollbackOnly (  )  ;", "return    \" result \"  ;", "}", "}  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertEquals (  0  ,    manager . getUOWTimeout (  )  )  ;", "assertEquals ( UOW _ TYPE _ GLOBAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertFalse ( manager . getJoined (  )  )  ;", "assertTrue ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["newTransactionWithRollbackOnly"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "definition . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ MANDATORY )  ;", "try    {", "ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "return    \" result \"  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   IllegalTransactionStateException \"  )  ;", "}    catch    ( IllegalTransactionStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["propagationMandatoryFailsInCaseOfNoExistingTransaction"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "manager . setUOWStatus ( UOW _ STATUS _ ACTIVE )  ;", "ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "definition . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ NESTED )  ;", "try    {", "ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "return    \" result \"  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   NestedTransactionNotSupportedException \"  )  ;", "}    catch    ( NestedTransactionNotSupportedException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["propagationNestedFailsInCaseOfExistingTransaction"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "manager . setUOWStatus ( UOW _ STATUS _ ACTIVE )  ;", "ptm    =    new    ( manager )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "definition . setPropagationBehavior ( TransactionDefinition . PROPAGATION _ NEVER )  ;", "try    {", "ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "return    \" result \"  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   IllegalTransactionStateException \"  )  ;", "}    catch    ( IllegalTransactionStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["propagationNeverFailsInCaseOfExistingTransaction"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut    =    mock ( UserTransaction . class )  ;", "given ( ut . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "ExpectedLookupTemplate   jndiTemplate    =    new   ExpectedLookupTemplate (  )  ;", "jndiTemplate . addObject (  . DEFAULT _ USER _ TRANSACTION _ NAME ,    ut )  ;", "jndiTemplate . addObject (  . DEFAULT _ UOW _ MANAGER _ NAME ,    manager )  ;", "ptm    =    new    (  )  ;", "ptm . setJndiTemplate ( jndiTemplate )  ;", "ptm . afterPropertiesSet (  )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "TransactionStatus   ts    =    ptm . getTransaction ( definition )  ;", "ptm . commit ( ts )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "return    \" result \"  ;", "}", "}  )  )  ;", "assertEquals ( UOW _ TYPE _ GLOBAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertFalse ( manager . getJoined (  )  )  ;", "assertFalse ( manager . getRollbackOnly (  )  )  ;", "verify ( ut )  . begin (  )  ;", "verify ( ut )  . commit (  )  ;", "}", "METHOD_END"], "methodName": ["uowManagerAndUserTransactionFoundInJndi"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "MockUOWManager   manager    =    new   MockUOWManager (  )  ;", "ExpectedLookupTemplate   jndiTemplate    =    new   ExpectedLookupTemplate (  . DEFAULT _ UOW _ MANAGER _ NAME ,    manager )  ;", "ptm    =    new    (  )  ;", "ptm . setJndiTemplate ( jndiTemplate )  ;", "ptm . afterPropertiesSet (  )  ;", "DefaultTransactionDefinition   definition    =    new   DefaultTransactionDefinition (  )  ;", "assertEquals (  \" result \"  ,    ptm . execute ( definition ,    new   TransactionCallback < String >  (  )     {", "@ Override", "public   String   doInTransaction ( TransactionStatus   status )     {", "return    \" result \"  ;", "}", "}  )  )  ;", "assertEquals ( UOW _ TYPE _ GLOBAL _ TRANSACTION ,    manager . getUOWType (  )  )  ;", "assertFalse ( manager . getJoined (  )  )  ;", "assertFalse ( manager . getRollbackOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["uowManagerFoundInJndi"], "fileName": "org.springframework.transaction.jta.WebSphereUowTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "status . setCompleted (  )  ;", "if    ( status . isNewSynchronization (  )  )     {", "TransactionSynchronizationManager . clear (  )  ;", "}", "if    ( status . isNewTransaction (  )  )     {", "doCleanupAfterCompletion ( status . getTransaction (  )  )  ;", "}", "if    (  ( status . getSuspendedResources (  )  )     !  =    null )     {", "if    ( status . isDebug (  )  )     {", "logger . debug (  \" Resuming   suspended   transaction   after   completion   of   inner   transaction \"  )  ;", "}", "Object   transaction    =     ( status . hasTransaction (  )  )     ?    status . getTransaction (  )     :    null ;", "resume ( transaction ,     (  (  . SuspendedResourcesHolder )     ( status . getSuspendedResources (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupAfterCompletion"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( definition . getTimeout (  )  )     !  =     ( TransactionDefinition . TIMEOUT _ DEFAULT )  )     {", "return   definition . getTimeout (  )  ;", "}", "return   this . defaultTimeout ;", "}", "METHOD_END"], "methodName": ["determineTimeout"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "throw   new   TransactionSuspensionNotSupportedException (  (  (  \" Transaction   manager    [  \"     +     ( getClass (  )  . getName (  )  )  )     +     \"  ]    does   not   support   transaction   suspension \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doResume"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationManager . initSynchronization (  )  ;", "for    ( TransactionSynchronization   synchronization    :    suspendedSynchronizations )     {", "synchronization . resume (  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synchronization )  ;", "}", "}", "METHOD_END"], "methodName": ["doResumeSynchronization"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( status . isNew (  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . debug (  \" Initiating   transaction   rollback   after   commit   exception \"  ,    ex )  ;", "}", "doRollback ( status )  ;", "} else", "if    (  ( status . has (  )  )     &  &     ( isGlobalRollbackOnParticipationFailure (  )  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . debug (  \" Marking   existing   transaction   as   rollback - only   after   commit   exception \"  ,    ex )  ;", "}", "doSetRollbackOnly ( status )  ;", "}", "}    catch    ( RuntimeException    |    Error   rbex )     {", "logger . error (  \" Commit   exception   overridden   by   rollback   exception \"  ,    ex )  ;", "triggerAfterCompletion ( status ,    Synchronization . STATUS _ UNKNOWN )  ;", "throw   rbex ;", "}", "triggerAfterCompletion ( status ,    Synchronization . STATUS _ ROLLED _ BACK )  ;", "}", "METHOD_END"], "methodName": ["doRollbackOnCommitException"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "throw   new   IllegalTransactionStateException (  (  \" Participating   in   existing   transactions   is   not   supported    -    when    ' isExistingTransaction '     \"     +     \" returns   true ,    appropriate    ' doSetRollbackOnly '    behavior   must   be   provided \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doSetRollbackOnly"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "throw   new   TransactionSuspensionNotSupportedException (  (  (  \" Transaction   manager    [  \"     +     ( getClass (  )  . getName (  )  )  )     +     \"  ]    does   not   support   transaction   suspension \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doSuspend"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "List < TransactionSynchronization >    suspendedSynchronizations    =    TransactionSynchronizationManager . getSynchronizations (  )  ;", "for    ( TransactionSynchronization   synchronization    :    suspendedSynchronizations )     {", "synchronization . suspend (  )  ;", "}", "TransactionSynchronizationManager . clearSynchronization (  )  ;", "return   suspendedSynchronizations ;", "}", "METHOD_END"], "methodName": ["doSuspendSynchronization"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultTimeout ;", "}", "METHOD_END"], "methodName": ["getDefaultTimeout"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionSynchronization ;", "}", "METHOD_END"], "methodName": ["getTransactionSynchronization"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( definition . getPropagationBehavior (  )  )     =  =     ( TransactionDefinition . PROPAGATION _ NEVER )  )     {", "throw   new   IllegalTransactionStateException (  \" Existing   transaction   found   for   transaction   marked   with   propagation    ' never '  \"  )  ;", "}", "if    (  ( definition . getPropagationBehavior (  )  )     =  =     ( TransactionDefinition . PROPAGATION _ NOT _ SUPPORTED )  )     {", "if    ( debugEnabled )     {", "logger . debug (  \" Suspending   current   transaction \"  )  ;", "}", "Object   suspendedResources    =    suspend ( transaction )  ;", "boolean   newSynchronization    =     ( getTransactionSynchronization (  )  )     =  =     (  . SYNCHRONIZATION _ ALWAYS )  ;", "return   prepareTransactionStatus ( definition ,    null ,    false ,    newSynchronization ,    debugEnabled ,    suspendedResources )  ;", "}", "if    (  ( definition . getPropagationBehavior (  )  )     =  =     ( TransactionDefinition . PROPAGATION _ REQUIRES _ NEW )  )     {", "if    ( debugEnabled )     {", "logger . debug (  (  (  \" Suspending   current   transaction ,    creating   new   transaction   with   name    [  \"     +     ( definition . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", ". SuspendedResourcesHolder   suspendedResources    =    suspend ( transaction )  ;", "try    {", "boolean   newSynchronization    =     ( getTransactionSynchronization (  )  )     !  =     (  . SYNCHRONIZATION _ NEVER )  ;", "DefaultTransactionStatus   status    =    newTransactionStatus ( definition ,    transaction ,    true ,    newSynchronization ,    debugEnabled ,    suspendedResources )  ;", "doBegin ( transaction ,    definition )  ;", "prepareSynchronization ( status ,    definition )  ;", "return   status ;", "}    catch    ( RuntimeException    |    Error   beginEx )     {", "resumeAfterBeginException ( transaction ,    suspendedResources ,    beginEx )  ;", "throw   beginEx ;", "}", "}", "if    (  ( definition . getPropagationBehavior (  )  )     =  =     ( TransactionDefinition . PROPAGATION _ NESTED )  )     {", "if    (  !  ( isNestedTransactionAllowed (  )  )  )     {", "throw   new   NestedTransactionNotSupportedException (  (  \" Transaction   manager   does   not   allow   nested   transactions   by   default    -     \"     +     \" specify    ' nestedTransactionAllowed '    property   with   value    ' true '  \"  )  )  ;", "}", "if    ( debugEnabled )     {", "logger . debug (  (  (  \" Creating   nested   transaction   with   name    [  \"     +     ( definition . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "if    ( useSavepointForNestedTransaction (  )  )     {", "DefaultTransactionStatus   status    =    prepareTransactionStatus ( definition ,    transaction ,    false ,    false ,    debugEnabled ,    null )  ;", "status . createAndHoldSavepoint (  )  ;", "return   status ;", "} else    {", "boolean   newSynchronization    =     ( getTransactionSynchronization (  )  )     !  =     (  . SYNCHRONIZATION _ NEVER )  ;", "DefaultTransactionStatus   status    =    newTransactionStatus ( definition ,    transaction ,    true ,    newSynchronization ,    debugEnabled ,    null )  ;", "doBegin ( transaction ,    definition )  ;", "prepareSynchronization ( status ,    definition )  ;", "return   status ;", "}", "}", "if    ( debugEnabled )     {", "logger . debug (  \" Participating   in   existing   transaction \"  )  ;", "}", "if    ( isValidateExistingTransaction (  )  )     {", "if    (  ( definition . getIsolationLevel (  )  )     !  =     ( TransactionDefinition . ISOLATION _ DEFAULT )  )     {", "Integer   currentIsolationLevel    =    TransactionSynchronizationManager . getCurrentTransactionIsolationLevel (  )  ;", "if    (  ( currentIsolationLevel    =  =    null )     |  |     ( currentIsolationLevel    !  =     ( definition . getIsolationLevel (  )  )  )  )     {", "Constants   isoConstants    =    DefaultTransactionDefinition . constants ;", "throw   new   IllegalTransactionStateException (  (  (  (  \" Participating   transaction   with   definition    [  \"     +    definition )     +     \"  ]    specifies   isolation   level   which   is   incompatible   with   existing   transaction :     \"  )     +     ( currentIsolationLevel    !  =    null    ?    isoConstants . toCode ( currentIsolationLevel ,    DefaultTransactionDefinition . PREFIX _ ISOLATION )     :     \"  ( unknown )  \"  )  )  )  ;", "}", "}", "if    (  !  ( definition . isReadOnly (  )  )  )     {", "if    ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )     {", "throw   new   IllegalTransactionStateException (  (  (  \" Participating   transaction   with   definition    [  \"     +    definition )     +     \"  ]    is   not   marked   as   read - only   but   existing   transaction   is \"  )  )  ;", "}", "}", "}", "boolean   newSynchronization    =     ( getTransactionSynchronization (  )  )     !  =     (  . SYNCHRONIZATION _ NEVER )  ;", "return   prepareTransactionStatus ( definition ,    transaction ,    false ,    newSynchronization ,    debugEnabled ,    null )  ;", "}", "METHOD_END"], "methodName": ["handleExistingTransaction"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationUtils . invokeAfterCompletion ( synchronizations ,    completionStatus )  ;", "}", "METHOD_END"], "methodName": ["invokeAfterCompletion"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isExistingTransaction"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . failEarlyOnGlobalRollbackOnly ;", "}", "METHOD_END"], "methodName": ["isFailEarlyOnGlobalRollbackOnly"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . globalRollbackOnParticipationFailure ;", "}", "METHOD_END"], "methodName": ["isGlobalRollbackOnParticipationFailure"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . nestedTransactionAllowed ;", "}", "METHOD_END"], "methodName": ["isNestedTransactionAllowed"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . rollbackOnCommitFailure ;", "}", "METHOD_END"], "methodName": ["isRollbackOnCommitFailure"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . validateExistingTransaction ;", "}", "METHOD_END"], "methodName": ["isValidateExistingTransaction"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "boolean   actualNewSynchronization    =    newSynchronization    &  &     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  ;", "return   new   DefaultTransactionStatus ( transaction ,    newTransaction ,    actualNewSynchronization ,    definition . isReadOnly (  )  ,    debug ,    suspendedResources )  ;", "}", "METHOD_END"], "methodName": ["newTransactionStatus"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( status . isNewSynchronization (  )  )     {", "SynchronizationManager . setActualActive ( status . has (  )  )  ;", "SynchronizationManager . setCurrentIsolationLevel (  (  ( definition . getIsolationLevel (  )  )     !  =     ( Definition . ISOLATION _ DEFAULT )     ?    definition . getIsolationLevel (  )     :    null )  )  ;", "SynchronizationManager . setCurrentReadOnly ( definition . isReadOnly (  )  )  ;", "SynchronizationManager . setCurrentName ( definition . getName (  )  )  ;", "SynchronizationManager . initSynchronization (  )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareSynchronization"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "DefaultTransactionStatus   status    =    newTransactionStatus ( definition ,    transaction ,    newTransaction ,    newSynchronization ,    debug ,    suspendedResources )  ;", "prepareSynchronization ( status ,    definition )  ;", "return   status ;", "}", "METHOD_END"], "methodName": ["prepareTransactionStatus"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "boolean   beforeCompletionInvoked    =    false ;", "try    {", "boolean   unexpectedRollback    =    false ;", "prepareForCommit ( status )  ;", "triggerBeforeCommit ( status )  ;", "triggerBeforeCompletion ( status )  ;", "beforeCompletionInvoked    =    true ;", "if    ( status . hasSavepoint (  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . debug (  \" Releasing      savepoint \"  )  ;", "}", "unexpectedRollback    =    status . isGlobalRollbackOnly (  )  ;", "status . releaseHeldSavepoint (  )  ;", "} else", "if    ( status . isNewTransaction (  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . debug (  \" Initiating      commit \"  )  ;", "}", "unexpectedRollback    =    status . isGlobalRollbackOnly (  )  ;", "doCommit ( status )  ;", "} else", "if    ( isFailEarlyOnGlobalRollbackOnly (  )  )     {", "unexpectedRollback    =    status . isGlobalRollbackOnly (  )  ;", "}", "if    ( unexpectedRollback )     {", "throw   new   UnexpectedRollbackException (  \" Transaction   silently   rolled   back   because   it   has   been   marked   as   rollback - only \"  )  ;", "}", "}    catch    ( UnexpectedRollbackException   ex )     {", "triggerAfterCompletion ( status ,    TransactionSynchronization . STATUS _ ROLLED _ BACK )  ;", "throw   ex ;", "}    catch    ( TransactionException   ex )     {", "if    ( isRollbackOnCommitFailure (  )  )     {", "doRollbackOnCommitException ( status ,    ex )  ;", "} else    {", "triggerAfterCompletion ( status ,    TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "throw   ex ;", "}    catch    ( RuntimeException    |    Error   ex )     {", "if    (  ! beforeCompletionInvoked )     {", "triggerBeforeCompletion ( status )  ;", "}", "doRollbackOnCommitException ( status ,    ex )  ;", "throw   ex ;", "}", "try    {", "triggerAfterCommit ( status )  ;", "}    finally    {", "triggerAfterCompletion ( status ,    TransactionSynchronization . STATUS _ COMMITTED )  ;", "}", "}    finally    {", "cleanupAfterCompletion ( status )  ;", "}", "}", "METHOD_END"], "methodName": ["processCommit"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "boolean   unexpectedRollback    =    unexpected ;", "try    {", "triggerBeforeCompletion ( status )  ;", "if    ( status . hasSavepoint (  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . debug (  \" Rolling   back      to   savepoint \"  )  ;", "}", "status . rollbackToHeldSavepoint (  )  ;", "} else", "if    ( status . isNewTransaction (  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . debug (  \" Initiating      rollback \"  )  ;", "}", "doRollback ( status )  ;", "} else    {", "if    ( status . hasTransaction (  )  )     {", "if    (  ( status . isLocalRollbackOnly (  )  )     |  |     ( isGlobalRollbackOnParticipationFailure (  )  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . debug (  \" Participating      failed    -    marking   existing      as   rollback - only \"  )  ;", "}", "doSetRollbackOnly ( status )  ;", "} else    {", "if    ( status . isDebug (  )  )     {", "logger . debug (  \" Participating      failed    -    letting      originator   decide   on   rollback \"  )  ;", "}", "}", "} else    {", "logger . debug (  \" Should   roll   back      but   cannot    -    no      available \"  )  ;", "}", "if    (  !  ( isFailEarlyOnGlobalRollbackOnly (  )  )  )     {", "unexpectedRollback    =    false ;", "}", "}", "}    catch    ( RuntimeException    |    Error   ex )     {", "triggerAfterCompletion ( status ,    TransactionSynchronization . STATUS _ UNKNOWN )  ;", "throw   ex ;", "}", "triggerAfterCompletion ( status ,    TransactionSynchronization . STATUS _ ROLLED _ BACK )  ;", "if    ( unexpectedRollback )     {", "throw   new   UnexpectedRollbackException (  \" Transaction   rolled   back   because   it   has   been   marked   as   rollback - only \"  )  ;", "}", "}    finally    {", "cleanupAfterCompletion ( status )  ;", "}", "}", "METHOD_END"], "methodName": ["processRollback"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "this . log    =    LogFactory . getLog ( getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  (  \" Cannot   register   Spring   after - completion   synchronization   with   existing   transaction    -     \"     +     \" processing   Spring   after - completion   callbacks   immediately ,    with   outcome   status    ' unknown '  \"  )  )  ;", "invokeAfterCompletion ( synchronizations ,    TransactionSynchronization . STATUS _ UNKNOWN )  ;", "}", "METHOD_END"], "methodName": ["registerAfterCompletionWithExistingTransaction"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( resourcesHolder    !  =    null )     {", "Object   suspendedResources    =    resourcesHolder . suspendedResources ;", "if    ( suspendedResources    !  =    null )     {", "doResume (  ,    suspendedResources )  ;", "}", "List < TransactionSynchronization >    suspendedSynchronizations    =    resourcesHolder . suspendedSynchronizations ;", "if    ( suspendedSynchronizations    !  =    null )     {", "TransactionSynchronizationManager . setActualTransactionActive ( resourcesHolder . wasActive )  ;", "TransactionSynchronizationManager . setCurrentTransactionIsolationLevel ( resourcesHolder . isolationLevel )  ;", "TransactionSynchronizationManager . setCurrentTransactionReadOnly ( resourcesHolder . readOnly )  ;", "TransactionSynchronizationManager . setCurrentTransactionName ( resourcesHolder . name )  ;", "doResumeSynchronization ( suspendedSynchronizations )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resume"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "String   exMessage    =     \" Inner   transaction   begin   exception   overridden   by   outer   transaction   resume   exception \"  ;", "try    {", "resume ( transaction ,    suspendedResources )  ;", "}    catch    ( RuntimeException    |    Error   resumeEx )     {", "logger . error ( exMessage ,    beginEx )  ;", "throw   resumeEx ;", "}", "}", "METHOD_END"], "methodName": ["resumeAfterBeginException"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( defaultTimeout    <     ( TransactionDefinition . TIMEOUT _ DEFAULT )  )     {", "throw   new   InvalidTimeoutException (  \" Invalid   default   timeout \"  ,    defaultTimeout )  ;", "}", "this . defaultTimeout    =    defaultTimeout ;", "}", "METHOD_END"], "methodName": ["setDefaultTimeout"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . failEarlyOnGlobalRollbackOnly    =    failEarlyOnGlobalRollbackOnly ;", "}", "METHOD_END"], "methodName": ["setFailEarlyOnGlobalRollbackOnly"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . globalRollbackOnParticipationFailure    =    globalRollbackOnParticipationFailure ;", "}", "METHOD_END"], "methodName": ["setGlobalRollbackOnParticipationFailure"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . nestedTransactionAllowed    =    nestedTransactionAllowed ;", "}", "METHOD_END"], "methodName": ["setNestedTransactionAllowed"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . rollbackOnCommitFailure    =    rollbackOnCommitFailure ;", "}", "METHOD_END"], "methodName": ["setRollbackOnCommitFailure"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . transactionSynchronization    =    transactionSynchronization ;", "}", "METHOD_END"], "methodName": ["setTransactionSynchronization"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "setTransactionSynchronization ( AbstractPlatformTransactionManager . constants . asNumber ( constantName )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setTransactionSynchronizationName"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . validateExistingTransaction    =    validateExistingTransaction ;", "}", "METHOD_END"], "methodName": ["setValidateExistingTransaction"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldCommitOnGlobalRollbackOnly"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( TransactionSynchronizationManager . isSynchronizationActive (  )  )     {", "List < TransactionSynchronization >    suspendedSynchronizations    =    doSuspendSynchronization (  )  ;", "try    {", "Object   suspendedResources    =    null ;", "if    ( transaction    !  =    null )     {", "suspendedResources    =    doSuspend ( transaction )  ;", "}", "String   name    =    TransactionSynchronizationManager . getCurrentTransactionName (  )  ;", "TransactionSynchronizationManager . setCurrentTransactionName ( null )  ;", "boolean   readOnly    =    TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  ;", "TransactionSynchronizationManager . setCurrentTransactionReadOnly ( false )  ;", "Integer   isolationLevel    =    TransactionSynchronizationManager . getCurrentTransactionIsolationLevel (  )  ;", "TransactionSynchronizationManager . setCurrentTransactionIsolationLevel ( null )  ;", "boolean   wasActive    =    TransactionSynchronizationManager . isActualTransactionActive (  )  ;", "TransactionSynchronizationManager . setActualTransactionActive ( false )  ;", "return   new    . SuspendedResourcesHolder ( suspendedResources ,    suspendedSynchronizations ,    name ,    readOnly ,    isolationLevel ,    wasActive )  ;", "}    catch    ( RuntimeException    |    Error   ex )     {", "doResumeSynchronization ( suspendedSynchronizations )  ;", "throw   ex ;", "}", "} else", "if    ( transaction    !  =    null )     {", "Object   suspendedResources    =    doSuspend ( transaction )  ;", "return   new    . SuspendedResourcesHolder ( suspendedResources )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["suspend"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( status . isNewSynchronization (  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . trace (  \" Triggering   afterCommit   synchronization \"  )  ;", "}", "SynchronizationUtils . triggerAfterCommit (  )  ;", "}", "}", "METHOD_END"], "methodName": ["triggerAfterCommit"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( status . isNewSynchronization (  )  )     {", "List < Synchronization >    synchronizations    =    SynchronizationManager . getSynchronizations (  )  ;", "SynchronizationManager . clearSynchronization (  )  ;", "if    (  (  !  ( status . has (  )  )  )     |  |     ( status . isNew (  )  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . trace (  \" Triggering   afterCompletion   synchronization \"  )  ;", "}", "invokeAfterCompletion ( synchronizations ,    completionStatus )  ;", "} else", "if    (  !  ( synchronizations . isEmpty (  )  )  )     {", "registerAfterCompletionWithExisting ( status . get (  )  ,    synchronizations )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["triggerAfterCompletion"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( status . isNewSynchronization (  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . trace (  \" Triggering   beforeCommit   synchronization \"  )  ;", "}", "SynchronizationUtils . triggerBeforeCommit ( status . isReadOnly (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["triggerBeforeCommit"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( status . isNewSynchronization (  )  )     {", "if    ( status . isDebug (  )  )     {", "logger . trace (  \" Triggering   beforeCompletion   synchronization \"  )  ;", "}", "SynchronizationUtils . triggerBeforeCompletion (  )  ;", "}", "}", "METHOD_END"], "methodName": ["triggerBeforeCompletion"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["useSavepointForNestedTransaction"], "fileName": "org.springframework.transaction.support.AbstractPlatformTransactionManager"}, {"methodBody": ["METHOD_START", "{", "setSavepoint ( getSavepointManager (  )  . createSavepoint (  )  )  ;", "}", "METHOD_END"], "methodName": ["createAndHoldSavepoint"], "fileName": "org.springframework.transaction.support.AbstractTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . savepoint ;", "}", "METHOD_END"], "methodName": ["getSavepoint"], "fileName": "org.springframework.transaction.support.AbstractTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "throw   new   NestedTransactionNotSupportedException (  \" This   transaction   does   not   support   savepoints \"  )  ;", "}", "METHOD_END"], "methodName": ["getSavepointManager"], "fileName": "org.springframework.transaction.support.AbstractTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isGlobalRollbackOnly"], "fileName": "org.springframework.transaction.support.AbstractTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . rollbackOnly ;", "}", "METHOD_END"], "methodName": ["isLocalRollbackOnly"], "fileName": "org.springframework.transaction.support.AbstractTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "Object   savepoint    =    getSavepoint (  )  ;", "if    ( savepoint    =  =    null )     {", "throw   new   TransactionUsageException (  \" Cannot   release   savepoint    -    no   savepoint   associated   with   current    \"  )  ;", "}", "getSavepointManager (  )  . releaseSavepoint ( savepoint )  ;", "setSavepoint ( null )  ;", "}", "METHOD_END"], "methodName": ["releaseHeldSavepoint"], "fileName": "org.springframework.transaction.support.AbstractTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "Object   savepoint    =    getSavepoint (  )  ;", "if    ( savepoint    =  =    null )     {", "throw   new   TransactionUsageException (  \" Cannot   roll   back   to   savepoint    -    no   savepoint   associated   with   current    \"  )  ;", "}", "getSavepointManager (  )  . rollbackToSavepoint ( savepoint )  ;", "getSavepointManager (  )  . releaseSavepoint ( savepoint )  ;", "setSavepoint ( null )  ;", "}", "METHOD_END"], "methodName": ["rollbackToHeldSavepoint"], "fileName": "org.springframework.transaction.support.AbstractTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "this . completed    =    true ;", "}", "METHOD_END"], "methodName": ["setCompleted"], "fileName": "org.springframework.transaction.support.AbstractTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "this . savepoint    =    savepoint ;", "}", "METHOD_END"], "methodName": ["setSavepoint"], "fileName": "org.springframework.transaction.support.AbstractTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "result . append (  . constants . toCode ( this . propagationBehavior ,     . PREFIX _ PROPAGATION )  )  ;", "result . append (  '  ,  '  )  ;", "result . append (  . constants . toCode ( this . isolationLevel ,     . PREFIX _ ISOLATION )  )  ;", "if    (  ( this . timeout )     !  =     ( TransactionDefinition . TIMEOUT _ DEFAULT )  )     {", "result . append (  '  ,  '  )  ;", "result . append (  . PREFIX _ TIMEOUT )  . append ( this . timeout )  ;", "}", "if    ( this . readOnly )     {", "result . append (  '  ,  '  )  ;", "result . append (  . READ _ ONLY _ MARKER )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDefinitionDescription"], "fileName": "org.springframework.transaction.support.DefaultTransactionDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( DefaultTransactionDefinition . constants . getValues ( DefaultTransactionDefinition . PREFIX _ ISOLATION )  . contains ( isolationLevel )  )  )     {", "throw   new   IllegalArgumentException (  \" Only   values   of   isolation   constants   allowed \"  )  ;", "}", "this . isolationLevel    =    isolationLevel ;", "}", "METHOD_END"], "methodName": ["setIsolationLevel"], "fileName": "org.springframework.transaction.support.DefaultTransactionDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( constantName . startsWith ( DefaultTransactionDefinition . PREFIX _ ISOLATION )  )  )     {", "throw   new   IllegalArgumentException (  \" Only   isolation   constants   allowed \"  )  ;", "}", "setIsolationLevel ( DefaultTransactionDefinition . constants . asNumber ( constantName )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setIsolationLevelName"], "fileName": "org.springframework.transaction.support.DefaultTransactionDefinition"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.transaction.support.DefaultTransactionDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( DefaultTransactionDefinition . constants . getValues ( DefaultTransactionDefinition . PREFIX _ PROPAGATION )  . contains ( propagationBehavior )  )  )     {", "throw   new   IllegalArgumentException (  \" Only   values   of   propagation   constants   allowed \"  )  ;", "}", "this . propagationBehavior    =    propagationBehavior ;", "}", "METHOD_END"], "methodName": ["setPropagationBehavior"], "fileName": "org.springframework.transaction.support.DefaultTransactionDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( constantName . startsWith ( DefaultTransactionDefinition . PREFIX _ PROPAGATION )  )  )     {", "throw   new   IllegalArgumentException (  \" Only   propagation   constants   allowed \"  )  ;", "}", "setPropagationBehavior ( DefaultTransactionDefinition . constants . asNumber ( constantName )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropagationBehaviorName"], "fileName": "org.springframework.transaction.support.DefaultTransactionDefinition"}, {"methodBody": ["METHOD_START", "{", "this . readOnly    =    readOnly ;", "}", "METHOD_END"], "methodName": ["setReadOnly"], "fileName": "org.springframework.transaction.support.DefaultTransactionDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( timeout    <     ( TransactionDefinition . TIMEOUT _ DEFAULT )  )     {", "throw   new   IllegalArgumentException (  \" Timeout   must   be   a   positive   integer   or   TIMEOUT _ DEFAULT \"  )  ;", "}", "this . timeout    =    timeout ;", "}", "METHOD_END"], "methodName": ["setTimeout"], "fileName": "org.springframework.transaction.support.DefaultTransactionDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . suspendedResources ;", "}", "METHOD_END"], "methodName": ["getSuspendedResources"], "fileName": "org.springframework.transaction.support.DefaultTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . transaction )     !  =    null )  ,     \" No   transaction   active \"  )  ;", "return   this . transaction ;", "}", "METHOD_END"], "methodName": ["getTransaction"], "fileName": "org.springframework.transaction.support.DefaultTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "return    ( this . transaction )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasTransaction"], "fileName": "org.springframework.transaction.support.DefaultTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . debug ;", "}", "METHOD_END"], "methodName": ["isDebug"], "fileName": "org.springframework.transaction.support.DefaultTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . newSynchronization ;", "}", "METHOD_END"], "methodName": ["isNewSynchronization"], "fileName": "org.springframework.transaction.support.DefaultTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "return   this . readOnly ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "org.springframework.transaction.support.DefaultTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "return    ( this . transaction )    instanceof   SavepointManager ;", "}", "METHOD_END"], "methodName": ["isTransactionSavepointManager"], "fileName": "org.springframework.transaction.support.DefaultTransactionStatus"}, {"methodBody": ["METHOD_START", "{", "UserTransaction   ut 1     =    mock ( UserTransaction . class )  ;", "UserTransaction   ut 2     =    mock ( UserTransaction . class )  ;", "TransactionManager   tm    =    mock ( TransactionManager . class )  ;", "jtam    =    new    (  )  ;", "jtam . setUserTransaction ( ut 1  )  ;", "jtam . setTransactionManager ( tm )  ;", "jtam . setRollbackOnCommitFailure ( true )  ;", "jtam . afterPropertiesSet (  )  ;", "SimpleNamingContextBuilder   jndiEnv    =    SimpleNamingContextBuilder . emptyActivatedContextBuilder (  )  ;", "jndiEnv . bind (  . DEFAULT _ USER _ TRANSACTION _ NAME ,    ut 2  )  ;", "serializedJtatm    =     (  (  )     ( SerializationTestUtils . serializeAndDeserialize ( jtam )  )  )  ;", "assertNotNull (  \" Logger   must   survive   serialization \"  ,    serializedJtatm . logger )  ;", "assertTrue (  \" UserTransaction   looked   up   on   client \"  ,     (  ( serializedJtatm . getUserTransaction (  )  )     =  =    ut 2  )  )  ;", "assertNull (  \" TransactionManager   didn ' t   survive \"  ,    serializedJtatm . getTransactionManager (  )  )  ;", "assertEquals ( true ,    serializedJtatm . isRollbackOnCommitFailure (  )  )  ;", "}", "METHOD_END"], "methodName": ["serializable"], "fileName": "org.springframework.transaction.support.JtaTransactionManagerSerializationTests"}, {"methodBody": ["METHOD_START", "{", "if    ( deadlineReached )     {", "setRollbackOnly (  )  ;", "throw   new   TTimedOutException (  (  \" T   timed   out :    deadline   was    \"     +     ( this . deadline )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkTransactionTimeout"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "this . synchronizedWithTransaction    =    false ;", "this . rollbackOnly    =    false ;", "this . deadline    =    null ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . deadline ;", "}", "METHOD_END"], "methodName": ["getDeadline"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . deadline )     =  =    null )     {", "throw   new   IllegalStateException (  \" No   timeout   specified   for   this   resource   holder \"  )  ;", "}", "long   timeToLive    =     ( this . deadline . getTime (  )  )     -     ( System . currentTimeMillis (  )  )  ;", "checkTTimeout (  ( timeToLive    <  =     0  )  )  ;", "return   timeToLive ;", "}", "METHOD_END"], "methodName": ["getTimeToLiveInMillis"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "double   diff    =     (  ( double )     ( getTimeToLiveInMillis (  )  )  )     /     1  0  0  0  ;", "int   secs    =     (  ( int )     ( Math . ceil ( diff )  )  )  ;", "checkTTimeout (  ( secs    <  =     0  )  )  ;", "return   secs ;", "}", "METHOD_END"], "methodName": ["getTimeToLiveInSeconds"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "return    ( this . deadline )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasTimeout"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "return    ( this . referenceCount )     >     0  ;", "}", "METHOD_END"], "methodName": ["isOpen"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . rollbackOnly ;", "}", "METHOD_END"], "methodName": ["isRollbackOnly"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . synchronizedWithTransaction ;", "}", "METHOD_END"], "methodName": ["isSynchronizedWithTransaction"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "( this . referenceCount )  -  -  ;", "}", "METHOD_END"], "methodName": ["released"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "( this . referenceCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["requested"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "this . rollbackOnly    =    false ;", "}", "METHOD_END"], "methodName": ["resetRollbackOnly"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "this . rollbackOnly    =    true ;", "}", "METHOD_END"], "methodName": ["setRollbackOnly"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "this . synchronizedWithTransaction    =    synchronizedWithTransaction ;", "}", "METHOD_END"], "methodName": ["setSynchronizedWithTransaction"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "this . deadline    =    new   Date (  (  ( System . currentTimeMillis (  )  )     +    millis )  )  ;", "}", "METHOD_END"], "methodName": ["setTimeoutInMillis"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "setTimeoutInMillis (  ( seconds    *     1  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["setTimeoutInSeconds"], "fileName": "org.springframework.transaction.support.ResourceHolderSupport"}, {"methodBody": ["METHOD_START", "{", "return    !  ( shouldReleaseBeforeCompletion (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldReleaseAfterCompletion"], "fileName": "org.springframework.transaction.support.ResourceHolderSynchronization"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldReleaseBeforeCompletion"], "fileName": "org.springframework.transaction.support.ResourceHolderSynchronization"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldUnbindAtCompletion"], "fileName": "org.springframework.transaction.support.ResourceHolderSynchronization"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   context    =    new   GenericApplicationContext (  )  ;", "context . getBeanFactory (  )  . registerScope (  \" tx \"  ,    new    (  )  )  ;", "GenericBeanDefinition   bd 1     =    new   GenericBeanDefinition (  )  ;", "bd 1  . setBeanClass ( TestBean . class )  ;", "bd 1  . setScope (  \" tx \"  )  ;", "bd 1  . setPrimary ( true )  ;", "context . registerBeanDefinition (  \" txScopedObject 1  \"  ,    bd 1  )  ;", "GenericBeanDefinition   bd 2     =    new   GenericBeanDefinition (  )  ;", "bd 2  . setBeanClass ( DerivedTestBean . class )  ;", "bd 2  . setScope (  \" tx \"  )  ;", "context . registerBeanDefinition (  \" txScopedObject 2  \"  ,    bd 2  )  ;", "context . refresh (  )  ;", "try    {", "context . getBean ( TestBean . class )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalStateException )  )  ;", "}", "try    {", "context . getBean ( DerivedTestBean . class )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalStateException )  )  ;", "}", "TestBean   bean 1     =    null ;", "DerivedTestBean   bean 2     =    null ;", "DerivedTestBean   bean 2 a    =    null ;", "DerivedTestBean   bean 2 b    =    null ;", "TransactionSynchronizationManager . initSynchronization (  )  ;", "try    {", "bean 1     =    context . getBean ( TestBean . class )  ;", "assertSame ( bean 1  ,    context . getBean ( TestBean . class )  )  ;", "bean 2     =    context . getBean ( DerivedTestBean . class )  ;", "assertSame ( bean 2  ,    context . getBean ( DerivedTestBean . class )  )  ;", "context . getBeanFactory (  )  . destroyScopedBean (  \" txScopedObject 2  \"  )  ;", "assertFalse ( TransactionSynchronizationManager . hasResource (  \" txScopedObject 2  \"  )  )  ;", "assertTrue ( bean 2  . wasDestroyed (  )  )  ;", "bean 2 a    =    context . getBean ( DerivedTestBean . class )  ;", "assertSame ( bean 2 a ,    context . getBean ( DerivedTestBean . class )  )  ;", "assertNotSame ( bean 2  ,    bean 2 a )  ;", "context . getBeanFactory (  )  . getRegisteredScope (  \" tx \"  )  . remove (  \" txScopedObject 2  \"  )  ;", "assertFalse ( TransactionSynchronizationManager . hasResource (  \" txScopedObject 2  \"  )  )  ;", "assertFalse ( bean 2 a . wasDestroyed (  )  )  ;", "bean 2 b    =    context . getBean ( DerivedTestBean . class )  ;", "assertSame ( bean 2 b ,    context . getBean ( DerivedTestBean . class )  )  ;", "assertNotSame ( bean 2  ,    bean 2 b )  ;", "assertNotSame ( bean 2 a ,    bean 2 b )  ;", "}    finally    {", "TransactionSynchronizationUtils . triggerAfterCompletion ( TransactionSynchronization . STATUS _ COMMITTED )  ;", "TransactionSynchronizationManager . clearSynchronization (  )  ;", "}", "assertFalse ( bean 2 a . wasDestroyed (  )  )  ;", "assertTrue ( bean 2 b . wasDestroyed (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . getResourceMap (  )  . isEmpty (  )  )  ;", "try    {", "context . getBean ( TestBean . class )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalStateException )  )  ;", "}", "try    {", "context . getBean ( DerivedTestBean . class )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   IllegalStateException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getFromScope"], "fileName": "org.springframework.transaction.support.SimpleTransactionScopeTests"}, {"methodBody": ["METHOD_START", "{", "try    ( GenericApplicationContext   context    =    new   GenericApplicationContext (  )  )     {", "context . getBeanFactory (  )  . registerScope (  \" tx \"  ,    new    (  )  )  ;", "GenericBeanDefinition   bd 1     =    new   GenericBeanDefinition (  )  ;", "bd 1  . setBeanClass ( TestBean . class )  ;", "bd 1  . setScope (  \" tx \"  )  ;", "bd 1  . setPrimary ( true )  ;", "context . registerBeanDefinition (  \" txScopedObject 1  \"  ,    bd 1  )  ;", "GenericBeanDefinition   bd 2     =    new   GenericBeanDefinition (  )  ;", "bd 2  . setBeanClass ( DerivedTestBean . class )  ;", "bd 2  . setScope (  \" tx \"  )  ;", "context . registerBeanDefinition (  \" txScopedObject 2  \"  ,    bd 2  )  ;", "context . refresh (  )  ;", "CallCountingTransactionManager   tm    =    new   CallCountingTransactionManager (  )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "Set < DerivedTestBean >    finallyDestroy    =    new   HashSet <  >  (  )  ;", "tt . execute (  (    status )     -  >     {", "TestBean   bean 1     =    context . getBean ( TestBean . class )  ;", "assertSame ( bean 1  ,    context . getBean ( TestBean . class )  )  ;", "DerivedTestBean   bean 2     =    context . getBean ( DerivedTestBean . class )  ;", "assertSame ( bean 2  ,    context . getBean ( DerivedTestBean . class )  )  ;", "context . getBeanFactory (  )  . destroyScopedBean (  \" txScopedObject 2  \"  )  ;", "assertFalse ( TransactionSynchronizationManager . hasResource (  \" txScopedObject 2  \"  )  )  ;", "assertTrue ( bean 2  . wasDestroyed (  )  )  ;", "DerivedTestBean   bean 2 a    =    context . getBean ( DerivedTestBean . class )  ;", "assertSame ( bean 2 a ,    context . getBean ( DerivedTestBean . class )  )  ;", "assertNotSame ( bean 2  ,    bean 2 a )  ;", "context . getBeanFactory (  )  . getRegisteredScope (  \" tx \"  )  . remove (  \" txScopedObject 2  \"  )  ;", "assertFalse ( TransactionSynchronizationManager . hasResource (  \" txScopedObject 2  \"  )  )  ;", "assertFalse ( bean 2 a . wasDestroyed (  )  )  ;", "DerivedTestBean   bean 2 b    =    context . getBean ( DerivedTestBean . class )  ;", "finallyDestroy . add ( bean 2 b )  ;", "assertSame ( bean 2 b ,    context . getBean ( DerivedTestBean . class )  )  ;", "assertNotSame ( bean 2  ,    bean 2 b )  ;", "assertNotSame ( bean 2 a ,    bean 2 b )  ;", "Set < DerivedTestBean >    immediatelyDestroy    =    new   HashSet <  >  (  )  ;", "TransactionTemplate   tt 2     =    new   TransactionTemplate ( tm )  ;", "tt 2  . setPropagationBehavior ( TransactionTemplate . PROPAGATION _ REQUIRED )  ;", "tt 2  . execute (  (    status 2  )     -  >     {", "DerivedTestBean   bean 2 c    =    context . getBean ( DerivedTestBean . class )  ;", "immediatelyDestroy . add ( bean 2 c )  ;", "assertSame ( bean 2 c ,    context . getBean ( DerivedTestBean . class )  )  ;", "assertNotSame ( bean 2  ,    bean 2 c )  ;", "assertNotSame ( bean 2 a ,    bean 2 c )  ;", "assertNotSame ( bean 2 b ,    bean 2 c )  ;", "return   null ;", "}  )  ;", "assertTrue ( immediatelyDestroy . iterator (  )  . next (  )  . wasDestroyed (  )  )  ;", "assertFalse ( bean 2 b . wasDestroyed (  )  )  ;", "return   null ;", "}  )  ;", "assertTrue ( finallyDestroy . iterator (  )  . next (  )  . wasDestroyed (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getWithTransactionManager"], "fileName": "org.springframework.transaction.support.SimpleTransactionScopeTests"}, {"methodBody": ["METHOD_START", "{", "Object   actualKey    =    TransactionSynchronizationUtils . unwrapResourceIfNecessary ( key )  ;", "Assert . notNull ( value ,     \" Value   must   not   be   null \"  )  ;", "Map < Object ,    Object >    map    =     . resources . get (  )  ;", "if    ( map    =  =    null )     {", "map    =    new   HashMap <  >  (  )  ;", ". resources . set ( map )  ;", "}", "Object   oldValue    =    map . put ( actualKey ,    value )  ;", "if    (  ( oldValue   instanceof   ResourceHolder )     &  &     (  (  ( ResourceHolder )     ( oldValue )  )  . isVoid (  )  )  )     {", "oldValue    =    null ;", "}", "if    ( oldValue    !  =    null )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Already   value    [  \"     +    oldValue )     +     \"  ]    for   key    [  \"  )     +    actualKey )     +     \"  ]    bound   to   thread    [  \"  )     +     ( Thread . currentThread (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  (  (  (  (  \" Bound   value    [  \"     +    value )     +     \"  ]    for   key    [  \"  )     +    actualKey )     +     \"  ]    to   thread    [  \"  )     +     ( Thread . currentThread (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["bindResource"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationManager . synchronizations . remove (  )  ;", "TransactionSynchronizationManager . currentTransactionName . remove (  )  ;", "TransactionSynchronizationManager . currentTransactionReadOnly . remove (  )  ;", "TransactionSynchronizationManager . currentTransactionIsolationLevel . remove (  )  ;", "TransactionSynchronizationManager . actualTransactionActive . remove (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )     {", "throw   new   IllegalStateException (  \" Cannot   deactivate   transaction   synchronization    -    not   active \"  )  ;", "}", "TransactionSynchronizationManager . logger . trace (  \" Clearing   transaction   synchronization \"  )  ;", "TransactionSynchronizationManager . synchronizations . remove (  )  ;", "}", "METHOD_END"], "methodName": ["clearSynchronization"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "Map < Object ,    Object >    map    =    TransactionSynchronizationManager . resources . get (  )  ;", "if    ( map    =  =    null )     {", "return   null ;", "}", "Object   value    =    map . get ( actualKey )  ;", "if    (  ( value   instanceof   ResourceHolder )     &  &     (  (  ( ResourceHolder )     ( value )  )  . isVoid (  )  )  )     {", "map . remove ( actualKey )  ;", "if    ( map . isEmpty (  )  )     {", "TransactionSynchronizationManager . resources . remove (  )  ;", "}", "value    =    null ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["doGetResource"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "Map < Object ,    Object >    map    =    TransactionSynchronizationManager . resources . get (  )  ;", "if    ( map    =  =    null )     {", "return   null ;", "}", "Object   value    =    map . remove ( actualKey )  ;", "if    ( map . isEmpty (  )  )     {", "TransactionSynchronizationManager . resources . remove (  )  ;", "}", "if    (  ( value   instanceof   ResourceHolder )     &  &     (  (  ( ResourceHolder )     ( value )  )  . isVoid (  )  )  )     {", "value    =    null ;", "}", "if    (  ( value    !  =    null )     &  &     ( TransactionSynchronizationManager . logger . isTraceEnabled (  )  )  )     {", "TransactionSynchronizationManager . logger . trace (  (  (  (  (  (  (  \" Removed   value    [  \"     +    value )     +     \"  ]    for   key    [  \"  )     +    actualKey )     +     \"  ]    from   thread    [  \"  )     +     ( Thread . currentThread (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["doUnbindResource"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "return   TransactionSynchronizationManager . currentTransactionIsolationLevel . get (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentTransactionIsolationLevel"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "return   TransactionSynchronizationManager . currentTransactionName . get (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentTransactionName"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "Object   actualKey    =    TransactionSynchronizationUtils . unwrapResourceIfNecessary ( key )  ;", "Object   value    =     . doGetResource ( actualKey )  ;", "if    (  ( value    !  =    null )     &  &     (  . logger . isTraceEnabled (  )  )  )     {", ". logger . trace (  (  (  (  (  (  (  \" Retrieved   value    [  \"     +    value )     +     \"  ]    for   key    [  \"  )     +    actualKey )     +     \"  ]    bound   to   thread    [  \"  )     +     ( Thread . currentThread (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "Map < Object ,    Object >    map    =    TransactionSynchronizationManager . resources . get (  )  ;", "return   map    !  =    null    ?    Collections . unmodifiableMap ( map )     :    Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceMap"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "Set < TransactionSynchronization >    synchs    =    TransactionSynchronizationManager . synchronizations . get (  )  ;", "if    ( synchs    =  =    null )     {", "throw   new   IllegalStateException (  \" Transaction   synchronization   is   not   active \"  )  ;", "}", "if    ( synchs . isEmpty (  )  )     {", "return   Collections . emptyList (  )  ;", "} else    {", "List < TransactionSynchronization >    sortedSynchs    =    new   ArrayList <  >  ( synchs )  ;", "AnnotationAwareOrderComparator . sort ( sortedSynchs )  ;", "return   Collections . unmodifiableList ( sortedSynchs )  ;", "}", "}", "METHOD_END"], "methodName": ["getSynchronizations"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "Object   actualKey    =    TransactionSynchronizationUtils . unwrapResourceIfNecessary ( key )  ;", "Object   value    =     . doGetResource ( actualKey )  ;", "return   value    !  =    null ;", "}", "METHOD_END"], "methodName": ["hasResource"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "if    ( TransactionSynchronizationManager . isSynchronizationActive (  )  )     {", "throw   new   IllegalStateException (  \" Cannot   activate   transaction   synchronization    -    already   active \"  )  ;", "}", "TransactionSynchronizationManager . logger . trace (  \" Initializing   transaction   synchronization \"  )  ;", "TransactionSynchronizationManager . synchronizations . set ( new   LinkedHashSet <  >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["initSynchronization"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "return    ( TransactionSynchronizationManager . actualTransactionActive . get (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isActualTransactionActive"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "return    ( TransactionSynchronizationManager . currentTransactionReadOnly . get (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isCurrentTransactionReadOnly"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "return    ( TransactionSynchronizationManager . synchronizations . get (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isSynchronizationActive"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( synchronization ,     \" TransactionSynchronization   must   not   be   null \"  )  ;", "if    (  !  (  . isSynchronizationActive (  )  )  )     {", "throw   new   IllegalStateException (  \" Transaction   synchronization   is   not   active \"  )  ;", "}", ". synchronizations . get (  )  . add ( synchronization )  ;", "}", "METHOD_END"], "methodName": ["registerSynchronization"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationManager . actualTransactionActive . set (  ( active    ?    Boolean . TRUE    :    null )  )  ;", "}", "METHOD_END"], "methodName": ["setActualTransactionActive"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationManager . currentTransactionIsolationLevel . set ( isolationLevel )  ;", "}", "METHOD_END"], "methodName": ["setCurrentTransactionIsolationLevel"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationManager . currentTransactionName . set ( name )  ;", "}", "METHOD_END"], "methodName": ["setCurrentTransactionName"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationManager . currentTransactionReadOnly . set (  ( readOnly    ?    Boolean . TRUE    :    null )  )  ;", "}", "METHOD_END"], "methodName": ["setCurrentTransactionReadOnly"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "Object   actualKey    =    TransactionSynchronizationUtils . unwrapResourceIfNecessary ( key )  ;", "Object   value    =     . doUnbindResource ( actualKey )  ;", "if    ( value    =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  (  \" No   value   for   key    [  \"     +    actualKey )     +     \"  ]    bound   to   thread    [  \"  )     +     ( Thread . currentThread (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["unbindResource"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "Object   actualKey    =    TransactionSynchronizationUtils . unwrapResourceIfNecessary ( key )  ;", "return    . doUnbindResource ( actualKey )  ;", "}", "METHOD_END"], "methodName": ["unbindResourceIfPossible"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationManager"}, {"methodBody": ["METHOD_START", "{", "if    ( synchronizations    !  =    null )     {", "for    (    synchronization    :    synchronizations )     {", "synchronization . afterCommit (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invokeAfterCommit"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( synchronizations    !  =    null )     {", "for    ( TransactionSynchronization   synchronization    :    synchronizations )     {", "try    {", "synchronization . afterCompletion ( completionStatus )  ;", "}    catch    ( Throwable   tsex )     {", ". logger . error (  \" TransactionSynchronization . afterCompletion   threw   exception \"  ,    tsex )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["invokeAfterCompletion"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationUtils"}, {"methodBody": ["METHOD_START", "{", "return   TransactionSynchronizationUtils . unwrapResourceIfNecessary ( tm . getResourceFactory (  )  )  . equals ( TransactionSynchronizationUtils . unwrapResourceIfNecessary ( resourceFactory )  )  ;", "}", "METHOD_END"], "methodName": ["sameResourceFactory"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationUtils"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationUtils . invokeAfterCommit ( TransactionSynchronizationManager . getSynchronizations (  )  )  ;", "}", "METHOD_END"], "methodName": ["triggerAfterCommit"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationUtils"}, {"methodBody": ["METHOD_START", "{", "List < TransactionSynchronization >    synchronizations    =    TransactionSynchronizationManager . getSynchronizations (  )  ;", ". invokeAfterCompletion ( synchronizations ,    completionStatus )  ;", "}", "METHOD_END"], "methodName": ["triggerAfterCompletion"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( TransactionSynchronization   synchronization    :    TransactionSynchronizationManager . getSynchronizations (  )  )     {", "synchronization . beforeCommit ( readOnly )  ;", "}", "}", "METHOD_END"], "methodName": ["triggerBeforeCommit"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( TransactionSynchronization   synchronization    :    TransactionSynchronizationManager . getSynchronizations (  )  )     {", "try    {", "synchronization . beforeCompletion (  )  ;", "}    catch    ( Throwable   tsex )     {", ". logger . error (  \" TransactionSynchronization . beforeCompletion   threw   exception \"  ,    tsex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["triggerBeforeCompletion"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( TransactionSynchronization   synchronization    :    TransactionSynchronizationManager . getSynchronizations (  )  )     {", "synchronization . flush (  )  ;", "}", "}", "METHOD_END"], "methodName": ["triggerFlush"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resource ,     \" Resource   must   not   be   null \"  )  ;", "Object   resourceRef    =    resource ;", "if    ( resourceRef   instanceof   InfrastructureProxy )     {", "resourceRef    =     (  ( InfrastructureProxy )     ( resourceRef )  )  . getWrappedObject (  )  ;", "}", "if    (  . aopAvailable )     {", "resourceRef    =     . ScopedProxyUnwrapper . unwrapIfNecessary ( resourceRef )  ;", "}", "return   resourceRef ;", "}", "METHOD_END"], "methodName": ["unwrapResourceIfNecessary"], "fileName": "org.springframework.transaction.support.TransactionSynchronizationUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionManager ;", "}", "METHOD_END"], "methodName": ["getTransactionManager"], "fileName": "org.springframework.transaction.support.TransactionTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . transactionManager )     !  =    null )  ,     \" No   PlatformTransactionManager   set \"  )  ;", "logger . debug (  \" Initiating   transaction   rollback   on   application   exception \"  ,    ex )  ;", "try    {", "this . transactionManager . rollback ( status )  ;", "}    catch    ( TransactionSystemException   ex 2  )     {", "logger . error (  \" Application   exception   overridden   by   rollback   exception \"  ,    ex )  ;", "ex 2  . initApplicationException ( ex )  ;", "throw   ex 2  ;", "}    catch    ( RuntimeException    |    Error   ex 2  )     {", "logger . error (  \" Application   exception   overridden   by   rollback   exception \"  ,    ex )  ;", "throw   ex 2  ;", "}", "}", "METHOD_END"], "methodName": ["rollbackOnException"], "fileName": "org.springframework.transaction.support.TransactionTemplate"}, {"methodBody": ["METHOD_START", "{", "this . transactionManager    =    transactionManager ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.transaction.support.TransactionTemplate"}]