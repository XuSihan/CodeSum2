[{"methodBody": ["METHOD_START", "{", "if    (  ( av )     !  =    null )     {", "av . v ( name ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.springframework.asm.AnnotationVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( av )     !  =    null )     {", "return   av . visit ( name ,    desc )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitAnnotation"], "fileName": "org.springframework.asm.AnnotationVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( av )     !  =    null )     {", "return   av . vArray ( name )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitArray"], "fileName": "org.springframework.asm.AnnotationVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( av )     !  =    null )     {", "av . vEnd (  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitEnd"], "fileName": "org.springframework.asm.AnnotationVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( av )     !  =    null )     {", "av . vEnum ( name ,    desc ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["visitEnum"], "fileName": "org.springframework.asm.AnnotationVisitor"}, {"methodBody": ["METHOD_START", "{", "int   size    =     0  ;", "aw    =    this ;", "while    ( aw    !  =    null )     {", "size    +  =    aw . bv . length ;", "aw    =    aw . next ;", "}", "return   size ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.springframework.asm.AnnotationWriter"}, {"methodBody": ["METHOD_START", "{", "int   size    =     1     +     (  2     *     (  ( panns . length )     -    off )  )  ;", "for    ( int   i    =    off ;    i    <     ( panns . length )  ;     +  + i )     {", "size    +  =     (  ( panns [ i ]  )     =  =    null )     ?     0     :    panns [ i ]  . getSize (  )  ;", "}", "out . putInt ( size )  . putByte (  (  ( panns . length )     -    off )  )  ;", "for    ( int   i    =    off ;    i    <     ( panns . length )  ;     +  + i )     {", "aw    =    panns [ i ]  ;", "last    =    null ;", "int   n    =     0  ;", "while    ( aw    !  =    null )     {", "+  + n ;", "aw . visitEnd (  )  ;", "aw . prev    =    last ;", "last    =    aw ;", "aw    =    aw . next ;", "}", "out . putShort ( n )  ;", "aw    =    last ;", "while    ( aw    !  =    null )     {", "out . putByteArray ( aw . bv . data ,     0  ,    aw . bv . length )  ;", "aw    =    aw . prev ;", "}", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.asm.AnnotationWriter"}, {"methodBody": ["METHOD_START", "{", "int   n    =     0  ;", "int   size    =     2  ;", "aw    =    this ;", "last    =    null ;", "while    ( aw    !  =    null )     {", "+  + n ;", "size    +  =    aw . bv . length ;", "aw . visitEnd (  )  ;", "aw . prev    =    last ;", "last    =    aw ;", "aw    =    aw . next ;", "}", "out . putInt ( size )  ;", "out . putShort ( n )  ;", "aw    =    last ;", "while    ( aw    !  =    null )     {", "out . putByteArray ( aw . bv . data ,     0  ,    aw . bv . length )  ;", "aw    =    aw . prev ;", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.asm.AnnotationWriter"}, {"methodBody": ["METHOD_START", "{", "switch    ( typeRef    >  >  >     2  4  )     {", "case    0     :", "case    1     :", "case    2  2     :", "out . putShort (  ( typeRef    >  >  >     1  6  )  )  ;", "break ;", "case    1  9     :", "case    2  0     :", "case    2  1     :", "out . putByte (  ( typeRef    >  >  >     2  4  )  )  ;", "break ;", "case    7  1     :", "case    7  2     :", "case    7  3     :", "case    7  4     :", "case    7  5     :", "out . putInt ( typeRef )  ;", "break ;", "default    :", "out . put 1  2  (  ( typeRef    >  >  >     2  4  )  ,     (  ( typeRef    &     1  6  7  7  6  9  6  0  )     >  >     8  )  )  ;", "break ;", "}", "if    ( typePath    =  =    null )     {", "out . putByte (  0  )  ;", "} else    {", "int   length    =     (  ( typePath . b [ typePath . offset ]  )     *     2  )     +     1  ;", "out . putByteArray ( typePath . b ,    typePath . offset ,    length )  ;", "}", "}", "METHOD_END"], "methodName": ["putTarget"], "fileName": "org.springframework.asm.AnnotationWriter"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "attr    =    this ;", "while    ( attr    !  =    null )     {", "count    +  =     1  ;", "attr    =    attr . next ;", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.asm.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getLabels"], "fileName": "org.springframework.asm.Attribute"}, {"methodBody": ["METHOD_START", "{", "Attribute   attr    =    this ;", "int   size    =     0  ;", "while    ( attr    !  =    null )     {", "cw . newUTF 8  ( attr . type )  ;", "size    +  =     ( attr . write ( cw ,    code ,    len ,    maxStack ,    maxLocals )  . length )     +     6  ;", "attr    =    attr . next ;", "}", "return   size ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.springframework.asm.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCodeAttribute"], "fileName": "org.springframework.asm.Attribute"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isUnknown"], "fileName": "org.springframework.asm.Attribute"}, {"methodBody": ["METHOD_START", "{", "Attribute   attr    =    this ;", "while    ( attr    !  =    null )     {", "ByteVector   b    =    attr . write ( cw ,    code ,    len ,    maxStack ,    maxLocals )  ;", "out . putShort ( cw . newUTF 8  ( attr . type )  )  . putInt ( b . length )  ;", "out . putByteArray ( b . data ,     0  ,    b . length )  ;", "attr    =    attr . next ;", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.asm.Attribute"}, {"methodBody": ["METHOD_START", "{", "Attribute   attr    =    new   Attribute ( type )  ;", "attr . value    =    new   byte [ len ]  ;", "System . arraycopy ( cr . b ,    off ,    attr . value ,     0  ,    len )  ;", "return   attr ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.asm.Attribute"}, {"methodBody": ["METHOD_START", "{", "ByteVector   v    =    new   ByteVector (  )  ;", "v . data    =    value ;", "v . length    =    value . length ;", "return   v ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.asm.Attribute"}, {"methodBody": ["METHOD_START", "{", "int   charLength    =    s . length (  )  ;", "int   byteLength    =    i ;", "char   c ;", "for    ( int   j    =    i ;    j    <    charLength ;     +  + j )     {", "c    =    s . charAt ( j )  ;", "if    (  ( c    >  =     '  \\ u 0  0  0  1  '  )     &  &     ( c    <  =     '  \\ u 0  0  7 f '  )  )     {", "byteLength +  +  ;", "} else", "if    ( c    >     '  \\ u 0  7 ff '  )     {", "byteLength    +  =     3  ;", "} else    {", "byteLength    +  =     2  ;", "}", "}", "if    ( byteLength    >    maxLength )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "int   start    =     (  ( length )     -    i )     -     2  ;", "if    ( start    >  =     0  )     {", "data [ start ]     =     (  ( byte )     ( byteLength    >  >  >     8  )  )  ;", "data [  ( start    +     1  )  ]     =     (  ( byte )     ( byteLength )  )  ;", "}", "if    (  (  (  ( length )     +    byteLength )     -    i )     >     ( data . length )  )     {", "enlarge (  ( byteLength    -    i )  )  ;", "}", "int   len    =    length ;", "for    ( int   j    =    i ;    j    <    charLength ;     +  + j )     {", "c    =    s . charAt ( j )  ;", "if    (  ( c    >  =     '  \\ u 0  0  0  1  '  )     &  &     ( c    <  =     '  \\ u 0  0  7 f '  )  )     {", "data [  ( len +  +  )  ]     =     (  ( byte )     ( c )  )  ;", "} else", "if    ( c    >     '  \\ u 0  7 ff '  )     {", "data [  ( len +  +  )  ]     =     (  ( byte )     (  2  2  4     |     (  ( c    >  >     1  2  )     &     1  5  )  )  )  ;", "data [  ( len +  +  )  ]     =     (  ( byte )     (  1  2  8     |     (  ( c    >  >     6  )     &     6  3  )  )  )  ;", "data [  ( len +  +  )  ]     =     (  ( byte )     (  1  2  8     |     ( c    &     6  3  )  )  )  ;", "} else    {", "data [  ( len +  +  )  ]     =     (  ( byte )     (  1  9  2     |     (  ( c    >  >     6  )     &     3  1  )  )  )  ;", "data [  ( len +  +  )  ]     =     (  ( byte )     (  1  2  8     |     ( c    &     6  3  )  )  )  ;", "}", "}", "length    =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["encodeUTF8"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "int   length 1     =     2     *     ( data . length )  ;", "int   length 2     =     ( length )     +    size ;", "b [  ]    newData    =    new   b [ length 1     >    length 2     ?    length 1     :    length 2  ]  ;", "System . arraycopy ( data ,     0  ,    newData ,     0  ,    length )  ;", "data    =    newData ;", "}", "METHOD_END"], "methodName": ["enlarge"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "int   length    =    this . length ;", "if    (  ( length    +     2  )     >     ( data . length )  )     {", "enlarge (  2  )  ;", "}", "b [  ]    data    =    this . data ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( b 1  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( b 2  )  )  ;", "this . length    =    length ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put11"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "int   length    =    this . length ;", "if    (  ( length    +     3  )     >     ( data . length )  )     {", "enlarge (  3  )  ;", "}", "b [  ]    data    =    this . data ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( b )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( s    >  >  >     8  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( s )  )  ;", "this . length    =    length ;", "return   this ;", "}", "METHOD_END"], "methodName": ["put12"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "int   length    =    this . length ;", "if    (  ( length    +     1  )     >     ( data . length )  )     {", "enlarge (  1  )  ;", "}", "data [  ( length +  +  )  ]     =     (  ( b )     ( b )  )  ;", "this . length    =    length ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putByte"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( length )     +    len )     >     ( data . length )  )     {", "enlarge ( len )  ;", "}", "if    ( b    !  =    null )     {", "System . arraycopy ( b ,    off ,    data ,    length ,    len )  ;", "}", "length    +  =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putByteArray"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "int   length    =    this . length ;", "if    (  ( length    +     4  )     >     ( data . length )  )     {", "enlarge (  4  )  ;", "}", "b [  ]    data    =    this . data ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i    >  >  >     2  4  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i    >  >  >     1  6  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i    >  >  >     8  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i )  )  ;", "this . length    =    length ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putInt"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "int   length    =    this . length ;", "if    (  ( length    +     8  )     >     ( data . length )  )     {", "enlarge (  8  )  ;", "}", "b [  ]    data    =    this . data ;", "int   i    =     (  ( int )     ( l    >  >  >     3  2  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i    >  >  >     2  4  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i    >  >  >     1  6  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i    >  >  >     8  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i )  )  ;", "i    =     (  ( int )     ( l )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i    >  >  >     2  4  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i    >  >  >     1  6  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i    >  >  >     8  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( i )  )  ;", "this . length    =    length ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putLong"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "int   length    =    this . length ;", "if    (  ( length    +     2  )     >     ( data . length )  )     {", "enlarge (  2  )  ;", "}", "b [  ]    data    =    this . data ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( s    >  >  >     8  )  )  ;", "data [  ( length +  +  )  ]     =     (  ( b )     ( s )  )  ;", "this . length    =    length ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putShort"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "int   charLength    =    s . length (  )  ;", "if    ( charLength    >     6  5  5  3  5  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "int   len    =    length ;", "if    (  (  ( len    +     2  )     +    charLength )     >     ( data . length )  )     {", "enlarge (  (  2     +    charLength )  )  ;", "}", "b [  ]    data    =    this . data ;", "data [  ( len +  +  )  ]     =     (  ( b )     ( charLength    >  >  >     8  )  )  ;", "data [  ( len +  +  )  ]     =     (  ( b )     ( charLength )  )  ;", "for    ( int   i    =     0  ;    i    <    charLength ;     +  + i )     {", "char   c    =    s . charAt ( i )  ;", "if    (  ( c    >  =     '  \\ u 0  0  0  1  '  )     &  &     ( c    <  =     '  \\ u 0  0  7 f '  )  )     {", "data [  ( len +  +  )  ]     =     (  ( b )     ( c )  )  ;", "} else    {", "length    =    len ;", "return   encodeUTF 8  ( s ,    i ,     6  5  5  3  5  )  ;", "}", "}", "length    =    len ;", "return   this ;", "}", "METHOD_END"], "methodName": ["putUTF8"], "fileName": "org.springframework.asm.ByteVector"}, {"methodBody": ["METHOD_START", "{", "accept ( classVisitor ,    new   Attribute [  0  ]  ,    flags )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   u    =    header ;", "char [  ]    c    =    new   char [ maxStringLength ]  ;", "Context   context    =    new   Context (  )  ;", "context . attrs    =    attrs ;", "context . flags    =    flags ;", "context . buffer    =    c ;", "int   access    =    readUnsignedShort ( u )  ;", "String   name    =    readClass (  ( u    +     2  )  ,    c )  ;", "String   superClass    =    readClass (  ( u    +     4  )  ,    c )  ;", "String [  ]    interfaces    =    new   String [ readUnsignedShort (  ( u    +     6  )  )  ]  ;", "u    +  =     8  ;", "for    ( int   i    =     0  ;    i    <     ( interfaces . length )  ;     +  + i )     {", "interfaces [ i ]     =    readClass ( u ,    c )  ;", "u    +  =     2  ;", "}", "String   signature    =    null ;", "String   sourceFile    =    null ;", "String   sourceDebug    =    null ;", "String   enclosingOwner    =    null ;", "String   enclosingName    =    null ;", "String   enclosingDesc    =    null ;", "String   moduleMainClass    =    null ;", "int   anns    =     0  ;", "int   ianns    =     0  ;", "int   tanns    =     0  ;", "int   itanns    =     0  ;", "int   innerClasses    =     0  ;", "int   module    =     0  ;", "int   packages    =     0  ;", "Attribute   attributes    =    null ;", "u    =    getAttributes (  )  ;", "for    ( int   i    =    readUnsignedShort ( u )  ;    i    >     0  ;     -  - i )     {", "String   attrName    =    readUTF 8  (  ( u    +     2  )  ,    c )  ;", "if    (  \" SourceFile \"  . equals ( attrName )  )     {", "sourceFile    =    readUTF 8  (  ( u    +     8  )  ,    c )  ;", "} else", "if    (  \" InnerClasses \"  . equals ( attrName )  )     {", "innerClasses    =    u    +     8  ;", "} else", "if    (  \" EnclosingMethod \"  . equals ( attrName )  )     {", "enclosingOwner    =    readClass (  ( u    +     8  )  ,    c )  ;", "int   item    =    readUnsignedShort (  ( u    +     1  0  )  )  ;", "if    ( item    !  =     0  )     {", "enclosingName    =    readUTF 8  ( items [ item ]  ,    c )  ;", "enclosingDesc    =    readUTF 8  (  (  ( items [ item ]  )     +     2  )  ,    c )  ;", "}", "} else", "if    (  (  . SIGNATURES )     &  &     (  \" Signature \"  . equals ( attrName )  )  )     {", "signature    =    readUTF 8  (  ( u    +     8  )  ,    c )  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeVisibleAnnotations \"  . equals ( attrName )  )  )     {", "anns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeVisibleTypeAnnotations \"  . equals ( attrName )  )  )     {", "tanns    =    u    +     8  ;", "} else", "if    (  \" Deprecated \"  . equals ( attrName )  )     {", "access    |  =    Opcodes . ACC _ DEPRECATED ;", "} else", "if    (  \" Synthetic \"  . equals ( attrName )  )     {", "access    |  =     ( Opcodes . ACC _ SYNTHETIC )     |     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  ;", "} else", "if    (  \" SourceDebugExtension \"  . equals ( attrName )  )     {", "int   len    =    readInt (  ( u    +     4  )  )  ;", "sourceDebug    =    readUTF (  ( u    +     8  )  ,    len ,    new   char [ len ]  )  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeInvisibleAnnotations \"  . equals ( attrName )  )  )     {", "ianns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeInvisibleTypeAnnotations \"  . equals ( attrName )  )  )     {", "itanns    =    u    +     8  ;", "} else", "if    (  \" Module \"  . equals ( attrName )  )     {", "module    =    u    +     8  ;", "} else", "if    (  \" ModuleMainClass \"  . equals ( attrName )  )     {", "moduleMainClass    =    readClass (  ( u    +     8  )  ,    c )  ;", "} else", "if    (  \" ModulePackages \"  . equals ( attrName )  )     {", "packages    =    u    +     1  0  ;", "} else", "if    (  \" BootstrapMethods \"  . equals ( attrName )  )     {", "int [  ]    bootstrapMethods    =    new   int [ readUnsignedShort (  ( u    +     8  )  )  ]  ;", "for    ( int   j    =     0  ,    v    =    u    +     1  0  ;    j    <     ( bootstrapMethods . length )  ;    j +  +  )     {", "bootstrapMethods [ j ]     =    v ;", "v    +  =     (  2     +     ( readUnsignedShort (  ( v    +     2  )  )  )  )     <  <     1  ;", "}", "context . bootstrapMethods    =    bootstrapMethods ;", "} else    {", "Attribute   attr    =    readAttribute ( attrs ,    attrName ,     ( u    +     8  )  ,    readInt (  ( u    +     4  )  )  ,    c ,     (  -  1  )  ,    null )  ;", "if    ( attr    !  =    null )     {", "attr . next    =    attributes ;", "attributes    =    attr ;", "}", "}", "u    +  =     6     +     ( readInt (  ( u    +     4  )  )  )  ;", "}", "classVisitor . visit ( readInt (  (  ( items [  1  ]  )     -     7  )  )  ,    access ,    name ,    signature ,    superClass ,    interfaces )  ;", "if    (  (  ( flags    &     (  . SKIP _ DEBUG )  )     =  =     0  )     &  &     (  ( sourceFile    !  =    null )     |  |     ( sourceDebug    !  =    null )  )  )     {", "classVisitor . visitSource ( sourceFile ,    sourceDebug )  ;", "}", "if    ( module    !  =     0  )     {", "readModule ( classVisitor ,    context ,    module ,    moduleMainClass ,    packages )  ;", "}", "if    ( enclosingOwner    !  =    null )     {", "classVisitor . visitOuterClass ( enclosingOwner ,    enclosingName ,    enclosingDesc )  ;", "}", "if    (  (  . ANNOTATIONS )     &  &     ( anns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( anns )  ,    v    =    anns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    classVisitor . visitAnnotation ( readUTF 8  ( v ,    c )  ,    true )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( ianns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( ianns )  ,    v    =    ianns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    classVisitor . visitAnnotation ( readUTF 8  ( v ,    c )  ,    false )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( tanns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( tanns )  ,    v    =    tanns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationTarget ( context ,    v )  ;", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    classVisitor . visitTypeAnnotation ( context . typeRef ,    context . typePath ,    readUTF 8  ( v ,    c )  ,    true )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( itanns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( itanns )  ,    v    =    itanns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationTarget ( context ,    v )  ;", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    classVisitor . visitTypeAnnotation ( context . typeRef ,    context . typePath ,    readUTF 8  ( v ,    c )  ,    false )  )  ;", "}", "}", "while    ( attributes    !  =    null )     {", "Attribute   attr    =    attributes . next ;", "attributes . next    =    null ;", "classVisitor . visitAttribute ( attributes )  ;", "attributes    =    attr ;", "}", "if    ( innerClasses    !  =     0  )     {", "int   v    =    innerClasses    +     2  ;", "for    ( int   i    =    readUnsignedShort ( innerClasses )  ;    i    >     0  ;     -  - i )     {", "classVisitor . visitInnerClass ( readClass ( v ,    c )  ,    readClass (  ( v    +     2  )  ,    c )  ,    readUTF 8  (  ( v    +     4  )  ,    c )  ,    readUnsignedShort (  ( v    +     6  )  )  )  ;", "v    +  =     8  ;", "}", "}", "u    =     (  ( header )     +     1  0  )     +     (  2     *     ( interfaces . length )  )  ;", "for    ( int   i    =    readUnsignedShort (  ( u    -     2  )  )  ;    i    >     0  ;     -  - i )     {", "u    =    readField ( classVisitor ,    context ,    u )  ;", "}", "u    +  =     2  ;", "for    ( int   i    =    readUnsignedShort (  ( u    -     2  )  )  ;    i    >     0  ;     -  - i )     {", "u    =    readMethod ( classVisitor ,    context ,    u )  ;", "}", "classVisitor . visitEnd (  )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   u    =    getAttributes (  )  ;", "boolean   found    =    false ;", "for    ( int   i    =    readUnsignedShort ( u )  ;    i    >     0  ;     -  - i )     {", "St   attrName    =    readUTF 8  (  ( u    +     2  )  ,    c )  ;", "if    (  \" BootstrapMethods \"  . equals ( attrName )  )     {", "found    =    true ;", "break ;", "}", "u    +  =     6     +     ( readInt (  ( u    +     4  )  )  )  ;", "}", "if    (  ! found )     {", "return ;", "}", "int   boostrapMethodCount    =    readUnsignedShort (  ( u    +     8  )  )  ;", "for    ( int   j    =     0  ,    v    =    u    +     1  0  ;    j    <    boostrapMethodCount ;    j +  +  )     {", "int   position    =     ( v    -    u )     -     1  0  ;", "int   hashCode    =    readConst ( readUnsignedShort ( v )  ,    c )  . hashCode (  )  ;", "for    ( int   k    =    readUnsignedShort (  ( v    +     2  )  )  ;    k    >     0  ;     -  - k )     {", "hashCode    ^  =    readConst ( readUnsignedShort (  ( v    +     4  )  )  ,    c )  . hashCode (  )  ;", "v    +  =     2  ;", "}", "v    +  =     4  ;", "Item   item    =    new   Item ( j )  ;", "item . set ( position ,     ( hashCode    &     2  1  4  7  4  8  3  6  4  7  )  )  ;", "int   index    =     ( item . hashCode )     %     ( items . length )  ;", "item . next    =    items [ index ]  ;", "items [ index ]     =    item ;", "}", "int   attrSize    =    readInt (  ( u    +     4  )  )  ;", "ByteVector   bootstrapMethods    =    new   ByteVector (  ( attrSize    +     6  2  )  )  ;", "bootstrapMethods . putByteArray ( b ,     ( u    +     1  0  )  ,     ( attrSize    -     2  )  )  ;", "classWriter . bootstrapMethodsCount    =    boostrapMethodCount ;", "classWriter . bootstrapMethods    =    bootstrapMethods ;", "}", "METHOD_END"], "methodName": ["copyBootstrapMethods"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    buf    =    new   char [ maxStringLength ]  ;", "int   ll    =    items . length ;", "Item [  ]    items 2     =    new   Item [ ll ]  ;", "for    ( int   i    =     1  ;    i    <    ll ;    i +  +  )     {", "int   index    =    items [ i ]  ;", "int   tag    =    b [  ( index    -     1  )  ]  ;", "Item   item    =    new   Item ( i )  ;", "int   nameType ;", "switch    ( tag )     {", "case   Writer . FIELD    :", "case   Writer . METH    :", "case   Writer . IMETH    :", "nameType    =    items [ readUnsignedShort (  ( index    +     2  )  )  ]  ;", "item . set ( tag ,    read ( index ,    buf )  ,    readUTF 8  ( nameType ,    buf )  ,    readUTF 8  (  ( nameType    +     2  )  ,    buf )  )  ;", "break ;", "case   Writer . INT    :", "item . set ( readInt ( index )  )  ;", "break ;", "case   Writer . FLOAT    :", "item . set ( Float . intBitsToFloat ( readInt ( index )  )  )  ;", "break ;", "case   Writer . NAME _ TYPE    :", "item . set ( tag ,    readUTF 8  ( index ,    buf )  ,    readUTF 8  (  ( index    +     2  )  ,    buf )  ,    null )  ;", "break ;", "case   Writer . LONG    :", "item . set ( readLong ( index )  )  ;", "+  + i ;", "break ;", "case   Writer . DOUBLE    :", "item . set ( Double . longBitsToDouble ( readLong ( index )  )  )  ;", "+  + i ;", "break ;", "case   Writer . UTF 8     :", "{", "String   s    =    strings [ i ]  ;", "if    ( s    =  =    null )     {", "index    =    items [ i ]  ;", "s    =    strings [ i ]     =    readUTF (  ( index    +     2  )  ,    readUnsignedShort ( index )  ,    buf )  ;", "}", "item . set ( tag ,    s ,    null ,    null )  ;", "break ;", "}", "case   Writer . HANDLE    :", "{", "int   fieldOrMethodRef    =    items [ readUnsignedShort (  ( index    +     1  )  )  ]  ;", "nameType    =    items [ readUnsignedShort (  ( fieldOrMethodRef    +     2  )  )  ]  ;", "item . set (  (  ( Writer . HANDLE _ BASE )     +     ( readByte ( index )  )  )  ,    read ( fieldOrMethodRef ,    buf )  ,    readUTF 8  ( nameType ,    buf )  ,    readUTF 8  (  ( nameType    +     2  )  ,    buf )  )  ;", "break ;", "}", "case   Writer . INDY    :", "if    (  ( classWriter . bootstrapMethods )     =  =    null )     {", "copyBootstrapMethods ( classWriter ,    items 2  ,    buf )  ;", "}", "nameType    =    items [ readUnsignedShort (  ( index    +     2  )  )  ]  ;", "item . set ( readUTF 8  ( nameType ,    buf )  ,    readUTF 8  (  ( nameType    +     2  )  ,    buf )  ,    readUnsignedShort ( index )  )  ;", "break ;", "default    :", "item . set ( tag ,    readUTF 8  ( index ,    buf )  ,    null ,    null )  ;", "break ;", "}", "int   index 2     =     ( item . hashCode )     %     ( items 2  . length )  ;", "item . next    =    items 2  [ index 2  ]  ;", "items 2  [ index 2  ]     =    item ;", "}", "int   off    =     ( items [  1  ]  )     -     1  ;", "classWriter . pool . putByteArray ( b ,    off ,     (  ( header )     -    off )  )  ;", "classWriter . items    =    items 2  ;", "classWriter . threshold    =     (  ( int )     (  0  .  7  5     *    ll )  )  ;", "classWriter . index    =    ll ;", "}", "METHOD_END"], "methodName": ["copyPool"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   readUnsignedShort ( header )  ;", "}", "METHOD_END"], "methodName": ["getAccess"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   u    =     (  ( header )     +     8  )     +     (  ( readUnsignedShort (  (  ( header )     +     6  )  )  )     *     2  )  ;", "for    ( int   i    =    readUnsignedShort ( u )  ;    i    >     0  ;     -  - i )     {", "for    ( int   j    =    readUnsignedShort (  ( u    +     8  )  )  ;    j    >     0  ;     -  - j )     {", "u    +  =     6     +     ( readInt (  ( u    +     1  2  )  )  )  ;", "}", "u    +  =     8  ;", "}", "u    +  =     2  ;", "for    ( int   i    =    readUnsignedShort ( u )  ;    i    >     0  ;     -  - i )     {", "for    ( int   j    =    readUnsignedShort (  ( u    +     8  )  )  ;    j    >     0  ;     -  - j )     {", "u    +  =     6     +     ( readInt (  ( u    +     1  2  )  )  )  ;", "}", "u    +  =     8  ;", "}", "return   u    +     2  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   readClass (  (  ( header )     +     2  )  ,    new   char [ maxStringLength ]  )  ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "String   desc    =    frame . desc ;", "Object [  ]    locals    =    frame . local ;", "int   local    =     0  ;", "if    (  (  ( frame . access )     &     ( Opcodes . ACC _ STATIC )  )     =  =     0  )     {", "if    (  \"  < init >  \"  . equals ( frame . name )  )     {", "locals [  ( local +  +  )  ]     =    Opcodes . UNINITIALIZED _ THIS ;", "} else    {", "locals [  ( local +  +  )  ]     =    readClass (  (  ( header )     +     2  )  ,    frame . buffer )  ;", "}", "}", "int   i    =     1  ;", "loop    :    while    ( true )     {", "int   j    =    i ;", "switch    ( desc . charAt (  ( i +  +  )  )  )     {", "case    ' Z '     :", "case    ' C '     :", "case    ' B '     :", "case    ' S '     :", "case    ' I '     :", "locals [  ( local +  +  )  ]     =    Opcodes . INTEGER ;", "break ;", "case    ' F '     :", "locals [  ( local +  +  )  ]     =    Opcodes . FLOAT ;", "break ;", "case    ' J '     :", "locals [  ( local +  +  )  ]     =    Opcodes . LONG ;", "break ;", "case    ' D '     :", "locals [  ( local +  +  )  ]     =    Opcodes . DOUBLE ;", "break ;", "case    '  [  '     :", "while    (  ( desc . charAt ( i )  )     =  =     '  [  '  )     {", "+  + i ;", "}", "if    (  ( desc . charAt ( i )  )     =  =     ' L '  )     {", "+  + i ;", "while    (  ( desc . charAt ( i )  )     !  =     '  ;  '  )     {", "+  + i ;", "}", "}", "locals [  ( local +  +  )  ]     =    desc . substring ( j ,     (  +  + i )  )  ;", "break ;", "case    ' L '     :", "while    (  ( desc . charAt ( i )  )     !  =     '  ;  '  )     {", "+  + i ;", "}", "locals [  ( local +  +  )  ]     =    desc . substring (  ( j    +     1  )  ,     ( i +  +  )  )  ;", "break ;", "default    :", "break   loop ;", "}", "}", "frame . localCount    =    local ;", "}", "METHOD_END"], "methodName": ["getImplicitFrame"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   index    =     ( header )     +     6  ;", "int   n    =    readUnsignedShort ( index )  ;", "String [  ]    interfaces    =    new   String [ n ]  ;", "if    ( n    >     0  )     {", "char [  ]    buf    =    new   char [ maxStringLength ]  ;", "for    ( int   i    =     0  ;    i    <    n ;     +  + i )     {", "index    +  =     2  ;", "interfaces [ i ]     =    readClass ( index ,    buf )  ;", "}", "}", "return   interfaces ;", "}", "METHOD_END"], "methodName": ["getInterfaces"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   items [ item ]  ;", "}", "METHOD_END"], "methodName": ["getItem"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   items . length ;", "}", "METHOD_END"], "methodName": ["getItemCount"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   maxStringLength ;", "}", "METHOD_END"], "methodName": ["getMaxStringLength"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   readClass (  (  ( header )     +     4  )  ,    new   char [ maxStringLength ]  )  ;", "}", "METHOD_END"], "methodName": ["getSuperName"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   target    =    readInt ( u )  ;", "switch    ( target    >  >  >     2  4  )     {", "case    0     :", "case    1     :", "case    2  2     :", "target    &  =     -  6  5  5  3  6  ;", "u    +  =     2  ;", "break ;", "case    1  9     :", "case    2  0     :", "case    2  1     :", "target    &  =     -  1  6  7  7  7  2  1  6  ;", "u    +  =     1  ;", "break ;", "case    6  4     :", "case    6  5     :", "{", "target    &  =     -  1  6  7  7  7  2  1  6  ;", "int   n    =    readUnsignedShort (  ( u    +     1  )  )  ;", "context . start    =    new   Label [ n ]  ;", "context . end    =    new   Label [ n ]  ;", "context . index    =    new   int [ n ]  ;", "u    +  =     3  ;", "for    ( int   i    =     0  ;    i    <    n ;     +  + i )     {", "int   start    =    readUnsignedShort ( u )  ;", "int   length    =    readUnsignedShort (  ( u    +     2  )  )  ;", "context . start [ i ]     =    readLabel ( start ,    context . labels )  ;", "context . end [ i ]     =    readLabel (  ( start    +    length )  ,    context . labels )  ;", "context . index [ i ]     =    readUnsignedShort (  ( u    +     4  )  )  ;", "u    +  =     6  ;", "}", "break ;", "}", "case    7  1     :", "case    7  2     :", "case    7  3     :", "case    7  4     :", "case    7  5     :", "target    &  =     -  1  6  7  7  6  9  6  1  ;", "u    +  =     4  ;", "break ;", "default    :", "target    &  =     (  ( target    >  >  >     2  4  )     <     6  7  )     ?     -  2  5  6     :     -  1  6  7  7  7  2  1  6  ;", "u    +  =     3  ;", "break ;", "}", "int   pathLength    =    readByte ( u )  ;", "context . typeRef    =    target ;", "context . typePath    =     ( pathLength    =  =     0  )     ?    null    :    new   TypePath ( b ,    u )  ;", "return    ( u    +     1  )     +     (  2     *    pathLength )  ;", "}", "METHOD_END"], "methodName": ["readAnnotationTarget"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   i ;", "if    ( av    =  =    null )     {", "switch    (  ( b [ v ]  )     &     2  5  5  )     {", "case    ' e '     :", "return   v    +     5  ;", "case    '  @  '     :", "return   rAnnotationValues (  ( v    +     3  )  ,    buf ,    true ,    null )  ;", "case    '  [  '     :", "return   rAnnotationValues (  ( v    +     1  )  ,    buf ,    false ,    null )  ;", "default    :", "return   v    +     3  ;", "}", "}", "switch    (  ( b [  ( v +  +  )  ]  )     &     2  5  5  )     {", "case    ' I '     :", "case    ' J '     :", "case    ' F '     :", "case    ' D '     :", "av . visit ( name ,    rConst ( rUnsignedShort ( v )  ,    buf )  )  ;", "v    +  =     2  ;", "break ;", "case    ' B '     :", "av . visit ( name ,     (  ( byte )     ( rInt ( items [ rUnsignedShort ( v )  ]  )  )  )  )  ;", "v    +  =     2  ;", "break ;", "case    ' Z '     :", "av . visit ( name ,     (  ( rInt ( items [ rUnsignedShort ( v )  ]  )  )     =  =     0     ?    Boolean . FALSE    :    Boolean . TRUE )  )  ;", "v    +  =     2  ;", "break ;", "case    ' S '     :", "av . visit ( name ,     (  ( short )     ( rInt ( items [ rUnsignedShort ( v )  ]  )  )  )  )  ;", "v    +  =     2  ;", "break ;", "case    ' C '     :", "av . visit ( name ,     (  ( char )     ( rInt ( items [ rUnsignedShort ( v )  ]  )  )  )  )  ;", "v    +  =     2  ;", "break ;", "case    ' s '     :", "av . visit ( name ,    rUTF 8  ( v ,    buf )  )  ;", "v    +  =     2  ;", "break ;", "case    ' e '     :", "av . visitEnum ( name ,    rUTF 8  ( v ,    buf )  ,    rUTF 8  (  ( v    +     2  )  ,    buf )  )  ;", "v    +  =     4  ;", "break ;", "case    ' c '     :", "av . visit ( name ,    Type . getType ( rUTF 8  ( v ,    buf )  )  )  ;", "v    +  =     2  ;", "break ;", "case    '  @  '     :", "v    =    rAnnotationValues (  ( v    +     2  )  ,    buf ,    true ,    av . visitAnnotation ( name ,    rUTF 8  ( v ,    buf )  )  )  ;", "break ;", "case    '  [  '     :", "int   size    =    rUnsignedShort ( v )  ;", "v    +  =     2  ;", "if    ( size    =  =     0  )     {", "return   rAnnotationValues (  ( v    -     2  )  ,    buf ,    false ,    av . visitArray ( name )  )  ;", "}", "switch    (  ( this . b [  ( v +  +  )  ]  )     &     2  5  5  )     {", "case    ' B '     :", "byte [  ]    bv    =    new   byte [ size ]  ;", "for    ( i    =     0  ;    i    <    size ;    i +  +  )     {", "bv [ i ]     =     (  ( byte )     ( rInt ( items [ rUnsignedShort ( v )  ]  )  )  )  ;", "v    +  =     3  ;", "}", "av . visit ( name ,    bv )  ;", "-  - v ;", "break ;", "case    ' Z '     :", "boolean [  ]    zv    =    new   boolean [ size ]  ;", "for    ( i    =     0  ;    i    <    size ;    i +  +  )     {", "zv [ i ]     =     ( rInt ( items [ rUnsignedShort ( v )  ]  )  )     !  =     0  ;", "v    +  =     3  ;", "}", "av . visit ( name ,    zv )  ;", "-  - v ;", "break ;", "case    ' S '     :", "short [  ]    sv    =    new   short [ size ]  ;", "for    ( i    =     0  ;    i    <    size ;    i +  +  )     {", "sv [ i ]     =     (  ( short )     ( rInt ( items [ rUnsignedShort ( v )  ]  )  )  )  ;", "v    +  =     3  ;", "}", "av . visit ( name ,    sv )  ;", "-  - v ;", "break ;", "case    ' C '     :", "char [  ]    cv    =    new   char [ size ]  ;", "for    ( i    =     0  ;    i    <    size ;    i +  +  )     {", "cv [ i ]     =     (  ( char )     ( rInt ( items [ rUnsignedShort ( v )  ]  )  )  )  ;", "v    +  =     3  ;", "}", "av . visit ( name ,    cv )  ;", "-  - v ;", "break ;", "case    ' I '     :", "int [  ]    iv    =    new   int [ size ]  ;", "for    ( i    =     0  ;    i    <    size ;    i +  +  )     {", "iv [ i ]     =    rInt ( items [ rUnsignedShort ( v )  ]  )  ;", "v    +  =     3  ;", "}", "av . visit ( name ,    iv )  ;", "-  - v ;", "break ;", "case    ' J '     :", "long [  ]    lv    =    new   long [ size ]  ;", "for    ( i    =     0  ;    i    <    size ;    i +  +  )     {", "lv [ i ]     =    rLong ( items [ rUnsignedShort ( v )  ]  )  ;", "v    +  =     3  ;", "}", "av . visit ( name ,    lv )  ;", "-  - v ;", "break ;", "case    ' F '     :", "float [  ]    fv    =    new   float [ size ]  ;", "for    ( i    =     0  ;    i    <    size ;    i +  +  )     {", "fv [ i ]     =    Float . intBitsToFloat ( rInt ( items [ rUnsignedShort ( v )  ]  )  )  ;", "v    +  =     3  ;", "}", "av . visit ( name ,    fv )  ;", "-  - v ;", "break ;", "case    ' D '     :", "double [  ]    dv    =    new   double [ size ]  ;", "for    ( i    =     0  ;    i    <    size ;    i +  +  )     {", "dv [ i ]     =    Double . longBitsToDouble ( rLong ( items [ rUnsignedShort ( v )  ]  )  )  ;", "v    +  =     3  ;", "}", "av . visit ( name ,    dv )  ;", "-  - v ;", "break ;", "default    :", "v    =    rAnnotationValues (  ( v    -     3  )  ,    buf ,    false ,    av . visitArray ( name )  )  ;", "}", "}", "return   v ;", "}", "METHOD_END"], "methodName": ["readAnnotationValue"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   i    =    readUnsignedShort ( v )  ;", "v    +  =     2  ;", "if    ( named )     {", "for    (  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationValue (  ( v    +     2  )  ,    buf ,    readUTF 8  ( v ,    buf )  ,    av )  ;", "}", "} else    {", "for    (  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationValue ( v ,    buf ,    null ,    av )  ;", "}", "}", "if    ( av    !  =    null )     {", "av . visitEnd (  )  ;", "}", "return   v ;", "}", "METHOD_END"], "methodName": ["readAnnotationValues"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( attrs . length )  ;     +  + i )     {", "if    ( attrs [ i ]  . type . equals ( type )  )     {", "return   attrs [ i ]  . r ( this ,    off ,    len ,    buf ,    codeOff ,    labels )  ;", "}", "}", "return   new   Attribute ( type )  . r ( this ,    off ,    len ,    null ,     (  -  1  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["readAttribute"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return    ( b [ index ]  )     &     2  5  5  ;", "}", "METHOD_END"], "methodName": ["readByte"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   readStringish ( index ,    buf )  ;", "}", "METHOD_END"], "methodName": ["readClass"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "if    ( is    =  =    null )     {", "throw   new   IOException (  \"    not   found \"  )  ;", "}", "try    {", "byte [  ]    b    =    new   byte [ is . available (  )  ]  ;", "int   len    =     0  ;", "while    ( true )     {", "int   n    =    is . read ( b ,    len ,     (  ( b . length )     -    len )  )  ;", "if    ( n    =  =     (  -  1  )  )     {", "if    ( len    <     ( b . length )  )     {", "byte [  ]    c    =    new   byte [ len ]  ;", "System . arraycopy ( b ,     0  ,    c ,     0  ,    len )  ;", "b    =    c ;", "}", "return   b ;", "}", "len    +  =    n ;", "if    ( len    =  =     ( b . length )  )     {", "int   last    =    is . read (  )  ;", "if    ( last    <     0  )     {", "return   b ;", "}", "byte [  ]    c    =    new   byte [  ( b . length )     +     1  0  0  0  ]  ;", "System . arraycopy ( b ,     0  ,    c ,     0  ,    len )  ;", "c [  ( len +  +  )  ]     =     (  ( byte )     ( last )  )  ;", "b    =    c ;", "}", "}", "}    finally    {", "if    ( close )     {", "is . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readClass"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    b    =    this . b ;", "char [  ]    c    =    context . buffer ;", "int   maxStack    =    readUnsignedShort ( u )  ;", "int   maxLocals    =    readUnsignedShort (  ( u    +     2  )  )  ;", "int   codeLength    =    readInt (  ( u    +     4  )  )  ;", "u    +  =     8  ;", "int   codeStart    =    u ;", "int   codeEnd    =    u    +    codeLength ;", "Label [  ]    labels    =    context . labels    =    new   Label [ codeLength    +     2  ]  ;", "readLabel (  ( codeLength    +     1  )  ,    labels )  ;", "while    ( u    <    codeEnd )     {", "int   offset    =    u    -    codeStart ;", "int   opcode    =     ( b [ u ]  )     &     2  5  5  ;", "switch    ( ClassWriter . TYPE [ opcode ]  )     {", "case   ClassWriter . NOARG _ INSN    :", "case   ClassWriter . IMPLVAR _ INSN    :", "u    +  =     1  ;", "break ;", "case   ClassWriter . LABEL _ INSN    :", "readLabel (  ( offset    +     ( readShort (  ( u    +     1  )  )  )  )  ,    labels )  ;", "u    +  =     3  ;", "break ;", "case   ClassWriter . ASM _ LABEL _ INSN    :", "readLabel (  ( offset    +     ( readUnsignedShort (  ( u    +     1  )  )  )  )  ,    labels )  ;", "u    +  =     3  ;", "break ;", "case   ClassWriter . LABELW _ INSN    :", "case   ClassWriter . ASM _ LABELW _ INSN    :", "readLabel (  ( offset    +     ( readInt (  ( u    +     1  )  )  )  )  ,    labels )  ;", "u    +  =     5  ;", "break ;", "case   ClassWriter . WIDE _ INSN    :", "opcode    =     ( b [  ( u    +     1  )  ]  )     &     2  5  5  ;", "if    ( opcode    =  =     ( Opcodes . IINC )  )     {", "u    +  =     6  ;", "} else    {", "u    +  =     4  ;", "}", "break ;", "case   ClassWriter . TABL _ INSN    :", "u    =     ( u    +     4  )     -     ( offset    &     3  )  ;", "readLabel (  ( offset    +     ( readInt ( u )  )  )  ,    labels )  ;", "for    ( int   i    =     (  ( readInt (  ( u    +     8  )  )  )     -     ( readInt (  ( u    +     4  )  )  )  )     +     1  ;    i    >     0  ;     -  - i )     {", "readLabel (  ( offset    +     ( readInt (  ( u    +     1  2  )  )  )  )  ,    labels )  ;", "u    +  =     4  ;", "}", "u    +  =     1  2  ;", "break ;", "case   ClassWriter . LOOK _ INSN    :", "u    =     ( u    +     4  )     -     ( offset    &     3  )  ;", "readLabel (  ( offset    +     ( readInt ( u )  )  )  ,    labels )  ;", "for    ( int   i    =    readInt (  ( u    +     4  )  )  ;    i    >     0  ;     -  - i )     {", "readLabel (  ( offset    +     ( readInt (  ( u    +     1  2  )  )  )  )  ,    labels )  ;", "u    +  =     8  ;", "}", "u    +  =     8  ;", "break ;", "case   ClassWriter . VAR _ INSN    :", "case   ClassWriter . SBYTE _ INSN    :", "case   ClassWriter . LDC _ INSN    :", "u    +  =     2  ;", "break ;", "case   ClassWriter . SHORT _ INSN    :", "case   ClassWriter . LDCW _ INSN    :", "case   ClassWriter . FIELDORMETH _ INSN    :", "case   ClassWriter . TYPE _ INSN    :", "case   ClassWriter . IINC _ INSN    :", "u    +  =     3  ;", "break ;", "case   ClassWriter . ITFMETH _ INSN    :", "case   ClassWriter . INDYMETH _ INSN    :", "u    +  =     5  ;", "break ;", "default    :", "u    +  =     4  ;", "break ;", "}", "}", "for    ( int   i    =    readUnsignedShort ( u )  ;    i    >     0  ;     -  - i )     {", "Label   start    =    readLabel ( readUnsignedShort (  ( u    +     2  )  )  ,    labels )  ;", "Label   end    =    readLabel ( readUnsignedShort (  ( u    +     4  )  )  ,    labels )  ;", "Label   handler    =    readLabel ( readUnsignedShort (  ( u    +     6  )  )  ,    labels )  ;", "String   type    =    readUTF 8  ( items [ readUnsignedShort (  ( u    +     8  )  )  ]  ,    c )  ;", "mv . visitTryCatchBlock ( start ,    end ,    handler ,    type )  ;", "u    +  =     8  ;", "}", "u    +  =     2  ;", "int [  ]    tanns    =    null ;", "int [  ]    itanns    =    null ;", "int   tann    =     0  ;", "int   itann    =     0  ;", "int   ntoff    =     -  1  ;", "int   nitoff    =     -  1  ;", "int   varTable    =     0  ;", "int   varTypeTable    =     0  ;", "boolean   zip    =    true ;", "boolean   unzip    =     (  ( context . flags )     &     (  . EXPAND _ FRAMES )  )     !  =     0  ;", "int   stackMap    =     0  ;", "int   stackMapSize    =     0  ;", "int   frameCount    =     0  ;", "Context   frame    =    null ;", "Attribute   attributes    =    null ;", "for    ( int   i    =    readUnsignedShort ( u )  ;    i    >     0  ;     -  - i )     {", "String   attrName    =    readUTF 8  (  ( u    +     2  )  ,    c )  ;", "if    (  \" LocalVariableTable \"  . equals ( attrName )  )     {", "if    (  (  ( context . flags )     &     (  . SKIP _ DEBUG )  )     =  =     0  )     {", "varTable    =    u    +     8  ;", "for    ( int   j    =    readUnsignedShort (  ( u    +     8  )  )  ,    v    =    u ;    j    >     0  ;     -  - j )     {", "int   label    =    readUnsignedShort (  ( v    +     1  0  )  )  ;", "if    (  ( labels [ label ]  )     =  =    null )     {", "readLabel ( label ,    labels )  . status    |  =    Label . DEBUG ;", "}", "label    +  =    readUnsignedShort (  ( v    +     1  2  )  )  ;", "if    (  ( labels [ label ]  )     =  =    null )     {", "readLabel ( label ,    labels )  . status    |  =    Label . DEBUG ;", "}", "v    +  =     1  0  ;", "}", "}", "} else", "if    (  \" LocalVariableTypeTable \"  . equals ( attrName )  )     {", "varTypeTable    =    u    +     8  ;", "} else", "if    (  \" LineNumberTable \"  . equals ( attrName )  )     {", "if    (  (  ( context . flags )     &     (  . SKIP _ DEBUG )  )     =  =     0  )     {", "for    ( int   j    =    readUnsignedShort (  ( u    +     8  )  )  ,    v    =    u ;    j    >     0  ;     -  - j )     {", "int   label    =    readUnsignedShort (  ( v    +     1  0  )  )  ;", "if    (  ( labels [ label ]  )     =  =    null )     {", "readLabel ( label ,    labels )  . status    |  =    Label . DEBUG ;", "}", "Label   l    =    labels [ label ]  ;", "while    (  ( l . line )     >     0  )     {", "if    (  ( l . next )     =  =    null )     {", "l . next    =    new   Label (  )  ;", "}", "l    =    l . next ;", "}", "l . line    =    readUnsignedShort (  ( v    +     1  2  )  )  ;", "v    +  =     4  ;", "}", "}", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeVisibleTypeAnnotations \"  . equals ( attrName )  )  )     {", "tanns    =    readTypeAnnotations ( mv ,    context ,     ( u    +     8  )  ,    true )  ;", "ntoff    =     (  (  ( tanns . length )     =  =     0  )     |  |     (  ( readByte ( tanns [  0  ]  )  )     <     6  7  )  )     ?     -  1     :    readUnsignedShort (  (  ( tanns [  0  ]  )     +     1  )  )  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeInvisibleTypeAnnotations \"  . equals ( attrName )  )  )     {", "itanns    =    readTypeAnnotations ( mv ,    context ,     ( u    +     8  )  ,    false )  ;", "nitoff    =     (  (  ( itanns . length )     =  =     0  )     |  |     (  ( readByte ( itanns [  0  ]  )  )     <     6  7  )  )     ?     -  1     :    readUnsignedShort (  (  ( itanns [  0  ]  )     +     1  )  )  ;", "} else", "if    (  (  . FRAMES )     &  &     (  \" StackMapTable \"  . equals ( attrName )  )  )     {", "if    (  (  ( context . flags )     &     (  . SKIP _ FRAMES )  )     =  =     0  )     {", "stackMap    =    u    +     1  0  ;", "stackMapSize    =    readInt (  ( u    +     4  )  )  ;", "frameCount    =    readUnsignedShort (  ( u    +     8  )  )  ;", "}", "} else", "if    (  (  . FRAMES )     &  &     (  \" StackMap \"  . equals ( attrName )  )  )     {", "if    (  (  ( context . flags )     &     (  . SKIP _ FRAMES )  )     =  =     0  )     {", "zip    =    false ;", "stackMap    =    u    +     1  0  ;", "stackMapSize    =    readInt (  ( u    +     4  )  )  ;", "frameCount    =    readUnsignedShort (  ( u    +     8  )  )  ;", "}", "} else    {", "for    ( int   j    =     0  ;    j    <     ( context . attrs . length )  ;     +  + j )     {", "if    ( context . attrs [ j ]  . type . equals ( attrName )  )     {", "Attribute   attr    =    context . attrs [ j ]  . read ( this ,     ( u    +     8  )  ,    readInt (  ( u    +     4  )  )  ,    c ,     ( codeStart    -     8  )  ,    labels )  ;", "if    ( attr    !  =    null )     {", "attr . next    =    attributes ;", "attributes    =    attr ;", "}", "}", "}", "}", "u    +  =     6     +     ( readInt (  ( u    +     4  )  )  )  ;", "}", "u    +  =     2  ;", "if    (  (  . FRAMES )     &  &     ( stackMap    !  =     0  )  )     {", "frame    =    context ;", "frame . offset    =     -  1  ;", "frame . mode    =     0  ;", "frame . localCount    =     0  ;", "frame . localDiff    =     0  ;", "frame . stackCount    =     0  ;", "frame . local    =    new   Object [ maxLocals ]  ;", "frame . stack    =    new   Object [ maxStack ]  ;", "if    ( unzip )     {", "getImplicitFrame ( context )  ;", "}", "for    ( int   i    =    stackMap ;    i    <     (  ( stackMap    +    stackMapSize )     -     2  )  ;     +  + i )     {", "if    (  ( b [ i ]  )     =  =     8  )     {", "int   v    =    readUnsignedShort (  ( i    +     1  )  )  ;", "if    (  ( v    >  =     0  )     &  &     ( v    <    codeLength )  )     {", "if    (  (  ( b [  ( codeStart    +    v )  ]  )     &     2  5  5  )     =  =     ( Opcodes . NEW )  )     {", "readLabel ( v ,    labels )  ;", "}", "}", "}", "}", "}", "if    (  (  (  ( context . flags )     &     (  . EXPAND _ ASM _ INSNS )  )     !  =     0  )     &  &     (  (  ( context . flags )     &     (  . EXPAND _ FRAMES )  )     !  =     0  )  )     {", "mv . visitFrame ( Opcodes . F _ NEW ,    maxLocals ,    null ,     0  ,    null )  ;", "}", "int   opcodeDelta    =     (  (  ( context . flags )     &     (  . EXPAND _ ASM _ INSNS )  )     =  =     0  )     ?     -  3  3     :     0  ;", "boolean   insertFrame    =    false ;", "u    =    codeStart ;", "while    ( u    <    codeEnd )     {", "int   offset    =    u    -    codeStart ;", "Label   l    =    labels [ offset ]  ;", "if    ( l    !  =    null )     {", "Label   next    =    l . next ;", "l . next    =    null ;", "mv . visitLabel ( l )  ;", "if    (  (  (  ( context . flags )     &     (  . SKIP _ DEBUG )  )     =  =     0  )     &  &     (  ( l . line )     >     0  )  )     {", "mv . visitLineNumber ( l . line ,    l )  ;", "while    ( next    !  =    null )     {", "mv . visitLineNumber ( next . line ,    l )  ;", "next    =    next . next ;", "}", "}", "}", "while    (  (  (  . FRAMES )     &  &     ( frame    !  =    null )  )     &  &     (  (  ( frame . offset )     =  =    offset )     |  |     (  ( frame . offset )     =  =     (  -  1  )  )  )  )     {", "if    (  ( frame . offset )     !  =     (  -  1  )  )     {", "if    (  (  ! zip )     |  |    unzip )     {", "mv . visitFrame ( Opcodes . F _ NEW ,    frame . localCount ,    frame . local ,    frame . stackCount ,    frame . stack )  ;", "} else    {", "mv . visitFrame ( frame . mode ,    frame . localDiff ,    frame . local ,    frame . stackCount ,    frame . stack )  ;", "}", "insertFrame    =    false ;", "}", "if    ( frameCount    >     0  )     {", "stackMap    =    readFrame ( stackMap ,    zip ,    unzip ,    frame )  ;", "-  - frameCount ;", "} else    {", "frame    =    null ;", "}", "}", "if    (  (  . FRAMES )     &  &    insertFrame )     {", "mv . visitFrame ( ClassWriter . F _ INSERT ,     0  ,    null ,     0  ,    null )  ;", "insertFrame    =    false ;", "}", "int   opcode    =     ( b [ u ]  )     &     2  5  5  ;", "switch    ( ClassWriter . TYPE [ opcode ]  )     {", "case   ClassWriter . NOARG _ INSN    :", "mv . visitInsn ( opcode )  ;", "u    +  =     1  ;", "break ;", "case   ClassWriter . IMPLVAR _ INSN    :", "if    ( opcode    >     ( Opcodes . ISTORE )  )     {", "opcode    -  =     5  9  ;", "mv . visitVarInsn (  (  ( Opcodes . ISTORE )     +     ( opcode    >  >     2  )  )  ,     ( opcode    &     3  )  )  ;", "} else    {", "opcode    -  =     2  6  ;", "mv . visitVarInsn (  (  ( Opcodes . ILOAD )     +     ( opcode    >  >     2  )  )  ,     ( opcode    &     3  )  )  ;", "}", "u    +  =     1  ;", "break ;", "case   ClassWriter . LABEL _ INSN    :", "mv . visitJumpInsn ( opcode ,    labels [  ( offset    +     ( readShort (  ( u    +     1  )  )  )  )  ]  )  ;", "u    +  =     3  ;", "break ;", "case   ClassWriter . LABELW _ INSN    :", "mv . visitJumpInsn (  ( opcode    +    opcodeDelta )  ,    labels [  ( offset    +     ( readInt (  ( u    +     1  )  )  )  )  ]  )  ;", "u    +  =     5  ;", "break ;", "case   ClassWriter . ASM _ LABEL _ INSN    :", "{", "opcode    =     ( opcode    <     2  1  8  )     ?    opcode    -     4  9     :    opcode    -     2  0  ;", "Label   target    =    labels [  ( offset    +     ( readUnsignedShort (  ( u    +     1  )  )  )  )  ]  ;", "if    (  ( opcode    =  =     ( Opcodes . GOTO )  )     |  |     ( opcode    =  =     ( Opcodes . JSR )  )  )     {", "mv . visitJumpInsn (  ( opcode    +     3  3  )  ,    target )  ;", "} else    {", "opcode    =     ( opcode    <  =     1  6  6  )     ?     (  ( opcode    +     1  )     ^     1  )     -     1     :    opcode    ^     1  ;", "Label   endif    =    readLabel (  ( offset    +     3  )  ,    labels )  ;", "mv . visitJumpInsn ( opcode ,    endif )  ;", "mv . visitJumpInsn (  2  0  0  ,    target )  ;", "insertFrame    =    true ;", "}", "u    +  =     3  ;", "break ;", "}", "case   ClassWriter . ASM _ LABELW _ INSN    :", "{", "mv . visitJumpInsn (  2  0  0  ,    labels [  ( offset    +     ( readInt (  ( u    +     1  )  )  )  )  ]  )  ;", "insertFrame    =    true ;", "u    +  =     5  ;", "break ;", "}", "case   ClassWriter . WIDE _ INSN    :", "opcode    =     ( b [  ( u    +     1  )  ]  )     &     2  5  5  ;", "if    ( opcode    =  =     ( Opcodes . IINC )  )     {", "mv . visitIincInsn ( readUnsignedShort (  ( u    +     2  )  )  ,    readShort (  ( u    +     4  )  )  )  ;", "u    +  =     6  ;", "} else    {", "mv . visitVarInsn ( opcode ,    readUnsignedShort (  ( u    +     2  )  )  )  ;", "u    +  =     4  ;", "}", "break ;", "case   ClassWriter . TABL _ INSN    :", "{", "u    =     ( u    +     4  )     -     ( offset    &     3  )  ;", "int   label    =    offset    +     ( readInt ( u )  )  ;", "int   min    =    readInt (  ( u    +     4  )  )  ;", "int   max    =    readInt (  ( u    +     8  )  )  ;", "Label [  ]    table    =    new   Label [  ( max    -    min )     +     1  ]  ;", "u    +  =     1  2  ;", "for    ( int   i    =     0  ;    i    <     ( table . length )  ;     +  + i )     {", "table [ i ]     =    labels [  ( offset    +     ( readInt ( u )  )  )  ]  ;", "u    +  =     4  ;", "}", "mv . visitTableSwitchInsn ( min ,    max ,    labels [ label ]  ,    table )  ;", "break ;", "}", "case   ClassWriter . LOOK _ INSN    :", "{", "u    =     ( u    +     4  )     -     ( offset    &     3  )  ;", "int   label    =    offset    +     ( readInt ( u )  )  ;", "int   len    =    readInt (  ( u    +     4  )  )  ;", "int [  ]    keys    =    new   int [ len ]  ;", "Label [  ]    values    =    new   Label [ len ]  ;", "u    +  =     8  ;", "for    ( int   i    =     0  ;    i    <    len ;     +  + i )     {", "keys [ i ]     =    readInt ( u )  ;", "values [ i ]     =    labels [  ( offset    +     ( readInt (  ( u    +     4  )  )  )  )  ]  ;", "u    +  =     8  ;", "}", "mv . visitLookupSwitchInsn ( labels [ label ]  ,    keys ,    values )  ;", "break ;", "}", "case   ClassWriter . VAR _ INSN    :", "mv . visitVarInsn ( opcode ,     (  ( b [  ( u    +     1  )  ]  )     &     2  5  5  )  )  ;", "u    +  =     2  ;", "break ;", "case   ClassWriter . SBYTE _ INSN    :", "mv . visitIntInsn ( opcode ,    b [  ( u    +     1  )  ]  )  ;", "u    +  =     2  ;", "break ;", "case   ClassWriter . SHORT _ INSN    :", "mv . visitIntInsn ( opcode ,    readShort (  ( u    +     1  )  )  )  ;", "u    +  =     3  ;", "break ;", "case   ClassWriter . LDC _ INSN    :", "mv . visitLdcInsn ( readConst (  (  ( b [  ( u    +     1  )  ]  )     &     2  5  5  )  ,    c )  )  ;", "u    +  =     2  ;", "break ;", "case   ClassWriter . LDCW _ INSN    :", "mv . visitLdcInsn ( readConst ( readUnsignedShort (  ( u    +     1  )  )  ,    c )  )  ;", "u    +  =     3  ;", "break ;", "case   ClassWriter . FIELDORMETH _ INSN    :", "case   ClassWriter . ITFMETH _ INSN    :", "{", "int   cpIndex    =    items [ readUnsignedShort (  ( u    +     1  )  )  ]  ;", "boolean   itf    =     ( b [  ( cpIndex    -     1  )  ]  )     =  =     ( ClassWriter . IMETH )  ;", "String   iowner    =    readClass ( cpIndex ,    c )  ;", "cpIndex    =    items [ readUnsignedShort (  ( cpIndex    +     2  )  )  ]  ;", "String   iname    =    readUTF 8  ( cpIndex ,    c )  ;", "String   idesc    =    readUTF 8  (  ( cpIndex    +     2  )  ,    c )  ;", "if    ( opcode    <     ( Opcodes . INVOKEVIRTUAL )  )     {", "mv . visitFieldInsn ( opcode ,    iowner ,    iname ,    idesc )  ;", "} else    {", "mv . visitMethodInsn ( opcode ,    iowner ,    iname ,    idesc ,    itf )  ;", "}", "if    ( opcode    =  =     ( Opcodes . INVOKEINTERFACE )  )     {", "u    +  =     5  ;", "} else    {", "u    +  =     3  ;", "}", "break ;", "}", "case   ClassWriter . INDYMETH _ INSN    :", "{", "int   cpIndex    =    items [ readUnsignedShort (  ( u    +     1  )  )  ]  ;", "int   bsmIndex    =    context . bootstrapMethods [ readUnsignedShort ( cpIndex )  ]  ;", "Handle   bsm    =     (  ( Handle )     ( readConst ( readUnsignedShort ( bsmIndex )  ,    c )  )  )  ;", "int   bsmArgCount    =    readUnsignedShort (  ( bsmIndex    +     2  )  )  ;", "Object [  ]    bsmArgs    =    new   Object [ bsmArgCount ]  ;", "bsmIndex    +  =     4  ;", "for    ( int   i    =     0  ;    i    <    bsmArgCount ;    i +  +  )     {", "bsmArgs [ i ]     =    readConst ( readUnsignedShort ( bsmIndex )  ,    c )  ;", "bsmIndex    +  =     2  ;", "}", "cpIndex    =    items [ readUnsignedShort (  ( cpIndex    +     2  )  )  ]  ;", "String   iname    =    readUTF 8  ( cpIndex ,    c )  ;", "String   idesc    =    readUTF 8  (  ( cpIndex    +     2  )  ,    c )  ;", "mv . visitInvokeDynamicInsn ( iname ,    idesc ,    bsm ,    bsmArgs )  ;", "u    +  =     5  ;", "break ;", "}", "case   ClassWriter . TYPE _ INSN    :", "mv . visitTypeInsn ( opcode ,    readClass (  ( u    +     1  )  ,    c )  )  ;", "u    +  =     3  ;", "break ;", "case   ClassWriter . IINC _ INSN    :", "mv . visitIincInsn (  (  ( b [  ( u    +     1  )  ]  )     &     2  5  5  )  ,    b [  ( u    +     2  )  ]  )  ;", "u    +  =     3  ;", "break ;", "default    :", "mv . visitMultiANewArrayInsn ( readClass (  ( u    +     1  )  ,    c )  ,     (  ( b [  ( u    +     3  )  ]  )     &     2  5  5  )  )  ;", "u    +  =     4  ;", "break ;", "}", "while    (  (  ( tanns    !  =    null )     &  &     ( tann    <     ( tanns . length )  )  )     &  &     ( ntoff    <  =    offset )  )     {", "if    ( ntoff    =  =    offset )     {", "int   v    =    readAnnotationTarget ( context ,    tanns [ tann ]  )  ;", "readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    mv . visitInsnAnnotation ( context . typeRef ,    context . typePath ,    readUTF 8  ( v ,    c )  ,    true )  )  ;", "}", "ntoff    =     (  (  (  +  + tann )     >  =     ( tanns . length )  )     |  |     (  ( readByte ( tanns [ tann ]  )  )     <     6  7  )  )     ?     -  1     :    readUnsignedShort (  (  ( tanns [ tann ]  )     +     1  )  )  ;", "}", "while    (  (  ( itanns    !  =    null )     &  &     ( itann    <     ( itanns . length )  )  )     &  &     ( nitoff    <  =    offset )  )     {", "if    ( nitoff    =  =    offset )     {", "int   v    =    readAnnotationTarget ( context ,    itanns [ itann ]  )  ;", "readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    mv . visitInsnAnnotation ( context . typeRef ,    context . typePath ,    readUTF 8  ( v ,    c )  ,    false )  )  ;", "}", "nitoff    =     (  (  (  +  + itann )     >  =     ( itanns . length )  )     |  |     (  ( readByte ( itanns [ itann ]  )  )     <     6  7  )  )     ?     -  1     :    readUnsignedShort (  (  ( itanns [ itann ]  )     +     1  )  )  ;", "}", "}", "if    (  ( labels [ codeLength ]  )     !  =    null )     {", "mv . visitLabel ( labels [ codeLength ]  )  ;", "}", "if    (  (  (  ( context . flags )     &     (  . SKIP _ DEBUG )  )     =  =     0  )     &  &     ( varTable    !  =     0  )  )     {", "int [  ]    typeTable    =    null ;", "if    ( varTypeTable    !  =     0  )     {", "u    =    varTypeTable    +     2  ;", "typeTable    =    new   int [  ( readUnsignedShort ( varTypeTable )  )     *     3  ]  ;", "for    ( int   i    =    typeTable . length ;    i    >     0  ;  )     {", "typeTable [  (  -  - i )  ]     =    u    +     6  ;", "typeTable [  (  -  - i )  ]     =    readUnsignedShort (  ( u    +     8  )  )  ;", "typeTable [  (  -  - i )  ]     =    readUnsignedShort ( u )  ;", "u    +  =     1  0  ;", "}", "}", "u    =    varTable    +     2  ;", "for    ( int   i    =    readUnsignedShort ( varTable )  ;    i    >     0  ;     -  - i )     {", "int   start    =    readUnsignedShort ( u )  ;", "int   length    =    readUnsignedShort (  ( u    +     2  )  )  ;", "int   index    =    readUnsignedShort (  ( u    +     8  )  )  ;", "String   vsignature    =    null ;", "if    ( typeTable    !  =    null )     {", "for    ( int   j    =     0  ;    j    <     ( typeTable . length )  ;    j    +  =     3  )     {", "if    (  (  ( typeTable [ j ]  )     =  =    start )     &  &     (  ( typeTable [  ( j    +     1  )  ]  )     =  =    index )  )     {", "vsignature    =    readUTF 8  ( typeTable [  ( j    +     2  )  ]  ,    c )  ;", "break ;", "}", "}", "}", "mv . visitLocalVariable ( readUTF 8  (  ( u    +     4  )  ,    c )  ,    readUTF 8  (  ( u    +     6  )  ,    c )  ,    vsignature ,    labels [ start ]  ,    labels [  ( start    +    length )  ]  ,    index )  ;", "u    +  =     1  0  ;", "}", "}", "if    ( tanns    !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( tanns . length )  ;     +  + i )     {", "if    (  (  ( readByte ( tanns [ i ]  )  )     >  >     1  )     =  =     (  6  4     >  >     1  )  )     {", "int   v    =    readAnnotationTarget ( context ,    tanns [ i ]  )  ;", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    mv . visitLocalVariableAnnotation ( context . typeRef ,    context . typePath ,    context . start ,    context . end ,    context . index ,    readUTF 8  ( v ,    c )  ,    true )  )  ;", "}", "}", "}", "if    ( itanns    !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( itanns . length )  ;     +  + i )     {", "if    (  (  ( readByte ( itanns [ i ]  )  )     >  >     1  )     =  =     (  6  4     >  >     1  )  )     {", "int   v    =    readAnnotationTarget ( context ,    itanns [ i ]  )  ;", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    mv . visitLocalVariableAnnotation ( context . typeRef ,    context . typePath ,    context . start ,    context . end ,    context . index ,    readUTF 8  ( v ,    c )  ,    false )  )  ;", "}", "}", "}", "while    ( attributes    !  =    null )     {", "Attribute   attr    =    attributes . next ;", "attributes . next    =    null ;", "mv . visitAttribute ( attributes )  ;", "attributes    =    attr ;", "}", "mv . visitMaxs ( maxStack ,    maxLocals )  ;", "}", "METHOD_END"], "methodName": ["readCode"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   index    =    items [ item ]  ;", "switch    ( b [  ( index    -     1  )  ]  )     {", "case   Writer . INT    :", "return   readInt ( index )  ;", "case   Writer . FLOAT    :", "return   Float . intBitsToFloat ( readInt ( index )  )  ;", "case   Writer . LONG    :", "return   readLong ( index )  ;", "case   Writer . DOUBLE    :", "return   Double . longBitsToDouble ( readLong ( index )  )  ;", "case   Writer . CLASS    :", "return   Type . getObjectType ( readUTF 8  ( index ,    buf )  )  ;", "case   Writer . STR    :", "return   readUTF 8  ( index ,    buf )  ;", "case   Writer . MTYPE    :", "return   Type . getMethodType ( readUTF 8  ( index ,    buf )  )  ;", "default    :", "int   tag    =    readByte ( index )  ;", "int [  ]    items    =    this . items ;", "int   cpIndex    =    items [ readUnsignedShort (  ( index    +     1  )  )  ]  ;", "boolean   itf    =     ( b [  ( cpIndex    -     1  )  ]  )     =  =     ( Writer . IMETH )  ;", "String   owner    =    read ( cpIndex ,    buf )  ;", "cpIndex    =    items [ readUnsignedShort (  ( cpIndex    +     2  )  )  ]  ;", "String   name    =    readUTF 8  ( cpIndex ,    buf )  ;", "String   desc    =    readUTF 8  (  ( cpIndex    +     2  )  ,    buf )  ;", "return   new   Handle ( tag ,    owner ,    name ,    desc ,    itf )  ;", "}", "}", "METHOD_END"], "methodName": ["readConst"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    c    =    context . buffer ;", "int   access    =    readUnsignedShort ( u )  ;", "String   name    =    readUTF 8  (  ( u    +     2  )  ,    c )  ;", "String   desc    =    readUTF 8  (  ( u    +     4  )  ,    c )  ;", "u    +  =     6  ;", "String   signature    =    null ;", "int   anns    =     0  ;", "int   ianns    =     0  ;", "int   tanns    =     0  ;", "int   itanns    =     0  ;", "Object   value    =    null ;", "Attribute   attributes    =    null ;", "for    ( int   i    =    readUnsignedShort ( u )  ;    i    >     0  ;     -  - i )     {", "String   attrName    =    readUTF 8  (  ( u    +     2  )  ,    c )  ;", "if    (  \" ConstantValue \"  . equals ( attrName )  )     {", "int   item    =    readUnsignedShort (  ( u    +     8  )  )  ;", "value    =     ( item    =  =     0  )     ?    null    :    readConst ( item ,    c )  ;", "} else", "if    (  (  . SIGNATURES )     &  &     (  \" Signature \"  . equals ( attrName )  )  )     {", "signature    =    readUTF 8  (  ( u    +     8  )  ,    c )  ;", "} else", "if    (  \" Deprecated \"  . equals ( attrName )  )     {", "access    |  =    Opcodes . ACC _ DEPRECATED ;", "} else", "if    (  \" Synthetic \"  . equals ( attrName )  )     {", "access    |  =     ( Opcodes . ACC _ SYNTHETIC )     |     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeVisibleAnnotations \"  . equals ( attrName )  )  )     {", "anns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeVisibleTypeAnnotations \"  . equals ( attrName )  )  )     {", "tanns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeInvisibleAnnotations \"  . equals ( attrName )  )  )     {", "ianns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeInvisibleTypeAnnotations \"  . equals ( attrName )  )  )     {", "itanns    =    u    +     8  ;", "} else    {", "Attribute   attr    =    readAttribute ( context . attrs ,    attrName ,     ( u    +     8  )  ,    readInt (  ( u    +     4  )  )  ,    c ,     (  -  1  )  ,    null )  ;", "if    ( attr    !  =    null )     {", "attr . next    =    attributes ;", "attributes    =    attr ;", "}", "}", "u    +  =     6     +     ( readInt (  ( u    +     4  )  )  )  ;", "}", "u    +  =     2  ;", "FieldVisitor   fv    =    classVisitor . visitField ( access ,    name ,    desc ,    signature ,    value )  ;", "if    ( fv    =  =    null )     {", "return   u ;", "}", "if    (  (  . ANNOTATIONS )     &  &     ( anns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( anns )  ,    v    =    anns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    fv . visitAnnotation ( readUTF 8  ( v ,    c )  ,    true )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( ianns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( ianns )  ,    v    =    ianns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    fv . visitAnnotation ( readUTF 8  ( v ,    c )  ,    false )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( tanns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( tanns )  ,    v    =    tanns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationTarget ( context ,    v )  ;", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    fv . visitTypeAnnotation ( context . typeRef ,    context . typePath ,    readUTF 8  ( v ,    c )  ,    true )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( itanns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( itanns )  ,    v    =    itanns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationTarget ( context ,    v )  ;", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    fv . visitTypeAnnotation ( context . typeRef ,    context . typePath ,    readUTF 8  ( v ,    c )  ,    false )  )  ;", "}", "}", "while    ( attributes    !  =    null )     {", "Attribute   attr    =    attributes . next ;", "attributes . next    =    null ;", "fv . visitAttribute ( attributes )  ;", "attributes    =    attr ;", "}", "fv . visitEnd (  )  ;", "return   u ;", "}", "METHOD_END"], "methodName": ["readField"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    c    =    frame . buffer ;", "Label [  ]    labels    =    frame . labels ;", "int   tag ;", "int   delta ;", "if    ( zip )     {", "tag    =     ( b [  ( stackMap +  +  )  ]  )     &     2  5  5  ;", "} else    {", "tag    =    MethodWriter . FULL _ FRAME ;", "frame . offset    =     -  1  ;", "}", "frame . localDiff    =     0  ;", "if    ( tag    <     ( MethodWriter . SAME _ LOCALS _  1  _ STACK _ ITEM _ FRAME )  )     {", "delta    =    tag ;", "frame . mode    =    Opcodes . F _ SAME ;", "frame . stackCount    =     0  ;", "} else", "if    ( tag    <     ( MethodWriter . RESERVED )  )     {", "delta    =    tag    -     ( MethodWriter . SAME _ LOCALS _  1  _ STACK _ ITEM _ FRAME )  ;", "stackMap    =    readFrameType ( frame . stack ,     0  ,    stackMap ,    c ,    labels )  ;", "frame . mode    =    Opcodes . F _ SAME 1  ;", "frame . stackCount    =     1  ;", "} else    {", "delta    =    readUnsignedShort ( stackMap )  ;", "stackMap    +  =     2  ;", "if    ( tag    =  =     ( MethodWriter . SAME _ LOCALS _  1  _ STACK _ ITEM _ FRAME _ EXTENDED )  )     {", "stackMap    =    readFrameType ( frame . stack ,     0  ,    stackMap ,    c ,    labels )  ;", "frame . mode    =    Opcodes . F _ SAME 1  ;", "frame . stackCount    =     1  ;", "} else", "if    (  ( tag    >  =     ( MethodWriter . CHOP _ FRAME )  )     &  &     ( tag    <     ( MethodWriter . SAME _ FRAME _ EXTENDED )  )  )     {", "frame . mode    =    Opcodes . F _ CHOP ;", "frame . localDiff    =     ( MethodWriter . SAME _ FRAME _ EXTENDED )     -    tag ;", "frame . localCount    -  =    frame . localDiff ;", "frame . stackCount    =     0  ;", "} else", "if    ( tag    =  =     ( MethodWriter . SAME _ FRAME _ EXTENDED )  )     {", "frame . mode    =    Opcodes . F _ SAME ;", "frame . stackCount    =     0  ;", "} else", "if    ( tag    <     ( MethodWriter . FULL _ FRAME )  )     {", "int   local    =     ( unzip )     ?    frame . localCount    :     0  ;", "for    ( int   i    =    tag    -     ( MethodWriter . SAME _ FRAME _ EXTENDED )  ;    i    >     0  ;    i -  -  )     {", "stackMap    =    readFrameType ( frame . local ,     ( local +  +  )  ,    stackMap ,    c ,    labels )  ;", "}", "frame . mode    =    Opcodes . F _ APPEND ;", "frame . localDiff    =    tag    -     ( MethodWriter . SAME _ FRAME _ EXTENDED )  ;", "frame . localCount    +  =    frame . localDiff ;", "frame . stackCount    =     0  ;", "} else    {", "frame . mode    =    Opcodes . F _ FULL ;", "int   n    =    readUnsignedShort ( stackMap )  ;", "stackMap    +  =     2  ;", "frame . localDiff    =    n ;", "frame . localCount    =    n ;", "for    ( int   local    =     0  ;    n    >     0  ;    n -  -  )     {", "stackMap    =    readFrameType ( frame . local ,     ( local +  +  )  ,    stackMap ,    c ,    labels )  ;", "}", "n    =    readUnsignedShort ( stackMap )  ;", "stackMap    +  =     2  ;", "frame . stackCount    =    n ;", "for    ( int   stack    =     0  ;    n    >     0  ;    n -  -  )     {", "stackMap    =    readFrameType ( frame . stack ,     ( stack +  +  )  ,    stackMap ,    c ,    labels )  ;", "}", "}", "}", "frame . offset    +  =    delta    +     1  ;", "readLabel ( frame . offset ,    labels )  ;", "return   stackMap ;", "}", "METHOD_END"], "methodName": ["readFrame"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   type    =     ( b [  ( v +  +  )  ]  )     &     2  5  5  ;", "switch    ( type )     {", "case    0     :", "[ index ]     =    Opcodes . TOP ;", "break ;", "case    1     :", "[ index ]     =    Opcodes . INTEGER ;", "break ;", "case    2     :", "[ index ]     =    Opcodes . FLOAT ;", "break ;", "case    3     :", "[ index ]     =    Opcodes . DOUBLE ;", "break ;", "case    4     :", "[ index ]     =    Opcodes . LONG ;", "break ;", "case    5     :", "[ index ]     =    Opcodes . NULL ;", "break ;", "case    6     :", "[ index ]     =    Opcodes . UNINITIALIZED _ THIS ;", "break ;", "case    7     :", "[ index ]     =    readClass ( v ,    buf )  ;", "v    +  =     2  ;", "break ;", "default    :", "[ index ]     =    readLabel ( readUnsignedShort ( v )  ,    labels )  ;", "v    +  =     2  ;", "}", "return   v ;", "}", "METHOD_END"], "methodName": ["readFrameType"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    b    =    this . b ;", "return    (  (  (  (  ( b [ dex ]  )     &     2  5  5  )     <  <     2  4  )     |     (  (  ( b [  ( dex    +     1  )  ]  )     &     2  5  5  )     <  <     1  6  )  )     |     (  (  ( b [  ( dex    +     2  )  ]  )     &     2  5  5  )     <  <     8  )  )     |     (  ( b [  ( dex    +     3  )  ]  )     &     2  5  5  )  ;", "}", "METHOD_END"], "methodName": ["readInt"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "if    ( offset    >  =     ( labels . length )  )     {", "return   new   Label (  )  ;", "}", "if    (  ( labels [ offset ]  )     =  =    null )     {", "labels [ offset ]     =    new   Label (  )  ;", "}", "return   labels [ offset ]  ;", "}", "METHOD_END"], "methodName": ["readLabel"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "long   l 1     =    readInt ( index )  ;", "long   l 0     =     ( readInt (  ( index    +     4  )  )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "return    ( l 1     <  <     3  2  )     |    l 0  ;", "}", "METHOD_END"], "methodName": ["readLong"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    c    =    context . buffer ;", "context . access    =    readUnsignedShort ( u )  ;", "context . name    =    readUTF 8  (  ( u    +     2  )  ,    c )  ;", "context . desc    =    readUTF 8  (  ( u    +     4  )  ,    c )  ;", "u    +  =     6  ;", "int   code    =     0  ;", "int   exception    =     0  ;", "String [  ]    exceptions    =    null ;", "String   signature    =    null ;", "int   methodParameters    =     0  ;", "int   anns    =     0  ;", "int   ianns    =     0  ;", "int   tanns    =     0  ;", "int   itanns    =     0  ;", "int   dann    =     0  ;", "int   mpanns    =     0  ;", "int   impanns    =     0  ;", "int   firstAttribute    =    u ;", "Attribute   attributes    =    null ;", "for    ( int   i    =    readUnsignedShort ( u )  ;    i    >     0  ;     -  - i )     {", "String   attrName    =    readUTF 8  (  ( u    +     2  )  ,    c )  ;", "if    (  \" Code \"  . equals ( attrName )  )     {", "if    (  (  ( context . flags )     &     (  . SKIP _ CODE )  )     =  =     0  )     {", "code    =    u    +     8  ;", "}", "} else", "if    (  \" Exceptions \"  . equals ( attrName )  )     {", "exceptions    =    new   String [ readUnsignedShort (  ( u    +     8  )  )  ]  ;", "exception    =    u    +     1  0  ;", "for    ( int   j    =     0  ;    j    <     ( exceptions . length )  ;     +  + j )     {", "exceptions [ j ]     =    readClass ( exception ,    c )  ;", "exception    +  =     2  ;", "}", "} else", "if    (  (  . SIGNATURES )     &  &     (  \" Signature \"  . equals ( attrName )  )  )     {", "signature    =    readUTF 8  (  ( u    +     8  )  ,    c )  ;", "} else", "if    (  \" Deprecated \"  . equals ( attrName )  )     {", "context . access    |  =    Opcodes . ACC _ DEPRECATED ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeVisibleAnnotations \"  . equals ( attrName )  )  )     {", "anns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeVisibleTypeAnnotations \"  . equals ( attrName )  )  )     {", "tanns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" AnnotationDefault \"  . equals ( attrName )  )  )     {", "dann    =    u    +     8  ;", "} else", "if    (  \" Synthetic \"  . equals ( attrName )  )     {", "context . access    |  =     ( Opcodes . ACC _ SYNTHETIC )     |     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeInvisibleAnnotations \"  . equals ( attrName )  )  )     {", "ianns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeInvisibleTypeAnnotations \"  . equals ( attrName )  )  )     {", "itanns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeVisibleParameterAnnotations \"  . equals ( attrName )  )  )     {", "mpanns    =    u    +     8  ;", "} else", "if    (  (  . ANNOTATIONS )     &  &     (  \" RuntimeInvisibleParameterAnnotations \"  . equals ( attrName )  )  )     {", "impanns    =    u    +     8  ;", "} else", "if    (  \" MethodParameters \"  . equals ( attrName )  )     {", "methodParameters    =    u    +     8  ;", "} else    {", "Attribute   attr    =    readAttribute ( context . attrs ,    attrName ,     ( u    +     8  )  ,    readInt (  ( u    +     4  )  )  ,    c ,     (  -  1  )  ,    null )  ;", "if    ( attr    !  =    null )     {", "attr . next    =    attributes ;", "attributes    =    attr ;", "}", "}", "u    +  =     6     +     ( readInt (  ( u    +     4  )  )  )  ;", "}", "u    +  =     2  ;", "MethodVisitor   mv    =    classVisitor . visitMethod ( context . access ,    context . name ,    context . desc ,    signature ,    exceptions )  ;", "if    ( mv    =  =    null )     {", "return   u ;", "}", "if    (  (  . WRITER )     &  &     ( mv   instanceof   MethodWriter )  )     {", "MethodWriter   mw    =     (  ( MethodWriter )     ( mv )  )  ;", "if    (  (  ( mw . cw . cr )     =  =     ( this )  )     &  &     ( signature    !  =    null    ?    signature . equals ( mw . signature )     :     ( mw . signature )     =  =    null )  )     {", "boolean   sameExceptions    =    false ;", "if    ( exceptions    =  =    null )     {", "sameExceptions    =     ( mw . exceptionCount )     =  =     0  ;", "} else", "if    (  ( exceptions . length )     =  =     ( mw . exceptionCount )  )     {", "sameExceptions    =    true ;", "for    ( int   j    =     ( exceptions . length )     -     1  ;    j    >  =     0  ;     -  - j )     {", "exception    -  =     2  ;", "if    (  ( mw . exceptions [ j ]  )     !  =     ( readUnsignedShort ( exception )  )  )     {", "sameExceptions    =    false ;", "break ;", "}", "}", "}", "if    ( sameExceptions )     {", "mw . classReaderOffset    =    firstAttribute ;", "mw . classReaderLength    =    u    -    firstAttribute ;", "return   u ;", "}", "}", "}", "if    ( methodParameters    !  =     0  )     {", "for    ( int   i    =     ( b [ methodParameters ]  )     &     2  5  5  ,    v    =    methodParameters    +     1  ;    i    >     0  ;     -  - i    ,    v    =    v    +     4  )     {", "mv . visitParameter ( readUTF 8  ( v ,    c )  ,    readUnsignedShort (  ( v    +     2  )  )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( dann    !  =     0  )  )     {", "AnnotationVisitor   dv    =    mv . visitAnnotationDefault (  )  ;", "readAnnotationValue ( dann ,    c ,    null ,    dv )  ;", "if    ( dv    !  =    null )     {", "dv . visitEnd (  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( anns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( anns )  ,    v    =    anns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    mv . visitAnnotation ( readUTF 8  ( v ,    c )  ,    true )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( ianns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( ianns )  ,    v    =    ianns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    mv . visitAnnotation ( readUTF 8  ( v ,    c )  ,    false )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( tanns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( tanns )  ,    v    =    tanns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationTarget ( context ,    v )  ;", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    mv . visitTypeAnnotation ( context . typeRef ,    context . typePath ,    readUTF 8  ( v ,    c )  ,    true )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( itanns    !  =     0  )  )     {", "for    ( int   i    =    readUnsignedShort ( itanns )  ,    v    =    itanns    +     2  ;    i    >     0  ;     -  - i )     {", "v    =    readAnnotationTarget ( context ,    v )  ;", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    mv . visitTypeAnnotation ( context . typeRef ,    context . typePath ,    readUTF 8  ( v ,    c )  ,    false )  )  ;", "}", "}", "if    (  (  . ANNOTATIONS )     &  &     ( mpanns    !  =     0  )  )     {", "readParameterAnnotations ( mv ,    context ,    mpanns ,    true )  ;", "}", "if    (  (  . ANNOTATIONS )     &  &     ( impanns    !  =     0  )  )     {", "readParameterAnnotations ( mv ,    context ,    impanns ,    false )  ;", "}", "while    ( attributes    !  =    null )     {", "Attribute   attr    =    attributes . next ;", "attributes . next    =    null ;", "mv . visitAttribute ( attributes )  ;", "attributes    =    attr ;", "}", "if    ( code    !  =     0  )     {", "mv . visitCode (  )  ;", "readCode ( mv ,    context ,    code )  ;", "}", "mv . visitEnd (  )  ;", "return   u ;", "}", "METHOD_END"], "methodName": ["readMethod"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   readStringish ( index ,    buf )  ;", "}", "METHOD_END"], "methodName": ["readModule"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    buffer    =    context . buffer ;", "String   name    =    readModule ( u ,    buffer )  ;", "int   flags    =    readUnsignedShort (  ( u    +     2  )  )  ;", "String   version    =    readUTF 8  (  ( u    +     4  )  ,    buffer )  ;", "u    +  =     6  ;", "ModuleVisitor   mv    =    classVisitor . visitModule ( name ,    flags ,    version )  ;", "if    ( mv    =  =    null )     {", "return ;", "}", "if    ( main    !  =    null )     {", "mv . visitMain ( main )  ;", "}", "if    ( packages    !  =     0  )     {", "for    ( int   i    =    readUnsignedShort (  ( packages    -     2  )  )  ;    i    >     0  ;     -  - i )     {", "String   packaze    =    readPackage ( packages ,    buffer )  ;", "mv . visitPackage ( packaze )  ;", "packages    +  =     2  ;", "}", "}", "u    +  =     2  ;", "for    ( int   i    =    readUnsignedShort (  ( u    -     2  )  )  ;    i    >     0  ;     -  - i )     {", "String   module    =    readModule ( u ,    buffer )  ;", "int   access    =    readUnsignedShort (  ( u    +     2  )  )  ;", "String   requireVersion    =    readUTF 8  (  ( u    +     4  )  ,    buffer )  ;", "mv . visitRequire ( module ,    access ,    requireVersion )  ;", "u    +  =     6  ;", "}", "u    +  =     2  ;", "for    ( int   i    =    readUnsignedShort (  ( u    -     2  )  )  ;    i    >     0  ;     -  - i )     {", "String   export    =    readPackage ( u ,    buffer )  ;", "int   access    =    readUnsignedShort (  ( u    +     2  )  )  ;", "int   exportToCount    =    readUnsignedShort (  ( u    +     4  )  )  ;", "u    +  =     6  ;", "String [  ]    tos    =    null ;", "if    ( exportToCount    !  =     0  )     {", "tos    =    new   String [ exportToCount ]  ;", "for    ( int   j    =     0  ;    j    <     ( tos . length )  ;     +  + j )     {", "tos [ j ]     =    readModule ( u ,    buffer )  ;", "u    +  =     2  ;", "}", "}", "mv . visitExport ( export ,    access ,    tos )  ;", "}", "u    +  =     2  ;", "for    ( int   i    =    readUnsignedShort (  ( u    -     2  )  )  ;    i    >     0  ;     -  - i )     {", "String   open    =    readPackage ( u ,    buffer )  ;", "int   access    =    readUnsignedShort (  ( u    +     2  )  )  ;", "int   openToCount    =    readUnsignedShort (  ( u    +     4  )  )  ;", "u    +  =     6  ;", "String [  ]    tos    =    null ;", "if    ( openToCount    !  =     0  )     {", "tos    =    new   String [ openToCount ]  ;", "for    ( int   j    =     0  ;    j    <     ( tos . length )  ;     +  + j )     {", "tos [ j ]     =    readModule ( u ,    buffer )  ;", "u    +  =     2  ;", "}", "}", "mv . visitOpen ( open ,    access ,    tos )  ;", "}", "u    +  =     2  ;", "for    ( int   i    =    readUnsignedShort (  ( u    -     2  )  )  ;    i    >     0  ;     -  - i )     {", "mv . visitUse ( read ( u ,    buffer )  )  ;", "u    +  =     2  ;", "}", "u    +  =     2  ;", "for    ( int   i    =    readUnsignedShort (  ( u    -     2  )  )  ;    i    >     0  ;     -  - i )     {", "String   service    =    read ( u ,    buffer )  ;", "int   provideWithCount    =    readUnsignedShort (  ( u    +     2  )  )  ;", "u    +  =     4  ;", "String [  ]    withs    =    new   String [ provideWithCount ]  ;", "for    ( int   j    =     0  ;    j    <     ( withs . length )  ;     +  + j )     {", "withs [ j ]     =    read ( u ,    buffer )  ;", "u    +  =     2  ;", "}", "mv . visitProvide ( service ,    withs )  ;", "}", "mv . visitEnd (  )  ;", "}", "METHOD_END"], "methodName": ["readModule"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   readStringish ( index ,    buf )  ;", "}", "METHOD_END"], "methodName": ["readPackage"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   i ;", "int   n    =     ( b [  ( v +  +  )  ]  )     &     2  5  5  ;", "int   synthetics    =     ( Type . getArgumentTypes ( context . desc )  . length )     -    n ;", "AnnotationVisitor   av ;", "for    ( i    =     0  ;    i    <    synthetics ;     +  + i )     {", "av    =    mv . visitPaterAnnotation ( i ,     \" Ljava / lang / Synthetic ;  \"  ,    false )  ;", "if    ( av    !  =    null )     {", "av . visitEnd (  )  ;", "}", "}", "char [  ]    c    =    context . buffer ;", "for    (  ;    i    <     ( n    +    synthetics )  ;     +  + i )     {", "int   j    =    readUnsignedShort ( v )  ;", "v    +  =     2  ;", "for    (  ;    j    >     0  ;     -  - j )     {", "av    =    mv . visitPaterAnnotation ( i ,    readUTF 8  ( v ,    c )  ,    visible )  ;", "v    =    readAnnotationValues (  ( v    +     2  )  ,    c ,    true ,    av )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readParameterAnnotations"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    b    =    this . b ;", "return    (  ( sht )     (  (  (  ( b [ index ]  )     &     2  5  5  )     <  <     8  )     |     (  ( b [  ( index    +     1  )  ]  )     &     2  5  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["readShort"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "return   readUTF 8  ( items [ readUnsignedShort ( index )  ]  ,    buf )  ;", "}", "METHOD_END"], "methodName": ["readStringish"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    c    =    context . buffer ;", "int [  ]    offsets    =    new   int [ rUnsignedShort ( u )  ]  ;", "u    +  =     2  ;", "for    ( int   i    =     0  ;    i    <     ( offsets . length )  ;     +  + i )     {", "offsets [ i ]     =    u ;", "int   target    =    rInt ( u )  ;", "switch    ( target    >  >  >     2  4  )     {", "case    0     :", "case    1     :", "case    2  2     :", "u    +  =     2  ;", "break ;", "case    1  9     :", "case    2  0     :", "case    2  1     :", "u    +  =     1  ;", "break ;", "case    6  4     :", "case    6  5     :", "for    ( int   j    =    rUnsignedShort (  ( u    +     1  )  )  ;    j    >     0  ;     -  - j )     {", "int   start    =    rUnsignedShort (  ( u    +     3  )  )  ;", "int   length    =    rUnsignedShort (  ( u    +     5  )  )  ;", "rLabel ( start ,    context . labels )  ;", "rLabel (  ( start    +    length )  ,    context . labels )  ;", "u    +  =     6  ;", "}", "u    +  =     3  ;", "break ;", "case    7  1     :", "case    7  2     :", "case    7  3     :", "case    7  4     :", "case    7  5     :", "u    +  =     4  ;", "break ;", "default    :", "u    +  =     3  ;", "break ;", "}", "int   pathLength    =    rByte ( u )  ;", "if    (  ( target    >  >  >     2  4  )     =  =     6  6  )     {", "TypePath   path    =     ( pathLength    =  =     0  )     ?    null    :    new   TypePath ( b ,    u )  ;", "u    +  =     1     +     (  2     *    pathLength )  ;", "u    =    rAnnotationValues (  ( u    +     2  )  ,    c ,    true ,    mv . visitTryCatchAnnotation ( target ,    path ,    rUTF 8  ( u ,    c )  ,    visible )  )  ;", "} else    {", "u    =    rAnnotationValues (  (  ( u    +     3  )     +     (  2     *    pathLength )  )  ,    c ,    true ,    null )  ;", "}", "}", "return   offsets ;", "}", "METHOD_END"], "methodName": ["readTypeAnnotations"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   endIndex    =    index    +    utfLen ;", "byte [  ]    b    =    this . b ;", "int   strLen    =     0  ;", "int   c ;", "int   st    =     0  ;", "char   cc    =     0  ;", "while    ( index    <    endIndex )     {", "c    =    b [  ( index +  +  )  ]  ;", "switch    ( st )     {", "case    0     :", "c    =    c    &     2  5  5  ;", "if    ( c    <     1  2  8  )     {", "buf [  ( strLen +  +  )  ]     =     (  ( char )     ( c )  )  ;", "} else", "if    (  ( c    <     2  2  4  )     &  &     ( c    >     1  9  1  )  )     {", "cc    =     (  ( char )     ( c    &     3  1  )  )  ;", "st    =     1  ;", "} else    {", "cc    =     (  ( char )     ( c    &     1  5  )  )  ;", "st    =     2  ;", "}", "break ;", "case    1     :", "buf [  ( strLen +  +  )  ]     =     (  ( char )     (  ( cc    <  <     6  )     |     ( c    &     6  3  )  )  )  ;", "st    =     0  ;", "break ;", "case    2     :", "cc    =     (  ( char )     (  ( cc    <  <     6  )     |     ( c    &     6  3  )  )  )  ;", "st    =     1  ;", "break ;", "}", "}", "return   new   St ( buf ,     0  ,    strLen )  ;", "}", "METHOD_END"], "methodName": ["readUTF"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "int   item    =    readUnsignedShort ( index )  ;", "if    (  ( index    =  =     0  )     |  |     ( item    =  =     0  )  )     {", "return   null ;", "}", "St   s    =    sts [ item ]  ;", "if    ( s    !  =    null )     {", "return   s ;", "}", "index    =    items [ item ]  ;", "return   sts [ item ]     =    readUTF (  ( index    +     2  )  ,    readUnsignedShort ( index )  ,    buf )  ;", "}", "METHOD_END"], "methodName": ["readUTF8"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    b    =    this . b ;", "return    (  (  ( b [ dex ]  )     &     2  5  5  )     <  <     8  )     |     (  ( b [  ( dex    +     1  )  ]  )     &     2  5  5  )  ;", "}", "METHOD_END"], "methodName": ["readUnsignedShort"], "fileName": "org.springframework.asm.ClassReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "cv . v ( version ,    access ,    name ,    signature ,    superName ,    interfaces )  ;", "}", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "return   cv . vAnnotation ( desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitAnnotation"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "cv . vAttribute ( attr )  ;", "}", "}", "METHOD_END"], "methodName": ["visitAttribute"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "cv . vEnd (  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitEnd"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "return   cv . vField ( access ,    name ,    desc ,    signature ,    value )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitField"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "cv . visitInner ( name ,    outerName ,    innerName ,    access )  ;", "}", "}", "METHOD_END"], "methodName": ["visitInnerClass"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "return   cv . vMethod ( access ,    name ,    desc ,    signature ,    exceptions )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitMethod"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( api )     <     ( Opcodes . ASM 6  )  )     {", "throw   new   RuntimeException (  )  ;", "}", "if    (  ( cv )     !  =    null )     {", "return   cv . vModule ( name ,    access ,    version )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitModule"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "cv . visitOuter ( owner ,    name ,    desc )  ;", "}", "}", "METHOD_END"], "methodName": ["visitOuterClass"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "cv . vSource ( source ,    debug )  ;", "}", "}", "METHOD_END"], "methodName": ["visitSource"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cv )     !  =    null )     {", "return   cv . vTypeAnnotation ( typeRef ,    typePath ,    desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitTypeAnnotation"], "fileName": "org.springframework.asm.ClassVisitor"}, {"methodBody": ["METHOD_START", "{", "key . set ( ClassWriter . TYPE _ NORMAL ,    type ,    null ,    null )  ;", "Item   result    =    get ( key )  ;", "if    ( result    =  =    null )     {", "result    =    addType ( key )  ;", "}", "return   result . index ;", "}", "METHOD_END"], "methodName": ["addType"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "+  +  ( typeCount )  ;", "Item   result    =    new   Item ( typeCount ,    m )  ;", "put ( result )  ;", "if    (  ( typeTable )     =  =    null )     {", "typeTable    =    new   Item [  1  6  ]  ;", "}", "if    (  ( typeCount )     =  =     ( typeTable . length )  )     {", "Item [  ]    newTable    =    new   Item [  2     *     ( typeTable . length )  ]  ;", "System . arraycopy ( typeTable ,     0  ,    newTable ,     0  ,    typeTable . length )  ;", "typeTable    =    newTable ;", "}", "typeTable [ typeCount ]     =    result ;", "return   result ;", "}", "METHOD_END"], "methodName": ["addType"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key . type    =    ClassWriter . TYPE _ UNINIT ;", "key . intVal    =    offset ;", "key . strVal 1     =    type ;", "key . hashCode    =     2  1  4  7  4  8  3  6  4  7     &     (  (  ( ClassWriter . TYPE _ UNINIT )     +     ( type . hashCode (  )  )  )     +    offset )  ;", "Item   result    =    get ( key )  ;", "if    ( result    =  =    null )     {", "result    =    addType ( key )  ;", "}", "return   result . index ;", "}", "METHOD_END"], "methodName": ["addUninitializedType"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "Item   i    =    items [  (  ( key . hashCode )     %     ( items . length )  )  ]  ;", "while    (  ( i    !  =    null )     &  &     (  (  ( i . type )     !  =     ( key . type )  )     |  |     (  !  ( key . isEqualTo ( i )  )  )  )  )     {", "i    =    i . next ;", "}", "return   i ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   classLoader    =    null ;", "try    {", "classLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "}    catch    ( Throwable   ex )     {", "}", "return   classLoader    !  =    null    ?    classLoader    :    getClass (  )  . getClassLoader (  )  ;", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    c ;", "Class <  ?  >    d ;", "ClassLoader   classLoader    =    getClassLoader (  )  ;", "try    {", "c    =    Class . forName ( type 1  . replace (  '  /  '  ,     '  .  '  )  ,    false ,    classLoader )  ;", "d    =    Class . forName ( type 2  . replace (  '  /  '  ,     '  .  '  )  ,    false ,    classLoader )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e . toString (  )  )  ;", "}", "if    ( c . isAssignableFrom ( d )  )     {", "return   type 1  ;", "}", "if    ( d . isAssignableFrom ( c )  )     {", "return   type 2  ;", "}", "if    (  ( c . isInterface (  )  )     |  |     ( d . isInterface (  )  )  )     {", "return    \" java / lang / Object \"  ;", "} else    {", "do    {", "c    =    c . getSuperclass (  )  ;", "}    while    (  !  ( c . isAssignableFrom ( d )  )     )  ;", "return   c . getName (  )  . replace (  '  .  '  ,     '  /  '  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCommonSuperClass"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key 2  . type    =    ClassWriter . TYPE _ MERGED ;", "key 2  . longVal    =    type 1     |     (  (  ( long )     ( type 2  )  )     <  <     3  2  )  ;", "key 2  . hashCode    =     2  1  4  7  4  8  3  6  4  7     &     (  (  ( ClassWriter . TYPE _ MERGED )     +    type 1  )     +    type 2  )  ;", "Item   result    =    get ( key 2  )  ;", "if    ( result    =  =    null )     {", "String   t    =    typeTable [ type 1  ]  . strVal 1  ;", "String   u    =    typeTable [ type 2  ]  . strVal 1  ;", "key 2  . intVal    =    addType ( getCommonSuperClass ( t ,    u )  )  ;", "result    =    new   Item (  (  ( short )     (  0  )  )  ,    key 2  )  ;", "put ( result )  ;", "}", "return   result . intVal ;", "}", "METHOD_END"], "methodName": ["getMergedType"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newStringishItem ( ClassWriter . CLASS ,    value )  . index ;", "}", "METHOD_END"], "methodName": ["newClass"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newConstItem ( cst )  . index ;", "}", "METHOD_END"], "methodName": ["newConst"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( cst   instanceof   Integer )     {", "int   val    =     (  ( Integer )     ( cst )  )  . intValue (  )  ;", "return   newInteger ( val )  ;", "} else", "if    ( cst   instanceof   Byte )     {", "int   val    =     (  ( Byte )     ( cst )  )  . intValue (  )  ;", "return   newInteger ( val )  ;", "} else", "if    ( cst   instanceof   Character )     {", "int   val    =     (  ( Character )     ( cst )  )  . charValue (  )  ;", "return   newInteger ( val )  ;", "} else", "if    ( cst   instanceof   Short )     {", "int   val    =     (  ( Short )     ( cst )  )  . intValue (  )  ;", "return   newInteger ( val )  ;", "} else", "if    ( cst   instanceof   Boolean )     {", "int   val    =     (  (  ( Boolean )     ( cst )  )  . booleanValue (  )  )     ?     1     :     0  ;", "return   newInteger ( val )  ;", "} else", "if    ( cst   instanceof   Float )     {", "float   val    =     (  ( Float )     ( cst )  )  . floatValue (  )  ;", "return   newFloat ( val )  ;", "} else", "if    ( cst   instanceof   Long )     {", "long   val    =     (  ( Long )     ( cst )  )  . longValue (  )  ;", "return   newLong ( val )  ;", "} else", "if    ( cst   instanceof   Double )     {", "double   val    =     (  ( Double )     ( cst )  )  . doubleValue (  )  ;", "return   newDouble ( val )  ;", "} else", "if    ( cst   instanceof   String )     {", "return   newStringishItem (  . STR ,     (  ( String )     ( cst )  )  )  ;", "} else", "if    ( cst   instanceof   Type )     {", "Type   t    =     (  ( Type )     ( cst )  )  ;", "int   s    =    t . getSort (  )  ;", "if    ( s    =  =     ( Type . OBJECT )  )     {", "return   newStringishItem (  . CLASS ,    t . getInternalName (  )  )  ;", "} else", "if    ( s    =  =     ( Type . METHOD )  )     {", "return   newStringishItem (  . MTYPE ,    t . getDescriptor (  )  )  ;", "} else    {", "return   newStringishItem (  . CLASS ,    t . getDescriptor (  )  )  ;", "}", "} else", "if    ( cst   instanceof   Handle )     {", "Handle   h    =     (  ( Handle )     ( cst )  )  ;", "return   newHandleItem ( h . tag ,    h . owner ,    h . name ,    h . desc ,    h . itf )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" value    \"     +    cst )  )  ;", "}", "}", "METHOD_END"], "methodName": ["newConstItem"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key . set ( value )  ;", "Item   result    =    get ( key )  ;", "if    ( result    =  =    null )     {", "pool . putByte (  . DOUBLE )  . putLong ( key . longVal )  ;", "result    =    new   Item ( index ,    key )  ;", "index    +  =     2  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newDouble"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newFieldItem ( owner ,    name ,    desc )  . index ;", "}", "METHOD_END"], "methodName": ["newField"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key 3  . set ( ClassWriter . FIELD ,    owner ,    name ,    desc )  ;", "Item   result    =    get ( key 3  )  ;", "if    ( result    =  =    null )     {", "put 1  2  2  ( ClassWriter . FIELD ,    newClass ( owner )  ,    newNameType ( name ,    desc )  )  ;", "result    =    new   Item (  (  ( index )  +  +  )  ,    key 3  )  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newFieldItem"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key . set ( value )  ;", "Item   result    =    get ( key )  ;", "if    ( result    =  =    null )     {", "pool . putByte (  . FLOAT )  . putInt ( key . intVal )  ;", "result    =    new   Item (  (  ( index )  +  +  )  ,    key )  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newFloat"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newHandle ( tag ,    owner ,    name ,    desc ,     ( tag    =  =     ( Opcodes . H _ INVOKEINTERFACE )  )  )  ;", "}", "METHOD_END"], "methodName": ["newHandle"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newHandleItem ( tag ,    owner ,    name ,    desc ,    itf )  . index ;", "}", "METHOD_END"], "methodName": ["newHandle"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key 4  . set (  (  ( ClassWriter . HANDLE _ BASE )     +    tag )  ,    owner ,    name ,    desc )  ;", "Item   result    =    get ( key 4  )  ;", "if    ( result    =  =    null )     {", "if    ( tag    <  =     ( Opcodes . H _ PUTSTATIC )  )     {", "put 1  1  2  ( ClassWriter . HANDLE ,    tag ,    newField ( owner ,    name ,    desc )  )  ;", "} else    {", "put 1  1  2  ( ClassWriter . HANDLE ,    tag ,    newMethod ( owner ,    name ,    desc ,    itf )  )  ;", "}", "result    =    new   Item (  (  ( index )  +  +  )  ,    key 4  )  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newHandleItem"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key . set ( value )  ;", "Item   result    =    get ( key )  ;", "if    ( result    =  =    null )     {", "pool . putByte (  . INT )  . putInt ( value )  ;", "result    =    new   Item (  (  ( index )  +  +  )  ,    key )  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newInteger"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newInvokeDynamicItem ( name ,    desc ,    bsm ,    bsmArgs )  . index ;", "}", "METHOD_END"], "methodName": ["newInvokeDynamic"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "ByteVector   bootstrapMethods    =    this . bootstrapMethods ;", "if    ( bootstrapMethods    =  =    null )     {", "bootstrapMethods    =    this . bootstrapMethods    =    new   ByteVector (  )  ;", "}", "int   position    =    bootstrapMethods . length ;", "int   hashCode    =    bsm . hashCode (  )  ;", "bootstrapMethods . putShort ( newHandle ( bsm . tag ,    bsm . owner ,    bsm . name ,    bsm . desc ,    bsm . isInterface (  )  )  )  ;", "int   argsLength    =    bsmArgs . length ;", "bootstrapMethods . putShort ( argsLength )  ;", "for    ( int   i    =     0  ;    i    <    argsLength ;    i +  +  )     {", "Object   bsmArg    =    bsmArgs [ i ]  ;", "hashCode    ^  =    bsmArg . hashCode (  )  ;", "bootstrapMethods . putShort ( newConst ( bsmArg )  )  ;", "}", "byte [  ]    data    =    bootstrapMethods . data ;", "int   length    =     (  (  1     +     1  )     +    argsLength )     <  <     1  ;", "hashCode    &  =     2  1  4  7  4  8  3  6  4  7  ;", "Item   result    =    items [  ( hashCode    %     ( items . length )  )  ]  ;", "loop    :    while    ( result    !  =    null )     {", "if    (  (  ( result . type )     !  =     (  . BSM )  )     |  |     (  ( result . hashCode )     !  =    hashCode )  )     {", "result    =    result . next ;", "continue ;", "}", "int   resultPosition    =    result . intVal ;", "for    ( int   p    =     0  ;    p    <    length ;    p +  +  )     {", "if    (  ( data [  ( position    +    p )  ]  )     !  =     ( data [  ( resultPosition    +    p )  ]  )  )     {", "result    =    result . next ;", "continue   loop ;", "}", "}", "break ;", "}", "int   bootstrapMethodIndex ;", "if    ( result    !  =    null )     {", "bootstrapMethodIndex    =    result . index ;", "bootstrapMethods . length    =    position ;", "} else    {", "bootstrapMethodIndex    =     ( bootstrapMethodsCount )  +  +  ;", "result    =    new   Item ( bootstrapMethodIndex )  ;", "result . set ( position ,    hashCode )  ;", "put ( result )  ;", "}", "key 3  . set ( name ,    desc ,    bootstrapMethodIndex )  ;", "result    =    get ( key 3  )  ;", "if    ( result    =  =    null )     {", "put 1  2  2  (  . INDY ,    bootstrapMethodIndex ,    newNameType ( name ,    desc )  )  ;", "result    =    new   Item (  (  ( index )  +  +  )  ,    key 3  )  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newInvokeDynamicItem"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key . set ( value )  ;", "Item   result    =    get ( key )  ;", "if    ( result    =  =    null )     {", "pool . putByte (  . LONG )  . putLong ( value )  ;", "result    =    new   Item ( index ,    key )  ;", "index    +  =     2  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newLong"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newMethodItem ( owner ,    name ,    desc ,    itf )  . index ;", "}", "METHOD_END"], "methodName": ["newMethod"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "int   type    =     ( itf )     ?    ClassWriter . IMETH    :    ClassWriter . METH ;", "key 3  . set ( type ,    owner ,    name ,    desc )  ;", "Item   result    =    get ( key 3  )  ;", "if    ( result    =  =    null )     {", "put 1  2  2  ( type ,    newClass ( owner )  ,    newNameType ( name ,    desc )  )  ;", "result    =    new   Item (  (  ( index )  +  +  )  ,    key 3  )  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newMethodItem"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newStringishItem ( ClassWriter . MTYPE ,    methodDesc )  . index ;", "}", "METHOD_END"], "methodName": ["newMethodType"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newStringishItem ( ClassWriter . MODULE ,    moduleName )  . index ;", "}", "METHOD_END"], "methodName": ["newModule"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newNameTypeItem ( name ,    desc )  . index ;", "}", "METHOD_END"], "methodName": ["newNameType"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key 2  . set ( ClassWriter . NAME _ TYPE ,    name ,    desc ,    null )  ;", "Item   result    =    get ( key 2  )  ;", "if    ( result    =  =    null )     {", "put 1  2  2  ( ClassWriter . NAME _ TYPE ,    newUTF 8  ( name )  ,    newUTF 8  ( desc )  )  ;", "result    =    new   Item (  (  ( index )  +  +  )  ,    key 2  )  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newNameTypeItem"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "return   newStringishItem ( ClassWriter . PACKAGE ,    packageName )  . index ;", "}", "METHOD_END"], "methodName": ["newPackage"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key 2  . set ( type ,    value ,    null ,    null )  ;", "Item   result    =    get ( key 2  )  ;", "if    ( result    =  =    null )     {", "pool . put 1  2  ( type ,    newUTF 8  ( value )  )  ;", "result    =    new   Item (  (  ( index )  +  +  )  ,    key 2  )  ;", "put ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["newStringishItem"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "key . set ( ClassWriter . UTF 8  ,    value ,    null ,    null )  ;", "Item   result    =    get ( key )  ;", "if    ( result    =  =    null )     {", "pool . putByte ( ClassWriter . UTF 8  )  . putUTF 8  ( value )  ;", "result    =    new   Item (  (  ( index )  +  +  )  ,    key )  ;", "put ( result )  ;", "}", "return   result . index ;", "}", "METHOD_END"], "methodName": ["newUTF8"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( index )     +     ( typeCount )  )     >     ( threshold )  )     {", "int   ll    =    ms . length ;", "int   nl    =     ( ll    *     2  )     +     1  ;", "Item [  ]    newItems    =    new   Item [ nl ]  ;", "for    ( int   l    =    ll    -     1  ;    l    >  =     0  ;     -  - l )     {", "Item   j    =    ms [ l ]  ;", "while    ( j    !  =    null )     {", "int   index    =     ( j . hashCode )     %     ( newItems . length )  ;", "Item   k    =    j . next ;", "j . next    =    newItems [ index ]  ;", "newItems [ index ]     =    j ;", "j    =    k ;", "}", "}", "ms    =    newItems ;", "threshold    =     (  ( int )     ( nl    *     0  .  7  5  )  )  ;", "}", "int   index    =     ( i . hashCode )     %     ( ms . length )  ;", "i . next    =    ms [ index ]  ;", "ms [ index ]     =    i ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "pool . put 1  1  ( b 1  ,    b 2  )  . putShort ( s )  ;", "}", "METHOD_END"], "methodName": ["put112"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "pool . put 1  2  ( b ,    s 1  )  . putShort ( s 2  )  ;", "}", "METHOD_END"], "methodName": ["put122"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index )     >     6  5  5  3  5  )     {", "throw   new   RuntimeException (  \" Class   file   too   large !  \"  )  ;", "}", "int   size    =     2  4     +     (  2     *     ( interfaceCount )  )  ;", "int   nbFields    =     0  ;", "FieldWriter   fb    =    firstField ;", "while    ( fb    !  =    null )     {", "+  + nbFields ;", "size    +  =    fb . getSize (  )  ;", "fb    =     (  ( FieldWriter )     ( fb . fv )  )  ;", "}", "int   nbMethods    =     0  ;", "MethodWriter   mb    =    firstMethod ;", "while    ( mb    !  =    null )     {", "+  + nbMethods ;", "size    +  =    mb . getSize (  )  ;", "mb    =     (  ( MethodWriter )     ( mb . mv )  )  ;", "}", "int   attributeCount    =     0  ;", "if    (  ( bootstrapMethods )     !  =    null )     {", "+  + attributeCount ;", "size    +  =     8     +     ( bootstrapMethods . length )  ;", "newUTF 8  (  \" BootstrapMethods \"  )  ;", "}", "if    (  ( ClassReader . SIGNATURES )     &  &     (  ( signature )     !  =     0  )  )     {", "+  + attributeCount ;", "size    +  =     8  ;", "newUTF 8  (  \" Signature \"  )  ;", "}", "if    (  ( sourceFile )     !  =     0  )     {", "+  + attributeCount ;", "size    +  =     8  ;", "newUTF 8  (  \" SourceFile \"  )  ;", "}", "if    (  ( sourceDebug )     !  =    null )     {", "+  + attributeCount ;", "size    +  =     ( sourceDebug . length )     +     6  ;", "newUTF 8  (  \" SourceDebugExtension \"  )  ;", "}", "if    (  ( enclosingMethodOwner )     !  =     0  )     {", "+  + attributeCount ;", "size    +  =     1  0  ;", "newUTF 8  (  \" EnclosingMethod \"  )  ;", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ DEPRECATED )  )     !  =     0  )     {", "+  + attributeCount ;", "size    +  =     6  ;", "newUTF 8  (  \" Deprecated \"  )  ;", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ SYNTHETIC )  )     !  =     0  )     {", "if    (  (  (  ( version )     &     6  5  5  3  5  )     <     ( Opcodes . V 1  _  5  )  )     |  |     (  (  ( access )     &     (  . ACC _ SYNTHETIC _ ATTRIBUTE )  )     !  =     0  )  )     {", "+  + attributeCount ;", "size    +  =     6  ;", "newUTF 8  (  \" Synthetic \"  )  ;", "}", "}", "if    (  ( innerClasses )     !  =    null )     {", "+  + attributeCount ;", "size    +  =     8     +     ( innerClasses . length )  ;", "newUTF 8  (  \" InnerClasses \"  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( anns )     !  =    null )  )     {", "+  + attributeCount ;", "size    +  =     8     +     ( anns . getSize (  )  )  ;", "newUTF 8  (  \" RuntimeVisibleAnnotations \"  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ianns )     !  =    null )  )     {", "+  + attributeCount ;", "size    +  =     8     +     ( ianns . getSize (  )  )  ;", "newUTF 8  (  \" RuntimeInvisibleAnnotations \"  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( tanns )     !  =    null )  )     {", "+  + attributeCount ;", "size    +  =     8     +     ( tanns . getSize (  )  )  ;", "newUTF 8  (  \" RuntimeVisibleTypeAnnotations \"  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( itanns )     !  =    null )  )     {", "+  + attributeCount ;", "size    +  =     8     +     ( itanns . getSize (  )  )  ;", "newUTF 8  (  \" RuntimeInvisibleTypeAnnotations \"  )  ;", "}", "if    (  ( moduleWriter )     !  =    null )     {", "attributeCount    +  =     1     +     ( moduleWriter . attributeCount )  ;", "size    +  =     (  6     +     ( moduleWriter . size )  )     +     ( moduleWriter . attributesSize )  ;", "newUTF 8  (  \" Module \"  )  ;", "}", "if    (  ( attrs )     !  =    null )     {", "attributeCount    +  =    attrs . getCount (  )  ;", "size    +  =    attrs . getSize ( this ,    null ,     0  ,     (  -  1  )  ,     (  -  1  )  )  ;", "}", "size    +  =    pool . length ;", "ByteVector   out    =    new   ByteVector ( size )  ;", "out . putInt (  -  8  8  9  2  7  5  7  1  4  )  . putInt ( version )  ;", "out . putShort ( index )  . putByteArray ( pool . data ,     0  ,    pool . length )  ;", "int   mask    =     (  ( Opcodes . ACC _ DEPRECATED )     |     (  . ACC _ SYNTHETIC _ ATTRIBUTE )  )     |     (  (  ( access )     &     (  . ACC _ SYNTHETIC _ ATTRIBUTE )  )     /     (  . TO _ ACC _ SYNTHETIC )  )  ;", "out . putShort (  (  ( access )     &     (  ~ mask )  )  )  . putShort ( name )  . putShort ( superName )  ;", "out . putShort ( interfaceCount )  ;", "for    ( int   i    =     0  ;    i    <     ( interfaceCount )  ;     +  + i )     {", "out . putShort ( interfaces [ i ]  )  ;", "}", "out . putShort ( nbFields )  ;", "fb    =    firstField ;", "while    ( fb    !  =    null )     {", "fb . put ( out )  ;", "fb    =     (  ( FieldWriter )     ( fb . fv )  )  ;", "}", "out . putShort ( nbMethods )  ;", "mb    =    firstMethod ;", "while    ( mb    !  =    null )     {", "mb . put ( out )  ;", "mb    =     (  ( MethodWriter )     ( mb . mv )  )  ;", "}", "out . putShort ( attributeCount )  ;", "if    (  ( bootstrapMethods )     !  =    null )     {", "out . putShort ( newUTF 8  (  \" BootstrapMethods \"  )  )  ;", "out . putInt (  (  ( bootstrapMethods . length )     +     2  )  )  . putShort ( bootstrapMethodsCount )  ;", "out . putByteArray ( bootstrapMethods . data ,     0  ,    bootstrapMethods . length )  ;", "}", "if    (  ( ClassReader . SIGNATURES )     &  &     (  ( signature )     !  =     0  )  )     {", "out . putShort ( newUTF 8  (  \" Signature \"  )  )  . putInt (  2  )  . putShort ( signature )  ;", "}", "if    (  ( sourceFile )     !  =     0  )     {", "out . putShort ( newUTF 8  (  \" SourceFile \"  )  )  . putInt (  2  )  . putShort ( sourceFile )  ;", "}", "if    (  ( sourceDebug )     !  =    null )     {", "int   len    =    sourceDebug . length ;", "out . putShort ( newUTF 8  (  \" SourceDebugExtension \"  )  )  . putInt ( len )  ;", "out . putByteArray ( sourceDebug . data ,     0  ,    len )  ;", "}", "if    (  ( moduleWriter )     !  =    null )     {", "out . putShort ( newUTF 8  (  \" Module \"  )  )  ;", "moduleWriter . put ( out )  ;", "moduleWriter . putAttributes ( out )  ;", "}", "if    (  ( enclosingMethodOwner )     !  =     0  )     {", "out . putShort ( newUTF 8  (  \" EnclosingMethod \"  )  )  . putInt (  4  )  ;", "out . putShort ( enclosingMethodOwner )  . putShort ( enclosingMethod )  ;", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ DEPRECATED )  )     !  =     0  )     {", "out . putShort ( newUTF 8  (  \" Deprecated \"  )  )  . putInt (  0  )  ;", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ SYNTHETIC )  )     !  =     0  )     {", "if    (  (  (  ( version )     &     6  5  5  3  5  )     <     ( Opcodes . V 1  _  5  )  )     |  |     (  (  ( access )     &     (  . ACC _ SYNTHETIC _ ATTRIBUTE )  )     !  =     0  )  )     {", "out . putShort ( newUTF 8  (  \" Synthetic \"  )  )  . putInt (  0  )  ;", "}", "}", "if    (  ( innerClasses )     !  =    null )     {", "out . putShort ( newUTF 8  (  \" InnerClasses \"  )  )  ;", "out . putInt (  (  ( innerClasses . length )     +     2  )  )  . putShort ( innerClassesCount )  ;", "out . putByteArray ( innerClasses . data ,     0  ,    innerClasses . length )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( anns )     !  =    null )  )     {", "out . putShort ( newUTF 8  (  \" RuntimeVisibleAnnotations \"  )  )  ;", "anns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ianns )     !  =    null )  )     {", "out . putShort ( newUTF 8  (  \" RuntimeInvisibleAnnotations \"  )  )  ;", "ianns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( tanns )     !  =    null )  )     {", "out . putShort ( newUTF 8  (  \" RuntimeVisibleTypeAnnotations \"  )  )  ;", "tanns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( itanns )     !  =    null )  )     {", "out . putShort ( newUTF 8  (  \" RuntimeInvisibleTypeAnnotations \"  )  )  ;", "itanns . put ( out )  ;", "}", "if    (  ( attrs )     !  =    null )     {", "attrs . put ( this ,    null ,     0  ,     (  -  1  )  ,     (  -  1  )  ,    out )  ;", "}", "if    ( hasAsmInsns )     {", "boolean   hasFrames    =    false ;", "mb    =    firstMethod ;", "while    ( mb    !  =    null )     {", "hasFrames    |  =     ( mb . frameCount )     >     0  ;", "mb    =     (  ( MethodWriter )     ( mb . mv )  )  ;", "}", "anns    =    null ;", "ianns    =    null ;", "attrs    =    null ;", "moduleWriter    =    null ;", "innerClassesCount    =     0  ;", "innerClasses    =    null ;", "firstField    =    null ;", "lastField    =    null ;", "firstMethod    =    null ;", "lastMethod    =    null ;", "compute    =     ( hasFrames )     ?    MethodWriter . INSERTED _ FRAMES    :     0  ;", "hasAsmInsns    =    false ;", "new   ClassReader ( out . data )  . accept ( this ,     (  ( hasFrames    ?    ClassReader . EXPAND _ FRAMES    :     0  )     |     ( ClassReader . EXPAND _ ASM _ INSNS )  )  )  ;", "return   toByteArray (  )  ;", "}", "return   out . data ;", "}", "METHOD_END"], "methodName": ["toByteArray"], "fileName": "org.springframework.asm.ClassWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fv )     !  =    null )     {", "return   fv . vAnnotation ( desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitAnnotation"], "fileName": "org.springframework.asm.FieldVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fv )     !  =    null )     {", "fv . vAttribute ( attr )  ;", "}", "}", "METHOD_END"], "methodName": ["visitAttribute"], "fileName": "org.springframework.asm.FieldVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fv )     !  =    null )     {", "fv . vEnd (  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitEnd"], "fileName": "org.springframework.asm.FieldVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fv )     !  =    null )     {", "return   fv . vTypeAnnotation ( typeRef ,    typePath ,    desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitTypeAnnotation"], "fileName": "org.springframework.asm.FieldVisitor"}, {"methodBody": ["METHOD_START", "{", "int   size    =     8  ;", "if    (  ( value )     !  =     0  )     {", "cw . newUTF 8  (  \" ConstantValue \"  )  ;", "size    +  =     8  ;", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ SYNTHETIC )  )     !  =     0  )     {", "if    (  (  (  ( cw . version )     &     6  5  5  3  5  )     <     ( Opcodes . V 1  _  5  )  )     |  |     (  (  ( access )     &     ( Class . ACC _ SYNTHETIC _ ATTRIBUTE )  )     !  =     0  )  )     {", "cw . newUTF 8  (  \" Synthetic \"  )  ;", "size    +  =     6  ;", "}", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ DEPRECATED )  )     !  =     0  )     {", "cw . newUTF 8  (  \" Deprecated \"  )  ;", "size    +  =     6  ;", "}", "if    (  ( ClassReader . SIGNATURES )     &  &     (  ( signature )     !  =     0  )  )     {", "cw . newUTF 8  (  \" Signature \"  )  ;", "size    +  =     8  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( anns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeVisibleAnnotations \"  )  ;", "size    +  =     8     +     ( anns . getSize (  )  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ianns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeInvisibleAnnotations \"  )  ;", "size    +  =     8     +     ( ianns . getSize (  )  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( tanns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeVisibleTypeAnnotations \"  )  ;", "size    +  =     8     +     ( tanns . getSize (  )  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( itanns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeInvisibleTypeAnnotations \"  )  ;", "size    +  =     8     +     ( itanns . getSize (  )  )  ;", "}", "if    (  ( attrs )     !  =    null )     {", "size    +  =    attrs . getSize ( cw ,    null ,     0  ,     (  -  1  )  ,     (  -  1  )  )  ;", "}", "return   size ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.springframework.asm.FieldWriter"}, {"methodBody": ["METHOD_START", "{", "final   int   FACTOR    =    ClassWriter . TO _ ACC _ SYNTHETIC ;", "int   mask    =     (  ( Opcodes . ACC _ DEPRECATED )     |     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  )     |     (  (  ( access )     &     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  )     /    FACTOR )  ;", "out . putShort (  (  ( access )     &     (  ~ mask )  )  )  . putShort ( name )  . putShort ( desc )  ;", "int   attributeCount    =     0  ;", "if    (  ( value )     !  =     0  )     {", "+  + attributeCount ;", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ SYNTHETIC )  )     !  =     0  )     {", "if    (  (  (  ( cw . version )     &     6  5  5  3  5  )     <     ( Opcodes . V 1  _  5  )  )     |  |     (  (  ( access )     &     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  )     !  =     0  )  )     {", "+  + attributeCount ;", "}", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ DEPRECATED )  )     !  =     0  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . SIGNATURES )     &  &     (  ( signature )     !  =     0  )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( anns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ianns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( tanns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( itanns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( attrs )     !  =    null )     {", "attributeCount    +  =    attrs . getCount (  )  ;", "}", "out . putShort ( attributeCount )  ;", "if    (  ( value )     !  =     0  )     {", "out . putShort ( cw . newUTF 8  (  \" ConstantValue \"  )  )  ;", "out . putInt (  2  )  . putShort ( value )  ;", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ SYNTHETIC )  )     !  =     0  )     {", "if    (  (  (  ( cw . version )     &     6  5  5  3  5  )     <     ( Opcodes . V 1  _  5  )  )     |  |     (  (  ( access )     &     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  )     !  =     0  )  )     {", "out . putShort ( cw . newUTF 8  (  \" Synthetic \"  )  )  . putInt (  0  )  ;", "}", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ DEPRECATED )  )     !  =     0  )     {", "out . putShort ( cw . newUTF 8  (  \" Deprecated \"  )  )  . putInt (  0  )  ;", "}", "if    (  ( ClassReader . SIGNATURES )     &  &     (  ( signature )     !  =     0  )  )     {", "out . putShort ( cw . newUTF 8  (  \" Signature \"  )  )  ;", "out . putInt (  2  )  . putShort ( signature )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( anns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeVisibleAnnotations \"  )  )  ;", "anns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ianns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeInvisibleAnnotations \"  )  )  ;", "ianns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( tanns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeVisibleTypeAnnotations \"  )  )  ;", "tanns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( itanns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeInvisibleTypeAnnotations \"  )  )  ;", "itanns . put ( out )  ;", "}", "if    (  ( attrs )     !  =    null )     {", "attrs . put ( cw ,    null ,     0  ,     (  -  1  )  ,     (  -  1  )  ,    out )  ;", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.asm.FieldWriter"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "for    ( int   j    =     0  ;    j    <    nInput ;     +  + j )     {", "if    (  ( input [ j ]  )    instanceof   Integer )     {", "output [  ( i +  +  )  ]     =     (  . BASE )     |     (  (  ( Integer )     ( input [ j ]  )  )  . intValue (  )  )  ;", "if    (  (  ( input [ j ]  )     =  =     ( Opcodes . LONG )  )     |  |     (  ( input [ j ]  )     =  =     ( Opcodes . DOUBLE )  )  )     {", "output [  ( i +  +  )  ]     =     . TOP ;", "}", "} else", "if    (  ( input [ j ]  )    instanceof   String )     {", "output [  ( i +  +  )  ]     =     . type ( cw ,    Type . getObjectType (  (  ( String )     ( input [ j ]  )  )  )  . getDescriptor (  )  )  ;", "} else    {", "output [  ( i +  +  )  ]     =     (  . UNINITIALIZED )     |     ( cw . addUninitializedType (  \"  \"  ,     (  ( Label )     ( input [ j ]  )  )  . position )  )  ;", "}", "}", "return   i ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "int   t 1  ;", "int   t 2  ;", "int   t 3  ;", "int   t 4  ;", "switch    ( opcode )     {", "case   Opcodes . NOP    :", "case   Opcodes . INEG    :", "case   Opcodes . LNEG    :", "case   Opcodes . FNEG    :", "case   Opcodes . DNEG    :", "case   Opcodes . I 2 B    :", "case   Opcodes . I 2 C    :", "case   Opcodes . I 2 S    :", "case   Opcodes . GOTO    :", "case   Opcodes . RETURN    :", "break ;", "case   Opcodes . ACONST _ NULL    :", "push (  . NULL )  ;", "break ;", "case   Opcodes . ICONST _ M 1     :", "case   Opcodes . ICONST _  0     :", "case   Opcodes . ICONST _  1     :", "case   Opcodes . ICONST _  2     :", "case   Opcodes . ICONST _  3     :", "case   Opcodes . ICONST _  4     :", "case   Opcodes . ICONST _  5     :", "case   Opcodes . BIPUSH    :", "case   Opcodes . SIPUSH    :", "case   Opcodes . ILOAD    :", "push (  . INTEGER )  ;", "break ;", "case   Opcodes . LCONST _  0     :", "case   Opcodes . LCONST _  1     :", "case   Opcodes . LLOAD    :", "push (  . LONG )  ;", "push (  . TOP )  ;", "break ;", "case   Opcodes . FCONST _  0     :", "case   Opcodes . FCONST _  1     :", "case   Opcodes . FCONST _  2     :", "case   Opcodes . FLOAD    :", "push (  . FLOAT )  ;", "break ;", "case   Opcodes . DCONST _  0     :", "case   Opcodes . DCONST _  1     :", "case   Opcodes . DLOAD    :", "push (  . DOUBLE )  ;", "push (  . TOP )  ;", "break ;", "case   Opcodes . LDC    :", "switch    ( item . type )     {", "case   ClassWriter . INT    :", "push (  . INTEGER )  ;", "break ;", "case   ClassWriter . LONG    :", "push (  . LONG )  ;", "push (  . TOP )  ;", "break ;", "case   ClassWriter . FLOAT    :", "push (  . FLOAT )  ;", "break ;", "case   ClassWriter . DOUBLE    :", "push (  . DOUBLE )  ;", "push (  . TOP )  ;", "break ;", "case   ClassWriter . CLASS    :", "push (  (  (  . OBJECT )     |     ( cw . addType (  \" java / lang / Class \"  )  )  )  )  ;", "break ;", "case   ClassWriter . STR    :", "push (  (  (  . OBJECT )     |     ( cw . addType (  \" java / lang / String \"  )  )  )  )  ;", "break ;", "case   ClassWriter . MTYPE    :", "push (  (  (  . OBJECT )     |     ( cw . addType (  \" java / lang / invoke / MethodType \"  )  )  )  )  ;", "break ;", "default    :", "push (  (  (  . OBJECT )     |     ( cw . addType (  \" java / lang / invoke / MethodHandle \"  )  )  )  )  ;", "}", "break ;", "case   Opcodes . ALOAD    :", "push ( get ( arg )  )  ;", "break ;", "case   Opcodes . IALOAD    :", "case   Opcodes . BALOAD    :", "case   Opcodes . CALOAD    :", "case   Opcodes . SALOAD    :", "pop (  2  )  ;", "push (  . INTEGER )  ;", "break ;", "case   Opcodes . LALOAD    :", "case   Opcodes . D 2 L    :", "pop (  2  )  ;", "push (  . LONG )  ;", "push (  . TOP )  ;", "break ;", "case   Opcodes . FALOAD    :", "pop (  2  )  ;", "push (  . FLOAT )  ;", "break ;", "case   Opcodes . DALOAD    :", "case   Opcodes . L 2 D    :", "pop (  2  )  ;", "push (  . DOUBLE )  ;", "push (  . TOP )  ;", "break ;", "case   Opcodes . AALOAD    :", "pop (  1  )  ;", "t 1     =    pop (  )  ;", "push (  (  (  . ELEMENT _ OF )     +    t 1  )  )  ;", "break ;", "case   Opcodes . ISTORE    :", "case   Opcodes . FSTORE    :", "case   Opcodes . ASTORE    :", "t 1     =    pop (  )  ;", "set ( arg ,    t 1  )  ;", "if    ( arg    >     0  )     {", "t 2     =    get (  ( arg    -     1  )  )  ;", "if    (  ( t 2     =  =     (  . LONG )  )     |  |     ( t 2     =  =     (  . DOUBLE )  )  )     {", "set (  ( arg    -     1  )  ,     . TOP )  ;", "} else", "if    (  ( t 2     &     (  . KIND )  )     !  =     (  . BASE )  )     {", "set (  ( arg    -     1  )  ,     ( t 2     |     (  . TOP _ IF _ LONG _ OR _ DOUBLE )  )  )  ;", "}", "}", "break ;", "case   Opcodes . LSTORE    :", "case   Opcodes . DSTORE    :", "pop (  1  )  ;", "t 1     =    pop (  )  ;", "set ( arg ,    t 1  )  ;", "set (  ( arg    +     1  )  ,     . TOP )  ;", "if    ( arg    >     0  )     {", "t 2     =    get (  ( arg    -     1  )  )  ;", "if    (  ( t 2     =  =     (  . LONG )  )     |  |     ( t 2     =  =     (  . DOUBLE )  )  )     {", "set (  ( arg    -     1  )  ,     . TOP )  ;", "} else", "if    (  ( t 2     &     (  . KIND )  )     !  =     (  . BASE )  )     {", "set (  ( arg    -     1  )  ,     ( t 2     |     (  . TOP _ IF _ LONG _ OR _ DOUBLE )  )  )  ;", "}", "}", "break ;", "case   Opcodes . IASTORE    :", "case   Opcodes . BASTORE    :", "case   Opcodes . CASTORE    :", "case   Opcodes . SASTORE    :", "case   Opcodes . FASTORE    :", "case   Opcodes . AASTORE    :", "pop (  3  )  ;", "break ;", "case   Opcodes . LASTORE    :", "case   Opcodes . DASTORE    :", "pop (  4  )  ;", "break ;", "case   Opcodes . POP    :", "case   Opcodes . IFEQ    :", "case   Opcodes . IFNE    :", "case   Opcodes . IFLT    :", "case   Opcodes . IFGE    :", "case   Opcodes . IFGT    :", "case   Opcodes . IFLE    :", "case   Opcodes . IRETURN    :", "case   Opcodes . FRETURN    :", "case   Opcodes . ARETURN    :", "case   Opcodes . TABLESWITCH    :", "case   Opcodes . LOOKUPSWITCH    :", "case   Opcodes . ATHROW    :", "case   Opcodes . MONITORENTER    :", "case   Opcodes . MONITOREXIT    :", "case   Opcodes . IFNULL    :", "case   Opcodes . IFNONNULL    :", "pop (  1  )  ;", "break ;", "case   Opcodes . POP 2     :", "case   Opcodes . IF _ ICMPEQ    :", "case   Opcodes . IF _ ICMPNE    :", "case   Opcodes . IF _ ICMPLT    :", "case   Opcodes . IF _ ICMPGE    :", "case   Opcodes . IF _ ICMPGT    :", "case   Opcodes . IF _ ICMPLE    :", "case   Opcodes . IF _ ACMPEQ    :", "case   Opcodes . IF _ ACMPNE    :", "case   Opcodes . LRETURN    :", "case   Opcodes . DRETURN    :", "pop (  2  )  ;", "break ;", "case   Opcodes . DUP    :", "t 1     =    pop (  )  ;", "push ( t 1  )  ;", "push ( t 1  )  ;", "break ;", "case   Opcodes . DUP _ X 1     :", "t 1     =    pop (  )  ;", "t 2     =    pop (  )  ;", "push ( t 1  )  ;", "push ( t 2  )  ;", "push ( t 1  )  ;", "break ;", "case   Opcodes . DUP _ X 2     :", "t 1     =    pop (  )  ;", "t 2     =    pop (  )  ;", "t 3     =    pop (  )  ;", "push ( t 1  )  ;", "push ( t 3  )  ;", "push ( t 2  )  ;", "push ( t 1  )  ;", "break ;", "case   Opcodes . DUP 2     :", "t 1     =    pop (  )  ;", "t 2     =    pop (  )  ;", "push ( t 2  )  ;", "push ( t 1  )  ;", "push ( t 2  )  ;", "push ( t 1  )  ;", "break ;", "case   Opcodes . DUP 2  _ X 1     :", "t 1     =    pop (  )  ;", "t 2     =    pop (  )  ;", "t 3     =    pop (  )  ;", "push ( t 2  )  ;", "push ( t 1  )  ;", "push ( t 3  )  ;", "push ( t 2  )  ;", "push ( t 1  )  ;", "break ;", "case   Opcodes . DUP 2  _ X 2     :", "t 1     =    pop (  )  ;", "t 2     =    pop (  )  ;", "t 3     =    pop (  )  ;", "t 4     =    pop (  )  ;", "push ( t 2  )  ;", "push ( t 1  )  ;", "push ( t 4  )  ;", "push ( t 3  )  ;", "push ( t 2  )  ;", "push ( t 1  )  ;", "break ;", "case   Opcodes . SWAP    :", "t 1     =    pop (  )  ;", "t 2     =    pop (  )  ;", "push ( t 1  )  ;", "push ( t 2  )  ;", "break ;", "case   Opcodes . IADD    :", "case   Opcodes . ISUB    :", "case   Opcodes . IMUL    :", "case   Opcodes . IDIV    :", "case   Opcodes . IREM    :", "case   Opcodes . IAND    :", "case   Opcodes . IOR    :", "case   Opcodes . IXOR    :", "case   Opcodes . ISHL    :", "case   Opcodes . ISHR    :", "case   Opcodes . IUSHR    :", "case   Opcodes . L 2 I    :", "case   Opcodes . D 2 I    :", "case   Opcodes . FCMPL    :", "case   Opcodes . FCMPG    :", "pop (  2  )  ;", "push (  . INTEGER )  ;", "break ;", "case   Opcodes . LADD    :", "case   Opcodes . LSUB    :", "case   Opcodes . LMUL    :", "case   Opcodes . LDIV    :", "case   Opcodes . LREM    :", "case   Opcodes . LAND    :", "case   Opcodes . LOR    :", "case   Opcodes . LXOR    :", "pop (  4  )  ;", "push (  . LONG )  ;", "push (  . TOP )  ;", "break ;", "case   Opcodes . FADD    :", "case   Opcodes . FSUB    :", "case   Opcodes . FMUL    :", "case   Opcodes . FDIV    :", "case   Opcodes . FREM    :", "case   Opcodes . L 2 F    :", "case   Opcodes . D 2 F    :", "pop (  2  )  ;", "push (  . FLOAT )  ;", "break ;", "case   Opcodes . DADD    :", "case   Opcodes . DSUB    :", "case   Opcodes . DMUL    :", "case   Opcodes . DDIV    :", "case   Opcodes . DREM    :", "pop (  4  )  ;", "push (  . DOUBLE )  ;", "push (  . TOP )  ;", "break ;", "case   Opcodes . LSHL    :", "case   Opcodes . LSHR    :", "case   Opcodes . LUSHR    :", "pop (  3  )  ;", "push (  . LONG )  ;", "push (  . TOP )  ;", "break ;", "case   Opcodes . IINC    :", "set ( arg ,     . INTEGER )  ;", "break ;", "case   Opcodes . I 2 L    :", "case   Opcodes . F 2 L    :", "pop (  1  )  ;", "push (  . LONG )  ;", "push (  . TOP )  ;", "break ;", "case   Opcodes . I 2 F    :", "pop (  1  )  ;", "push (  . FLOAT )  ;", "break ;", "case   Opcodes . I 2 D    :", "case   Opcodes . F 2 D    :", "pop (  1  )  ;", "push (  . DOUBLE )  ;", "push (  . TOP )  ;", "break ;", "case   Opcodes . F 2 I    :", "case   Opcodes . ARRAYLENGTH    :", "case   Opcodes . INSTANCEOF    :", "pop (  1  )  ;", "push (  . INTEGER )  ;", "break ;", "case   Opcodes . LCMP    :", "case   Opcodes . DCMPL    :", "case   Opcodes . DCMPG    :", "pop (  4  )  ;", "push (  . INTEGER )  ;", "break ;", "case   Opcodes . JSR    :", "case   Opcodes . RET    :", "throw   new   RuntimeException (  \" JSR / RET   are   not   supported   with   computes   option \"  )  ;", "case   Opcodes . GETSTATIC    :", "push ( cw ,    item . strVal 3  )  ;", "break ;", "case   Opcodes . PUTSTATIC    :", "pop ( item . strVal 3  )  ;", "break ;", "case   Opcodes . GETFIELD    :", "pop (  1  )  ;", "push ( cw ,    item . strVal 3  )  ;", "break ;", "case   Opcodes . PUTFIELD    :", "pop ( item . strVal 3  )  ;", "pop (  )  ;", "break ;", "case   Opcodes . INVOKEVIRTUAL    :", "case   Opcodes . INVOKESPECIAL    :", "case   Opcodes . INVOKESTATIC    :", "case   Opcodes . INVOKEINTERFACE    :", "pop ( item . strVal 3  )  ;", "if    ( opcode    !  =     ( Opcodes . INVOKESTATIC )  )     {", "t 1     =    pop (  )  ;", "if    (  ( opcode    =  =     ( Opcodes . INVOKESPECIAL )  )     &  &     (  ( item . strVal 2  . charAt (  0  )  )     =  =     '  <  '  )  )     {", "init ( t 1  )  ;", "}", "}", "push ( cw ,    item . strVal 3  )  ;", "break ;", "case   Opcodes . INVOKEDYNAMIC    :", "pop ( item . strVal 2  )  ;", "push ( cw ,    item . strVal 2  )  ;", "break ;", "case   Opcodes . NEW    :", "push (  (  (  . UNINITIALIZED )     |     ( cw . addUninitializedType ( item . strVal 1  ,    arg )  )  )  )  ;", "break ;", "case   Opcodes . NEWARRAY    :", "pop (  )  ;", "switch    ( arg )     {", "case   Opcodes . T _ BOOLEAN    :", "push (  (  (  . ARRAY _ OF )     |     (  . BOOLEAN )  )  )  ;", "break ;", "case   Opcodes . T _ CHAR    :", "push (  (  (  . ARRAY _ OF )     |     (  . CHAR )  )  )  ;", "break ;", "case   Opcodes . T _ BYTE    :", "push (  (  (  . ARRAY _ OF )     |     (  . BYTE )  )  )  ;", "break ;", "case   Opcodes . T _ SHORT    :", "push (  (  (  . ARRAY _ OF )     |     (  . SHORT )  )  )  ;", "break ;", "case   Opcodes . T _ INT    :", "push (  (  (  . ARRAY _ OF )     |     (  . INTEGER )  )  )  ;", "break ;", "case   Opcodes . T _ FLOAT    :", "push (  (  (  . ARRAY _ OF )     |     (  . FLOAT )  )  )  ;", "break ;", "case   Opcodes . T _ DOUBLE    :", "push (  (  (  . ARRAY _ OF )     |     (  . DOUBLE )  )  )  ;", "break ;", "default    :", "push (  (  (  . ARRAY _ OF )     |     (  . LONG )  )  )  ;", "break ;", "}", "break ;", "case   Opcodes . ANEWARRAY    :", "String   s    =    item . strVal 1  ;", "pop (  )  ;", "if    (  ( s . charAt (  0  )  )     =  =     '  [  '  )     {", "push ( cw ,     (  '  [  '     +    s )  )  ;", "} else    {", "push (  (  (  (  . ARRAY _ OF )     |     (  . OBJECT )  )     |     ( cw . addType ( s )  )  )  )  ;", "}", "break ;", "case   Opcodes . CHECKCAST    :", "s    =    item . strVal 1  ;", "pop (  )  ;", "if    (  ( s . charAt (  0  )  )     =  =     '  [  '  )     {", "push ( cw ,    s )  ;", "} else    {", "push (  (  (  . OBJECT )     |     ( cw . addType ( s )  )  )  )  ;", "}", "break ;", "default    :", "pop ( arg )  ;", "push ( cw ,    item . strVal 1  )  ;", "break ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( outputLocals )     =  =    null )     |  |     ( local    >  =     ( outputLocals . length )  )  )     {", "return    (  . LOCAL )     |    local ;", "} else    {", "int   type    =    outputLocals [ local ]  ;", "if    ( type    =  =     0  )     {", "type    =    outputLocals [ local ]     =     (  . LOCAL )     |    local ;", "}", "return   type ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "if    (  ( initializations )     =  =    null )     {", "initializations    =    new   int [  2  ]  ;", "}", "int   n    =    initializations . length ;", "if    (  ( initializationCount )     >  =    n )     {", "int [  ]    t    =    new   int [ Math . max (  (  ( initializationCount )     +     1  )  ,     (  2     *    n )  )  ]  ;", "System . arraycopy ( initializations ,     0  ,    t ,     0  ,    n )  ;", "initializations    =    t ;", "}", "initializations [  (  ( initializationCount )  +  +  )  ]     =    var ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "int   s ;", "if    ( t    =  =     (  . UNINITIALIZED _ THIS )  )     {", "s    =     (  . OBJECT )     |     ( cw . addType ( cw . thisName )  )  ;", "} else", "if    (  ( t    &     (  (  . DIM )     |     (  . BASE _ KIND )  )  )     =  =     (  . UNINITIALIZED )  )     {", "String   type    =    cw . typeTable [  ( t    &     (  . BASE _ VALUE )  )  ]  . strVal 1  ;", "s    =     (  . OBJECT )     |     ( cw . addType ( type )  )  ;", "} else    {", "return   t ;", "}", "for    ( int   j    =     0  ;    j    <     ( initializationCount )  ;     +  + j )     {", "int   u    =    initializations [ j ]  ;", "int   dim    =    u    &     (  . DIM )  ;", "int   kind    =    u    &     (  . KIND )  ;", "if    ( kind    =  =     (  . LOCAL )  )     {", "u    =    dim    +     ( inputLocals [  ( u    &     (  . VALUE )  )  ]  )  ;", "} else", "if    ( kind    =  =     (  . STACK )  )     {", "u    =    dim    +     ( inputStack [  (  ( inputStack . length )     -     ( u    &     (  . VALUE )  )  )  ]  )  ;", "}", "if    ( t    =  =    u )     {", "return   s ;", "}", "}", "return   t ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "inputLocals    =    new   int [ maxLocals ]  ;", "inputStack    =    new   int [  0  ]  ;", "int   i    =     0  ;", "if    (  ( access    &     ( Opcodes . ACC _ STATIC )  )     =  =     0  )     {", "if    (  ( access    &     ( MethodWriter . ACC _ CONSTRUCTOR )  )     =  =     0  )     {", "inputLocals [  ( i +  +  )  ]     =     (  . OBJECT )     |     ( cw . addType ( cw . thisName )  )  ;", "} else    {", "inputLocals [  ( i +  +  )  ]     =     . UNINITIALIZED _ THIS ;", "}", "}", "for    ( int   j    =     0  ;    j    <     ( args . length )  ;     +  + j )     {", "int   t    =     . type ( cw ,    args [ j ]  . getDescriptor (  )  )  ;", "inputLocals [  ( i +  +  )  ]     =    t ;", "if    (  ( t    =  =     (  . LONG )  )     |  |     ( t    =  =     (  . DOUBLE )  )  )     {", "inputLocals [  ( i +  +  )  ]     =     . TOP ;", "}", "}", "while    ( i    <    maxLocals )     {", "inputLocals [  ( i +  +  )  ]     =     . TOP ;", "}", "}", "METHOD_END"], "methodName": ["initInputFrame"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "int   u    =    types [ index ]  ;", "if    ( u    =  =    t )     {", "return   false ;", "}", "if    (  ( t    &     (  ~  (  . DIM )  )  )     =  =     (  . NULL )  )     {", "if    ( u    =  =     (  . NULL )  )     {", "return   false ;", "}", "t    =     . NULL ;", "}", "if    ( u    =  =     0  )     {", "types [ index ]     =    t ;", "return   true ;", "}", "int   v ;", "if    (  (  ( u    &     (  . BASE _ KIND )  )     =  =     (  . OBJECT )  )     |  |     (  ( u    &     (  . DIM )  )     !  =     0  )  )     {", "if    ( t    =  =     (  . NULL )  )     {", "return   false ;", "} else", "if    (  ( t    &     (  (  . DIM )     |     (  . BASE _ KIND )  )  )     =  =     ( u    &     (  (  . DIM )     |     (  . BASE _ KIND )  )  )  )     {", "if    (  ( u    &     (  . BASE _ KIND )  )     =  =     (  . OBJECT )  )     {", "v    =     (  ( t    &     (  . DIM )  )     |     (  . OBJECT )  )     |     ( cw . getMergedType (  ( t    &     (  . BASE _ VALUE )  )  ,     ( u    &     (  . BASE _ VALUE )  )  )  )  ;", "} else    {", "int   vdim    =     (  . ELEMENT _ OF )     +     ( u    &     (  . DIM )  )  ;", "v    =     ( vdim    |     (  . OBJECT )  )     |     ( cw . addType (  \" java / lang / Object \"  )  )  ;", "}", "} else", "if    (  (  ( t    &     (  . BASE _ KIND )  )     =  =     (  . OBJECT )  )     |  |     (  ( t    &     (  . DIM )  )     !  =     0  )  )     {", "int   tdim    =     (  (  ( t    &     (  . DIM )  )     =  =     0  )     |  |     (  ( t    &     (  . BASE _ KIND )  )     =  =     (  . OBJECT )  )     ?     0     :     . ELEMENT _ OF )     +     ( t    &     (  . DIM )  )  ;", "int   udim    =     (  (  ( u    &     (  . DIM )  )     =  =     0  )     |  |     (  ( u    &     (  . BASE _ KIND )  )     =  =     (  . OBJECT )  )     ?     0     :     . ELEMENT _ OF )     +     ( u    &     (  . DIM )  )  ;", "v    =     (  ( Math . min ( tdim ,    udim )  )     |     (  . OBJECT )  )     |     ( cw . addType (  \" java / lang / Object \"  )  )  ;", "} else    {", "v    =     . TOP ;", "}", "} else", "if    ( u    =  =     (  . NULL )  )     {", "v    =     (  (  ( t    &     (  . BASE _ KIND )  )     =  =     (  . OBJECT )  )     |  |     (  ( t    &     (  . DIM )  )     !  =     0  )  )     ?    t    :     . TOP ;", "} else    {", "v    =     . TOP ;", "}", "if    ( u    !  =    v )     {", "types [ index ]     =    v ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "boolean   changed    =    false ;", "int   i ;", "int   s ;", "int   dim ;", "int   kind ;", "int   t ;", "int   nLocal    =    inputLocals . length ;", "int   nStack    =    inputStack . length ;", "if    (  (  . inputLocals )     =  =    null )     {", ". inputLocals    =    new   int [ nLocal ]  ;", "changed    =    true ;", "}", "for    ( i    =     0  ;    i    <    nLocal ;     +  + i )     {", "if    (  (  ( outputLocals )     !  =    null )     &  &     ( i    <     ( outputLocals . length )  )  )     {", "s    =    outputLocals [ i ]  ;", "if    ( s    =  =     0  )     {", "t    =    inputLocals [ i ]  ;", "} else    {", "dim    =    s    &     ( Frame . DIM )  ;", "kind    =    s    &     ( Frame . KIND )  ;", "if    ( kind    =  =     ( Frame . BASE )  )     {", "t    =    s ;", "} else    {", "if    ( kind    =  =     ( Frame . LOCAL )  )     {", "t    =    dim    +     ( inputLocals [  ( s    &     ( Frame . VALUE )  )  ]  )  ;", "} else    {", "t    =    dim    +     ( inputStack [  ( nStack    -     ( s    &     ( Frame . VALUE )  )  )  ]  )  ;", "}", "if    (  (  ( s    &     ( Frame . TOP _ IF _ LONG _ OR _ DOUBLE )  )     !  =     0  )     &  &     (  ( t    =  =     ( Frame . LONG )  )     |  |     ( t    =  =     ( Frame . DOUBLE )  )  )  )     {", "t    =    Frame . TOP ;", "}", "}", "}", "} else    {", "t    =    inputLocals [ i ]  ;", "}", "if    (  ( initializations )     !  =    null )     {", "t    =    init ( cw ,    t )  ;", "}", "changed    |  =    Frame . merge ( cw ,    t ,     . inputLocals ,    i )  ;", "}", "if    ( edge    >     0  )     {", "for    ( i    =     0  ;    i    <    nLocal ;     +  + i )     {", "t    =    inputLocals [ i ]  ;", "changed    |  =    Frame . merge ( cw ,    t ,     . inputLocals ,    i )  ;", "}", "if    (  (  . inputStack )     =  =    null )     {", ". inputStack    =    new   int [  1  ]  ;", "changed    =    true ;", "}", "changed    |  =    Frame . merge ( cw ,    edge ,     . inputStack ,     0  )  ;", "return   changed ;", "}", "int   nInputStack    =     ( inputStack . length )     +     ( owner . inputStackTop )  ;", "if    (  (  . inputStack )     =  =    null )     {", ". inputStack    =    new   int [ nInputStack    +     ( outputStackTop )  ]  ;", "changed    =    true ;", "}", "for    ( i    =     0  ;    i    <    nInputStack ;     +  + i )     {", "t    =    inputStack [ i ]  ;", "if    (  ( initializations )     !  =    null )     {", "t    =    init ( cw ,    t )  ;", "}", "changed    |  =    Frame . merge ( cw ,    t ,     . inputStack ,    i )  ;", "}", "for    ( i    =     0  ;    i    <     ( outputStackTop )  ;     +  + i )     {", "s    =    outputStack [ i ]  ;", "dim    =    s    &     ( Frame . DIM )  ;", "kind    =    s    &     ( Frame . KIND )  ;", "if    ( kind    =  =     ( Frame . BASE )  )     {", "t    =    s ;", "} else    {", "if    ( kind    =  =     ( Frame . LOCAL )  )     {", "t    =    dim    +     ( inputLocals [  ( s    &     ( Frame . VALUE )  )  ]  )  ;", "} else    {", "t    =    dim    +     ( inputStack [  ( nStack    -     ( s    &     ( Frame . VALUE )  )  )  ]  )  ;", "}", "if    (  (  ( s    &     ( Frame . TOP _ IF _ LONG _ OR _ DOUBLE )  )     !  =     0  )     &  &     (  ( t    =  =     ( Frame . LONG )  )     |  |     ( t    =  =     ( Frame . DOUBLE )  )  )  )     {", "t    =    Frame . TOP ;", "}", "}", "if    (  ( initializations )     !  =    null )     {", "t    =    init ( cw ,    t )  ;", "}", "changed    |  =    Frame . merge ( cw ,    t ,     . inputStack ,     ( nInputStack    +    i )  )  ;", "}", "return   changed ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "if    (  ( outputStackTop )     >     0  )     {", "return   outputStack [  (  -  -  ( outputStackTop )  )  ]  ;", "} else    {", "return    (  . STACK )     |     (  -  (  -  -  ( owner . inputStackTop )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "if    (  ( outputStackTop )     >  =    elements )     {", "outputStackTop    -  =    elements ;", "} else    {", "owner . inputStackTop    -  =    elements    -     ( outputStackTop )  ;", "outputStackTop    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "char   c    =    desc . charAt (  0  )  ;", "if    ( c    =  =     '  (  '  )     {", "pop (  (  (  ( Type . getAumentsAndReturnSizes ( desc )  )     >  >     2  )     -     1  )  )  ;", "} else", "if    (  ( c    =  =     ' J '  )     |  |     ( c    =  =     ' D '  )  )     {", "pop (  2  )  ;", "} else    {", "pop (  1  )  ;", "}", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "if    (  ( outputStack )     =  =    null )     {", "outputStack    =    new   t [  1  0  ]  ;", "}", "t   n    =    outputStack . length ;", "if    (  ( outputStackTop )     >  =    n )     {", "t [  ]    t    =    new   t [ Math . max (  (  ( outputStackTop )     +     1  )  ,     (  2     *    n )  )  ]  ;", "System . arraycopy ( outputStack ,     0  ,    t ,     0  ,    n )  ;", "outputStack    =    t ;", "}", "outputStack [  (  ( outputStackTop )  +  +  )  ]     =    type ;", "t   top    =     ( owner . putStackTop )     +     ( outputStackTop )  ;", "if    ( top    >     ( owner . outputStackMax )  )     {", "owner . outputStackMax    =    top ;", "}", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "int   type    =    Frame . type ( cw ,    desc )  ;", "if    ( type    !  =     0  )     {", "push ( type )  ;", "if    (  ( type    =  =     ( Frame . LONG )  )     |  |     ( type    =  =     ( Frame . DOUBLE )  )  )     {", "push ( Frame . TOP )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "if    (  ( outputLocals )     =  =    null )     {", "outputLocals    =    new   t [  1  0  ]  ;", "}", "t   n    =    outputLocals . length ;", "if    ( local    >  =    n )     {", "t [  ]    t    =    new   t [ Math . max (  ( local    +     1  )  ,     (  2     *    n )  )  ]  ;", "System . arraycopy ( outputLocals ,     0  ,    t ,     0  ,    n )  ;", "outputLocals    =    t ;", "}", "outputLocals [ local ]     =    type ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "int   i    =    Frame . convert ( cw ,    nLocal ,    local ,    inputLocals )  ;", "while    ( i    <     ( local . length )  )     {", "inputLocals [  ( i +  +  )  ]     =    Frame . TOP ;", "}", "int   nStackTop    =     0  ;", "for    ( int   j    =     0  ;    j    <    nStack ;     +  + j )     {", "if    (  (  ( stack [ j ]  )     =  =     ( Opcodes . LONG )  )     |  |     (  ( stack [ j ]  )     =  =     ( Opcodes . DOUBLE )  )  )     {", "+  + nStackTop ;", "}", "}", "inputStack    =    new   int [ nStack    +    nStackTop ]  ;", "Frame . convert ( cw ,    nStack ,    stack ,    inputStack )  ;", "outputStackTop    =     0  ;", "initializationCount    =     0  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "inputLocals    =    f . inputLocals ;", "inputStack    =    f . inputStack ;", "outputLocals    =    f . outputLocals ;", "outputStack    =    f . outputStack ;", "outputStackTop    =    f . outputStackTop ;", "initializationCount    =    f . initializationCount ;", "initializations    =    f . initializations ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "String   t ;", "int   index    =     (  ( desc . charAt (  0  )  )     =  =     '  (  '  )     ?     ( desc . indexOf (  '  )  '  )  )     +     1     :     0  ;", "switch    ( desc . charAt ( index )  )     {", "case    ' V '     :", "return    0  ;", "case    ' Z '     :", "case    ' C '     :", "case    ' B '     :", "case    ' S '     :", "case    ' I '     :", "return    . INTEGER ;", "case    ' F '     :", "return    . FLOAT ;", "case    ' J '     :", "return    . LONG ;", "case    ' D '     :", "return    . DOUBLE ;", "case    ' L '     :", "t    =    desc . substring (  ( index    +     1  )  ,     (  ( desc . length (  )  )     -     1  )  )  ;", "return    (  . OBJECT )     |     ( cw . addType ( t )  )  ;", "default    :", "int   data ;", "int   dims    =    index    +     1  ;", "while    (  ( desc . charAt ( dims )  )     =  =     '  [  '  )     {", "+  + dims ;", "}", "switch    ( desc . charAt ( dims )  )     {", "case    ' Z '     :", "data    =     . BOOLEAN ;", "break ;", "case    ' C '     :", "data    =     . CHAR ;", "break ;", "case    ' B '     :", "data    =     . BYTE ;", "break ;", "case    ' S '     :", "data    =     . SHORT ;", "break ;", "case    ' I '     :", "data    =     . INTEGER ;", "break ;", "case    ' F '     :", "data    =     . FLOAT ;", "break ;", "case    ' J '     :", "data    =     . LONG ;", "break ;", "case    ' D '     :", "data    =     . DOUBLE ;", "break ;", "default    :", "t    =    desc . substring (  ( dims    +     1  )  ,     (  ( desc . length (  )  )     -     1  )  )  ;", "data    =     (  . OBJECT )     |     ( cw . addType ( t )  )  ;", "}", "return    (  ( dims    -    index )     <  <     2  8  )     |    data ;", "}", "}", "METHOD_END"], "methodName": ["type"], "fileName": "org.springframework.asm.Frame"}, {"methodBody": ["METHOD_START", "{", "return   desc ;", "}", "METHOD_END"], "methodName": ["getDesc"], "fileName": "org.springframework.asm.Handle"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.asm.Handle"}, {"methodBody": ["METHOD_START", "{", "return   owner ;", "}", "METHOD_END"], "methodName": ["getOwner"], "fileName": "org.springframework.asm.Handle"}, {"methodBody": ["METHOD_START", "{", "return   tag ;", "}", "METHOD_END"], "methodName": ["getTag"], "fileName": "org.springframework.asm.Handle"}, {"methodBody": ["METHOD_START", "{", "return   itf ;", "}", "METHOD_END"], "methodName": ["isInterface"], "fileName": "org.springframework.asm.Handle"}, {"methodBody": ["METHOD_START", "{", "if    ( h    =  =    null )     {", "return   null ;", "} else    {", "h . next    =     . remove ( h . next ,    start ,    end )  ;", "}", "int   hstart    =    h . start . position ;", "int   hend    =    h . end . position ;", "int   s    =    start . position ;", "int   e    =     ( end    =  =    null )     ?    Integer . MAX _ VALUE    :    end . position ;", "if    (  ( s    <    hend )     &  &     ( e    >    hstart )  )     {", "if    ( s    <  =    hstart )     {", "if    ( e    >  =    hend )     {", "h    =    h . next ;", "} else    {", "h . start    =    end ;", "}", "} else", "if    ( e    >  =    hend )     {", "h . end    =    start ;", "} else    {", "g    =    new    (  )  ;", "g . start    =    end ;", "g . end    =    h . end ;", "g . handler    =    h . handler ;", "g . desc    =    h . desc ;", "g . type    =    h . type ;", "g . next    =    h . next ;", "h . end    =    start ;", "h . next    =    g ;", "}", "}", "return   h ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.springframework.asm.Handler"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   ClassWter . UTF 8     :", "case   ClassWter . STR    :", "case   ClassWter . CLASS    :", "case   ClassWter . MODULE    :", "case   ClassWter . PACKAGE    :", "case   ClassWter . MTYPE    :", "case   ClassWter . TYPE _ NORMAL    :", "return   i . strVal 1  . equals ( strVal 1  )  ;", "case   ClassWter . TYPE _ MERGED    :", "case   ClassWter . LONG    :", "case   ClassWter . DOUBLE    :", "return    ( i . longVal )     =  =     ( longVal )  ;", "case   ClassWter . INT    :", "case   ClassWter . FLOAT    :", "return    ( i . intVal )     =  =     ( intVal )  ;", "case   ClassWter . TYPE _ UNINIT    :", "return    (  ( i . intVal )     =  =     ( intVal )  )     &  &     ( i . strVal 1  . equals ( strVal 1  )  )  ;", "case   ClassWter . NAME _ TYPE    :", "return    ( i . strVal 1  . equals ( strVal 1  )  )     &  &     ( i . strVal 2  . equals ( strVal 2  )  )  ;", "case   ClassWter . INDY    :", "{", "return    (  (  ( i . longVal )     =  =     ( longVal )  )     &  &     ( i . strVal 1  . equals ( strVal 1  )  )  )     &  &     ( i . strVal 2  . equals ( strVal 2  )  )  ;", "}", "default    :", "return    (  ( i . strVal 1  . equals ( strVal 1  )  )     &  &     ( i . strVal 2  . equals ( strVal 2  )  )  )     &  &     ( i . strVal 3  . equals ( strVal 3  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isEqualTo"], "fileName": "org.springframework.asm.Item"}, {"methodBody": ["METHOD_START", "{", "this . type    =    ClassWriter . DOUBLE ;", "this . longVal    =    Double . doubleToRawLongBits ( doubleVal )  ;", "this . hashCode    =     2  1  4  7  4  8  3  6  4  7     &     (  ( type )     +     (  ( int )     ( doubleVal )  )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Item"}, {"methodBody": ["METHOD_START", "{", "this . type    =    ClassWriter . FLOAT ;", "this . intVal    =    Float . floatToRawIntBits ( floatVal )  ;", "this . hashCode    =     2  1  4  7  4  8  3  6  4  7     &     (  ( type )     +     (  ( int )     ( floatVal )  )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Item"}, {"methodBody": ["METHOD_START", "{", "this . type    =    ClassWriter . INT ;", "this . intVal    =    intVal ;", "this . hashCode    =     2  1  4  7  4  8  3  6  4  7     &     (  ( type )     +    intVal )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Item"}, {"methodBody": ["METHOD_START", "{", "this . type    =    ClassWriter . BSM ;", "this . intVal    =    position ;", "this . hashCode    =    hashCode ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Item"}, {"methodBody": ["METHOD_START", "{", "th . type    =    type ;", "thtrVal 1     = trVal 1  ;", "thtrVal 2     = trVal 2  ;", "thtrVal 3     = trVal 3  ;", "witch    ( type )     {", "ce   ClsWriter . CLASS    :", "th . intVal    =     0  ;", "ce   ClsWriter . UTF 8     :", "ce   ClsWriter . STR    :", "ce   ClsWriter . MTYPE    :", "ce   ClsWriter . MODULE    :", "ce   ClsWriter . PACKAGE    :", "ce   ClsWriter . TYPE _ NORMAL    :", "hhCode    =     2  1  4  7  4  8  3  6  4  7     &     ( type    +    trVal 1  . hhCode (  )  )  )  ;", "return ;", "ce   ClsWriter . NAME _ TYPE    :", "{", "hhCode    =     2  1  4  7  4  8  3  6  4  7     &     ( type    +     ( trVal 1  . hhCode (  )  )     *    trVal 2  . hhCode (  )  )  )  )  ;", "return ;", "}", "default    :", "hhCode    =     2  1  4  7  4  8  3  6  4  7     &     ( type    +     (  ( trVal 1  . hhCode (  )  )     *    trVal 2  . hhCode (  )  )  )     *    trVal 3  . hhCode (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Item"}, {"methodBody": ["METHOD_START", "{", "this . type    =    ClassWriter . INDY ;", "this . longVal    =    bsmIndex ;", "this . strVal 1     =    n ;", "this . strVal 2     =    desc ;", "this . hashCode    =     2  1  4  7  4  8  3  6  4  7     &     (  ( ClassWriter . INDY )     +     (  ( bsmIndex    *     ( strVal 1  . hashCode (  )  )  )     *     ( strVal 2  . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Item"}, {"methodBody": ["METHOD_START", "{", "this . type    =    ClassWriter . LONG ;", "this . longVal    =    longVal ;", "this . hashCode    =     2  1  4  7  4  8  3  6  4  7     &     (  ( type )     +     (  ( int )     ( longVal )  )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.asm.Item"}, {"methodBody": ["METHOD_START", "{", "if    (  ( srcAndRefPositions )     =  =    null )     {", "srcAndRefPositions    =    new   t [  6  ]  ;", "}", "if    (  ( referenceCount )     >  =     ( srcAndRefPositions . length )  )     {", "t [  ]    a    =    new   t [  ( srcAndRefPositions . length )     +     6  ]  ;", "System . arraycopy ( srcAndRefPositions ,     0  ,    a ,     0  ,    srcAndRefPositions . length )  ;", "srcAndRefPositions    =    a ;", "}", "srcAndRefPositions [  (  ( referenceCount )  +  +  )  ]     =    sourcePosition ;", "srcAndRefPositions [  (  ( referenceCount )  +  +  )  ]     =    referencePosition ;", "}", "METHOD_END"], "methodName": ["addReference"], "fileName": "org.springframework.asm.Label"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( status )     &     ( Label . VISITED )  )     =  =     0  )     {", "status    |  =    Label . VISITED ;", "srcAndRefPositions    =    new   int [  ( nbSubroutines    /     3  2  )     +     1  ]  ;", "}", "srcAndRefPositions [  (  ( int )     ( id    >  >  >     3  2  )  )  ]     |  =     (  ( int )     ( id )  )  ;", "}", "METHOD_END"], "methodName": ["addToSubroutine"], "fileName": "org.springframework.asm.Label"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( ClassReader . FRAMES )  )     |  |     (  ( frame )     =  =    null )     ?    this    :    frame . owner ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "org.springframework.asm.Label"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( status )     &     ( Label . RESOLVED )  )     =  =     0  )     {", "throw   new   IllegalStateException (  \" Label   offset   position   has   not   been   resolved   yet \"  )  ;", "}", "return   position ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "org.springframework.asm.Label"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( status )     &     ( Label . VISITED )  )     =  =     0  )     |  |     (  (  ( block . status )     &     ( Label . VISITED )  )     =  =     0  )  )     {", "return   false ;", "}", "for    ( int   i    =     0  ;    i    <     ( srcAndRefPositions . length )  ;     +  + i )     {", "if    (  (  ( srcAndRefPositions [ i ]  )     &     ( block . srcAndRefPositions [ i ]  )  )     !  =     0  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["inSameSubroutine"], "fileName": "org.springframework.asm.Label"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( status )     &     ( Label . VISITED )  )     !  =     0  )     {", "return    (  ( srcAndRefPositions [  (  ( int )     ( id    >  >  >     3  2  )  )  ]  )     &     (  ( int )     ( id )  )  )     !  =     0  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["inSubroutine"], "fileName": "org.springframework.asm.Label"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( status )     &     ( Label . RESOLVED )  )     =  =     0  )     {", "if    ( wideOffset )     {", "addReference (  (  (  -  1  )     -    source )  ,    out . length )  ;", "out . putInt (  (  -  1  )  )  ;", "} else    {", "addReference ( source ,    out . length )  ;", "out . putShort (  (  -  1  )  )  ;", "}", "} else    {", "if    ( wideOffset )     {", "out . putInt (  (  ( position )     -    source )  )  ;", "} else    {", "out . putShort (  (  ( position )     -    source )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.asm.Label"}, {"methodBody": ["METHOD_START", "{", "boolean   needUpdate    =    false ;", "this . status    |  =     . RESOLVED ;", "this . position    =    position ;", "int   i    =     0  ;", "while    ( i    <     ( referenceCount )  )     {", "int   source    =    srcAndRefPositions [  ( i +  +  )  ]  ;", "int   reference    =    srcAndRefPositions [  ( i +  +  )  ]  ;", "int   offset ;", "if    ( source    >  =     0  )     {", "offset    =    position    -    source ;", "if    (  ( offset    <     ( Short . MIN _ VALUE )  )     |  |     ( offset    >     ( Short . MAX _ VALUE )  )  )     {", "int   opcode    =     ( data [  ( reference    -     1  )  ]  )     &     2  5  5  ;", "if    ( opcode    <  =     ( Opcodes . JSR )  )     {", "data [  ( reference    -     1  )  ]     =     (  ( byte )     ( opcode    +     4  9  )  )  ;", "} else    {", "data [  ( reference    -     1  )  ]     =     (  ( byte )     ( opcode    +     2  0  )  )  ;", "}", "needUpdate    =    true ;", "}", "data [  ( reference +  +  )  ]     =     (  ( byte )     ( offset    >  >  >     8  )  )  ;", "data [ reference ]     =     (  ( byte )     ( offset )  )  ;", "} else    {", "offset    =     ( position    +    source )     +     1  ;", "data [  ( reference +  +  )  ]     =     (  ( byte )     ( offset    >  >  >     2  4  )  )  ;", "data [  ( reference +  +  )  ]     =     (  ( byte )     ( offset    >  >  >     1  6  )  )  ;", "data [  ( reference +  +  )  ]     =     (  ( byte )     ( offset    >  >  >     8  )  )  ;", "data [ reference ]     =     (  ( byte )     ( offset )  )  ;", "}", "}", "return   needUpdate ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.asm.Label"}, {"methodBody": ["METHOD_START", "{", "Label   stack    =    this ;", "while    ( stack    !  =    null )     {", "Label   l    =    stack ;", "stack    =    l . next ;", "l . next    =    null ;", "if    ( JSR    !  =    null )     {", "if    (  (  ( l . status )     &     ( Label . VISITED 2  )  )     !  =     0  )     {", "continue ;", "}", "l . status    |  =    Label . VISITED 2  ;", "if    (  (  ( l . status )     &     ( Label . RET )  )     !  =     0  )     {", "if    (  !  ( l . inSameSubroutine ( JSR )  )  )     {", "Edge   e    =    new   Edge (  )  ;", "e . info    =    l . inputStackTop ;", "e . successor    =    JSR . successors . successor ;", "e . next    =    l . successors ;", "l . successors    =    e ;", "}", "}", "} else    {", "if    ( l . inSubroutine ( id )  )     {", "continue ;", "}", "l . addToSubroutine ( id ,    nbSubroutines )  ;", "}", "Edge   e    =    l . successors ;", "while    ( e    !  =    null )     {", "if    (  (  (  ( l . status )     &     ( Label . JSR )  )     =  =     0  )     |  |     ( e    !  =     ( l . successors . next )  )  )     {", "if    (  ( e . successor . next )     =  =    null )     {", "e . successor . next    =    stack ;", "stack    =    e . successor ;", "}", "}", "e    =    e . next ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitSubroutine"], "fileName": "org.springframework.asm.Label"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "return   mv . vAnnotation ( desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitAnnotation"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "return   mv . vAnnotationDefault (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitAnnotationDefault"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vAttribute ( attr )  ;", "}", "}", "METHOD_END"], "methodName": ["visitAttribute"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vCode (  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitCode"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vEnd (  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitEnd"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vFieldInsn ( opcode ,    owner ,    name ,    desc )  ;", "}", "}", "METHOD_END"], "methodName": ["visitFieldInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . visitF ( type ,    nLocal ,    local ,    nStack ,    stack )  ;", "}", "}", "METHOD_END"], "methodName": ["visitFrame"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vIincInsn ( var ,    increment )  ;", "}", "}", "METHOD_END"], "methodName": ["visitIincInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vInsn ( opcode )  ;", "}", "}", "METHOD_END"], "methodName": ["visitInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "return   mv . vInsnAnnotation ( typeRef ,    typePath ,    desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitInsnAnnotation"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vIntInsn ( opcode ,    operand )  ;", "}", "}", "METHOD_END"], "methodName": ["visitIntInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vInvokeDynamicInsn ( name ,    desc ,    bsm ,    bsmArgs )  ;", "}", "}", "METHOD_END"], "methodName": ["visitInvokeDynamicInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vJumpInsn ( opcode ,    label )  ;", "}", "}", "METHOD_END"], "methodName": ["visitJumpInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vLabel ( label )  ;", "}", "}", "METHOD_END"], "methodName": ["visitLabel"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vLdcInsn ( cst )  ;", "}", "}", "METHOD_END"], "methodName": ["visitLdcInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vLineNumber ( line ,    start )  ;", "}", "}", "METHOD_END"], "methodName": ["visitLineNumber"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vLocalVariable ( name ,    desc ,    signature ,    start ,    end ,    index )  ;", "}", "}", "METHOD_END"], "methodName": ["visitLocalVariable"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "return   mv . vLocalVariableAnnotation ( typeRef ,    typePath ,    start ,    end ,    index ,    desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitLocalVariableAnnotation"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vLookupSwitchInsn ( dflt ,    keys ,    labels )  ;", "}", "}", "METHOD_END"], "methodName": ["visitLookupSwitchInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vMaxs ( maxStack ,    maxLocals )  ;", "}", "}", "METHOD_END"], "methodName": ["visitMaxs"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( api )     >  =     ( Opcodes . ASM 5  )  )     {", "boolean   itf    =    opcode    =  =     ( Opcodes . INVOKEINTERFACE )  ;", "visitInsn ( opcode ,    owner ,    name ,    desc ,    itf )  ;", "return ;", "}", "if    (  ( mv )     !  =    null )     {", "mv . visitInsn ( opcode ,    owner ,    name ,    desc )  ;", "}", "}", "METHOD_END"], "methodName": ["visitMethodInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( api )     <     ( Opcodes . ASM 5  )  )     {", "if    ( itf    !  =     ( opcode    =  =     ( Opcodes . INVOKEINTERFACE )  )  )     {", "throw   new   IllegalArgumentException (  \" INVOKESPECIAL / STATIC   on   interfaces   require   ASM    5  \"  )  ;", "}", "visitInsn ( opcode ,    owner ,    name ,    desc )  ;", "return ;", "}", "if    (  ( mv )     !  =    null )     {", "mv . visitInsn ( opcode ,    owner ,    name ,    desc ,    itf )  ;", "}", "}", "METHOD_END"], "methodName": ["visitMethodInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vMultiANewArrayInsn ( desc ,    dims )  ;", "}", "}", "METHOD_END"], "methodName": ["visitMultiANewArrayInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . visitPater ( name ,    access )  ;", "}", "}", "METHOD_END"], "methodName": ["visitParameter"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "return   mv . visitPaterAnnotation ( pater ,    desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitParameterAnnotation"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vTableSwitchInsn ( min ,    max ,    dflt ,    labels )  ;", "}", "}", "METHOD_END"], "methodName": ["visitTableSwitchInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "return   mv . vTryCatchAnnotation ( typeRef ,    typePath ,    desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitTryCatchAnnotation"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vTryCatchBlock ( start ,    end ,    handler ,    type )  ;", "}", "}", "METHOD_END"], "methodName": ["visitTryCatchBlock"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "return   mv . vTypeAnnotation ( typeRef ,    typePath ,    desc ,    visible )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["visitTypeAnnotation"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vTypeInsn ( opcode ,    type )  ;", "}", "}", "METHOD_END"], "methodName": ["visitTypeInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vVarInsn ( opcode ,    var )  ;", "}", "}", "METHOD_END"], "methodName": ["visitVarInsn"], "fileName": "org.springframework.asm.MethodVisitor"}, {"methodBody": ["METHOD_START", "{", "Edge   b    =    new   Edge (  )  ;", "b . info    =    info ;", "b . successor    =    successor ;", "b . next    =    currentBlock . successors ;", "currentBlock . successors    =    b ;", "}", "METHOD_END"], "methodName": ["addSuccessor"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( previousFrame )     !  =    null )     {", "if    (  ( stackMap )     =  =    null )     {", "stackMap    =    new   ByteVector (  )  ;", "}", "writeFrame (  )  ;", "+  +  ( Count )  ;", "}", "previousFrame    =     ;", "=    null ;", "}", "METHOD_END"], "methodName": ["endFrame"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( classReaderOffset )     !  =     0  )     {", "return    6     +     ( classReaderLength )  ;", "}", "int   size    =     8  ;", "if    (  ( code . length )     >     0  )     {", "if    (  ( code . length )     >     6  5  5  3  5  )     {", "throw   new   RuntimeException (  \"    code   too   large !  \"  )  ;", "}", "cw . newUTF 8  (  \" Code \"  )  ;", "size    +  =     (  1  8     +     ( code . length )  )     +     (  8     *     ( handlerCount )  )  ;", "if    (  ( localVar )     !  =    null )     {", "cw . newUTF 8  (  \" LocalVariableTable \"  )  ;", "size    +  =     8     +     ( localVar . length )  ;", "}", "if    (  ( localVarType )     !  =    null )     {", "cw . newUTF 8  (  \" LocalVariableTypeTable \"  )  ;", "size    +  =     8     +     ( localVarType . length )  ;", "}", "if    (  ( lineNumber )     !  =    null )     {", "cw . newUTF 8  (  \" LineNumberTable \"  )  ;", "size    +  =     8     +     ( lineNumber . length )  ;", "}", "if    (  ( stackMap )     !  =    null )     {", "boolean   zip    =     (  ( cw . version )     &     6  5  5  3  5  )     >  =     ( Opcodes . V 1  _  6  )  ;", "cw . newUTF 8  (  ( zip    ?     \" StackMapTable \"     :     \" StackMap \"  )  )  ;", "size    +  =     8     +     ( stackMap . length )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ctanns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeVisibleTypeAnnotations \"  )  ;", "size    +  =     8     +     ( ctanns . getSize (  )  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ictanns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeInvisibleTypeAnnotations \"  )  ;", "size    +  =     8     +     ( ictanns . getSize (  )  )  ;", "}", "if    (  ( cattrs )     !  =    null )     {", "size    +  =    cattrs . getSize ( cw ,    code . data ,    code . length ,    maxStack ,    maxLocals )  ;", "}", "}", "if    (  ( exceptionCount )     >     0  )     {", "cw . newUTF 8  (  \" Exceptions \"  )  ;", "size    +  =     8     +     (  2     *     ( exceptionCount )  )  ;", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ SYNTHETIC )  )     !  =     0  )     {", "if    (  (  (  ( cw . version )     &     6  5  5  3  5  )     <     ( Opcodes . V 1  _  5  )  )     |  |     (  (  ( access )     &     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  )     !  =     0  )  )     {", "cw . newUTF 8  (  \" Synthetic \"  )  ;", "size    +  =     6  ;", "}", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ DEPRECATED )  )     !  =     0  )     {", "cw . newUTF 8  (  \" Deprecated \"  )  ;", "size    +  =     6  ;", "}", "if    (  ( ClassReader . SIGNATURES )     &  &     (  ( signature )     !  =    null )  )     {", "cw . newUTF 8  (  \" Signature \"  )  ;", "cw . newUTF 8  ( signature )  ;", "size    +  =     8  ;", "}", "if    (  ( methodParameters )     !  =    null )     {", "cw . newUTF 8  (  \" Parameters \"  )  ;", "size    +  =     7     +     ( methodParameters . length )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( annd )     !  =    null )  )     {", "cw . newUTF 8  (  \" AnnotationDefault \"  )  ;", "size    +  =     6     +     ( annd . length )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( anns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeVisibleAnnotations \"  )  ;", "size    +  =     8     +     ( anns . getSize (  )  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ianns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeInvisibleAnnotations \"  )  ;", "size    +  =     8     +     ( ianns . getSize (  )  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( tanns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeVisibleTypeAnnotations \"  )  ;", "size    +  =     8     +     ( tanns . getSize (  )  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( itanns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeInvisibleTypeAnnotations \"  )  ;", "size    +  =     8     +     ( itanns . getSize (  )  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( panns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeVisibleParameterAnnotations \"  )  ;", "size    +  =     7     +     (  2     *     (  ( panns . length )     -     ( synthetics )  )  )  ;", "for    ( int   i    =     ( panns . length )     -     1  ;    i    >  =     ( synthetics )  ;     -  - i )     {", "size    +  =     (  ( panns [ i ]  )     =  =    null )     ?     0     :    panns [ i ]  . getSize (  )  ;", "}", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ipanns )     !  =    null )  )     {", "cw . newUTF 8  (  \" RuntimeInvisibleParameterAnnotations \"  )  ;", "size    +  =     7     +     (  2     *     (  ( ipanns . length )     -     ( synthetics )  )  )  ;", "for    ( int   i    =     ( ipanns . length )     -     1  ;    i    >  =     ( synthetics )  ;     -  - i )     {", "size    +  =     (  ( ipanns [ i ]  )     =  =    null )     ?     0     :    ipanns [ i ]  . getSize (  )  ;", "}", "}", "if    (  ( attrs )     !  =    null )     {", "size    +  =    attrs . getSize ( cw ,    null ,     0  ,     (  -  1  )  ,     (  -  1  )  )  ;", "}", "return   size ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( compute )     =  =     ( MethodWriter . FRAMES )  )     {", "Label   l    =    new   Label (  )  ;", "l . frame    =    new   Frame (  )  ;", "l . frame . owner    =    l ;", "l . resolve ( this ,    code . length ,    code . data )  ;", "previousBlock . successor    =    l ;", "previousBlock    =    l ;", "} else    {", "currentBlock . outputStackMax    =    maxStackSize ;", "}", "if    (  ( compute )     !  =     ( MethodWriter . INSERTED _ FRAMES )  )     {", "currentBlock    =    null ;", "}", "}", "METHOD_END"], "methodName": ["noSuccessor"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "final   int   FACTOR    =    ClassWriter . TO _ ACC _ SYNTHETIC ;", "int   mask    =     (  (  (  . ACC _ CONSTRUCTOR )     |     ( Opcodes . ACC _ DEPRECATED )  )     |     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  )     |     (  (  ( access )     &     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  )     /    FACTOR )  ;", "out . putShort (  (  ( access )     &     (  ~ mask )  )  )  . putShort ( name )  . putShort ( desc )  ;", "if    (  ( classReaderOffset )     !  =     0  )     {", "out . putByteArray ( cw . cr . b ,    classReaderOffset ,    classReaderLength )  ;", "return ;", "}", "int   attributeCount    =     0  ;", "if    (  ( code . length )     >     0  )     {", "+  + attributeCount ;", "}", "if    (  ( exceptionCount )     >     0  )     {", "+  + attributeCount ;", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ SYNTHETIC )  )     !  =     0  )     {", "if    (  (  (  ( cw . version )     &     6  5  5  3  5  )     <     ( Opcodes . V 1  _  5  )  )     |  |     (  (  ( access )     &     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  )     !  =     0  )  )     {", "+  + attributeCount ;", "}", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ DEPRECATED )  )     !  =     0  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . SIGNATURES )     &  &     (  ( signature )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( methodParameters )     !  =    null )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( annd )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( anns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ianns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( tanns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( itanns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( panns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ipanns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( attrs )     !  =    null )     {", "attributeCount    +  =    attrs . getCount (  )  ;", "}", "out . putShort ( attributeCount )  ;", "if    (  ( code . length )     >     0  )     {", "int   size    =     (  1  2     +     ( code . length )  )     +     (  8     *     ( handlerCount )  )  ;", "if    (  ( localVar )     !  =    null )     {", "size    +  =     8     +     ( localVar . length )  ;", "}", "if    (  ( localVarType )     !  =    null )     {", "size    +  =     8     +     ( localVarType . length )  ;", "}", "if    (  ( lineNumber )     !  =    null )     {", "size    +  =     8     +     ( lineNumber . length )  ;", "}", "if    (  ( stackMap )     !  =    null )     {", "size    +  =     8     +     ( stackMap . length )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ctanns )     !  =    null )  )     {", "size    +  =     8     +     ( ctanns . getSize (  )  )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ictanns )     !  =    null )  )     {", "size    +  =     8     +     ( ictanns . getSize (  )  )  ;", "}", "if    (  ( cattrs )     !  =    null )     {", "size    +  =    cattrs . getSize ( cw ,    code . data ,    code . length ,    maxStack ,    maxLocals )  ;", "}", "out . putShort ( cw . newUTF 8  (  \" Code \"  )  )  . putInt ( size )  ;", "out . putShort ( maxStack )  . putShort ( maxLocals )  ;", "out . putInt ( code . length )  . putByteArray ( code . data ,     0  ,    code . length )  ;", "out . putShort ( handlerCount )  ;", "if    (  ( handlerCount )     >     0  )     {", "Handler   h    =    firstHandler ;", "while    ( h    !  =    null )     {", "out . putShort ( h . start . position )  . putShort ( h . end . position )  . putShort ( h . handler . position )  . putShort ( h . type )  ;", "h    =    h . next ;", "}", "}", "attributeCount    =     0  ;", "if    (  ( localVar )     !  =    null )     {", "+  + attributeCount ;", "}", "if    (  ( localVarType )     !  =    null )     {", "+  + attributeCount ;", "}", "if    (  ( lineNumber )     !  =    null )     {", "+  + attributeCount ;", "}", "if    (  ( stackMap )     !  =    null )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ctanns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ictanns )     !  =    null )  )     {", "+  + attributeCount ;", "}", "if    (  ( cattrs )     !  =    null )     {", "attributeCount    +  =    cattrs . getCount (  )  ;", "}", "out . putShort ( attributeCount )  ;", "if    (  ( localVar )     !  =    null )     {", "out . putShort ( cw . newUTF 8  (  \" LocalVariableTable \"  )  )  ;", "out . putInt (  (  ( localVar . length )     +     2  )  )  . putShort ( localVarCount )  ;", "out . putByteArray ( localVar . data ,     0  ,    localVar . length )  ;", "}", "if    (  ( localVarType )     !  =    null )     {", "out . putShort ( cw . newUTF 8  (  \" LocalVariableTypeTable \"  )  )  ;", "out . putInt (  (  ( localVarType . length )     +     2  )  )  . putShort ( localVarTypeCount )  ;", "out . putByteArray ( localVarType . data ,     0  ,    localVarType . length )  ;", "}", "if    (  ( lineNumber )     !  =    null )     {", "out . putShort ( cw . newUTF 8  (  \" LineNumberTable \"  )  )  ;", "out . putInt (  (  ( lineNumber . length )     +     2  )  )  . putShort ( lineNumberCount )  ;", "out . putByteArray ( lineNumber . data ,     0  ,    lineNumber . length )  ;", "}", "if    (  ( stackMap )     !  =    null )     {", "boolean   zip    =     (  ( cw . version )     &     6  5  5  3  5  )     >  =     ( Opcodes . V 1  _  6  )  ;", "out . putShort ( cw . newUTF 8  (  ( zip    ?     \" StackMapTable \"     :     \" StackMap \"  )  )  )  ;", "out . putInt (  (  ( stackMap . length )     +     2  )  )  . putShort ( frameCount )  ;", "out . putByteArray ( stackMap . data ,     0  ,    stackMap . length )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ctanns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeVisibleTypeAnnotations \"  )  )  ;", "ctanns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ictanns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeInvisibleTypeAnnotations \"  )  )  ;", "ictanns . put ( out )  ;", "}", "if    (  ( cattrs )     !  =    null )     {", "cattrs . put ( cw ,    code . data ,    code . length ,    maxLocals ,    maxStack ,    out )  ;", "}", "}", "if    (  ( exceptionCount )     >     0  )     {", "out . putShort ( cw . newUTF 8  (  \" Exceptions \"  )  )  . putInt (  (  (  2     *     ( exceptionCount )  )     +     2  )  )  ;", "out . putShort ( exceptionCount )  ;", "for    ( int   i    =     0  ;    i    <     ( exceptionCount )  ;     +  + i )     {", "out . putShort ( exceptions [ i ]  )  ;", "}", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ SYNTHETIC )  )     !  =     0  )     {", "if    (  (  (  ( cw . version )     &     6  5  5  3  5  )     <     ( Opcodes . V 1  _  5  )  )     |  |     (  (  ( access )     &     ( ClassWriter . ACC _ SYNTHETIC _ ATTRIBUTE )  )     !  =     0  )  )     {", "out . putShort ( cw . newUTF 8  (  \" Synthetic \"  )  )  . putInt (  0  )  ;", "}", "}", "if    (  (  ( access )     &     ( Opcodes . ACC _ DEPRECATED )  )     !  =     0  )     {", "out . putShort ( cw . newUTF 8  (  \" Deprecated \"  )  )  . putInt (  0  )  ;", "}", "if    (  ( ClassReader . SIGNATURES )     &  &     (  ( signature )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" Signature \"  )  )  . putInt (  2  )  . putShort ( cw . newUTF 8  ( signature )  )  ;", "}", "if    (  ( methodParameters )     !  =    null )     {", "out . putShort ( cw . newUTF 8  (  \" MethodParameters \"  )  )  ;", "out . putInt (  (  ( methodParameters . length )     +     1  )  )  . putByte ( methodParametersCount )  ;", "out . putByteArray ( methodParameters . data ,     0  ,    methodParameters . length )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( annd )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" AnnotationDefault \"  )  )  ;", "out . putInt ( annd . length )  ;", "out . putByteArray ( annd . data ,     0  ,    annd . length )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( anns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeVisibleAnnotations \"  )  )  ;", "anns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ianns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeInvisibleAnnotations \"  )  )  ;", "ianns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( tanns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeVisibleTypeAnnotations \"  )  )  ;", "tanns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( itanns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeInvisibleTypeAnnotations \"  )  )  ;", "itanns . put ( out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( panns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeVisibleParameterAnnotations \"  )  )  ;", "AnnotationWriter . put ( panns ,    synthetics ,    out )  ;", "}", "if    (  ( ClassReader . ANNOTATIONS )     &  &     (  ( ipanns )     !  =    null )  )     {", "out . putShort ( cw . newUTF 8  (  \" RuntimeInvisibleParameterAnnotations \"  )  )  ;", "AnnotationWriter . put ( ipanns ,    synthetics ,    out )  ;", "}", "if    (  ( attrs )     !  =    null )     {", "attrs . put ( cw ,    null ,     0  ,     (  -  1  )  ,     (  -  1  )  ,    out )  ;", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "int   n    =     (  3     +    nLocal )     +    nStack ;", "if    (  (  (  )     =  =    null )     |  |     (  (  . length )     <    n )  )     {", "=    new   int [ n ]  ;", "}", "[  0  ]     =    offset ;", "[  1  ]     =    nLocal ;", "[  2  ]     =    nStack ;", "return    3  ;", "}", "METHOD_END"], "methodName": ["startFrame"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "int   i ;", "int   t ;", "int   nTop    =     0  ;", "int   nLocal    =     0  ;", "int   nStack    =     0  ;", "int [  ]    locals    =    f . inputLocals ;", "int [  ]    stacks    =    f . inputStack ;", "for    ( i    =     0  ;    i    <     ( locals . length )  ;     +  + i )     {", "t    =    locals [ i ]  ;", "if    ( t    =  =     ( Frame . TOP )  )     {", "+  + nTop ;", "} else    {", "nLocal    +  =    nTop    +     1  ;", "nTop    =     0  ;", "}", "if    (  ( t    =  =     ( Frame . LONG )  )     |  |     ( t    =  =     ( Frame . DOUBLE )  )  )     {", "+  + i ;", "}", "}", "for    ( i    =     0  ;    i    <     ( stacks . length )  ;     +  + i )     {", "t    =    stacks [ i ]  ;", "+  + nStack ;", "if    (  ( t    =  =     ( Frame . LONG )  )     |  |     ( t    =  =     ( Frame . DOUBLE )  )  )     {", "+  + i ;", "}", "}", "int   Index    =    startFrame ( f . owner . position ,    nLocal ,    nStack )  ;", "for    ( i    =     0  ;    nLocal    >     0  ;     +  + i    ,     -  - nLocal )     {", "t    =    locals [ i ]  ;", "[  ( Index +  +  )  ]     =    t ;", "if    (  ( t    =  =     ( Frame . LONG )  )     |  |     ( t    =  =     ( Frame . DOUBLE )  )  )     {", "+  + i ;", "}", "}", "for    ( i    =     0  ;    i    <     ( stacks . length )  ;     +  + i )     {", "t    =    stacks [ i ]  ;", "[  ( Index +  +  )  ]     =    t ;", "if    (  ( t    =  =     ( Frame . LONG )  )     |  |     ( t    =  =     ( Frame . DOUBLE )  )  )     {", "+  + i ;", "}", "}", "endFrame (  )  ;", "}", "METHOD_END"], "methodName": ["visitFrame"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "int   frameIndex    =    startFrame (  0  ,     (  ( descriptor . length (  )  )     +     1  )  ,     0  )  ;", "if    (  (  ( access )     &     ( Opcodes . ACC _ STATIC )  )     =  =     0  )     {", "if    (  (  ( access )     &     (  . ACC _ CONSTRUCTOR )  )     =  =     0  )     {", "frame [  ( frameIndex +  +  )  ]     =     ( Frame . OBJECT )     |     ( cw . addType ( cw . thisName )  )  ;", "} else    {", "frame [  ( frameIndex +  +  )  ]     =     6  ;", "}", "}", "int   i    =     1  ;", "loop    :    while    ( true )     {", "int   j    =    i ;", "switch    ( descriptor . charAt (  ( i +  +  )  )  )     {", "case    ' Z '     :", "case    ' C '     :", "case    ' B '     :", "case    ' S '     :", "case    ' I '     :", "frame [  ( frameIndex +  +  )  ]     =     1  ;", "break ;", "case    ' F '     :", "frame [  ( frameIndex +  +  )  ]     =     2  ;", "break ;", "case    ' J '     :", "frame [  ( frameIndex +  +  )  ]     =     4  ;", "break ;", "case    ' D '     :", "frame [  ( frameIndex +  +  )  ]     =     3  ;", "break ;", "case    '  [  '     :", "while    (  ( descriptor . charAt ( i )  )     =  =     '  [  '  )     {", "+  + i ;", "}", "if    (  ( descriptor . charAt ( i )  )     =  =     ' L '  )     {", "+  + i ;", "while    (  ( descriptor . charAt ( i )  )     !  =     '  ;  '  )     {", "+  + i ;", "}", "}", "frame [  ( frameIndex +  +  )  ]     =     ( Frame . OBJECT )     |     ( cw . addType ( descriptor . substring ( j ,     (  +  + i )  )  )  )  ;", "break ;", "case    ' L '     :", "while    (  ( descriptor . charAt ( i )  )     !  =     '  ;  '  )     {", "+  + i ;", "}", "frame [  ( frameIndex +  +  )  ]     =     ( Frame . OBJECT )     |     ( cw . addType ( descriptor . substring (  ( j    +     1  )  ,     ( i +  +  )  )  )  )  ;", "break ;", "default    :", "break   loop ;", "}", "}", "frame [  1  ]     =    frameIndex    -     3  ;", "endFrame (  )  ;", "}", "METHOD_END"], "methodName": ["visitImplicitFirstFrame"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentBlock )     !  =    null )     {", "if    (  ( compute )     =  =     (  . FRAMES )  )     {", "currentBlock . frame . execute ( Opcodes . LOOKUPSWITCH ,     0  ,    null ,    null )  ;", "addSuccessor ( Edge . NORMAL ,    dflt )  ;", "dflt . getFirst (  )  . status    |  =    Label . TARGET ;", "for    ( int   i    =     0  ;    i    <     ( labels . length )  ;     +  + i )     {", "addSuccessor ( Edge . NORMAL ,    labels [ i ]  )  ;", "labels [ i ]  . getFirst (  )  . status    |  =    Label . TARGET ;", "}", "} else    {", "-  -  ( stackSize )  ;", "addSuccessor ( stackSize ,    dflt )  ;", "for    ( int   i    =     0  ;    i    <     ( labels . length )  ;     +  + i )     {", "addSuccessor ( stackSize ,    labels [ i ]  )  ;", "}", "}", "noSuccessor (  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitSwitchInsn"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "int   clocalsSize    =    frame [  1  ]  ;", "int   cstackSize    =    frame [  2  ]  ;", "if    (  (  ( cw . version )     &     6  5  5  3  5  )     <     ( Opcodes . V 1  _  6  )  )     {", "stackMap . putShort ( frame [  0  ]  )  . putShort ( clocalsSize )  ;", "writeFrameTypes (  3  ,     (  3     +    clocalsSize )  )  ;", "stackMap . putShort ( cstackSize )  ;", "writeFrameTypes (  (  3     +    clocalsSize )  ,     (  (  3     +    clocalsSize )     +    cstackSize )  )  ;", "return ;", "}", "int   localsSize    =    previousFrame [  1  ]  ;", "int   type    =     . FULL _ FRAME ;", "int   k    =     0  ;", "int   delta ;", "if    (  ( frameCount )     =  =     0  )     {", "delta    =    frame [  0  ]  ;", "} else    {", "delta    =     (  ( frame [  0  ]  )     -     ( previousFrame [  0  ]  )  )     -     1  ;", "}", "if    ( cstackSize    =  =     0  )     {", "k    =    clocalsSize    -    localsSize ;", "switch    ( k )     {", "case    -  3     :", "case    -  2     :", "case    -  1     :", "type    =     . CHOP _ FRAME ;", "localsSize    =    clocalsSize ;", "break ;", "case    0     :", "type    =     ( delta    <     6  4  )     ?     . SAME _ FRAME    :     . SAME _ FRAME _ EXTENDED ;", "break ;", "case    1     :", "case    2     :", "case    3     :", "type    =     . APPEND _ FRAME ;", "break ;", "}", "} else", "if    (  ( clocalsSize    =  =    localsSize )     &  &     ( cstackSize    =  =     1  )  )     {", "type    =     ( delta    <     6  3  )     ?     . SAME _ LOCALS _  1  _ STACK _ ITEM _ FRAME    :     . SAME _ LOCALS _  1  _ STACK _ ITEM _ FRAME _ EXTENDED ;", "}", "if    ( type    !  =     (  . FULL _ FRAME )  )     {", "int   l    =     3  ;", "for    ( int   j    =     0  ;    j    <    localsSize ;    j +  +  )     {", "if    (  ( frame [ l ]  )     !  =     ( previousFrame [ l ]  )  )     {", "type    =     . FULL _ FRAME ;", "break ;", "}", "l +  +  ;", "}", "}", "switch    ( type )     {", "case    . SAME _ FRAME    :", "stackMap . putByte ( delta )  ;", "break ;", "case    . SAME _ LOCALS _  1  _ STACK _ ITEM _ FRAME    :", "stackMap . putByte (  (  (  . SAME _ LOCALS _  1  _ STACK _ ITEM _ FRAME )     +    delta )  )  ;", "writeFrameTypes (  (  3     +    clocalsSize )  ,     (  4     +    clocalsSize )  )  ;", "break ;", "case    . SAME _ LOCALS _  1  _ STACK _ ITEM _ FRAME _ EXTENDED    :", "stackMap . putByte (  . SAME _ LOCALS _  1  _ STACK _ ITEM _ FRAME _ EXTENDED )  . putShort ( delta )  ;", "writeFrameTypes (  (  3     +    clocalsSize )  ,     (  4     +    clocalsSize )  )  ;", "break ;", "case    . SAME _ FRAME _ EXTENDED    :", "stackMap . putByte (  . SAME _ FRAME _ EXTENDED )  . putShort ( delta )  ;", "break ;", "case    . CHOP _ FRAME    :", "stackMap . putByte (  (  (  . SAME _ FRAME _ EXTENDED )     +    k )  )  . putShort ( delta )  ;", "break ;", "case    . APPEND _ FRAME    :", "stackMap . putByte (  (  (  . SAME _ FRAME _ EXTENDED )     +    k )  )  . putShort ( delta )  ;", "writeFrameTypes (  (  3     +    localsSize )  ,     (  3     +    clocalsSize )  )  ;", "break ;", "default    :", "stackMap . putByte (  . FULL _ FRAME )  . putShort ( delta )  . putShort ( clocalsSize )  ;", "writeFrameTypes (  3  ,     (  3     +    clocalsSize )  )  ;", "stackMap . putShort ( cstackSize )  ;", "writeFrameTypes (  (  3     +    clocalsSize )  ,     (  (  3     +    clocalsSize )     +    cstackSize )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeFrame"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   String )     {", "stackMap . putByte (  7  )  . putShort ( cw . newClass (  (  ( String )     ( type )  )  )  )  ;", "} else", "if    ( type   instanceof   Integer )     {", "stackMap . putByte (  (  ( Integer )     ( type )  )  . intValue (  )  )  ;", "} else    {", "stackMap . putByte (  8  )  . putShort (  (  ( Label )     ( type )  )  . position )  ;", "}", "}", "METHOD_END"], "methodName": ["writeFrameType"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    start ;    i    <    end ;     +  + i )     {", "int   t    =     [ i ]  ;", "int   d    =    t    &     ( Frame . DIM )  ;", "if    ( d    =  =     0  )     {", "int   v    =    t    &     ( Frame . BASE _ VALUE )  ;", "switch    ( t    &     ( Frame . BASE _ KIND )  )     {", "case   Frame . OBJECT    :", "stackMap . putByte (  7  )  . putShort ( cw . newClass ( cw . typeTable [ v ]  . strVal 1  )  )  ;", "break ;", "case   Frame . UNINITIALIZED    :", "stackMap . putByte (  8  )  . putShort ( cw . typeTable [ v ]  . intVal )  ;", "break ;", "default    :", "stackMap . putByte ( v )  ;", "}", "} else    {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "d    >  >  =     2  8  ;", "while    (  ( d -  -  )     >     0  )     {", "sb . append (  '  [  '  )  ;", "}", "if    (  ( t    &     ( Frame . BASE _ KIND )  )     =  =     ( Frame . OBJECT )  )     {", "sb . append (  ' L '  )  ;", "sb . append ( cw . typeTable [  ( t    &     ( Frame . BASE _ VALUE )  )  ]  . strVal 1  )  ;", "sb . append (  '  ;  '  )  ;", "} else    {", "switch    ( t    &     1  5  )     {", "case    1     :", "sb . append (  ' I '  )  ;", "break ;", "case    2     :", "sb . append (  ' F '  )  ;", "break ;", "case    3     :", "sb . append (  ' D '  )  ;", "break ;", "case    9     :", "sb . append (  ' Z '  )  ;", "break ;", "case    1  0     :", "sb . append (  ' B '  )  ;", "break ;", "case    1  1     :", "sb . append (  ' C '  )  ;", "break ;", "case    1  2     :", "sb . append (  ' S '  )  ;", "break ;", "default    :", "sb . append (  ' J '  )  ;", "}", "}", "stackMap . putByte (  7  )  . putShort ( cw . newClass ( sb . toString (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeFrameTypes"], "fileName": "org.springframework.asm.MethodWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vEnd (  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitEnd"], "fileName": "org.springframework.asm.ModuleVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . visitExport ( packaze ,    access ,    ms )  ;", "}", "}", "METHOD_END"], "methodName": ["visitExport"], "fileName": "org.springframework.asm.ModuleVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vMainClass ( mainClass )  ;", "}", "}", "METHOD_END"], "methodName": ["visitMainClass"], "fileName": "org.springframework.asm.ModuleVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . visitOpen ( packaze ,    access ,    ms )  ;", "}", "}", "METHOD_END"], "methodName": ["visitOpen"], "fileName": "org.springframework.asm.ModuleVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vPackage ( packaze )  ;", "}", "}", "METHOD_END"], "methodName": ["visitPackage"], "fileName": "org.springframework.asm.ModuleVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vProvide ( service ,    providers )  ;", "}", "}", "METHOD_END"], "methodName": ["visitProvide"], "fileName": "org.springframework.asm.ModuleVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . visitRequire ( m ,    access ,    version )  ;", "}", "}", "METHOD_END"], "methodName": ["visitRequire"], "fileName": "org.springframework.asm.ModuleVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mv )     !  =    null )     {", "mv . vUse ( service )  ;", "}", "}", "METHOD_END"], "methodName": ["visitUse"], "fileName": "org.springframework.asm.ModuleVisitor"}, {"methodBody": ["METHOD_START", "{", "out . putInt ( size )  ;", "out . putShort ( n )  . putShort ( access )  . putShort ( version )  ;", "out . putShort ( requireCount )  ;", "if    (  ( requires )     !  =    null )     {", "out . putByteArray ( requires . data ,     0  ,    requires . length )  ;", "}", "out . putShort ( exportCount )  ;", "if    (  ( exports )     !  =    null )     {", "out . putByteArray ( exports . data ,     0  ,    exports . length )  ;", "}", "out . putShort ( openCount )  ;", "if    (  ( opens )     !  =    null )     {", "out . putByteArray ( opens . data ,     0  ,    opens . length )  ;", "}", "out . putShort ( useCount )  ;", "if    (  ( uses )     !  =    null )     {", "out . putByteArray ( uses . data ,     0  ,    uses . length )  ;", "}", "out . putShort ( provideCount )  ;", "if    (  ( provides )     !  =    null )     {", "out . putByteArray ( provides . data ,     0  ,    provides . length )  ;", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.asm.ModuleWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mainClass )     !  =     0  )     {", "out . putShort ( cw . newUTF 8  (  \" MainClass \"  )  )  . putInt (  2  )  . putShort ( mainClass )  ;", "}", "if    (  ( packages )     !  =    null )     {", "out . putShort ( cw . newUTF 8  (  \" Packages \"  )  )  . putInt (  (  2     +     (  2     *     ( packageCount )  )  )  )  . putShort ( packageCount )  . putByteArray ( packages . data ,     0  ,    packages . length )  ;", "}", "}", "METHOD_END"], "methodName": ["putAttributes"], "fileName": "org.springframework.asm.ModuleWriter"}, {"methodBody": ["METHOD_START", "{", "return   Type . getArgumentTypes ( getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getArgumentTypes"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "char [  ]    buf    =    methodDescriptor . toCharArray (  )  ;", "int   off    =     1  ;", "int   size    =     0  ;", "while    ( true )     {", "char   car    =    buf [  ( off +  +  )  ]  ;", "if    ( car    =  =     '  )  '  )     {", "break ;", "} else", "if    ( car    =  =     ' L '  )     {", "while    (  ( buf [  ( off +  +  )  ]  )     !  =     '  ;  '  )     {", "}", "+  + size ;", "} else", "if    ( car    !  =     '  [  '  )     {", "+  + size ;", "}", "}", "[  ]    args    =    new    [ size ]  ;", "off    =     1  ;", "size    =     0  ;", "while    (  ( buf [ off ]  )     !  =     '  )  '  )     {", "args [ size ]     =     . get ( buf ,    off )  ;", "off    +  =     ( args [ size ]  . len )     +     (  ( args [ size ]  . sort )     =  =     (  . OBJECT )     ?     2     :     0  )  ;", "size    +  =     1  ;", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["getArgumentTypes"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes    =    method . getParameterTypes (  )  ;", "Type [  ]    types    =    new   Type [ classes . length ]  ;", "for    ( int   i    =     ( classes . length )     -     1  ;    i    >  =     0  ;     -  - i )     {", "types [ i ]     =    Type . getType ( classes [ i ]  )  ;", "}", "return   types ;", "}", "METHOD_END"], "methodName": ["getArgumentTypes"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   Type . getArgumentsAndReturnSizes ( getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getArgumentsAndReturnSizes"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "int   n    =     1  ;", "int   c    =     1  ;", "while    ( true )     {", "char   car    =    desc . charAt (  ( c +  +  )  )  ;", "if    ( car    =  =     '  )  '  )     {", "car    =    desc . charAt ( c )  ;", "return    ( n    <  <     2  )     |     ( car    =  =     ' V '     ?     0     :     ( car    =  =     ' D '  )     |  |     ( car    =  =     ' J '  )     ?     2     :     1  )  ;", "} else", "if    ( car    =  =     ' L '  )     {", "while    (  ( desc . charAt (  ( c +  +  )  )  )     !  =     '  ;  '  )     {", "}", "n    +  =     1  ;", "} else", "if    ( car    =  =     '  [  '  )     {", "while    (  ( car    =    desc . charAt ( c )  )     =  =     '  [  '  )     {", "+  + c ;", "}", "if    (  ( car    =  =     ' D '  )     |  |     ( car    =  =     ' J '  )  )     {", "n    -  =     1  ;", "}", "} else", "if    (  ( car    =  =     ' D '  )     |  |     ( car    =  =     ' J '  )  )     {", "n    +  =     2  ;", "} else    {", "n    +  =     1  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getArgumentsAndReturnSizes"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "switch    ( sort )     {", "case    . VOID    :", "return    \" void \"  ;", "case    . BOOLEAN    :", "return    \" boolean \"  ;", "case    . CHAR    :", "return    \" char \"  ;", "case    . BYTE    :", "return    \" byte \"  ;", "case    . SHORT    :", "return    \" short \"  ;", "case    . INT    :", "return    \" int \"  ;", "case    . FLOAT    :", "return    \" float \"  ;", "case    . LONG    :", "return    \" long \"  ;", "case    . DOUBLE    :", "return    \" double \"  ;", "case    . ARRAY    :", "StringBuilder   sb    =    new   StringBuilder ( getElement (  )  . getClassName (  )  )  ;", "for    ( int   i    =    getDimensions (  )  ;    i    >     0  ;     -  - i )     {", "sb . append (  \"  [  ]  \"  )  ;", "}", "return   sb . toString (  )  ;", "case    . OBJECT    :", "return   new   String ( buf ,    off ,    len )  . replace (  '  /  '  ,     '  .  '  )  . intern (  )  ;", "default    :", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    parameters    =    c . getParameterTypes (  )  ;", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "buf . append (  '  (  '  )  ;", "for    ( int   i    =     0  ;    i    <     ( parameters . length )  ;     +  + i )     {", "Type . getDescriptor ( buf ,    parameters [ i ]  )  ;", "}", "return   buf . append (  \"  ) V \"  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getConstructorDescriptor"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "getDescriptor ( buf )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "Type . getDescriptor ( buf ,    c )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . buf )     =  =    null )     {", "buf . append (  (  ( char )     (  (  ( off )     &     -  1  6  7  7  7  2  1  6  )     >  >  >     2  4  )  )  )  ;", "} else", "if    (  ( sort )     =  =     (  . OBJECT )  )     {", "buf . append (  ' L '  )  ;", "buf . append ( this . buf ,    off ,    len )  ;", "buf . append (  '  ;  '  )  ;", "} else    {", "buf . append ( this . buf ,    off ,    len )  ;", "}", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    d    =    c ;", "while    ( true )     {", "if    ( d . isPrimitive (  )  )     {", "char   car ;", "if    ( d    =  =     ( Integer . TYPE )  )     {", "car    =     ' I '  ;", "} else", "if    ( d    =  =     ( Void . TYPE )  )     {", "car    =     ' V '  ;", "} else", "if    ( d    =  =     ( Boolean . TYPE )  )     {", "car    =     ' Z '  ;", "} else", "if    ( d    =  =     ( Byte . TYPE )  )     {", "car    =     ' B '  ;", "} else", "if    ( d    =  =     ( Character . TYPE )  )     {", "car    =     ' C '  ;", "} else", "if    ( d    =  =     ( Short . TYPE )  )     {", "car    =     ' S '  ;", "} else", "if    ( d    =  =     ( Double . TYPE )  )     {", "car    =     ' D '  ;", "} else", "if    ( d    =  =     ( Float . TYPE )  )     {", "car    =     ' F '  ;", "} else    {", "car    =     ' J '  ;", "}", "buf . append ( car )  ;", "return ;", "} else", "if    ( d . isArray (  )  )     {", "buf . append (  '  [  '  )  ;", "d    =    d . getComponent (  )  ;", "} else    {", "buf . append (  ' L '  )  ;", "String   name    =    d . getName (  )  ;", "int   len    =    name . length (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;     +  + i )     {", "char   car    =    name . charAt ( i )  ;", "buf . append (  ( car    =  =     '  .  '     ?     '  /  '     :    car )  )  ;", "}", "buf . append (  '  ;  '  )  ;", "return ;", "}", "}", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "int   i    =     1  ;", "while    (  ( buf [  (  ( off )     +    i )  ]  )     =  =     '  [  '  )     {", "+  + i ;", "}", "return   i ;", "}", "METHOD_END"], "methodName": ["getDimensions"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   Type . getType ( buf ,     (  ( off )     +     ( getDimensions (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getElementType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   new   String ( buf ,    off ,    len )  . intern (  )  ;", "}", "METHOD_END"], "methodName": ["getInternalName"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   c . getName (  )  . replace (  '  .  '  ,     '  /  '  )  ;", "}", "METHOD_END"], "methodName": ["getInternalName"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    parameters    =    m . getParameterTypes (  )  ;", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "buf . append (  '  (  '  )  ;", "for    ( int   i    =     0  ;    i    <     ( parameters . length )  ;     +  + i )     {", "Type . getDescriptor ( buf ,    parameters [ i ]  )  ;", "}", "buf . append (  '  )  '  )  ;", "Type . getDescriptor ( buf ,    m . getReturnType (  )  )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getMethodDescriptor"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "buf . append (  '  (  '  )  ;", "for    ( int   i    =     0  ;    i    <     ( argumentTypes . length )  ;     +  + i )     {", "argumentTypes [ i ]  . getDescriptor ( buf )  ;", "}", "buf . append (  '  )  '  )  ;", "returnType . getDescriptor ( buf )  ;", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getMethodDescriptor"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   Type . getType ( methodDescriptor . toCharArray (  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getMethodType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   Type . getType ( Type . getMethodDescriptor ( returnType ,    argumentTypes )  )  ;", "}", "METHOD_END"], "methodName": ["getMethodType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "char [  ]    buf    =    internalName . toCharArray (  )  ;", "return   new    (  (  ( buf [  0  ]  )     =  =     '  [  '     ?     . ARRAY    :     . OBJECT )  ,    buf ,     0  ,    buf . length )  ;", "}", "METHOD_END"], "methodName": ["getObjectType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "if    (  ( opcode    =  =     ( Opcodes . IALOAD )  )     |  |     ( opcode    =  =     ( Opcodes . IASTORE )  )  )     {", "return   opcode    +     (  ( buf )     =  =    null    ?     (  ( off )     &     6  5  2  8  0  )     >  >     8     :     4  )  ;", "} else    {", "return   opcode    +     (  ( buf )     =  =    null    ?     (  ( off )     &     1  6  7  1  1  6  8  0  )     >  >     1  6     :     4  )  ;", "}", "}", "METHOD_END"], "methodName": ["getOpcode"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   Type . getReturnType ( getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "char [  ]    buf    =    methodDescriptor . toCharArray (  )  ;", "int   off    =     1  ;", "while    ( true )     {", "char   car    =    buf [  ( off +  +  )  ]  ;", "if    ( car    =  =     '  )  '  )     {", "return    . get ( buf ,    off )  ;", "} else", "if    ( car    =  =     ' L '  )     {", "while    (  ( buf [  ( off +  +  )  ]  )     !  =     '  ;  '  )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   Type . getType ( method . getReturnType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return    ( buf )     =  =    null    ?     ( off )     &     2  5  5     :     1  ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   sort ;", "}", "METHOD_END"], "methodName": ["getSort"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "int   len ;", "switch    ( buf [ off ]  )     {", "case    ' V '     :", "return    . VOID _ TYPE ;", "case    ' Z '     :", "return    . BOOLEAN _ TYPE ;", "case    ' C '     :", "return    . CHAR _ TYPE ;", "case    ' B '     :", "return    . BYTE _ TYPE ;", "case    ' S '     :", "return    . SHORT _ TYPE ;", "case    ' I '     :", "return    . INT _ TYPE ;", "case    ' F '     :", "return    . FLOAT _ TYPE ;", "case    ' J '     :", "return    . LONG _ TYPE ;", "case    ' D '     :", "return    . DOUBLE _ TYPE ;", "case    '  [  '     :", "len    =     1  ;", "while    (  ( buf [  ( off    +    len )  ]  )     =  =     '  [  '  )     {", "+  + len ;", "}", "if    (  ( buf [  ( off    +    len )  ]  )     =  =     ' L '  )     {", "+  + len ;", "while    (  ( buf [  ( off    +    len )  ]  )     !  =     '  ;  '  )     {", "+  + len ;", "}", "}", "return   new    (  . ARRAY ,    buf ,    off ,     ( len    +     1  )  )  ;", "case    ' L '     :", "len    =     1  ;", "while    (  ( buf [  ( off    +    len )  ]  )     !  =     '  ;  '  )     {", "+  + len ;", "}", "return   new    (  . OBJECT ,    buf ,     ( off    +     1  )  ,     ( len    -     1  )  )  ;", "default    :", "return   new    (  . METHOD ,    buf ,    off ,     (  ( buf . length )     -    off )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "if    ( c . isPrimitive (  )  )     {", "if    ( c    =  =     ( Integer . TYPE )  )     {", "return    . INT _ TYPE ;", "} else", "if    ( c    =  =     ( Void . TYPE )  )     {", "return    . VOID _ TYPE ;", "} else", "if    ( c    =  =     ( Boolean . TYPE )  )     {", "return    . BOOLEAN _ TYPE ;", "} else", "if    ( c    =  =     ( Byte . TYPE )  )     {", "return    . BYTE _ TYPE ;", "} else", "if    ( c    =  =     ( Character . TYPE )  )     {", "return    . CHAR _ TYPE ;", "} else", "if    ( c    =  =     ( Short . TYPE )  )     {", "return    . SHORT _ TYPE ;", "} else", "if    ( c    =  =     ( Double . TYPE )  )     {", "return    . DOUBLE _ TYPE ;", "} else", "if    ( c    =  =     ( Float . TYPE )  )     {", "return    . FLOAT _ TYPE ;", "} else    {", "return    . LONG _ TYPE ;", "}", "} else    {", "return    . get (  . getDescriptor ( c )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   Type . getType ( typeDescriptor . toCharArray (  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   Type . getType ( Type . getConstructorDescriptor ( c )  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "return   Type . getType ( Type . getMethodDescriptor ( m )  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.asm.Type"}, {"methodBody": ["METHOD_START", "{", "if    (  ( typePath    =  =    null )     |  |     (  ( typePath . length (  )  )     =  =     0  )  )     {", "return   null ;", "}", "int   n    =    typePath . length (  )  ;", "ByteVector   out    =    new   ByteVector ( n )  ;", "out . putByte (  0  )  ;", "for    ( int   i    =     0  ;    i    <    n ;  )     {", "char   c    =    typePath . charAt (  ( i +  +  )  )  ;", "if    ( c    =  =     '  [  '  )     {", "out . put 1  1  (  . ARRAY _ ELEMENT ,     0  )  ;", "} else", "if    ( c    =  =     '  .  '  )     {", "out . put 1  1  (  . INNER _ TYPE ,     0  )  ;", "} else", "if    ( c    =  =     '  *  '  )     {", "out . put 1  1  (  . WILDCARD _ BOUND ,     0  )  ;", "} else", "if    (  ( c    >  =     '  0  '  )     &  &     ( c    <  =     '  9  '  )  )     {", "int   typeArg    =    c    -     '  0  '  ;", "while    (  (  ( i    <    n )     &  &     (  ( c    =    typePath . charAt ( i )  )     >  =     '  0  '  )  )     &  &     ( c    <  =     '  9  '  )  )     {", "typeArg    =     (  ( typeArg    *     1  0  )     +    c )     -     '  0  '  ;", "i    +  =     1  ;", "}", "if    (  ( i    <    n )     &  &     (  ( typePath . charAt ( i )  )     =  =     '  ;  '  )  )     {", "i    +  =     1  ;", "}", "out . put 1  1  (  . TYPE _ ARGUMENT ,    typeArg )  ;", "}", "}", "out . data [  0  ]     =     (  ( byte )     (  ( out . length )     /     2  )  )  ;", "return   new    ( out . data ,     0  )  ;", "}", "METHOD_END"], "methodName": ["fromString"], "fileName": "org.springframework.asm.TypePath"}, {"methodBody": ["METHOD_START", "{", "return   b [ offset ]  ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "org.springframework.asm.TypePath"}, {"methodBody": ["METHOD_START", "{", "return   b [  (  (  ( offset )     +     (  2     *    index )  )     +     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["getStep"], "fileName": "org.springframework.asm.TypePath"}, {"methodBody": ["METHOD_START", "{", "return   b [  (  (  ( offset )     +     (  2     *    index )  )     +     2  )  ]  ;", "}", "METHOD_END"], "methodName": ["getStepArgument"], "fileName": "org.springframework.asm.TypePath"}, {"methodBody": ["METHOD_START", "{", "return    (  ( value )     &     1  6  7  7  6  9  6  0  )     >  >     8  ;", "}", "METHOD_END"], "methodName": ["getExceptionIndex"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return    (  ( value )     &     1  6  7  1  1  6  8  0  )     >  >     1  6  ;", "}", "METHOD_END"], "methodName": ["getFormalParameterIndex"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return    ( value )     >  >  >     2  4  ;", "}", "METHOD_END"], "methodName": ["getSort"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return    (  ( short )     (  (  ( value )     &     1  6  7  7  6  9  6  0  )     >  >     8  )  )  ;", "}", "METHOD_END"], "methodName": ["getSuperTypeIndex"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return    (  ( value )     &     1  6  7  7  6  9  6  0  )     >  >     8  ;", "}", "METHOD_END"], "methodName": ["getTryCatchBlockIndex"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return    ( value )     &     2  5  5  ;", "}", "METHOD_END"], "methodName": ["getTypeArgumentIndex"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return    (  ( value )     &     6  5  2  8  0  )     >  >     8  ;", "}", "METHOD_END"], "methodName": ["getTypeParameterBoundIndex"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return    (  ( value )     &     1  6  7  1  1  6  8  0  )     >  >     1  6  ;", "}", "METHOD_END"], "methodName": ["getTypeParameterIndex"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeReference (  (  (  ( TypeReference . THROWS )     <  <     2  4  )     |     ( exceptionIndex    <  <     8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newExceptionReference"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeReference (  (  (  ( TypeReference . METHOD _ FORMAL _ PARAMETER )     <  <     2  4  )     |     ( paramIndex    <  <     1  6  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newFormalParameterReference"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "itfIndex    &  =     6  5  5  3  5  ;", "return   new    (  (  (  (  . CLASS _ EXTENDS )     <  <     2  4  )     |     ( itfIndex    <  <     8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newSuperTypeReference"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeReference (  (  (  ( TypeReference . EXCEPTION _ PARAMETER )     <  <     2  4  )     |     ( tryCatchBlockIndex    <  <     8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newTryCatchReference"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeReference (  (  ( sort    <  <     2  4  )     |    argIndex )  )  ;", "}", "METHOD_END"], "methodName": ["newTypeArgumentReference"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeReference (  (  (  ( sort    <  <     2  4  )     |     ( paramIndex    <  <     1  6  )  )     |     ( boundIndex    <  <     8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newTypeParameterBoundReference"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeReference (  (  ( sort    <  <     2  4  )     |     ( paramIndex    <  <     1  6  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newTypeParameterReference"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeReference (  ( sort    <  <     2  4  )  )  ;", "}", "METHOD_END"], "methodName": ["newTypeReference"], "fileName": "org.springframework.asm.TypeReference"}, {"methodBody": ["METHOD_START", "{", "try    {", "ClassLoader   loader    =    getClassLoader (  )  ;", "Map < ClassLoader ,     . ClassLoaderData >    cache    =     . CACHE ;", ". ClassLoaderData   data    =    cache . get ( loader )  ;", "if    ( data    =  =    null )     {", "synchronized (  . class )     {", "cache    =     . CACHE ;", "data    =    cache . get ( loader )  ;", "if    ( data    =  =    null )     {", "Map < ClassLoader ,     . ClassLoaderData >    newCache    =    new   WeakHashMap < ClassLoader ,     . ClassLoaderData >  ( cache )  ;", "data    =    new    . ClassLoaderData ( loader )  ;", "newCache . put ( loader ,    data )  ;", ". CACHE    =    newCache ;", "}", "}", "}", "this . key    =    key ;", "Object   obj    =    data . get ( this ,    getUseCache (  )  )  ;", "if    ( obj   instanceof   Class )     {", "return   firstInstance (  (  ( Class )     ( obj )  )  )  ;", "}", "return   nextInstance ( obj )  ;", "}    catch    ( RuntimeException    |    Error   ex )     {", "throw   ex ;", "}    catch    ( Exception   ex )     {", "throw   new   CodeGenerationException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Class   gen ;", "Object   save    =     . CURRENT . get (  )  ;", ". CURRENT . set ( this )  ;", "try    {", "ClassLoader   classLoader    =    data . getClassLoader (  )  ;", "if    ( classLoader    =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  \" ClassLoader   is   null   while   trying   to   define   class    \"     +     ( getClassName (  )  )  )     +     \"  .    It   seems   that   the   loader   has   been   expired   from   a   weak   reference   somehow .     \"  )     +     \" Please   file   an   issue   at   cglib ' s   issue   tracker .  \"  )  )  ;", "}", "synchronized ( classLoader )     {", "String   name    =    generateClassName ( data . getUniqueNamePredicate (  )  )  ;", "data . reserveName ( name )  ;", "this . setClassName ( name )  ;", "}", "if    ( attemptLoad )     {", "try    {", "gen    =    classLoader . loadClass ( getClassName (  )  )  ;", "return   gen ;", "}    catch    ( ClassNotFoundException   e )     {", "}", "}", "byte [  ]    b    =    strategy . generate ( this )  ;", "String   className    =    ClassNameReader . getClassName ( new   ClassReader ( b )  )  ;", "ProtectionDomain   protectionDomain    =    getProtectionDomain (  )  ;", "synchronized ( classLoader )     {", "gen    =    ReflectUtils . defineClass ( className ,    b ,    classLoader ,    protectionDomain ,    contextClass )  ;", "}", "return   gen ;", "}    catch    ( RuntimeException    |    Error   ex )     {", "throw   ex ;", "}    catch    ( Exception   ex )     {", "throw   new   CodeGenerationException ( ex )  ;", "}    finally    {", ". CURRENT . set ( save )  ;", "}", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   namingPolicy . getClassName ( namePrefix ,    source . name ,    key ,    nameTestPredicate )  ;", "}", "METHOD_END"], "methodName": ["generateClassName"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   attemptLoad ;", "}", "METHOD_END"], "methodName": ["getAttemptLoad"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   t    =    classLoader ;", "if    ( t    =  =    null )     {", "t    =    getDefaulLoader (  )  ;", "}", "if    ( t    =  =    null )     {", "t    =    ge (  )  . geLoader (  )  ;", "}", "if    ( t    =  =    null )     {", "t    =    Thread . currentThread (  )  . getContexLoader (  )  ;", "}", "if    ( t    =  =    null )     {", "throw   new   IllegalStateException (  \" Cannot   determine   classloader \"  )  ;", "}", "return   t ;", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   className ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return    (  ( AbstractClassGenerator )     ( AbstractClassGenerator . CURRENT . get (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCurrent"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   namingPolicy ;", "}", "METHOD_END"], "methodName": ["getNamingPolicy"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getProtectionDomain"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   strategy ;", "}", "METHOD_END"], "methodName": ["getStrategy"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   useCache ;", "}", "METHOD_END"], "methodName": ["getUseCache"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "this . attemptLoad    =    attemptLoad ;", "}", "METHOD_END"], "methodName": ["setAttemptLoad"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "this . classLoader    =    classLoader ;", "}", "METHOD_END"], "methodName": ["setClassLoader"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "this . className    =    className ;", "}", "METHOD_END"], "methodName": ["setClassName"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "this . contextClass    =    contextClass ;", "}", "METHOD_END"], "methodName": ["setContextClass"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "this . namePrefix    =    namePrefix ;", "}", "METHOD_END"], "methodName": ["setNamePrefix"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( namingPolicy    =  =    null )", "namingPolicy    =    DefaultNamingPolicy . INSTANCE ;", "this . namingPolicy    =    namingPolicy ;", "}", "METHOD_END"], "methodName": ["setNamingPolicy"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( strategy    =  =    null )", "strategy    =    DefaultStrategy . INSTANCE ;", "this . strategy    =    strategy ;", "}", "METHOD_END"], "methodName": ["setStrategy"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "this . useCache    =    useCache ;", "}", "METHOD_END"], "methodName": ["setUseCache"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return    (  ( WeakReference )     ( cached )  )  . get (  )  ;", "}", "METHOD_END"], "methodName": ["unwrapCachedValue"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( new   WeakReference ( klass )  )  )  ;", "}", "METHOD_END"], "methodName": ["wrapCachedClass"], "fileName": "org.springframework.cglib.core.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   KeyFactory . create ( keyInterface ,    null )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.core.KeyFactory"}, {"methodBody": ["METHOD_START", "{", "return   KeyFactory . create ( keyInterface . getClassLoader (  )  ,    keyInterface ,    customizer )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.core.KeyFactory"}, {"methodBody": ["METHOD_START", "{", "return   KeyFactory . create ( keyInterface . getClassLoader (  )  ,    keyInterface ,    first ,    next )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.core.KeyFactory"}, {"methodBody": ["METHOD_START", "{", "return   KeyFactory . create ( loader ,    keyInterface ,    customizer ,    Collections .  < KeyFactoryCustomizer > emptyList (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.core.KeyFactory"}, {"methodBody": ["METHOD_START", "{", "KeyFactory . Generator   gen    =    new   KeyFactory . Generator (  )  ;", "gen . setInterface ( keyInterface )  ;", "gen . setContextClass ( keyInterface )  ;", "if    ( customizer    !  =    null )     {", "gen . addCustomizer ( customizer )  ;", "}", "if    (  ( next    !  =    null )     &  &     (  !  ( next . isEmpty (  )  )  )  )     {", "for    ( KeyFactoryCustomizer   keyFactoryCustomizer    :    next )     {", "gen . addCustomizer ( keyFactoryCustomizer )  ;", "}", "}", "gen . setClassLoader ( loader )  ;", "return   gen . create (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.core.KeyFactory"}, {"methodBody": ["METHOD_START", "{", "Class   superclass    =    type . getSuperclass (  )  ;", "if    ( superclass    !  =    null )     {", "list . addAll ( Arrays . asList ( type . getInterfaces (  )  )  )  ;", ". addAllInterfaces ( superclass ,    list )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["addAllInterfaces"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =     ( Object . class )  )     {", "list . addAll (  . OBJECT _ METHODS )  ;", "} else", "list . addAll ( asList ( type . getDeclaredMethods (  )  )  )  ;", "Class   superclass    =    type . getSuperclass (  )  ;", "if    ( superclass    !  =    null )     {", ". addAllMethods ( superclass ,    list )  ;", "}", "Class [  ]    interfaces    =    type . getInterfaces (  )  ;", "for    ( int   i    =     0  ;    i    <     ( interfaces . length )  ;    i +  +  )     {", ". addAllMethods ( interfaces [ i ]  ,    list )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["addAllMethods"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . defineClass ( className ,    b ,    loader ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["defineClass"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . defineClass ( className ,    b ,    loader ,    protectionDomain ,    null )  ;", "}", "METHOD_END"], "methodName": ["defineClass"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "Class   c    =    null ;", "if    (  (  ( contextClass    !  =    null )     &  &     (  (  . privateLookupInMethod )     !  =    null )  )     &  &     (  (  . lookupDefineClassMethod )     !  =    null )  )     {", "try    {", "MethodHandles . Lookup   lookup    =     (  ( MethodHandles . Lookup )     (  . privateLookupInMethod . invoke ( null ,    contextClass ,    MethodHandles . lookup (  )  )  )  )  ;", "c    =     (  ( Class )     (  . lookupDefineClassMethod . invoke ( lookup ,    b )  )  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "if    (  !  (  ( ex . getTargetException (  )  )    instanceof   IllegalArgumentException )  )     {", "throw   new   CodeGenerationException ( ex . getTargetException (  )  )  ;", "}", "}    catch    ( Throwable   ex )     {", "throw   new   CodeGenerationException ( ex )  ;", "}", "}", "if    ( protectionDomain    =  =    null )     {", "protectionDomain    =     . PROTECTION _ DOMAIN ;", "}", "if    ( c    =  =    null )     {", "if    (  (  . classLoaderDefineClassMethod )     !  =    null )     {", "Object [  ]    args    =    new   Object [  ]  {    className ,    b ,     0  ,    b . length ,    protectionDomain    }  ;", "try    {", "if    (  !  (  . classLoaderDefineClassMethod . isAccessible (  )  )  )     {", ". classLoaderDefineClassMethod . setAccessible ( true )  ;", "}", "c    =     (  ( Class )     (  . classLoaderDefineClassMethod . invoke ( loader ,    args )  )  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   CodeGenerationException ( ex . getTargetException (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   CodeGenerationException ( ex )  ;", "}", "} else    {", "throw   new   CodeGenerationException (  . THROWABLE )  ;", "}", "}", "Class . forName ( className ,    true ,    loader )  ;", "return   c ;", "}", "METHOD_END"], "methodName": ["defineClass"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . findConstructor ( desc ,    ReflectUtils . defaultLoader )  ;", "}", "METHOD_END"], "methodName": ["findConstructor"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "int   lparen    =    desc . indexOf (  '  (  '  )  ;", "String   className    =    desc . substring (  0  ,    lparen )  . trim (  )  ;", "return    . getClass ( className ,    loader )  . getConstructor (  . parseTypes ( desc ,    loader )  )  ;", "}    catch    ( ClassNotFoundException    |    NoSuchMethodException   ex )     {", "throw   new   CodeGenerationException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["findConstructor"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "Class   cl    =    type ;", "while    ( cl    !  =    null )     {", "try    {", "return   cl . getDeclaredMethod ( methodName ,    paterTypes )  ;", "}    catch    ( NoSuchMethodException   e )     {", "cl    =    cl . getSuperclass (  )  ;", "}", "}", "throw   new   NoSuchMethodException ( methodName )  ;", "}", "METHOD_END"], "methodName": ["findDeclaredMethod"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( iface . isInterface (  )  )  )     {", "throw   new   IllegalArgumentException (  ( iface    +     \"    is   not   an   interface \"  )  )  ;", "}", "Method [  ]    methods    =    iface . getDeclaredMethods (  )  ;", "if    (  ( methods . length )     !  =     1  )     {", "throw   new   IllegalArgumentException (  (  \" expect   exactly    1    method   in    \"     +    iface )  )  ;", "}", "return   methods [  0  ]  ;", "}", "METHOD_END"], "methodName": ["findInterfaceMethod"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . findMethod ( desc ,    ReflectUtils . defaultLoader )  ;", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "int   lparen    =    desc . indexOf (  '  (  '  )  ;", "int   dot    =    desc . lastIndexOf (  '  .  '  ,    lparen )  ;", "String   className    =    desc . substring (  0  ,    dot )  . trim (  )  ;", "String   methodName    =    desc . substring (  ( dot    +     1  )  ,    lparen )  . trim (  )  ;", "return    . getClass ( className ,    loader )  . getDeclaredMethod ( methodName ,     . parseTypes ( desc ,    loader )  )  ;", "}    catch    ( ClassNotFoundException    |    NoSuchMethodException   ex )     {", "throw   new   CodeGenerationException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "Map   map    =    new   HashMap (  )  ;", "for    ( int   i    =     0  ;    i    <     ( methods . length )  ;    i +  +  )     {", "Method   method    =    methods [ i ]  ;", "map . put (  (  ( method . getN (  )  )     +     ( Type . getMethodDescriptor ( method )  )  )  ,    method )  ;", "}", "Method [  ]    result    =    new   Method [  ( nsAndDescriptors . length )     /     2  ]  ;", "for    ( int   i    =     0  ;    i    <     ( result . length )  ;    i +  +  )     {", "result [ i ]     =     (  ( Method )     ( map . get (  (  ( nsAndDescriptors [  ( i    *     2  )  ]  )     +     ( nsAndDescriptors [  (  ( i    *     2  )     +     1  )  ]  )  )  )  )  )  ;", "if    (  ( result [ i ]  )     =  =    null )     {", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findMethods"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    ReflectUtils . findInterfaceMethod ( iface )  ;", "if    (  !  ( m . getName (  )  . equals (  \" newInstance \"  )  )  )     {", "throw   new   IllegalArgumentException (  ( iface    +     \"    missing   newInstance   method \"  )  )  ;", "}", "return   m ;", "}", "METHOD_END"], "methodName": ["findNewInstance"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( classes . length )  ;    i +  +  )     {", "if    (  !  ( Modifier . isPublic ( classes [ i ]  . getModifiers (  )  )  )  )     {", "return   i ;", "}", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["findPackageProtected"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . getPropertiesHelper ( type ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["getBeanGetters"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . getPropertiesHelper ( type ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["getBeanProperties"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . getPropertiesHelper ( type ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["getBeanSetters"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . getClass ( className ,    loader ,    ReflectUtils . CGLIB _ PACKAGES )  ;", "}", "METHOD_END"], "methodName": ["getClass"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "String   save    =    className ;", "int   dimensions    =     0  ;", "int   index    =     0  ;", "while    (  ( index    =     ( className . indexOf (  \"  [  ]  \"  ,    index )  )     +     1  )     >     0  )     {", "dimensions +  +  ;", "}", "StringBuffer   brackets    =    new   StringBuffer (  (  ( className . length (  )  )     -    dimensions )  )  ;", "for    ( int   i    =     0  ;    i    <    dimensions ;    i +  +  )     {", "brackets . append (  '  [  '  )  ;", "}", "className    =    className . substring (  0  ,     (  ( className . length (  )  )     -     (  2     *    dimensions )  )  )  ;", "String   prefix    =     ( dimensions    >     0  )     ?    brackets    +     \" L \"     :     \"  \"  ;", "String   suffix    =     ( dimensions    >     0  )     ?     \"  ;  \"     :     \"  \"  ;", "try    {", "return   Class . forName (  (  ( prefix    +    className )     +    suffix )  ,    false ,    loader )  ;", "}    catch    ( ClassNotFoundException   ignore )     {", "}", "for    ( int   i    =     0  ;    i    <     ( packages . length )  ;    i +  +  )     {", "try    {", "return   Class . forName (  (  (  (  ( prefix    +     ( packages [ i ]  )  )     +     '  .  '  )     +    className )     +    suffix )  ,    false ,    loader )  ;", "}    catch    ( ClassNotFoundException   ignore )     {", "}", "}", "if    ( dimensions    =  =     0  )     {", "Class   c    =     (  ( Class )     (  . primitives . get ( className )  )  )  ;", "if    ( c    !  =    null )     {", "return   c ;", "}", "} else    {", "String   transform    =     (  ( String )     (  . transforms . get ( className )  )  )  ;", "if    ( transform    !  =    null )     {", "try    {", "return   Class . forName (  ( brackets    +    transform )  ,    false ,    loader )  ;", "}    catch    ( ClassNotFoundException   ignore )     {", "}", "}", "}", "throw   new   ClassNotFoundException ( save )  ;", "}", "METHOD_END"], "methodName": ["getClass"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "final   Type   type    =    Type . getType ( clazz )  ;", "final   Type   sc    =     (  ( clazz . getSuperclass (  )  )     =  =    null )     ?    null    :    Type . getType ( clazz . getSuperclass (  )  )  ;", "return   new   ClassInfo (  )     {", "public   Type   getType (  )     {", "return   type ;", "}", "public   Type   getSuperType (  )     {", "return   sc ;", "}", "public   Type [  ]    getInterfaces (  )     {", "return   Type . getTypes ( clazz . getInterfaces (  )  )  ;", "}", "public   int   getModifiers (  )     {", "return   clazz . getModifiers (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getClassInfo"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "Class [  ]    classes    =    new   Class [ objects . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( objects . length )  ;    i +  +  )     {", "classes [ i ]     =    objects [ i ]  . getClass (  )  ;", "}", "return   classes ;", "}", "METHOD_END"], "methodName": ["getClasses"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "Constructor   constructor    =    type . getDeclaredConstructor ( paterTypes )  ;", "constructor . setAccessible ( true )  ;", "return   constructor ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   CodeGenerationException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getConstructor"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( member   instanceof   Method )     {", "return   TypeUtils . getTypes (  (  ( Method )     ( member )  )  . getExceptionTypes (  )  )  ;", "} else", "if    ( member   instanceof   Constructor )     {", "return   TypeUtils . getTypes (  (  ( Constructor )     ( member )  )  . getExceptionTypes (  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Cannot   get   exception   types   of   a   field \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["getExceptionTypes"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . getMethodInfo ( member ,    member . getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMethodInfo"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "final   Signature   sig    =    ReflectUtils . getSignature ( member )  ;", "return   new   MethodInfo (  )     {", "private   ClassInfo   ci ;", "public   ClassInfo   getClassInfo (  )     {", "if    (  ( ci )     =  =    null )", "ci    =    ReflectUtils . getClassInfo ( member . getDeclaringClass (  )  )  ;", "return   ci ;", "}", "public   int   getModifiers (  )     {", "return   modifiers ;", "}", "public   Signature   getSignature (  )     {", "return   sig ;", "}", "public   Type [  ]    getExceptionTypes (  )     {", "return   ReflectUtils . getExceptionTypes ( member )  ;", "}", "public   Attribute   getAttribute (  )     {", "return   null ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getMethodInfo"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( classes    =  =    null )", "return   null ;", "St [  ]    names    =    new   St [ classes . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( names . length )  ;    i +  +  )     {", "names [ i ]     =    classes [ i ]  . getName (  )  ;", "}", "return   names ;", "}", "METHOD_END"], "methodName": ["getNames"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "BeanInfo   info    =    Introspor . getBeanInfo ( type ,    Obj . class )  ;", "PropertyDescriptor [  ]    all    =    info . getPropertyDescriptors (  )  ;", "if    ( read    &  &    write )     {", "return   all ;", "}", "List   properties    =    new   ArrayList ( all . length )  ;", "for    ( int   i    =     0  ;    i    <     ( all . length )  ;    i +  +  )     {", "PropertyDescriptor   pd    =    all [ i ]  ;", "if    (  ( read    &  &     (  ( pd . getReadMethod (  )  )     !  =    null )  )     |  |     ( write    &  &     (  ( pd . getWriteMethod (  )  )     !  =    null )  )  )     {", "properties . add ( pd )  ;", "}", "}", "return    (  ( PropertyDescriptor [  ]  )     ( properties . toArray ( new   PropertyDescriptor [ properties . size (  )  ]  )  )  )  ;", "}    catch    ( IntrospionException   e )     {", "throw   new   CodeGenerationException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getPropertiesHelper"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "Set   methods    =    new   HashSet (  )  ;", "for    ( int   i    =     0  ;    i    <     ( properties . length )  ;    i +  +  )     {", "PropertyDescriptor   pd    =    properties [ i ]  ;", "if    ( read )     {", "methods . add ( pd . getReadMethod (  )  )  ;", "}", "if    ( write )     {", "methods . add ( pd . getWriteMethod (  )  )  ;", "}", "}", "methods . remove ( null )  ;", "return    (  ( Method [  ]  )     ( methods . toArray ( new   Method [ methods . size (  )  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyMethods"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( source    =  =    null )     {", "return   null ;", "}", "return    (  ( ProtionDomain )     ( AccessController . doPrivileged ( new   PrivilegedAction (  )     {", "public   Obj   run (  )     {", "return   source . getProtionDomain (  )  ;", "}", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getProtectionDomain"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( member   instanceof   Method )     {", "return   new   Signature ( member . getName (  )  ,    Type . getMethodDescriptor (  (  ( Method )     ( member )  )  )  )  ;", "} else", "if    ( member   instanceof   Constructor )     {", "Type [  ]    types    =    TypeUtils . getTypes (  (  ( Constructor )     ( member )  )  . getParameterTypes (  )  )  ;", "return   new   Signature ( Constants . CONSTRUCTOR _ NAME ,    Type . getMethodDescriptor ( Type . VOID _ TYPE ,    types )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Cannot   get   signature   of   a   field \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSignature"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . newInstance ( type ,    EMPTY _ CLASS _ ARRAY ,    null )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectUtils . newInstance ( ReflectUtils . getConstructor ( type ,    parameterTypes )  ,    args )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "boolean   flag    =    cstruct . isAccessible (  )  ;", "try    {", "if    (  ! flag )     {", "cstruct . setAccessible ( true )  ;", "}", "Obj   result    =    cstruct . newInstance ( args )  ;", "return   result ;", "}    catch    ( InstantiationException   e )     {", "throw   new   CodeGenerationException ( e )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   CodeGenerationException ( e )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   new   CodeGenerationException ( e . getTargetException (  )  )  ;", "}    finally    {", "if    (  ! flag )     {", "cstruct . setAccessible ( flag )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "int   lparen    =    desc . indexOf (  '  (  '  )  ;", "int   rparen    =    desc . indexOf (  '  )  '  ,    lparen )  ;", "List   params    =    new   ArrayList (  )  ;", "int   start    =    lparen    +     1  ;", "for    (  ;     ;  )     {", "int   comma    =    desc . indexOf (  '  ,  '  ,    start )  ;", "if    ( comma    <     0  )     {", "break ;", "}", "params . add ( desc . substring ( start ,    comma )  . trim (  )  )  ;", "start    =    comma    +     1  ;", "}", "if    ( start    <    rparen )     {", "params . add ( desc . substring ( start ,    rparen )  . trim (  )  )  ;", "}", "Class [  ]    types    =    new   Class [ params . size (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( types . length )  ;    i +  +  )     {", "types [ i ]     =     . getClass (  (  ( String )     ( params . get ( i )  )  )  ,    loader )  ;", "}", "return   types ;", "}", "METHOD_END"], "methodName": ["parseTypes"], "fileName": "org.springframework.cglib.core.ReflectUtils"}, {"methodBody": ["METHOD_START", "{", "classOnly    =    false ;", "aumentTypes    =    null ;", "return   createHelper (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer   e    =    new   Enhancer (  )  ;", "e . setSuperclass ( superclass )  ;", "e . setInterfaces ( interfaces )  ;", "e . setCallback ( callback )  ;", "return   e . create (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer   e    =    new   Enhancer (  )  ;", "e . setSuperclass ( superclass )  ;", "e . setInterfaces ( interfaces )  ;", "e . setCallbackFilter ( filter )  ;", "e . setCallbacks ( callbacks )  ;", "return   e . create (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer   e    =    new   Enhancer (  )  ;", "e . setSuperclass ( type )  ;", "e . setCallback ( callback )  ;", "return   e . create (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "classOnly    =    false ;", "if    (  (  ( aumentTypes    =  =    null )     |  |     ( auments    =  =    null )  )     |  |     (  ( aumentTypes . length )     !  =     ( auments . length )  )  )     {", "throw   new   IllegalAumentException (  \" Auments   must   be   non - null   and   of   equal   length \"  )  ;", "}", "this . aumentTypes    =    aumentTypes ;", "this . auments    =    auments ;", "return   createHelper (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "classOnly    =    true ;", "return    (  ( Class )     ( createHelp (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createClass"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "preValidate (  )  ;", "Object   key    =    Enhancer . KEY _ FACTORY . newInstance (  (  ( superclass )     !  =    null    ?    superclass . getName (  )     :    null )  ,    ReflectUtils . getNames ( interfaces )  ,     (  ( filter )     =  =     ( Enhancer . ALL _ ZERO )     ?    null    :    new   core . WeakCacheKey < CallbackFilter >  ( filter )  )  ,    callbackTypes ,    useFactory ,    interceptDuringConstruction ,    serialVersionUID )  ;", "this . currentKey    =    key ;", "Object   result    =    super . create ( key )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createHelper"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer . setThreadCallbacks ( type ,    callbacks )  ;", "try    {", "if    (  ( argumentTypes )     !  =    null )     {", "return   ReflectUtils . newInstance ( type ,    argumentTypes ,    arguments )  ;", "} else    {", "return   ReflectUtils . newInstance ( type )  ;", "}", "}    finally    {", "Enhancer . setThreadCallbacks ( type ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["createUsingReflection"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "CodeEmitter   e    =    ce . begin _ method ( PRIVATE _ FINAL _ STATIC ,    Enhancer . BIND _ CALLBACKS ,    null )  ;", "Local   me    =    e . make _ local (  )  ;", "e . load _ arg (  0  )  ;", "e . checkcast _ this (  )  ;", "e . store _ local ( me )  ;", "Label   end    =    e . make _ label (  )  ;", "e . load _ local ( me )  ;", "e . getfield ( Enhancer . BOUND _ FIELD )  ;", "e . if _ jump ( NE ,    end )  ;", "e . load _ local ( me )  ;", "e . push (  1  )  ;", "e . putfield ( Enhancer . BOUND _ FIELD )  ;", "e . getfield ( Enhancer . THREAD _ CALLBACKS _ FIELD )  ;", "e . invoke _ virtual ( Enhancer . THREAD _ LOCAL ,    Enhancer . THREAD _ LOCAL _ GET )  ;", "e . dup (  )  ;", "Label   found _ callback    =    e . make _ label (  )  ;", "e . ifnonnull ( found _ callback )  ;", "e . pop (  )  ;", "e . getfield ( Enhancer . STATIC _ CALLBACKS _ FIELD )  ;", "e . dup (  )  ;", "e . ifnonnull ( found _ callback )  ;", "e . pop (  )  ;", "e . goTo ( end )  ;", "e . mark ( found _ callback )  ;", "e . checkcast ( Enhancer . CALLBACK _ ARRAY )  ;", "e . load _ local ( me )  ;", "e . swap (  )  ;", "for    ( int   i    =     ( callbackTypes . length )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "if    ( i    !  =     0  )     {", "e . dup 2  (  )  ;", "}", "e . aaload ( i )  ;", "e . checkcast ( callbackTypes [ i ]  )  ;", "e . putfield ( Enhancer . getCallbackField ( i )  )  ;", "}", "e . mark ( end )  ;", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitBindCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Type   thisType    =    getThisType ( e )  ;", "e . new _ instance ( thisType )  ;", "e . dup (  )  ;", "e . invoke _ constructor ( thisType )  ;", "e . aconst _ null (  )  ;", "e . invoke _ static ( thisType ,     . SET _ THREAD _ CALLBACKS )  ;", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitCommonNewInstance"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "boolean   seenNull    =    false ;", "for    ( Iterator   it    =    constructors . iterator (  )  ;    it . hasNext (  )  ;  )     {", "MethodInfo   constructor    =     (  ( MethodInfo )     ( it . next (  )  )  )  ;", "if    (  (  ( currentData )     !  =    null )     &  &     (  !  (  \"  (  ) V \"  . equals ( constructor . getSignature (  )  . getDescriptor (  )  )  )  )  )     {", "continue ;", "}", "CodeEmitter   e    =    EmitUtils . begin _ method ( ce ,    constructor ,    ACC _ PUBLIC )  ;", "e . load _ this (  )  ;", "e . dup (  )  ;", "e . load _ args (  )  ;", "Signature   sig    =    constructor . getSignature (  )  ;", "seenNull    =    seenNull    |  |     ( sig . getDescriptor (  )  . equals (  \"  (  ) V \"  )  )  ;", "e . super _ invoke _ constructor ( sig )  ;", "if    (  ( currentData )     =  =    null )     {", "e . invoke _ static _ this (  . BIND _ CALLBACKS )  ;", "if    (  !  ( interceptDuringConstruction )  )     {", "e . load _ this (  )  ;", "e . push (  1  )  ;", "e . putfield (  . CONSTRUCTED _ FIELD )  ;", "}", "}", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "if    (  (  (  !  ( classOnly )  )     &  &     (  ! seenNull )  )     &  &     (  ( arguments )     =  =    null )  )", "throw   new   IllegalArgumentException (  \" Superclass   has   no   null   constructors   but   no   arguments   were   given \"  )  ;", "}", "METHOD_END"], "methodName": ["emitConstructors"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "e . load _ this (  )  ;", "e . getfield (  . getCallbackField ( index )  )  ;", "e . dup (  )  ;", "Label   end    =    e . make _ label (  )  ;", "e . ifnonnull ( end )  ;", "e . pop (  )  ;", "e . load _ this (  )  ;", "e . invoke _ static _ this (  . BIND _ CALLBACKS )  ;", "e . load _ this (  )  ;", "e . getfield (  . getCallbackField ( index )  )  ;", "e . mark ( end )  ;", "}", "METHOD_END"], "methodName": ["emitCurrentCallback"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Constructor < Object >    declaredConstructor ;", "try    {", "declaredConstructor    =    Object . class . getDeclaredConstructor (  )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   IllegalStateException (  \" Object   should   have   default   constructor    \"  ,    e )  ;", "}", "MethodInfo   constructor    =     (  ( MethodInfo )     ( MethodInfoTransformer . getInst (  )  . transform ( declaredConstructor )  )  )  ;", "CodeEmitter   e    =    EmitUtils . begin _ method ( ce ,    constructor ,    ACC _ PUBLIC )  ;", "e . load _ this (  )  ;", "e . dup (  )  ;", "Signature   sig    =    constructor . getSignature (  )  ;", "e . super _ invoke _ constructor ( sig )  ;", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitDefaultConstructor"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "final   CodeEmitter   e    =    ce . begin _ method ( ACC _ PUBLIC ,    Enhancer . GET _ CALLBACK ,    null )  ;", "e . load _ this (  )  ;", "e . invoke _ static _ this ( Enhancer . BIND _ CALLBACKS )  ;", "e . load _ this (  )  ;", "e . load _ arg (  0  )  ;", "e . process _ switch ( keys ,    new   ProcessSwitchCallback (  )     {", "public   void   processCase ( int   key ,    Label   end )     {", "e . getfield ( Enhancer . getCallbackField ( key )  )  ;", "e . goTo ( end )  ;", "}", "public   void   processDefault (  )     {", "e . pop (  )  ;", "e . aconst _ null (  )  ;", "}", "}  )  ;", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitGetCallback"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "CodeEmitter   e    =    ce . begin _ method ( ACC _ PUBLIC ,    Enhancer . GET _ CALLBACKS ,    null )  ;", "e . load _ this (  )  ;", "e . invoke _ static _ this ( Enhancer . BIND _ CALLBACKS )  ;", "e . load _ this (  )  ;", "e . push ( callbackTypes . length )  ;", "e . newarray ( Enhancer . CALLBACK )  ;", "for    ( int   i    =     0  ;    i    <     ( callbackTypes . length )  ;    i +  +  )     {", "e . dup (  )  ;", "e . push ( i )  ;", "e . load _ this (  )  ;", "e . getfield ( Enhancer . getCallbackField ( i )  )  ;", "e . aastore (  )  ;", "}", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitGetCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "CallbackGenerator [  ]    generators    =    CallbackInfo . getGenerators ( callbackTypes )  ;", "Map   groups    =    new   HashMap (  )  ;", "final   Map   indexes    =    new   HashMap (  )  ;", "final   Map   originalModifiers    =    new   HashMap (  )  ;", "final   Map   positions    =    CollectionUtils . getIndexMap ( methods )  ;", "final   Map   declToBridge    =    new   HashMap (  )  ;", "Iterator   it 1     =    methods . iterator (  )  ;", "Iterator   it 2     =     ( actualMethods    !  =    null )     ?    actualMethods . iterator (  )     :    null ;", "while    ( it 1  . hasNext (  )  )     {", "MethodInfo   method    =     (  ( MethodInfo )     ( it 1  . next (  )  )  )  ;", "Method   actualMethod    =     ( it 2     !  =    null )     ?     (  ( Method )     ( it 2  . next (  )  )  )     :    null ;", "int   index    =    filter . accept ( actualMethod )  ;", "if    ( index    >  =     ( callbackTypes . length )  )     {", "throw   new   IllegalArgumentException (  (  \" Callback   filter   returned   an   index   that   is   too   large :     \"     +    index )  )  ;", "}", "originalModifiers . put ( method ,     ( actualMethod    !  =    null    ?    actualMethod . getModifiers (  )     :    method . getModifiers (  )  )  )  ;", "indexes . put ( method ,    index )  ;", "List   group    =     (  ( List )     ( groups . get ( generators [ index ]  )  )  )  ;", "if    ( group    =  =    null )     {", "groups . put ( generators [ index ]  ,     ( group    =    new   ArrayList ( methods . size (  )  )  )  )  ;", "}", "group . add ( method )  ;", "if    ( TypeUtils . isBridge ( actualMethod . getModifiers (  )  )  )     {", "Set   bridges    =     (  ( Set )     ( declToBridge . get ( actualMethod . getDeclaringClass (  )  )  )  )  ;", "if    ( bridges    =  =    null )     {", "bridges    =    new   HashSet (  )  ;", "declToBridge . put ( actualMethod . getDeclaringClass (  )  ,    bridges )  ;", "}", "bridges . add ( method . getSignature (  )  )  ;", "}", "}", "final   Map   bridgeToTarget    =    new   BridgeMethodResolver ( declToBridge ,    getClassLoader (  )  )  . resolveAll (  )  ;", "Set   seenGen    =    new   HashSet (  )  ;", "CodeEmitter   se    =    ce . getStaticHook (  )  ;", "se . new _ instance (  . THREAD _ LOCAL )  ;", "se . dup (  )  ;", "se . invoke _ constructor (  . THREAD _ LOCAL ,     . CSTRUCT _ NULL )  ;", "se . putfield (  . THREAD _ CALLBACKS _ FIELD )  ;", "final   Object [  ]    state    =    new   Object [  1  ]  ;", "CallbackGenerator . Context   context    =    new   CallbackGenerator . Context (  )     {", "public   ClassLoader   getClassLoader (  )     {", "return    . this . getClassLoader (  )  ;", "}", "public   int   getOriginalModifiers ( MethodInfo   method )     {", "return    (  ( Integer )     ( originalModifiers . get ( method )  )  )  . intValue (  )  ;", "}", "public   int   getIndex ( MethodInfo   method )     {", "return    (  ( Integer )     ( indexes . get ( method )  )  )  . intValue (  )  ;", "}", "public   void   emitCallback ( CodeEmitter   e ,    int   index )     {", "emitCurrentCallback ( e ,    index )  ;", "}", "public   Signature   getImplSignature ( MethodInfo   method )     {", "return   rename ( method . getSignature (  )  ,     (  ( Integer )     ( positions . get ( method )  )  )  . intValue (  )  )  ;", "}", "public   void   emitLoadArgsAndInvoke ( CodeEmitter   e ,    MethodInfo   method )     {", "Signature   bridgeTarget    =     (  ( Signature )     ( bridgeToTarget . get ( method . getSignature (  )  )  )  )  ;", "if    ( bridgeTarget    !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( bridgeTarget . getArgumentTypes (  )  . length )  ;    i +  +  )     {", "e . load _ arg ( i )  ;", "Type   target    =    bridgeTarget . getArgumentTypes (  )  [ i ]  ;", "if    (  !  ( target . equals ( method . getSignature (  )  . getArgumentTypes (  )  [ i ]  )  )  )     {", "e . checkcast ( target )  ;", "}", "}", "e . invoke _ virtual _ this ( bridgeTarget )  ;", "Type   retType    =    method . getSignature (  )  . getReturnType (  )  ;", "if    (  !  ( retType . equals ( bridgeTarget . getReturnType (  )  )  )  )     {", "e . checkcast ( retType )  ;", "}", "} else    {", "e . load _ args (  )  ;", "e . super _ invoke ( method . getSignature (  )  )  ;", "}", "}", "public   CodeEmitter   beginMethod ( ClassEmitter   ce ,    MethodInfo   method )     {", "CodeEmitter   e    =    EmitUtils . begin _ method ( ce ,    method )  ;", "if    (  (  !  ( interceptDuringConstruction )  )     &  &     (  !  ( TypeUtils . isAbstract ( method . getModifiers (  )  )  )  )  )     {", "Label   constructed    =    e . make _ label (  )  ;", "e . load _ this (  )  ;", "e . getfield (  . CONSTRUCTED _ FIELD )  ;", "e . if _ jump ( NE ,    constructed )  ;", "e . load _ this (  )  ;", "e . load _ args (  )  ;", "e . super _ invoke (  )  ;", "e . return _ value (  )  ;", "e . mark ( constructed )  ;", "}", "return   e ;", "}", "}  ;", "for    ( int   i    =     0  ;    i    <     ( callbackTypes . length )  ;    i +  +  )     {", "CallbackGenerator   gen    =    generators [ i ]  ;", "if    (  !  ( seenGen . contains ( gen )  )  )     {", "seenGen . add ( gen )  ;", "final   List   fmethods    =     (  ( List )     ( groups . get ( gen )  )  )  ;", "if    ( fmethods    !  =    null )     {", "try    {", "gen . generate ( ce ,    context ,    fmethods )  ;", "gen . generateStatic ( se ,    context ,    fmethods )  ;", "}    catch    ( RuntimeException   x )     {", "throw   x ;", "}    catch    ( Exception   x )     {", "throw   new   CodeGenerationException ( x )  ;", "}", "}", "}", "}", "se . return _ value (  )  ;", "se . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitMethods"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "CodeEmitter   e    =    ce . begin _ method ( ACC _ PUBLIC ,    Enhancer . SINGLE _ NEW _ INSTANCE ,    null )  ;", "switch    ( callbackTypes . length )     {", "case    0     :", "break ;", "case    1     :", "e . push (  1  )  ;", "e . newarray ( Enhancer . CALLBACK )  ;", "e . dup (  )  ;", "e . push (  0  )  ;", "e . load _ arg (  0  )  ;", "e . aastore (  )  ;", "e . invoke _ static ( getThisType ( e )  ,    Enhancer . SET _ THREAD _ CALLBACKS )  ;", "break ;", "default    :", "e . throw _ exception ( Enhancer . ILLEGAL _ STATE _ EXCEPTION ,     \" More   than   one   callback   object   required \"  )  ;", "}", "emitCommonNewInstance ( e )  ;", "}", "METHOD_END"], "methodName": ["emitNewInstanceCallback"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "CodeEmitter   e    =    ce . begin _ method ( ACC _ PUBLIC ,    Enhancer . NEW _ INSTANCE ,    null )  ;", "Type   thisType    =    getThisType ( e )  ;", "e . load _ arg (  0  )  ;", "e . invoke _ static ( thisType ,    Enhancer . SET _ THREAD _ CALLBACKS )  ;", "emitCommonNewInstance ( e )  ;", "}", "METHOD_END"], "methodName": ["emitNewInstanceCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "final   CodeEmitter   e    =    ce . begin _ method ( ACC _ PUBLIC ,    Enhancer . MULTIARG _ NEW _ INSTANCE ,    null )  ;", "final   Type   thisType    =    getThisType ( e )  ;", "e . load _ arg (  2  )  ;", "e . invoke _ static ( thisType ,    Enhancer . SET _ THREAD _ CALLBACKS )  ;", "e . new _ instance ( thisType )  ;", "e . dup (  )  ;", "e . load _ arg (  0  )  ;", "EmitUtils . constructor _ switch ( e ,    constructors ,    new   ObjectSwitchCallback (  )     {", "public   void   processCase ( Object   key ,    Label   end )     {", "MethodInfo   constructor    =     (  ( MethodInfo )     ( key )  )  ;", "Type [  ]    types    =    constructor . getSignature (  )  . getArgumentTypes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( types . length )  ;    i +  +  )     {", "e . load _ arg (  1  )  ;", "e . push ( i )  ;", "e . aaload (  )  ;", "e . unbox ( types [ i ]  )  ;", "}", "e . invoke _ constructor ( thisType ,    constructor . getSignature (  )  )  ;", "e . goTo ( end )  ;", "}", "public   void   processDefault (  )     {", "e . throw _ exception ( Enhancer . ILLEGAL _ ARGUMENT _ EXCEPTION ,     \" Constructor   not   found \"  )  ;", "}", "}  )  ;", "e . aconst _ null (  )  ;", "e . invoke _ static ( thisType ,    Enhancer . SET _ THREAD _ CALLBACKS )  ;", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitNewInstanceMultiarg"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "final   CodeEmitter   e    =    ce . begin _ method ( ACC _ PUBLIC ,    Enhancer . SET _ CALLBACK ,    null )  ;", "e . load _ arg (  0  )  ;", "e . process _ switch ( keys ,    new   ProcessSwitchCallback (  )     {", "public   void   processCase ( int   key ,    Label   end )     {", "e . load _ this (  )  ;", "e . load _ arg (  1  )  ;", "e . checkcast ( callbackTypes [ key ]  )  ;", "e . putfield ( Enhancer . getCallbackField ( key )  )  ;", "e . goTo ( end )  ;", "}", "public   void   processDefault (  )     {", "}", "}  )  ;", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitSetCallback"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "CodeEmitter   e    =    ce . begin _ method ( ACC _ PUBLIC ,    Enhancer . SET _ CALLBACKS ,    null )  ;", "e . load _ this (  )  ;", "e . load _ arg (  0  )  ;", "for    ( int   i    =     0  ;    i    <     ( callbackTypes . length )  ;    i +  +  )     {", "e . dup 2  (  )  ;", "e . aaload ( i )  ;", "e . checkcast ( callbackTypes [ i ]  )  ;", "e . putfield ( Enhancer . getCallbackField ( i )  )  ;", "}", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitSetCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "CodeEmitter   e    =    ce . begin _ method (  (  ( Constants . ACC _ PUBLIC )     |     ( Constants . ACC _ STATIC )  )  ,    Enhancer . SET _ STATIC _ CALLBACKS ,    null )  ;", "e . load _ arg (  0  )  ;", "e . putfield ( Enhancer . STATIC _ CALLBACKS _ FIELD )  ;", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitSetStaticCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "CodeEmitter   e    =    ce . begin _ method (  (  ( Constants . ACC _ PUBLIC )     |     ( Constants . ACC _ STATIC )  )  ,    Enhancer . SET _ THREAD _ CALLBACKS ,    null )  ;", "e . getfield ( Enhancer . THREAD _ CALLBACKS _ FIELD )  ;", "e . load _ arg (  0  )  ;", "e . invoke _ virtual ( Enhancer . THREAD _ LOCAL ,    Enhancer . THREAD _ LOCAL _ SET )  ;", "e . return _ value (  )  ;", "e . end _ method (  )  ;", "}", "METHOD_END"], "methodName": ["emitSetThreadCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "CollectionUtils . filter ( constructors ,    new   VisibilityPredicate ( sc ,    true )  )  ;", "if    (  ( constructors . size (  )  )     =  =     0  )", "throw   new   IllegalArgumentException (  (  \" No   visible   constructors   in    \"     +    sc )  )  ;", "}", "METHOD_END"], "methodName": ["filterConstructors"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "if    ( classOnly )     {", "return   type ;", "} else    {", "return   createUsReflection ( type )  ;", "}", "}", "METHOD_END"], "methodName": ["firstInstance"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Class   sc    =     (  ( superclass )     =  =    null )     ?    Object . class    :    superclass ;", "if    ( TypeUtils . isFinal ( sc . getModifiers (  )  )  )", "throw   new   IllegalArgumentException (  (  \" Cannot   subclass   final   class    \"     +     ( sc . getName (  )  )  )  )  ;", "List   constructors    =    new   ArrayList ( Arrays . asList ( sc . getDeclaredConstructors (  )  )  )  ;", "filterConstructors ( sc ,    constructors )  ;", "List   actualMethods    =    new   ArrayList (  )  ;", "List   interfaceMethods    =    new   ArrayList (  )  ;", "final   Set   forcePublic    =    new   HashSet (  )  ;", ". getMethods ( sc ,    interfaces ,    actualMethods ,    interfaceMethods ,    forcePublic )  ;", "List   methods    =    CollectionUtils . transform ( actualMethods ,    new   Transformer (  )     {", "public   Object   transform ( Object   value )     {", "Method   method    =     (  ( Method )     ( value )  )  ;", "int   modifiers    =     ( Constants . ACC _ FINAL )     |     (  (  (  ( method . getModifiers (  )  )     &     (  ~  ( Constants . ACC _ ABSTRACT )  )  )     &     (  ~  ( Constants . ACC _ NATIVE )  )  )     &     (  ~  ( Constants . ACC _ SYNCHRONIZED )  )  )  ;", "if    ( forcePublic . contains ( MethodWrapper . create ( method )  )  )     {", "modifiers    =     ( modifiers    &     (  ~  ( Constants . ACC _ PROTECTED )  )  )     |     ( Constants . ACC _ PUBLIC )  ;", "}", "return   ReflectUtils . getMethodInfo ( method ,    modifiers )  ;", "}", "}  )  ;", "ClassEmitter   e    =    new   ClassEmitter ( v )  ;", "if    (  ( currentData )     =  =    null )     {", "e . begin _ class ( V 1  _  2  ,    ACC _ PUBLIC ,    getClassName (  )  ,    Type . getType ( sc )  ,     ( useFactory    ?    TypeUtils . add ( TypeUtils . getTypes ( interfaces )  ,     . FACTORY )     :    TypeUtils . getTypes ( interfaces )  )  ,    SOURCE _ FILE )  ;", "} else    {", "e . begin _ class ( V 1  _  2  ,    ACC _ PUBLIC ,    getClassName (  )  ,    null ,    new   Type [  ]  {     . FACTORY    }  ,    SOURCE _ FILE )  ;", "}", "List   constructorInfo    =    CollectionUtils . transform ( constructors ,    MethodInfoTransformer . getInstance (  )  )  ;", "e . declare _ field ( ACC _ PRIVATE ,     . BOUND _ FIELD ,    Type . BOOLEAN _ TYPE ,    null )  ;", "e . declare _ field (  (  ( Constants . ACC _ PUBLIC )     |     ( Constants . ACC _ STATIC )  )  ,     . FACTORY _ DATA _ FIELD ,     . OBJECT _ TYPE ,    null )  ;", "if    (  !  ( interceptDuringConstruction )  )     {", "e . declare _ field ( ACC _ PRIVATE ,     . CONSTRUCTED _ FIELD ,    Type . BOOLEAN _ TYPE ,    null )  ;", "}", "e . declare _ field ( PRIVATE _ FINAL _ STATIC ,     . THREAD _ CALLBACKS _ FIELD ,     . THREAD _ LOCAL ,    null )  ;", "e . declare _ field ( PRIVATE _ FINAL _ STATIC ,     . STATIC _ CALLBACKS _ FIELD ,     . CALLBACK _ ARRAY ,    null )  ;", "if    (  ( serialVersionUID )     !  =    null )     {", "e . declare _ field ( PRIVATE _ FINAL _ STATIC ,    SUID _ FIELD _ NAME ,    Type . LONG _ TYPE ,    serialVersionUID )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( callbackTypes . length )  ;    i +  +  )     {", "e . declare _ field ( ACC _ PRIVATE ,     . getCallbackField ( i )  ,    callbackTypes [ i ]  ,    null )  ;", "}", "e . declare _ field (  (  ( Constants . ACC _ PRIVATE )     |     ( Constants . ACC _ STATIC )  )  ,     . CALLBACK _ FILTER _ FIELD ,     . OBJECT _ TYPE ,    null )  ;", "if    (  ( currentData )     =  =    null )     {", "emitMethods ( e ,    methods ,    actualMethods )  ;", "emitConstructors ( e ,    constructorInfo )  ;", "} else    {", "emitDefaultConstructor ( e )  ;", "}", "emitSetThreadCallbacks ( e )  ;", "emitSetStaticCallbacks ( e )  ;", "emitBindCallbacks ( e )  ;", "if    (  ( useFactory )     |  |     (  ( currentData )     !  =    null )  )     {", "int [  ]    keys    =    getCallbackKeys (  )  ;", "emitNewInstanceCallbacks ( e )  ;", "emitNewInstanceCallback ( e )  ;", "emitNewInstanceMultiarg ( e ,    constructorInfo )  ;", "emitGetCallback ( e ,    keys )  ;", "emitSetCallback ( e ,    keys )  ;", "emitGetCallbacks ( e )  ;", "emitSetCallbacks ( e )  ;", "}", "e . end _ class (  )  ;", "}", "METHOD_END"], "methodName": ["generateClass"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "return    \" CGLIB $ CALLBACK _  \"     +    index ;", "}", "METHOD_END"], "methodName": ["getCallbackField"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    keys    =    new   int [ callbackTypes . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( callbackTypes . length )  ;    i +  +  )     {", "keys [ i ]     =    i ;", "}", "return   keys ;", "}", "METHOD_END"], "methodName": ["getCallbackKeys"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "return   type . getDeclaredMethod ( methodName ,    new   Class [  ]  {    Callback [  ]  . class    }  )  ;", "}", "METHOD_END"], "methodName": ["getCallbacksSetter"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( superclass )     !  =    null )     {", "return   superclass . getClassLoader (  )  ;", "} else", "if    (  ( interfaces )     !  =    null )     {", "return   interfaces [  0  ]  . getClassLoader (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getDefaultClassLoader"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer . getMethods ( superclass ,    interfaces ,    methods ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["getMethods"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "ReflectUtils . addAllMethods ( superclass ,    methods )  ;", "List   target    =     ( interfaceMethods    !  =    null )     ?    interfaceMethods    :    methods ;", "if    ( interfaces    !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( interfaces . length )  ;    i +  +  )     {", "if    (  ( interfaces [ i ]  )     !  =     ( Factory . class )  )     {", "ReflectUtils . addAllMethods ( interfaces [ i ]  ,    target )  ;", "}", "}", "}", "if    ( interfaceMethods    !  =    null )     {", "if    ( forcePublic    !  =    null )     {", "forcePublic . addAll ( MethodWrapper . createSet ( interfaceMethods )  )  ;", "}", "methods . addAll ( interfaceMethods )  ;", "}", "CollectionUtils . filter ( methods ,    new   core . RejectModifierPredicate ( Constants . ACC _ STATIC )  )  ;", "CollectionUtils . filter ( methods ,    new   VisibilityPredicate ( superclass ,    true )  )  ;", "CollectionUtils . filter ( methods ,    new   DuplicatesPredicate (  )  )  ;", "CollectionUtils . filter ( methods ,    new   core . RejectModifierPredicate ( Constants . ACC _ FINAL )  )  ;", "}", "METHOD_END"], "methodName": ["getMethods"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( superclass )     !  =    null )     {", "return   ReflectUtils . getProtectionDomain ( superclass )  ;", "} else", "if    (  ( interfaces )     !  =    null )     {", "return   ReflectUtils . getProtectionDomain ( interfaces [  0  ]  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getProtectionDomain"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( currentData )     =  =    null )     {", "return   e . getClassEmitt (  )  . getClassType (  )  ;", "} else    {", "return   Type . getType ( currentData . genatedClass )  ;", "}", "}", "METHOD_END"], "methodName": ["getThisType"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "try    {", ". getCallbacksSetter ( type ,     . SET _ THREAD _ CALLBACKS _ NAME )  ;", "return   true ;", "}    catch    ( NoSuchMethodException   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isEnhanced"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer . EnhancerFactoryData   data    =     (  ( Enhancer . EnhancerFactoryData )     ( instance )  )  ;", "if    ( classOnly )     {", "return   data . generatedClass ;", "}", "Class [  ]    argumentTypes    =    this . argumentTypes ;", "Object [  ]    arguments    =    this . arguments ;", "if    ( argumentTypes    =  =    null )     {", "argumentTypes    =    Constants . EMPTY _ CLASS _ ARRAY ;", "arguments    =    null ;", "}", "return   data . newInstance ( argumentTypes ,    arguments ,    callbacks )  ;", "}", "METHOD_END"], "methodName": ["nextInstance"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( callbackTypes )     =  =    null )     {", "callbackTypes    =    CallbackInfo . determineTypes ( callbacks ,    false )  ;", "validateCallbackTypes    =    true ;", "}", "if    (  ( filter )     =  =    null )     {", "if    (  ( callbackTypes . length )     >     1  )     {", "throw   new   IllegalStateException (  \" Multiple   callback   types   possible   but   no   filter   specified \"  )  ;", "}", "filter    =     . ALL _ ZERO ;", "}", "}", "METHOD_END"], "methodName": ["preValidate"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer . setThreadCallbacks ( generatedClass ,    callbacks )  ;", "}", "METHOD_END"], "methodName": ["registerCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer . setCallbacksHelper ( generatedClass ,    callbacks ,    Enhancer . SET _ STATIC _ CALLBACKS _ NAME )  ;", "}", "METHOD_END"], "methodName": ["registerStaticCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "return   new   Signature (  (  (  (  \" CGLIB $  \"     +     ( sig . getName (  )  )  )     +     \"  $  \"  )     +    index )  ,    sig . getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "setCallbacks ( new   Callback [  ]  {    callback    }  )  ;", "}", "METHOD_END"], "methodName": ["setCallback"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "this . filter    =    filter ;", "}", "METHOD_END"], "methodName": ["setCallbackFilter"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "setCallbackTypes ( new   Class [  ]  {    callbackType    }  )  ;", "}", "METHOD_END"], "methodName": ["setCallbackType"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( callbackTypes    !  =    null )     &  &     (  ( callbackTypes . length )     =  =     0  )  )     {", "throw   new   IllegalArgumentException (  \" Array   cannot   be   empty \"  )  ;", "}", "this . callbackTypes    =    CallbackInfo . determineTypes ( callbackTypes )  ;", "}", "METHOD_END"], "methodName": ["setCallbackTypes"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( callbacks    !  =    null )     &  &     (  ( callbacks . length )     =  =     0  )  )     {", "throw   new   IllegalArgumentException (  \" Array   cannot   be   empty \"  )  ;", "}", "this . callbacks    =    callbacks ;", "}", "METHOD_END"], "methodName": ["setCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "try    {", "Method   setter    =     . getCallbacksSetter ( type ,    methodName )  ;", "setter . invoke ( null ,    new   Object [  ]  {    callbacks    }  )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   IllegalArgumentException (  ( type    +     \"    is   not   an   enhanced   class \"  )  )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   CodeGenerationException ( e )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   new   CodeGenerationException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["setCallbacksHelper"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "this . interceptDuringConstruction    =    interceptDuringConstruction ;", "}", "METHOD_END"], "methodName": ["setInterceptDuringConstruction"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "this . interfaces    =    interfaces ;", "}", "METHOD_END"], "methodName": ["setInterfaces"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "serialVersionUID    =    sUID ;", "}", "METHOD_END"], "methodName": ["setSerialVersionUID"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( superclass    !  =    null )     &  &     ( superclass . isInterface (  )  )  )     {", "setInterfaces ( new   Class [  ]  {    superclass    }  )  ;", "} else", "if    (  ( superclass    !  =    null )     &  &     ( superclass . equals ( Object . class )  )  )     {", "this . superclass    =    null ;", "} else    {", "this . superclass    =    superclass ;", "setContextClass ( superclass )  ;", "}", "}", "METHOD_END"], "methodName": ["setSuperclass"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "Enhancer . setCallbacksHelper ( type ,    callbacks ,    Enhancer . SET _ THREAD _ CALLBACKS _ NAME )  ;", "}", "METHOD_END"], "methodName": ["setThreadCallbacks"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "this . useFactory    =    useFactory ;", "}", "METHOD_END"], "methodName": ["setUseFactory"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( classOnly )     ^     (  ( callbacks )     =  =    null )  )     {", "if    ( classOnly )     {", "throw   new   IllegalStateException (  \" createClass   does   not   accept   callbacks \"  )  ;", "} else    {", "throw   new   IllegalStateException (  \" Callbacks   are   required \"  )  ;", "}", "}", "if    (  ( classOnly )     &  &     (  ( callbackTypes )     =  =    null )  )     {", "throw   new   IllegalStateException (  \" Callback   types   are   required \"  )  ;", "}", "if    ( validateCallbackTypes )     {", "callbackTypes    =    null ;", "}", "if    (  (  ( callbacks )     !  =    null )     &  &     (  ( callbackTypes )     !  =    null )  )     {", "if    (  ( callbacks . length )     !  =     ( callbackTypes . length )  )     {", "throw   new   IllegalStateException (  \" Lengths   of   callback   and   callback   types   array   must   be   the   s \"  )  ;", "}", "Type [  ]    check    =    CallbackInfo . determineTypes ( callbacks )  ;", "for    ( int   i    =     0  ;    i    <     ( check . length )  ;    i +  +  )     {", "if    (  !  ( check [ i ]  . equals ( callbackTypes [ i ]  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  \" Callback    \"     +     ( check [ i ]  )  )     +     \"    is   not   assignable   to    \"  )     +     ( callbackTypes [ i ]  )  )  )  ;", "}", "}", "} else", "if    (  ( callbacks )     !  =    null )     {", "callbackTypes    =    CallbackInfo . determineTypes ( callbacks )  ;", "}", "if    (  ( interfaces )     !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( interfaces . length )  ;    i +  +  )     {", "if    (  ( interfaces [ i ]  )     =  =    null )     {", "throw   new   IllegalStateException (  \" Interfaces   cannot   be   null \"  )  ;", "}", "if    (  !  ( interfaces [ i ]  . isInterface (  )  )  )     {", "throw   new   IllegalStateException (  (  ( interfaces [ i ]  )     +     \"    is   not   an   interface \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.springframework.cglib.proxy.Enhancer"}, {"methodBody": ["METHOD_START", "{", "MethodProxy   proxy    =    new   MethodProxy (  )  ;", "proxy . sig 1     =    new   Signature ( name 1  ,    desc )  ;", "proxy . sig 2     =    new   Signature ( name 2  ,    desc )  ;", "proxy . createInfo    =    new   MethodProxy . CreateInfo ( c 1  ,    c 2  )  ;", "return   proxy ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "try    {", "Method   m    =    type . getDeclaredMethod ( FIND _ PROXY _ NAME ,    FIND _ PROXY _ TYPES )  ;", "return    (  (  )     ( m . invoke ( null ,    new   Object [  ]  {    sig    }  )  )  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   IllegalArgumentException (  (  (  \" Class    \"     +    type )     +     \"    does   not   use   a   MethodInterceptor \"  )  )  ;", "}    catch    ( IllegalAccessException    |    InvocationTargetException   ex )     {", "throw   new   CodeGenerationException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "init (  )  ;", "return   fastClassInfo . f 1  ;", "}", "METHOD_END"], "methodName": ["getFastClass"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "return   sig 1  ;", "}", "METHOD_END"], "methodName": ["getSignature"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "init (  )  ;", "return   fastClassInfo . f 2  ;", "}", "METHOD_END"], "methodName": ["getSuperFastClass"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "init (  )  ;", "return   fastClassInfo . i 2  ;", "}", "METHOD_END"], "methodName": ["getSuperIndex"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "return   sig 2  . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getSuperName"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "FastClass . Generator   g    =    new   FastClass . Generator (  )  ;", "etType ( type )  ;", "etContextClass ( type )  ;", "etClassLoader ( ci . c 2  . getClassLoader (  )  )  ;", "etNamingPolicy ( ci . namingPolicy )  ;", "etStrategy ( ci . strategy )  ;", "etAttemptLoad ( ci . attemptLoad )  ;", "return   g . create (  )  ;", "}", "METHOD_END"], "methodName": ["helper"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fastClassInfo )     =  =    null )     {", "synchronized ( initLock )     {", "if    (  ( fastClassInfo )     =  =    null )     {", ". CreateInfo   ci    =    createInfo ;", ". FastClassInfo   fci    =    new    . FastClassInfo (  )  ;", "fci . f 1     =     . helper ( ci ,    ci . c 1  )  ;", "fci . f 2     =     . helper ( ci ,    ci . c 2  )  ;", "fci . i 1     =    fci . f 1  . getIndex ( sig 1  )  ;", "fci . i 2     =    fci . f 2  . getIndex ( sig 2  )  ;", "fastClassInfo    =    fci ;", "createInfo    =    null ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "try    {", "init (  )  ;", ". FastClassInfo   fci    =    fastClassInfo ;", "return   fci . f 1  . invoke ( fci . i 1  ,    obj ,    args )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   ex . getTargetException (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "if    (  ( fastClassInfo . i 1  )     <     0  )", "throw   new   IllegalArgumentException (  (  \" Protected   method :     \"     +     ( sig 1  )  )  )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "try    {", "init (  )  ;", ". FastClassInfo   fci    =    fastClassInfo ;", "return   fci . f 2  . invoke ( fci . i 2  ,    obj ,    args )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   e . getTargetException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeSuper"], "fileName": "org.springframework.cglib.proxy.MethodProxy"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( source ,     \" Source   must   not   be   null \"  )  ;", "String [  ]    attributeNames    =    source . attributeNames (  )  ;", "for    ( String   attributeName    :    attributeNames )     {", "set ( attributeName ,    source . get ( attributeName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyAttributesFrom"], "fileName": "org.springframework.core.AttributeAccessorSupport"}, {"methodBody": ["METHOD_START", "{", "this . attributeAccessor . setAttribute ( AttributeAccessorSupportTests . NAME ,    AttributeAccessorSupportTests . VALUE )  ;", "this . attributeAccessor . setAttribute (  \" abc \"  ,     \"  1  2  3  \"  )  ;", "String [  ]    attributeNames    =    this . attributeAccessor . attributeNames (  )  ;", "Arrays . sort ( attributeNames )  ;", "assertTrue (  (  ( Arrays . binarySearch ( attributeNames ,    AttributeAccessorSupportTests . NAME )  )     >     (  -  1  )  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( attributeNames ,     \" abc \"  )  )     >     (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["attributeNames"], "fileName": "org.springframework.core.AttributeAccessorSupportTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . attributeAccessor . hasAttribute ( AttributeAccessorSupportTests . NAME )  )  ;", "this . attributeAccessor . setAttribute ( AttributeAccessorSupportTests . NAME ,    AttributeAccessorSupportTests . VALUE )  ;", "assertEquals ( AttributeAccessorSupportTests . VALUE ,    this . attributeAccessor . removeAttribute ( AttributeAccessorSupportTests . NAME )  )  ;", "assertFalse ( this . attributeAccessor . hasAttribute ( AttributeAccessorSupportTests . NAME )  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.springframework.core.AttributeAccessorSupportTests"}, {"methodBody": ["METHOD_START", "{", "this . attributeAccessor . setAttribute ( AttributeAccessorSupportTests . NAME ,    AttributeAccessorSupportTests . VALUE )  ;", "assertEquals ( AttributeAccessorSupportTests . VALUE ,    this . attributeAccessor . getAttribute ( AttributeAccessorSupportTests . NAME )  )  ;", "}", "METHOD_END"], "methodName": ["setAndGet"], "fileName": "org.springframework.core.AttributeAccessorSupportTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . attributeAccessor . hasAttribute ( AttributeAccessorSupportTests . NAME )  )  ;", "this . attributeAccessor . setAttribute ( AttributeAccessorSupportTests . NAME ,    AttributeAccessorSupportTests . VALUE )  ;", "assertTrue ( this . attributeAccessor . hasAttribute ( AttributeAccessorSupportTests . NAME )  )  ;", "}", "METHOD_END"], "methodName": ["setAndHas"], "fileName": "org.springframework.core.AttributeAccessorSupportTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( bridgeMethod . isBridge (  )  )  )     {", "return   bridgeMethod ;", "}", "List < Method >    candidateMethods    =    new   ArrayList <  >  (  )  ;", "Method [  ]    methods    =    ReflectionUtils . getAllDeclaredMethods ( bridgeMethod . getDeclaringClass (  )  )  ;", "for    ( Method   candidateMethod    :    methods )     {", "if    (  . isBridgedCandidateFor ( candidateMethod ,    bridgeMethod )  )     {", "candidateMethods . add ( candidateMethod )  ;", "}", "}", "if    (  ( candidateMethods . size (  )  )     =  =     1  )     {", "return   candidateMethods . get (  0  )  ;", "}", "Method   bridgedMethod    =     . searchCandidates ( candidateMethods ,    bridgeMethod )  ;", "if    ( bridgedMethod    !  =    null )     {", "return   bridgedMethod ;", "} else    {", "return   bridgeMethod ;", "}", "}", "METHOD_END"], "methodName": ["findBridgedMethod"], "fileName": "org.springframework.core.BridgeMethodResolver"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    superclass    =    bridgeMethod . getDeclaringClass (  )  . getSuperclass (  )  ;", "while    (  ( superclass    !  =    null )     &  &     (  ( Object . class )     !  =    superclass )  )     {", "Method   method    =     . searchForMatch ( superclass ,    bridgeMethod )  ;", "if    (  ( method    !  =    null )     &  &     (  !  ( method . isBridge (  )  )  )  )     {", "return   method ;", "}", "superclass    =    superclass . getSuperclass (  )  ;", "}", "Class <  ?  >  [  ]    interfaces    =    ClassUtils . getAllInterfacesForClass ( bridgeMethod . getDeclaringClass (  )  )  ;", "return    . searchInterfaces ( interfaces ,    bridgeMethod )  ;", "}", "METHOD_END"], "methodName": ["findGenericDeclaration"], "fileName": "org.springframework.core.BridgeMethodResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( BridgeMethodResolver . isResolvedTypeMatch ( candidateMethod ,    bridgeMethod ,    declaringClass )  )     {", "return   true ;", "}", "Method   method    =    BridgeMethodResolver . findGenericDeclaration ( bridgeMethod )  ;", "return    ( method    !  =    null )     &  &     ( BridgeMethodResolver . isResolvedTypeMatch ( method ,    candidateMethod ,    declaringClass )  )  ;", "}", "METHOD_END"], "methodName": ["isBridgeMethodFor"], "fileName": "org.springframework.core.BridgeMethodResolver"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  !  ( candidateMethod . isBridge (  )  )  )     &  &     (  !  ( candidateMethod . equals ( bridgeMethod )  )  )  )     &  &     ( candidateMethod . getName (  )  . equals ( bridgeMethod . getName (  )  )  )  )     &  &     (  ( candidateMethod . getParameterCount (  )  )     =  =     ( bridgeMethod . getParameterCount (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isBridgedCandidateFor"], "fileName": "org.springframework.core.BridgeMethodResolver"}, {"methodBody": ["METHOD_START", "{", "Type [  ]    genericParameters    =    genericMethod . getGenericParameterTypes (  )  ;", "Class <  ?  >  [  ]    candidateParameters    =    candidat . getParameterTypes (  )  ;", "if    (  ( genericParameters . length )     !  =     ( candidateParameters . length )  )     {", "return   false ;", "}", "for    ( int   i    =     0  ;    i    <     ( candidateParameters . length )  ;    i +  +  )     {", "ResolvableType   genericParameter    =    ResolvableType . forMethodParameter ( genericMethod ,    i ,    declaringClass )  ;", "Class <  ?  >    candidateParameter    =    candidateParameters [ i ]  ;", "if    ( candidateParameter . isArray (  )  )     {", "if    (  !  ( candidateParameter . getComponentType (  )  . equals ( genericParameter . getComponentType (  )  . resolve ( Object . class )  )  )  )     {", "return   false ;", "}", "}", "if    (  !  ( candidateParameter . equals ( genericParameter . resolve ( Object . class )  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isResolvedTypeMatch"], "fileName": "org.springframework.core.BridgeMethodResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( bridgeMethod    =  =    bridgedMethod )     {", "return   true ;", "}", "return    ( Arrays . equals ( bridgeMethod . getParameterTypes (  )  ,    bridgedMethod . getParameterTypes (  )  )  )     &  &     ( bridgeMethod . getReturnType (  )  . equals ( bridgedMethod . getReturnType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isVisibilityBridgeMethodPair"], "fileName": "org.springframework.core.BridgeMethodResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( candidateMethods . isEmpty (  )  )     {", "return   null ;", "}", "Method   previousMethod    =    null ;", "boolean   sameSig    =    true ;", "for    ( Method   candidateMethod    :    candidateMethods )     {", "if    (  . isBridgeMethodFor ( bridgeMethod ,    candidateMethod ,    bridgeMethod . getDeclaringClass (  )  )  )     {", "return   candidateMethod ;", "} else", "if    ( previousMethod    !  =    null )     {", "sameSig    =    sameSig    &  &     ( equals ( candidateMethod . getGenericParameterTypes (  )  ,    previousMethod . getGenericParameterTypes (  )  )  )  ;", "}", "previousMethod    =    candidateMethod ;", "}", "return   sameSig    ?    candidateMethods . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["searchCandidates"], "fileName": "org.springframework.core.BridgeMethodResolver"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   type . getDeclaredMethod ( b . getName (  )  ,    b . getParameterTypes (  )  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["searchForMatch"], "fileName": "org.springframework.core.BridgeMethodResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    ifc    :    interfaces )     {", "Method   method    =     . searchForMatch ( ifc ,    bridgeMethod )  ;", "if    (  ( method    !  =    null )     &  &     (  !  ( method . isBridge (  )  )  )  )     {", "return   method ;", "} else    {", "method    =     . searchInterfaces ( ifc . getInterfaces (  )  ,    bridgeMethod )  ;", "if    ( method    !  =    null )     {", "return   method ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["searchInterfaces"], "fileName": "org.springframework.core.BridgeMethodResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    clazz . getDeclaredMethods (  )  )     {", "Method   bridged    =    BridgeMethodResolver . findBridgedMethod ( method )  ;", "Method   expected    =    clazz . getMethod (  \" test \"  ,     . FooEntity . class )  ;", "assertEquals ( expected ,    bridged )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestHierarchyResolution"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    targetType . getMethods (  )  ;", "for    ( Method   m    :    methods )     {", "if    (  ( m . getName (  )  . equals ( name )  )     &  &     ( m . getReturnType (  )  . equals ( returnType )  )  )     {", "return   m ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findMethodWithReturnType"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "doTestHierarchyResolution ( BridgeMethodResolverTests . FooClass . class )  ;", "}", "METHOD_END"], "methodName": ["testClassHierarchy"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   objectBridge    =    BridgeMethodResolverTests . MyBoo . class . getDeclaredMethod (  \" foo \"  ,    Object . class )  ;", "Method   serializableBridge    =    BridgeMethodResolverTests . MyBoo . class . getDeclaredMethod (  \" foo \"  ,    Serializable . class )  ;", "Method   stringFoo    =    BridgeMethodResolverTests . MyBoo . class . getDeclaredMethod (  \" foo \"  ,    String . class )  ;", "Method   integerFoo    =    BridgeMethodResolverTests . MyBoo . class . getDeclaredMethod (  \" foo \"  ,    Integer . class )  ;", "assertEquals (  \" foo ( String )    not   resolved .  \"  ,    stringFoo ,    BridgeMethodResolver . findBridgedMethod ( objectBridge )  )  ;", "assertEquals (  \" foo ( Integer )    not   resolved .  \"  ,    integerFoo ,    BridgeMethodResolver . findBridgedMethod ( serializableBridge )  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleParameterization"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   unbridged    =    BridgeMethodResolverTests . MyFoo . class . getDeclaredMethod (  \" someMethod \"  ,    String . class ,    Object . class )  ;", "Method   bridged    =    BridgeMethodResolverTests . MyFoo . class . getDeclaredMethod (  \" someMethod \"  ,    Serializable . class ,    Object . class )  ;", "assertFalse ( unbridged . isBridge (  )  )  ;", "assertTrue ( bridged . isBridge (  )  )  ;", "assertEquals (  \" Unbridged   method   not   returned   directly \"  ,    unbridged ,    BridgeMethodResolver . findBridgedMethod ( unbridged )  )  ;", "assertEquals (  \" Incorrect   bridged   method   returned \"  ,    unbridged ,    BridgeMethodResolver . findBridgedMethod ( bridged )  )  ;", "}", "METHOD_END"], "methodName": ["testFindBridgedMethod"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   loadWithObjectReturn    =    BridgeMethodResolverTests . findMethodWithReturnType (  \" load \"  ,    Object . class ,    BridgeMethodResolverTests . SettingsDaoImpl . class )  ;", "assertNotNull ( loadWithObjectReturn )  ;", "Method   loadWithSettingsReturn    =    BridgeMethodResolverTests . findMethodWithReturnType (  \" load \"  ,    BridgeMethodResolverTests . Settings . class ,    BridgeMethodResolverTests . SettingsDaoImpl . class )  ;", "assertNotNull ( loadWithSettingsReturn )  ;", "assertNotSame ( loadWithObjectReturn ,    loadWithSettingsReturn )  ;", "Method   method    =    BridgeMethodResolverTests . SettingsDaoImpl . class . getMethod (  \" load \"  )  ;", "assertEquals ( method ,    BridgeMethodResolver . findBridgedMethod ( loadWithObjectReturn )  )  ;", "assertEquals ( method ,    BridgeMethodResolver . findBridgedMethod ( loadWithSettingsReturn )  )  ;", "}", "METHOD_END"], "methodName": ["testFindBridgedMethodFromMultipleBridges"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   loadFromParentBridge    =    BridgeMethodResolverTests . SettingsDaoImpl . class . getMethod (  \" loadFromParent \"  )  ;", "assertTrue ( loadFromParentBridge . isBridge (  )  )  ;", "Method   loadFromParent    =    BridgeMethodResolverTests . AbstractDaoImpl . class . getMethod (  \" loadFromParent \"  )  ;", "assertFalse ( loadFromParent . isBridge (  )  )  ;", "assertEquals ( loadFromParent ,    BridgeMethodResolver . findBridgedMethod ( loadFromParentBridge )  )  ;", "}", "METHOD_END"], "methodName": ["testFindBridgedMethodFromParent"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgeMethod    =    BridgeMethodResolverTests . DateAdder . class . getMethod (  \" add \"  ,    Object . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "Method   bridgedMethod    =    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "assertEquals (  \" add \"  ,    bridgedMethod . getName (  )  )  ;", "assertEquals (  1  ,    bridgedMethod . getParameterCount (  )  )  ;", "assertEquals ( Date . class ,    bridgedMethod . getParameterTypes (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testFindBridgedMethodInHierarchy"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   unbridged    =    BridgeMethodResolverTests . MyFoo . class . getDeclaredMethod (  \" someVarargMethod \"  ,    String . class ,    Object [  ]  . class )  ;", "Method   bridged    =    BridgeMethodResolverTests . MyFoo . class . getDeclaredMethod (  \" someVarargMethod \"  ,    Serializable . class ,    Object [  ]  . class )  ;", "assertFalse ( unbridged . isBridge (  )  )  ;", "assertTrue ( bridged . isBridge (  )  )  ;", "assertEquals (  \" Unbridged   method   not   returned   directly \"  ,    unbridged ,    BridgeMethodResolver . findBridgedMethod ( unbridged )  )  ;", "assertEquals (  \" Incorrect   bridged   method   returned \"  ,    unbridged ,    BridgeMethodResolver . findBridgedMethod ( bridged )  )  ;", "}", "METHOD_END"], "methodName": ["testFindBridgedVarargMethod"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "doTestHierarchyResolution ( BridgeMethodResolverTests . FooInterface . class )  ;", "}", "METHOD_END"], "methodName": ["testInterfaceHierarchy"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridged    =    BridgeMethodResolverTests . MyBar . class . getDeclaredMethod (  \" someMethod \"  ,    String . class ,    Object . class )  ;", "Method   other    =    BridgeMethodResolverTests . MyBar . class . getDeclaredMethod (  \" someMethod \"  ,    Integer . class ,    Object . class )  ;", "Method   bridge    =    BridgeMethodResolverTests . MyBar . class . getDeclaredMethod (  \" someMethod \"  ,    Object . class ,    Object . class )  ;", "assertTrue (  \" Should   be   bridge   method \"  ,    BridgeMethodResolver . isBridgeMethodFor ( bridge ,    bridged ,    BridgeMethodResolverTests . MyBar . class )  )  ;", "assertFalse (  \" Should   not   be   bridge   method \"  ,    BridgeMethodResolver . isBridgeMethodFor ( bridge ,    other ,    BridgeMethodResolverTests . MyBar . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIsBridgeMethodFor"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    BridgeMethodResolverTests . StringList . class . getMethods (  )  ;", "for    ( Method   method    :    methods )     {", "assertNotNull ( BridgeMethodResolver . findBridgedMethod ( method )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testOnAllMethods"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgedMethod    =    BridgeMethodResolverTests . MessageBroadcasterImpl . class . getMethod (  \" receive \"  ,    BridgeMethodResolverTests . MessageEvent . class )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "Method   bridgeMethod    =    BridgeMethodResolverTests . MessageBroadcasterImpl . class . getMethod (  \" receive \"  ,    BridgeMethodResolverTests . Event . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "Method   otherMethod    =    BridgeMethodResolverTests . MessageBroadcasterImpl . class . getMethod (  \" receive \"  ,    BridgeMethodResolverTests . NewMessageEvent . class )  ;", "assertFalse ( otherMethod . isBridge (  )  )  ;", "assertFalse (  \" Match   identified   incorrectly \"  ,    BridgeMethodResolver . isBridgeMethodFor ( bridgeMethod ,    otherMethod ,    BridgeMethodResolverTests . MessageBroadcasterImpl . class )  )  ;", "assertTrue (  \" Match   not   found   correctly \"  ,    BridgeMethodResolver . isBridgeMethodFor ( bridgeMethod ,    bridgedMethod ,    BridgeMethodResolverTests . MessageBroadcasterImpl . class )  )  ;", "assertEquals ( bridgedMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR2583"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   objectBridge    =    BridgeMethodResolverTests . YourHomer . class . getDeclaredMethod (  \" foo \"  ,    BridgeMethodResolverTests . Bounded . class )  ;", "Method   abstractBoundedFoo    =    BridgeMethodResolverTests . YourHomer . class . getDeclaredMethod (  \" foo \"  ,    BridgeMethodResolverTests . AbstractBounded . class )  ;", "Method   bridgedMethod    =    BridgeMethodResolver . findBridgedMethod ( objectBridge )  ;", "assertEquals (  \" foo ( AbstractBounded )    not   resolved .  \"  ,    abstractBoundedFoo ,    bridgedMethod )  ;", "}", "METHOD_END"], "methodName": ["testSPR2603"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgeMethod    =    ReflectionUtils . findMethod ( BridgeMethodResolverTests . GenericSqlMapIntegerDao . class ,     \" saveOrUpdate \"  ,    Object . class )  ;", "assertTrue (  (  ( bridgeMethod    !  =    null )     &  &     ( bridgeMethod . isBridge (  )  )  )  )  ;", "Method   bridgedMethod    =    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "assertEquals (  \" saveOrUpdate \"  ,    bridgedMethod . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR2648"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgedMethod    =    BridgeMethodResolverTests . AbstractDao . class . getDeclaredMethod (  \" save \"  ,    Object . class )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "Method   bridgeMethod    =    BridgeMethodResolverTests . UserDaoImpl . class . getDeclaredMethod (  \" save \"  ,    BridgeMethodResolverTests . User . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "assertEquals ( bridgedMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR2763"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgedMethod    =    BridgeMethodResolverTests . BusinessDao . class . getDeclaredMethod (  \" save \"  ,    BridgeMethodResolverTests . Business . class )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "Method   bridgeMethod    =    BridgeMethodResolverTests . BusinessDao . class . getDeclaredMethod (  \" save \"  ,    Object . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "assertEquals ( bridgedMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR3041"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgedMethod    =    BridgeMethodResolverTests . UserDaoImpl . class . getDeclaredMethod (  \" saveVararg \"  ,    BridgeMethodResolverTests . User . class ,    Object [  ]  . class )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "Method   bridgeMethod    =    BridgeMethodResolverTests . UserDaoImpl . class . getDeclaredMethod (  \" saveVararg \"  ,    Object . class ,    Object [  ]  . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "assertEquals ( bridgedMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR3173"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgedMethod    =    BridgeMethodResolverTests . MegaMessageProducerImpl . class . getDeclaredMethod (  \" receive \"  ,    BridgeMethodResolverTests . MegaMessageEvent . class )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "Method   bridgeMethod    =    BridgeMethodResolverTests . MegaMessageProducerImpl . class . getDeclaredMethod (  \" receive \"  ,    BridgeMethodResolverTests . MegaEvent . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "assertEquals ( bridgedMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR3304"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgedMethod    =    BridgeMethodResolverTests . BusinessDao . class . getDeclaredMethod (  \" get \"  ,    Long . class )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "Method   bridgeMethod    =    BridgeMethodResolverTests . BusinessDao . class . getDeclaredMethod (  \" get \"  ,    Object . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "assertEquals ( bridgedMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR3324"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgedMethod    =    BridgeMethodResolverTests . ExtendsAbstractImplementsInterface . class . getDeclaredMethod (  \" doSomething \"  ,    BridgeMethodResolverTests . DomainObjectExtendsSuper . class ,    Object . class )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "Method   bridgeMethod    =    BridgeMethodResolverTests . ExtendsAbstractImplementsInterface . class . getDeclaredMethod (  \" doSomething \"  ,    BridgeMethodResolverTests . DomainObjectSuper . class ,    Object . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "assertEquals ( bridgedMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR3357"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgedMethod    =    BridgeMethodResolverTests . DomainObject . class . getDeclaredMethod (  \" method 2  \"  ,    BridgeMethodResolverTests . ParameterType . class ,    byte [  ]  . class )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "Method   bridgeMethod    =    BridgeMethodResolverTests . DomainObject . class . getDeclaredMethod (  \" method 2  \"  ,    Serializable . class ,    Object . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "assertEquals ( bridgedMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR3485"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgeMethod    =    ReflectionUtils . findMethod ( BridgeMethodResolverTests . TestEmailProvider . class ,     \" findBy \"  ,    Object . class )  ;", "assertTrue (  (  ( bridgeMethod    !  =    null )     &  &     ( bridgeMethod . isBridge (  )  )  )  )  ;", "Method   bridgedMethod    =    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "assertEquals (  \" findBy \"  ,    bridgedMethod . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSPR3534"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgeMethod    =    BridgeMethodResolverTests . SerializableBounded . class . getMethod (  \" boundedOperation \"  ,    Object . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "Method   actualMethod    =    BridgeMethodResolverTests . SerializableBounded . class . getMethod (  \" boundedOperation \"  ,    HashMap . class )  ;", "assertFalse ( actualMethod . isBridge (  )  )  ;", "assertEquals ( actualMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testWithDoubleBoundParameterizedOnInstantiate"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    BridgeMethodResolverTests . StringGenericParameter . class . getMethods (  )  ;", "Method   bridgeMethod    =    null ;", "Method   bridgedMethod    =    null ;", "for    ( Method   method    :    methods )     {", "if    (  (  \" getFor \"  . equals ( method . getName (  )  )  )     &  &     (  !  ( method . getParameterTypes (  )  [  0  ]  . equals ( Integer . class )  )  )  )     {", "if    ( method . getReturnType (  )  . equals ( Object . class )  )     {", "bridgeMethod    =    method ;", "} else    {", "bridgedMethod    =    method ;", "}", "}", "}", "assertTrue (  (  ( bridgeMethod    !  =    null )     &  &     ( bridgeMethod . isBridge (  )  )  )  )  ;", "assertTrue (  (  ( bridgedMethod    !  =    null )     &  &     (  !  ( bridgedMethod . isBridge (  )  )  )  )  )  ;", "assertEquals ( bridgedMethod ,    BridgeMethodResolver . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testWithGenericParameter"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgeMethod    =    DelayQueue . class . getMethod (  \" add \"  ,    Object . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "Method   actualMethod    =    DelayQueue . class . getMethod (  \" add \"  ,    Delayed . class )  ;", "assertFalse ( actualMethod . isBridge (  )  )  ;", "assertEquals ( actualMethod ,     . findBridgedMethod ( bridgeMethod )  )  ;", "}", "METHOD_END"], "methodName": ["testWithSingleBoundParameterizedOnInstantiate"], "fileName": "org.springframework.core.BridgeMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( enumType ,     \" Enum   type   must   not   be   null \"  )  ;", "if    (  !  ( Enum . class . isAssignableFrom ( enumType )  )  )     {", "throw   new   IllegalArgumentExcep (  (  \" Supplied   type   is   not   an   enum :     \"     +     ( enumType . getName (  )  )  )  )  ;", "}", "return   enumType . asSubclass ( Enum . class )  ;", "}", "METHOD_END"], "methodName": ["asEnumType"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( collection   instanceof   LinkedList )     {", "return   new   LinkedList <  >  (  )  ;", "} else", "if    ( collection   instanceof   List )     {", "return   new   ArrayList <  >  ( capacity )  ;", "} else", "if    ( collection   instanceof   EnumSet )     {", "util < E >    enumSet    =     (  ( util < E >  )     ( copyOf (  (  ( EnumSet )     ( collection )  )  )  )  )  ;", "enumSet . clear (  )  ;", "return   enumSet ;", "} else", "if    ( collection   instanceof   SortedSet )     {", "return   new   TreeSet <  >  (  (  ( SortedSet < E >  )     ( collection )  )  . comparator (  )  )  ;", "} else    {", "return   new   LinkedHashSet <  >  ( capacity )  ;", "}", "}", "METHOD_END"], "methodName": ["createApproximateCollection"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( map   instanceof   EnumMap )     {", "EnumMap   enumMap    =    new   EnumMap (  (  ( EnumMap )     ( map )  )  )  ;", "enumMap . clear (  )  ;", "return   enumMap ;", "} else", "if    ( map   instanceof   SortedMap )     {", "return   new   TreeMap <  >  (  (  ( SortedMap < K ,    V >  )     ( map )  ) mparator (  )  )  ;", "} else    {", "return   new   LinkedHashMap <  >  ( capacity )  ;", "}", "}", "METHOD_END"], "methodName": ["createApproximateMap"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   CollectionFactory . createCollection ( collectionType ,    null ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["createCollection"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( collectionType ,     \" Collection   type   must   not   be   null \"  )  ;", "if    ( collectionType . isInterface (  )  )     {", "if    (  (  ( Set . class )     =  =    collectionType )     |  |     (  ( Collection . class )     =  =    collectionType )  )     {", "return   new   LinkedHashSet <  >  ( capacity )  ;", "} else", "if    (  ( class )     =  =    collectionType )     {", "return   new   ArrayList <  >  ( capacity )  ;", "} else", "if    (  (  ( class )     =  =    collectionType )     |  |     (  ( class )     =  =    collectionType )  )     {", "return   new   TreeSet <  >  (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unsupported   Collection   interface :     \"     +     ( collectionType . getName (  )  )  )  )  ;", "}", "} else", "if    (  ( class )     =  =    collectionType )     {", "Assert . notNull ( elementType ,     \" Cannot   create   EnumSet   for   unknown   element   type \"  )  ;", "return    (  ( Collection < E >  )     ( noneOf ( CollectionFactory . asEnumType ( elementType )  )  )  )  ;", "} else    {", "if    (  !  ( Collection . class . isAssignableFrom ( collectionType )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Unsupported   Collection   type :     \"     +     ( collectionType . getName (  )  )  )  )  ;", "}", "try    {", "return    (  ( Collection < E >  )     ( util . ReflectionUtils . accessibleConstructor ( collectionType )  . newInstance (  )  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  \" Could   not   instantiate   Collection   type :     \"     +     ( collectionType . getName (  )  )  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createCollection"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   CollectionFactory . createMap ( mapType ,    null ,    capacity )  ;", "}", "METHOD_END"], "methodName": ["createMap"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mapType ,     \" Map   type   must   not   be   null \"  )  ;", "if    ( mapType . isInterface (  )  )     {", "if    (  ( Map . class )     =  =    mapType )     {", "return   new   LinkedHashMap <  >  ( capacity )  ;", "} else", "if    (  (  ( class )     =  =    mapType )     |  |     (  ( class )     =  =    mapType )  )     {", "return   new   TreeMap <  >  (  )  ;", "} else", "if    (  ( util . MultiValueMap . class )     =  =    mapType )     {", "return   new   util . LinkedMultiValueMap (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unsupported   Map   interface :     \"     +     ( mapType . getName (  )  )  )  )  ;", "}", "} else", "if    (  ( class )     =  =    mapType )     {", "Assert . notNull ( keyType ,     \" Cannot   create   EnumMap   for   unknown   key   type \"  )  ;", "return   new   EnumMap ( CollectionFactory . asEnumType ( keyType )  )  ;", "} else    {", "if    (  !  ( Map . class . isAssignableFrom ( mapType )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Unsupported   Map   type :     \"     +     ( mapType . getName (  )  )  )  )  ;", "}", "try    {", "return    (  ( Map < K ,    V >  )     ( util . ReflectionUtils . accessibleConstructor ( mapType )  . newInstance (  )  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  \" Could   not   instantiate   Map   type :     \"     +     ( mapType . getName (  )  )  )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createMap"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   Properties (  )     {", "@ Override", "@ Nullable", "public   St   getProperty ( St   key )     {", "Object   value    =    get ( key )  ;", "return   value    !  =    null    ?    value . toSt (  )     :    null ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createStringAdaptingProperties"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( collectionType    !  =    null )     &  &     ( CollectionFactory . approximableCollectionTypes . contains ( collectionType )  )  ;", "}", "METHOD_END"], "methodName": ["isApproximableCollectionType"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( mapType    !  =    null )     &  &     ( CollectionFactory . approximableMapTypes . contains ( mapType )  )  ;", "}", "METHOD_END"], "methodName": ["isApproximableMapType"], "fileName": "org.springframework.core.CollectionFactory"}, {"methodBody": ["METHOD_START", "{", "Collection < CollectionFactoryTests . Color >    colors    =    CollectionFactory . createApproximateCollection ( EnumSet . noneOf ( CollectionFactoryTests . Color . class )  ,     2  )  ;", "assertThat ( colors ,    is ( empty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createApproximateCollectionFromEmptyEnumSet"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    set    =    CollectionFactory . createApproximateCollection ( new   HashSet < String >  (  )  ,     2  )  ;", "assertThat ( set ,    is ( empty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createApproximateCollectionFromEmptyHashSet"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Collection < CollectionFactoryTests . Color >    colors    =    CollectionFactory . createApproximateCollection ( EnumSet . of ( CollectionFactoryTests . Color . BLUE )  ,     2  )  ;", "assertThat ( colors ,    is ( empty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createApproximateCollectionFromNonEmptyEnumSet"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "HashSet < String >    hashSet    =    new   HashSet <  >  (  )  ;", "hashSet . add (  \" foo \"  )  ;", "Collection < String >    set    =     . createApproximateCollection ( hashSet ,     2  )  ;", "assertThat ( set ,    is ( empty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createApproximateCollectionFromNonEmptyHashSet"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Collection < Integer >    ints    =    CollectionFactory . createApproximateCollection ( EnumSet . of ( CollectionFactoryTests . Color . BLUE )  ,     3  )  ;", "try    {", "ints . add (  4  2  )  ;", "fail (  \" Should   have   thrown   a   ClassCastException \"  )  ;", "}    catch    ( ClassCastException   e )     {", "}", "}", "METHOD_END"], "methodName": ["createApproximateCollectionIsNotTypeSafeForEnumSet"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Map < CollectionFactoryTests . Color ,    String >    colors    =    CollectionFactory . createApproximateMap ( new   EnumMap < CollectionFactoryTests . Color ,    String >  ( CollectionFactoryTests . Color . class )  ,     2  )  ;", "assertThat ( colors . size (  )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["createApproximateMapFromEmptyEnumMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    CollectionFactory . createApproximateMap ( new   HashMap < String ,    String >  (  )  ,     2  )  ;", "assertThat ( map . size (  )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["createApproximateMapFromEmptyHashMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "EnumMap < CollectionFactoryTests . Color ,    String >    enumMap    =    new   EnumMap <  >  ( CollectionFactoryTests . Color . class )  ;", "enumMap . put ( CollectionFactoryTests . Color . BLUE ,     \" blue \"  )  ;", "Map < CollectionFactoryTests . Color ,    String >    colors    =    CollectionFactory . createApproximateMap ( enumMap ,     2  )  ;", "assertThat ( colors . size (  )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["createApproximateMapFromNonEmptyEnumMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    hashMap    =    new   HashMap <  >  (  )  ;", "hashMap . put (  \" foo \"  ,     \" bar \"  )  ;", "Map < String ,    String >    map    =     . createApproximateMap ( hashMap ,     2  )  ;", "assertThat ( map . size (  )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["createApproximateMapFromNonEmptyHashMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "EnumMap < CollectionFactoryTests . Color ,    Integer >    enumMap    =    new   EnumMap <  >  ( CollectionFactoryTests . Color . class )  ;", "enumMap . put ( CollectionFactoryTests . Color . RED ,     1  )  ;", "enumMap . put ( CollectionFactoryTests . Color . BLUE ,     2  )  ;", "Map < String ,    Integer >    map    =    CollectionFactory . createApproximateMap ( enumMap ,     3  )  ;", "try    {", "map . put (  \" foo \"  ,     1  )  ;", "fail (  \" Should   have   thrown   a   ClassCastException \"  )  ;", "}    catch    ( ClassCastException   e )     {", "}", "}", "METHOD_END"], "methodName": ["createApproximateMapIsNotTypeSafeForEnumMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Collection < Integer >    ints    =    CollectionFactory . createCollection ( EnumSet . class ,    CollectionFactoryTests . Color . class ,     3  )  ;", "try    {", "ints . add (  4  2  )  ;", "fail (  \" Should   have   thrown   a   ClassCastException \"  )  ;", "}    catch    ( ClassCastException   e )     {", "}", "}", "METHOD_END"], "methodName": ["createCollectionIsNotTypeSafeForEnumSet"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Integer >    map    =    CollectionFactory . createMap ( EnumMap . class ,    CollectionFactoryTests . Color . class ,     3  )  ;", "try    {", "map . put (  \" foo \"  ,     1  )  ;", "fail (  \" Should   have   thrown   a   ClassCastException \"  )  ;", "}    catch    ( ClassCastException   e )     {", "}", "}", "METHOD_END"], "methodName": ["createMapIsNotTypeSafeForEnumMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Integer >    map    =    CollectionFactory . createMap ( MultiValueMap . class ,    null ,     3  )  ;", "try    {", "map . put (  \" foo \"  ,     1  )  ;", "fail (  \" Should   have   thrown   a   ClassCastException \"  )  ;", "}    catch    ( ClassCastException   e )     {", "}", "}", "METHOD_END"], "methodName": ["createMapIsNotTypeSafeForLinkedMultiValueMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( CollectionFactory . createCollection ( List . class ,     0  )  ,    is ( instanceOf ( ArrayList . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( Set . class ,     0  )  ,    is ( instanceOf ( LinkedHashSet . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( Collection . class ,     0  )  ,    is ( instanceOf ( LinkedHashSet . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( SortedSet . class ,     0  )  ,    is ( instanceOf ( TreeSet . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( NavigableSet . class ,     0  )  ,    is ( instanceOf ( TreeSet . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( List . class ,    String . class ,     0  )  ,    is ( instanceOf ( ArrayList . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( Set . class ,    String . class ,     0  )  ,    is ( instanceOf ( LinkedHashSet . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( Collection . class ,    String . class ,     0  )  ,    is ( instanceOf ( LinkedHashSet . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( SortedSet . class ,    String . class ,     0  )  ,    is ( instanceOf ( TreeSet . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( NavigableSet . class ,    String . class ,     0  )  ,    is ( instanceOf ( TreeSet . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( HashSet . class ,     0  )  ,    is ( instanceOf ( HashSet . class )  )  )  ;", "assertThat ( CollectionFactory . createCollection ( HashSet . class ,    String . class ,     0  )  ,    is ( instanceOf ( HashSet . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["createsCollectionsCorrectly"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( CollectionFactory . createMap ( EnumMap . class ,    CollectionFactoryTests . Color . class ,     0  )  ,    is ( instanceOf ( EnumMap . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["createsEnumMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( CollectionFactory . createCollection ( EnumSet . class ,    CollectionFactoryTests . Color . class ,     0  )  ,    is ( instanceOf ( EnumSet . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["createsEnumSet"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( CollectionFactory . createMap ( Map . class ,     0  )  ,    is ( instanceOf ( LinkedHashMap . class )  )  )  ;", "assertThat ( CollectionFactory . createMap ( SortedMap . class ,     0  )  ,    is ( instanceOf ( TreeMap . class )  )  )  ;", "assertThat ( CollectionFactory . createMap ( NavigableMap . class ,     0  )  ,    is ( instanceOf ( TreeMap . class )  )  )  ;", "assertThat ( CollectionFactory . createMap ( MultiValueMap . class ,     0  )  ,    is ( instanceOf ( LinkedMultiValueMap . class )  )  )  ;", "assertThat ( CollectionFactory . createMap ( Map . class ,    String . class ,     0  )  ,    is ( instanceOf ( LinkedHashMap . class )  )  )  ;", "assertThat ( CollectionFactory . createMap ( SortedMap . class ,    String . class ,     0  )  ,    is ( instanceOf ( TreeMap . class )  )  )  ;", "assertThat ( CollectionFactory . createMap ( NavigableMap . class ,    String . class ,     0  )  ,    is ( instanceOf ( TreeMap . class )  )  )  ;", "assertThat ( CollectionFactory . createMap ( MultiValueMap . class ,    String . class ,     0  )  ,    is ( instanceOf ( LinkedMultiValueMap . class )  )  )  ;", "assertThat ( CollectionFactory . createMap ( HashMap . class ,     0  )  ,    is ( instanceOf ( HashMap . class )  )  )  ;", "assertThat ( CollectionFactory . createMap ( HashMap . class ,    String . class ,     0  )  ,    is ( instanceOf ( HashMap . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["createsMapsCorrectly"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "CollectionFactory . createCollection ( EnumSet . class ,    Object . class ,     0  )  ;", "}", "METHOD_END"], "methodName": ["rejectsInvalidElementTypeForEnumSet"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "CollectionFactory . createMap ( EnumMap . class ,    Object . class ,     0  )  ;", "}", "METHOD_END"], "methodName": ["rejectsInvalidKeyTypeForEnumMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "CollectionFactory . createCollection ( null ,    Object . class ,     0  )  ;", "}", "METHOD_END"], "methodName": ["rejectsNullCollectionType"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "CollectionFactory . createCollection ( EnumSet . class ,    null ,     0  )  ;", "}", "METHOD_END"], "methodName": ["rejectsNullElementTypeForEnumSet"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "CollectionFactory . createMap ( EnumMap . class ,    null ,     0  )  ;", "}", "METHOD_END"], "methodName": ["rejectsNullKeyTypeForEnumMap"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "CollectionFactory . createMap ( null ,    Object . class ,     0  )  ;", "}", "METHOD_END"], "methodName": ["rejectsNullMapType"], "fileName": "org.springframework.core.CollectionFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getFallbackClassLoader"], "fileName": "org.springframework.core.ConfigurableObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "throw   ex ;", "}", "METHOD_END"], "methodName": ["resolveFallbackIfPossible"], "fileName": "org.springframework.core.ConfigurableObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "Object   obj    =    asObject ( code )  ;", "if    (  !  ( obj   instanceof   Number )  )     {", "throw   newsException ( this . className ,    code ,     \" not   a   Number \"  )  ;", "}", "return    (  ( Number )     ( obj )  )  ;", "}", "METHOD_END"], "methodName": ["asNumber"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( code ,     \" Code   must   not   be   null \"  )  ;", "String   codeToUse    =    code . toUpperCase ( Locale . ENGLISH )  ;", "Object   val    =    this . fieldCache . get ( codeToUse )  ;", "if    ( val    =  =    null )     {", "throw   newsException ( this . className ,    codeToUse ,     \" not   found \"  )  ;", "}", "return   val ;", "}", "METHOD_END"], "methodName": ["asObject"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "return   asObject ( code )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["asString"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "return   this . className ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "return   this . fieldCache ;", "}", "METHOD_END"], "methodName": ["getFieldCache"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "String   prefixToUse    =     ( namePrefix    !  =    null )     ?    namePrefix . trim (  )  . toUpperCase ( Locale . ENGLISH )     :     \"  \"  ;", "Set < String >    names    =    new   HashSet <  >  (  )  ;", "for    ( String   code    :    this . fieldCache . keySet (  )  )     {", "if    ( code . startsWith ( prefixToUse )  )     {", "names . add ( code )  ;", "}", "}", "return   names ;", "}", "METHOD_END"], "methodName": ["getNames"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "return   getNames ( propertyToConstantNamePrefix ( propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["getNamesForProperty"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "String   suffixToUse    =     ( nameSuffix    !  =    null )     ?    nameSuffix . trim (  )  . toUpperCase ( Locale . ENGLISH )     :     \"  \"  ;", "Set < String >    names    =    new   HashSet <  >  (  )  ;", "for    ( String   code    :    this . fieldCache . keySet (  )  )     {", "if    ( code . endsWith ( suffixToUse )  )     {", "names . add ( code )  ;", "}", "}", "return   names ;", "}", "METHOD_END"], "methodName": ["getNamesForSuffix"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "return   this . fieldCache . size (  )  ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "String   prefixToUse    =     ( namePrefix    !  =    null )     ?    namePrefix . trim (  )  . toUpperCase ( Locale . ENGLISH )     :     \"  \"  ;", "Set < Object >    values    =    new   HashSet <  >  (  )  ;", "this . fieldCache . forEach (  (    code ,    value )     -  >     {", "if    ( code . startsWith ( prefixToUse )  )     {", "values . add ( value )  ;", "}", "}  )  ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "return   getValues ( propertyToConstantNamePrefix ( propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["getValuesForProperty"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "String   suffixToUse    =     ( nameSuffix    !  =    null )     ?    nameSuffix . trim (  )  . toUpperCase ( Locale . ENGLISH )     :     \"  \"  ;", "Set < Object >    values    =    new   HashSet <  >  (  )  ;", "this . fieldCache . forEach (  (    code ,    value )     -  >     {", "if    ( code . endsWith ( suffixToUse )  )     {", "values . add ( value )  ;", "}", "}  )  ;", "return   values ;", "}", "METHOD_END"], "methodName": ["getValuesForSuffix"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   parsedPrefix    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( propertyName . length (  )  )  ;    i +  +  )     {", "char   c    =    propertyName . charAt ( i )  ;", "if    ( Character . isUpperCase ( c )  )     {", "parsedPrefix . append (  \"  _  \"  )  ;", "parsedPrefix . append ( c )  ;", "} else    {", "parsedPrefix . append ( Character . toUpperCase ( c )  )  ;", "}", "}", "return   parsedPrefix . toString (  )  ;", "}", "METHOD_END"], "methodName": ["propertyToConstantNamePrefix"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "String   prefixToUse    =     ( namePrefix    !  =    null )     ?    namePrefix . trim (  )  . toUpperCase ( Locale . ENGLISH )     :     \"  \"  ;", "for    ( Map . Entry < String ,    Object >    entry    :    this . fieldCache . entrySet (  )  )     {", "if    (  ( entry . getKey (  )  . startsWith ( prefixToUse )  )     &  &     ( entry . getValue (  )  . equals ( value )  )  )     {", "return   entry . getKey (  )  ;", "}", "}", "throw   newsException ( this . className ,    prefixToUse ,    value )  ;", "}", "METHOD_END"], "methodName": ["toCode"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "return   toCode ( value ,    propertyToConstantNamePrefix ( propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["toCodeForProperty"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "String   suffixToUse    =     ( nameSuffix    !  =    null )     ?    nameSuffix . trim (  )  . toUpperCase ( Locale . ENGLISH )     :     \"  \"  ;", "for    ( Map . Entry < String ,    Object >    entry    :    this . fieldCache . entrySet (  )  )     {", "if    (  ( entry . getKey (  )  . endsWith ( suffixToUse )  )     &  &     ( entry . getValue (  )  . equals ( value )  )  )     {", "return   entry . getKey (  )  ;", "}", "}", "throw   newsException ( this . className ,    suffixToUse ,    value )  ;", "}", "METHOD_END"], "methodName": ["toCodeForSuffix"], "fileName": "org.springframework.core.Constants"}, {"methodBody": ["METHOD_START", "{", "Constants   c    =    new   Constants ( ConstantsTests . A . class )  ;", "assertEquals ( ConstantsTests . A . class . getName (  )  ,    c . getClassName (  )  )  ;", "assertEquals (  9  ,    c . getSize (  )  )  ;", "assertEquals ( ConstantsTests . A . DOG ,    c . asNumber (  \" DOG \"  )  . intValue (  )  )  ;", "assertEquals ( ConstantsTests . A . DOG ,    c . asNumber (  \" dog \"  )  . intValue (  )  )  ;", "assertEquals ( ConstantsTests . A . CAT ,    c . asNumber (  \" cat \"  )  . intValue (  )  )  ;", "try    {", "c . asNumber (  \" bogus \"  )  ;", "fail (  \" Can ' t   get   bogus   field \"  )  ;", "}    catch    ( Constants . ConstantException   expected )     {", "}", "assertTrue ( c . asString (  \" S 1  \"  )  . equals ( ConstantsTests . A . S 1  )  )  ;", "try    {", "c . asNumber (  \" S 1  \"  )  ;", "fail (  \" Wrong   type \"  )  ;", "}    catch    ( Constants . ConstantException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["constants"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    ( null )  ;", "fail (  \" Must   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["ctorWithNullClass"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Constants   c    =    new   Constants ( ConstantsTests . A . class )  ;", "Set <  ?  >    names    =    c . getNames (  \"  \"  )  ;", "assertEquals ( c . getSize (  )  ,    names . size (  )  )  ;", "assertTrue ( names . contains (  \" DOG \"  )  )  ;", "assertTrue ( names . contains (  \" CAT \"  )  )  ;", "assertTrue ( names . contains (  \" S 1  \"  )  )  ;", "names    =    c . getNames (  \" D \"  )  ;", "assertEquals (  1  ,    names . size (  )  )  ;", "assertTrue ( names . contains (  \" DOG \"  )  )  ;", "names    =    c . getNames (  \" d \"  )  ;", "assertEquals (  1  ,    names . size (  )  )  ;", "assertTrue ( names . contains (  \" DOG \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getNames"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Constants   c    =    new   Constants ( ConstantsTests . A . class )  ;", "Set <  ?  >    values    =    c . getValues (  \"  \"  )  ;", "assertEquals (  7  ,    values . size (  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  0  )  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  6  6  )  )  )  ;", "assertTrue ( values . contains (  \"  \"  )  )  ;", "values    =    c . getValues (  \" D \"  )  ;", "assertEquals (  1  ,    values . size (  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  0  )  )  )  ;", "values    =    c . getValues (  \" prefix \"  )  ;", "assertEquals (  2  ,    values . size (  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  1  )  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  2  )  )  )  ;", "values    =    c . getValuesForProperty (  \" myProperty \"  )  ;", "assertEquals (  2  ,    values . size (  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  1  )  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Locale   oldLocale    =    Locale . getDefault (  )  ;", "Locale . setDefault ( new   Locale (  \" tr \"  ,     \"  \"  )  )  ;", "try    {", "Constants   c    =    new   Constants (  . A . class )  ;", "Set <  ?  >    values    =    c . getValues (  \"  \"  )  ;", "assertEquals (  7  ,    values . size (  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  0  )  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  6  6  )  )  )  ;", "assertTrue ( values . contains (  \"  \"  )  )  ;", "values    =    c . getValues (  \" D \"  )  ;", "assertEquals (  1  ,    values . size (  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  0  )  )  )  ;", "values    =    c . getValues (  \" prefix \"  )  ;", "assertEquals (  2  ,    values . size (  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  1  )  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  2  )  )  )  ;", "values    =    c . getValuesForProperty (  \" myProperty \"  )  ;", "assertEquals (  2  ,    values . size (  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  1  )  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  2  )  )  )  ;", "}    finally    {", "Locale . setDefault ( oldLocale )  ;", "}", "}", "METHOD_END"], "methodName": ["getValuesInTurkey"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Constants   c    =    new   Constants ( ConstantsTests . A . class )  ;", "Set < Object >    values    =    c . getValues (  \"  \"  )  ;", "assertEquals (  \" Must   have   returned    * all *    public   static   final   values \"  ,     7  ,    values . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getValuesWithEmptyStringPrefix"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Constants   c    =    new   Constants ( ConstantsTests . A . class )  ;", "Set <  ?  >    values    =    c . getValues ( null )  ;", "assertEquals (  \" Must   have   returned    * all *    public   static   final   values \"  ,     7  ,    values . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getValuesWithNullPrefix"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Constants   c    =    new   Constants ( ConstantsTests . A . class )  ;", "Set <  ?  >    values    =    c . getValues (  \"     \"  )  ;", "assertEquals (  \" Must   have   returned    * all *    public   static   final   values \"  ,     7  ,    values . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getValuesWithWhitespacedStringPrefix"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Constants   c    =    new   Constants ( ConstantsTests . A . class )  ;", "Set <  ?  >    names    =    c . getNamesForSuffix (  \"  _ PROPERTY \"  )  ;", "assertEquals (  2  ,    names . size (  )  )  ;", "assertTrue ( names . contains (  \" NO _ PROPERTY \"  )  )  ;", "assertTrue ( names . contains (  \" YES _ PROPERTY \"  )  )  ;", "Set <  ?  >    values    =    c . getValuesForSuffix (  \"  _ PROPERTY \"  )  ;", "assertEquals (  2  ,    values . size (  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  3  )  )  )  ;", "assertTrue ( values . contains ( Integer . valueOf (  4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["suffixAccess"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Constants   c    =    new   Constants ( ConstantsTests . A . class )  ;", "assertEquals (  \" DOG \"  ,    c . toCode ( Integer . valueOf (  0  )  ,     \"  \"  )  )  ;", "assertEquals (  \" DOG \"  ,    c . toCode ( Integer . valueOf (  0  )  ,     \" D \"  )  )  ;", "assertEquals (  \" DOG \"  ,    c . toCode ( Integer . valueOf (  0  )  ,     \" DO \"  )  )  ;", "assertEquals (  \" DOG \"  ,    c . toCode ( Integer . valueOf (  0  )  ,     \" DoG \"  )  )  ;", "assertEquals (  \" DOG \"  ,    c . toCode ( Integer . valueOf (  0  )  ,    null )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCode ( Integer . valueOf (  6  6  )  ,     \"  \"  )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCode ( Integer . valueOf (  6  6  )  ,     \" C \"  )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCode ( Integer . valueOf (  6  6  )  ,     \" ca \"  )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCode ( Integer . valueOf (  6  6  )  ,     \" cAt \"  )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCode ( Integer . valueOf (  6  6  )  ,    null )  )  ;", "assertEquals (  \" S 1  \"  ,    c . toCode (  \"  \"  ,     \"  \"  )  )  ;", "assertEquals (  \" S 1  \"  ,    c . toCode (  \"  \"  ,     \" s \"  )  )  ;", "assertEquals (  \" S 1  \"  ,    c . toCode (  \"  \"  ,     \" s 1  \"  )  )  ;", "assertEquals (  \" S 1  \"  ,    c . toCode (  \"  \"  ,    null )  )  ;", "try    {", "c . toCode (  \" bogus \"  ,     \" bogus \"  )  ;", "fail (  \" Should   have   thrown   ConstantException \"  )  ;", "}    catch    ( Constants . ConstantException   expected )     {", "}", "try    {", "c . toCode (  \" bogus \"  ,    null )  ;", "fail (  \" Should   have   thrown   ConstantException \"  )  ;", "}    catch    ( Constants . ConstantException   expected )     {", "}", "assertEquals (  \" MY _ PROPERTY _ NO \"  ,    c . toCodeForProperty ( Integer . valueOf (  1  )  ,     \" myProperty \"  )  )  ;", "assertEquals (  \" MY _ PROPERTY _ YES \"  ,    c . toCodeForProperty ( Integer . valueOf (  2  )  ,     \" myProperty \"  )  )  ;", "try    {", "c . toCodeForProperty (  \" bogus \"  ,     \" bogus \"  )  ;", "fail (  \" Should   have   thrown   ConstantException \"  )  ;", "}    catch    ( Constants . ConstantException   expected )     {", "}", "assertEquals (  \" DOG \"  ,    c . toCodeForSuffix ( Integer . valueOf (  0  )  ,     \"  \"  )  )  ;", "assertEquals (  \" DOG \"  ,    c . toCodeForSuffix ( Integer . valueOf (  0  )  ,     \" G \"  )  )  ;", "assertEquals (  \" DOG \"  ,    c . toCodeForSuffix ( Integer . valueOf (  0  )  ,     \" OG \"  )  )  ;", "assertEquals (  \" DOG \"  ,    c . toCodeForSuffix ( Integer . valueOf (  0  )  ,     \" DoG \"  )  )  ;", "assertEquals (  \" DOG \"  ,    c . toCodeForSuffix ( Integer . valueOf (  0  )  ,    null )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCodeForSuffix ( Integer . valueOf (  6  6  )  ,     \"  \"  )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCodeForSuffix ( Integer . valueOf (  6  6  )  ,     \" T \"  )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCodeForSuffix ( Integer . valueOf (  6  6  )  ,     \" at \"  )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCodeForSuffix ( Integer . valueOf (  6  6  )  ,     \" cAt \"  )  )  ;", "assertEquals (  \" CAT \"  ,    c . toCodeForSuffix ( Integer . valueOf (  6  6  )  ,    null )  )  ;", "assertEquals (  \" S 1  \"  ,    c . toCodeForSuffix (  \"  \"  ,     \"  \"  )  )  ;", "assertEquals (  \" S 1  \"  ,    c . toCodeForSuffix (  \"  \"  ,     \"  1  \"  )  )  ;", "assertEquals (  \" S 1  \"  ,    c . toCodeForSuffix (  \"  \"  ,     \" s 1  \"  )  )  ;", "assertEquals (  \" S 1  \"  ,    c . toCodeForSuffix (  \"  \"  ,    null )  )  ;", "try    {", "c . toCodeForSuffix (  \" bogus \"  ,     \" bogus \"  )  ;", "fail (  \" Should   have   thrown   ConstantException \"  )  ;", "}    catch    ( Constants . ConstantException   expected )     {", "}", "try    {", "c . toCodeForSuffix (  \" bogus \"  ,    null )  ;", "fail (  \" Should   have   thrown   ConstantException \"  )  ;", "}    catch    ( Constants . ConstantException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["toCode"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Constants   c    =    new   Constants ( ConstantsTests . NoConstants . class )  ;", "assertEquals (  0  ,    c . getSize (  )  )  ;", "final   Set <  ?  >    values    =    c . getValues (  \"  \"  )  ;", "assertNotNull ( values )  ;", "assertEquals (  0  ,    values . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["withClassThatExposesNoConstants"], "fileName": "org.springframework.core.ConstantsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeName ,     \"  ' attributeName '    must   not   be   null \"  )  ;", "if    (  !  ( attributeName . contains (  \"  -  \"  )  )  )     {", "return   attributeName ;", "}", "char [  ]    chars    =    attributeName . toCharArray (  )  ;", "char [  ]    result    =    new   char [  ( chars . length )     -     1  ]  ;", "int   currPos    =     0  ;", "boolean   upperCaseNext    =    false ;", "for    ( char   c    :    chars )     {", "if    ( c    =  =     '  -  '  )     {", "upperCaseNext    =    true ;", "} else", "if    ( upperCaseNext )     {", "result [  ( currPos +  +  )  ]     =    Character . toUpperCase ( c )  ;", "upperCaseNext    =    false ;", "} else    {", "result [  ( currPos +  +  )  ]     =    c ;", "}", "}", "return   new   St ( result ,     0  ,    currPos )  ;", "}", "METHOD_END"], "methodName": ["attributeNameToPropertyName"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    valueClass    =    value . getClass (  )  ;", "if    ( Proxy . isProxyClass ( valueClass )  )     {", "Class <  ?  >  [  ]    ifcs    =    valueClass . getInterfaces (  )  ;", "for    ( Class <  ?  >    ifc    :    ifcs )     {", "if    (  !  ( ClassUtils . isJavaLanguageInterface ( ifc )  )  )     {", "return   ifc ;", "}", "}", "} else", "if    (  (  ( valueClass . getName (  )  . lastIndexOf (  '  $  '  )  )     !  =     (  -  1  )  )     &  &     (  ( valueClass . getDeclaClass (  )  )     =  =    null )  )     {", "valueClass    =    valueClass . getSuperclass (  )  ;", "}", "return   valueClass ;", "}", "METHOD_END"], "methodName": ["getClassForValue"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( enclosingClass ,     \"  ' enclosingClass '    must   not   be   null \"  )  ;", "Assert . notNull ( attributeName ,     \"  ' attributeName '    must   not   be   null \"  )  ;", "return    (  ( enclosingClass . getName (  )  )     +     '  .  '  )     +    attributeName ;", "}", "METHOD_END"], "methodName": ["getQualifiedAttributeName"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( value ,     \" Value   must   not   be   null \"  )  ;", "Class <  ?  >    valueClass ;", "boolean   pluralize    =    false ;", "if    ( value . getClass (  )  . isArray (  )  )     {", "valueClass    =    value . getClass (  )  . getComponentType (  )  ;", "pluralize    =    true ;", "} else", "if    ( value   instanceof   Collection )     {", "Collection <  ?  >    collection    =     (  ( Collection <  ?  >  )     ( value )  )  ;", "if    ( collection . isEmpty (  )  )     {", "throw   new   IllegalArgumentException (  \" Cannot   generate   variable   name   for   an   empty   Collection \"  )  ;", "}", "Object   valueToCheck    =     . peekAhead ( collection )  ;", "valueClass    =     . getClassForValue ( valueToCheck )  ;", "pluralize    =    true ;", "} else    {", "valueClass    =     . getClassForValue ( value )  ;", "}", "String   name    =    ClassUtils . getShortNameAsProperty ( valueClass )  ;", "return   pluralize    ?     . pluralize ( name )     :    name ;", "}", "METHOD_END"], "methodName": ["getVariableName"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( parameter ,     \" MethodParameter   must   not   be   null \"  )  ;", "Class <  ?  >    valueClass ;", "boolean   pluralize    =    false ;", "String   reactiveSuffix    =     \"  \"  ;", "if    ( parameter . getParameterType (  )  . isArray (  )  )     {", "valueClass    =    parameter . getParameterType (  )  . getComponentType (  )  ;", "pluralize    =    true ;", "} else", "if    ( isAssignableFrom ( parameter . getParameterType (  )  )  )     {", "valueClass    =    ResolvableType . forMethodParameter ( parameter )  . asCollection (  )  . resolveGeneric (  )  ;", "if    ( valueClass    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Cannot   generate   variable   name   for   non - typed   Collection   parameter   type \"  )  ;", "}", "pluralize    =    true ;", "} else    {", "valueClass    =    parameter . getParameterType (  )  ;", "if    (  . reactiveAdapterRegistry . hasAdapters (  )  )     {", "ReactiveAdapter   adapter    =     . reactiveAdapterRegistry . getAdapter ( valueClass )  ;", "if    (  ( adapter    !  =    null )     &  &     (  !  ( adapter . getDescriptor (  )  . isNoValue (  )  )  )  )     {", "reactiveSuffix    =    ClassUtils . getShortName ( valueClass )  ;", "valueClass    =    parameter . nested (  )  . getNestedParameterType (  )  ;", "}", "}", "}", "String   name    =    ClassUtils . getShortNameAsProperty ( valueClass )  ;", "return   pluralize    ?     . pluralize ( name )     :    name    +    reactiveSuffix ;", "}", "METHOD_END"], "methodName": ["getVariableNameForParameter"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "return   Conventions . getVariableNameForReturnType ( method ,    method . getReturnType (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["getVariableNameForReturnType"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "if    (  ( Object . class )     =  =    resolvedType )     {", "if    ( value    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Cannot   generate   variable   name   for   an   Object   return   type   with   null   value \"  )  ;", "}", "return    . getVariableName ( value )  ;", "}", "Class <  ?  >    valueClass ;", "boolean   pluralize    =    false ;", "String   reactiveSuffix    =     \"  \"  ;", "if    ( resolvedType . isArray (  )  )     {", "valueClass    =    resolvedType . getComponentType (  )  ;", "pluralize    =    true ;", "} else", "if    ( isAssignableFrom ( resolvedType )  )     {", "valueClass    =    ResolvableType . forMethodReturnType ( method )  . asCollection (  )  . resolveGeneric (  )  ;", "if    ( valueClass    =  =    null )     {", "if    (  !  ( value   instanceof   Collection )  )     {", "throw   new   IllegalArgumentException (  (  \" Cannot   generate   variable   name    \"     +     \" for   non - typed   Collection   return   type   and   a   non - Collection   value \"  )  )  ;", "}", "Collection <  ?  >    collection    =     (  ( Collection <  ?  >  )     ( value )  )  ;", "if    ( collection . isEmpty (  )  )     {", "throw   new   IllegalArgumentException (  (  \" Cannot   generate   variable   name    \"     +     \" for   non - typed   Collection   return   type   and   an   empty   Collection   value \"  )  )  ;", "}", "Object   valueToCheck    =     . peekAhead ( collection )  ;", "valueClass    =     . getClassForValue ( valueToCheck )  ;", "}", "pluralize    =    true ;", "} else    {", "valueClass    =    resolvedType ;", "if    (  . reactiveAdapterRegistry . hasAdapters (  )  )     {", "ReactiveAdapter   adapter    =     . reactiveAdapterRegistry . getAdapter ( valueClass )  ;", "if    (  ( adapter    !  =    null )     &  &     (  !  ( adapter . getDescriptor (  )  . isNoValue (  )  )  )  )     {", "reactiveSuffix    =    ClassUtils . getShortName ( valueClass )  ;", "valueClass    =    ResolvableType . forMethodReturnType ( method )  . getGeneric (  )  . resolve ( Object . class )  ;", "}", "}", "}", "String   name    =    ClassUtils . getShortNameAsProperty ( valueClass )  ;", "return   pluralize    ?     . pluralize ( name )     :    name    +    reactiveSuffix ;", "}", "METHOD_END"], "methodName": ["getVariableNameForReturnType"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "return   Conventions . getVariableNameForReturnType ( method ,    method . getReturnType (  )  ,    value )  ;", "}", "METHOD_END"], "methodName": ["getVariableNameForReturnType"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "Iterator < E >    it    =    collection . iterator (  )  ;", "if    (  !  ( it . hasNext (  )  )  )     {", "throw   new   IllegalStateException (  \" Unable   to   peek   ahead   in   non - empty   collection    -    no   element   found \"  )  ;", "}", "E   value    =    it . next (  )  ;", "if    ( value    =  =    null )     {", "throw   new   IllegalStateException (  \" Unable   to   peek   ahead   in   non - empty   collection    -    only   null   element   found \"  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["peekAhead"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "return   name    +     ( Conventions . PLURAL _ SUFFIX )  ;", "}", "METHOD_END"], "methodName": ["pluralize"], "fileName": "org.springframework.core.Conventions"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Incorrect   plural   array   form \"  ,     \" testObjectList \"  ,    Conventions . getVariableName ( new   TestObject [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" transactionManager \"  ,    Conventions . attributeNameToPropertyName (  \" transaction - manager \"  )  )  ;", "assertEquals (  \" pointcutRef \"  ,    Conventions . attributeNameToPropertyName (  \" pointcut - ref \"  )  )  ;", "assertEquals (  \" lookupOnStartup \"  ,    Conventions . attributeNameToPropertyName (  \" lookup - on - startup \"  )  )  ;", "}", "METHOD_END"], "methodName": ["attributeNameToPropertyName"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "this . exception . expect ( IllegalArgumentException . class )  ;", ". getVariableName ( new   ArrayList <  >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyList"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . stream ( ConventionsTests . TestBean . class . getMethods (  )  )  . filter (  (    method )     -  >    method . getReturnType (  )  . equals ( returnType )  )  . findFirst (  )  . orElseThrow (  (  )     -  >    new   IllegalArgumentException (  (  \" Unique   return   type   not   found :     \"     +    returnType )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMethodForReturnType"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ClassUtils . getMethod ( ConventionsTests . TestBean . class ,     \" handle \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( method . getParameterCount (  )  )  ;    i +  +  )     {", "if    ( parameterType . equals ( method . getParameterTypes (  )  [ i ]  )  )     {", "return   new   MethodParameter ( method ,    i )  ;", "}", "}", "throw   new   IllegalArgumentException (  (  \" Parameter   type   not   found :     \"     +    parameterType )  )  ;", "}", "METHOD_END"], "methodName": ["getMethodParameter"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "String   baseName    =     \" foo \"  ;", "Class < String >    cls    =    String . class ;", "String   desiredResult    =     \" foo \"  ;", "assertEquals ( desiredResult ,     . getQualifiedAttributeName ( cls ,    baseName )  )  ;", "}", "METHOD_END"], "methodName": ["getQualifiedAttributeName"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Incorrect   plural   List   form \"  ,     \" testObjectList \"  ,    Conventions . getVariableName ( Collections . singletonList ( new   TestObject (  )  )  )  )  ;", "assertEquals (  \" Incorrect   plural   List   form \"  ,     \" testObjectList \"  ,    Conventions . getVariableNameForParameter (  . getMethodParameter ( List . class )  )  )  ;", "assertEquals (  \" Incorrect   plural   List   form \"  ,     \" testObjectList \"  ,    Conventions . getVariableNameForReturnType (  . getMethodForReturnType ( List . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" testObjectMono \"  ,    Conventions . getVariableNameForParameter ( ConventionsTests . getMethodParameter ( Mono . class )  )  )  ;", "assertEquals (  \" testObjectFlux \"  ,    Conventions . getVariableNameForParameter ( ConventionsTests . getMethodParameter ( Flux . class )  )  )  ;", "assertEquals (  \" testObjectSingle \"  ,    Conventions . getVariableNameForParameter ( ConventionsTests . getMethodParameter ( Single . class )  )  )  ;", "assertEquals (  \" testObjectObservable \"  ,    Conventions . getVariableNameForParameter ( ConventionsTests . getMethodParameter ( Observable . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["reactiveParameters"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" testObjectMono \"  ,    Conventions . getVariableNameForReturnType ( ConventionsTests . getMethodForReturnType ( Mono . class )  )  )  ;", "assertEquals (  \" testObjectFlux \"  ,    Conventions . getVariableNameForReturnType ( ConventionsTests . getMethodForReturnType ( Flux . class )  )  )  ;", "assertEquals (  \" testObjectSingle \"  ,    Conventions . getVariableNameForReturnType ( ConventionsTests . getMethodForReturnType ( Single . class )  )  )  ;", "assertEquals (  \" testObjectObservable \"  ,    Conventions . getVariableNameForReturnType ( ConventionsTests . getMethodForReturnType ( Observable . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["reactiveReturnTypes"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Incorrect   plural   Set   form \"  ,     \" testObjectList \"  ,    Conventions . getVariableName ( Collections . singleton ( new   TestObject (  )  )  )  )  ;", "assertEquals (  \" Incorrect   plural   Set   form \"  ,     \" testObjectList \"  ,    Conventions . getVariableNameForParameter (  . getMethodParameter ( Set . class )  )  )  ;", "assertEquals (  \" Incorrect   plural   Set   form \"  ,     \" testObjectList \"  ,    Conventions . getVariableNameForReturnType (  . getMethodForReturnType ( Set . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Incorrect   singular   variable   name \"  ,     \" testObject \"  ,    Conventions . getVariableName ( new   TestObject (  )  )  )  ;", "assertEquals (  \" Incorrect   singular   variable   name \"  ,     \" testObject \"  ,    Conventions . getVariableNameForParameter (  . getMethodParameter ( TestObject . class )  )  )  ;", "assertEquals (  \" Incorrect   singular   variable   name \"  ,     \" testObject \"  ,    Conventions . getVariableNameForReturnType (  . getMethodForReturnType ( TestObject . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleObject"], "fileName": "org.springframework.core.ConventionsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( className ,     \" Class   name   must   not   be   null \"  )  ;", "this . excludedClasses . add ( className )  ;", "}", "METHOD_END"], "methodName": ["excludeClass"], "fileName": "org.springframework.core.DecoratingClassLoader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( packageName ,     \" Package   name   must   not   be   null \"  )  ;", "this . excludedPackages . add ( packageName )  ;", "}", "METHOD_END"], "methodName": ["excludePackage"], "fileName": "org.springframework.core.DecoratingClassLoader"}, {"methodBody": ["METHOD_START", "{", "if    ( this . excludedClasses . contains ( className )  )     {", "return   true ;", "}", "for    ( String   packageName    :    this . excludedPackages )     {", "if    ( className . startsWith ( packageName )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isExcluded"], "fileName": "org.springframework.core.DecoratingClassLoader"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( exceptionTypes ,     \" Exception   types   must   not   be   empty \"  )  ;", "if    (  ( exceptionTypes . size (  )  )     =  =     1  )     {", "return   exceptionTypes . iterator (  )  . next (  )  ;", "}", "List < Class <  ?    extends   Throwable >  >    handledExceptions    =    new   ArrayList <  >  ( exceptionTypes )  ;", "handledExceptions . sort ( new    ( targetException )  )  ;", "return   handledExceptions . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["findClosestMatch"], "fileName": "org.springframework.core.ExceptionDepthComparator"}, {"methodBody": ["METHOD_START", "{", "if    ( exceptionToMatch . equals ( declaredException )  )     {", "return   depth ;", "}", "if    ( exceptionToMatch    =  =     ( Throwable . class )  )     {", "return   Integer . MAX _ VALUE ;", "}", "return   getDepth ( declaredException ,    exceptionToMatch . getSuperclass (  )  ,     ( depth    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getDepth"], "fileName": "org.springframework.core.ExceptionDepthComparator"}, {"methodBody": ["METHOD_START", "{", "return   ExceptionDepthComparator . findClosestMatch ( Arrays . asList ( classes )  ,    new   ExceptionDepthComparatorTests . TargetException (  )  )  ;", "}", "METHOD_END"], "methodName": ["findClosestMatch"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Throwable >    foundClass    =    findClosestMatch ( ExceptionDepthComparatorTests . HighestDepthException . class ,    ExceptionDepthComparatorTests . LowestDepthException . class )  ;", "assertEquals ( ExceptionDepthComparatorTests . LowestDepthException . class ,    foundClass )  ;", "}", "METHOD_END"], "methodName": ["highestDepthBeforeLowestDepth"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Throwable >    foundClass    =    findClosestMatch ( ExceptionDepthComparatorTests . HighestDepthException . class ,    ExceptionDepthComparatorTests . NoDepthException . class )  ;", "assertEquals ( ExceptionDepthComparatorTests . HighestDepthException . class ,    foundClass )  ;", "}", "METHOD_END"], "methodName": ["highestDepthBeforeNoDepth"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Throwable >    foundClass    =    findClosestMatch ( ExceptionDepthComparatorTests . LowestDepthException . class ,    ExceptionDepthComparatorTests . HighestDepthException . class )  ;", "assertEquals ( ExceptionDepthComparatorTests . LowestDepthException . class ,    foundClass )  ;", "}", "METHOD_END"], "methodName": ["lowestDepthBeforeHighestDepth"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Throwable >    foundClass    =    findClosestMatch ( ExceptionDepthComparatorTests . LowestDepthException . class ,    ExceptionDepthComparatorTests . TargetException . class )  ;", "assertEquals ( ExceptionDepthComparatorTests . TargetException . class ,    foundClass )  ;", "}", "METHOD_END"], "methodName": ["lowestDepthBeforeTarget"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Throwable >    foundClass    =    findClosestMatch ( ExceptionDepthComparatorTests . NoDepthException . class ,    ExceptionDepthComparatorTests . HighestDepthException . class )  ;", "assertEquals ( ExceptionDepthComparatorTests . HighestDepthException . class ,    foundClass )  ;", "}", "METHOD_END"], "methodName": ["noDepthBeforeHighestDepth"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Throwable >    foundClass    =    findClosestMatch ( ExceptionDepthComparatorTests . NoDepthException . class ,    ExceptionDepthComparatorTests . TargetException . class )  ;", "assertEquals ( ExceptionDepthComparatorTests . TargetException . class ,    foundClass )  ;", "}", "METHOD_END"], "methodName": ["noDepthBeforeTarget"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Throwable >    foundClass    =    findClosestMatch ( ExceptionDepthComparatorTests . SameDepthException . class ,    ExceptionDepthComparatorTests . TargetException . class )  ;", "assertEquals ( ExceptionDepthComparatorTests . TargetException . class ,    foundClass )  ;", "}", "METHOD_END"], "methodName": ["sameDepthBeforeTarget"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Throwable >    foundClass    =    findClosestMatch ( ExceptionDepthComparatorTests . TargetException . class ,    ExceptionDepthComparatorTests . LowestDepthException . class )  ;", "assertEquals ( ExceptionDepthComparatorTests . TargetException . class ,    foundClass )  ;", "}", "METHOD_END"], "methodName": ["targetBeforeLowestDepth"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Throwable >    foundClass    =    findClosestMatch ( ExceptionDepthComparatorTests . TargetException . class ,    ExceptionDepthComparatorTests . SameDepthException . class )  ;", "assertEquals ( ExceptionDepthComparatorTests . TargetException . class ,    foundClass )  ;", "}", "METHOD_END"], "methodName": ["targetBeforeSameDepth"], "fileName": "org.springframework.core.ExceptionDepthComparatorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( type    !  =     ( ResolvableType . NONE )  )     {", "Class <  ?  >    resolved    =    type . resolve (  )  ;", "if    (  ( resolved    !  =    null )     &  &     (  ( type . getType (  )  )    instanceof   ParameterizedType )  )     {", "TypeVariable <  ?  >  [  ]    variables    =    resolved . getTypeParameters (  )  ;", "for    ( int   i    =     0  ;    i    <     ( variables . length )  ;    i +  +  )     {", "ResolvableType   generic    =    type . getGeneric ( i )  ;", "while    (  ( generic . getType (  )  )    instanceof   TypeVariable <  ?  >  )     {", "generic    =    generic . resolveType (  )  ;", "}", "if    ( generic    !  =     ( ResolvableType . NONE )  )     {", "typeVariableMap . put ( variables [ i ]  ,    generic . getType (  )  )  ;", "}", "}", "}", ". buildTypeVariableMap ( type . getSuperType (  )  ,    typeVariableMap )  ;", "for    ( ResolvableType   interfaceType    :    type . getInterfaces (  )  )     {", ". buildTypeVariableMap ( interfaceType ,    typeVariableMap )  ;", "}", "if    (  ( resolved    !  =    null )     &  &     ( resolved . isMemberClass (  )  )  )     {", ". buildTypeVariableMap ( ResolvableType . forClass ( resolved . getEnclosingClass (  )  )  ,    typeVariableMap )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["buildTypeVariableMap"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( resolvableType . getGenerics (  )  . length )     =  =     1  )  ,     (  )     -  >     (  (  \" Expected    1    type   argument   on   generic   interface    [  \"     +    resolvableType )     +     \"  ]    but   found    \"  )     +     ( resolvableType . getGenerics (  )  . length )  )  ;", "return   resolvableType . getGeneric (  )  . resolve (  )  ;", "}", "METHOD_END"], "methodName": ["getSingleGeneric"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "Map < TypeVariable ,    Type >    typeVariableMap    =    GenericTypeResolver . typeVariableCache . get ( clazz )  ;", "if    ( typeVariableMap    =  =    null )     {", "typeVariableMap    =    new   HashMap <  >  (  )  ;", "GenericTypeResolver . buildTypeVariableMap ( ResolvableType . forClass ( clazz )  ,    typeVariableMap )  ;", "GenericTypeResolver . typeVariableCache . put ( clazz ,    Collections . unmodifiableMap ( typeVariableMap )  )  ;", "}", "return   typeVariableMap ;", "}", "METHOD_END"], "methodName": ["getTypeVariableMap"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( methodParameter ,     \" MethodParameter   must   not   be   null \"  )  ;", "Assert . notNull ( implementationClass ,     \" Class   must   not   be   null \"  )  ;", "methodParameter . setContainingClass ( implementationClass )  ;", "ableType . resolveMethodParameter ( methodParameter )  ;", "return   methodParameter . getParameterType (  )  ;", "}", "METHOD_END"], "methodName": ["resolveParameterType"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "return   ableType . forMethodReturnType ( method ,    clazz )  . resolve ( method . getReturnType (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveReturnType"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" method   must   not   be   null \"  )  ;", "ResolvableType   resolvableType    =    ResolvableType . forMethodReturnType ( method )  . as ( genericIfc )  ;", "if    (  (  !  ( resolvableType . hasGenerics (  )  )  )     |  |     (  ( resolvableType . getType (  )  )    instanceof   WildcardType )  )     {", "return   null ;", "}", "return    . getSingleGeneric ( resolvableType )  ;", "}", "METHOD_END"], "methodName": ["resolveReturnTypeArgument"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( contextClass    !  =    null )     {", "if    ( genericType   instanceof   TypeVariable )     {", "ResolvableType   resolvedTypeVariable    =     . resolveVariable (  (  ( TypeVariable <  ?  >  )     ( genericType )  )  ,    ResolvableType . forClass ( contextClass )  )  ;", "if    ( resolvedTypeVariable    !  =     ( ResolvableType . NONE )  )     {", "Class <  ?  >    resolved    =    resolvedTypeVariable . resolve (  )  ;", "if    ( resolved    !  =    null )     {", "return   resolved ;", "}", "}", "} else", "if    ( genericType   instanceof   ParameterizedType )     {", "ResolvableType   resolvedType    =    ResolvableType . forType ( genericType )  ;", "if    ( resolvedType . hasUnresolvableGenerics (  )  )     {", "ParameterizedType   parameterizedType    =     (  ( ParameterizedType )     ( genericType )  )  ;", "Class <  ?  >  [  ]    generics    =    new   Class <  ?  >  [ parameterizedType . getActualTypeArguments (  )  . length ]  ;", "Type [  ]    typeArguments    =    parameterizedType . getActualTypeArguments (  )  ;", "for    ( int   i    =     0  ;    i    <     ( typeArguments . length )  ;    i +  +  )     {", "Type   typeArgument    =    typeArguments [ i ]  ;", "if    ( typeArgument   instanceof   TypeVariable )     {", "ResolvableType   resolvedTypeArgument    =     . resolveVariable (  (  ( TypeVariable <  ?  >  )     ( typeArgument )  )  ,    ResolvableType . forClass ( contextClass )  )  ;", "if    ( resolvedTypeArgument    !  =     ( ResolvableType . NONE )  )     {", "generics [ i ]     =    resolvedTypeArgument . resolve (  )  ;", "} else    {", "generics [ i ]     =    ResolvableType . forType ( typeArgument )  . resolve (  )  ;", "}", "} else    {", "generics [ i ]     =    ResolvableType . forType ( typeArgument )  . resolve (  )  ;", "}", "}", "Class <  ?  >    rawClass    =    resolvedType . getRawClass (  )  ;", "if    ( rawClass    !  =    null )     {", "return   ResolvableType . forClassWithGenerics ( rawClass ,    generics )  . getType (  )  ;", "}", "}", "}", "}", "return   genericType ;", "}", "METHOD_END"], "methodName": ["resolveType"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forType ( genericType ,    new   GenericTypeResolver . TypeVariableMapVariableResolver ( map )  )  . resolve ( Object . class )  ;", "}", "METHOD_END"], "methodName": ["resolveType"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   resolvableType    =    ResolvableType . forClass ( clazz )  . as ( genericIfc )  ;", "if    (  !  ( resolvableType . hasGenerics (  )  )  )     {", "return   null ;", "}", "return    . getSingleGeneric ( resolvableType )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeArgument"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( clazz )  . as ( genericIfc )  ;", "if    (  (  !  ( type . hass (  )  )  )     |  |     ( type . isEntirelyUnresolvable (  )  )  )     {", "return   null ;", "}", "return   type . resolves ( Object . class )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeArguments"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   resolvedType ;", "if    ( contextType . hasGenerics (  )  )     {", "resolvedType    =    ResolvableType . forType ( typeVariable ,    contextType )  ;", "if    (  ( resolvedType . resolve (  )  )     !  =    null )     {", "return   resolvedType ;", "}", "}", "ResolvableType   superType    =    contextType . getSuperType (  )  ;", "if    ( superType    !  =     ( ResolvableType . NONE )  )     {", "resolvedType    =     . resolveVariable ( typeVariable ,    superType )  ;", "if    (  ( resolvedType . resolve (  )  )     !  =    null )     {", "return   resolvedType ;", "}", "}", "for    ( ResolvableType   ifc    :    contextType . getInterfaces (  )  )     {", "resolvedType    =     . resolveVariable ( typeVariable ,    ifc )  ;", "if    (  ( resolvedType . resolve (  )  )     !  =    null )     {", "return   resolvedType ;", "}", "}", "return   ResolvableType . NONE ;", "}", "METHOD_END"], "methodName": ["resolveVariable"], "fileName": "org.springframework.core.GenericTypeResolver"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    resolved    =    GenericTypeResolver . resolveTypeArguments ( List . class ,    Iterable . class )  ;", "assertNull ( resolved )  ;", "}", "METHOD_END"], "methodName": ["getGenericsCannotBeResolved"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( GenericTypeResolverTests . WithArrayBase . class . getDeclaredMethod (  \" array \"  ,    Object [  ]  . class )  ,     0  )  ;", "Class <  ?  >    resolved    =    GenericTypeResolver . resolveParameterType ( methodParameter ,    GenericTypeResolverTests . WithArray . class )  ;", "assertThat ( resolved ,    equalTo (  (  ( Class <  ?  >  )     ( Object [  ]  . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getGenericsOnArrayFromParamCannotBeResolved"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    resolved    =    GenericTypeResolver . resolveReturnType ( GenericTypeResolverTests . WithArrayBase . class . getDeclaredMethod (  \" array \"  ,    Object [  ]  . class )  ,    GenericTypeResolverTests . WithArray . class )  ;", "assertThat ( resolved ,    equalTo (  (  ( Class <  ?  >  )     ( Object [  ]  . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getGenericsOnArrayFromReturnCannotBeResolved"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    resolved    =    GenericTypeResolver . resolveTypeArguments ( Map . class ,    Map . class )  ;", "assertNull ( resolved )  ;", "}", "METHOD_END"], "methodName": ["getRawMapTypeCannotBeResolved"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Integer . class ,    GenericTypeResolver . resolveReturnTypeArgument ( ReflectionUtils . findMethod ( GenericTypeResolverTests . MyTypeWithMethods . class ,     \" integer \"  )  ,    GenericTypeResolverTests . MyInterfaceType . class )  )  ;", "assertEquals ( String . class ,    GenericTypeResolver . resolveReturnTypeArgument ( ReflectionUtils . findMethod ( GenericTypeResolverTests . MyTypeWithMethods . class ,     \" string \"  )  ,    GenericTypeResolverTests . MyInterfaceType . class )  )  ;", "assertEquals ( null ,    GenericTypeResolver . resolveReturnTypeArgument ( ReflectionUtils . findMethod ( GenericTypeResolverTests . MyTypeWithMethods . class ,     \" raw \"  )  ,    GenericTypeResolverTests . MyInterfaceType . class )  )  ;", "assertEquals ( null ,    GenericTypeResolver . resolveReturnTypeArgument ( ReflectionUtils . findMethod ( GenericTypeResolverTests . MyTypeWithMethods . class ,     \" object \"  )  ,    GenericTypeResolverTests . MyInterfaceType . class )  )  ;", "}", "METHOD_END"], "methodName": ["methodReturnTypes"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "GenericTypeResolverTests . GenericClass < String >    obj    =    new   GenericTypeResolverTests . GenericClass <  >  (  )  ;", "assertNull ( GenericTypeResolver . resolveTypeArgument ( obj . getClass (  )  ,    GenericTypeResolverTests . GenericClass . class )  )  ;", "}", "METHOD_END"], "methodName": ["nullIfNotResolvable"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    resolved    =    GenericTypeResolver . resolveTypeArguments ( GenericTypeResolverTests . IdFixingRepository . class ,    GenericTypeResolverTests . Repository . class )  ;", "assertNotNull ( resolved )  ;", "assertEquals (  2  ,    resolved . length )  ;", "assertEquals ( Object . class ,    resolved [  0  ]  )  ;", "assertEquals ( Long . class ,    resolved [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["resolveIncompleteTypeVariables"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Collection . class ,    GenericTypeResolver . resolveTypeArgument ( GenericTypeResolverTests . MyCollectionInterfaceType . class ,    GenericTypeResolverTests . MyInterfaceType . class )  )  ;", "}", "METHOD_END"], "methodName": ["simpleCollectionInterfaceType"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Collection . class ,    GenericTypeResolver . resolveTypeArgument ( GenericTypeResolverTests . MyCollectionSuperclassType . class ,    GenericTypeResolverTests . MySuperclassType . class )  )  ;", "}", "METHOD_END"], "methodName": ["simpleCollectionSuperclassType"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( String . class ,    GenericTypeResolver . resolveTypeArgument ( GenericTypeResolverTests . MySimpleInterfaceType . class ,    GenericTypeResolverTests . MyInterfaceType . class )  )  ;", "}", "METHOD_END"], "methodName": ["simpleInterfaceType"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( String . class ,    GenericTypeResolver . resolveTypeArgument ( GenericTypeResolverTests . MySimpleSuperclassType . class ,    GenericTypeResolverTests . MySuperclassType . class )  )  ;", "}", "METHOD_END"], "methodName": ["simpleSuperclassType"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( GenericTypeResolverTests . B . class ,    GenericTypeResolver . resolveTypeArgument ( GenericTypeResolverTests . TestImpl . class ,    GenericTypeResolverTests . TestIfc . class )  )  ;", "}", "METHOD_END"], "methodName": ["testBoundParameterizedType"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < TypeVariable ,    Type >    map ;", "map    =    GenericTypeResolver . getTypeVariableMap (  . MySimpleInterfaceType . class )  ;", "assertThat ( map . toString (  )  ,    equalTo (  \"  { T = class   String }  \"  )  )  ;", "map    =    GenericTypeResolver . getTypeVariableMap (  . MyCollectionInterfaceType . class )  ;", "assertThat ( map . toString (  )  ,    equalTo (  \"  { T = Collection < String >  }  \"  )  )  ;", "map    =    GenericTypeResolver . getTypeVariableMap (  . MyCollectionSuperclassType . class )  ;", "assertThat ( map . toString (  )  ,    equalTo (  \"  { T = Collection < String >  }  \"  )  )  ;", "map    =    GenericTypeResolver . getTypeVariableMap (  . MySimpleTypeWithMethods . class )  ;", "assertThat ( map . toString (  )  ,    equalTo (  \"  { T = class   Integer }  \"  )  )  ;", "map    =    GenericTypeResolver . getTypeVariableMap (  . TopLevelClass . class )  ;", "assertThat ( map . toString (  )  ,    equalTo (  \"  {  }  \"  )  )  ;", "map    =    GenericTypeResolver . getTypeVariableMap (  . TypedTopLevelClass . class )  ;", "assertThat ( map . toString (  )  ,    equalTo (  \"  { T = class   Integer }  \"  )  )  ;", "map    =    GenericTypeResolver . getTypeVariableMap (  . TypedTopLevelClass . TypedNested . class )  ;", "assertThat ( map . size (  )  ,    equalTo (  2  )  )  ;", "Type   t    =    null ;", "Type   x    =    null ;", "for    ( Map . Entry < TypeVariable ,    Type >    entry    :    map . entrySet (  )  )     {", "if    ( entry . getKey (  )  . toString (  )  . equals (  \" T \"  )  )     {", "t    =    entry . getValue (  )  ;", "} else    {", "x    =    entry . getValue (  )  ;", "}", "}", "assertThat ( t ,    equalTo (  (  ( Type )     ( Integer . class )  )  )  )  ;", "assertThat ( x ,    equalTo (  (  ( Type )     ( Long . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTypeVariableMap"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "Method   intMessageMethod    =    ReflectionUtils . findMethod ( GenericTypeResolverTests . MyTypeWithMethods . class ,     \" readIntegerInputMessage \"  ,    GenericTypeResolverTests . MyInterfaceType . class )  ;", "MethodParameter   intMessageMethodParam    =    new   MethodParameter ( intMessageMethod ,     0  )  ;", "assertEquals ( GenericTypeResolverTests . MyInterfaceType . class ,    GenericTypeResolver . resolveType ( intMessageMethodParam . getGenericParameterType (  )  ,    new   HashMap <  >  (  )  )  )  ;", "Method   intArrMessageMethod    =    ReflectionUtils . findMethod ( GenericTypeResolverTests . MyTypeWithMethods . class ,     \" readIntegerArrayInputMessage \"  ,    GenericTypeResolverTests . MyInterfaceType [  ]  . class )  ;", "MethodParameter   intArrMessageMethodParam    =    new   MethodParameter ( intArrMessageMethod ,     0  )  ;", "assertEquals ( GenericTypeResolverTests . MyInterfaceType [  ]  . class ,    GenericTypeResolver . resolveType ( intArrMessageMethodParam . getGenericParameterType (  )  ,    new   HashMap <  >  (  )  )  )  ;", "Method   genericArrMessageMethod    =    ReflectionUtils . findMethod ( GenericTypeResolverTests . MySimpleTypeWithMethods . class ,     \" readGenericArrayInputMessage \"  ,    Object [  ]  . class )  ;", "MethodParameter   genericArrMessageMethodParam    =    new   MethodParameter ( genericArrMessageMethod ,     0  )  ;", "Map < TypeVariable ,    Type >    varMap    =    GenericTypeResolver . getTypeVariableMap ( GenericTypeResolverTests . MySimpleTypeWithMethods . class )  ;", "assertEquals ( Integer [  ]  . class ,    GenericTypeResolver . resolveType ( genericArrMessageMethodParam . getGenericParameterType (  )  ,    varMap )  )  ;", "}", "METHOD_END"], "methodName": ["testResolveType"], "fileName": "org.springframework.core.GenericTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "return    ( KotlinDetector . kotlinMetadata )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isKotlinPresent"], "fileName": "org.springframework.core.KotlinDetector"}, {"methodBody": ["METHOD_START", "{", "return    (  ( KotlinDetector . kotlinMetadata )     !  =    null )     &  &     (  ( clazz . getDeclaredAnnotation ( KotlinDetector . kotlinMetadata )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isKotlinType"], "fileName": "org.springframework.core.KotlinDetector"}, {"methodBody": ["METHOD_START", "{", "List < KParameter >    filteredParameters    =    parameters . stream (  )  . filter (  (    p )     -  >     ( KParameter . Kind . VALUE . equals ( p . getKind (  )  )  )     |  |     ( KParameter . Kind . EXTENSION _ RECEIVER . equals ( p . getKind (  )  )  )  )  . collect ( Collectors . toList (  )  )  ;", "String [  ]    ps    =    new   String [ filteredParameters . size (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( filteredParameters . size (  )  )  ;    i +  +  )     {", "KParameter   parameter    =    filteredParameters . get ( i )  ;", "String   name    =     ( EXTENSION _ RECEIVER . equals ( parameter . getKind (  )  )  )     ?     \"  $ receiver \"     :    parameter . getName (  )  ;", "if    ( name    =  =    null )     {", "return   null ;", "}", "ps [ i ]     =    name ;", "}", "return   ps ;", "}", "METHOD_END"], "methodName": ["getParameterNames"], "fileName": "org.springframework.core.KotlinReflectionParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "InputStream   is    =    clazz . getResourceAsStream ( ClassUtils . getClassFileName ( clazz )  )  ;", "if    ( is    =  =    null )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Cannot   find    '  . class '    file   for   class    [  \"     +    clazz )     +     \"  ]     -    unable   to   determine   constructor / method   parameter   names \"  )  )  ;", "}", "return    . NO _ DEBUG _ INFO _ MAP ;", "}", "try    {", "ClassReader   classReader    =    new   ClassReader ( is )  ;", "Map < Member ,    String [  ]  >    map    =    new   ConcurrentHashMap <  >  (  3  2  )  ;", "classReader . accept ( new    . ParameterNameDiscoveringVisitor ( clazz ,    map )  ,     0  )  ;", "return   map ;", "}    catch    ( IOException   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Exception   thrown   while   reading    '  . class '    file   for   class    [  \"     +    clazz )     +     \"  ]     -    unable   to   determine   constructor / method   parameter   names \"  )  ,    ex )  ;", "}", "}    catch    ( IllegalArgumentException   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" ASM   ClassReader   failed   to   parse   class   file    [  \"     +    clazz )     +     \"  ]  ,    probably   due   to   a   new   Java   class   file   version   that   isn ' t   supported   yet    \"  )     +     \"  -    unable   to   determine   constructor / method   parameter   names \"  )  ,    ex )  ;", "}", "}    finally    {", "try    {", "is . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "return    . NO _ DEBUG _ INFO _ MAP ;", "}", "METHOD_END"], "methodName": ["inspectClass"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "Class < Component >    clazz    =    Component . class ;", "String   methodName    =     \" list \"  ;", "Method   m    =    clazz . getMethod ( methodName )  ;", "String [  ]    names    =    discoverer . gets ( m )  ;", "assertNull ( names )  ;", "m    =    clazz . getMethod ( methodName ,    PrintStream . class )  ;", "names    =    discoverer . gets ( m )  ;", "assertNull ( names )  ;", "m    =    clazz . getMethod ( methodName ,    PrintStream . class ,    int . class )  ;", "names    =    discoverer . gets ( m )  ;", "assertNull ( names )  ;", "}", "METHOD_END"], "methodName": ["classesWithoutDebugSymbols"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Constructor < TestObject >    twoArgCons    =    TestObject . class . getConstructor ( String . class ,    int . class )  ;", "String [  ]    names    =    discoverer . gets ( twoArgCons )  ;", "assertNotNull (  \" should   find   cons   info \"  ,    names )  ;", "assertEquals (  \" one   argument \"  ,     2  ,    names . length )  ;", "assertEquals (  \" name \"  ,    names [  0  ]  )  ;", "assertEquals (  \" age \"  ,    names [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["consParameterNameDiscoveryArgs"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Constructor < TestObject >    noArgsCons    =    TestObject . class . getConstructor (  )  ;", "String [  ]    names    =    discoverer . gets ( noArgsCons )  ;", "assertNotNull (  \" should   find   cons   info \"  ,    names )  ;", "assertEquals (  \" no   argument   names \"  ,     0  ,    names . length )  ;", "}", "METHOD_END"], "methodName": ["consParameterNameDiscoveryNoArgs"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    LocalVariableTableParameterNameDiscovererTests . GenerifiedClass . class ;", "Constructor <  ?  >    ctor    =    clazz . getDeclaredConstructor ( Object . class )  ;", "String [  ]    names    =    discoverer . getParameterNames ( ctor )  ;", "assertEquals (  1  ,    names . length )  ;", "assertEquals (  \" key \"  ,    names [  0  ]  )  ;", "ctor    =    clazz . getDeclaredConstructor ( Object . class ,    Object . class )  ;", "names    =    discoverer . getParameterNames ( ctor )  ;", "assertEquals (  2  ,    names . length )  ;", "assertEquals (  \" key \"  ,    names [  0  ]  )  ;", "assertEquals (  \" value \"  ,    names [  1  ]  )  ;", "Method   m    =    clazz . getMethod (  \" generifiedStaticMethod \"  ,    Object . class )  ;", "names    =    discoverer . getParameterNames ( m )  ;", "assertEquals (  1  ,    names . length )  ;", "assertEquals (  \" param \"  ,    names [  0  ]  )  ;", "m    =    clazz . getMethod (  \" generifiedMethod \"  ,    Object . class ,    long . class ,    Object . class ,    Object . class )  ;", "names    =    discoverer . getParameterNames ( m )  ;", "assertEquals (  4  ,    names . length )  ;", "assertEquals (  \" param \"  ,    names [  0  ]  )  ;", "assertEquals (  \" x \"  ,    names [  1  ]  )  ;", "assertEquals (  \" key \"  ,    names [  2  ]  )  ;", "assertEquals (  \" value \"  ,    names [  3  ]  )  ;", "m    =    clazz . getMethod (  \" voidStaticMethod \"  ,    Object . class ,    long . class ,    int . class )  ;", "names    =    discoverer . getParameterNames ( m )  ;", "assertEquals (  3  ,    names . length )  ;", "assertEquals (  \" obj \"  ,    names [  0  ]  )  ;", "assertEquals (  \" x \"  ,    names [  1  ]  )  ;", "assertEquals (  \" i \"  ,    names [  2  ]  )  ;", "m    =    clazz . getMethod (  \" nonVoidStaticMethod \"  ,    Object . class ,    long . class ,    int . class )  ;", "names    =    discoverer . getParameterNames ( m )  ;", "assertEquals (  3  ,    names . length )  ;", "assertEquals (  \" obj \"  ,    names [  0  ]  )  ;", "assertEquals (  \" x \"  ,    names [  1  ]  )  ;", "assertEquals (  \" i \"  ,    names [  2  ]  )  ;", "m    =    clazz . getMethod (  \" getDate \"  )  ;", "names    =    discoverer . getParameterNames ( m )  ;", "assertEquals (  0  ,    names . length )  ;", "}", "METHOD_END"], "methodName": ["generifiedClass"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "double   u    =    x    *    y ;", "return   u ;", "}", "METHOD_END"], "methodName": ["instanceMethod"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "double   u    =     ( x    *    y )     *    z ;", "return   u ;", "}", "METHOD_END"], "methodName": ["instanceMethod"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Method   getName    =    TestObject . class . getMethod (  \" getName \"  )  ;", "String [  ]    names    =    discoverer . gets ( getName )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" no   argument   names \"  ,     0  ,    names . length )  ;", "}", "METHOD_END"], "methodName": ["methodParameterNameDiscoveryNoArgs"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Method   setName    =    TestObject . class . getMethod (  \" setName \"  ,    String . class )  ;", "String [  ]    names    =    discoverer . gets ( setName )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" one   argument \"  ,     1  ,    names . length )  ;", "assertEquals (  \" name \"  ,    names [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["methodParameterNameDiscoveryWithArgs"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   LocalVariableTableParameterNameDiscovererTests >    clazz    =    this . getClass (  )  ;", "Method   m 1     =    clazz . getMethod (  \" instanceMethod \"  ,    Double . TYPE ,    Double . TYPE )  ;", "String [  ]    names    =    discoverer . getParameterNames ( m 1  )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" two   arguments \"  ,     2  ,    names . length )  ;", "assertEquals (  \" x \"  ,    names [  0  ]  )  ;", "assertEquals (  \" y \"  ,    names [  1  ]  )  ;", "Method   m 2     =    clazz . getMethod (  \" instanceMethod \"  ,    Double . TYPE ,    Double . TYPE ,    Double . TYPE )  ;", "names    =    discoverer . getParameterNames ( m 2  )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" three   arguments \"  ,     3  ,    names . length )  ;", "assertEquals (  \" x \"  ,    names [  0  ]  )  ;", "assertEquals (  \" y \"  ,    names [  1  ]  )  ;", "assertEquals (  \" z \"  ,    names [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["overloadedMethod"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Class < LocalVariableTableParameterNameDiscovererTests . InnerClass >    clazz    =    LocalVariableTableParameterNameDiscovererTests . InnerClass . class ;", "Method   m 1     =    clazz . getMethod (  \" instanceMethod \"  ,    String . class )  ;", "String [  ]    names    =    discoverer . getParameterNames ( m 1  )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" one   argument \"  ,     1  ,    names . length )  ;", "assertEquals (  \" aa \"  ,    names [  0  ]  )  ;", "Method   m 2     =    clazz . getMethod (  \" instanceMethod \"  ,    String . class ,    String . class )  ;", "names    =    discoverer . getParameterNames ( m 2  )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" two   arguments \"  ,     2  ,    names . length )  ;", "assertEquals (  \" aa \"  ,    names [  0  ]  )  ;", "assertEquals (  \" bb \"  ,    names [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["overloadedMethodInInnerClass"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   LocalVariableTableParameterNameDiscovererTests >    clazz    =    this . getClass (  )  ;", "Method   m 1     =    clazz . getMethod (  \" staticMethod \"  ,    Long . TYPE ,    Long . TYPE )  ;", "String [  ]    names    =    discoverer . getParameterNames ( m 1  )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" two   arguments \"  ,     2  ,    names . length )  ;", "assertEquals (  \" x \"  ,    names [  0  ]  )  ;", "assertEquals (  \" y \"  ,    names [  1  ]  )  ;", "Method   m 2     =    clazz . getMethod (  \" staticMethod \"  ,    Long . TYPE ,    Long . TYPE ,    Long . TYPE )  ;", "names    =    discoverer . getParameterNames ( m 2  )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" three   arguments \"  ,     3  ,    names . length )  ;", "assertEquals (  \" x \"  ,    names [  0  ]  )  ;", "assertEquals (  \" y \"  ,    names [  1  ]  )  ;", "assertEquals (  \" z \"  ,    names [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["overloadedStaticMethod"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Class < LocalVariableTableParameterNameDiscovererTests . InnerClass >    clazz    =    LocalVariableTableParameterNameDiscovererTests . InnerClass . class ;", "Method   m 1     =    clazz . getMethod (  \" staticMethod \"  ,    Long . TYPE )  ;", "String [  ]    names    =    discoverer . getParameterNames ( m 1  )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" one   argument \"  ,     1  ,    names . length )  ;", "assertEquals (  \" x \"  ,    names [  0  ]  )  ;", "Method   m 2     =    clazz . getMethod (  \" staticMethod \"  ,    Long . TYPE ,    Long . TYPE )  ;", "names    =    discoverer . getParameterNames ( m 2  )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" two   arguments \"  ,     2  ,    names . length )  ;", "assertEquals (  \" x \"  ,    names [  0  ]  )  ;", "assertEquals (  \" y \"  ,    names [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["overloadedStaticMethodInInnerClass"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "long   u    =    x    *    y ;", "return   u ;", "}", "METHOD_END"], "methodName": ["staticMethod"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "long   u    =     ( x    *    y )     *    z ;", "return   u ;", "}", "METHOD_END"], "methodName": ["staticMethod"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    getClass (  )  . getMethod (  \" staticMethodNoLocalVars \"  )  ;", "String [  ]    names    =    discoverer . gets ( m )  ;", "assertNotNull (  \" should   find   method   info \"  ,    names )  ;", "assertEquals (  \" no   argument   names \"  ,     0  ,    names . length )  ;", "}", "METHOD_END"], "methodName": ["staticMethodParameterNameDiscoveryNoArgs"], "fileName": "org.springframework.core.LocalVariableTableParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "if    ( method . getDeclaringClass (  )  . isAssignableFrom ( targetType )  )     {", "return   method ;", "}", "try    {", "String   methodName    =    method . getName (  )  ;", "Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "for    ( Class <  ?  >    ifc    :    targetType . getInterfaces (  )  )     {", "try    {", "return   ifc . get ( methodName ,    parameterTypes )  ;", "}    catch    ( NoSuchException   ex )     {", "}", "}", "return   targetType . get ( methodName ,    parameterTypes )  ;", "}    catch    ( NoSuchException   ex )     {", "throw   new   IllegalStateException ( String . format (  (  \" Need   to   invoke   method    '  % s '    declared   on   target   class    '  % s '  ,     \"     +     (  (  \" but   not   found   in   any   interface ( s )    of   the   exposed   proxy   type .     \"     +     \" Either   pull   the   method   up   to   an   interface   or   switch   to   CGLIB    \"  )     +     \" proxies   by   enforcing   proxy - target - class   mode   in   your   configuration .  \"  )  )  ,    method . getName (  )  ,    method . getDeclaringClass (  )  . getSimpleName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["selectInvocableMethod"], "fileName": "org.springframework.core.MethodIntrospector"}, {"methodBody": ["METHOD_START", "{", "final   Map < Method ,    T >    methodMap    =    new   LinkedHashMap <  >  (  )  ;", "Set < Class <  ?  >  >    handlerTypes    =    new   LinkedHashSet <  >  (  )  ;", "Class <  ?  >    specificHandlerType    =    null ;", "if    (  !  ( Proxy . isProxyClass ( targetType )  )  )     {", "specificHandlerType    =    ClassUtils . getUserClass ( targetType )  ;", "handlerTypes . add ( specificHandlerType )  ;", "}", "handlerTypes . addAll ( ClassUtils . getAllInterfacesForClassAsSet ( targetType )  )  ;", "for    ( Class <  ?  >    currentHandlerType    :    handlerTypes )     {", "final   Class <  ?  >    targetClass    =     ( specificHandlerType    !  =    null )     ?    specificHandlerType    :    currentHandlerType ;", "ReflectionUtils . doWithMethods ( currentHandlerType ,     (    method )     -  >     {", "Method   specificMethod    =    ClassUtils . getMostSpecificMethod ( method ,    targetClass )  ;", "T   result    =    metadataLookup . inspect ( specificMethod )  ;", "if    ( result    !  =    null )     {", "Method   bridgedMethod    =    BridgeMethodResolver . findBridgedMethod ( specificMethod )  ;", "if    (  ( bridgedMethod    =  =    specificMethod )     |  |     (  ( metadataLookup . inspect ( bridgedMethod )  )     =  =    null )  )     {", "methodMap . put ( specificMethod ,    result )  ;", "}", "}", "}  ,    ReflectionUtils . USER _ DECLARED _ METHODS )  ;", "}", "return   methodMap ;", "}", "METHOD_END"], "methodName": ["selectMethods"], "fileName": "org.springframework.core.MethodIntrospector"}, {"methodBody": ["METHOD_START", "{", "return   MethodIntrospector . selectMethods ( targetType ,     (  ( MethodIntrospector . MetadataLookup < Boolean >  )     (  (    method )     -  >    methodFilter . matches ( method )     ?    Boolean . TRUE    :    null )  )  )  . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["selectMethods"], "fileName": "org.springframework.core.MethodIntrospector"}, {"methodBody": ["METHOD_START", "{", "return   annotation ;", "}", "METHOD_END"], "methodName": ["adaptAnnotation"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   annotations ;", "}", "METHOD_END"], "methodName": ["adaptAnnotationArray"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "getTypeIndexesPerLevel (  )  . remove ( this . nestingLevel )  ;", "( this . nestingLevel )  -  -  ;", "}", "METHOD_END"], "methodName": ["decreaseNestingLevel"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "Executable   executable    =    parameter . getDeclaringExecutable (  )  ;", "[  ]    allParams    =    executable . gets (  )  ;", "for    ( int   i    =     0  ;    i    <     ( allParams . length )  ;    i +  +  )     {", "if    ( parameter    =  =     ( allParams [ i ]  )  )     {", "return   i ;", "}", "}", "throw   new   IllegalArgumentException (  (  (  \" Given   parameter    [  \"     +    parameter )     +     \"  ]    does   not   match   any   parameter   in   the   declaring   executable \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findParameterIndex"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "if    ( executable   instanceof   Method )     {", "return   new    (  (  ( Method )     ( executable )  )  ,    parameterIndex )  ;", "} else", "if    ( executable   instanceof   Constructor )     {", "return   new    (  (  ( Constructor <  ?  >  )     ( executable )  )  ,    parameterIndex )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Not   a   Method / Constructor :     \"     +    executable )  )  ;", "}", "}", "METHOD_END"], "methodName": ["forExecutable"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( methodOrConstructor   instanceof   Executable )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Given   object    [  \"     +    methodOrConstructor )     +     \"  ]    is   neither   a   Method   nor   a   Constructor \"  )  )  ;", "}", "return    . forExecutable (  (  ( Executable )     ( methodOrConstructor )  )  ,    parameterIndex )  ;", "}", "METHOD_END"], "methodName": ["forMethodOrConstructor"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   MethodParameter . forExecutable ( parameter . getDeclaringExecutable (  )  ,    MethodParameter . findParameterIndex ( parameter )  )  ;", "}", "METHOD_END"], "methodName": ["forParameter"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . executable ;", "}", "METHOD_END"], "methodName": ["getAnnotatedElement"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . executable )    instanceof   Constructor    ?     (  ( Constructor <  ?  >  )     ( this . executable )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getConstructor"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    containingClass    =    this . containingClass ;", "return   containingClass    !  =    null    ?    containingClass    :    getDeclaClass (  )  ;", "}", "METHOD_END"], "methodName": ["getContainingClass"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . executable . getDeclaringClass (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaringClass"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . executable ;", "}", "METHOD_END"], "methodName": ["getExecutable"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "Type   paramType    =    this . genericParameterType ;", "if    ( paramType    =  =    null )     {", "if    (  ( this . parameterIndex )     <     0  )     {", "Method   method    =    getMethod (  )  ;", "paramType    =     ( method    !  =    null )     ?    method . getGenericReturnType (  )     :    void . class ;", "} else    {", "Type [  ]    genericParameterTypes    =    this . executable . getGenericParameterTypes (  )  ;", "int   index    =    this . parameterIndex ;", "if    (  (  (  ( this . executable )    instanceof   Constructor )     &  &     ( ClassUtils . isInnerClass ( this . executable . getDeclaringClass (  )  )  )  )     &  &     (  ( genericParameterTypes . length )     =  =     (  ( this . executable . getParameterCount (  )  )     -     1  )  )  )     {", "index    =     ( this . parameterIndex )     -     1  ;", "}", "paramType    =     (  ( index    >  =     0  )     &  &     ( index    <     ( genericParameterTypes . length )  )  )     ?    genericParameterTypes [ index ]     :    getParameterType (  )  ;", "}", "this . genericParameterType    =    paramType ;", "}", "return   paramType ;", "}", "METHOD_END"], "methodName": ["getGenericParameterType"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . executable ;", "}", "METHOD_END"], "methodName": ["getMember"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . executable )    instanceof   Method    ?     (  ( Method )     ( this . executable )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "A   annotation    =    getAnnotatedElement (  )  . getAnnotation ( annotationType )  ;", "return   annotation    !  =    null    ?    adaptAnnotation ( annotation )     :    null ;", "}", "METHOD_END"], "methodName": ["getMethodAnnotation"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   adaptAnnotationArray ( getAnnotatedElement (  )  . getAnnotations (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMethodAnnotations"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . nestingLevel )     >     1  )     {", "Type   type    =    getGenericType (  )  ;", "for    ( int   i    =     2  ;    i    <  =     ( this . nestingLevel )  ;    i +  +  )     {", "if    ( type   instanceof   izedType )     {", "Type [  ]    args    =     (  ( izedType )     ( type )  )  . getActualTypeArguments (  )  ;", "Integer   index    =    getTypeIndexForLevel ( i )  ;", "type    =    args [  ( index    !  =    null    ?    index    :     ( args . length )     -     1  )  ]  ;", "}", "}", "return   type ;", "} else    {", "return   getGenericType (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getNestedGenericParameterType"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . nestingLevel )     >     1  )     {", "Type   type    =    getGenericType (  )  ;", "for    ( int   i    =     2  ;    i    <  =     ( this . nestingLevel )  ;    i +  +  )     {", "if    ( type   instanceof   izedType )     {", "Type [  ]    args    =     (  ( izedType )     ( type )  )  . getActualTypeArguments (  )  ;", "Integer   index    =    getTypeIndexForLevel ( i )  ;", "type    =    args [  ( index    !  =    null    ?    index    :     ( args . length )     -     1  )  ]  ;", "}", "}", "if    ( type   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( type )  )  ;", "} else", "if    ( type   instanceof   izedType )     {", "Type   arg    =     (  ( izedType )     ( type )  )  . getRawType (  )  ;", "if    ( arg   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( arg )  )  ;", "}", "}", "return   Object . class ;", "} else    {", "return   getType (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getNestedParameterType"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . nestingLevel ;", "}", "METHOD_END"], "methodName": ["getNestingLevel"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "Parameter   parameter    =    this . parameter ;", "if    ( parameter    =  =    null )     {", "parameter    =    getExecutable (  )  . getParameters (  )  [ this . parameterIndex ]  ;", "this . parameter    =    parameter ;", "}", "return   parameter ;", "}", "METHOD_END"], "methodName": ["getParameter"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    anns    =    getParameterAnnotations (  )  ;", "for    ( Annotation   ann    :    anns )     {", "if    ( annotationType . isInstance ( ann )  )     {", "return    (  ( A )     ( ann )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getParameterAnnotation"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    paramAnns    =    this . parameterAnnotations ;", "if    ( paramAnns    =  =    null )     {", "Annotation [  ]  [  ]    annotationArray    =    this . executable . getParameterAnnotations (  )  ;", "int   index    =    this . parameterIndex ;", "if    (  (  (  ( this . executable )    instanceof   Constructor )     &  &     ( ClassUtils . isInnerClass ( this . executable . getDeclaringClass (  )  )  )  )     &  &     (  ( annotationArray . length )     =  =     (  ( this . executable . getParameterCount (  )  )     -     1  )  )  )     {", "index    =     ( this . parameterIndex )     -     1  ;", "}", "paramAnns    =     (  ( index    >  =     0  )     &  &     ( index    <     ( annotationArray . length )  )  )     ?    adaptAnnotationArray ( annotationArray [ index ]  )     :     . EMPTY _ ANNOTATION _ ARRAY ;", "this . parameterAnnotations    =    paramAnns ;", "}", "return   paramAnns ;", "}", "METHOD_END"], "methodName": ["getParameterAnnotations"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterIndex ;", "}", "METHOD_END"], "methodName": ["getParameterIndex"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "ParameterNameDiscoverer   discoverer    =    this . parameterNameDiscoverer ;", "if    ( discoverer    !  =    null )     {", "String [  ]    parameterNames    =    null ;", "if    (  ( this . executable )    instanceof   Method )     {", "parameterNames    =    discoverer . getParameterNames (  (  ( Method )     ( this . executable )  )  )  ;", "} else", "if    (  ( this . executable )    instanceof   Constructor )     {", "parameterNames    =    discoverer . getParameterNames (  (  ( Constructor <  ?  >  )     ( this . executable )  )  )  ;", "}", "if    ( parameterNames    !  =    null )     {", "this . parameterName    =    parameterNames [ this . parameterIndex ]  ;", "}", "this . parameterNameDiscoverer    =    null ;", "}", "return   this . parameterName ;", "}", "METHOD_END"], "methodName": ["getParameterName"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    paramType    =    this . parameterType ;", "if    ( paramType    =  =    null )     {", "if    (  ( this . parameterIndex )     <     0  )     {", "Method   method    =    getMethod (  )  ;", "paramType    =     ( method    !  =    null )     ?    method . getReturnType (  )     :    void . class ;", "} else    {", "paramType    =    this . executable . getTypes (  )  [ this . parameterIndex ]  ;", "}", "this . parameterType    =    paramType ;", "}", "return   paramType ;", "}", "METHOD_END"], "methodName": ["getParameterType"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   getTypeIndexForLevel ( this . nestingLevel )  ;", "}", "METHOD_END"], "methodName": ["getTypeIndexForCurrentLevel"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   getTypeIndexesPerLevel (  )  . get ( nestingLevel )  ;", "}", "METHOD_END"], "methodName": ["getTypeIndexForLevel"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . typeIndexesPerLevel )     =  =    null )     {", "this . typeIndexesPerLevel    =    new   HashMap <  >  (  4  )  ;", "}", "return   this . typeIndexesPerLevel ;", "}", "METHOD_END"], "methodName": ["getTypeIndexesPerLevel"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   getAnnotatedElement (  )  . isAnnotationPresent ( annotationType )  ;", "}", "METHOD_END"], "methodName": ["hasMethodAnnotation"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "for    ( Annotation   ann    :    getParameterAnnotations (  )  )     {", "if    (  \" Nullable \"  . equals ( ann . annotationType (  )  . getSimpleName (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasNullableAnnotation"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return    ( getParameterAnnotation ( annotationType )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasParameterAnnotation"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return    ( getParameterAnnotations (  )  . length )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["hasParameterAnnotations"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "( this . nestingLevel )  +  +  ;", "}", "METHOD_END"], "methodName": ["increaseNestingLevel"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "this . parameterNameDiscoverer    =    parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["initParameterNameDiscovery"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( getParameterType (  )  )     =  =     ( Optional . class )  )     |  |     ( hasNullableAnnotation (  )  )  )     |  |     (  ( KotlinDetector . isKotlinType ( getContainingClass (  )  )  )     &  &     ( MethodParameter . KotlinDelegate . isOptional ( this )  )  )  ;", "}", "METHOD_END"], "methodName": ["isOptional"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   nestedParam    =    this . nestedMethodParameter ;", "if    ( nestedParam    !  =    null )     {", "return   nestedParam ;", "}", "nestedParam    =    clone (  )  ;", "nestedParam . nestingLevel    =     ( this . nestingLevel )     +     1  ;", "this . nestedMethodParameter    =    nestedParam ;", "return   nestedParam ;", "}", "METHOD_END"], "methodName": ["nested"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "return    ( getParameterType (  )  )     =  =     ( Optional . class )     ?    nested (  )     :    this ;", "}", "METHOD_END"], "methodName": ["nestedIfOptional"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "this . containingClass    =    containingClass ;", "}", "METHOD_END"], "methodName": ["setContainingClass"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "this . parameterType    =    parameterType ;", "}", "METHOD_END"], "methodName": ["setParameterType"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "getTypeIndexesPerLevel (  )  . put ( this . nestingLevel ,    typeIndex )  ;", "}", "METHOD_END"], "methodName": ["setTypeIndexForCurrentLevel"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "int   count    =    executable . getParameterCount (  )  ;", "Assert . isTrue (  ( parameterIndex    <    count )  ,     (  )     -  >     \" Parameter   index   needs   to   be   between    -  1    and    \"     +     ( count    -     1  )  )  ;", "return   parameterIndex ;", "}", "METHOD_END"], "methodName": ["validateIndex"], "fileName": "org.springframework.core.MethodParameter"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    constructor    =    MethodParameterTests . InnerClass . class . getConstructor ( getClass (  )  ,    String . class ,    Callable . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( constructor ,     0  )  ;", "assertEquals ( getClass (  )  ,    methodParameter . getParameterType (  )  )  ;", "assertNull ( methodParameter . getParameterAnnotation ( MethodParameterTests . Param . class )  )  ;", "methodParameter    =    MethodParameter . forExecutable ( constructor ,     1  )  ;", "assertEquals ( String . class ,    methodParameter . getParameterType (  )  )  ;", "assertNotNull (  \" Failed   to   find    @ Param   annotation \"  ,    methodParameter . getParameterAnnotation ( MethodParameterTests . Param . class )  )  ;", "methodParameter    =    MethodParameter . forExecutable ( constructor ,     2  )  ;", "assertEquals ( Callable . class ,    methodParameter . getParameterType (  )  )  ;", "assertNull ( methodParameter . getParameterAnnotation ( MethodParameterTests . Param . class )  )  ;", "}", "METHOD_END"], "methodName": ["annotatedConstructorParameterInInnerClass"], "fileName": "org.springframework.core.MethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    constructor    =    MethodParameterTests . NestedClass . class . getDeclaredConstructor ( String . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( constructor ,     0  )  ;", "assertEquals ( String . class ,    methodParameter . getParameterType (  )  )  ;", "assertNotNull (  \" Failed   to   find    @ Param   annotation \"  ,    methodParameter . getParameterAnnotation ( MethodParameterTests . Param . class )  )  ;", "}", "METHOD_END"], "methodName": ["annotatedConstructorParameterInStaticNestedClass"], "fileName": "org.springframework.core.MethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    constructor    =    MethodParameterTests . InnerClass . class . getConstructor ( getClass (  )  ,    String . class ,    Callable . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( constructor ,     0  )  ;", "assertEquals ( getClass (  )  ,    methodParameter . getParameterType (  )  )  ;", "assertEquals ( getClass (  )  ,    methodParameter . getGenericParameterType (  )  )  ;", "methodParameter    =    MethodParameter . forExecutable ( constructor ,     1  )  ;", "assertEquals ( String . class ,    methodParameter . getParameterType (  )  )  ;", "assertEquals ( String . class ,    methodParameter . getGenericParameterType (  )  )  ;", "methodParameter    =    MethodParameter . forExecutable ( constructor ,     2  )  ;", "assertEquals ( Callable . class ,    methodParameter . getParameterType (  )  )  ;", "assertEquals ( ResolvableType . forClassWithGenerics ( Callable . class ,    Integer . class )  . getType (  )  ,    methodParameter . getGenericParameterType (  )  )  ;", "}", "METHOD_END"], "methodName": ["genericConstructorParameterInInnerClass"], "fileName": "org.springframework.core.MethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "return    4  2  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.core.MethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "method    =    getClass (  )  . getMethod (  \" method \"  ,    String . class ,    Long . TYPE )  ;", "stringParameter    =    new    ( method ,     0  )  ;", "longParameter    =    new    ( method ,     1  )  ;", "intReturnType    =    new    ( method ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.core.MethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( stringParameter ,    stringParameter )  ;", "assertEquals ( longParameter ,    longParameter )  ;", "assertEquals ( intReturnType ,    intReturnType )  ;", "assertFalse ( stringParameter . equals ( longParameter )  )  ;", "assertFalse ( stringParameter . equals ( intReturnType )  )  ;", "assertFalse ( longParameter . equals ( stringParameter )  )  ;", "assertFalse ( longParameter . equals ( intReturnType )  )  ;", "assertFalse ( intReturnType . equals ( stringParameter )  )  ;", "assertFalse ( intReturnType . equals ( longParameter )  )  ;", "Method   method    =    getClass (  )  . getMethod (  \" method \"  ,    String . class ,    Long . TYPE )  ;", "methodParameter    =    new    ( method ,     0  )  ;", "assertEquals ( stringParameter ,    methodParameter )  ;", "assertEquals ( methodParameter ,    stringParameter )  ;", "assertNotEquals ( longParameter ,    methodParameter )  ;", "assertNotEquals ( methodParameter ,    longParameter )  ;", "}", "METHOD_END"], "methodName": ["testEquals"], "fileName": "org.springframework.core.MethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( stringParameter ,    MethodParameter . forMethodOrConstructor ( method ,     0  )  )  ;", "assertEquals ( longParameter ,    MethodParameter . forMethodOrConstructor ( method ,     1  )  )  ;", "assertEquals ( stringParameter ,    MethodParameter . forExecutable ( method ,     0  )  )  ;", "assertEquals ( longParameter ,    MethodParameter . forExecutable ( method ,     1  )  )  ;", "assertEquals ( stringParameter ,    MethodParameter . forParameter ( method . getParameters (  )  [  0  ]  )  )  ;", "assertEquals ( longParameter ,    MethodParameter . forParameter ( method . getParameters (  )  [  1  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryMethods"], "fileName": "org.springframework.core.MethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( stringParameter . hashCode (  )  ,    stringParameter . hashCode (  )  )  ;", "assertEquals ( longParameter . hashCode (  )  ,    longParameter . hashCode (  )  )  ;", "assertEquals ( intReturnType . hashCode (  )  ,    intReturnType . hashCode (  )  )  ;", "Method   method    =    getClass (  )  . getMethod (  \" method \"  ,    String . class ,    Long . TYPE )  ;", "methodParameter    =    new    ( method ,     0  )  ;", "assertEquals ( stringParameter . hashCode (  )  ,    methodParameter . hashCode (  )  )  ;", "assertNotEquals ( longParameter . hashCode (  )  ,    methodParameter . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHashCode"], "fileName": "org.springframework.core.MethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "new   MethodParameter ( method ,     2  )  ;", "}", "METHOD_END"], "methodName": ["testIndexValidation"], "fileName": "org.springframework.core.MethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "if    ( exType    =  =    null )     {", "return   false ;", "}", "if    ( exType . isInstance ( this )  )     {", "return   true ;", "}", "Throwable   cause    =    getCause (  )  ;", "if    ( cause    =  =     ( this )  )     {", "return   false ;", "}", "if    ( cause   instanceof    )     {", "return    (  (  )     ( cause )  )  . contains ( exType )  ;", "} else    {", "while    ( cause    !  =    null )     {", "if    ( exType . isInstance ( cause )  )     {", "return   true ;", "}", "if    (  ( cause . getCause (  )  )     =  =    cause )     {", "break ;", "}", "cause    =    cause . getCause (  )  ;", "}", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.springframework.core.NestedCheckedException"}, {"methodBody": ["METHOD_START", "{", "Throwable   rootCause    =    getRootCause (  )  ;", "turn   rootCause    !  =    null    ?    rootCause    :    this ;", "}", "METHOD_END"], "methodName": ["getMostSpecificCause"], "fileName": "org.springframework.core.NestedCheckedException"}, {"methodBody": ["METHOD_START", "{", "return   NestedExceptionUtils . getRootCause ( this )  ;", "}", "METHOD_END"], "methodName": ["getRootCause"], "fileName": "org.springframework.core.NestedCheckedException"}, {"methodBody": ["METHOD_START", "{", "String   mesg    =     \" mesg   of   mine \"  ;", "NestedCheck   nex    =    new   NestedCheck ( mesg )     {  }  ;", "assertNull ( nex . getCause (  )  )  ;", "assertEquals ( nex . getMessage (  )  ,    mesg )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "nex . printStackTrace ( pw )  ;", "pw . flush (  )  ;", "String   stackTrace    =    new   String ( baos . toByteArray (  )  )  ;", "assertTrue ( stackTrace . contains ( mesg )  )  ;", "}", "METHOD_END"], "methodName": ["nestedCheckedExceptionWithNoRootCause"], "fileName": "org.springframework.core.NestedExceptionTests"}, {"methodBody": ["METHOD_START", "{", "String   myMessage    =     \" mesg   for   this   exception \"  ;", "String   rootCauseMsg    =     \" this   is   the   obscure   message   of   the   root   cause \"  ;", "Exception   rootCause    =    new   Exception ( rootCauseMsg )  ;", "NestedCheck   nex    =    new   NestedCheck ( myMessage ,    rootCause )     {  }  ;", "assertEquals ( nex . getCause (  )  ,    rootCause )  ;", "assertTrue ( nex . getMessage (  )  . contains ( myMessage )  )  ;", "assertTrue ( nex . getMessage (  )  . endsWith ( rootCauseMsg )  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "nex . printStackTrace ( pw )  ;", "pw . flush (  )  ;", "String   stackTrace    =    new   String ( baos . toByteArray (  )  )  ;", "assertTrue ( stackTrace . contains ( rootCause . getClass (  )  . getName (  )  )  )  ;", "assertTrue ( stackTrace . contains ( rootCauseMsg )  )  ;", "}", "METHOD_END"], "methodName": ["nestedCheckedExceptionWithRootCause"], "fileName": "org.springframework.core.NestedExceptionTests"}, {"methodBody": ["METHOD_START", "{", "String   mesg    =     \" mesg   of   mine \"  ;", "NestedRuntime   nex    =    new   NestedRuntime ( mesg )     {  }  ;", "assertNull ( nex . getCause (  )  )  ;", "assertEquals ( nex . getMessage (  )  ,    mesg )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "nex . printStackTrace ( pw )  ;", "pw . flush (  )  ;", "String   stackTrace    =    new   String ( baos . toByteArray (  )  )  ;", "assertTrue ( stackTrace . contains ( mesg )  )  ;", "}", "METHOD_END"], "methodName": ["nestedRuntimeExceptionWithNoRootCause"], "fileName": "org.springframework.core.NestedExceptionTests"}, {"methodBody": ["METHOD_START", "{", "String   myMessage    =     \" mesg   for   this   exception \"  ;", "String   rootCauseMsg    =     \" this   is   the   obscure   message   of   the   root   cause \"  ;", "rootCause    =    new    ( rootCauseMsg )  ;", "NestedRuntime   nex    =    new   NestedRuntime ( myMessage ,    rootCause )     {  }  ;", "assertEquals ( nex . getCause (  )  ,    rootCause )  ;", "assertTrue ( nex . getMessage (  )  . contains ( myMessage )  )  ;", "assertTrue ( nex . getMessage (  )  . endsWith ( rootCauseMsg )  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "nex . printStackTrace ( pw )  ;", "pw . flush (  )  ;", "String   stackTrace    =    new   String ( baos . toByteArray (  )  )  ;", "assertTrue ( stackTrace . contains ( rootCause . getClass (  )  . getName (  )  )  )  ;", "assertTrue ( stackTrace . contains ( rootCauseMsg )  )  ;", "}", "METHOD_END"], "methodName": ["nestedRuntimeExceptionWithRootCause"], "fileName": "org.springframework.core.NestedExceptionTests"}, {"methodBody": ["METHOD_START", "{", "if    ( cause    =  =    null )     {", "return   message ;", "}", "StringBuilder   sb    =    new   StringBuilder (  6  4  )  ;", "if    ( message    !  =    null )     {", "sb . append ( message )  . append (  \"  ;     \"  )  ;", "}", "sb . append (  \" nested   e   is    \"  )  . append ( cause )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["buildMessage"], "fileName": "org.springframework.core.NestedExceptionUtils"}, {"methodBody": ["METHOD_START", "{", "Throwable   rootCause    =    NestedExceptionUtils . getRootCause ( original )  ;", "return   rootCause    !  =    null    ?    rootCause    :    original ;", "}", "METHOD_END"], "methodName": ["getMostSpecificCause"], "fileName": "org.springframework.core.NestedExceptionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( original    =  =    null )     {", "return   null ;", "}", "Throwable   rootCause    =    null ;", "Throwable   cause    =    original . getCause (  )  ;", "while    (  ( cause    !  =    null )     &  &     ( cause    !  =    rootCause )  )     {", "rootCause    =    cause ;", "cause    =    cause . getCause (  )  ;", "}", "return   rootCause ;", "}", "METHOD_END"], "methodName": ["getRootCause"], "fileName": "org.springframework.core.NestedExceptionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( exType    =  =    null )     {", "return   false ;", "}", "if    ( exType . isInstance ( this )  )     {", "return   true ;", "}", "Throwable   cause    =    getCause (  )  ;", "if    ( cause    =  =     ( this )  )     {", "return   false ;", "}", "if    ( cause   instanceof    )     {", "return    (  (  )     ( cause )  )  . contains ( exType )  ;", "} else    {", "while    ( cause    !  =    null )     {", "if    ( exType . isInstance ( cause )  )     {", "return   true ;", "}", "if    (  ( cause . getCause (  )  )     =  =    cause )     {", "break ;", "}", "cause    =    cause . getCause (  )  ;", "}", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.springframework.core.NestedRuntimeException"}, {"methodBody": ["METHOD_START", "{", "Throwable   rootCause    =    getRootCause (  )  ;", "turn   rootCause    !  =    null    ?    rootCause    :    this ;", "}", "METHOD_END"], "methodName": ["getMostSpecificCause"], "fileName": "org.springframework.core.NestedRuntimeException"}, {"methodBody": ["METHOD_START", "{", "return   NestedExceptionUtils . getRootCause ( this )  ;", "}", "METHOD_END"], "methodName": ["getRootCause"], "fileName": "org.springframework.core.NestedRuntimeException"}, {"methodBody": ["METHOD_START", "{", "boolean   p 1     =    o 1    instanceof   PriorityOrdered ;", "boolean   p 2     =    o 2    instanceof   PriorityOrdered ;", "if    ( p 1     &  &     (  ! p 2  )  )     {", "return    -  1  ;", "} else", "if    ( p 2     &  &     (  ! p 1  )  )     {", "return    1  ;", "}", "int   i 1     =    getOrder ( o 1  ,    sourceProvider )  ;", "int   i 2     =    getOrder ( o 2  ,    sourceProvider )  ;", "return   i 1     <    i 2     ?     -  1     :    i 1     >    i 2     ?     1     :     0  ;", "}", "METHOD_END"], "methodName": ["doCompare"], "fileName": "org.springframework.core.OrderComparator"}, {"methodBody": ["METHOD_START", "{", "return   obj   instanceof   Ordered    ?     (  ( Ordered )     ( obj )  )  . getOrder (  )     :    null ;", "}", "METHOD_END"], "methodName": ["findOrder"], "fileName": "org.springframework.core.OrderComparator"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    !  =    null )     {", "Integer   order    =    find ( obj )  ;", "if    ( order    !  =    null )     {", "return   order ;", "}", "}", "return   ed . LOWEST _ PRECEDENCE ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.core.OrderComparator"}, {"methodBody": ["METHOD_START", "{", "Integer   order    =    null ;", "if    (  ( obj    !  =    null )     &  &     ( sourceProvider    !  =    null )  )     {", "Object   orderSource    =    sourceProvider . getSource ( obj )  ;", "if    ( orderSource    !  =    null )     {", "if    ( orderSource . getClass (  )  . isArray (  )  )     {", "Object [  ]    sources    =    ObjectUtils . toObjectArray ( orderSource )  ;", "for    ( Object   source    :    sources )     {", "order    =    find ( source )  ;", "if    ( order    !  =    null )     {", "break ;", "}", "}", "} else    {", "order    =    find ( orderSource )  ;", "}", "}", "}", "return   order    !  =    null    ?    order    :    get ( obj )  ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.core.OrderComparator"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getPriority"], "fileName": "org.springframework.core.OrderComparator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( array . length )     >     1  )     {", "Arrays . sort ( array ,     . INSTANCE )  ;", "}", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "org.springframework.core.OrderComparator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( list . size (  )  )     >     1  )     {", "list . sort (  . INSTANCE )  ;", "}", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "org.springframework.core.OrderComparator"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   Object [  ]  )     {", ". sort (  (  ( Object [  ]  )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   List )     {", ". sort (  (  ( List <  ?  >  )     ( value )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sortIfNecessary"], "fileName": "org.springframework.core.OrderComparator"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    this . comparator . compare ( new   OrderComparatorTests . StubOrdered (  9  8  2  3  0  0  )  ,    new   OrderComparatorTests . StubOrdered (  1  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compareOrderedInstancesAfter"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  -  1  )  ,    this . comparator . compare ( new   OrderComparatorTests . StubOrdered (  1  0  0  )  ,    new   OrderComparatorTests . StubOrdered (  2  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compareOrderedInstancesBefore"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . comparator . compare ( null ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["compareOrderedInstancesDoubleNull"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    this . comparator . compare ( null ,    new   OrderComparatorTests . StubOrdered (  1  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compareOrderedInstancesNullFirst"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  -  1  )  ,    this . comparator . compare ( new   OrderComparatorTests . StubOrdered (  1  0  0  )  ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["compareOrderedInstancesNullLast"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . comparator . compare ( new   OrderComparatorTests . StubOrdered (  1  0  0  )  ,    new   OrderComparatorTests . StubOrdered (  1  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compareOrderedInstancesSame"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    this . comparator . compare ( new   Object (  )  ,    new   Object (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTwoNonOrderedInstancesEndsUpAsSame"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    customComparator    =    this . comparator . withSourceProvider ( new   OrderComparatorTests . TestSourceProvider (  5 L ,    new   OrderComparatorTests . StubOrdered (  2  5  )  )  )  ;", "assertEquals (  (  -  1  )  ,    customComparator . compare ( new   OrderComparatorTests . StubOrdered (  1  0  )  ,     5 L )  )  ;", "}", "METHOD_END"], "methodName": ["compareWithSimpleSourceProvider"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    customComparator    =    this . comparator . withSourceProvider ( new   OrderComparatorTests . TestSourceProvider (  5 L ,    new   Object [  ]  {    new   OrderComparatorTests . StubOrdered (  1  0  )  ,    new   OrderComparatorTests . StubOrdered (  (  -  2  5  )  )     }  )  )  ;", "assertEquals (  (  -  1  )  ,    customComparator . compare (  5 L ,    new   Object (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compareWithSourceProviderArray"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    customComparator    =    this . comparator . withSourceProvider ( new   OrderComparatorTests . TestSourceProvider (  5 L ,    new   Object [  ]  {    new   Object (  )  ,    new   Object (  )     }  )  )  ;", "assertEquals (  0  ,    customComparator . compare ( new   Object (  )  ,     5 L )  )  ;", "}", "METHOD_END"], "methodName": ["compareWithSourceProviderArrayNoMatch"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    customComparator    =    this . comparator . withSourceProvider ( new   OrderComparatorTests . TestSourceProvider (  5  0 L ,    new   Object (  )  )  )  ;", "assertEquals (  0  ,    customComparator . compare ( new   Object (  )  ,     5 L )  )  ;", "}", "METHOD_END"], "methodName": ["compareWithSourceProviderEmpty"], "fileName": "org.springframework.core.OrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "return    !  ( isExcluded ( className )  )  ;", "}", "METHOD_END"], "methodName": ["isEligibleForOverriding"], "fileName": "org.springframework.core.OverridingClassLoader"}, {"methodBody": ["METHOD_START", "{", "InputStream   is    =    openStreamForClass ( name )  ;", "if    ( is    =  =    null )     {", "return   null ;", "}", "try    {", "byte [  ]    bytes    =    FileCopyUtils . copyToByteArray ( is )  ;", "return   transformIfNecessary ( name ,    bytes )  ;", "}    catch    ( IOException   ex )     {", "throw   new   ClassNotFoundException (  (  (  \" Cannot   load   resource   for   class    [  \"     +    name )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["loadBytesForClass"], "fileName": "org.springframework.core.OverridingClassLoader"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    result    =    findLoadedClass ( name )  ;", "if    ( result    =  =    null )     {", "byte [  ]    bytes    =    loadBytesForClass ( name )  ;", "if    ( bytes    !  =    null )     {", "result    =    defineClass ( name ,    bytes ,     0  ,    bytes . length )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["loadClassForOverriding"], "fileName": "org.springframework.core.OverridingClassLoader"}, {"methodBody": ["METHOD_START", "{", "String   internalName    =     ( name . replace (  '  .  '  ,     '  /  '  )  )     +     ( OverridingClassLoader . CLASS _ FILE _ SUFFIX )  ;", "return   getParent (  )  . getResourceAsStream ( internalName )  ;", "}", "METHOD_END"], "methodName": ["openStreamForClass"], "fileName": "org.springframework.core.OverridingClassLoader"}, {"methodBody": ["METHOD_START", "{", "return   bytes ;", "}", "METHOD_END"], "methodName": ["transformIfNecessary"], "fileName": "org.springframework.core.OverridingClassLoader"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    parent    =    child . getSuperclass (  )  ;", "if    (  ( Object . class )     =  =    parent )     {", "throw   new   IllegalStateException (  \" Expected      superclass \"  )  ;", "} else", "if    (  (  . class )     =  =    parent )     {", "return   child ;", "} else    {", "return    . findSubclass ( parent )  ;", "}", "}", "METHOD_END"], "methodName": ["findParameterizedTypeReferenceSubclass"], "fileName": "org.springframework.core.ParameterizedTypeReference"}, {"methodBody": ["METHOD_START", "{", "return   new   ParameterizedTypeReference < T >  ( type )     {  }  ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.springframework.core.ParameterizedTypeReference"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.core.ParameterizedTypeReference"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["listMethod"], "fileName": "org.springframework.core.ParameterizedTypeReferenceTests"}, {"methodBody": ["METHOD_START", "{", "Type   listType    =    getClass (  )  . getMethod (  \" listMethod \"  )  . getGenericReturnType (  )  ;", "< List < String >  >    typeReference    =    new    < List < String >  >  (  )     {  }  ;", "assertEquals ( listType ,    typeReference . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["listTypeReference"], "fileName": "org.springframework.core.ParameterizedTypeReferenceTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["mapMethod"], "fileName": "org.springframework.core.ParameterizedTypeReferenceTests"}, {"methodBody": ["METHOD_START", "{", "Type   mapType    =    getClass (  )  . getMethod (  \" mapMethod \"  )  . getGenericReturnType (  )  ;", "< Map < Object ,    String >  >    typeReference    =    new    < Map < Object ,    String >  >  (  )     {  }  ;", "assertEquals ( mapType ,    typeReference . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["mapTypeReference"], "fileName": "org.springframework.core.ParameterizedTypeReferenceTests"}, {"methodBody": ["METHOD_START", "{", "Type   listType    =    getClass (  )  . getMethod (  \" listMethod \"  )  . getGenericReturnType (  )  ;", "<  ?  >    typeReference    =     . forType ( listType )  ;", "assertEquals ( listType ,    typeReference . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["reflectiveTypeReferenceWithGenericDeclaration"], "fileName": "org.springframework.core.ParameterizedTypeReferenceTests"}, {"methodBody": ["METHOD_START", "{", "Type   listType    =    getClass (  )  . getMethod (  \" listMethod \"  )  . getGenericReturnType (  )  ;", "< List < String >  >    typeReference    =     . forType ( listType )  ;", "assertEquals ( listType ,    typeReference . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["reflectiveTypeReferenceWithSpecificDeclaration"], "fileName": "org.springframework.core.ParameterizedTypeReferenceTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedTypeReference < String >    typeReference    =    new   ParameterizedTypeReference < String >  (  )     {  }  ;", "assertEquals ( String . class ,    typeReference . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["stringTypeReference"], "fileName": "org.springframework.core.ParameterizedTypeReferenceTests"}, {"methodBody": ["METHOD_START", "{", "this . parameterNameDiscoverers . add ( pnd )  ;", "}", "METHOD_END"], "methodName": ["addDiscoverer"], "fileName": "org.springframework.core.PrioritizedParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "ParameterNameDiscoverer   pnd    =    new   PrioritizedParameterNameDiscoverer (  )  ;", "assertNull ( pnd . getParameterNames ( anyMethod )  )  ;", "assertNull ( pnd . getParameterNames (  (  ( Constructor <  ?  >  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["noParametersDiscoverers"], "fileName": "org.springframework.core.PrioritizedParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "PrioritizedParameterNameDiscoverer   pnd    =    new   PrioritizedParameterNameDiscoverer (  )  ;", "pnd . addDiscoverer ( returnsFooBar )  ;", "assertTrue ( Arrays . equals (  . FOO _ BAR ,    pnd . getParameterNames ( anyMethod )  )  )  ;", "assertTrue ( Arrays . equals (  . FOO _ BAR ,    pnd . getParameterNames (  (  ( Constructor <  ?  >  )     ( null )  )  )  )  )  ;", "pnd . addDiscoverer ( returnsSomethingElse )  ;", "assertTrue ( Arrays . equals (  . FOO _ BAR ,    pnd . getParameterNames ( anyMethod )  )  )  ;", "assertTrue ( Arrays . equals (  . FOO _ BAR ,    pnd . getParameterNames (  (  ( Constructor <  ?  >  )     ( null )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["orderedParameterDiscoverers1"], "fileName": "org.springframework.core.PrioritizedParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "PrioritizedParameterNameDiscoverer   pnd    =    new   PrioritizedParameterNameDiscoverer (  )  ;", "pnd . addDiscoverer ( returnsSomethingElse )  ;", "assertTrue ( Arrays . equals (  . SOMETHING _ ELSE ,    pnd . getParameterNames ( anyMethod )  )  )  ;", "assertTrue ( Arrays . equals (  . SOMETHING _ ELSE ,    pnd . getParameterNames (  (  ( Constructor <  ?  >  )     ( null )  )  )  )  )  ;", "pnd . addDiscoverer ( returnsFooBar )  ;", "assertTrue ( Arrays . equals (  . SOMETHING _ ELSE ,    pnd . getParameterNames ( anyMethod )  )  )  ;", "assertTrue ( Arrays . equals (  . SOMETHING _ ELSE ,    pnd . getParameterNames (  (  ( Constructor <  ?  >  )     ( null )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["orderedParameterDiscoverers2"], "fileName": "org.springframework.core.PrioritizedParameterNameDiscovererTests"}, {"methodBody": ["METHOD_START", "{", "return   this . fromPublisherFunction . apply ( publisher )  ;", "}", "METHOD_END"], "methodName": ["fromPublisher"], "fileName": "org.springframework.core.ReactiveAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.springframework.core.ReactiveAdapter"}, {"methodBody": ["METHOD_START", "{", "return   getDescriptor (  )  . getReactiveType (  )  ;", "}", "METHOD_END"], "methodName": ["getReactiveType"], "fileName": "org.springframework.core.ReactiveAdapter"}, {"methodBody": ["METHOD_START", "{", "return   getDescriptor (  )  . isMultiValue (  )  ;", "}", "METHOD_END"], "methodName": ["isMultiValue"], "fileName": "org.springframework.core.ReactiveAdapter"}, {"methodBody": ["METHOD_START", "{", "return   getDescriptor (  )  . isNoValue (  )  ;", "}", "METHOD_END"], "methodName": ["isNoValue"], "fileName": "org.springframework.core.ReactiveAdapter"}, {"methodBody": ["METHOD_START", "{", "return   getDescriptor (  )  . supportsEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["supportsEmpty"], "fileName": "org.springframework.core.ReactiveAdapter"}, {"methodBody": ["METHOD_START", "{", "if    ( source    =  =    null )     {", "source    =    getDescriptor (  )  . getEmptyValue (  )  ;", "}", "return    (  ( Publisher < T >  )     ( this . toPublisherFunon . apply ( source )  )  )  ;", "}", "METHOD_END"], "methodName": ["toPublisher"], "fileName": "org.springframework.core.ReactiveAdapter"}, {"methodBody": ["METHOD_START", "{", "return   getAdapter ( reactiveType ,    null )  ;", "}", "METHOD_END"], "methodName": ["getAdapter"], "fileName": "org.springframework.core.ReactiveAdapterRegistry"}, {"methodBody": ["METHOD_START", "{", "Object   sourceToUse    =     ( source   instanceof   Optional )     ?     (  ( Optional <  ?  >  )     ( source )  )  . orElse ( null )     :    source ;", "Class <  ?  >    clazz    =     ( sourceToUse    !  =    null )     ?    sourceToUse . getClass (  )     :    reactiveType ;", "if    ( clazz    =  =    null )     {", "return   null ;", "}", "return   this . adapters . stream (  )  . filter (  (    adapter )     -  >     ( adapter . getType (  )  )     =  =    clazz )  . findFirst (  )  . orElseGet (  (  )     -  >    this . adapters . stream (  )  . filter (  (    adapter )     -  >    adapter . getType (  )  . isAssignableFrom ( clazz )  )  . findFirst (  )  . orElse ( null )  )  ;", "}", "METHOD_END"], "methodName": ["getAdapter"], "fileName": "org.springframework.core.ReactiveAdapterRegistry"}, {"methodBody": ["METHOD_START", "{", "ReactiveAdapterRegistry   ar    =    ReactiveAdapterRegistry . sharedInstance ;", "if    ( ar    =  =    null )     {", "synchronized ( ReactiveAdapterRegistry . class )     {", "ar    =    ReactiveAdapterRegistry . sharedInstance ;", "if    ( ar    =  =    null )     {", "ar    =    new   ReactiveAdapterRegistry (  )  ;", "ReactiveAdapterRegistry . sharedInstance    =    ar ;", "}", "}", "}", "return   ar ;", "}", "METHOD_END"], "methodName": ["getSharedInstance"], "fileName": "org.springframework.core.ReactiveAdapterRegistry"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . adapters . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasAdapters"], "fileName": "org.springframework.core.ReactiveAdapterRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( reactorPresent )     {", "this . adapters . add ( new    . ReactorAdapter ( descriptor ,    toAdapter ,    fromAdapter )  )  ;", "} else    {", "this . adapters . add ( new   ReactiveAdapter ( descriptor ,    toAdapter ,    fromAdapter )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerReactiveType"], "fileName": "org.springframework.core.ReactiveAdapterRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . emptyValueSupplier )     !  =    null )  ,     \" Empty   values   not   supported \"  )  ;", "return   this . emptyValueSupplier . get (  )  ;", "}", "METHOD_END"], "methodName": ["getEmptyValue"], "fileName": "org.springframework.core.ReactiveTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . reactiveType ;", "}", "METHOD_END"], "methodName": ["getReactiveType"], "fileName": "org.springframework.core.ReactiveTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . multiValue ;", "}", "METHOD_END"], "methodName": ["isMultiValue"], "fileName": "org.springframework.core.ReactiveTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . noValue ;", "}", "METHOD_END"], "methodName": ["isNoValue"], "fileName": "org.springframework.core.ReactiveTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   ReactiveTypeDescriptor ( type ,    emptySupplier ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["multiValue"], "fileName": "org.springframework.core.ReactiveTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   ReactiveTypeDescriptor ( type ,    emptySupplier ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["noValue"], "fileName": "org.springframework.core.ReactiveTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   ReactiveTypeDescriptor ( type ,    emptySupplier ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["singleOptionalValue"], "fileName": "org.springframework.core.ReactiveTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   ReactiveTypeDescriptor ( type ,    null ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["singleRequiredValue"], "fileName": "org.springframework.core.ReactiveTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return    ( this . emptyValueSupplier )     !  =    null ;", "}", "METHOD_END"], "methodName": ["supportsEmpty"], "fileName": "org.springframework.core.ReactiveTypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =     ( ResolvableType . NONE )  )     {", "return   ResolvableType . NONE ;", "}", "if    ( ObjectUtils . nullSafeEquals ( resolve (  )  ,    type )  )     {", "return   this ;", "}", "for    ( ResolvableType   interfaceType    :    getInterfaces (  )  )     {", "ResolvableType   interfaceAsType    =    interfaceType . as ( type )  ;", "if    ( interfaceAsType    !  =     ( ResolvableType . NONE )  )     {", "return   interfaceAsType ;", "}", "}", "return   getSuperType (  )  . as ( type )  ;", "}", "METHOD_END"], "methodName": ["as"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   as ( Collection . class )  ;", "}", "METHOD_END"], "methodName": ["asCollection"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   as ( Map . class )  ;", "}", "METHOD_END"], "methodName": ["asMap"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =     ( ResolvableType . NONE )  )     {", "return   null ;", "}", "return   new   ResolvableType . DefaultVariableResolver (  )  ;", "}", "METHOD_END"], "methodName": ["asVariableResolver"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    ObjectUtils . nullSafeHashCode ( this . type )  ;", "if    (  ( this . typeProvider )     !  =    null )     {", "hashCode    =     (  3  1     *    hashCode )     +     ( ObjectUtils . nullSafeHashCode ( this . typeProvider . getType (  )  )  )  ;", "}", "if    (  ( this . variableer )     !  =    null )     {", "hashCode    =     (  3  1     *    hashCode )     +     ( ObjectUtils . nullSafeHashCode ( this . variableer . getSource (  )  )  )  ;", "}", "if    (  ( this . componentType )     !  =    null )     {", "hashCode    =     (  3  1     *    hashCode )     +     ( ObjectUtils . nullSafeHashCode ( this . componentType )  )  ;", "}", "return   hashCode ;", "}", "METHOD_END"], "methodName": ["calculateHashCode"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "ResolvableType . cache . clear (  )  ;", "SerializableTypeWrapper . cache . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( componentType ,     \" Component   type   must   not   be   null \"  )  ;", "Class <  ?  >    arrayClass    =    Array . newInstance ( componentType . resolve (  )  ,     0  )  . getClass (  )  ;", "return   new    ( arrayClass ,    null ,    null ,    componentType )  ;", "}", "METHOD_END"], "methodName": ["forArrayComponent"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   new   ResolvableType ( clazz )  ;", "}", "METHOD_END"], "methodName": ["forClass"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( baseType ,     \" Base   type   must   not   be   null \"  )  ;", "asType    =     . forType ( implementationClass )  . as ( baseType )  ;", "return   asType    =  =     (  . NONE )     ?     . forType ( baseType )     :    asType ;", "}", "METHOD_END"], "methodName": ["forClass"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( generics ,     \" Generics   array   must   not   be   null \"  )  ;", "[  ]    resolvableGenerics    =    new    [ generics . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( generics . length )  ;    i +  +  )     {", "resolvableGenerics [ i ]     =     . forClass ( generics [ i ]  )  ;", "}", "return    . forClassWithGenerics ( clazz ,    resolvableGenerics )  ;", "}", "METHOD_END"], "methodName": ["forClassWithGenerics"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( generics ,     \" Generics   array   must   not   be   null \"  )  ;", "TypeVariable <  ?  >  [  ]    variables    =    clazz . getTypeParameters (  )  ;", "Assert . isTrue (  (  ( variables . length )     =  =     ( generics . length )  )  ,     \" Mismatched   number   of   generics   specified \"  )  ;", "Type [  ]    arguments    =    new   Type [ generics . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( generics . length )  ;    i +  +  )     {", "generic    =    generics [ i ]  ;", "Type   argument    =     ( generic    !  =    null )     ?    generic . getType (  )     :    null ;", "arguments [ i ]     =     (  ( argument    !  =    null )     &  &     (  !  ( argument   instanceof   TypeVariable )  )  )     ?    argument    :    variables [ i ]  ;", "}", "ParameterizedType   syntheticType    =    new    . SyntheticParameterizedType ( clazz ,    arguments )  ;", "return    . forType ( syntheticType ,    new    . TypeVariablesVariableResolver ( variables ,    generics )  )  ;", "}", "METHOD_END"], "methodName": ["forClassWithGenerics"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( constructor ,     \" Constructor   must   not   be   null \"  )  ;", "return    . forMethodParameter ( new   MethodParameter ( constructor ,    parameterIndex )  )  ;", "}", "METHOD_END"], "methodName": ["forConstructorParameter"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( constructor ,     \" Constructor   must   not   be   null \"  )  ;", "MethodParameter   methodParameter    =    new   MethodParameter ( constructor ,    parameterIndex )  ;", "methodParameter . setContainingClass ( implementationClass )  ;", "return    . forMethodParameter ( methodParameter )  ;", "}", "METHOD_END"], "methodName": ["forConstructorParameter"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( field ,     \" Field   must   not   be   null \"  )  ;", "return    . forType ( null ,    new   SerializableTypeWrapper . FieldTypeProvider ( field )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( field ,     \" Field   must   not   be   null \"  )  ;", "return    . forType ( null ,    new   SerializableTypeWrapper . FieldTypeProvider ( field )  ,    null )  . getNested ( nestingLevel )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( field ,     \" Field   must   not   be   null \"  )  ;", "owner    =     . forType ( implementationClass )  . as ( field . getDeclaringClass (  )  )  ;", "return    . forType ( null ,    new   SerializableTypeWrapper . FieldTypeProvider ( field )  ,    owner . asVariableResolver (  )  )  . getNested ( nestingLevel )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( field ,     \" Field   must   not   be   null \"  )  ;", "owner    =     . forType ( implementationClass )  . as ( field . getDeclaringClass (  )  )  ;", "return    . forType ( null ,    new   SerializableTypeWrapper . FieldTypeProvider ( field )  ,    owner . asVariableResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( field ,     \" Field   must   not   be   null \"  )  ;", "owner    =     ( implementationType    !  =    null )     ?    implementationType    :     . NONE ;", "owner    =    owner . as ( field . getDeclaringClass (  )  )  ;", "return    . forType ( null ,    new   SerializableTypeWrapper . FieldTypeProvider ( field )  ,    owner . asVariableResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( instance ,     \" Instance   must   not   be   null \"  )  ;", "if    ( instance   instanceof   Provider )     {", "type    =     (  ( Provider )     ( instance )  )  . get (  )  ;", "if    ( type    !  =    null )     {", "return   type ;", "}", "}", "return    . forClass ( instance . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["forInstance"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "return    . forMethodParameter ( new   MethodParameter ( method ,    parameterIndex )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameter"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "MethodParameter   methodParameter    =    new   MethodParameter ( method ,    parameterIndex )  ;", "methodParameter . setContainingClass ( implementationClass )  ;", "return    . forMethodParameter ( methodParameter )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameter"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forMethodParameter ( methodParameter ,     (  ( Type )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameter"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( methodParameter ,     \" MethodParameter   must   not   be   null \"  )  ;", "owner    =     . forType ( methodParameter . getContainingClass (  )  )  . as ( methodParameter . getDeclaringClass (  )  )  ;", "return    . forType ( targetType ,    new   SerializableTypeWrapper . MethodParameterTypeProvider ( methodParameter )  ,    owner . asVariableResolver (  )  )  . getNested ( methodParameter . getNestingLevel (  )  ,    methodParameter . typeIndexesPerLevel )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameter"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( methodParameter ,     \" MethodParameter   must   not   be   null \"  )  ;", "implementationType    =     ( implementationType    !  =    null )     ?    implementationType    :     . forType ( methodParameter . getContainingClass (  )  )  ;", "owner    =    implementationType . as ( methodParameter . getDeclaringClass (  )  )  ;", "return    . forType ( null ,    new   SerializableTypeWrapper . MethodParameterTypeProvider ( methodParameter )  ,    owner . asVariableResolver (  )  )  . getNested ( methodParameter . getNestingLevel (  )  ,    methodParameter . typeIndexesPerLevel )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameter"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "return    . forMethodParameter ( new   MethodParameter ( method ,     (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodReturnType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "MethodParameter   methodParameter    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "methodParameter . setContainingClass ( implementationClass )  ;", "return    . forMethodParameter ( methodParameter )  ;", "}", "METHOD_END"], "methodName": ["forMethodReturnType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   new   ResolvableType ( clazz )     {", "@ Override", "public   ResolvableType [  ]    getGenerics (  )     {", "return   ResolvableType . EMPTY _ TYPES _ ARRAY ;", "}", "@ Override", "public   boolean   isAssignableFrom ( Class <  ?  >    other )     {", "return    ( clazz    =  =    null )     |  |     ( ClassUtils . isAssignable ( clazz ,    other )  )  ;", "}", "@ Override", "public   boolean   isAssignableFrom ( ResolvableType   other )     {", "Class <  ?  >    otherClass    =    other . getRawClass (  )  ;", "return    ( otherClass    !  =    null )     &  &     (  ( clazz    =  =    null )     |  |     ( ClassUtils . isAssignable ( clazz ,    otherClass )  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["forRawClass"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forType ( type ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forType ( type ,    null ,    variableResolver )  ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "ResolvableType . VariableResolver   variableResolver    =    null ;", "if    ( owner    !  =    null )     {", "variableResolver    =    owner . asVariableResolver (  )  ;", "}", "return   ResolvableType . forType ( type ,    variableResolver )  ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type    =  =    null )     &  &     ( typeProvider    !  =    null )  )     {", "type    =    SerializableTypeWrapper . forTypeProvider ( typeProvider )  ;", "}", "if    ( type    =  =    null )     {", "return    . NONE ;", "}", "if    ( type   instanceof   Class )     {", "return   new    ( type ,    typeProvider ,    variableResolver ,     (  (  )     ( null )  )  )  ;", "}", ". cache . purgeUnreferencedEntries (  )  ;", "resultType    =    new    ( type ,    typeProvider ,    variableResolver )  ;", "cachedType    =     . cache . get ( resultType )  ;", "if    ( cachedType    =  =    null )     {", "cachedType    =    new    ( type ,    typeProvider ,    variableResolver ,    resultType . hash )  ;", ". cache . put ( cachedType ,    cachedType )  ;", "}", "resultType . resolved    =    cachedType . resolved ;", "return   resultType ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   ResolvableType . forType ( typeReference . getType (  )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "ResolvableType [  ]    result    =    new   ResolvableType [ types . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( types . length )  ;    i +  +  )     {", "result [ i ]     =    ResolvableType . forType ( types [ i ]  ,    owner )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["forTypes"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =     ( ResolvableType . NONE )  )     {", "return   ResolvableType . NONE ;", "}", "if    (  ( this . componentType )     !  =    null )     {", "return   this . componentType ;", "}", "if    (  ( this . type )    instanceof   Class )     {", "Class <  ?  >    componentType    =     (  ( Class <  ?  >  )     ( this . type )  )  . getComponentType (  )  ;", "return   ResolvableType . forType ( componentType ,    this . variableResolver )  ;", "}", "if    (  ( this . type )    instanceof   GenericArrayType )     {", "return   ResolvableType . forType (  (  ( GenericArrayType )     ( this . type )  )  . getGenericComponentType (  )  ,    this . variableResolver )  ;", "}", "return   resolveType (  )  . getComponentType (  )  ;", "}", "METHOD_END"], "methodName": ["getComponentType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "ResolvableType [  ]    generics    =    getGenerics (  )  ;", "if    (  ( indexes    =  =    null )     |  |     (  ( indexes . length )     =  =     0  )  )     {", "return    ( generics . length )     =  =     0     ?    ResolvableType . NONE    :    generics [  0  ]  ;", "}", "ResolvableType   generic    =    this ;", "for    ( int   index    :    indexes )     {", "generics    =    generic . getGenerics (  )  ;", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( generics . length )  )  )     {", "return   ResolvableType . NONE ;", "}", "generic    =    generics [ index ]  ;", "}", "return   generic ;", "}", "METHOD_END"], "methodName": ["getGeneric"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =     ( ResolvableType . NONE )  )     {", "return   ResolvableType . EMPTY _ TYPES _ ARRAY ;", "}", "ResolvableType [  ]    generics    =    this . generics ;", "if    ( generics    =  =    null )     {", "if    (  ( this . type )    instanceof   Class )     {", "Class <  ?  >    typeClass    =     (  ( Class <  ?  >  )     ( this . type )  )  ;", "generics    =    ResolvableType . forTypes ( SerializableTypeWrapper . forTypeParameters ( typeClass )  ,    this . variableResolver )  ;", "} else", "if    (  ( this . type )    instanceof   ParameterizedType )     {", "Type [  ]    actualTypeArguments    =     (  ( ParameterizedType )     ( this . type )  )  . getActualTypeArguments (  )  ;", "generics    =    new   ResolvableType [ actualTypeArguments . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( actualTypeArguments . length )  ;    i +  +  )     {", "generics [ i ]     =    ResolvableType . forType ( actualTypeArguments [ i ]  ,    this . variableResolver )  ;", "}", "} else    {", "generics    =    resolveType (  )  . getGenerics (  )  ;", "}", "this . generics    =    generics ;", "}", "return   generics ;", "}", "METHOD_END"], "methodName": ["getGenerics"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    resolved    =    resolve (  )  ;", "if    (  ( resolved    =  =    null )     |  |     ( ObjectUtils . isEmpty ( resolved . getGenericInterfaces (  )  )  )  )     {", "return    . EMPTY _ TYPES _ ARRAY ;", "}", "[  ]    interfaces    =    this . interfaces ;", "if    ( interfaces    =  =    null )     {", "interfaces    =     . forTypes ( SerializableTypeWrapper . forGenericInterfaces ( resolved )  ,    asVariableResolver (  )  )  ;", "this . interfaces    =    interfaces ;", "}", "return   interfaces ;", "}", "METHOD_END"], "methodName": ["getInterfaces"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   getNested ( nestingLevel ,    null )  ;", "}", "METHOD_END"], "methodName": ["getNested"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   result    =    this ;", "for    ( int   i    =     2  ;    i    <  =    nestingLevel ;    i +  +  )     {", "if    ( result . isArray (  )  )     {", "result    =    result . getComponentType (  )  ;", "} else    {", "while    (  ( result    !  =     ( ResolvableType . NONE )  )     &  &     (  !  ( result . hasGenerics (  )  )  )  )     {", "result    =    result . getSuperType (  )  ;", "}", "Integer   index    =     ( typeIndexesPerLevel    !  =    null )     ?    typeIndexesPerLevel . get ( i )     :    null ;", "index    =     ( index    =  =    null )     ?     ( result . getGenerics (  )  . length )     -     1     :    index ;", "result    =    result . getGeneric ( index )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getNested"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . type )     =  =     ( this . resolved )  )     {", "return   this . resolved ;", "}", "Type   rawType    =    this . type ;", "if    ( rawType   instanceof   ParameterizedType )     {", "rawType    =     (  ( ParameterizedType )     ( rawType )  )  . getRawType (  )  ;", "}", "return   rawType   instanceof   Class    ?     (  ( Class <  ?  >  )     ( rawType )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getRawClass"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Object   source    =     (  ( this . typeProvider )     !  =    null )     ?    this . typeProvider . getSource (  )     :    null ;", "return   source    !  =    null    ?    source    :    this . type ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    resolved    =    resolve (  )  ;", "if    (  ( resolved    =  =    null )     |  |     (  ( resolved . getGenericSuperclass (  )  )     =  =    null )  )     {", "return    . NONE ;", "}", "superType    =    this . superType ;", "if    ( superType    =  =    null )     {", "superType    =     . forType ( SerializableTypeWrapper . forGenericSuperclass ( resolved )  ,    asVariableResolver (  )  )  ;", "this . superType    =    superType ;", "}", "return   superType ;", "}", "METHOD_END"], "methodName": ["getSuperType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   SerializableTypeWrapper . unwrap ( this . type )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return    ( getGenerics (  )  . length )     >     0  ;", "}", "METHOD_END"], "methodName": ["hasGenerics"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =     ( ResolvableType . NONE )  )     {", "return   false ;", "}", "ResolvableType [  ]    generics    =    getGenerics (  )  ;", "for    ( ResolvableType   generic    :    generics )     {", "if    (  ( generic . isUnresolvableTypeVariable (  )  )     |  |     ( generic . isWildcardWithoutBounds (  )  )  )     {", "return   true ;", "}", "}", "Class <  ?  >    resolved    =    resolve (  )  ;", "if    ( resolved    !  =    null )     {", "for    ( Type   genericInterface    :    resolved . getGenericInterfaces (  )  )     {", "if    ( genericInterface   instanceof   Class )     {", "if    ( ResolvableType . forClass (  (  ( Class <  ?  >  )     ( genericInterface )  )  )  . hasGenerics (  )  )     {", "return   true ;", "}", "}", "}", "return   getSuperType (  )  . hasUnresolvableGenerics (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasUnresolvableGenerics"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =     ( ResolvableType . NONE )  )     {", "return   false ;", "}", "return    (  (  (  ( this . type )    instanceof   Class )     &  &     (  (  ( Class <  ?  >  )     ( this . type )  )  . isArray (  )  )  )     |  |     (  ( this . type )    instanceof   GenericArrayType )  )     |  |     ( resolveType (  )  . isArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   isAssignableFrom ( ResolvableType . forClass ( other )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   isAssignableFrom ( other ,    null )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( other ,     \" ResolvableType   must   not   be   null \"  )  ;", "if    (  (  ( this )     =  =     ( ResolvableType . NONE )  )     |  |     ( other    =  =     ( ResolvableType . NONE )  )  )     {", "return   false ;", "}", "if    ( isArray (  )  )     {", "return    ( other . isArray (  )  )     &  &     ( getComponentType (  )  . isAssignableFrom ( other . getComponentType (  )  )  )  ;", "}", "if    (  ( matchedBefore    !  =    null )     &  &     (  ( matchedBefore . get ( this . type )  )     =  =     ( other . type )  )  )     {", "return   true ;", "}", "ResolvableType . WildcardBounds   ourBounds    =    ResolvableType . WildcardBounds . get ( this )  ;", "ResolvableType . WildcardBounds   typeBounds    =    ResolvableType . WildcardBounds . get ( other )  ;", "if    ( typeBounds    !  =    null )     {", "return    (  ( ourBounds    !  =    null )     &  &     ( ourBounds . isSameKind ( typeBounds )  )  )     &  &     ( ourBounds . isAssignableFrom ( typeBounds . getBounds (  )  )  )  ;", "}", "if    ( ourBounds    !  =    null )     {", "return   ourBounds . isAssignableFrom ( other )  ;", "}", "boolean   exactMatch    =    matchedBefore    !  =    null ;", "boolean   checkGenerics    =    true ;", "Class <  ?  >    ourResolved    =    null ;", "if    (  ( this . type )    instanceof   TypeVariable )     {", "TypeVariable <  ?  >    variable    =     (  ( TypeVariable <  ?  >  )     ( this . type )  )  ;", "if    (  ( this . variableResolver )     !  =    null )     {", "ResolvableType   resolved    =    this . variableResolver . resolveVariable ( variable )  ;", "if    ( resolved    !  =    null )     {", "ourResolved    =    resolved . resolve (  )  ;", "}", "}", "if    ( ourResolved    =  =    null )     {", "if    (  ( other . variableResolver )     !  =    null )     {", "ResolvableType   resolved    =    other . variableResolver . resolveVariable ( variable )  ;", "if    ( resolved    !  =    null )     {", "ourResolved    =    resolved . resolve (  )  ;", "checkGenerics    =    false ;", "}", "}", "}", "if    ( ourResolved    =  =    null )     {", "exactMatch    =    false ;", "}", "}", "if    ( ourResolved    =  =    null )     {", "ourResolved    =    resolve ( Object . class )  ;", "}", "Class <  ?  >    otherResolved    =    other . resolve ( Object . class )  ;", "if    ( exactMatch    ?     !  ( ourResolved . equals ( otherResolved )  )     :     !  ( ClassUtils . isAssignable ( ourResolved ,    otherResolved )  )  )     {", "return   false ;", "}", "if    ( checkGenerics )     {", "ResolvableType [  ]    ourGenerics    =    getGenerics (  )  ;", "ResolvableType [  ]    typeGenerics    =    other . as ( ourResolved )  . getGenerics (  )  ;", "if    (  ( ourGenerics . length )     !  =     ( typeGenerics . length )  )     {", "return   false ;", "}", "if    ( matchedBefore    =  =    null )     {", "matchedBefore    =    new   IdentityHashMap <  >  (  1  )  ;", "}", "matchedBefore . put ( this . type ,    other . type )  ;", "for    ( int   i    =     0  ;    i    <     ( ourGenerics . length )  ;    i +  +  )     {", "if    (  !  ( ourGenerics [ i ]  . isAssignableFrom ( typeGenerics [ i ]  ,    matchedBefore )  )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =     ( ResolvableType . NONE )  )     {", "return   false ;", "}", "ResolvableType [  ]    generics    =    getGenerics (  )  ;", "for    ( ResolvableType   generic    :    generics )     {", "if    (  (  !  ( generic . isUnresolvableTypeVariable (  )  )  )     &  &     (  !  ( generic . isWildcardWithoutBounds (  )  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isEntirelyUnresolvable"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return    ( obj    !  =    null )     &  &     ( isAssignableFrom ( obj . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isInstance"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . type )    instanceof   TypeVariable )     {", "if    (  ( this . variableResolver )     =  =    null )     {", "return   true ;", "}", "TypeVariable <  ?  >    variable    =     (  ( TypeVariable <  ?  >  )     ( this . type )  )  ;", "resolved    =    this . variableResolver . resolveVariable ( variable )  ;", "if    (  ( resolved    =  =    null )     |  |     ( resolved . isUnresolvableTypeVariable (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isUnresolvableTypeVariable"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . type )    instanceof   WildcardType )     {", "WildcardType   wt    =     (  ( WildcardType )     ( this . type )  )  ;", "if    (  ( wt . getLowerBounds (  )  . length )     =  =     0  )     {", "Type [  ]    upperBounds    =    wt . getUpperBounds (  )  ;", "if    (  (  ( upperBounds . length )     =  =     0  )     |  |     (  (  ( upperBounds . length )     =  =     1  )     &  &     (  ( Object . class )     =  =     ( upperBounds [  0  ]  )  )  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isWildcardWithoutBounds"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return    ( this . type )     =  =     ( ResolvableType . EmptyType . INSTANCE )     ?    ResolvableType . NONE    :    this ;", "}", "METHOD_END"], "methodName": ["readResolve"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   this . resolved ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return    ( this . resolved )     !  =    null    ?    this . resolved    :    fallback ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ObjectUtils . isEmpty ( bounds )  )     |  |     (  ( Object . class )     =  =     ( bounds [  0  ]  )  )  )     {", "return   null ;", "}", "return   bounds [  0  ]  ;", "}", "METHOD_END"], "methodName": ["resolveBounds"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . type )     =  =     ( ResolvableType . EmptyType . INSTANCE )  )     {", "return   null ;", "}", "if    (  ( this . type )    instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( this . type )  )  ;", "}", "if    (  ( this . type )    instanceof   GenericArrayType )     {", "Class <  ?  >    resolvedComponent    =    getComponentType (  )  . resolve (  )  ;", "return   resolvedComponent    !  =    null    ?    Array . newInstance ( resolvedComponent ,     0  )  . getClass (  )     :    null ;", "}", "return   resolveType (  )  . resolve (  )  ;", "}", "METHOD_END"], "methodName": ["resolveClass"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "return   getGeneric ( indexes )  . resolve (  )  ;", "}", "METHOD_END"], "methodName": ["resolveGeneric"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "ResolvableType [  ]    generics    =    getGenerics (  )  ;", "Class <  ?  >  [  ]    resolvedGenerics    =    new   Class <  ?  >  [ generics . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( generics . length )  ;    i +  +  )     {", "resolvedGenerics [ i ]     =    generics [ i ]  . resolve (  )  ;", "}", "return   resolvedGenerics ;", "}", "METHOD_END"], "methodName": ["resolveGenerics"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "ResolvableType [  ]    generics    =    getGenerics (  )  ;", "Class <  ?  >  [  ]    resolvedGenerics    =    new   Class <  ?  >  [ generics . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( generics . length )  ;    i +  +  )     {", "resolvedGenerics [ i ]     =    generics [ i ]  . resolve ( fallback )  ;", "}", "return   resolvedGenerics ;", "}", "METHOD_END"], "methodName": ["resolveGenerics"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( methodParameter ,     \" MethodParameter   must   not   be   null \"  )  ;", "owner    =     . forType ( methodParameter . getContainingClass (  )  )  . as ( methodParameter . getDeclaringClass (  )  )  ;", "methodParameter . setParameterType (  . forType ( null ,    new   SerializableTypeWrapper . MethodParameterTypeProvider ( methodParameter )  ,    owner . asVariableResolver (  )  )  . resolve (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodParameter"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . type )    instanceof   ParameterizedType )     {", "return    . forType (  (  ( ParameterizedType )     ( this . type )  )  . getRawType (  )  ,    this . variableResolver )  ;", "}", "if    (  ( this . type )    instanceof   WildcardType )     {", "Type   resolved    =    resolveBounds (  (  ( WildcardType )     ( this . type )  )  . getUpperBounds (  )  )  ;", "if    ( resolved    =  =    null )     {", "resolved    =    resolveBounds (  (  ( WildcardType )     ( this . type )  )  . getLowerBounds (  )  )  ;", "}", "return    . forType ( resolved ,    this . variableResolver )  ;", "}", "if    (  ( this . type )    instanceof   TypeVariable )     {", "TypeVariable <  ?  >    variable    =     (  ( TypeVariable <  ?  >  )     ( this . type )  )  ;", "if    (  ( this . variableResolver )     !  =    null )     {", "resolved    =    this . variableResolver . resolveVariable ( variable )  ;", "if    ( resolved    !  =    null )     {", "return   resolved ;", "}", "}", "return    . forType ( resolveBounds ( variable . getBounds (  )  )  ,    this . variableResolver )  ;", "}", "return    . NONE ;", "}", "METHOD_END"], "methodName": ["resolveType"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . type )    instanceof   TypeVariable )     {", "return   resolveType (  )  . resolveVariable ( variable )  ;", "}", "if    (  ( this . type )    instanceof   ParameterizedType )     {", "ParameterizedType   parameterizedType    =     (  ( ParameterizedType )     ( this . type )  )  ;", "Class <  ?  >    resolved    =    resolve (  )  ;", "if    ( resolved    =  =    null )     {", "return   null ;", "}", "TypeVariable <  ?  >  [  ]    variables    =    resolved . getTypeParameters (  )  ;", "for    ( int   i    =     0  ;    i    <     ( variables . length )  ;    i +  +  )     {", "if    ( ObjectUtils . nullSafeEquals ( variables [ i ]  . getName (  )  ,    variable . getName (  )  )  )     {", "Type   actualType    =    parameterizedType . getActualTypeArguments (  )  [ i ]  ;", "return    . forType ( actualType ,    this . variableResolver )  ;", "}", "}", "Type   ownerType    =    parameterizedType . getOwnerType (  )  ;", "if    ( ownerType    !  =    null )     {", "return    . forType ( ownerType ,    this . variableResolver )  . resolveVariable ( variable )  ;", "}", "}", "if    (  ( this . variableResolver )     !  =    null )     {", "return   this . variableResolver . resolveVariable ( variable )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveVariable"], "fileName": "org.springframework.core.ResolvableType"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" arrayClassType \"  )  )  ;", "assertThat ( type . getType (  )  ,    instanceOf ( Class . class )  )  ;", "assertThat (  (  ( Class )     ( type . getType (  )  )  )  . isArray (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["arrayClassType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  . asCollection (  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Collection . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  )  ,    equalTo (  (  ( Class )     ( CharSequence . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["asCollection"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  . as ( Collection . class )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" Collection < E >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["asFromInheritedInterface"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  . as ( List . class )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" List < E >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["asFromInheritedSuperType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  . as ( List . class )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" List < E >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["asFromInterface"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  . as ( ArrayList . class )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" ArrayList < CharSequence >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["asFromSuperType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsMap . class )  . asMap (  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Map . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  0  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  1  )  ,    equalTo (  (  ( Class )     ( Integer . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["asMap"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  . as ( Map . class )  ;", "assertThat ( type ,    sameInstance ( ResolvableType . NONE )  )  ;", "}", "METHOD_END"], "methodName": ["asNotFound"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  ;", "assertThat ( type . as ( ResolvableTypeTests . ExtendsList . class )  ,    equalTo ( type )  )  ;", "}", "METHOD_END"], "methodName": ["asSelf"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "return    (    values )     -  >     {", "for    ( int   i    =     0  ;    i    <     ( froms . length )  ;    i +  +  )     {", "assertThat (  (  (  ( stringDesc ( type )  )     +     \"    isAssignableFrom    \"  )     +     ( stringDesc ( froms [ i ]  )  )  )  ,    type . isAssignableFrom ( froms [ i ]  )  ,    equalTo ( values [ i ]  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["assertAssignable"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField ( field )  )  ;", "assertThat (  (  (  \" field    \"     +    field )     +     \"    toString \"  )  ,    type . toString (  )  ,    equalTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["assertFieldToStringValue"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField ( field )  ,    ResolvableTypeTests . TypedFields . class )  ;", "assertThat (  (  (  \" field    \"     +    field )     +     \"    toString \"  )  ,    type . toString (  )  ,    equalTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["assertTypedFieldToStringValue"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( void . class )  ;", "assertThat ( type . resolve (  )  ,    equalTo ( void . class )  )  ;", "}", "METHOD_END"], "methodName": ["canResolveVoid"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" classType \"  )  )  ;", "assertThat ( type . getType (  )  . getClass (  )  ,    equalTo (  (  ( Class )     ( Class . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["classType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( MultiValueMap . class ,    Integer . class ,    String . class )  ;", "assertThat ( type . asMap (  )  . toString (  )  ,    equalTo (  \" Map < Integer ,    List < String >  >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["classWithGenericsAs"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" listOfListOfUnknown \"  )  )  . as ( Collection . class )  ;", "assertThat ( type . getGeneric (  0  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . getGeneric (  0  )  . as ( Collection . class )  . getGeneric (  0  )  . as ( Collection . class )  . resolve (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesResolveFromOuterOwner"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   elementType    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringList \"  )  )  ;", "ResolvableType   type    =    ResolvableType . forArrayComponent ( elementType )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" List < String >  [  ]  \"  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo ( List [  ]  . class )  )  ;", "}", "METHOD_END"], "methodName": ["forArrayComponent"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  ;", "assertThat ( type . getType (  )  ,    equalTo (  (  ( Type )     ( ResolvableTypeTests . ExtendsList . class )  )  )  )  ;", "assertThat ( type . getRawClass (  )  ,    equalTo ( ResolvableTypeTests . ExtendsList . class )  )  ;", "assertTrue ( type . isAssignableFrom ( ResolvableTypeTests . ExtendsList . class )  )  ;", "assertFalse ( type . isAssignableFrom ( ArrayList . class )  )  ;", "}", "METHOD_END"], "methodName": ["forClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   elementType    =    ResolvableType . forClassWithGenerics ( Map . class ,    Integer . class ,    String . class )  ;", "ResolvableType   listType    =    ResolvableType . forClassWithGenerics ( List . class ,    elementType )  ;", "assertThat ( listType . toString (  )  ,    equalTo (  \" List < Map < Integer ,    String >  >  \"  )  )  ;", "assertThat ( listType . getType (  )  . getTypeName (  )  ,    equalTo (  \" List < Map < Integer ,    String >  >  \"  )  )  ;", "assertThat ( listType . getType (  )  . toString (  )  ,    equalTo (  \" List < Map < Integer ,    String >  >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["forClassWithGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Mismatched   number   of   generics   specified \"  )  ;", ". forClassWithGenerics ( Map . class ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["forClassWithMismatchedGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( null )  ;", "assertThat ( type . getType (  )  ,    equalTo (  (  ( Type )     ( Object . class )  )  )  )  ;", "assertThat ( type . getRawClass (  )  ,    equalTo ( Object . class )  )  ;", "assertTrue ( type . isAssignableFrom ( Object . class )  )  ;", "assertTrue ( type . isAssignableFrom ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["forClassWithNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Constructor < ResolvableTypeTests . Constructors >    constructor    =    ResolvableTypeTests . Constructors . class . getConstructor ( List . class )  ;", "ResolvableType   type    =    ResolvableType . forConstructorParameter ( constructor ,     0  )  ;", "assertThat ( type . getType (  )  ,    equalTo ( constructor . getGenericParameterTypes (  )  [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["forConstructorParameter"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Constructor   must   not   be   null \"  )  ;", ". forConstructorParameter ( null ,     0  )  ;", "}", "METHOD_END"], "methodName": ["forConstructorParameterMustNotBeNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    ResolvableTypeTests . Fields . class . getField (  \" charSequenceList \"  )  ;", "ResolvableType   type    =    ResolvableType . forField ( field )  ;", "assertThat ( type . getType (  )  ,    equalTo ( field . getGenericType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Field   must   not   be   null \"  )  ;", ". forField ( null )  ;", "}", "METHOD_END"], "methodName": ["forFieldMustNotBeNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Instance   must   not   be   null \"  )  ;", ". forInstance ( null )  ;", "}", "METHOD_END"], "methodName": ["forInstanceMustNotBeNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forInstance ( new   Object (  )  )  ;", "assertThat ( type . getType (  )  ,    equalTo ( Object . class )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo ( Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["forInstanceNoProvider"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forInstance ( new   ResolvableTypeTests . MyGenericInterfaceType <  >  ( String . class )  )  ;", "assertThat ( type . getRawClass (  )  ,    equalTo ( ResolvableTypeTests . MyGenericInterfaceType . class )  )  ;", "assertThat ( type . getGeneric (  )  . resolve (  )  ,    equalTo ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["forInstanceProvider"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forInstance ( new   ResolvableTypeTests . MyGenericInterfaceType < String >  ( null )  )  ;", "assertThat ( type . getType (  )  ,    equalTo ( ResolvableTypeTests . MyGenericInterfaceType . class )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo ( ResolvableTypeTests . MyGenericInterfaceType . class )  )  ;", "}", "METHOD_END"], "methodName": ["forInstanceProviderNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" charSequenceParameter \"  ,    List . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( method ,     0  )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( methodParameter )  ;", "assertThat ( type . getType (  )  ,    equalTo ( method . getGenericParameterTypes (  )  [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameter"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" charSequenceParameter \"  ,    List . class )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( method ,     0  )  ;", "assertThat ( type . getType (  )  ,    equalTo ( method . getGenericParameterTypes (  )  [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameterByIndex"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Method   must   not   be   null \"  )  ;", ". forMethodParameter ( null ,     0  )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameterByIndexMustNotBeNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" MethodParameter   must   not   be   null \"  )  ;", ". forMethodParameter ( null )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameterMustNotBeNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" nested \"  ,    Map . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( method ,     0  )  ;", "methodParameter . increaseNestingLevel (  )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( methodParameter )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Map . class )  )  )  )  ;", "assertThat ( type . getGeneric (  0  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Byte . class )  )  )  )  ;", "assertThat ( type . getGeneric (  1  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Long . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameterWithNesting"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" nested \"  ,    Map . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( method ,     0  )  ;", "methodParameter . increaseNestingLevel (  )  ;", "methodParameter . setTypeIndexForCurrentLevel (  0  )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( methodParameter )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Map . class )  )  )  )  ;", "assertThat ( type . getGeneric (  0  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( type . getGeneric (  1  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Integer . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameterWithNestingAndLevels"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" list 1  \"  )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( method ,     (  -  1  )  )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( methodParameter )  ;", "assertThat (  (  ( MethodParameter )     ( type . getSource (  )  )  )  . getMethod (  )  ,    equalTo ( method )  )  ;", "method    =    ResolvableTypeTests . Methods . class . getMethod (  \" list 2  \"  )  ;", "methodParameter    =    MethodParameter . forExecutable ( method ,     (  -  1  )  )  ;", "type    =    ResolvableType . forMethodParameter ( methodParameter )  ;", "assertThat (  (  ( MethodParameter )     ( type . getSource (  )  )  )  . getMethod (  )  ,    equalTo ( method )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameterWithSameSignatureAndGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" charSequenceReturn \"  )  ;", "ResolvableType   type    =    ResolvableType . forMethodReturnType ( method )  ;", "assertThat ( type . getType (  )  ,    equalTo ( method . getGenericReturnType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodReturn"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Method   must   not   be   null \"  )  ;", ". forMethodReturnType ( null )  ;", "}", "METHOD_END"], "methodName": ["forMethodReturnMustNotBeNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    ResolvableTypeTests . Fields . class . getDeclaredField (  \" privateField \"  )  ;", "ResolvableType   type    =    ResolvableType . forField ( field )  ;", "assertThat ( type . getType (  )  ,    equalTo ( field . getGenericType (  )  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . getSource (  )  ,    sameInstance ( field )  )  ;", "Field   field 2     =    ResolvableTypeTests . Fields . class . getDeclaredField (  \" otherPrivateField \"  )  ;", "ResolvableType   type 2     =    ResolvableType . forField ( field 2  )  ;", "assertThat ( type 2  . getType (  )  ,    equalTo ( field 2  . getGenericType (  )  )  )  ;", "assertThat ( type 2  . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type 2  . getSource (  )  ,    sameInstance ( field 2  )  )  ;", "assertEquals ( type ,    type 2  )  ;", "assertEquals ( type . hashCode (  )  ,    type 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["forPrivateField"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forRawClass ( ResolvableTypeTests . ExtendsList . class )  ;", "assertThat ( type . getType (  )  ,    equalTo (  (  ( Type )     ( ResolvableTypeTests . ExtendsList . class )  )  )  )  ;", "assertThat ( type . getRawClass (  )  ,    equalTo ( ResolvableTypeTests . ExtendsList . class )  )  ;", "assertTrue ( type . isAssignableFrom ( ResolvableTypeTests . ExtendsList . class )  )  ;", "assertFalse ( type . isAssignableFrom ( ArrayList . class )  )  ;", "}", "METHOD_END"], "methodName": ["forRawClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forRawClass ( null )  ;", "assertThat ( type . getType (  )  ,    equalTo (  (  ( Type )     ( Object . class )  )  )  )  ;", "assertThat ( type . getRawClass (  )  ,    equalTo ( Object . class )  )  ;", "assertTrue ( type . isAssignableFrom ( Object . class )  )  ;", "assertTrue ( type . isAssignableFrom ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["forRawClassWithNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" genericArrayType \"  )  )  ;", "assertThat ( type . getType (  )  ,    instanceOf ( GenericArrayType . class )  )  ;", "}", "METHOD_END"], "methodName": ["genericArrayType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringListList \"  )  )  . asCollection (  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" Collection < List < String >  >  \"  )  )  ;", "assertThat ( type . getGeneric (  )  . asCollection (  )  . toString (  )  ,    equalTo (  \" Collection < String >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["genericOfGenericWithAs"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    ResolvableTypeTests . Fields . class . getField (  \" arrayClassType \"  )  ;", "ResolvableType   type    =    ResolvableType . forField ( field )  ;", "assertThat ( type . isArray (  )  ,    equalTo ( true )  )  ;", "assertThat ( type . getComponentType (  )  . getType (  )  ,    equalTo (  (  ( Type )     (  (  ( Class )     ( field . getGenericType (  )  )  )  . getComponentType (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponentTypeForClassArray"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" genericArrayType \"  )  )  ;", "assertThat ( type . isArray (  )  ,    equalTo ( true )  )  ;", "assertThat ( type . getComponentType (  )  . getType (  )  ,    equalTo (  (  ( GenericArrayType )     ( type . getType (  )  )  )  . getGenericComponentType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponentTypeForGenericArrayType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( String . class )  ;", "assertThat ( type . isArray (  )  ,    equalTo ( false )  )  ;", "assertThat ( type . getComponentType (  )  ,    equalTo ( ResolvableType . NONE )  )  ;", "}", "METHOD_END"], "methodName": ["getComponentTypeForNonArray"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ListOfGenericArray . class )  . asCollection (  )  . getGeneric (  )  ;", "assertThat ( type . isArray (  )  ,    equalTo ( true )  )  ;", "assertThat ( type . getType (  )  ,    instanceOf ( TypeVariable . class )  )  ;", "assertThat ( type . getComponentType (  )  . getType (  )  . toString (  )  ,    equalTo (  \" List < String >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponentTypeForVariableThatResolvesToGenericArray"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringList \"  )  )  ;", "assertThat ( type . getGeneric (  )  . getType (  )  ,    equalTo (  (  ( Type )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getGeneric"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringIntegerMultiValueMap \"  )  )  ;", "assertThat ( type . getGeneric (  0  )  . getType (  )  ,    equalTo (  (  ( Type )     ( String . class )  )  )  )  ;", "assertThat ( type . getGeneric (  1  )  . getType (  )  ,    equalTo (  (  ( Type )     ( Integer . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getGenericByIndex"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringListList \"  )  )  ;", "assertThat ( type . getGeneric (  )  . getType (  )  . toString (  )  ,    equalTo (  \" List < String >  \"  )  )  ;", "assertThat ( type . getGeneric (  )  . getGeneric (  )  . getType (  )  ,    equalTo (  (  ( Type )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getGenericOfGeneric"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringListList \"  )  )  ;", "assertThat ( type . getGeneric (  0  ,     0  )  . getType (  )  ,    equalTo (  (  ( Type )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getGenericOfGenericByIndexes"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( List . class ,    ResolvableTypeTests . ExtendsList . class )  ;", "assertThat ( type . getGeneric (  0  )  ,    not ( equalTo ( ResolvableType . NONE )  )  )  ;", "assertThat ( type . getGeneric (  1  )  ,    equalTo ( ResolvableType . NONE )  )  ;", "assertThat ( type . getGeneric (  0  ,     1  )  ,    equalTo ( ResolvableType . NONE )  )  ;", "}", "METHOD_END"], "methodName": ["getGenericOutOfBounds"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( List . class )  ;", "ResolvableType [  ]    generics    =    type . getGenerics (  )  ;", "assertThat ( generics . length ,    equalTo (  1  )  )  ;", "assertThat ( generics [  0  ]  . getType (  )  . toString (  )  ,    equalTo (  \" E \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getGenericsFromClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( List . class ,    ResolvableTypeTests . ExtendsList . class )  ;", "ResolvableType [  ]    generics    =    type . getGenerics (  )  ;", "assertThat ( generics . length ,    equalTo (  1  )  )  ;", "assertThat ( generics [  0  ]  . resolve (  )  ,    equalTo (  (  ( Class )     ( CharSequence . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getGenericsFromParameterizedType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  ;", "assertThat ( type . getInterfaces (  )  . length ,    equalTo (  0  )  )  ;", "SortedSet < String >    interfaces    =    new   TreeSet <  >  (  )  ;", "for    ( ResolvableType   interfaceType    :    type . getSuperType (  )  . getInterfaces (  )  )     {", "interfaces . add ( interfaceType . toString (  )  )  ;", "}", "assertThat ( interfaces . toString (  )  ,    equalTo (  (  \"  [  \"     +     (  (  (  (  \" Serializable ,     \"     +     \" Cloneable ,     \"  )     +     \" List < CharSequence >  ,     \"  )     +     \" RandomAccess \"  )     +     \"  ]  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getInterfaces"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( List . class ,    ResolvableTypeTests . ExtendsList . class )  ;", "Class <  ?  >  [  ]    generics    =    type . resolveGenerics (  )  ;", "assertThat ( generics . length ,    equalTo (  1  )  )  ;", "assertThat ( generics [  0  ]  ,    equalTo (  (  ( Class )     ( CharSequence . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getResolvedGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    classType    =    ResolvableTypeTests . MySimpleInterfaceType . class ;", "Field   basicField    =    ResolvableTypeTests . Fields . class . getField (  \" classType \"  )  ;", "Field   field    =    ResolvableTypeTests . Fields . class . getField (  \" charSequenceList \"  )  ;", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" charSequenceParameter \"  ,    List . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( method ,     0  )  ;", "assertThat ( ResolvableType . forField ( basicField )  . getSource (  )  ,    equalTo (  (  ( Object )     ( basicField )  )  )  )  ;", "assertThat ( ResolvableType . forField ( field )  . getSource (  )  ,    equalTo (  (  ( Object )     ( field )  )  )  )  ;", "assertThat ( ResolvableType . forMethodParameter ( methodParameter )  . getSource (  )  ,    equalTo (  (  ( Object )     ( methodParameter )  )  )  )  ;", "assertThat ( ResolvableType . forMethodParameter ( method ,     0  )  . getSource (  )  ,    equalTo (  (  ( Object )     ( methodParameter )  )  )  )  ;", "assertThat ( ResolvableType . forClass ( classType )  . getSource (  )  ,    equalTo (  (  ( Object )     ( classType )  )  )  )  ;", "assertThat ( ResolvableType . forClass ( classType )  . getSuperType (  )  . getSource (  )  ,    equalTo (  (  ( Object )     ( classType . getGenericSuperclass (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  . getSuperType (  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( ArrayList . class )  )  )  )  ;", "type    =    type . getSuperType (  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( AbstractList . class )  )  )  )  ;", "type    =    type . getSuperType (  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( AbstractCollection . class )  )  )  )  ;", "type    =    type . getSuperType (  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Object . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSuperType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  ;", "assertThat ( type . hasGenerics (  )  ,    equalTo ( false )  )  ;", "assertThat ( type . asCollection (  )  . hasGenerics (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["hasGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringList \"  )  )  ;", "assertThat ( type . hasUnresolvableGenerics (  )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["hasUnresolvableGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( List . class )  ;", "assertThat ( type . hasUnresolvableGenerics (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["hasUnresolvableGenericsBasedOnOwnGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsMySimpleInterfaceTypeWithImplementsRaw . class )  ;", "for    ( ResolvableType   generic    :    type . getGenerics (  )  )     {", "assertThat ( generic . resolve (  )  ,    not ( nullValue (  )  )  )  ;", "}", "assertThat ( type . hasUnresolvableGenerics (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["hasUnresolvableGenericsWhenExtends"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . MySimpleInterfaceTypeWithImplementsRaw . class )  ;", "for    ( ResolvableType   generic    :    type . getGenerics (  )  )     {", "assertThat ( generic . resolve (  )  ,    not ( nullValue (  )  )  )  ;", "}", "assertThat ( type . hasUnresolvableGenerics (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["hasUnresolvableGenericsWhenImplementesRawInterface"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( List . class )  . getGeneric (  )  ;", "assertThat ( type . hasUnresolvableGenerics (  )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["hasUnresolvableGenericsWhenSelfNotResolvable"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   forClass    =    ResolvableType . forClass ( List . class )  ;", "ResolvableType   forFieldDirect    =    ResolvableType . forField (  . Fields . class . getDeclaredField (  \" stringList \"  )  )  ;", "ResolvableType   forFieldViaType    =    ResolvableType . forType (  . Fields . class . getDeclaredField (  \" stringList \"  )  . getGenericType (  )  ,     (  ( ResolvableType . VariableResolver )     ( null )  )  )  ;", "ResolvableType   forFieldWithImplementation    =    ResolvableType . forField (  . Fields . class . getDeclaredField (  \" stringList \"  )  ,     . TypedFields . class )  ;", "assertThat ( forClass ,    equalTo ( forClass )  )  ;", "assertThat ( forClass . hashCode (  )  ,    equalTo ( forClass . hashCode (  )  )  )  ;", "assertThat ( forClass ,    not ( equalTo ( forFieldDirect )  )  )  ;", "assertThat ( forClass ,    not ( equalTo ( forFieldWithImplementation )  )  )  ;", "assertThat ( forFieldDirect ,    equalTo ( forFieldDirect )  )  ;", "assertThat ( forFieldDirect ,    not ( equalTo ( forFieldViaType )  )  )  ;", "assertThat ( forFieldDirect ,    not ( equalTo ( forFieldWithImplementation )  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeAndEquals"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   objectType    =    ResolvableType . forClass ( Object . class )  ;", "ResolvableType   unresolvableVariable    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" o \"  )  )  ;", "assertThat ( unresolvableVariable . resolve (  )  ,    nullValue (  )  )  ;", "assertAssignable ( objectType ,    unresolvableVariable )  . equalTo ( true )  ;", "assertAssignable ( unresolvableVariable ,    objectType )  . equalTo ( true )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromCannotBeResolved"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   object    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" o \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   objectArray    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" oarray \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   charSequenceArray    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" carray \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   stringArray    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" sarray \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "assertAssignable ( object ,    objectArray ,    charSequenceArray ,    stringArray )  . equalTo ( true ,    true ,    true )  ;", "assertAssignable ( objectArray ,    object ,    objectArray ,    charSequenceArray ,    stringArray )  . equalTo ( false ,    true ,    true ,    true )  ;", "assertAssignable ( charSequenceArray ,    object ,    objectArray ,    charSequenceArray ,    stringArray )  . equalTo ( false ,    false ,    true ,    true )  ;", "assertAssignable ( stringArray ,    object ,    objectArray ,    charSequenceArray ,    stringArray )  . equalTo ( false ,    false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromForArrays"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   objectType    =    ResolvableType . forClass ( Object . class )  ;", "ResolvableType   charSequenceType    =    ResolvableType . forClass ( CharSequence . class )  ;", "ResolvableType   stringType    =    ResolvableType . forClass ( String . class )  ;", "assertAssignable ( objectType ,    objectType ,    charSequenceType ,    stringType )  . equalTo ( true ,    true ,    true )  ;", "assertAssignable ( charSequenceType ,    objectType ,    charSequenceType ,    stringType )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( stringType ,    objectType ,    charSequenceType ,    stringType )  . equalTo ( false ,    false ,    true )  ;", "assertTrue ( objectType . isAssignableFrom ( String . class )  )  ;", "assertTrue ( objectType . isAssignableFrom ( StringBuilder . class )  )  ;", "assertTrue ( charSequenceType . isAssignableFrom ( String . class )  )  ;", "assertTrue ( charSequenceType . isAssignableFrom ( StringBuilder . class )  )  ;", "assertTrue ( stringType . isAssignableFrom ( String . class )  )  ;", "assertFalse ( stringType . isAssignableFrom ( StringBuilder . class )  )  ;", "assertTrue ( objectType . isInstance (  \" a   String \"  )  )  ;", "assertTrue ( objectType . isInstance ( new   StringBuilder (  \" a   StringBuilder \"  )  )  )  ;", "assertTrue ( charSequenceType . isInstance (  \" a   String \"  )  )  ;", "assertTrue ( charSequenceType . isInstance ( new   StringBuilder (  \" a   StringBuilder \"  )  )  )  ;", "assertTrue ( stringType . isInstance (  \" a   String \"  )  )  ;", "assertFalse ( stringType . isInstance ( new   StringBuilder (  \" a   StringBuilder \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromForClassAndClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   objectType    =    ResolvableType . forClass ( Object . class )  ;", "ResolvableType   charSequenceType    =    ResolvableType . forClass ( CharSequence . class )  ;", "ResolvableType   stringType    =    ResolvableType . forClass ( String . class )  ;", "ResolvableType   objectVariable    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" o \"  )  ,     . Assignment . class )  ;", "ResolvableType   charSequenceVariable    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" c \"  )  ,     . Assignment . class )  ;", "ResolvableType   stringVariable    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" s \"  )  ,     . Assignment . class )  ;", "assertAssignable ( objectType ,    objectVariable ,    charSequenceVariable ,    stringVariable )  . equalTo ( true ,    true ,    true )  ;", "assertAssignable ( charSequenceType ,    objectVariable ,    charSequenceVariable ,    stringVariable )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( stringType ,    objectVariable ,    charSequenceVariable ,    stringVariable )  . equalTo ( false ,    false ,    true )  ;", "assertAssignable ( objectVariable ,    objectType ,    charSequenceType ,    stringType )  . equalTo ( true ,    true ,    true )  ;", "assertAssignable ( charSequenceVariable ,    objectType ,    charSequenceType ,    stringType )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( stringVariable ,    objectType ,    charSequenceType ,    stringType )  . equalTo ( false ,    false ,    true )  ;", "assertAssignable ( objectVariable ,    objectVariable ,    charSequenceVariable ,    stringVariable )  . equalTo ( true ,    true ,    true )  ;", "assertAssignable ( charSequenceVariable ,    objectVariable ,    charSequenceVariable ,    stringVariable )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( stringVariable ,    objectVariable ,    charSequenceVariable ,    stringVariable )  . equalTo ( false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromForClassAndSimpleVariable"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   complex 1     =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" complexWildcard 1  \"  )  )  ;", "ResolvableType   complex 2     =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" complexWildcard 2  \"  )  )  ;", "ResolvableType   complex 3     =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" complexWildcard 3  \"  )  )  ;", "ResolvableType   complex 4     =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" complexWildcard 4  \"  )  )  ;", "assertAssignable ( complex 1  ,    complex 2  )  . equalTo ( true )  ;", "assertAssignable ( complex 2  ,    complex 1  )  . equalTo ( false )  ;", "assertAssignable ( complex 3  ,    complex 4  )  . equalTo ( true )  ;", "assertAssignable ( complex 4  ,    complex 3  )  . equalTo ( false )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromForComplexWildcards"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   extendsCharSequenceCollection    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" collectionxc \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   charSequenceCollection    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" collectionc \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   charSequenceList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" listc \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   extendsCharSequenceList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" listxc \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   extendsStringList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" listxs \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "assertAssignable ( extendsCharSequenceCollection ,    charSequenceCollection ,    charSequenceList ,    extendsCharSequenceList ,    extendsStringList )  . equalTo ( true ,    true ,    true ,    true )  ;", "assertAssignable ( charSequenceCollection ,    charSequenceList ,    extendsCharSequenceList ,    extendsStringList )  . equalTo ( true ,    false ,    false )  ;", "assertAssignable ( charSequenceList ,    extendsCharSequenceCollection ,    charSequenceCollection )  . equalTo ( false ,    false )  ;", "assertAssignable ( extendsCharSequenceList ,    extendsCharSequenceCollection ,    charSequenceCollection )  . equalTo ( false ,    false )  ;", "assertAssignable ( extendsStringList ,    charSequenceCollection ,    charSequenceList ,    extendsCharSequenceList )  . equalTo ( false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromForDifferentClassesWithGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   objectType    =    ResolvableType . forClass ( Object . class )  ;", "assertThat ( objectType . isAssignableFrom ( ResolvableType . NONE )  ,    equalTo ( false )  )  ;", "assertThat ( ResolvableType . NONE . isAssignableFrom ( objectType )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromForNone"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   objectList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" listo \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   charSequenceList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" listc \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   stringList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" lists \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   extendsObjectList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" listxo \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   extendsCharSequenceList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" listxc \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   extendsStringList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" listxs \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "assertAssignable ( objectList ,    extendsObjectList ,    extendsCharSequenceList ,    extendsStringList )  . equalTo ( false ,    false ,    false )  ;", "assertAssignable ( charSequenceList ,    extendsObjectList ,    extendsCharSequenceList ,    extendsStringList )  . equalTo ( false ,    false ,    false )  ;", "assertAssignable ( stringList ,    extendsObjectList ,    extendsCharSequenceList ,    extendsStringList )  . equalTo ( false ,    false ,    false )  ;", "assertAssignable ( extendsObjectList ,    objectList ,    charSequenceList ,    stringList )  . equalTo ( true ,    true ,    true )  ;", "assertAssignable ( extendsObjectList ,    extendsObjectList ,    extendsCharSequenceList ,    extendsStringList )  . equalTo ( true ,    true ,    true )  ;", "assertAssignable ( extendsCharSequenceList ,    extendsObjectList ,    extendsCharSequenceList ,    extendsStringList )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( extendsCharSequenceList ,    objectList ,    charSequenceList ,    stringList )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( extendsStringList ,    extendsObjectList ,    extendsCharSequenceList ,    extendsStringList )  . equalTo ( false ,    false ,    true )  ;", "assertAssignable ( extendsStringList ,    objectList ,    charSequenceList ,    stringList )  . equalTo ( false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromForSameClassExtendsGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   objectList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" listo \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "ResolvableType   stringList    =    ResolvableType . forField ( ResolvableTypeTests . AssignmentBase . class . getField (  \" lists \"  )  ,    ResolvableTypeTests . Assignment . class )  ;", "assertAssignable ( stringList ,    objectList )  . equalTo ( false )  ;", "assertAssignable ( objectList ,    stringList )  . equalTo ( false )  ;", "assertAssignable ( stringList ,    stringList )  . equalTo ( true )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromForSameClassNonExtendsGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   object    =    ResolvableType . forClass ( Object . class )  ;", "ResolvableType   charSequence    =    ResolvableType . forClass ( CharSequence . class )  ;", "ResolvableType   string    =    ResolvableType . forClass ( String . class )  ;", "ResolvableType   extendsAnon    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" listAnon \"  )  ,     . Assignment . class )  . getGeneric (  )  ;", "ResolvableType   extendsObject    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" listxo \"  )  ,     . Assignment . class )  . getGeneric (  )  ;", "ResolvableType   extendsCharSequence    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" listxc \"  )  ,     . Assignment . class )  . getGeneric (  )  ;", "ResolvableType   extendsString    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" listxs \"  )  ,     . Assignment . class )  . getGeneric (  )  ;", "ResolvableType   superObject    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" listso \"  )  ,     . Assignment . class )  . getGeneric (  )  ;", "ResolvableType   superCharSequence    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" listsc \"  )  ,     . Assignment . class )  . getGeneric (  )  ;", "ResolvableType   superString    =    ResolvableType . forField (  . AssignmentBase . class . getField (  \" listss \"  )  ,     . Assignment . class )  . getGeneric (  )  ;", "assertAssignable ( extendsCharSequence ,    extendsObject ,    extendsCharSequence ,    extendsString )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( extendsCharSequence ,    object ,    charSequence ,    string )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( superCharSequence ,    superObject ,    superCharSequence ,    superString )  . equalTo ( true ,    true ,    false )  ;", "assertAssignable ( superCharSequence ,    object ,    charSequence ,    string )  . equalTo ( true ,    true ,    false )  ;", "assertAssignable ( superCharSequence ,    extendsObject ,    extendsCharSequence ,    extendsString )  . equalTo ( false ,    false ,    false )  ;", "assertAssignable ( extendsCharSequence ,    superObject ,    superCharSequence ,    superString )  . equalTo ( false ,    false ,    false )  ;", "assertAssignable ( charSequence ,    object ,    charSequence ,    string )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( extendsCharSequence ,    object ,    charSequence ,    string )  . equalTo ( false ,    true ,    true )  ;", "assertAssignable ( charSequence ,    extendsObject ,    extendsCharSequence ,    extendsString )  . equalTo ( false ,    false ,    false )  ;", "assertAssignable ( extendsAnon ,    object ,    charSequence ,    string )  . equalTo ( true ,    true ,    true )  ;", "assertAssignable ( superCharSequence ,    object ,    charSequence ,    string )  . equalTo ( true ,    true ,    false )  ;", "assertAssignable ( charSequence ,    superObject ,    superCharSequence ,    superString )  . equalTo ( false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromForWildcards"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Type   must   not   be   null \"  )  ;", ". forClass ( Object . class )  . isAssignableFrom (  (  (  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFromMustNotBeNull"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   t    =    ResolvableType . forField ( getClass (  )  . getDeclaredField (  \" myMap \"  )  )  ;", "assertThat ( t . toString (  )  ,    equalTo (  \" HashMap < Integer ,    List < String >  >  \"  )  )  ;", "assertThat ( t . getType (  )  . getTypeName (  )  ,    equalTo (  \" HashMap < Integer ,    List < String >  >  \"  )  )  ;", "assertThat ( t . getType (  )  . toString (  )  ,    equalTo (  \" HashMap < Integer ,    List < String >  >  \"  )  )  ;", "assertThat ( t . getSuperType (  )  . toString (  )  ,    equalTo (  \" AbstractMap < Integer ,    List < String >  >  \"  )  )  ;", "assertThat ( t . asMap (  )  . toString (  )  ,    equalTo (  \" Map < Integer ,    List < String >  >  \"  )  )  ;", "assertThat ( t . getGeneric (  0  )  . resolve (  )  ,    equalTo ( Integer . class )  )  ;", "assertThat ( t . getGeneric (  1  )  . resolve (  )  ,    equalTo ( List . class )  )  ;", "assertThat ( t . getGeneric (  1  )  . toString (  )  ,    equalTo (  \" List < String >  \"  )  )  ;", "assertThat ( t . resolveGeneric (  1  ,     0  )  ,    equalTo ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["javaDocSample"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringList \"  )  )  ;", "ResolvableType   narrow    =    ResolvableType . forType ( ArrayList . class ,    type )  ;", "assertThat ( narrow . getGeneric (  )  . resolve (  )  ,    equalTo ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["narrow"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" nested \"  )  )  ;", "type    =    type . getNested (  2  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Map . class )  )  )  )  ;", "assertThat ( type . getGeneric (  0  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Byte . class )  )  )  )  ;", "assertThat ( type . getGeneric (  1  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Long . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nested"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" genericArrayType \"  )  )  ;", "type    =    type . getNested (  2  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nestedWithArray"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" nested \"  )  )  ;", "type    =    type . getNested (  2  ,    Collections . singletonMap (  2  ,     0  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Map . class )  )  )  )  ;", "assertThat ( type . getGeneric (  0  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( type . getGeneric (  1  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Integer . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nestedWithIndexes"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  ;", "ResolvableType [  ]    generics    =    type . getGenerics (  )  ;", "assertThat ( generics . length ,    equalTo (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["noGetGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( ResolvableType . forClass ( Object . class )  . getInterfaces (  )  . length ,    equalTo (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["noInterfaces"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( ResolvableType . forClass ( Object . class )  . getSuperType (  )  ,    equalTo ( ResolvableType . NONE )  )  ;", "}", "METHOD_END"], "methodName": ["noSuperType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   none    =    ResolvableType . NONE ;", "assertThat ( none . as ( Object . class )  ,    equalTo ( ResolvableType . NONE )  )  ;", "assertThat ( none . asCollection (  )  ,    equalTo ( ResolvableType . NONE )  )  ;", "assertThat ( none . asMap (  )  ,    equalTo ( ResolvableType . NONE )  )  ;", "assertThat ( none . getComponentType (  )  ,    equalTo ( ResolvableType . NONE )  )  ;", "assertThat ( none . getGeneric (  0  )  ,    equalTo ( ResolvableType . NONE )  )  ;", "assertThat ( none . getGenerics (  )  . length ,    equalTo (  0  )  )  ;", "assertThat ( none . getInterfaces (  )  . length ,    equalTo (  0  )  )  ;", "assertThat ( none . getSuperType (  )  ,    equalTo ( ResolvableType . NONE )  )  ;", "assertThat ( none . getType (  )  ,    equalTo ( ResolvableType . EmptyType . INSTANCE )  )  ;", "assertThat ( none . hasGenerics (  )  ,    equalTo ( false )  )  ;", "assertThat ( none . isArray (  )  ,    equalTo ( false )  )  ;", "assertThat ( none . resolve (  )  ,    nullValue (  )  )  ;", "assertThat ( none . resolve ( String . class )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( none . resolveGeneric (  0  )  ,    nullValue (  )  )  ;", "assertThat ( none . resolveGenerics (  )  . length ,    equalTo (  0  )  )  ;", "assertThat ( none . toString (  )  ,    equalTo (  \"  ?  \"  )  )  ;", "assertThat ( none . hasUnresolvableGenerics (  )  ,    equalTo ( false )  )  ;", "assertThat ( none . isAssignableFrom ( ResolvableType . forClass ( Object . class )  )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["noneReturnValues"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" parameterizedType \"  )  )  ;", "assertThat ( type . getType (  )  ,    instanceOf ( ParameterizedType . class )  )  ;", "}", "METHOD_END"], "methodName": ["paramaterizedType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" arrayClassType \"  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List [  ]  . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArrayClassType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forMethodReturnType ( ResolvableTypeTests . Methods . class . getMethod (  \" boundedTypeVaraibleResult \"  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( CharSequence . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveBoundedTypeVariableResult"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" classType \"  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveClassType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( List . class ,    ResolvableType . forClassWithGenerics ( List . class ,    String . class )  )  ;", "assertThat ( type . asCollection (  )  . toString (  )  ,    equalTo (  \" Collection < List < String >  >  \"  )  )  ;", "assertThat ( type . asCollection (  )  . getGeneric (  )  . toString (  )  ,    equalTo (  \" List < String >  \"  )  )  ;", "assertThat ( type . asCollection (  )  . getGeneric (  )  . asCollection (  )  . toString (  )  ,    equalTo (  \" Collection < String >  \"  )  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" List < List < String >  >  \"  )  )  ;", "assertThat ( type . asCollection (  )  . getGeneric (  )  . getGeneric (  )  . resolve (  )  ,    equalTo (  (  ( Type )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveFromClassWithGenerics"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    ResolvableTypeTests . EnclosedInParameterizedType . InnerTyped . class . getField (  \" field \"  )  ;", "ResolvableType   type    =    ResolvableType . forField ( field ,    ResolvableTypeTests . TypedEnclosedInParameterizedType . TypedInnerTyped . class )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Type )     ( Integer . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveFromOuterClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringArrayList \"  )  )  ;", "ResolvableType   generic    =    type . asCollection (  )  . getGeneric (  )  ;", "assertThat ( generic . getType (  )  . toString (  )  ,    equalTo (  \" E \"  )  )  ;", "assertThat ( generic . isArray (  )  ,    equalTo ( true )  )  ;", "assertThat ( generic . resolve (  )  ,    equalTo (  (  ( Class )     ( String [  ]  . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveGenericArrayFromGeneric"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" genericArrayType \"  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List [  ]  . class )  )  )  )  ;", "assertThat ( type . getComponentType (  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . getComponentType (  )  . getGeneric (  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveGenericArrayType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" genericMultiArrayType \"  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List [  ]  [  ]  [  ]  . class )  )  )  )  ;", "assertThat ( type . getComponentType (  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( List [  ]  [  ]  . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveGenericMultiArrayType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" parameterizedType \"  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveParameterizedType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forMethodReturnType ( ResolvableTypeTests . Methods . class . getMethod (  \" typedReturn \"  )  )  ;", "assertThat ( type . resolve (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVaraibleFromMethodReturn"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forMethodReturnType ( ResolvableTypeTests . Methods . class . getMethod (  \" typedReturn \"  )  ,    ResolvableTypeTests . TypedMethods . class )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVaraibleFromMethodReturnWithInstanceClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . MyCollectionInterfaceType . class )  . as ( ResolvableTypeTests . MyInterfaceType . class )  ;", "assertThat ( type . resolveGeneric (  )  ,    equalTo (  (  ( Class )     ( Collection . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  0  ,     0  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVaraibleFromSimpleCollectionInterfaceType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . MyCollectionSuperclassType . class )  . as ( ResolvableTypeTests . MySuperclassType . class )  ;", "assertThat ( type . resolveGeneric (  )  ,    equalTo (  (  ( Class )     ( Collection . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  0  ,     0  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVaraibleFromSimpleCollectionSuperclassType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . MySimpleInterfaceType . class )  . as ( ResolvableTypeTests . MyInterfaceType . class )  ;", "assertThat ( type . resolveGeneric (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVaraibleFromSimpleInterfaceType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . MySimpleSuperclassType . class )  . as ( ResolvableTypeTests . MySuperclassType . class )  ;", "assertThat ( type . resolveGeneric (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVaraibleFromSimpleSuperclassType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . MySuperclassType . class ,    ResolvableTypeTests . MyCollectionSuperclassType . class )  ;", "assertThat ( type . resolveGeneric (  )  ,    equalTo (  (  ( Class )     ( Collection . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  0  ,     0  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromClassWithImplementsClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    constructor    =    ResolvableTypeTests . Constructors . class . getConstructor ( List . class )  ;", "ResolvableType   type    =    ResolvableType . forConstructorParameter ( constructor ,     0  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  0  )  ,    equalTo (  (  ( Class )     ( CharSequence . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromConstructorParameter"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    constructor    =    ResolvableTypeTests . Constructors . class . getConstructor ( Map . class )  ;", "ResolvableType   type    =    ResolvableType . forConstructorParameter ( constructor ,     0  ,    ResolvableTypeTests . TypedConstructors . class )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Map . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  0  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromConstructorParameterWithImplementsClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Type   sourceType    =    ResolvableTypeTests . Methods . class . getMethod (  \" charSequenceReturn \"  )  . getGenericReturnType (  )  ;", "ResolvableType   reflectiveType    =    ResolvableType . forType ( sourceType )  ;", "ResolvableType   declaredType    =    ResolvableType . forType ( new   ParameterizedTypeReference < List < CharSequence >  >  (  )     {  }  )  ;", "assertEquals ( reflectiveType ,    declaredType )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromDeclaredParameterizedTypeReference"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" parameterizedType \"  )  ,    ResolvableTypeTests . TypedFields . class )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . getGeneric (  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromFieldTypeWithImplementsClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   implementationType    =    ResolvableType . forClassWithGenerics ( ResolvableTypeTests . Fields . class ,    Integer . class )  ;", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" parameterizedType \"  )  ,    implementationType )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . getGeneric (  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Integer . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromFieldTypeWithImplementsType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedParameter \"  ,    Object . class )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( method ,     0  )  ;", "assertThat ( type . resolve (  )  ,    nullValue (  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromMethodParameter"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedParameter \"  ,    Object . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( method ,     0  )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( methodParameter )  ;", "assertThat ( type . resolve (  )  ,    nullValue (  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromMethodParameterType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedParameter \"  ,    Object . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( method ,     0  )  ;", "methodParameter . setContainingClass ( ResolvableTypeTests . TypedMethods . class )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( methodParameter )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromMethodParameterTypeWithImplementsClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedParameter \"  ,    Object . class )  ;", "MethodParameter   methodParameter    =    MethodParameter . forExecutable ( method ,     0  )  ;", "ResolvableType   implementationType    =    ResolvableType . forClassWithGenerics ( ResolvableTypeTests . Methods . class ,    Integer . class )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( methodParameter ,    implementationType )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Integer . class )  )  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromMethodParameterTypeWithImplementsType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedParameter \"  ,    Object . class )  ;", "ResolvableType   type    =    ResolvableType . forMethodParameter ( method ,     0  ,    ResolvableTypeTests . TypedMethods . class )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromMethodParameterWithImplementsClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedReturn \"  )  ;", "ResolvableType   type    =    ResolvableType . forMethodReturnType ( method )  ;", "assertThat ( type . resolve (  )  ,    nullValue (  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromMethodReturn"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedReturn \"  )  ;", "ResolvableType   type    =    ResolvableType . forMethodReturnType ( method ,    ResolvableTypeTests . TypedMethods . class )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromMethodReturnWithImplementsClass"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Type   sourceType    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedReturn \"  )  . getGenericReturnType (  )  ;", "ResolvableType   type    =    ResolvableType . forType ( ParameterizedTypeReference . forType ( sourceType )  )  ;", "assertThat ( type . resolve (  )  ,    nullValue (  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromReflectiveParameterizedTypeReference"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forClass ( ResolvableTypeTests . ExtendsList . class )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( ResolvableTypeTests . ExtendsList . class )  )  )  )  ;", "assertThat ( type . asCollection (  )  . resolveGeneric (  )  ,    equalTo (  (  ( Class )     ( CharSequence . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromSuperType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Type   sourceType    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedReturn \"  )  . getGenericReturnType (  )  ;", "ResolvableType   type    =    ResolvableType . forType ( sourceType )  ;", "assertThat ( type . resolve (  )  ,    nullValue (  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Type   sourceType    =    ResolvableTypeTests . Methods . class . getMethod (  \" typedReturn \"  )  . getGenericReturnType (  )  ;", "ResolvableType   type    =    ResolvableType . forType ( sourceType ,    ResolvableType . forClass ( ResolvableTypeTests . TypedMethods . class )  . as ( ResolvableTypeTests . Methods . class )  . asVariableResolver (  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeVariableFromTypeWithVariableResolver"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType . VariableResolver   variableResolver    =    mock ( ResolvableType . VariableResolver . class )  ;", "given ( variableResolver . getSource (  )  )  . willReturn ( this )  ;", "ResolvableType   longType    =    ResolvableType . forClass ( Long . class )  ;", "given ( variableResolver . resolveVariable ( any (  )  )  )  . willReturn ( longType )  ;", "ResolvableType   variable    =    ResolvableType . forType (  . Fields . class . getField (  \" typeVariableType \"  )  . getGenericType (  )  ,    variableResolver )  ;", "ResolvableType   parameterized    =    ResolvableType . forType (  . Fields . class . getField (  \" parameterizedType \"  )  . getGenericType (  )  ,    variableResolver )  ;", "assertThat ( variable . resolve (  )  ,    equalTo (  (  ( Class )     ( Long . class )  )  )  )  ;", "assertThat ( parameterized . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( parameterized . resolveGeneric (  )  ,    equalTo (  (  ( Class )     ( Long . class )  )  )  )  ;", "verify ( variableResolver ,    atLeastOnce (  )  )  . resolveVariable ( this . typeVariableCaptor . capture (  )  )  ;", "assertThat ( this . typeVariableCaptor . getValue (  )  . getName (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTypeWithCustomVariableResolver"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    constructor    =    ResolvableTypeTests . Constructors . class . getConstructor ( Map . class )  ;", "ResolvableType   type    =    ResolvableType . forConstructorParameter ( constructor ,     0  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( Map . class )  )  )  )  ;", "assertThat ( type . resolveGeneric (  0  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveUnknownTypeVariableFromConstructorParameter"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringList \"  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . getGeneric (  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveVariableFromFieldType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" parameterizedType \"  )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . getGeneric (  )  . resolve (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveVariableFromFieldTypeUnknown"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringIntegerMultiValueMap \"  )  )  . as ( Map . class )  ;", "assertThat ( type . getGeneric (  0  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( type . getGeneric (  1  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . getGeneric (  1  ,     0  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Integer . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveVariableFromInheritedField"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" stringIntegerMultiValueMapSwitched \"  )  )  . as ( Map . class )  ;", "assertThat ( type . getGeneric (  0  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( String . class )  )  )  )  ;", "assertThat ( type . getGeneric (  1  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( List . class )  )  )  )  ;", "assertThat ( type . getGeneric (  1  ,     0  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Integer . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveVariableFromInheritedFieldSwitched"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" variableTypeGenericArray \"  )  ,    ResolvableTypeTests . TypedFields . class )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T [  ]  \"  )  )  ;", "assertThat ( type . isArray (  )  ,    equalTo ( true )  )  ;", "assertThat ( type . resolve (  )  ,    equalTo (  (  ( Class )     ( String [  ]  . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveVariableGenericArray"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" variableTypeGenericArray \"  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T [  ]  \"  )  )  ;", "assertThat ( type . isArray (  )  ,    equalTo ( true )  )  ;", "assertThat ( type . resolve (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveVariableGenericArrayUnknown"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" variableTypeGenericArray \"  )  )  ;", "assertThat ( type . getType (  )  . toString (  )  ,    equalTo (  \" T [  ]  \"  )  )  ;", "assertThat ( type . isArray (  )  ,    equalTo ( true )  )  ;", "assertThat ( type . resolve ( Object . class )  ,    equalTo (  (  ( Class )     ( Object . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveVariableGenericArrayUnknownWithFallback"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forMethodReturnType ( ResolvableTypeTests . Methods . class . getMethod (  \" typedReturn \"  )  )  ;", "assertThat ( type . resolve (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveVariableNotFound"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" wildcardSuperType \"  )  )  ;", "assertThat ( type . getGeneric (  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Number . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWildcardLowerBounds"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" wildcardType \"  )  )  ;", "assertThat ( type . getGeneric (  )  . resolve (  )  ,    equalTo (  (  ( Class )     ( Number . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWildcardTypeUpperBounds"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "testSerialization ( ResolvableType . forClass ( List . class )  )  ;", "testSerialization ( ResolvableType . forField (  . Fields . class . getField (  \" charSequenceList \"  )  )  )  ;", "testSerialization ( ResolvableType . forMethodParameter (  . Methods . class . getMethod (  \" charSequenceParameter \"  ,    List . class )  ,     0  )  )  ;", "testSerialization ( ResolvableType . forMethodReturnType (  . Methods . class . getMethod (  \" charSequenceReturn \"  )  )  )  ;", "testSerialization ( ResolvableType . forConstructorParameter (  . Constructors . class . getConstructor ( List . class )  ,     0  )  )  ;", "testSerialization ( ResolvableType . forField (  . Fields . class . getField (  \" charSequenceList \"  )  )  . getGeneric (  )  )  ;", "testSerialization ( ResolvableType . forField (  . Fields . class . getField (  \" charSequenceList \"  )  )  . asCollection (  )  )  ;", "testSerialization ( ResolvableType . forClass (  . ExtendsMap . class )  . getSuperType (  )  )  ;", "ResolvableType   deserializedNone    =    testSerialization ( ResolvableType . NONE )  ;", "assertThat ( deserializedNone ,    sameInstance ( ResolvableType . NONE )  )  ;", "}", "METHOD_END"], "methodName": ["serialize"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =     ( ResolvableType . NONE )  )     {", "return    \" NONE \"  ;", "}", "if    ( type . getType (  )  . getClass (  )  . equals ( Class . class )  )     {", "return   type . toString (  )  ;", "}", "return    (  ( type . getType (  )  )     +     \"  :  \"  )     +    type ;", "}", "METHOD_END"], "methodName": ["stringDesc"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream (  )  ;", "ObjectOutputStream   oos    =    new   ObjectOutputStream ( bos )  ;", "oos . writeObject ( type )  ;", "oos . close (  )  ;", "ObjectInputStream   ois    =    new   ObjectInputStream ( new   ByteArrayInputStream ( bos . toByteArray (  )  )  )  ;", "read    =     (  (  )     ( ois . readObject (  )  )  )  ;", "assertThat ( read ,    equalTo ( type )  )  ;", "assertThat ( read . getType (  )  ,    equalTo ( type . getType (  )  )  )  ;", "assertThat ( read . resolve (  )  ,    equalTo ( type . resolve (  )  )  )  ;", "return   read ;", "}", "METHOD_END"], "methodName": ["testSerialization"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . BaseProvider . class . getField (  \" stuff \"  )  ,    ResolvableTypeTests . BaseProvider . class )  ;", "assertTrue ( type . getNested (  2  )  . isAssignableFrom ( ResolvableType . forClass ( ResolvableTypeTests . BaseImplementation . class )  )  )  ;", "assertEquals (  \" Collection <  $ IBase <  ?  >  >  \"  ,    type . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpr11219"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   resolvableType    =    ResolvableType . forClassWithGenerics ( Callable . class ,    String . class )  ;", "Type   type    =    resolvableType . getType (  )  ;", "assertThat ( type ,    is ( instanceOf ( ParameterizedType . class )  )  )  ;", "assertThat (  (  ( ParameterizedType )     ( type )  )  . getRawType (  )  ,    is ( equalTo ( Callable . class )  )  )  ;", "assertThat (  (  ( ParameterizedType )     ( type )  )  . getActualTypeArguments (  )  . length ,    is ( equalTo (  1  )  )  )  ;", "assertThat (  (  ( ParameterizedType )     ( type )  )  . getActualTypeArguments (  )  [  0  ]  ,    is ( equalTo ( String . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpr12701"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   collectionClass    =    ResolvableType . forRawClass ( Collection . class )  ;", "ResolvableType   setClass    =    ResolvableType . forRawClass ( Set . class )  ;", "ResolvableType   fromReturnType    =    ResolvableType . forMethodReturnType (  . Methods . class . getMethod (  \" wildcardSet \"  )  )  ;", "assertTrue ( collectionClass . isAssignableFrom ( fromReturnType )  )  ;", "assertTrue ( setClass . isAssignableFrom ( fromReturnType )  )  ;", "}", "METHOD_END"], "methodName": ["testSpr14648"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   genericType    =    ResolvableType . forField ( ResolvableTypeTests . UnresolvedWithGenerics . class . getDeclaredField (  \" set \"  )  )  . asCollection (  )  ;", "ResolvableType   type    =    ResolvableType . forClassWithGenerics ( ArrayList . class ,    genericType . getGeneric (  )  )  ;", "assertThat ( type . resolveGeneric (  )  ,    equalTo ( Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["testSpr16456"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( ResolvableType . NONE . toString (  )  ,    equalTo (  \"  ?  \"  )  )  ;", "assertFieldToStringValue (  \" classType \"  ,     \" List <  ?  >  \"  )  ;", "assertFieldToStringValue (  \" typeVariableType \"  ,     \"  ?  \"  )  ;", "assertFieldToStringValue (  \" parameterizedType \"  ,     \" List <  ?  >  \"  )  ;", "assertFieldToStringValue (  \" arrayClassType \"  ,     \" List <  ?  >  [  ]  \"  )  ;", "assertFieldToStringValue (  \" genericArrayType \"  ,     \" List < String >  [  ]  \"  )  ;", "assertFieldToStringValue (  \" genericMultiArrayType \"  ,     \" List < String >  [  ]  [  ]  [  ]  \"  )  ;", "assertFieldToStringValue (  \" wildcardType \"  ,     \" List < Number >  \"  )  ;", "assertFieldToStringValue (  \" wildcardSuperType \"  ,     \" List < Number >  \"  )  ;", "assertFieldToStringValue (  \" charSequenceList \"  ,     \" List < CharSequence >  \"  )  ;", "assertFieldToStringValue (  \" stringList \"  ,     \" List < String >  \"  )  ;", "assertFieldToStringValue (  \" stringListList \"  ,     \" List < List < String >  >  \"  )  ;", "assertFieldToStringValue (  \" stringArrayList \"  ,     \" List < String [  ]  >  \"  )  ;", "assertFieldToStringValue (  \" stringIntegerMultiValueMap \"  ,     \" util . MultiValueMap < String ,    Integer >  \"  )  ;", "assertFieldToStringValue (  \" stringIntegerMultiValueMapSwitched \"  ,     (  ( ResolvableTypeTests . VariableNameSwitch . class . getName (  )  )     +     \"  < Integer ,    String >  \"  )  )  ;", "assertFieldToStringValue (  \" listOfListOfUnknown \"  ,     \" List < List <  ?  >  >  \"  )  ;", "assertTypedFieldToStringValue (  \" typeVariableType \"  ,     \" String \"  )  ;", "assertTypedFieldToStringValue (  \" parameterizedType \"  ,     \" List < String >  \"  )  ;", "assertThat ( ResolvableType . forClass ( ResolvableTypeTests . ListOfGenericArray . class )  . toString (  )  ,    equalTo ( ResolvableTypeTests . ListOfGenericArray . class . getName (  )  )  )  ;", "assertThat ( ResolvableType . forClass ( List . class ,    ResolvableTypeTests . ListOfGenericArray . class )  . toString (  )  ,    equalTo (  \" List < List < String >  [  ]  >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["toStrings"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" typeVariableType \"  )  )  ;", "assertThat ( type . getType (  )  ,    instanceOf ( TypeVariable . class )  )  ;", "}", "METHOD_END"], "methodName": ["typeVariableType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   type    =    ResolvableType . forField ( ResolvableTypeTests . Fields . class . getField (  \" wildcardType \"  )  )  ;", "assertThat ( type . getType (  )  ,    instanceOf ( ParameterizedType . class )  )  ;", "assertThat ( type . getGeneric (  )  . getType (  )  ,    instanceOf ( WildcardType . class )  )  ;", "}", "METHOD_END"], "methodName": ["wildcardType"], "fileName": "org.springframework.core.ResolvableTypeTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( field ,     \" Field   must   not   be   null \"  )  ;", "return    . forTypeProvider ( new    . FieldTypeProvider ( field )  )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.core.SerializableTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "Type [  ]    result    =    new   Type [ type . getGenericInterfaces (  )  . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( result . length )  ;    i +  +  )     {", "final   int   index    =    i ;", "result [ i ]     =     . forTypeProvider (  (  )     -  >    type . getGenericInterfaces (  )  [ index ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["forGenericInterfaces"], "fileName": "org.springframework.core.SerializableTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "return   SerializableTypeWrapper . forTypeProvider ( type :  : getGenericSuperclass )  ;", "}", "METHOD_END"], "methodName": ["forGenericSuperclass"], "fileName": "org.springframework.core.SerializableTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "return   SerializableTypeWrapper . forTypeProvider ( new   SerializableTypeWrapper . MethodParameterTypeProvider ( methodParameter )  )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameter"], "fileName": "org.springframework.core.SerializableTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "Type [  ]    result    =    new   Type [ type . getTypeParameters (  )  . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( result . length )  ;    i +  +  )     {", "final   int   index    =    i ;", "result [ i ]     =     . forTypeProvider (  (  )     -  >    type . getTypeParameters (  )  [ index ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["forTypeParameters"], "fileName": "org.springframework.core.SerializableTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( provider ,     \" Provider   must   not   be   null \"  )  ;", "Type   providedType    =    provider . getType (  )  ;", "if    ( providedType    =  =    null )     {", "return   null ;", "}", "if    ( providedType   instanceof   Serializable )     {", "return   providedType ;", "}", "Type   cached    =     . cache . get ( providedType )  ;", "if    ( cached    !  =    null )     {", "return   cached ;", "}", "for    ( Class <  ?  >    type    :     . SUPPORTED _ SERIALIZABLE _ TYPES )     {", "if    ( type . isAssignableFrom ( providedType . getClass (  )  )  )     {", "ClassLoader   classLoader    =    provider . getClass (  )  . getClassLoader (  )  ;", "Class <  ?  >  [  ]    interfaces    =    new   Class <  ?  >  [  ]  {    type ,     . SerializableTypeProxy . class ,    Serializable . class    }  ;", "InvocationHandler   handler    =    new    . TypeProxyInvocationHandler ( provider )  ;", "cached    =     (  ( Type )     ( Proxy . newProxyInstance ( classLoader ,    interfaces ,    handler )  )  )  ;", ". cache . put ( providedType ,    cached )  ;", "return   cached ;", "}", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   Type   class :     \"     +     ( providedType . getClass (  )  . getName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["forTypeProvider"], "fileName": "org.springframework.core.SerializableTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "Type   unwrapped    =    type ;", "while    ( unwrapped   instanceof    . SerializableTypeProxy )     {", "unwrapped    =     (  (  . SerializableTypeProxy )     ( type )  )  . getTypeProvider (  )  . getType (  )  ;", "}", "return   unwrapped    !  =    null    ?     (  ( T )     ( unwrapped )  )     :    type ;", "}", "METHOD_END"], "methodName": ["unwrap"], "fileName": "org.springframework.core.SerializableTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream (  )  ;", "ObjectOutputStream   oos    =    new   ObjectOutputStream ( bos )  ;", "oos . writeObject ( source )  ;", "oos . close (  )  ;", "ObjectInputStream   ois    =    new   ObjectInputStream ( new   ByteArrayInputStream ( bos . toByteArray (  )  )  )  ;", "assertThat ( ois . readObject (  )  ,    equalTo ( source )  )  ;", "}", "METHOD_END"], "methodName": ["assertSerializable"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Type   type    =    SerializableTypeWrapper . forField ( SerializableTypeWrapperTests . Fields . class . getField (  \" classType \"  )  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" class   String \"  )  )  ;", "assertSerializable ( type )  ;", "}", "METHOD_END"], "methodName": ["classType"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    constructor    =    SerializableTypeWrapperTests . Constructors . class . getDeclaredConstructor ( List . class )  ;", "Type   type    =    SerializableTypeWrapper . forMethodParameter ( MethodParameter . forExecutable ( constructor ,     0  )  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" List < String >  \"  )  )  ;", "assertSerializable ( type )  ;", "}", "METHOD_END"], "methodName": ["forConstructor"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Type   type    =    SerializableTypeWrapper . forField ( SerializableTypeWrapperTests . Fields . class . getField (  \" parameterizedType \"  )  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" List < String >  \"  )  )  ;", "assertSerializable ( type )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Type   type    =    SerializableTypeWrapper . forGenericInterfaces ( List . class )  [  0  ]  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" Collection < E >  \"  )  )  ;", "assertSerializable ( type )  ;", "}", "METHOD_END"], "methodName": ["forGenericInterfaces"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Type   type    =    SerializableTypeWrapper . forGenericSuperclass ( ArrayList . class )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" AbstractList < E >  \"  )  )  ;", "assertSerializable ( type )  ;", "}", "METHOD_END"], "methodName": ["forGenericSuperClass"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    SerializableTypeWrapperTests . Methods . class . getDeclaredMethod (  \" method \"  ,    Class . class ,    Object . class )  ;", "Type   type    =    SerializableTypeWrapper . forMethodParameter ( MethodParameter . forExecutable ( method ,     0  )  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" Class < T >  \"  )  )  ;", "assertSerializable ( type )  ;", "}", "METHOD_END"], "methodName": ["forMethodParameter"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "Type   type    =    SerializableTypeWrapper . forTypeParameters ( List . class )  [  0  ]  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" E \"  )  )  ;", "assertSerializable ( type )  ;", "}", "METHOD_END"], "methodName": ["forTypeParameters"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "GenericArrayType   type    =     (  ( GenericArrayType )     ( SerializableTypeWrapper . forField ( SerializableTypeWrapperTests . Fields . class . getField (  \" genericArrayType \"  )  )  )  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" List < String >  [  ]  \"  )  )  ;", "assertSerializable ( type )  ;", "assertSerializable ( type . getGenericComponentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["genericArrayType"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedType   type    =     (  ( ParameterizedType )     ( SerializableTypeWrapper . forField ( SerializableTypeWrapperTests . Fields . class . getField (  \" parameterizedType \"  )  )  )  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" List < String >  \"  )  )  ;", "assertSerializable ( type )  ;", "assertSerializable ( type . getOwnerType (  )  )  ;", "assertSerializable ( type . getRawType (  )  )  ;", "assertSerializable ( type . getActualTypeArguments (  )  )  ;", "assertSerializable ( type . getActualTypeArguments (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedType"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "TypeVariable <  ?  >    type    =     (  ( TypeVariable <  ?  >  )     ( SerializableTypeWrapper . forField ( SerializableTypeWrapperTests . Fields . class . getField (  \" typeVariableType \"  )  )  )  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \" T \"  )  )  ;", "assertSerializable ( type )  ;", "assertSerializable ( type . getBounds (  )  )  ;", "}", "METHOD_END"], "methodName": ["typeVariableType"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedType   typeSource    =     (  ( ParameterizedType )     ( SerializableTypeWrapper . forField ( SerializableTypeWrapperTests . Fields . class . getField (  \" wildcardType \"  )  )  )  )  ;", "WildcardType   type    =     (  ( WildcardType )     ( typeSource . getActualTypeArguments (  )  [  0  ]  )  )  ;", "assertThat ( type . toString (  )  ,    equalTo (  \"  ?    extends   CharSequence \"  )  )  ;", "assertSerializable ( type )  ;", "assertSerializable ( type . getLowerBounds (  )  )  ;", "assertSerializable ( type . getUpperBounds (  )  )  ;", "}", "METHOD_END"], "methodName": ["wildcardType"], "fileName": "org.springframework.core.SerializableTypeWrapperTests"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["allowAliasOverriding"], "fileName": "org.springframework.core.SimpleAliasRegistry"}, {"methodBody": ["METHOD_START", "{", "String   canonicalName    =    name ;", "String   resolvedName ;", "do    {", "resolvedName    =    this . aliasMap . get ( canonicalName )  ;", "if    ( resolvedName    !  =    null )     {", "canonicalName    =    resolvedName ;", "}", "}    while    ( resolvedName    !  =    null    )  ;", "return   canonicalName ;", "}", "METHOD_END"], "methodName": ["canonicalName"], "fileName": "org.springframework.core.SimpleAliasRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( hasAlias ( alias ,    name )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  (  (  \" Cannot   register   alias    '  \"     +    alias )     +     \"  '    for   name    '  \"  )     +    name )     +     \"  '  :    Circular   reference    -     '  \"  )     +    name )     +     \"  '    is   a   direct   or   indirect   alias   for    '  \"  )     +    alias )     +     \"  '    already \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkForAliasCircle"], "fileName": "org.springframework.core.SimpleAliasRegistry"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    String >    entry    :    this . aliasMap . entrySet (  )  )     {", "String   reredName    =    entry . getValue (  )  ;", "if    ( reredName . equals ( name )  )     {", "String   reredAlias    =    entry . getKey (  )  ;", "return    ( reredAlias . equals ( alias )  )     |  |     ( hasAlias ( reredAlias ,    alias )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasAlias"], "fileName": "org.springframework.core.SimpleAliasRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( valueResolver ,     \" StringValueResolver   must   not   be   null \"  )  ;", "synchronized ( this . aliasMap )     {", "Map < String ,    String >    aliasCopy    =    new   HashMap <  >  ( this . aliasMap )  ;", "aliasCopy . forEach (  (    alias ,    reredName )     -  >     {", "String   resolvedAlias    =    valueResolver . resolveStringValue ( alias )  ;", "String   resolvedName    =    valueResolver . resolveStringValue ( reredName )  ;", "if    (  (  ( resolvedAlias    =  =    null )     |  |     ( resolvedName    =  =    null )  )     |  |     ( resolvedAlias . equals ( resolvedName )  )  )     {", "this . aliasMap . remove ( alias )  ;", "} else", "if    (  !  ( resolvedAlias . equals ( alias )  )  )     {", "String   existingName    =    this . aliasMap . get ( resolvedAlias )  ;", "if    ( existingName    !  =    null )     {", "if    ( existingName . equals ( resolvedName )  )     {", "this . aliasMap . remove ( alias )  ;", "return ;", "}", "throw   new   IllegalStateException (  (  (  (  (  (  (  (  (  \" Cannot   rer   resolved   alias    '  \"     +    resolvedAlias )     +     \"  '     ( original :     '  \"  )     +    alias )     +     \"  '  )    for   name    '  \"  )     +    resolvedName )     +     \"  '  :    It   is   already   rered   for   name    '  \"  )     +    reredName )     +     \"  '  .  \"  )  )  ;", "}", "checkForAliasCircle ( resolvedName ,    resolvedAlias )  ;", "this . aliasMap . remove ( alias )  ;", "this . aliasMap . put ( resolvedAlias ,    resolvedName )  ;", "} else", "if    (  !  ( reredName . equals ( resolvedName )  )  )     {", "this . aliasMap . put ( alias ,    resolvedName )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveAliases"], "fileName": "org.springframework.core.SimpleAliasRegistry"}, {"methodBody": ["METHOD_START", "{", "this . aliasMap . forEach (  (    alias ,    registeredName )     -  >     {", "if    ( registeredName . equals ( name )  )     {", "result . add ( alias )  ;", "retrieves ( alias ,    result )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["retrieveAliases"], "fileName": "org.springframework.core.SimpleAliasRegistry"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . parseBoolean ( SpringProperties . getProperty ( key )  )  ;", "}", "METHOD_END"], "methodName": ["getFlag"], "fileName": "org.springframework.core.SpringProperties"}, {"methodBody": ["METHOD_START", "{", "String   value    =    SpringProperties . localProperties . getProperty ( key )  ;", "if    ( value    =  =    null )     {", "try    {", "value    =    System . getProperty ( key )  ;", "}    catch    ( Throwable   ex )     {", "if    ( SpringProperties . logger . isDebugEnabled (  )  )     {", "SpringProperties . logger . debug (  (  (  (  \" Could   not   retrieve   system   property    '  \"     +    key )     +     \"  '  :     \"  )     +    ex )  )  ;", "}", "}", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.springframework.core.SpringProperties"}, {"methodBody": ["METHOD_START", "{", "SpringProperties . localProperties . put ( key ,    Boolean . TRUE . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["setFlag"], "fileName": "org.springframework.core.SpringProperties"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", ". localProperties . setProperty ( key ,    value )  ;", "} else    {", ". localProperties . remove ( key )  ;", "}", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.core.SpringProperties"}, {"methodBody": ["METHOD_START", "{", "Package   pkg    =    SpringVersion . class . getPackage (  )  ;", "return   pkg    !  =    null    ?    pkg . getImplementationVersion (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.springframework.core.SpringVersion"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( StandardReflectionParameterNameDiscoverTests . MessageService . class ,     \" sendMessage \"  ,    String . class )  ;", "String [  ]    actualParams    =    parameterNameDiscoverer . getParameterNames ( method )  ;", "assertThat ( actualParams ,    is ( new   String [  ]  {     \" message \"     }  )  )  ;", "}", "METHOD_END"], "methodName": ["getParameterNamesOnInterface"], "fileName": "org.springframework.core.StandardReflectionParameterNameDiscoverTests"}, {"methodBody": ["METHOD_START", "{", "parameterNameDiscoverer    =    new   StandardReflectionParameterNameDiscoverer (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.core.StandardReflectionParameterNameDiscoverTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    parameterNames    =    new   String [ parameters . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( parameters . length )  ;    i +  +  )     {", "Parameter   param    =    parameters [ i ]  ;", "if    (  !  ( param . isNamePresent (  )  )  )     {", "return   null ;", "}", "parameterNames [ i ]     =    param . getName (  )  ;", "}", "return   parameterNames ;", "}", "METHOD_END"], "methodName": ["getParameterNames"], "fileName": "org.springframework.core.StandardReflectionParameterNameDiscoverer"}, {"methodBody": ["METHOD_START", "{", "Method   xmlFile    =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" xmlFile \"  )  ;", "Method   groovyScript    =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" groovyScript \"  )  ;", "Method   value    =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" value \"  )  ;", "<  ?  >    extractor    =    createExtractorFor ( clazz ,    expected ,    AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "assertThat ( extractor . getAttributeValue ( value )  ,    is ( expected )  )  ;", "assertThat ( extractor . getAttributeValue ( groovyScript )  ,    is ( expected )  )  ;", "assertThat ( extractor . getAttributeValue ( xmlFile )  ,    is ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["assertGetAttributeValueForImplicitAliases"], "fileName": "org.springframework.core.annotation.AbstractAliasAwareAnnotationAttributeExtractorTestCase"}, {"methodBody": ["METHOD_START", "{", "assertGetAttributeValueForImplicitAliases ( AnnotationUtilsTests . GroovyImplicitAliasesContextConfigClass . class ,     \" groovyScript \"  )  ;", "assertGetAttributeValueForImplicitAliases ( AnnotationUtilsTests . XmlImplicitAliasesContextConfigClass . class ,     \" xmlFile \"  )  ;", "assertGetAttributeValueForImplicitAliases ( AnnotationUtilsTests . ValueImplicitAliasesContextConfigClass . class ,     \" value \"  )  ;", "assertGetAttributeValueForImplicitAliases ( AnnotationUtilsTests . Location 1 ImplicitAliasesContextConfigClass . class ,     \" location 1  \"  )  ;", "assertGetAttributeValueForImplicitAliases ( AnnotationUtilsTests . Location 2 ImplicitAliasesContextConfigClass . class ,     \" location 2  \"  )  ;", "assertGetAttributeValueForImplicitAliases ( AnnotationUtilsTests . Location 3 ImplicitAliasesContextConfigClass . class ,     \" location 3  \"  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeValueForImplicitAliases"], "fileName": "org.springframework.core.annotation.AbstractAliasAwareAnnotationAttributeExtractorTestCase"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElementUtils . MergedAnnotationAttributesProcessor   processor    =    new   AnnotatedElementUtils . MergedAnnotationAttributesProcessor ( false ,    false ,    true )  ;", "AnnotatedElementUtils . searchWithFindSemantics ( element ,    annotationType ,    null ,    processor )  ;", "return   AnnotatedElementUtils . postProcessAndSynthesizeAggregatedResults ( element ,    annotationType ,    processor . getAggregatedResults (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAllMergedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( element   instanceof   Class )  )     {", "A   annotation    =    element . getAnnotation ( annotationType )  ;", "if    ( annotation    !  =    null )     {", "return   AnnotationUtils . synthesizeAnnotation ( annotation ,    element )  ;", "}", "}", "AnnotationAttributes   attributes    =     . findMergedAnnotationAttributes ( element ,    annotationType ,    false ,    false )  ;", "return   attributes    !  =    null    ?    AnnotationUtils . synthesizeAnnotation ( attributes ,    annotationType ,    element )     :    null ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . searchWithFindSemantics ( element ,    annotationType ,    null ,    new   AnnotatedElementUtils . MergedAnnotationAttributesProcessor ( classValuesAsString ,    nestedAnnotationsAsMap )  )  ;", "AnnotationUtils . postProcessAnnotationAttributes ( element ,    attributes ,    classValuesAsString ,    nestedAnnotationsAsMap )  ;", "return   attributes ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . searchWithFindSemantics ( element ,    null ,    annotationName ,    new   AnnotatedElementUtils . MergedAnnotationAttributesProcessor ( classValuesAsString ,    nestedAnnotationsAsMap )  )  ;", "AnnotationUtils . postProcessAnnotationAttributes ( element ,    attributes ,    classValuesAsString ,    nestedAnnotationsAsMap )  ;", "return   attributes ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . findMergedRepeatableAnnotations ( element ,    annotationType ,    null )  ;", "}", "METHOD_END"], "methodName": ["findMergedRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( containerType    =  =    null )     {", "containerType    =     . resolveContainerType ( annotationType )  ;", "} else    {", ". validateContainerType ( annotationType ,    containerType )  ;", "}", ". MergedAnnotationAttributesProcessor   processor    =    new    . MergedAnnotationAttributesProcessor ( false ,    false ,    true )  ;", ". searchWithFindSemantics ( element ,    annotationType ,    null ,    containerType ,    processor )  ;", "return    . postProcessAndSynthesizeAggregatedResults ( element ,    annotationType ,    processor . getAggregatedResults (  )  )  ;", "}", "METHOD_END"], "methodName": ["findMergedRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   AnnotatedElement (  )     {", "@ Override", "@ SuppressWarnings (  \" unchecked \"  )", "@ Nullable", "public    < T   extends   Annotation >    T   getAnnotation ( Class < T >    annotationClass )     {", "for    ( Annotation   ann    :    annotations )     {", "if    (  ( ann . annotationType (  )  )     =  =    annotationClass )     {", "return    (  ( T )     ( ann )  )  ;", "}", "}", "return   null ;", "}", "@ Override", "public   Annotation [  ]    getAnnotations (  )     {", "return   annotations ;", "}", "@ Override", "public   Annotation [  ]    getDeclaredAnnotations (  )     {", "return   annotations ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["forAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . getAllAnnotationAttributes ( element ,    annotationName ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["getAllAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "final   MultiValueMap < String ,    Object >    attributesMap    =    new   LinkedMultiValueMap <  >  (  )  ;", ". searchWithGetSemantics ( element ,    null ,    annotationName ,    new    . SimpleAnnotationProcessor < Object >  (  )     {", "@ Override", "@ Nullable", "public   Object   process (  @ Nullable", "AnnotatedElement   annotatedElement ,    Annotation   annotation ,    int   metaDepth )     {", "AnnotationAttributes   annotationAttributes    =    AnnotationUtils . getAnnotationAttributes ( annotation ,    classValuesAsString ,    nestedAnnotationsAsMap )  ;", "annotationAttributes . forEach ( attributesMap :  : add )  ;", "return    . CONTINUE ;", "}", "}  )  ;", "return    !  ( attributesMap . isEmpty (  )  )     ?    attributesMap    :    null ;", "}", "METHOD_END"], "methodName": ["getAllAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElementUtils . MergedAnnotationAttributesProcessor   processor    =    new   AnnotatedElementUtils . MergedAnnotationAttributesProcessor ( false ,    false ,    true )  ;", "AnnotatedElementUtils . searchWithGetSemantics ( element ,    annotationType ,    null ,    processor )  ;", "return   AnnotatedElementUtils . postProcessAndSynthesizeAggregatedResults ( element ,    annotationType ,    processor . getAggregatedResults (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllMergedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( element   instanceof   Class )  )     {", "A   annotation    =    element . getAnnotation ( annotationType )  ;", "if    ( annotation    !  =    null )     {", "return   AnnotationUtils . synthesizeAnnotation ( annotation ,    element )  ;", "}", "}", "AnnotationAttributes   attributes    =     . getMergedAnnotationAttributes ( element ,    annotationType )  ;", "return   attributes    !  =    null    ?    AnnotationUtils . synthesizeAnnotation ( attributes ,    annotationType ,    element )     :    null ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . searchWithGetSemantics ( element ,    annotationType ,    null ,    new   AnnotatedElementUtils . MergedAnnotationAttributesProcessor (  )  )  ;", "AnnotationUtils . postProcessAnnotationAttributes ( element ,    attributes ,    false ,    false )  ;", "return   attributes ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    annotationName ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . searchWithGetSemantics ( element ,    null ,    annotationName ,    new   AnnotatedElementUtils . MergedAnnotationAttributesProcessor ( classValuesAsString ,    nestedAnnotationsAsMap )  )  ;", "AnnotationUtils . postProcessAnnotationAttributes ( element ,    attributes ,    classValuesAsString ,    nestedAnnotationsAsMap )  ;", "return   attributes ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . getMergedRepeatableAnnotations ( element ,    annotationType ,    null )  ;", "}", "METHOD_END"], "methodName": ["getMergedRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( containerType    =  =    null )     {", "containerType    =     . resolveContainerType ( annotationType )  ;", "} else    {", ". validateContainerType ( annotationType ,    containerType )  ;", "}", ". MergedAnnotationAttributesProcessor   processor    =    new    . MergedAnnotationAttributesProcessor ( false ,    false ,    true )  ;", ". searchWithGetSemantics ( element ,    annotationType ,    null ,    containerType ,    processor )  ;", "return    . postProcessAndSynthesizeAggregatedResults ( element ,    annotationType ,    processor . getAggregatedResults (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . getMetaAnnotationTypes ( element ,    element . getAnnotation ( annotationType )  )  ;", "}", "METHOD_END"], "methodName": ["getMetaAnnotationTypes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . getMetaAnnotationTypes ( element ,    AnnotationUtils . getAnnotation ( element ,    annotationName )  )  ;", "}", "METHOD_END"], "methodName": ["getMetaAnnotationTypes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( composed    =  =    null )     {", "return   Collections . emptySet (  )  ;", "}", "try    {", "final   Set < String >    types    =    new   LinkedHashSet <  >  (  )  ;", ". searchWithGetSemantics ( composed . annotationType (  )  ,    null ,    null ,    null ,    new    . SimpleAnnotationProcessor < Object >  ( true )     {", "@ Override", "@ Nullable", "public   Object   process (  @ Nullable", "AnnotatedElement   annotatedElement ,    Annotation   annotation ,    int   metaDepth )     {", "types . add ( annotation . annotationType (  )  . getName (  )  )  ;", "return    . CONTINUE ;", "}", "}  ,    new   HashSet <  >  (  )  ,     1  )  ;", "return   types ;", "}    catch    ( Throwable   ex )     {", "AnnotationUtils . rethrowAnnotationConfigurationException ( ex )  ;", "throw   new   IllegalStateException (  (  \" Failed   to   introspect   annotations   on    \"     +    element )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getMetaAnnotationTypes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "A [  ]    value    =     (  ( A [  ]  )     ( AnnotationUtils . getValue ( container )  )  )  ;", "if    ( value    !  =    null )     {", "return   value ;", "}", "}    catch    ( Throwable   ex )     {", "AnnotationUtils . handleIntrospectionFailure ( element ,    ex )  ;", "}", "return    (  ( A [  ]  )     (  . EMPTY _ ANNOTATION _ ARRAY )  )  ;", "}", "METHOD_END"], "methodName": ["getRawAnnotationsFromContainer"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( element . isAnnotationPresent ( annotationType )  )     {", "return   true ;", "}", "return   Boolean . TRUE . equals (  . searchWithFindSemantics ( element ,    annotationType ,    null ,     . alwaysTrueAnnotationProcessor )  )  ;", "}", "METHOD_END"], "methodName": ["hasAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . hasMetaAnnotationTypes ( element ,    annotationType ,    null )  ;", "}", "METHOD_END"], "methodName": ["hasMetaAnnotationTypes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . TRUE . equals ( AnnotatedElementUtils . searchWithGetSemantics ( element ,    annotationType ,    annotationName ,    new   AnnotatedElementUtils . SimpleAnnotationProcessor < Boolean >  (  )     {", "@ Override", "@ Nullable", "public   Boolean   process (  @ Nullable", "AnnotatedElement   annotatedElement ,    Annotation   annotation ,    int   metaDepth )     {", "return   metaDepth    >     0     ?    Boolean . TRUE    :    AnnotatedElementUtils . CONTINUE ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["hasMetaAnnotationTypes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . hasMetaAnnotationTypes ( element ,    null ,    annotationName )  ;", "}", "METHOD_END"], "methodName": ["hasMetaAnnotationTypes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( AnnotationUtils . isInJavaLangAnnotationPackage ( currentAnnotationType )  )     {", "return   false ;", "}", "if    (  ( currentAnnotationType    =  =     ( Nullable . class )  )     |  |     ( currentAnnotationType . getName (  )  . startsWith (  \" java \"  )  )  )     {", "return    (  ( Type    !  =    null )     &  &     ( Type . getName (  )  . startsWith (  \" java \"  )  )  )     |  |     (  ( Name    !  =    null )     &  &     ( Name . startsWith (  \" java \"  )  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["hasSearchableMetaAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( element . isAnnotationPresent ( annotationType )  )     {", "return   true ;", "}", "return   Boolean . TRUE . equals (  . searchWithGetSemantics ( element ,    annotationType ,    null ,     . alwaysTrueAnnotationProcessor )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotated"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . TRUE . equals ( AnnotatedElementUtils . searchWithGetSemantics ( element ,    null ,    annotationName ,    AnnotatedElementUtils . alwaysTrueAnnotationProcessor )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotated"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "Set < A >    annotations    =    new   LinkedHashSet <  >  (  )  ;", "for    ( AnnotationAttributes   attributes    :    aggregatedResults )     {", "AnnotationUtils . postProcessAnnotationAttributes ( element ,    attributes ,    false ,    false )  ;", "annotations . add ( AnnotationUtils . synthesizeAnnotation ( attributes ,    annotationType ,    element )  )  ;", "}", "return   annotations ;", "}", "METHOD_END"], "methodName": ["postProcessAndSynthesizeAggregatedResults"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Annotation >    containerType    =    AnnotationUtils . resolveContainerAnnotationType ( annotationType )  ;", "if    ( containerType    =  =    null )     {", "throw   new   IllegalArgumentException (  (  \" Annotation   type   must   be   a   repeatable   annotation :    failed   to   resolve   container   type   for    \"     +     ( annotationType . getName (  )  )  )  )  ;", "}", "return   containerType ;", "}", "METHOD_END"], "methodName": ["resolveContainerType"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    ifc    :    ifcs )     {", "Set < Method >    annotatedMethods    =    AnnotationUtils . getAnnotatedMethodsInBaseType ( ifc )  ;", "if    (  !  ( annotatedMethods . isEmpty (  )  )  )     {", "for    ( Method   annotatedMethod    :    annotatedMethods )     {", "if    (  ( annotatedMethod . getName (  )  . equals ( method . getName (  )  )  )     &  &     ( Arrays . equals ( annotatedMethod . getParameterTypes (  )  ,    method . getParameterTypes (  )  )  )  )     {", "T   result    =     . searchWithFindSemantics ( annotatedMethod ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["searchOnInterfaces"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( containerType    !  =    null )     &  &     (  !  ( processor . aggregates (  )  )  )  )     {", "throw   new   IllegalArgumentException (  \" Searches   for   repeatable   annotations   must   supply   an   aggregating   Processor \"  )  ;", "}", "try    {", "return    . searchWithFindSemantics ( element ,    annotationType ,    annotationName ,    containerType ,    processor ,    new   HashSet <  >  (  )  ,     0  )  ;", "}    catch    ( Throwable   ex )     {", "AnnotationUtils . rethrowAnnotationConfigurationException ( ex )  ;", "throw   new   IllegalStateException (  (  \" Failed   to   introspect   annotations   on    \"     +    element )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["searchWithFindSemantics"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( visited . add ( element )  )     {", "try    {", "Annotation [  ]    annotations    =    element . getDeclaredAnnotations (  )  ;", "if    (  ( annotations . length )     >     0  )     {", "List < T >    aggregatedResults    =     ( processor . aggregates (  )  )     ?    new   ArrayList <  >  (  )     :    null ;", "for    ( Annotation   annotation    :    annotations )     {", "Class <  ?    extends   Annotation >    currentAnnotationType    =    annotation . annotationType (  )  ;", "if    (  !  ( AnnotationUtils . isInJavaLangAnnotationPackage ( currentAnnotationType )  )  )     {", "if    (  (  ( currentAnnotationType    =  =    annotationType )     |  |     ( currentAnnotationType . getName (  )  . equals ( annotationName )  )  )     |  |     ( processor . alwaysProcesses (  )  )  )     {", "T   result    =    processor . process ( element ,    annotation ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "if    (  ( aggregatedResults    !  =    null )     &  &     ( metaDepth    =  =     0  )  )     {", "aggregatedResults . add ( result )  ;", "} else    {", "return   result ;", "}", "}", "} else", "if    ( currentAnnotationType    =  =    containerType )     {", "for    ( Annotation   contained    :     . getRawAnnotationsFromContainer ( element ,    annotation )  )     {", "T   result    =    processor . process ( element ,    contained ,    metaDepth )  ;", "if    (  ( aggregatedResults    !  =    null )     &  &     ( result    !  =    null )  )     {", "aggregatedResults . add ( result )  ;", "}", "}", "}", "}", "}", "for    ( Annotation   annotation    :    annotations )     {", "Class <  ?    extends   Annotation >    currentAnnotationType    =    annotation . annotationType (  )  ;", "if    (  . hasSearchableMetaAnnotations ( currentAnnotationType ,    annotationType ,    annotationName )  )     {", "T   result    =     . searchWithFindSemantics ( currentAnnotationType ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,     ( metaDepth    +     1  )  )  ;", "if    ( result    !  =    null )     {", "processor . postProcess ( currentAnnotationType ,    annotation ,    result )  ;", "if    (  ( aggregatedResults    !  =    null )     &  &     ( metaDepth    =  =     0  )  )     {", "aggregatedResults . add ( result )  ;", "} else    {", "return   result ;", "}", "}", "}", "}", "if    (  !  ( CollectionUtils . isEmpty ( aggregatedResults )  )  )     {", "processor . getAggregatedResults (  )  . addAll (  0  ,    aggregatedResults )  ;", "}", "}", "if    ( element   instanceof   Method )     {", "Method   method    =     (  ( Method )     ( element )  )  ;", "T   result ;", "Method   resolvedMethod    =    BridgeMethodResolver . findBridgedMethod ( method )  ;", "if    ( resolvedMethod    !  =    method )     {", "result    =     . searchWithFindSemantics ( resolvedMethod ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "Class <  ?  >  [  ]    ifcs    =    method . getDeclaringClass (  )  . getInterfaces (  )  ;", "if    (  ( ifcs . length )     >     0  )     {", "result    =     . searchOnInterfaces ( method ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,    metaDepth ,    ifcs )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "Class <  ?  >    clazz    =    method . getDeclaringClass (  )  ;", "while    ( true )     {", "clazz    =    clazz . getSuperclass (  )  ;", "if    (  ( clazz    =  =    null )     |  |     (  ( Object . class )     =  =    clazz )  )     {", "break ;", "}", "Set < Method >    annotatedMethods    =    AnnotationUtils . getAnnotatedMethodsInBaseType ( clazz )  ;", "if    (  !  ( annotatedMethods . isEmpty (  )  )  )     {", "for    ( Method   annotatedMethod    :    annotatedMethods )     {", "if    (  ( annotatedMethod . getName (  )  . equals ( method . getName (  )  )  )     &  &     ( Arrays . equals ( annotatedMethod . getParameterTypes (  )  ,    method . getParameterTypes (  )  )  )  )     {", "Method   resolvedSuperMethod    =    BridgeMethodResolver . findBridgedMethod ( annotatedMethod )  ;", "result    =     . searchWithFindSemantics ( resolvedSuperMethod ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "}", "}", "result    =     . searchOnInterfaces ( method ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,    metaDepth ,    clazz . getInterfaces (  )  )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "} else", "if    ( element   instanceof   Class )     {", "Class <  ?  >    clazz    =     (  ( Class <  ?  >  )     ( element )  )  ;", "for    ( Class <  ?  >    ifc    :    clazz . getInterfaces (  )  )     {", "T   result    =     . searchWithFindSemantics ( ifc ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "Class <  ?  >    superclass    =    clazz . getSuperclass (  )  ;", "if    (  ( superclass    !  =    null )     &  &     (  ( Object . class )     !  =    superclass )  )     {", "T   result    =     . searchWithFindSemantics ( superclass ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "}", "}    catch    ( Throwable   ex )     {", "AnnotationUtils . handleIntrospectionFailure ( element ,    ex )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["searchWithFindSemantics"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . searchWithFindSemantics ( element ,    annotationType ,    annotationName ,    null ,    processor )  ;", "}", "METHOD_END"], "methodName": ["searchWithFindSemantics"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . searchWithGetSemantics ( element ,    annotationType ,    annotationName ,    containerType ,    processor ,    new   HashSet <  >  (  )  ,     0  )  ;", "}    catch    ( Throwable   ex )     {", "AnnotationUtils . rethrowAnnotationConfigurationException ( ex )  ;", "throw   new   IllegalStateException (  (  \" Failed   to   introspect   annotations   on    \"     +    element )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["searchWithGetSemantics"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( visited . add ( element )  )     {", "try    {", "List < Annotation >    declaredAnnotations    =    Arrays . asList ( element . getDeclaredAnnotations (  )  )  ;", "T   result    =     . searchWithGetSemanticsInAnnotations ( element ,    declaredAnnotations ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "if    ( element   instanceof   Class )     {", "List < Annotation >    inheritedAnnotations    =    new   ArrayList <  >  (  )  ;", "for    ( Annotation   annotation    :    element . getAnnotations (  )  )     {", "if    (  !  ( declaredAnnotations . contains ( annotation )  )  )     {", "inheritedAnnotations . add ( annotation )  ;", "}", "}", "result    =     . searchWithGetSemanticsInAnnotations ( element ,    inheritedAnnotations ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "}    catch    ( Throwable   ex )     {", "AnnotationUtils . handleIntrospectionFailure ( element ,    ex )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["searchWithGetSemantics"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . searchWithGetSemantics ( element ,    annotationType ,    annotationName ,    null ,    processor )  ;", "}", "METHOD_END"], "methodName": ["searchWithGetSemantics"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Annotation   annotation    :    annotations )     {", "Class <  ?    extends   Annotation >    currentAnnotationType    =    annotation . annotationType (  )  ;", "if    (  !  ( AnnotationUtils . isInJavaLangAnnotationPackage ( currentAnnotationType )  )  )     {", "if    (  (  ( currentAnnotationType    =  =    annotationType )     |  |     ( currentAnnotationType . getName (  )  . equals ( annotationName )  )  )     |  |     ( processor . alwaysProcesses (  )  )  )     {", "T   result    =    processor . process ( element ,    annotation ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "if    (  ( processor . aggregates (  )  )     &  &     ( metaDepth    =  =     0  )  )     {", "processor . getAggregatedResults (  )  . add ( result )  ;", "} else    {", "return   result ;", "}", "}", "} else", "if    ( currentAnnotationType    =  =    containerType )     {", "for    ( Annotation   contained    :     . getRawAnnotationsFromContainer ( element ,    annotation )  )     {", "T   result    =    processor . process ( element ,    contained ,    metaDepth )  ;", "if    ( result    !  =    null )     {", "processor . getAggregatedResults (  )  . add ( result )  ;", "}", "}", "}", "}", "}", "for    ( Annotation   annotation    :    annotations )     {", "Class <  ?    extends   Annotation >    currentAnnotationType    =    annotation . annotationType (  )  ;", "if    (  . hasSearchableMetaAnnotations ( currentAnnotationType ,    annotationType ,    annotationName )  )     {", "T   result    =     . searchWithGetSemantics ( currentAnnotationType ,    annotationType ,    annotationName ,    containerType ,    processor ,    visited ,     ( metaDepth    +     1  )  )  ;", "if    ( result    !  =    null )     {", "processor . postProcess ( element ,    annotation ,    result )  ;", "if    (  ( processor . aggregates (  )  )     &  &     ( metaDepth    =  =     0  )  )     {", "processor . getAggregatedResults (  )  . add ( result )  ;", "} else    {", "return   result ;", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["searchWithGetSemanticsInAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "Method   method    =    containerType . getDeclaredMethod ( AnnotationUtils . VALUE )  ;", "Class <  ?  >    returnType    =    method . getReturnType (  )  ;", "if    (  (  !  ( returnType . isArray (  )  )  )     |  |     (  ( returnType . getComponentType (  )  )     !  =    Type )  )     {", "String   msg    =    String . format (  \" Container   type    [  % s ]    must   declare   a    ' value '    attribute   for   an   array   of   type    [  % s ]  \"  ,    containerType . getName (  )  ,    Type . getName (  )  )  ;", "throw   new   AnnotationConfigurationException ( msg )  ;", "}", "}    catch    ( Throwable   ex )     {", "AnnotationUtils . rethrowAnnotationConfigurationException ( ex )  ;", "String   msg    =    String . format (  \" Invalid   declaration   of   container   type    [  % s ]    for   repeatable       [  % s ]  \"  ,    containerType . getName (  )  ,    Type . getName (  )  )  ;", "throw   new   AnnotationConfigurationException ( msg ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["validateContainerType"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( element ,    AnnotatedElementUtilsTests . ComponentScan . class )  ;", "assertNotNull (  (  \" Should   find    @ ComponentScan   on    \"     +    element )  ,    attributes )  ;", "assertArrayEquals (  \" value :     \"  ,    expected ,    attributes . getStringArray (  \" value \"  )  )  ;", "assertArrayEquals (  \" basePackages :     \"  ,    expected ,    attributes . getStringArray (  \" basePackages \"  )  )  ;", "return   attributes ;", "}", "METHOD_END"], "methodName": ["assertComponentScanAttributes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =    AnnotatedElementUtilsTests . ContextConfig . class . getName (  )  ;", "AnnotatedElementUtilsTests . ContextConfig   contextConfig    =    AnnotatedElementUtils . getMergedAnnotation ( element ,    AnnotatedElementUtilsTests . ContextConfig . class )  ;", "assertNotNull (  (  \" Should   find    @ ContextConfig   on    \"     +     ( element . getSimpleName (  )  )  )  ,    contextConfig )  ;", "assertArrayEquals (  \" locations \"  ,    expected ,    contextConfig . locations (  )  )  ;", "assertArrayEquals (  \" value \"  ,    expected ,    contextConfig . value (  )  )  ;", "assertArrayEquals (  \" classes \"  ,    new   Class <  ?  >  [  0  ]  ,    contextConfig . classes (  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["assertGetMergedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . WebMapping   webMapping    =    AnnotatedElementUtils . findMergedAnnotation ( element ,    AnnotationUtilsTests . WebMapping . class )  ;", "assertNotNull ( webMapping )  ;", "assertArrayEquals (  \" value   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    webMapping . value (  )  )  ;", "assertArrayEquals (  \" path   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    webMapping . path (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertWebMapping"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotatedElementUtilsTests . TransactionalServiceImpl . class . getMethod (  \" doIt \"  )  ;", "Set < AnnotatedElementUtilsTests . Transactional >    allMergedAnnotations    =    AnnotatedElementUtils . findAllMergedAnnotations ( m ,    AnnotatedElementUtilsTests . Transactional . class )  ;", "assertEquals (  1  ,    allMergedAnnotations . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAllMergedAnnotationsOnClassWithInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   qualifier    =     \" aliasForQualifier \"  ;", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes (  . AliasedTransactionalComponentClass . class ,     . AliasedTransactional . class )  ;", "assertNotNull (  \"  @ AliasedTransactional   on   AliasedTransactionalComponentClass .  \"  ,    attributes )  ;", ". AliasedTransactional   annotation    =    AnnotationUtils . synthesizeAnnotation ( attributes ,     . AliasedTransactional . class ,     . AliasedTransactionalComponentClass . class )  ;", "assertNotNull ( annotation )  ;", "assertEquals (  \" TX   value   via   attributes .  \"  ,    qualifier ,    attributes . getString (  \" value \"  )  )  ;", "assertEquals (  \" TX   value   via   synthesized   annotation .  \"  ,    qualifier ,    annotation . value (  )  )  ;", "assertEquals (  \" TX   qualifier   via   attributes .  \"  ,    qualifier ,    attributes . getString (  \" qualifier \"  )  )  ;", "assertEquals (  \" TX   qualifier   via   synthesized   annotation .  \"  ,    qualifier ,    annotation . qualifier (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( annotationType ,     \" annotationType   must   not   be   null \"  )  ;", "return    . findMergedAnnotationAttributes ( element ,    annotationType . getName (  )  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    AnnotatedElementUtilsTests . StringGenericParameter . class . getMethods (  )  ;", "Method   bridgeMethod    =    null ;", "Method   bridgedMethod    =    null ;", "for    ( Method   method    :    methods )     {", "if    (  (  \" getFor \"  . equals ( method . getName (  )  )  )     &  &     (  !  ( method . getParameterTypes (  )  [  0  ]  . equals ( Integer . class )  )  )  )     {", "if    ( method . getReturnType (  )  . equals ( Object . class )  )     {", "bridgeMethod    =    method ;", "} else    {", "bridgedMethod    =    method ;", "}", "}", "}", "assertTrue (  (  ( bridgeMethod    !  =    null )     &  &     ( bridgeMethod . isBridge (  )  )  )  )  ;", "assertTrue (  (  ( bridgedMethod    !  =    null )     &  &     (  !  ( bridgedMethod . isBridge (  )  )  )  )  )  ;", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( bridgeMethod ,    Order . class )  ;", "assertNotNull (  \" Should   find    @ Order   on   StringGenericParameter . getFor (  )    bridge   method \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesFromBridgeMethod"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotatedElementUtilsTests . ConcreteClassWithInheritedAnnotation . class . getMethod (  \" handle \"  )  ;", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( method ,    AnnotatedElementUtilsTests . Transactional . class )  ;", "assertNotNull (  \" Should   find    @ Transactional   on   ConcreteClassWithInheritedAnnotation . handle (  )    method \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesInheritedFromAbstractMethod"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotatedElementUtilsTests . ConcreteClassWithInheritedAnnotation . class . getMethod (  \" handleParameterized \"  ,    String . class )  ;", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( method ,    AnnotatedElementUtilsTests . Transactional . class )  ;", "assertNull (  \" Should   not   find    @ Transactional   on   bridged   ConcreteClassWithInheritedAnnotation . handleParameterized (  )  \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesInheritedFromBridgedMethod"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotatedElementUtilsTests . ConcreteClassWithInheritedAnnotation . class . getMethod (  \" handleFromInterface \"  )  ;", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( method ,    Order . class )  ;", "assertNotNull (  \" Should   find    @ Order   on   ConcreteClassWithInheritedAnnotation . handleFromInterface (  )    method \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesInheritedFromInterfaceMethod"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    assertComponentScanAttributes ( AnnotatedElementUtilsTests . TestComponentScanClass . class ,     \" com . example . app . test \"  )  ;", "AnnotatedElementUtilsTests . Filter [  ]    excludeFilters    =    attributes . getAnnotationArray (  \" excludeFilters \"  ,    AnnotatedElementUtilsTests . Filter . class )  ;", "assertNotNull ( excludeFilters )  ;", "List < String >    patterns    =    Arrays . stream ( excludeFilters )  . map ( AnnotatedElementUtilsTests . Filter :  : pattern )  . collect ( Collectors . toList (  )  )  ;", "assertEquals ( Arrays . asList (  \"  * Test \"  ,     \"  * Tests \"  )  ,    patterns )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertComponentScanAttributes ( AnnotatedElementUtilsTests . ComponentScanWithBasePackagesAndValueAliasClass . class ,     \" com . example . app . test \"  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( AnnotatedElementUtilsTests . MetaAndLocalTxConfigClass . class ,    AnnotatedElementUtilsTests . Transactional . class )  ;", "assertNotNull (  \" Should   find    @ Transactional   on   MetaAndLocalTxConfigClass \"  ,    attributes )  ;", "assertEquals (  \" TX   qualifier   for   MetaAndLocalTxConfigClass .  \"  ,     \" localTxMgr \"  ,    attributes . getString (  \" qualifier \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( AnnotatedElementUtilsTests . InheritedAnnotationInterface . class ,    AnnotatedElementUtilsTests . Transactional . class )  ;", "assertNotNull (  \" Should   find    @ Transactional   on   InheritedAnnotationInterface \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesOnInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( AnnotatedElementUtilsTests . NonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull (  \" Should   find    @ Order   on   NonInheritedAnnotationInterface \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesOnNonInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( AnnotatedElementUtilsTests . SubInheritedAnnotationInterface . class ,    AnnotatedElementUtilsTests . Transactional . class )  ;", "assertNotNull (  \" Should   find    @ Transactional   on   SubInheritedAnnotationInterface \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesOnSubInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( AnnotatedElementUtilsTests . SubNonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull (  \" Should   find    @ Order   on   SubNonInheritedAnnotationInterface \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( AnnotatedElementUtilsTests . SubSubInheritedAnnotationInterface . class ,    AnnotatedElementUtilsTests . Transactional . class )  ;", "assertNotNull (  \" Should   find    @ Transactional   on   SubSubInheritedAnnotationInterface \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    findMergedAnnotationAttributes ( AnnotatedElementUtilsTests . SubSubNonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull (  \" Should   find    @ Order   on   SubSubNonInheritedAnnotationInterface \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertComponentScanAttributes ( AnnotatedElementUtilsTests . AliasForBasedSinglePackageComponentScanClass . class ,     \" com . example . app . test \"  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertComponentScanAttributes ( AnnotatedElementUtilsTests . ConventionBasedSinglePackageComponentScanClass . class ,     \" com . example . app . test \"  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaConvention"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    xmlLocations    =    AnnotationUtilsTests . asArray (  \" test . xml \"  )  ;", "String [  ]    propFiles    =    AnnotationUtilsTests . asArray (  \" test . properties \"  )  ;", "Class <  ?  >    element    =     . AliasedComposedContextConfigAndTestPropSourceClass . class ;", ". ContextConfig   contextConfig    =    AnnotatedElementUtils . findMergedAnnotation ( element ,     . ContextConfig . class )  ;", "assertNotNull (  (  \"  @ ContextConfig   on    \"     +    element )  ,    contextConfig )  ;", "assertArrayEquals (  \" locations \"  ,    xmlLocations ,    contextConfig . locations (  )  )  ;", "assertArrayEquals (  \" value \"  ,    xmlLocations ,    contextConfig . value (  )  )  ;", ". TestPropSource   testPropSource    =    AnnotationUtils . findAnnotation ( element ,     . TestPropSource . class )  ;", "assertArrayEquals (  \" locations \"  ,    propFiles ,    testPropSource . locations (  )  )  ;", "assertArrayEquals (  \" value \"  ,    propFiles ,    testPropSource . value (  )  )  ;", "testPropSource    =    AnnotatedElementUtils . findMergedAnnotation ( element ,     . TestPropSource . class )  ;", "assertNotNull (  (  \"  @ TestPropSource   on    \"     +    element )  ,    testPropSource )  ;", "assertArrayEquals (  \" locations \"  ,    propFiles ,    testPropSource . locations (  )  )  ;", "assertArrayEquals (  \" value \"  ,    propFiles ,    testPropSource . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . AliasedTransactionalComponentClass . class ;", "AnnotatedElementUtilsTests . AliasedTransactional   annotation    =    AnnotatedElementUtils . findMergedAnnotation ( element ,    AnnotatedElementUtilsTests . AliasedTransactional . class )  ;", "assertNotNull (  (  \"  @ AliasedTransactional   on    \"     +    element )  ,    annotation )  ;", "assertEquals (  \" TX   value   via   synthesized   annotation .  \"  ,     \" aliasForQualifier \"  ,    annotation . value (  )  )  ;", "assertEquals (  \" TX   qualifier   via   synthesized   annotation .  \"  ,     \" aliasForQualifier \"  ,    annotation . qualifier (  )  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationWithAttributeAliasesInTargetAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    EMPTY    =    new   String [  0  ]  ;", "Class <  ?  >    element    =     . SpringAppConfigClass . class ;", ". ContextConfig   contextConfig    =    AnnotatedElementUtils . findMergedAnnotation ( element ,     . ContextConfig . class )  ;", "assertNotNull (  (  \" Should   find    @ ContextConfig   on    \"     +    element )  ,    contextConfig )  ;", "assertArrayEquals (  (  \" locations   for    \"     +    element )  ,    EMPTY ,    contextConfig . locations (  )  )  ;", "assertArrayEquals (  (  \" value   for    \"     +    element )  ,    EMPTY ,    contextConfig . value (  )  )  ;", "assertArrayEquals (  (  \" classes   for    \"     +    element )  ,    new   Class <  ?  >  [  ]  {    Number . class    }  ,    contextConfig . classes (  )  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertWebMapping ( AnnotationUtilsTests . WebController . class . getMethod (  \" getMappedWithValueAttribute \"  )  )  ;", "assertWebMapping ( AnnotationUtilsTests . WebController . class . getMethod (  \" getMappedWithPathAttribute \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertWebMapping ( AnnotationUtilsTests . WebController . class . getMethod (  \" postMappedWithPathAttribute \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findMergedAnnotationWithSingleElementOverridingAnArrayViaConvention"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    attributes    =    AnnotatedElementUtils . getAllAnnotationAttributes ( AnnotatedElementUtilsTests . SubSubClassWithInheritedAnnotation . class ,    AnnotatedElementUtilsTests . TX _ NAME )  ;", "assertNotNull (  \" Annotation   attributes   map   for    @ Transactional   on   SubSubClassWithInheritedAnnotation \"  ,    attributes )  ;", "assertEquals ( Arrays . asList (  \" transactionManager \"  )  ,    attributes . get (  \" qualifier \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    attributes    =    AnnotatedElementUtils . getAllAnnotationAttributes ( AnnotatedElementUtilsTests . SubSubClassWithInheritedComposedAnnotation . class ,    AnnotatedElementUtilsTests . TX _ NAME )  ;", "assertNotNull (  \" Annotation   attributes   map   for    @ Transactional   on   SubSubClassWithInheritedComposedAnnotation \"  ,    attributes )  ;", "assertEquals ( Arrays . asList (  \" composed 1  \"  )  ,    attributes . get (  \" qualifier \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    attributes    =    AnnotatedElementUtils . getAllAnnotationAttributes ( AnnotatedElementUtilsTests . TxConfig . class ,    AnnotatedElementUtilsTests . TX _ NAME )  ;", "assertNotNull (  \" Annotation   attributes   map   for    @ Transactional   on   TxConfig \"  ,    attributes )  ;", "assertEquals (  \" value   for   TxConfig .  \"  ,    Arrays . asList (  \" TxConfig \"  )  ,    attributes . get (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllAnnotationAttributesOnClassWithLocalAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    attributes    =    AnnotatedElementUtils . getAllAnnotationAttributes ( AnnotatedElementUtilsTests . DerivedTxConfig . class ,    AnnotatedElementUtilsTests . TX _ NAME )  ;", "assertNotNull (  \" Annotation   attributes   map   for    @ Transactional   on   DerivedTxConfig \"  ,    attributes )  ;", "assertEquals (  \" value   for   DerivedTxConfig .  \"  ,    Arrays . asList (  \" DerivedTxConfig \"  )  ,    attributes . get (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    attributes    =    AnnotatedElementUtils . getAllAnnotationAttributes ( AnnotatedElementUtilsTests . SubClassWithInheritedAnnotation . class ,    AnnotatedElementUtilsTests . TX _ NAME )  ;", "assertNotNull (  \" Annotation   attributes   map   for    @ Transactional   on   SubClassWithInheritedAnnotation \"  ,    attributes )  ;", "assertEquals ( Arrays . asList (  \" composed 2  \"  ,     \" transactionManager \"  )  ,    attributes . get (  \" qualifier \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    Object >    attributes    =    AnnotatedElementUtils . getAllAnnotationAttributes ( AnnotatedElementUtilsTests . TxFromMultipleComposedAnnotations . class ,    AnnotatedElementUtilsTests . TX _ NAME )  ;", "assertNotNull (  \" Annotation   attributes   map   for    @ Transactional   on   TxFromMultipleComposedAnnotations \"  ,    attributes )  ;", "assertEquals (  \" value   for   TxFromMultipleComposedAnnotations .  \"  ,    Arrays . asList (  \" TxInheritedComposed \"  ,     \" TxComposed \"  )  ,    attributes . get (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( AnnotatedElementUtils . getAllAnnotationAttributes ( AnnotatedElementUtilsTests . NonAnnotatedClass . class ,    AnnotatedElementUtilsTests . TX _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["getAllAnnotationAttributesOnNonAnnotatedClass"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotatedElementUtilsTests . TransactionalServiceImpl . class . getMethod (  \" doIt \"  )  ;", "Set < AnnotatedElementUtilsTests . Transactional >    allMergedAnnotations    =    AnnotatedElementUtils . getAllMergedAnnotations ( m ,    AnnotatedElementUtilsTests . Transactional . class )  ;", "assertTrue ( allMergedAnnotations . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllMergedAnnotationsOnClassWithInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . SubSubClassWithInheritedAnnotation . class ;", "String   name    =    AnnotatedElementUtilsTests . TX _ NAME ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  \" AnnotationAttributes   for    @ Transactional   on   SubSubClassWithInheritedAnnotation \"  ,    attributes )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "assertFalse (  \" readOnly   flag   for   SubSubClassWithInheritedAnnotation .  \"  ,    attributes . getBoolean (  \" readOnly \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . SubSubClassWithInheritedComposedAnnotation . class ;", "String   name    =    AnnotatedElementUtilsTests . TX _ NAME ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  \" AnnotationAttributtes   for    @ Transactional   on   SubSubClassWithInheritedComposedAnnotation .  \"  ,    attributes )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "assertFalse (  \" readOnly   flag   for   SubSubClassWithInheritedComposedAnnotation .  \"  ,    attributes . getBoolean (  \" readOnly \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . SubClassWithInheritedAnnotation . class ;", "String   name    =    AnnotatedElementUtilsTests . TX _ NAME ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  \" AnnotationAttributes   for    @ Transactional   on   SubClassWithInheritedAnnotation \"  ,    attributes )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "assertTrue (  \" readOnly   flag   for   SubClassWithInheritedAnnotation .  \"  ,    attributes . getBoolean (  \" readOnly \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . ConcreteClassWithInheritedAnnotation . class ;", "String   name    =    AnnotatedElementUtilsTests . TX _ NAME ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNull (  \" Should   not   find    @ Transactional   on   ConcreteClassWithInheritedAnnotation \"  ,    attributes )  ;", "assertFalse ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . TxConfig . class ;", "String   name    =    AnnotatedElementUtilsTests . TX _ NAME ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  \" Annotation   attributes   for    @ Transactional   on   TxConfig \"  ,    attributes )  ;", "assertEquals (  \" value   for   TxConfig .  \"  ,     \" TxConfig \"  ,    attributes . getString (  \" value \"  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesOnClassWithLocalAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . DerivedTxConfig . class ;", "String   name    =    AnnotatedElementUtilsTests . TX _ NAME ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  \" Annotation   attributes   for    @ Transactional   on   DerivedTxConfig \"  ,    attributes )  ;", "assertEquals (  \" value   for   DerivedTxConfig .  \"  ,     \" DerivedTxConfig \"  ,    attributes . getString (  \" value \"  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . InheritedAnnotationInterface . class ;", "String   name    =    AnnotatedElementUtilsTests . TX _ NAME ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  \" Should   find    @ Transactional   on   InheritedAnnotationInterface \"  ,    attributes )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesOnInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( AnnotatedElementUtilsTests . MetaCycleAnnotatedClass . class ,    AnnotatedElementUtilsTests . TX _ NAME )  ;", "assertNull (  \" Should   not   find   annotation   attributes   for    @ Transactional   on   MetaCycleAnnotatedClass \"  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . NonInheritedAnnotationInterface . class ;", "String   name    =    Order . class . getName (  )  ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  \" Should   find    @ Order   on   NonInheritedAnnotationInterface \"  ,    attributes )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesOnNonInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . AliasedComposedContextConfigClass . class ;", "String   name    =    AnnotatedElementUtilsTests . ContextConfig . class . getName (  )  ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  (  \" Should   find    @ ContextConfig   on    \"     +     ( element . getSimpleName (  )  )  )  ,    attributes )  ;", "assertArrayEquals (  \" value \"  ,    AnnotationUtilsTests . asArray (  \" test . xml \"  )  ,    attributes . getStringArray (  \" value \"  )  )  ;", "assertArrayEquals (  \" locations \"  ,    AnnotationUtilsTests . asArray (  \" test . xml \"  )  ,    attributes . getStringArray (  \" locations \"  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesWithAliasedComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . AliasedValueComposedContextConfigClass . class ;", "String   name    =    AnnotatedElementUtilsTests . ContextConfig . class . getName (  )  ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  (  \" Should   find    @ ContextConfig   on    \"     +     ( element . getSimpleName (  )  )  )  ,    attributes )  ;", "assertArrayEquals (  \" locations \"  ,    AnnotationUtilsTests . asArray (  \" test . xml \"  )  ,    attributes . getStringArray (  \" locations \"  )  )  ;", "assertArrayEquals (  \" value \"  ,    AnnotationUtilsTests . asArray (  \" test . xml \"  )  ,    attributes . getStringArray (  \" value \"  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesWithAliasedValueComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . ConventionBasedComposedContextConfigClass . class ;", "String   name    =    AnnotatedElementUtilsTests . ContextConfig . class . getName (  )  ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "assertNotNull (  (  \" Should   find    @ ContextConfig   on    \"     +     ( element . getSimpleName (  )  )  )  ,    attributes )  ;", "assertArrayEquals (  \" locations \"  ,    AnnotationUtilsTests . asArray (  \" explicitDeclaration \"  )  ,    attributes . getStringArray (  \" locations \"  )  )  ;", "assertArrayEquals (  \" value \"  ,    AnnotationUtilsTests . asArray (  \" explicitDeclaration \"  )  ,    attributes . getStringArray (  \" value \"  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesWithConventionBasedComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    clazz    :    Arrays . asList ( AnnotatedElementUtilsTests . HalfConventionBasedAndHalfAliasedComposedContextConfigClassV 1  . class ,    AnnotatedElementUtilsTests . HalfConventionBasedAndHalfAliasedComposedContextConfigClassV 2  . class )  )     {", "getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation ( clazz )  ;", "}", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    expected    =    AnnotationUtilsTests . asArray (  \" explicitDeclaration \"  )  ;", "String   name    =     . ContextConfig . class . getName (  )  ;", "String   simpleName    =    clazz . getSimpleName (  )  ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( clazz ,    name )  ;", "assertNotNull (  (  \" Should   find    @ ContextConfig   on    \"     +    simpleName )  ,    attributes )  ;", "assertArrayEquals (  (  (  \" locations   for   class    [  \"     +     ( clazz . getSimpleName (  )  )  )     +     \"  ]  \"  )  ,    expected ,    attributes . getStringArray (  \" locations \"  )  )  ;", "assertArrayEquals (  (  (  \" value   for   class    [  \"     +     ( clazz . getSimpleName (  )  )  )     +     \"  ]  \"  )  ,    expected ,    attributes . getStringArray (  \" value \"  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( clazz ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . ComposedImplicitAliasesContextConfigClass . class ;", "String   name    =    AnnotatedElementUtilsTests . ImplicitAliasesContextConfig . class . getName (  )  ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    name )  ;", "String [  ]    expected    =    AnnotationUtilsTests . asArray (  \" A . xml \"  ,     \" B . xml \"  )  ;", "assertNotNull (  (  \" Should   find    @ ImplicitAliasesContextConfig   on    \"     +     ( element . getSimpleName (  )  )  )  ,    attributes )  ;", "assertArrayEquals (  \" groovyScripts \"  ,    expected ,    attributes . getStringArray (  \" groovyScripts \"  )  )  ;", "assertArrayEquals (  \" xmlFiles \"  ,    expected ,    attributes . getStringArray (  \" xmlFiles \"  )  )  ;", "assertArrayEquals (  \" locations \"  ,    expected ,    attributes . getStringArray (  \" locations \"  )  )  ;", "assertArrayEquals (  \" value \"  ,    expected ,    attributes . getStringArray (  \" value \"  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . InvalidConventionBasedComposedContextConfigClass . class ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( either ( containsString (  \" attribute    ' value '    and   its   alias    ' locations '  \"  )  )  . or ( containsString (  \" attribute    ' locations '    and   its   alias    ' value '  \"  )  )  )  ;", "exception . expectMessage ( either ( containsString (  \" values   of    [  { duplicateDeclaration }  ]    and    [  { requiredLocationsDeclaration }  ]  \"  )  )  . or ( containsString (  \" values   of    [  { requiredLocationsDeclaration }  ]    and    [  { duplicateDeclaration }  ]  \"  )  )  )  ;", "exception . expectMessage ( containsString (  \" but   only   one   is   permitted \"  )  )  ;", "AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    AnnotatedElementUtilsTests . ContextConfig . class )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesWithInvalidConventionBasedComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . ShadowedAliasComposedContextConfigClass . class ;", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( element ,    AnnotatedElementUtilsTests . ContextConfig . class )  ;", "String [  ]    expected    =    AnnotationUtilsTests . asArray (  \" test . xml \"  )  ;", "assertNotNull (  (  \" Should   find    @ ContextConfig   on    \"     +     ( element . getSimpleName (  )  )  )  ,    attributes )  ;", "assertArrayEquals (  \" locations \"  ,    expected ,    attributes . getStringArray (  \" locations \"  )  )  ;", "assertArrayEquals (  \" value \"  ,    expected ,    attributes . getStringArray (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetMergedAnnotation ( AnnotatedElementUtilsTests . AliasedValueComposedContextConfigClass . class ,     \" test . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationWithAliasedValueComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetMergedAnnotation ( AnnotatedElementUtilsTests . ImplicitAliasesContextConfigClass 1  . class ,     \" foo . xml \"  )  ;", "assertGetMergedAnnotation ( AnnotatedElementUtilsTests . ImplicitAliasesContextConfigClass 2  . class ,     \" bar . xml \"  )  ;", "assertGetMergedAnnotation ( AnnotatedElementUtilsTests . ImplicitAliasesContextConfigClass 3  . class ,     \" baz . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    AnnotatedElementUtilsTests . ComposedImplicitAliasesContextConfigClass . class ;", "String   name    =    AnnotatedElementUtilsTests . ImplicitAliasesContextConfig . class . getName (  )  ;", "AnnotatedElementUtilsTests . ImplicitAliasesContextConfig   config    =    AnnotatedElementUtils . getMergedAnnotation ( element ,    AnnotatedElementUtilsTests . ImplicitAliasesContextConfig . class )  ;", "String [  ]    expected    =    AnnotationUtilsTests . asArray (  \" A . xml \"  ,     \" B . xml \"  )  ;", "assertNotNull (  (  \" Should   find    @ ImplicitAliasesContextConfig   on    \"     +     ( element . getSimpleName (  )  )  )  ,    config )  ;", "assertArrayEquals (  \" groovyScripts \"  ,    expected ,    config . groovyScripts (  )  )  ;", "assertArrayEquals (  \" xmlFiles \"  ,    expected ,    config . xmlFiles (  )  )  ;", "assertArrayEquals (  \" locations \"  ,    expected ,    config . locations (  )  )  ;", "assertArrayEquals (  \" value \"  ,    expected ,    config . value (  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( element ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetMergedAnnotation ( AnnotatedElementUtilsTests . TransitiveImplicitAliasesContextConfigClass . class ,     \" test . groovy \"  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationWithTransitiveImplicitAliases"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetMergedAnnotation ( AnnotatedElementUtilsTests . SingleLocationTransitiveImplicitAliasesContextConfigClass . class ,     \" test . groovy \"  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetMergedAnnotation ( AnnotatedElementUtilsTests . TransitiveImplicitAliasesWithSkippedLevelContextConfigClass . class ,     \" test . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetMergedAnnotation ( AnnotatedElementUtilsTests . SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass . class ,     \" test . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    names    =    AnnotatedElementUtils . getMetaAnnotationTypes ( AnnotatedElementUtilsTests . TransactionalComponentClass . class ,    AnnotatedElementUtilsTests . TransactionalComponent . class )  ;", "assertEquals ( names ( AnnotatedElementUtilsTests . Transactional . class ,    Component . class ,    Indexed . class )  ,    names )  ;", "names    =    AnnotatedElementUtils . getMetaAnnotationTypes ( AnnotatedElementUtilsTests . TransactionalComponentClass . class ,    AnnotatedElementUtilsTests . TransactionalComponent . class . getName (  )  )  ;", "assertEquals ( names ( AnnotatedElementUtilsTests . Transactional . class ,    Component . class ,    Indexed . class )  ,    names )  ;", "}", "METHOD_END"], "methodName": ["getMetaAnnotationTypesOnClassWithMetaDepth1"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    names    =    AnnotatedElementUtils . getMetaAnnotationTypes ( AnnotatedElementUtilsTests . ComposedTransactionalComponentClass . class ,    AnnotatedElementUtilsTests . ComposedTransactionalComponent . class )  ;", "assertEquals ( names ( AnnotatedElementUtilsTests . TransactionalComponent . class ,    AnnotatedElementUtilsTests . Transactional . class ,    Component . class ,    Indexed . class )  ,    names )  ;", "names    =    AnnotatedElementUtils . getMetaAnnotationTypes ( AnnotatedElementUtilsTests . ComposedTransactionalComponentClass . class ,    AnnotatedElementUtilsTests . ComposedTransactionalComponent . class . getName (  )  )  ;", "assertEquals ( names ( AnnotatedElementUtilsTests . TransactionalComponent . class ,    AnnotatedElementUtilsTests . Transactional . class ,    Component . class ,    Indexed . class )  ,    names )  ;", "}", "METHOD_END"], "methodName": ["getMetaAnnotationTypesOnClassWithMetaDepth2"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AnnotatedElementUtils . getMetaAnnotationTypes ( AnnotatedElementUtilsTests . NonAnnotatedClass . class ,    AnnotatedElementUtilsTests . TransactionalComponent . class )  . isEmpty (  )  )  ;", "assertTrue ( AnnotatedElementUtils . getMetaAnnotationTypes ( AnnotatedElementUtilsTests . NonAnnotatedClass . class ,    AnnotatedElementUtilsTests . TransactionalComponent . class . getName (  )  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMetaAnnotationTypesOnNonAnnotatedClass"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( AnnotatedElementUtils . hasMetaAnnotationTypes ( AnnotatedElementUtilsTests . TransactionalComponentClass . class ,    AnnotatedElementUtilsTests . TransactionalComponent . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasMetaAnnotationTypesOnClassWithMetaDepth0"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AnnotatedElementUtils . hasMetaAnnotationTypes ( AnnotatedElementUtilsTests . TransactionalComponentClass . class ,    AnnotatedElementUtilsTests . TX _ NAME )  )  ;", "assertTrue ( AnnotatedElementUtils . hasMetaAnnotationTypes ( AnnotatedElementUtilsTests . TransactionalComponentClass . class ,    Component . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasMetaAnnotationTypesOnClassWithMetaDepth1"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AnnotatedElementUtils . hasMetaAnnotationTypes ( AnnotatedElementUtilsTests . ComposedTransactionalComponentClass . class ,    AnnotatedElementUtilsTests . TX _ NAME )  )  ;", "assertTrue ( AnnotatedElementUtils . hasMetaAnnotationTypes ( AnnotatedElementUtilsTests . ComposedTransactionalComponentClass . class ,    Component . class . getName (  )  )  )  ;", "assertFalse ( AnnotatedElementUtils . hasMetaAnnotationTypes ( AnnotatedElementUtilsTests . ComposedTransactionalComponentClass . class ,    AnnotatedElementUtilsTests . ComposedTransactionalComponent . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasMetaAnnotationTypesOnClassWithMetaDepth2"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( AnnotatedElementUtils . hasMetaAnnotationTypes ( AnnotatedElementUtilsTests . NonAnnotatedClass . class ,    AnnotatedElementUtilsTests . TX _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["hasMetaAnnotationTypesOnNonAnnotatedClass"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AnnotatedElementUtils . isAnnotated ( AnnotatedElementUtilsTests . TransactionalComponentClass . class ,    AnnotatedElementUtilsTests . TransactionalComponent . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotatedOnClassWithMetaDepth0"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AnnotatedElementUtils . isAnnotated ( AnnotatedElementUtilsTests . TransactionalComponentClass . class ,    AnnotatedElementUtilsTests . TX _ NAME )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( AnnotatedElementUtilsTests . TransactionalComponentClass . class ,    Component . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotatedOnClassWithMetaDepth1"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AnnotatedElementUtils . isAnnotated ( AnnotatedElementUtilsTests . ComposedTransactionalComponentClass . class ,    AnnotatedElementUtilsTests . TX _ NAME )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( AnnotatedElementUtilsTests . ComposedTransactionalComponentClass . class ,    Component . class . getName (  )  )  )  ;", "assertTrue ( AnnotatedElementUtils . isAnnotated ( AnnotatedElementUtilsTests . ComposedTransactionalComponentClass . class ,    AnnotatedElementUtilsTests . ComposedTransactionalComponent . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotatedOnClassWithMetaDepth2"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( AnnotatedElementUtils . isAnnotated ( AnnotatedElementUtilsTests . NonAnnotatedClass . class ,    AnnotatedElementUtilsTests . TX _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotatedOnNonAnnotatedClass"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" isAnnotated (  )    does   not   search   the   class   hierarchy .  \"  ,    AnnotatedElementUtils . isAnnotated ( AnnotatedElementUtilsTests . SubTransactionalComponentClass . class ,    AnnotatedElementUtilsTests . TransactionalComponent . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotatedOnSubclassWithMetaDepth0"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    deprecatedCtor    =    Date . class . getConstructor ( String . class )  ;", "assertEquals ( deprecatedCtor . getAnnotation ( Deprecated . class )  ,     . findMergedAnnotation ( deprecatedCtor ,    Deprecated . class )  )  ;", "assertEquals ( Date . class . getAnnotation ( Deprecated . class )  ,     . findMergedAnnotation ( Date . class ,    Deprecated . class )  )  ;", "}", "METHOD_END"], "methodName": ["javaLangAnnotationTypeViaFindMergedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( AnnotatedElementUtilsTests . ResourceHolder . class . getAnnotation ( Resource . class )  ,    AnnotatedElementUtils . findMergedAnnotation ( AnnotatedElementUtilsTests . ResourceHolder . class ,    Resource . class )  )  ;", "assertEquals ( AnnotatedElementUtilsTests . SpringAppConfigClass . class . getAnnotation ( Resource . class )  ,    AnnotatedElementUtils . findMergedAnnotation ( AnnotatedElementUtilsTests . SpringAppConfigClass . class ,    Resource . class )  )  ;", "}", "METHOD_END"], "methodName": ["javaxAnnotationTypeViaFindMergedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . stream ( classes )  . map ( Class :  : getName )  . collect ( Collectors . toSet (  )  )  ;", "}", "METHOD_END"], "methodName": ["names"], "fileName": "org.springframework.core.annotation.AnnotatedElementUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . annotationType ;", "}", "METHOD_END"], "methodName": ["annotationType"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attributeValue ,     (  )     -  >    String . format (  \" Attribute    '  % s '    not   found   in   attributes   for   annotation    [  % s ]  \"  ,    attributeName ,    this . displayName )  )  ;", "}", "METHOD_END"], "methodName": ["assertAttributePresence"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( expectedType . isInstance ( attributeValue )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Attribute    '  % s '    is   of   type    [  % s ]  ,    but    [  % s ]    was   expected   in   attributes   for       [  % s ]  \"  ,    attributeName ,    attributeValue . getClass (  )  . getSimpleName (  )  ,    expectedType . getSimpleName (  )  ,    this . displayName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertAttributeType"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "if    ( attributeValue   instanceof   Exception )     {", "throw   new   IllegalArgumentException ( String . format (  \" Attribute    '  % s '    for       [  % s ]    was   not   resolvable   due   to   exception    [  % s ]  \"  ,    attributeName ,    this . displayName ,    attributeValue )  ,     (  ( Exception )     ( attributeValue )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertNotException"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "if    ( map    =  =    null )     {", "return   null ;", "}", "if    ( map   instanceof    )     {", "return    (  (  )     ( map )  )  ;", "}", "return   new    ( map )  ;", "}", "METHOD_END"], "methodName": ["fromMap"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getRequiredAttribute ( attributeName ,    AnnotationAttributes . class )  ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getRequiredAttribute ( attributeName ,    annotationType )  ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getRequiredAttribute ( attributeName ,    AnnotationAttributes [  ]  . class )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationArray"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    Array . newInstance ( annotationType ,     0  )  ;", "return    (  ( A [  ]  )     ( getRequiredAttribute ( attributeName ,    array . getClass (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationArray"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "if    ( classLoader    !  =    null )     {", "try    {", "return    (  ( Class <  ?    extends   Annotation >  )     ( classLoader . loadClass ( Type )  )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getRequiredAttribute ( attributeName ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["getBoolean"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getRequiredAttribute ( attributeName ,    Class . class )  ;", "}", "METHOD_END"], "methodName": ["getClass"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getRequiredAttribute ( attributeName ,    Class [  ]  . class )  ;", "}", "METHOD_END"], "methodName": ["getClassArray"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return    (  ( E )     ( getRequiredAttribute ( attributeName ,    Enum . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["getEnum"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return    (  ( N )     ( getRequiredAttribute ( attributeName ,    Number . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["getNumber"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( attributeName ,     \"  ' attributeName '    must   not   be   null   or   empty \"  )  ;", "Object   value    =    get ( attributeName )  ;", "assertPresence ( attributeName ,    value )  ;", "assertNotException ( attributeName ,    value )  ;", "if    (  (  (  !  ( expectedType . isInstance ( value )  )  )     &  &     ( expectedType . isArray (  )  )  )     &  &     ( expectedType . getComponentType (  )  . isInstance ( value )  )  )     {", "Object   array    =    Array . newInstance ( expectedType . getComponentType (  )  ,     1  )  ;", "Array . set ( array ,     0  ,    value )  ;", "value    =    array ;", "}", "assertType ( attributeName ,    value ,    expectedType )  ;", "return    (  ( T )     ( value )  )  ;", "}", "METHOD_END"], "methodName": ["getRequiredAttribute"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getRequiredAttribute ( attributeName ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["getString"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "return   getRequiredAttribute ( attributeName ,    String [  ]  . class )  ;", "}", "METHOD_END"], "methodName": ["getStringArray"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =     ( this )  )     {", "return    \"  ( this   Map )  \"  ;", "}", "if    ( value   instanceof   Object [  ]  )     {", "return    (  \"  [  \"     +     ( StUtils . arrayToDelimitedSt (  (  ( Object [  ]  )     ( value )  )  ,     \"  ,     \"  )  )  )     +     \"  ]  \"  ;", "}", "return   St . valueOf ( value )  ;", "}", "METHOD_END"], "methodName": ["valueToString"], "fileName": "org.springframework.core.annotation.AnnotationAttributes"}, {"methodBody": ["METHOD_START", "{", "String [  ]    value    =    new   String [  ]  {     \" test . xml \"     }  ;", "List < String >    aliases    =    Arrays . asList (  \" value \"  ,     \" location 1  \"  ,     \" location 2  \"  ,     \" location 3  \"  ,     \" xmlFile \"  ,     \" groovyScript \"  )  ;", "attributes    =    new    ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "attributes . put (  \" location 1  \"  ,    value )  ;", "AnnotationUtils . postProcess ( null ,    attributes ,    false )  ;", "aliases . stream (  )  . forEach (  (    alias )     -  >    assertArrayEquals ( value ,    attributes . getStringArray ( alias )  )  )  ;", "attributes    =    new    ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "attributes . put (  \" value \"  ,    value )  ;", "AnnotationUtils . postProcess ( null ,    attributes ,    false )  ;", "aliases . stream (  )  . forEach (  (    alias )     -  >    assertArrayEquals ( value ,    attributes . getStringArray ( alias )  )  )  ;", "attributes    =    new    ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "attributes . put (  \" location 1  \"  ,    value )  ;", "attributes . put (  \" value \"  ,    value )  ;", "AnnotationUtils . postProcess ( null ,    attributes ,    false )  ;", "aliases . stream (  )  . forEach (  (    alias )     -  >    assertArrayEquals ( value ,    attributes . getStringArray ( alias )  )  )  ;", "attributes    =    new    ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "attributes . put (  \" location 1  \"  ,    value )  ;", "AnnotationUtils . registerDefaultValues ( attributes )  ;", "AnnotationUtils . postProcess ( null ,    attributes ,    false )  ;", "aliases . stream (  )  . forEach (  (    alias )     -  >    assertArrayEquals ( value ,    attributes . getStringArray ( alias )  )  )  ;", "attributes    =    new    ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "attributes . put (  \" value \"  ,    value )  ;", "AnnotationUtils . registerDefaultValues ( attributes )  ;", "AnnotationUtils . postProcess ( null ,    attributes ,    false )  ;", "aliases . stream (  )  . forEach (  (    alias )     -  >    assertArrayEquals ( value ,    attributes . getStringArray ( alias )  )  )  ;", "attributes    =    new    ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "AnnotationUtils . registerDefaultValues ( attributes )  ;", "AnnotationUtils . postProcess ( null ,    attributes ,    false )  ;", "aliases . stream (  )  . forEach (  (    alias )     -  >    assertArrayEquals ( new   String [  ]  {     \"  \"     }  ,    attributes . getStringArray ( alias )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAliasedStringArrayWithImplicitAliases"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "String   value    =     \" metaverse \"  ;", "List < String >    aliases    =    Arrays . asList (  \" value \"  ,     \" location 1  \"  ,     \" location 2  \"  ,     \" location 3  \"  ,     \" xmlFile \"  ,     \" groovyScript \"  )  ;", "attributes    =    new    ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "attributes . put (  \" value \"  ,    value )  ;", "AnnotationUtils . postProcess ( null ,    attributes ,    false )  ;", "aliases . stream (  )  . forEach (  (    alias )     -  >    assertEquals ( value ,    attributes . getString ( alias )  )  )  ;", "attributes    =    new    ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "attributes . put (  \" location 1  \"  ,    value )  ;", "AnnotationUtils . postProcess ( null ,    attributes ,    false )  ;", "aliases . stream (  )  . forEach (  (    alias )     -  >    assertEquals ( value ,    attributes . getString ( alias )  )  )  ;", "attributes    =    new    ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "attributes . put (  \" value \"  ,    value )  ;", "attributes . put (  \" location 1  \"  ,    value )  ;", "attributes . put (  \" xmlFile \"  ,    value )  ;", "attributes . put (  \" groovyScript \"  ,    value )  ;", "AnnotationUtils . postProcess ( null ,    attributes ,    false )  ;", "aliases . stream (  )  . forEach (  (    alias )     -  >    assertEquals ( value ,    attributes . getString ( alias )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAliasedStringWithImplicitAliases"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage (  \" must   not   be   null   or   empty \"  )  ;", "a . getEnum (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["getEnumWithEmptyAttributeName"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage (  \" must   not   be   null   or   empty \"  )  ;", "a . getEnum ( null )  ;", "}", "METHOD_END"], "methodName": ["getEnumWithNullAttributeName"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "attributes . put (  \" color \"  ,     \" RED \"  )  ;", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( containsString (  \" Attribute    ' color '    is   of   type    [ String ]  ,    but    [ Enum ]    was   expected \"  )  )  ;", "attributes . getEnum (  \" color \"  )  ;", "}", "METHOD_END"], "methodName": ["getEnumWithTypeMismatch"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage (  \"     ' bogus '    not   found \"  )  ;", "attributes . getEnum (  \" bogus \"  )  ;", "}", "METHOD_END"], "methodName": ["getEnumWithUnknownAttributeName"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributesTests . Filter   filter    =    AnnotationAttributesTests . FilteredClass . class . getAnnotation ( AnnotationAttributesTests . Filter . class )  ;", "attributes . put (  \" filter \"  ,    filter )  ;", "attributes . put (  \" filters \"  ,    new   AnnotationAttributesTests . Filter [  ]  {    filter ,    filter    }  )  ;", "AnnotationAttributesTests . Filter   retrievedFilter    =    attributes . getAnnotation (  \" filter \"  ,    AnnotationAttributesTests . Filter . class )  ;", "assertThat ( retrievedFilter ,    equalTo ( filter )  )  ;", "assertThat ( retrievedFilter . pattern (  )  ,    equalTo (  \" foo \"  )  )  ;", "AnnotationAttributesTests . Filter [  ]    retrievedFilters    =    attributes . getAnnotationArray (  \" filters \"  ,    AnnotationAttributesTests . Filter . class )  ;", "assertNotNull ( retrievedFilters )  ;", "assertEquals (  2  ,    retrievedFilters . length )  ;", "assertThat ( retrievedFilters [  1  ]  . pattern (  )  ,    equalTo (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["nestedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributesTests . Filter   filter    =    AnnotationAttributesTests . FilteredClass . class . getAnnotation ( AnnotationAttributesTests . Filter . class )  ;", "AnnotationAttributes   nestedAttributes    =    new   AnnotationAttributes (  )  ;", "nestedAttributes . put (  \" name \"  ,     \" Dilbert \"  )  ;", "attributes . put (  \" names \"  ,     \" Dogbert \"  )  ;", "attributes . put (  \" classes \"  ,    Number . class )  ;", "attributes . put (  \" nestedAttributes \"  ,    nestedAttributes )  ;", "attributes . put (  \" filters \"  ,    filter )  ;", "assertThat ( attributes . getStringArray (  \" names \"  )  ,    equalTo ( new   String [  ]  {     \" Dogbert \"     }  )  )  ;", "assertThat ( attributes . getClassArray (  \" classes \"  )  ,    equalTo ( new   Class <  ?  >  [  ]  {    Number . class    }  )  )  ;", "AnnotationAttributes [  ]    array    =    attributes . getAnnotationArray (  \" nestedAttributes \"  )  ;", "assertNotNull ( array )  ;", "assertThat ( array . length ,    is (  1  )  )  ;", "assertThat ( array [  0  ]  . getString (  \" name \"  )  ,    equalTo (  \" Dilbert \"  )  )  ;", "AnnotationAttributesTests . Filter [  ]    filters    =    attributes . getAnnotationArray (  \" filters \"  ,    AnnotationAttributesTests . Filter . class )  ;", "assertNotNull ( filters )  ;", "assertThat ( filters . length ,    is (  1  )  )  ;", "assertThat ( filters [  0  ]  . pattern (  )  ,    equalTo (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["singleElementToSingleElementArrayConversionSupport"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   nestedAttributes    =    new   AnnotationAttributes (  )  ;", "nestedAttributes . put (  \" value \"  ,     1  0  )  ;", "nestedAttributes . put (  \" name \"  ,     \" algernon \"  )  ;", "attributes . put (  \" name \"  ,     \" dave \"  )  ;", "attributes . put (  \" names \"  ,    new   String [  ]  {     \" dave \"  ,     \" frank \"  ,     \" hal \"     }  )  ;", "attributes . put (  \" bool 1  \"  ,    true )  ;", "attributes . put (  \" bool 2  \"  ,    false )  ;", "attributes . put (  \" color \"  ,     . Color . RED )  ;", "attributes . put (  \" class \"  ,    Integer . class )  ;", "attributes . put (  \" classes \"  ,    new   Class <  ?  >  [  ]  {    Number . class ,    Short . class ,    Integer . class    }  )  ;", "attributes . put (  \" number \"  ,     4  2  )  ;", "attributes . put (  \" anno \"  ,    nestedAttributes )  ;", "attributes . put (  \" annoArray \"  ,    new   AnnotationAttributes [  ]  {    nestedAttributes    }  )  ;", "assertThat ( attributes . getString (  \" name \"  )  ,    equalTo (  \" dave \"  )  )  ;", "assertThat ( attributes . getStringArray (  \" names \"  )  ,    equalTo ( new   String [  ]  {     \" dave \"  ,     \" frank \"  ,     \" hal \"     }  )  )  ;", "assertThat ( attributes . getBoolean (  \" bool 1  \"  )  ,    equalTo ( true )  )  ;", "assertThat ( attributes . getBoolean (  \" bool 2  \"  )  ,    equalTo ( false )  )  ;", "assertThat ( attributes .  <  . Color > getEnum (  \" color \"  )  ,    equalTo (  . Color . RED )  )  ;", "assertTrue ( attributes . getClass (  \" class \"  )  . equals ( Integer . class )  )  ;", "assertThat ( attributes . getClassArray (  \" classes \"  )  ,    equalTo ( new   Class <  ?  >  [  ]  {    Number . class ,    Short . class ,    Integer . class    }  )  )  ;", "assertThat ( attributes .  < Integer > getNumber (  \" number \"  )  ,    equalTo (  4  2  )  )  ;", "assertThat ( attributes . getAnnotation (  \" anno \"  )  .  < Integer > getNumber (  \" value \"  )  ,    equalTo (  1  0  )  )  ;", "assertThat ( attributes . getAnnotationArray (  \" annoArray \"  )  [  0  ]  . getString (  \" name \"  )  ,    equalTo (  \" algernon \"  )  )  ;", "}", "METHOD_END"], "methodName": ["typeSafeAttributeAccess"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "attributes . put (  \" unresolvableClass \"  ,    new   ClassNotFoundException (  \" myclass \"  )  )  ;", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( containsString (  \" myclass \"  )  )  ;", "attributes . getClass (  \" unresolvableClass \"  )  ;", "}", "METHOD_END"], "methodName": ["unresolvableClass"], "fileName": "org.springframework.core.annotation.AnnotationAttributesTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( array . length )     >     1  )     {", "Arrays . sort ( array ,     . INSTANCE )  ;", "}", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( list . size (  )  )     >     1  )     {", "list . sort (  . INSTANCE )  ;", "}", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparator"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   Object [  ]  )     {", ". sort (  (  ( Object [  ]  )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   List )     {", ". sort (  (  ( List <  ?  >  )     ( value )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sortIfNecessary"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparator"}, {"methodBody": ["METHOD_START", "{", "assertThat ( AnnotationAwareOrderComparator . INSTANCE ,    is ( instanceOf ( AnnotationAwareOrderComparator . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["instanceVariableIsAnAnnotationAwareOrderComparator"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  . B . class )  ;", "list . add (  . A . class )  ;", "AnnotationAwareOrderComparator . sort ( list )  ;", "assertEquals (  . A . class ,    list . get (  0  )  )  ;", "assertEquals (  . B . class ,    list . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["sortClasses"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  . B . class )  ;", "list . add (  . C . class )  ;", "AnnotationAwareOrderComparator . sort ( list )  ;", "assertEquals (  . C . class ,    list . get (  0  )  )  ;", "assertEquals (  . B . class ,    list . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["sortClassesWithSubclass"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new    . B (  )  )  ;", "list . add ( new    . A (  )  )  ;", "AnnotationAwareOrderComparator . sort ( list )  ;", "assertTrue (  (  ( list . get (  0  )  )    instanceof    . A )  )  ;", "assertTrue (  (  ( list . get (  1  )  )    instanceof    . B )  )  ;", "}", "METHOD_END"], "methodName": ["sortInstances"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new    . B (  )  )  ;", "list . add ( new    . A 2  (  )  )  ;", "AnnotationAwareOrderComparator . sort ( list )  ;", "assertTrue (  (  ( list . get (  0  )  )    instanceof    . A 2  )  )  ;", "assertTrue (  (  ( list . get (  1  )  )    instanceof    . B )  )  ;", "}", "METHOD_END"], "methodName": ["sortInstancesWithOrderAndPriority"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new    . B 2  (  )  )  ;", "list . add ( new    . A 2  (  )  )  ;", "AnnotationAwareOrderComparator . sort ( list )  ;", "assertTrue (  (  ( list . get (  0  )  )    instanceof    . A 2  )  )  ;", "assertTrue (  (  ( list . get (  1  )  )    instanceof    . B 2  )  )  ;", "}", "METHOD_END"], "methodName": ["sortInstancesWithPriority"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new    . B (  )  )  ;", "list . add ( new    . C (  )  )  ;", "AnnotationAwareOrderComparator . sort ( list )  ;", "assertTrue (  (  ( list . get (  0  )  )    instanceof    . C )  )  ;", "assertTrue (  (  ( list . get (  1  )  )    instanceof    . B )  )  ;", "}", "METHOD_END"], "methodName": ["sortInstancesWithSubclass"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( null )  ;", "list . add (  . B . class )  ;", "list . add ( null )  ;", "list . add (  . A . class )  ;", "AnnotationAwareOrderComparator . sort ( list )  ;", "assertEquals (  . A . class ,    list . get (  0  )  )  ;", "assertEquals (  . B . class ,    list . get (  1  )  )  ;", "assertNull ( list . get (  2  )  )  ;", "assertNull ( list . get (  3  )  )  ;", "}", "METHOD_END"], "methodName": ["sortWithNulls"], "fileName": "org.springframework.core.annotation.AnnotationAwareOrderComparatorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( classValuesAsString )     {", "if    ( value   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( value )  )  . getName (  )  ;", "} else", "if    ( value   instanceof   Class [  ]  )     {", "Class <  ?  >  [  ]    clazzArray    =     (  ( Class <  ?  >  [  ]  )     ( value )  )  ;", "String [  ]    classNames    =    new   String [ clazzArray . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( clazzArray . length )  ;    i +  +  )     {", "classNames [ i ]     =    clazzArray [ i ]  . getName (  )  ;", "}", "return   classNames ;", "}", "}", "if    ( value   instanceof   Annotation )     {", "Annotation   annotation    =     (  ( Annotation )     ( value )  )  ;", "if    ( nestedAnnotationsAsMap )     {", "return    . getAnnotationAttributes ( annotatedElement ,    annotation ,    classValuesAsString ,    true )  ;", "} else    {", "return    . synthesizeAnnotation ( annotation ,    annotatedElement )  ;", "}", "}", "if    ( value   instanceof   Annotation [  ]  )     {", "Annotation [  ]    annotations    =     (  ( Annotation [  ]  )     ( value )  )  ;", "if    ( nestedAnnotationsAsMap )     {", "AnnotationAttributes [  ]    mappedAnnotations    =    new   AnnotationAttributes [ annotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "mappedAnnotations [ i ]     =     . getAnnotationAttributes ( annotatedElement ,    annotations [ i ]  ,    classValuesAsString ,    true )  ;", "}", "return   mappedAnnotations ;", "} else    {", "return    . synthesizeAnnotationArray ( annotations ,    annotatedElement )  ;", "}", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["adaptValue"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    ( Class . forName ( SynthesizedAnnotation . class . getName (  )  ,    false ,    Type . getClassLoader (  )  )  )     =  =     ( SynthesizedAnnotation . class )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["canExposeSynthesizedMarker"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtils . findAnnotationCache . clear (  )  ;", "AnnotationUtils . metaPresentCache . clear (  )  ;", "AnnotationUtils . annotatedBaseTypeCache . clear (  )  ;", "AnnotationUtils . synthesizableCache . clear (  )  ;", "AnnotationUtils . attributeAliasesCache . clear (  )  ;", "AnnotationUtils . attributeMethodsCache . clear (  )  ;", "AnnotationUtils . aliasDescriptorCache . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . findAnnotation ( clazz ,    annotationType ,    true )  ;", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "if    ( annotationType    =  =    null )     {", "return   null ;", "}", ". AnnotationCacheKey   cacheKey    =    new    . AnnotationCacheKey ( clazz ,    annotationType )  ;", "A   result    =     (  ( A )     (  . findAnnotationCache . get ( cacheKey )  )  )  ;", "if    ( result    =  =    null )     {", "result    =     . findAnnotation ( clazz ,    annotationType ,    new   HashSet <  >  (  )  )  ;", "if    (  ( result    !  =    null )     &  &    synthesize )     {", "result    =     . synthesizeAnnotation ( result ,    clazz )  ;", ". findAnnotationCache . put ( cacheKey ,    result )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "A   annotation    =    clazz . getDeclaredAnnotation ( annotationType )  ;", "if    ( annotation    !  =    null )     {", "return   annotation ;", "}", "for    ( Annotation   declaredAnn    :    clazz . getDeclaredAnnotations (  )  )     {", "Class <  ?    extends   Annotation >    declaredType    =    declaredAnn . annotationType (  )  ;", "if    (  (  !  (  . isInJavaLangAnnotationPackage ( declaredType )  )  )     &  &     ( visited . add ( declaredAnn )  )  )     {", "annotation    =     . findAnnotation ( declaredType ,    annotationType ,    visited )  ;", "if    ( annotation    !  =    null )     {", "return   annotation ;", "}", "}", "}", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( clazz ,    ex )  ;", "return   null ;", "}", "for    ( Class <  ?  >    ifc    :    clazz . getInterfaces (  )  )     {", "A   annotation    =     . findAnnotation ( ifc ,    annotationType ,    visited )  ;", "if    ( annotation    !  =    null )     {", "return   annotation ;", "}", "}", "Class <  ?  >    superclass    =    clazz . getSuperclass (  )  ;", "if    (  ( superclass    =  =    null )     |  |     (  ( Object . class )     =  =    superclass )  )     {", "return   null ;", "}", "return    . findAnnotation ( superclass ,    annotationType ,    visited )  ;", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "A   ann    =    AnnotationUtils . findAnnotation ( annotatedElement ,    annotationType ,    new   HashSet <  >  (  )  )  ;", "return   ann    !  =    null    ?    AnnotationUtils . synthesizeAnnotation ( ann ,    annotatedElement )     :    null ;", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "A   annotation    =    annotatedElement . getDeclaredAnnotation ( annotationType )  ;", "if    ( annotation    !  =    null )     {", "return   annotation ;", "}", "for    ( Annotation   declaredAnn    :    annotatedElement . getDeclaredAnnotations (  )  )     {", "Class <  ?    extends   Annotation >    declaredType    =    declaredAnn . annotationType (  )  ;", "if    (  (  !  (  . isInJavaLangAnnotationPackage ( declaredType )  )  )     &  &     ( visited . add ( declaredAnn )  )  )     {", "annotation    =     . findAnnotation (  (  ( AnnotatedElement )     ( declaredType )  )  ,    annotationType ,    visited )  ;", "if    ( annotation    !  =    null )     {", "return   annotation ;", "}", "}", "}", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( annotatedElement ,    ex )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "if    ( annotationType    =  =    null )     {", "return   null ;", "}", ". AnnotationCacheKey   cacheKey    =    new    . AnnotationCacheKey ( method ,    annotationType )  ;", "A   result    =     (  ( A )     (  . findAnnotationCache . get ( cacheKey )  )  )  ;", "if    ( result    =  =    null )     {", "Method   resolvedMethod    =    BridgeMethodResolver . findBridgedMethod ( method )  ;", "result    =     . findAnnotation (  (  ( AnnotatedElement )     ( resolvedMethod )  )  ,    annotationType )  ;", "if    ( result    =  =    null )     {", "result    =     . searchOnInterfaces ( method ,    annotationType ,    method . getDeclaringClass (  )  . getInterfaces (  )  )  ;", "}", "Class <  ?  >    clazz    =    method . getDeclaringClass (  )  ;", "while    ( result    =  =    null )     {", "clazz    =    clazz . getSuperclass (  )  ;", "if    (  ( clazz    =  =    null )     |  |     (  ( Object . class )     =  =    clazz )  )     {", "break ;", "}", "Set < Method >    annotatedMethods    =     . getAnnotatedMethodsInBaseType ( clazz )  ;", "if    (  !  ( annotatedMethods . isEmpty (  )  )  )     {", "for    ( Method   annotatedMethod    :    annotatedMethods )     {", "if    (  ( annotatedMethod . getName (  )  . equals ( method . getName (  )  )  )     &  &     ( Arrays . equals ( annotatedMethod . getParameterTypes (  )  ,    method . getParameterTypes (  )  )  )  )     {", "Method   resolvedSuperMethod    =    BridgeMethodResolver . findBridgedMethod ( annotatedMethod )  ;", "result    =     . findAnnotation (  (  ( AnnotatedElement )     ( resolvedSuperMethod )  )  ,    annotationType )  ;", "if    ( result    !  =    null )     {", "break ;", "}", "}", "}", "}", "if    ( result    =  =    null )     {", "result    =     . searchOnInterfaces ( method ,    annotationType ,    clazz . getInterfaces (  )  )  ;", "}", "}", "if    ( result    !  =    null )     {", "result    =     . synthesizeAnnotation ( result ,    method )  ;", ". findAnnotationCache . put ( cacheKey ,    result )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( clazz    =  =    null )     |  |     (  ( Object . class )     =  =    clazz )  )     {", "return   null ;", "}", "if    (  . isAnnotationDeclaredLocally ( annotationType ,    clazz )  )     {", "return   clazz ;", "}", "return    . findAnnotationDeclaringClass ( annotationType ,    clazz . getSuperclass (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDeclaringClass"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( clazz    =  =    null )     |  |     (  ( Object . class )     =  =    clazz )  )     {", "return   null ;", "}", "for    ( Class <  ?    extends   Annotation >    annotationType    :    annotationTypes )     {", "if    (  . isAnnotationDeclaredLocally ( annotationType ,    clazz )  )     {", "return   clazz ;", "}", "}", "return    . findAnnotationDeclaringClassForTypes ( annotationTypes ,    clazz . getSuperclass (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDeclaringClassForTypes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "boolean   ifcCheck    =    baseType . isInterface (  )  ;", "if    ( ifcCheck    &  &     ( ClassUtils . isJavaLanguageInterface ( baseType )  )  )     {", "return   Collections . emptySet (  )  ;", "}", "Set < Method >    annotatedMethods    =     . annotatedBaseTypeCache . get ( baseType )  ;", "if    ( annotatedMethods    !  =    null )     {", "return   annotatedMethods ;", "}", "Method [  ]    methods    =     ( ifcCheck )     ?    baseType . getMethods (  )     :    baseType . getDeclaredMethods (  )  ;", "for    ( Method   baseMethod    :    methods )     {", "try    {", "if    (  ( ifcCheck    |  |     (  !  ( Modifier . isPrivate ( baseMethod . getModifiers (  )  )  )  )  )     &  &     (  . hasSearchableAnnotations ( baseMethod )  )  )     {", "if    ( annotatedMethods    =  =    null )     {", "annotatedMethods    =    new   HashSet <  >  (  )  ;", "}", "annotatedMethods . add ( baseMethod )  ;", "}", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( baseMethod ,    ex )  ;", "}", "}", "if    ( annotatedMethods    =  =    null )     {", "annotatedMethods    =    Collections . emptySet (  )  ;", "}", ". annotatedBaseTypeCache . put ( baseType ,    annotatedMethods )  ;", "return   annotatedMethods ;", "}", "METHOD_END"], "methodName": ["getAnnotatedMethodsInBaseType"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( annotationType . isInstance ( annotation )  )     {", "return    . synthesizeAnnotation (  (  ( A )     ( annotation )  )  )  ;", "}", "Class <  ?    extends   Annotation >    annotatedElement    =    annotation . annotationType (  )  ;", "try    {", "A   metaAnn    =    annotatedElement . getAnnotation ( annotationType )  ;", "return   metaAnn    !  =    null    ?     . synthesizeAnnotation ( metaAnn ,    annotatedElement )     :    null ;", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( annotatedElement ,    ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "A   annotation    =    annotatedElement . getAnnotation ( annotationType )  ;", "if    ( annotation    =  =    null )     {", "for    ( Annotation   metaAnn    :    annotatedElement . getAnnotations (  )  )     {", "annotation    =    metaAnn . annotationType (  )  . getAnnotation ( annotationType )  ;", "if    ( annotation    !  =    null )     {", "break ;", "}", "}", "}", "return   annotation    !  =    null    ?     . synthesizeAnnotation ( annotation ,    annotatedElement )     :    null ;", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( annotatedElement ,    ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Annotation    :    element . getAnnotations (  )  )     {", "if   Type (  )  . getName (  )  . equalsName )  )     {", "return ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Method   resolvedMethod    =    BridgeMethodResolver . findBridgedMethod ( method )  ;", "return    . getAnnotation (  (  ( AnnotatedElement )     ( resolvedMethod )  )  ,    annotationType )  ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =    AnnotationUtils . retrieveAnnotationAttributes ( annotatedElement ,    annotation ,    classValuesAsString ,    nestedAnnotationsAsMap )  ;", "AnnotationUtils . postProcessAnnotationAttributes ( annotatedElement ,    attributes ,    classValuesAsString ,    nestedAnnotationsAsMap )  ;", "return   attributes ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getAnnotationAttributes ( null ,    annotation )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getAnnotationAttributes ( annotation ,    classValuesAsString ,    false )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getAnnotationAttributes ( null ,    annotation ,    classValuesAsString ,    nestedAnnotationsAsMap )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getAnnotationAttributes ( annotatedElement ,    annotation ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getAnnotationAttributes (  (  ( Object )     ( annotatedElement )  )  ,    annotation ,    classValuesAsString ,    nestedAnnotationsAsMap )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . synthesizeAnnotationArray ( annotatedElement . getAnnotations (  )  ,    annotatedElement )  ;", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( annotatedElement ,    ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . synthesizeAnnotationArray ( BridgeMethodResolver . findBridgedMethod ( method )  . getAnnotations (  )  ,    method )  ;", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( method ,    ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( annotationType    =  =    null )     {", "return   Collections . emptyMap (  )  ;", "}", "Map < String ,    List < String >  >    map    =     . attributeAliasesCache . get ( annotationType )  ;", "if    ( map    !  =    null )     {", "return   map ;", "}", "map    =    new   LinkedHashMap <  >  (  )  ;", "for    ( Method   attribute    :     . getAttributeMethods ( annotationType )  )     {", "List < String >    aliasNames    =     . getAttributeAliasNames ( attribute )  ;", "if    (  !  ( aliasNames . isEmpty (  )  )  )     {", "map . put ( attribute . getName (  )  ,    aliasNames )  ;", "}", "}", ". attributeAliasesCache . put ( annotationType ,    map )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["getAttributeAliasMap"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtils . AliasDescriptor   descriptor    =    AnnotationUtils . AliasDescriptor . from ( attribute )  ;", "return   descriptor    !  =    null    ?    descriptor . getAttributeAliasNames (  )     :    Collections .  < String > emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeAliasNames"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "List < Method >    methods    =    AnnotationUtils . attributeMethodsCache . get ( annotationType )  ;", "if    ( methods    !  =    null )     {", "return   methods ;", "}", "methods    =    new   ArrayList <  >  (  )  ;", "for    ( Method   method    :    annotationType . getDeclaredMethods (  )  )     {", "if    ( AnnotationUtils . isAttributeMethod ( method )  )     {", "ReflectionUtils . makeAccessible ( method )  ;", "methods . add ( method )  ;", "}", "}", "AnnotationUtils . attributeMethodsCache . put ( annotationType ,    methods )  ;", "return   methods ;", "}", "METHOD_END"], "methodName": ["getAttributeMethods"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtils . AliasDescriptor   descriptor    =    AnnotationUtils . AliasDescriptor . from ( attribute )  ;", "return    ( descriptor    !  =    null )     &  &     ( metaAnnotationType    !  =    null )     ?    descriptor . getAttributeOverrideName ( metaAnnotationType )     :    null ;", "}", "METHOD_END"], "methodName": ["getAttributeOverrideName"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getDeclaredRepeatableAnnotations ( annotatedElement ,    annotationType ,    null )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getRepeatableAnnotations ( annotatedElement ,    annotationType ,    containerAnnotationType ,    true )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getDefaultValue ( annotationType ,    AnnotationUtils . VALUE )  ;", "}", "METHOD_END"], "methodName": ["getDefaultValue"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( annotationType    =  =    null )     |  |     (  !  ( StringUtils . hasText ( attributeName )  )  )  )     {", "return   null ;", "}", "try    {", "return   annotationType . getDeclaredMethod ( attributeName )  . getDefaultValue (  )  ;", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( annotationType ,    ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getDefaultValue"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getDefaultValue ( annotation ,    AnnotationUtils . VALUE )  ;", "}", "METHOD_END"], "methodName": ["getDefaultValue"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( annotation    =  =    null )     {", "return   null ;", "}", "return    . getDefaultValue ( annotation . annotationType (  )  ,    attributeName )  ;", "}", "METHOD_END"], "methodName": ["getDefaultValue"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getRepeatableAnnotations ( annotatedElement ,    annotationType ,    null )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Set < A >    annotations    =    AnnotationUtils . getDeclaredRepeatableAnnotations ( annotatedElement ,    annotationType ,    containerAnnotationType )  ;", "if    (  !  ( annotations . isEmpty (  )  )  )     {", "return   annotations ;", "}", "if    ( annotatedElement   instanceof   Class )     {", "Class <  ?  >    superclass    =     (  ( Class <  ?  >  )     ( annotatedElement )  )  . getSuperclass (  )  ;", "if    (  ( superclass    !  =    null )     &  &     (  ( Object . class )     !  =    superclass )  )     {", "return   AnnotationUtils . getRepeatableAnnotations ( superclass ,    annotationType ,    containerAnnotationType )  ;", "}", "}", "return   AnnotationUtils . getRepeatableAnnotations ( annotatedElement ,    annotationType ,    containerAnnotationType ,    false )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( annotatedElement   instanceof   Method )     {", "annotatedElement    =    BridgeMethodResolver . findBridgedMethod (  (  ( Method )     ( annotatedElement )  )  )  ;", "}", "return   new    . AnnotationCollector <  >  ( annotationType ,    containerAnnotationType ,    declaredMode )  . getResult ( annotatedElement )  ;", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( annotatedElement ,    ex )  ;", "return   Collections . emptySet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . getValue ( annotation ,    AnnotationUtils . VALUE )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( annotation    =  =    null )     |  |     (  !  ( StringUtils . hasText ( attributeName )  )  )  )     {", "return   null ;", "}", "try    {", "Method   method    =    annotation . annotationType (  )  . getDeclaredMethod ( attributeName )  ;", "ReflectionUtils . makeAccessible ( method )  ;", "return   method . invoke ( annotation )  ;", "}    catch    ( InvocationTargetException   ex )     {", ". rethrowAnnotationConfigurationException ( ex . getTargetException (  )  )  ;", "throw   new   IllegalStateException (  (  (  (  \" Could   not   obtain   value   for   annotation   attribute    '  \"     +    attributeName )     +     \"  '    in    \"  )     +    annotation )  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( annotation . getClass (  )  ,    ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtils . rethrowAnnotationConfigurationException ( ex )  ;", "Log   loggerToUse    =    AnnotationUtils . logger ;", "if    ( loggerToUse    =  =    null )     {", "loggerToUse    =    LogFactory . getLog ( AnnotationUtils . class )  ;", "AnnotationUtils . logger    =    loggerToUse ;", "}", "if    (  ( element   instanceof   Class )     &  &     ( Annotation . class . isAssignableFrom (  (  ( Class <  ?  >  )     ( element )  )  )  )  )     {", "if    ( loggerToUse . isDebugEnabled (  )  )     {", "loggerToUse . debug (  (  (  (  \" Failed   to   meta - introspect   annotation    \"     +    element )     +     \"  :     \"  )     +    ex )  )  ;", "}", "} else    {", "if    ( loggerToUse . isInfoEnabled (  )  )     {", "loggerToUse . info (  (  (  (  \" Failed   to   introspect   annotations   on    \"     +    element )     +     \"  :     \"  )     +    ex )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleIntrospectionFailure"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    anns    =    ifcMethod . getAnnotations (  )  ;", "if    (  ( anns . length )     =  =     0  )     {", "return   false ;", "}", "if    (  ( anns . length )     =  =     1  )     {", "Class <  ?  >    annType    =    anns [  0  ] Type (  )  ;", "return    ( annType    !  =     ( Nullable . class )  )     &  &     ( annType    !  =     ( Deprecated . class )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["hasSearchableAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    ( clazz . getDeclaredAnnotation ( annotationType )  )     !  =    null ;", "}    catch    ( Throwable   ex )     {", ". handleIntrospectionFailure ( clazz ,    ex )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isAnnotationDeclaredLocally"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( clazz . isAnnotationPresent ( annotationType )  )     &  &     (  !  ( AnnotationUtils . isAnnotationDeclaredLocally ( annotationType ,    clazz )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationInherited"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( annotationType ,     \" Annotation   type   must   not   be   null \"  )  ;", "if    ( metaAnnotationType    =  =    null )     {", "return   false ;", "}", ". AnnotationCacheKey   cacheKey    =    new    . AnnotationCacheKey ( annotationType ,    metaAnnotationType )  ;", "Boolean   metaPresent    =     . metaPresentCache . get ( cacheKey )  ;", "if    ( metaPresent    !  =    null )     {", "return   metaPresent ;", "}", "metaPresent    =    Boolean . FALSE ;", "if    (  (  . findAnnotation ( annotationType ,    metaAnnotationType ,    false )  )     !  =    null )     {", "metaPresent    =    Boolean . TRUE ;", "}", ". metaPresentCache . put ( cacheKey ,    metaPresent )  ;", "return   metaPresent ;", "}", "METHOD_END"], "methodName": ["isAnnotationMetaPresent"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( method    !  =    null )     &  &     ( method . getName (  )  . equals (  \" annotationType \"  )  )  )     &  &     (  ( method . getParameterCount (  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationTypeMethod"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( method    !  =    null )     &  &     (  ( method . getParameterCount (  )  )     =  =     0  )  )     &  &     (  ( method . getReturnType (  )  )     !  =     ( void . class )  )  ;", "}", "METHOD_END"], "methodName": ["isAttributeMethod"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( annotationType    !  =    null )     &  &     ( AnnotationUtils . isInJavaLangAnnotationPackage ( annotationType . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isInJavaLangAnnotationPackage"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( annotationType    !  =    null )     &  &     ( annotationType . startsWith (  \" annotation \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isInJavaLangAnnotationPackage"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( annotation    !  =    null )     &  &     ( AnnotationUtils . isInJavaLangAnnotationPackage ( annotation . annotationType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isInJavaLangAnnotationPackage"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Boolean   synthesizable    =    AnnotationUtils . synthesizableCache . get ( annotationType )  ;", "if    ( synthesizable    !  =    null )     {", "return   synthesizable ;", "}", "synthesizable    =    Boolean . FALSE ;", "for    ( Method   attribute    :    AnnotationUtils . getAttributeMethods ( annotationType )  )     {", "if    (  !  ( AnnotationUtils . getAttributeAliasNames ( attribute )  . isEmpty (  )  )  )     {", "synthesizable    =    Boolean . TRUE ;", "break ;", "}", "Class <  ?  >    returnType    =    attribute . getReturnType (  )  ;", "if    ( Annotation [  ]  . class . isAssignableFrom ( returnType )  )     {", "Class <  ?    extends   Annotation >    nestedAnnotationType    =     (  ( Class <  ?    extends   Annotation >  )     ( returnType . getComponentType (  )  )  )  ;", "if    ( AnnotationUtils . isSynthesizable ( nestedAnnotationType )  )     {", "synthesizable    =    Boolean . TRUE ;", "break ;", "}", "} else", "if    ( Annotation . class . isAssignableFrom ( returnType )  )     {", "Class <  ?    extends   Annotation >    nestedAnnotationType    =     (  ( Class <  ?    extends   Annotation >  )     ( returnType )  )  ;", "if    ( AnnotationUtils . isSynthesizable ( nestedAnnotationType )  )     {", "synthesizable    =    Boolean . TRUE ;", "break ;", "}", "}", "}", "AnnotationUtils . synthesizableCache . put ( annotationType ,    synthesizable )  ;", "return   synthesizable ;", "}", "METHOD_END"], "methodName": ["isSynthesizable"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtils . postProcessAnnotationAttributes ( annotatedElement ,    attributes ,    classValuesAsString ,    false )  ;", "}", "METHOD_END"], "methodName": ["postProcessAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    =  =    null )     {", "return ;", "}", "Class <  ?    extends   Annotation >    annotationType    =    attributes . annotationType (  )  ;", "Set < String >    valuesAlreadyReplaced    =    new   HashSet <  >  (  )  ;", "if    (  !  ( attributes . validated )  )     {", "Map < String ,    List < String >  >    aliasMap    =     . getAttributeAliasMap ( annotationType )  ;", "aliasMap . forEach (  (    attributeName ,    aliasedAttributeNames )     -  >     {", "if    ( valuesAlreadyReplaced . contains ( attributeName )  )     {", "return ;", "}", "Object   value    =    attributes . get ( attributeName )  ;", "boolean   valuePresent    =     ( value    !  =    null )     &  &     (  !  ( value   instanceof    . DefaultValueHolder )  )  ;", "for    ( String   aliasedAttributeName    :    aliasedAttributeNames )     {", "if    ( valuesAlreadyReplaced . contains ( aliasedAttributeName )  )     {", "continue ;", "}", "Object   aliasedValue    =    attributes . get ( aliasedAttributeName )  ;", "boolean   aliasPresent    =     ( aliasedValue    !  =    null )     &  &     (  !  ( aliasedValue   instanceof    . DefaultValueHolder )  )  ;", "if    ( valuePresent    |  |    aliasPresent )     {", "if    ( valuePresent    &  &    aliasPresent )     {", "if    (  !  ( ObjectUtils . nullSafeEquals ( value ,    aliasedValue )  )  )     {", "String   elementAsString    =     ( annotatedElement    !  =    null )     ?    annotatedElement . toString (  )     :     \" unknown   element \"  ;", "throw   new   AnnotationConfigurationException ( String . format (  (  \" In   AnnotationAttributes   for   annotation    [  % s ]    declared   on    % s ,     \"     +     (  \" attribute    '  % s '    and   its   alias    '  % s '    are   declared   with   values   of    [  % s ]    and    [  % s ]  ,     \"     +     \" but   only   one   is   permitted .  \"  )  )  ,    attributes . displayName ,    elementAsString ,    attributeName ,    aliasedAttributeName ,    ObjectUtils . nullSafeToString ( value )  ,    ObjectUtils . nullSafeToString ( aliasedValue )  )  )  ;", "}", "} else", "if    ( aliasPresent )     {", "attributes . put ( attributeName ,     . adaptValue ( annotatedElement ,    aliasedValue ,    classValuesAsString ,    nestedAnnotationsAsMap )  )  ;", "valuesAlreadyReplaced . add ( attributeName )  ;", "} else    {", "attributes . put ( aliasedAttributeName ,     . adaptValue ( annotatedElement ,    value ,    classValuesAsString ,    nestedAnnotationsAsMap )  )  ;", "valuesAlreadyReplaced . add ( aliasedAttributeName )  ;", "}", "}", "}", "}  )  ;", "attributes . validated    =    true ;", "}", "for    ( String   attributeName    :    attributes . keySet (  )  )     {", "if    ( valuesAlreadyReplaced . contains ( attributeName )  )     {", "continue ;", "}", "Object   value    =    attributes . get ( attributeName )  ;", "if    ( value   instanceof    . DefaultValueHolder )     {", "value    =     (  (  . DefaultValueHolder )     ( value )  )  . defaultValue ;", "attributes . put ( attributeName ,     . adaptValue ( annotatedElement ,    value ,    classValuesAsString ,    nestedAnnotationsAsMap )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["postProcessAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Annotation >    annotationType    =    attributes . annotationType (  )  ;", "if    (  ( annotationType    !  =    null )     &  &     ( Modifier . isPublic ( annotationType . getModifiers (  )  )  )  )     {", "for    ( Method   annotationAttribute    :     . getAttributeMethods ( annotationType )  )     {", "String   attributeName    =    annotationAttribute . getName (  )  ;", "Object   defaultValue    =    annotationAttribute . getDefaultValue (  )  ;", "if    (  ( defaultValue    !  =    null )     &  &     (  !  ( attributes . containsKey ( attributeName )  )  )  )     {", "if    ( defaultValue   instanceof   Annotation )     {", "defaultValue    =     . getAnnotationAttributes (  (  ( Annotation )     ( defaultValue )  )  ,    false ,    true )  ;", "} else", "if    ( defaultValue   instanceof   Annotation [  ]  )     {", "Annotation [  ]    realAnnotations    =     (  ( Annotation [  ]  )     ( defaultValue )  )  ;", "AnnotationAttributes [  ]    mappedAnnotations    =    new   AnnotationAttributes [ realAnnotations . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( realAnnotations . length )  ;    i +  +  )     {", "mappedAnnotations [ i ]     =     . getAnnotationAttributes ( realAnnotations [ i ]  ,    false ,    true )  ;", "}", "defaultValue    =    mappedAnnotations ;", "}", "attributes . put ( attributeName ,    new    . DefaultValueHolder ( defaultValue )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["registerDefaultValues"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Repeatable   repeatable    =    AnnotationUtils . getAnnotation ( annotationType ,    Repeatable . class )  ;", "return   repeatable    !  =    null    ?    repeatable . value (  )     :    null ;", "}", "METHOD_END"], "methodName": ["resolveContainerAnnotationType"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   AnnotationConfigurationException )     {", "throw    (  ( AnnotationConfigurationException )     ( ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["rethrowAnnotationConfigurationException"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Annotation >    annotationType    =    annotation . annotationType (  )  ;", "AnnotationAttributes   attributes    =    new   AnnotationAttributes ( annotationType )  ;", "for    ( Method   method    :     . getAttributeMethods ( annotationType )  )     {", "try    {", "Object   attributeValue    =    method . invoke ( annotation )  ;", "Object   defaultValue    =    method . getDefaultValue (  )  ;", "if    (  ( defaultValue    !  =    null )     &  &     ( ObjectUtils . nullSafeEquals ( attributeValue ,    defaultValue )  )  )     {", "attributeValue    =    new    . DefaultValueHolder ( defaultValue )  ;", "}", "attributes . put ( method . getName (  )  ,     . adaptValue ( annotatedElement ,    attributeValue ,    classValuesAsString ,    nestedAnnotationsAsMap )  )  ;", "}    catch    ( Throwable   ex )     {", "if    ( ex   instanceof   InvocationTargetException )     {", "Throwable   targetException    =     (  ( InvocationTargetException )     ( ex )  )  . getTargetException (  )  ;", ". rethrowAnnotationConfigurationException ( targetException )  ;", "}", "throw   new   IllegalStateException (  (  \" Could   not   obtain   annotation   attribute   value   for    \"     +    method )  ,    ex )  ;", "}", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["retrieveAnnotationAttributes"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    ifc    :    ifcs )     {", "Set < Method >    annotatedMethods    =     . getAnnotatedMethodsInBaseType ( ifc )  ;", "if    (  !  ( annotatedMethods . isEmpty (  )  )  )     {", "for    ( Method   annotatedMethod    :    annotatedMethods )     {", "if    (  ( annotatedMethod . getName (  )  . equals ( method . getName (  )  )  )     &  &     ( Arrays . equals ( annotatedMethod . getParameterTypes (  )  ,    method . getParameterTypes (  )  )  )  )     {", "A   annotation    =     . getAnnotation ( annotatedMethod ,    annotationType )  ;", "if    ( annotation    !  =    null )     {", "return   annotation ;", "}", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["searchOnInterfaces"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . synthesizeAnnotation ( annotation ,    null )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( annotation   instanceof   SynthesizedAnnotation )     {", "return   annotation ;", "}", "Class <  ?    extends   Annotation >    annotationType    =    annotation . annotationType (  )  ;", "if    (  !  (  . isSynthesizable ( annotationType )  )  )     {", "return   annotation ;", "}", "DefaultAnnotationAttributeExtractor   attributeExtractor    =    new   DefaultAnnotationAttributeExtractor ( annotation ,    annotatedElement )  ;", "InvocationHandler   handler    =    new   SynthesizedAnnotationInvocationHandler ( attributeExtractor )  ;", "Class <  ?  >  [  ]    exposedInterfaces    =    new   Class <  ?  >  [  ]  {    annotationType ,    SynthesizedAnnotation . class    }  ;", "return    (  ( A )     ( Proxy . newProxyInstance ( annotation . getClass (  )  . getClassLoader (  )  ,    exposedInterfaces ,    handler )  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . synthesizeAnnotation ( annotation ,     (  ( Object )     ( annotatedElement )  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   AnnotationUtils . synthesizeAnnotation ( Collections .  < String ,    Object > emptyMap (  )  ,    annotationType ,    null )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "MapAnnotationAttributeExtractor   attributeExtractor    =    new   MapAnnotationAttributeExtractor ( attributes ,    annotationType ,    annotatedElement )  ;", "InvocationHandler   handler    =    new   SynthesizedAnnotationInvocationHandler ( attributeExtractor )  ;", "Class <  ?  >  [  ]    exposedInterfaces    =     (  . canExposeSynthesizedMarker ( annotationType )  )     ?    new   Class <  ?  >  [  ]  {    annotationType ,    SynthesizedAnnotation . class    }     :    new   Class <  ?  >  [  ]  {    annotationType    }  ;", "return    (  ( A )     ( Proxy . newProxyInstance ( annotationType . getClassLoader (  )  ,    exposedInterfaces ,    handler )  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    synthesized    =     (  ( Annotation [  ]  )     ( Array . newInstance ( annotations . getClass (  )  . getComponentType (  )  ,    annotations . length )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( annotations . length )  ;    i +  +  )     {", "synthesized [ i ]     =     . synthesizeAnnotation ( annotations [ i ]  ,    annotatedElement )  ;", "}", "return   synthesized ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationArray"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( maps    =  =    null )     {", "return   null ;", "}", "A [  ]    synthesized    =     (  ( A [  ]  )     ( Array . newInstance ( annotationType ,    maps . length )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( maps . length )  ;    i +  +  )     {", "synthesized [ i ]     =     . synthesizeAnnotation ( maps [ i ]  ,    annotationType ,    null )  ;", "}", "return   synthesized ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationArray"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    AnnotationUtils . getAttributeMethods ( annotation . annotationType (  )  )  )     {", "Class <  ?  >    returnType    =    method . getReturnType (  )  ;", "if    (  ( returnType    =  =     ( Class . class )  )     |  |     ( returnType    =  =     ( Class [  ]  . class )  )  )     {", "try    {", "method . invoke ( annotation )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  \" Could   not   obtain   annotation   attribute   value   for    \"     +    method )  ,    ex )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["validateAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "return   arr ;", "}", "METHOD_END"], "methodName": ["asArray"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    Collections . singletonMap ( attributeNameAndValue ,    attributeNameAndValue )  ;", ". ImplicitAliasesContextConfig   config    =    AnnotationUtils . synthesizeAnnotation ( map ,     . ImplicitAliasesContextConfig . class ,    null )  ;", "assertNotNull ( config )  ;", "assertEquals (  \" value :     \"  ,    attributeNameAndValue ,    config . value (  )  )  ;", "assertEquals (  \" location 1  :     \"  ,    attributeNameAndValue ,    config . location 1  (  )  )  ;", "assertEquals (  \" location 2  :     \"  ,    attributeNameAndValue ,    config . location 2  (  )  )  ;", "assertEquals (  \" location 3  :     \"  ,    attributeNameAndValue ,    config . location 3  (  )  )  ;", "assertEquals (  \" xmlFile :     \"  ,    attributeNameAndValue ,    config . xmlFile (  )  )  ;", "assertEquals (  \" groovyScript :     \"  ,    attributeNameAndValue ,    config . groovyScript (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAnnotationSynthesisFromMapWithImplicitAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . ImplicitAliasesContextConfig   config    =    clazz . getAnnotation ( AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  ;", "assertNotNull ( config )  ;", "AnnotationUtilsTests . ImplicitAliasesContextConfig   synthesizedConfig    =    AnnotationUtils . synthesizeAnnotation ( config )  ;", "assertThat ( synthesizedConfig ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", "assertEquals (  \" value :     \"  ,    expected ,    synthesizedConfig . value (  )  )  ;", "assertEquals (  \" location 1  :     \"  ,    expected ,    synthesizedConfig . location 1  (  )  )  ;", "assertEquals (  \" xmlFile :     \"  ,    expected ,    synthesizedConfig . xmlFile (  )  )  ;", "assertEquals (  \" groovyScript :     \"  ,    expected ,    synthesizedConfig . groovyScript (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAnnotationSynthesisWithImplicitAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig   config    =    clazz . getAnnotation ( AnnotationUtilsTests . ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig . class )  ;", "assertNotNull ( config )  ;", "AnnotationUtilsTests . ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig   synthesizedConfig    =    AnnotationUtils . synthesizeAnnotation ( config )  ;", "assertThat ( synthesizedConfig ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", "assertEquals (  \" value :     \"  ,    expected ,    synthesizedConfig . value (  )  )  ;", "assertEquals (  \" locations :     \"  ,    expected ,    synthesizedConfig . location (  )  )  ;", "assertEquals (  \" xmlFiles :     \"  ,    expected ,    synthesizedConfig . xmlFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Attributes   map \"  )  )  ;", "exception . expectMessage ( containsString (  \" returned   null   for   required   attribute    ' text '  \"  )  )  ;", "exception . expectMessage ( containsString (  (  (  \" defined   by   annotation   type    [  \"     +     (  . AnnotationWithoutDefaults . class . getName (  )  )  )     +     \"  ]  \"  )  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( attributes ,     . AnnotationWithoutDefaults . class ,    null )  ;", "}", "METHOD_END"], "methodName": ["assertMissingTextAttribute"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   string    =    webMapping . toString (  )  ;", "assertThat ( string ,    startsWith (  (  (  \"  @  \"     +     (  . WebMapping . class . getName (  )  )  )     +     \"  (  \"  )  )  )  ;", "assertThat ( string ,    containsString (  \" value =  [  / test ]  \"  )  )  ;", "assertThat ( string ,    containsString (  \" path =  [  / test ]  \"  )  )  ;", "assertThat ( string ,    containsString (  \" name = bar \"  )  )  ;", "assertThat ( string ,    containsString (  \" method =  \"  )  )  ;", "assertThat ( string ,    containsString (  \"  [ GET ,    POST ]  \"  )  )  ;", "assertThat ( string ,    endsWith (  \"  )  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertToStringForWebMappingWithPathAndValue"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtils . clearCache (  )  ;", "}", "METHOD_END"], "methodName": ["clearCacheBeforeTests"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   methodWithPath    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithPathAttribute \"  )  ;", "AnnotationUtilsTests . WebMapping   webMappingWithAliases    =    methodWithPath . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "assertNotNull ( webMappingWithAliases )  ;", "Method   methodWithPathAndValue    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithSamePathAndValueAttributes \"  )  ;", "AnnotationUtilsTests . WebMapping   webMappingWithPathAndValue    =    methodWithPathAndValue . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "assertNotNull ( webMappingWithPathAndValue )  ;", "AnnotationUtilsTests . WebMapping   synthesizedWebMapping 1     =    AnnotationUtils . synthesizeAnnotation ( webMappingWithAliases )  ;", "assertNotNull ( synthesizedWebMapping 1  )  ;", "AnnotationUtilsTests . WebMapping   synthesizedWebMapping 2     =    AnnotationUtils . synthesizeAnnotation ( webMappingWithAliases )  ;", "assertNotNull ( synthesizedWebMapping 2  )  ;", "assertThat ( webMappingWithAliases ,    is ( webMappingWithAliases )  )  ;", "assertThat ( webMappingWithPathAndValue ,    is ( webMappingWithPathAndValue )  )  ;", "assertThat ( webMappingWithAliases ,    is ( not ( webMappingWithPathAndValue )  )  )  ;", "assertThat ( webMappingWithPathAndValue ,    is ( not ( webMappingWithAliases )  )  )  ;", "assertThat ( synthesizedWebMapping 1  ,    is ( synthesizedWebMapping 1  )  )  ;", "assertThat ( synthesizedWebMapping 2  ,    is ( synthesizedWebMapping 2  )  )  ;", "assertThat ( synthesizedWebMapping 1  ,    is ( synthesizedWebMapping 2  )  )  ;", "assertThat ( synthesizedWebMapping 2  ,    is ( synthesizedWebMapping 1  )  )  ;", "assertThat ( synthesizedWebMapping 1  ,    is ( webMappingWithPathAndValue )  )  ;", "assertThat ( webMappingWithPathAndValue ,    is ( synthesizedWebMapping 1  )  )  ;", "assertThat ( synthesizedWebMapping 1  ,    is ( not ( webMappingWithAliases )  )  )  ;", "assertThat ( webMappingWithAliases ,    is ( not ( synthesizedWebMapping 1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equalsForSynthesizedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( AnnotationUtils . findAnnotationDeclaringClass ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . NonAnnotatedInterface . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClass ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . NonAnnotatedClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . InheritedAnnotationInterface . class ,    AnnotationUtils . findAnnotationDeclaringClass ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . InheritedAnnotationInterface . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClass ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . SubInheritedAnnotationInterface . class )  )  ;", "assertEquals ( AnnotationUtilsTests . InheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClass ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . InheritedAnnotationClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . InheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClass ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . SubInheritedAnnotationClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    AnnotationUtils . findAnnotationDeclaringClass ( Order . class ,    AnnotationUtilsTests . NonInheritedAnnotationInterface . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClass ( Order . class ,    AnnotationUtilsTests . SubNonInheritedAnnotationInterface . class )  )  ;", "assertEquals ( AnnotationUtilsTests . NonInheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClass ( Order . class ,    AnnotationUtilsTests . NonInheritedAnnotationClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . NonInheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClass ( Order . class ,    AnnotationUtilsTests . SubNonInheritedAnnotationClass . class )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDeclaringClassForAllScenarios"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?    extends   Annotation >  >    candidates    =    Arrays . asList ( AnnotationUtilsTests . Transactional . class ,    Order . class )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . NonAnnotatedInterface . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . NonAnnotatedClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . InheritedAnnotationInterface . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . InheritedAnnotationInterface . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . SubInheritedAnnotationInterface . class )  )  ;", "assertEquals ( AnnotationUtilsTests . InheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . InheritedAnnotationClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . InheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . SubInheritedAnnotationClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . NonInheritedAnnotationInterface . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . SubNonInheritedAnnotationInterface . class )  )  ;", "assertEquals ( AnnotationUtilsTests . NonInheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . NonInheritedAnnotationClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . NonInheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . SubNonInheritedAnnotationClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . TransactionalClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . TransactionalClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . TransactionalAndOrderedClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . TransactionalAndOrderedClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . TransactionalAndOrderedClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( candidates ,    AnnotationUtilsTests . SubTransactionalAndOrderedClass . class )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?    extends   Annotation >  >    transactionalCandidateList    =    Collections . singletonList ( AnnotationUtilsTests . Transactional . class )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClassForTypes ( transactionalCandidateList ,    AnnotationUtilsTests . NonAnnotatedInterface . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClassForTypes ( transactionalCandidateList ,    AnnotationUtilsTests . NonAnnotatedClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . InheritedAnnotationInterface . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( transactionalCandidateList ,    AnnotationUtilsTests . InheritedAnnotationInterface . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClassForTypes ( transactionalCandidateList ,    AnnotationUtilsTests . SubInheritedAnnotationInterface . class )  )  ;", "assertEquals ( AnnotationUtilsTests . InheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( transactionalCandidateList ,    AnnotationUtilsTests . InheritedAnnotationClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . InheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( transactionalCandidateList ,    AnnotationUtilsTests . SubInheritedAnnotationClass . class )  )  ;", "List < Class <  ?    extends   Annotation >  >    orderCandidateList    =    Collections . singletonList ( Order . class )  ;", "assertEquals ( AnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( orderCandidateList ,    AnnotationUtilsTests . NonInheritedAnnotationInterface . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotationDeclaringClassForTypes ( orderCandidateList ,    AnnotationUtilsTests . SubNonInheritedAnnotationInterface . class )  )  ;", "assertEquals ( AnnotationUtilsTests . NonInheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( orderCandidateList ,    AnnotationUtilsTests . NonInheritedAnnotationClass . class )  )  ;", "assertEquals ( AnnotationUtilsTests . NonInheritedAnnotationClass . class ,    AnnotationUtils . findAnnotationDeclaringClassForTypes ( orderCandidateList ,    AnnotationUtilsTests . SubNonInheritedAnnotationClass . class )  )  ;", "}", "METHOD_END"], "methodName": ["findAnnotationDeclaringClassForTypesWithSingleCandidateType"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface . class ,    Component . class )  ;", "assertNotNull ( component )  ;", "assertEquals (  \" meta 2  \"  ,    component . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . Transactional   transactional    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . SubSubClassWithInheritedAnnotation . class ,    AnnotationUtilsTests . Transactional . class )  ;", "assertNotNull ( transactional )  ;", "assertTrue (  \" readOnly   flag   for   SubSubClassWithInheritedAnnotation \"  ,    transactional . readOnly (  )  )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . SubSubClassWithInheritedMetaAnnotation . class ,    Component . class )  ;", "assertNotNull ( component )  ;", "assertEquals (  \" meta 2  \"  ,    component . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . TransactionalClass . class ,    Component . class )  ;", "assertNull (  \" Should   not   find    @ Component   on   TransactionalClass \"  ,    component )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . Transactional   tx    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . InheritedAnnotationInterface . class ,    AnnotationUtilsTests . Transactional . class )  ;", "assertNotNull (  \" Should   find    @ Transactional   on   InheritedAnnotationInterface \"  ,    tx )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . MetaCycleAnnotatedClass . class ,    Component . class )  ;", "assertNull (  \" Should   not   find    @ Component   on   MetaCycleAnnotatedClass \"  ,    component )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . MetaMetaAnnotatedClass . class ,    Component . class )  ;", "assertNotNull (  \" Should   find   meta - annotation   on   composed   annotation   on   class \"  ,    component )  ;", "assertEquals (  \" meta 2  \"  ,    component . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnMetaMetaAnnotatedClass"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . MetaMetaMetaAnnotatedClass . class ,    Component . class )  ;", "assertNotNull (  \" Should   find   meta - annotation   on   meta - annotation   on   composed   annotation   on   class \"  ,    component )  ;", "assertEquals (  \" meta 2  \"  ,    component . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnMetaMetaMetaAnnotatedClass"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Order   order    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . NonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull (  \" Should   find    @ Order   on   NonInheritedAnnotationInterface \"  ,    order )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnNonInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . Transactional   tx    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . SubInheritedAnnotationInterface . class ,    AnnotationUtilsTests . Transactional . class )  ;", "assertNotNull (  \" Should   find    @ Transactional   on   SubInheritedAnnotationInterface \"  ,    tx )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnSubInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Order   order    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . SubNonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull (  \" Should   find    @ Order   on   SubNonInheritedAnnotationInterface \"  ,    order )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnSubNonInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . Transactional   tx    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . SubSubInheritedAnnotationInterface . class ,    AnnotationUtilsTests . Transactional . class )  ;", "assertNotNull (  \" Should   find    @ Transactional   on   SubSubInheritedAnnotationInterface \"  ,    tx )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnSubSubInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Order   order    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . SubSubNonInheritedAnnotationInterface . class ,    Order . class )  ;", "assertNotNull (  \" Should   find    @ Order   on   SubSubNonInheritedAnnotationInterface \"  ,    order )  ;", "}", "METHOD_END"], "methodName": ["findClassAnnotationOnSubSubNonInheritedAnnotationInterface"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationUtilsTests . ImplementsInterfaceWithAnnotatedMethod . class . getMethod (  \" foo \"  )  ;", "Order   order    =    AnnotationUtils . findAnnotation ( method ,    Order . class )  ;", "assertNotNull ( order )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationFromInterface"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationUtilsTests . SubOfImplementsInterfaceWithAnnotatedMethod . class . getMethod (  \" foo \"  )  ;", "Order   order    =    AnnotationUtils . findAnnotation ( method ,    Order . class )  ;", "assertNotNull ( order )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationFromInterfaceOnSuper"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationUtilsTests . SubOfAbstractImplementsInterfaceWithAnnotatedMethod . class . getMethod (  \" foo \"  )  ;", "Order   order    =    AnnotationUtils . findAnnotation ( method ,    Order . class )  ;", "assertNotNull ( order )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotationUtilsTests . Leaf . class . getMethod (  \" notAnnotated \"  )  ;", "assertNull ( AnnotationUtils . findAnnotation ( m ,    Order . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationNotAnnotated"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgeMethod    =    AnnotationUtilsTests . SimpleFoo . class . getMethod (  \" something \"  ,    Object . class )  ;", "assertTrue ( bridgeMethod . isBridge (  )  )  ;", "assertNull ( bridgeMethod . getAnnotation ( Order . class )  )  ;", "assertNull ( AnnotationUtils . getAnnotation ( bridgeMethod ,    Order . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( bridgeMethod ,    Order . class )  )  ;", "assertNotNull ( AnnotationUtils . getAnnotation ( bridgeMethod ,    AnnotationUtilsTests . Transactional . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( bridgeMethod ,    AnnotationUtilsTests . Transactional . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationOnBridgeMethod"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   bridgedMethod    =    AnnotationUtilsTests . SimpleFoo . class . getMethod (  \" something \"  ,    String . class )  ;", "assertFalse ( bridgedMethod . isBridge (  )  )  ;", "assertNull ( bridgedMethod . getAnnotation ( Order . class )  )  ;", "assertNull ( AnnotationUtils . getAnnotation ( bridgedMethod ,    Order . class )  )  ;", "assertNull ( AnnotationUtils . findAnnotation ( bridgedMethod ,    Order . class )  )  ;", "assertNotNull ( bridgedMethod . getAnnotation ( AnnotationUtilsTests . Transactional . class )  )  ;", "assertNotNull ( AnnotationUtils . getAnnotation ( bridgedMethod ,    AnnotationUtilsTests . Transactional . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( bridgedMethod ,    AnnotationUtilsTests . Transactional . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationOnBridgedMethod"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotationUtilsTests . Leaf . class . getMethod (  \" annotatedOnLeaf \"  )  ;", "assertNotNull ( m . getAnnotation ( Order . class )  )  ;", "assertNotNull ( AnnotationUtils . getAnnotation ( m ,    Order . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( m ,    Order . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationOnLeaf"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotationUtilsTests . Leaf . class . getMethod (  \" annotatedOnRoot \"  )  ;", "assertNotNull ( m . getAnnotation ( Order . class )  )  ;", "assertNotNull ( AnnotationUtils . getAnnotation ( m ,    Order . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( m ,    Order . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationOnRoot"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotationUtilsTests . Leaf . class . getMethod (  \" overrideWithoutNewAnnotation \"  )  ;", "assertNull ( m . getAnnotation ( Order . class )  )  ;", "assertNull ( AnnotationUtils . getAnnotation ( m ,    Order . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( m ,    Order . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationOnRootButOverridden"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotationUtilsTests . Leaf . class . getMethod (  \" fromInterfaceImplementedByRoot \"  )  ;", "assertNull ( m . getAnnotation ( Order . class )  )  ;", "assertNull ( AnnotationUtils . getAnnotation ( m ,    Order . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( m ,    Order . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationWithAnnotationOnMethodInInterface"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotationUtilsTests . Leaf . class . getMethod (  \" metaAnnotatedOnLeaf \"  )  ;", "assertNull ( m . getAnnotation ( Order . class )  )  ;", "assertNotNull ( AnnotationUtils . getAnnotation ( m ,    Order . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( m ,    Order . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationWithMetaAnnotationOnLeaf"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotationUtilsTests . Leaf . class . getMethod (  \" metaAnnotatedOnRoot \"  )  ;", "assertNull ( m . getAnnotation ( Order . class )  )  ;", "assertNotNull ( AnnotationUtils . getAnnotation ( m ,    Order . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( m ,    Order . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationWithMetaAnnotationOnRoot"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   m    =    AnnotationUtilsTests . Leaf . class . getMethod (  \" metaMetaAnnotatedOnLeaf \"  )  ;", "assertNull ( m . getAnnotation ( Component . class )  )  ;", "assertNull ( AnnotationUtils . getAnnotation ( m ,    Component . class )  )  ;", "assertNotNull ( AnnotationUtils . findAnnotation ( m ,    Component . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodAnnotationWithMetaMetaAnnotationOnLeaf"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Repeatable   repeatable    =    AnnotationUtils . findAnnotation ( AnnotationUtilsTests . MyRepeatableMeta 1  . class ,    Repeatable . class )  ;", "assertNotNull ( repeatable )  ;", "assertEquals ( AnnotationUtilsTests . MyRepeatableContainer . class ,    repeatable . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["findRepeatableAnnotationOnComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithValueAttribute \"  )  ;", "AnnotationUtilsTests . WebMapping   webMapping    =    method . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "AnnotationAttributes   attributes    =     (  ( AnnotationAttributes )     ( AnnotationUtils . getAnnotationAttributes ( webMapping )  )  )  ;", "assertNotNull ( attributes )  ;", "assertEquals ( AnnotationUtilsTests . WebMapping . class ,    attributes . annotationType (  )  )  ;", "assertEquals (  \" name   attribute :     \"  ,     \" foo \"  ,    attributes . getString (  \" name \"  )  )  ;", "assertArrayEquals (  \" value   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    attributes . getStringArray ( AnnotationUtils . VALUE )  )  ;", "assertArrayEquals (  \" path   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    attributes . getStringArray (  \" path \"  )  )  ;", "method    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithPathAttribute \"  )  ;", "webMapping    =    method . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "attributes    =     (  ( AnnotationAttributes )     ( AnnotationUtils . getAnnotationAttributes ( webMapping )  )  )  ;", "assertNotNull ( attributes )  ;", "assertEquals ( AnnotationUtilsTests . WebMapping . class ,    attributes . annotationType (  )  )  ;", "assertEquals (  \" name   attribute :     \"  ,     \" bar \"  ,    attributes . getString (  \" name \"  )  )  ;", "assertArrayEquals (  \" value   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    attributes . getStringArray ( AnnotationUtils . VALUE )  )  ;", "assertArrayEquals (  \" path   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    attributes . getStringArray (  \" path \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributesWithAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( containsString (  \" attribute    ' value '    and   its   alias    ' path '  \"  )  )  ;", "exception . expectMessage ( containsString (  \" values   of    [  {  / enigma }  ]    and    [  {  / test }  ]  \"  )  )  ;", "Method   method    =     . WebController . class . getMethod (  \" handleMappedWithDifferentPathAndValueAttributes \"  )  ;", ". WebMapping   webMapping    =    method . getAnnotation (  . WebMapping . class )  ;", "AnnotationUtils . getAnnotationAttributes ( webMapping )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributesWithAttributeAliasesWithDifferentValues"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . ComponentScan   componentScan    =    AnnotationUtilsTests . ComponentScanClass . class . getAnnotation ( AnnotationUtilsTests . ComponentScan . class )  ;", "assertNotNull ( componentScan )  ;", "AnnotationAttributes   attributes    =    AnnotationUtils . getAnnotationAttributes ( AnnotationUtilsTests . ComponentScanClass . class ,    componentScan )  ;", "assertNotNull ( attributes )  ;", "assertEquals ( AnnotationUtilsTests . ComponentScan . class ,    attributes . annotationType (  )  )  ;", "AnnotationUtilsTests . Filter [  ]    filters    =    attributes . getAnnotationArray (  \" excludeFilters \"  ,    AnnotationUtilsTests . Filter . class )  ;", "assertNotNull ( filters )  ;", "List < String >    patterns    =    Arrays . stream ( filters )  . map ( AnnotationUtilsTests . Filter :  : pattern )  . collect ( Collectors . toList (  )  )  ;", "assertEquals ( Arrays . asList (  \"  * Foo \"  ,     \"  * Bar \"  )  ,    patterns )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributesWithNestedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtilsTests . WebController . class . getAnnotation ( Component . class )  ;", "assertNotNull ( component )  ;", "AnnotationAttributes   attributes    =     (  ( AnnotationAttributes )     ( AnnotationUtils . getAnnotationAttributes ( component )  )  )  ;", "assertNotNull ( attributes )  ;", "assertEquals (  \" value   attribute :     \"  ,     \" webController \"  ,    attributes . getString ( AnnotationUtils . VALUE )  )  ;", "assertEquals ( Component . class ,    attributes . annotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationAttributesWithoutAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   xmlFile    =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" xmlFile \"  )  ;", "Method   groovyScript    =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" groovyScript \"  )  ;", "Method   value    =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" value \"  )  ;", "Method   location 1     =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" location 1  \"  )  ;", "Method   location 2     =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" location 2  \"  )  ;", "Method   location 3     =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" location 3  \"  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( xmlFile ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( groovyScript ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( value ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( xmlFile )  ,    containsInAnyOrder (  \" value \"  ,     \" groovyScript \"  ,     \" location 1  \"  ,     \" location 2  \"  ,     \" location 3  \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( groovyScript )  ,    containsInAnyOrder (  \" value \"  ,     \" xmlFile \"  ,     \" location 1  \"  ,     \" location 2  \"  ,     \" location 3  \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( value )  ,    containsInAnyOrder (  \" xmlFile \"  ,     \" groovyScript \"  ,     \" location 1  \"  ,     \" location 2  \"  ,     \" location 3  \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( location 1  )  ,    containsInAnyOrder (  \" xmlFile \"  ,     \" groovyScript \"  ,     \" value \"  ,     \" location 2  \"  ,     \" location 3  \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( location 2  )  ,    containsInAnyOrder (  \" xmlFile \"  ,     \" groovyScript \"  ,     \" value \"  ,     \" location 1  \"  ,     \" location 3  \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( location 3  )  ,    containsInAnyOrder (  \" xmlFile \"  ,     \" groovyScript \"  ,     \" value \"  ,     \" location 1  \"  ,     \" location 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeAliasNamesFromComposedAnnotationWithImplicitAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   xmlFile    =    AnnotationUtilsTests . ImplicitAliasesForAliasPairContextConfig . class . getDeclaredMethod (  \" xmlFile \"  )  ;", "Method   groovyScript    =    AnnotationUtilsTests . ImplicitAliasesForAliasPairContextConfig . class . getDeclaredMethod (  \" groovyScript \"  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( xmlFile ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertEquals (  \" value \"  ,    AnnotationUtils . getAttributeOverrideName ( groovyScript ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( xmlFile )  ,    containsInAnyOrder (  \" groovyScript \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( groovyScript )  ,    containsInAnyOrder (  \" xmlFile \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeAliasNamesFromComposedAnnotationWithImplicitAliasesForAliasPair"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   value    =    AnnotationUtilsTests . ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig . class . getDeclaredMethod (  \" value \"  )  ;", "Method   location    =    AnnotationUtilsTests . ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig . class . getDeclaredMethod (  \" location \"  )  ;", "Method   xmlFile    =    AnnotationUtilsTests . ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig . class . getDeclaredMethod (  \" xmlFile \"  )  ;", "assertEquals (  \" value \"  ,    AnnotationUtils . getAttributeOverrideName ( value ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( location ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( xmlFile ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( value )  ,    containsInAnyOrder (  \" location \"  ,     \" xmlFile \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( location )  ,    containsInAnyOrder (  \" value \"  ,     \" xmlFile \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( xmlFile )  ,    containsInAnyOrder (  \" value \"  ,     \" location \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeAliasNamesFromComposedAnnotationWithImplicitAliasesWithImpliedAliasNamesOmitted"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   xml    =    AnnotationUtilsTests . TransitiveImplicitAliasesContextConfig . class . getDeclaredMethod (  \" xml \"  )  ;", "Method   groovy    =    AnnotationUtilsTests . TransitiveImplicitAliasesContextConfig . class . getDeclaredMethod (  \" groovy \"  )  ;", "assertEquals (  \" xmlFile \"  ,    AnnotationUtils . getAttributeOverrideName ( xml ,    AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  )  ;", "assertEquals (  \" groovyScript \"  ,    AnnotationUtils . getAttributeOverrideName ( groovy ,    AnnotationUtilsTests . ImplicitAliasesContextConfig . class )  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( xml ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( groovy ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( xml )  ,    containsInAnyOrder (  \" groovy \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( groovy )  ,    containsInAnyOrder (  \" xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeAliasNamesFromComposedAnnotationWithTransitiveImplicitAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   xml    =    AnnotationUtilsTests . TransitiveImplicitAliasesForAliasPairContextConfig . class . getDeclaredMethod (  \" xml \"  )  ;", "Method   groovy    =    AnnotationUtilsTests . TransitiveImplicitAliasesForAliasPairContextConfig . class . getDeclaredMethod (  \" groovy \"  )  ;", "assertEquals (  \" xmlFile \"  ,    AnnotationUtils . getAttributeOverrideName ( xml ,    AnnotationUtilsTests . ImplicitAliasesForAliasPairContextConfig . class )  )  ;", "assertEquals (  \" groovyScript \"  ,    AnnotationUtils . getAttributeOverrideName ( groovy ,    AnnotationUtilsTests . ImplicitAliasesForAliasPairContextConfig . class )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( xml )  ,    containsInAnyOrder (  \" groovy \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( groovy )  ,    containsInAnyOrder (  \" xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeAliasNamesFromComposedAnnotationWithTransitiveImplicitAliasesForAliasPair"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   xml    =    AnnotationUtilsTests . TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig . class . getDeclaredMethod (  \" xml \"  )  ;", "Method   groovy    =    AnnotationUtilsTests . TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig . class . getDeclaredMethod (  \" groovy \"  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( xml ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( groovy ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "assertEquals (  \" xmlFile \"  ,    AnnotationUtils . getAttributeOverrideName ( xml ,    AnnotationUtilsTests . ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig . class )  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( groovy ,    AnnotationUtilsTests . ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig . class )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( groovy )  ,    containsInAnyOrder (  \" xml \"  )  )  ;", "assertThat ( AnnotationUtils . getAttributeAliasNames ( xml )  ,    containsInAnyOrder (  \" groovy \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeAliasNamesFromComposedAnnotationWithTransitiveImplicitAliasesWithImpliedAliasNamesOmitted"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   nonAliasedAttribute    =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class . getDeclaredMethod (  \" nonAliasedAttribute \"  )  ;", "assertThat ( AnnotationUtils . getAttributeOverrideName ( nonAliasedAttribute ,    AnnotationUtilsTests . ContextConfig . class )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeOverrideNameForNonAliasedAttribute"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   attribute    =    AnnotationUtilsTests . AliasedComposedContextConfig . class . getDeclaredMethod (  \" xmlConfigFile \"  )  ;", "assertEquals (  \" location \"  ,    AnnotationUtils . getAttributeOverrideName ( attribute ,    AnnotationUtilsTests . ContextConfig . class )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeOverrideNameFromAliasedComposedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   attribute    =    AnnotationUtilsTests . AliasedComposedContextConfig . class . getDeclaredMethod (  \" xmlConfigFile \"  )  ;", "assertThat (  \" xmlConfigFile   is   not   an   alias   for    @ Component .  \"  ,    AnnotationUtils . getAttributeOverrideName ( attribute ,    Component . class )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeOverrideNameFromWrongTargetAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    expectedValuesJava    =    Arrays . asList (  \" A \"  ,     \" B \"  ,     \" C \"  )  ;", "final   List < String >    expectedValuesSpring    =    Arrays . asList (  \" A \"  ,     \" B \"  ,     \" C \"  ,     \" meta 1  \"  )  ;", ". MyRepeatable [  ]    array    =     . MyRepeatableClass . class . getDeclaredAnnotationsByType (  . MyRepeatable . class )  ;", "assertNotNull ( array )  ;", "List < String >    values    =    Arrays . stream ( array )  . map (  . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesJava )  )  ;", "Set <  . MyRepeatable >    set    =    AnnotationUtils . getDeclaredRepeatableAnnotations (  . MyRepeatableClass . class ,     . MyRepeatable . class ,     . MyRepeatableContainer . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map (  . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "set    =    AnnotationUtils . getDeclaredRepeatableAnnotations (  . MyRepeatableClass . class ,     . MyRepeatable . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map (  . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredRepeatableAnnotationsDeclaredOnClass"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    clazz    =    AnnotationUtilsTests . SubMyRepeatableClass . class ;", "AnnotationUtilsTests . MyRepeatable [  ]    array    =    clazz . getDeclaredAnnotationsByType ( AnnotationUtilsTests . MyRepeatable . class )  ;", "assertNotNull ( array )  ;", "assertThat ( array . length ,    is (  0  )  )  ;", "Set < AnnotationUtilsTests . MyRepeatable >    set    =    AnnotationUtils . getDeclaredRepeatableAnnotations ( clazz ,    AnnotationUtilsTests . MyRepeatable . class ,    AnnotationUtilsTests . MyRepeatableContainer . class )  ;", "assertNotNull ( set )  ;", "assertThat ( set . size (  )  ,    is (  0  )  )  ;", "set    =    AnnotationUtils . getDeclaredRepeatableAnnotations ( clazz ,    AnnotationUtilsTests . MyRepeatable . class )  ;", "assertNotNull ( set )  ;", "assertThat ( set . size (  )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredRepeatableAnnotationsDeclaredOnSuperclass"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationUtilsTests . SimpleFoo . class . getMethod (  \" something \"  ,    Object . class )  ;", "Order   order    =    AnnotationUtils . findAnnotation ( method ,    Order . class )  ;", "assertEquals ( Ordered . LOWEST _ PRECEDENCE ,    AnnotationUtils . getDefaultValue ( order ,    AnnotationUtils . VALUE )  )  ;", "assertEquals ( Ordered . LOWEST _ PRECEDENCE ,    AnnotationUtils . getDefaultValue ( order )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultValueFromAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Ordered . LOWEST _ PRECEDENCE ,    AnnotationUtils . getDefaultValue ( Order . class ,    AnnotationUtils . VALUE )  )  ;", "assertEquals ( Ordered . LOWEST _ PRECEDENCE ,    AnnotationUtils . getDefaultValue ( Order . class )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultValueFromAnnotationType"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    declaredAnnotations    =    NonPublicAnnotatedClass . class . getDeclaredAnnotations (  )  ;", "assertEquals (  1  ,    declaredAnnotations . length )  ;", "Annotation   annotation    =    declaredAnnotations [  0  ]  ;", "assertNotNull ( annotation )  ;", "assertEquals (  \" NonPublicAnnotation \"  ,    annotation . annotationType (  )  . getSimpleName (  )  )  ;", "assertEquals (  (  -  1  )  ,     . getDefaultValue ( annotation ,     . VALUE )  )  ;", "assertEquals (  (  -  1  )  ,     . getDefaultValue ( annotation )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultValueFromNonPublicAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    expectedValuesJava    =    Arrays . asList (  \" A \"  ,     \" B \"  ,     \" C \"  )  ;", "final   List < String >    expectedValuesSpring    =    Arrays . asList (  \" A \"  ,     \" B \"  ,     \" C \"  ,     \" meta 1  \"  )  ;", ". MyRepeatable [  ]    array    =     . MyRepeatableClass . class . getAnnotationsByType (  . MyRepeatable . class )  ;", "assertNotNull ( array )  ;", "List < String >    values    =    Arrays . stream ( array )  . map (  . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesJava )  )  ;", "Set <  . MyRepeatable >    set    =    AnnotationUtils . getRepeatableAnnotations (  . MyRepeatableClass . class ,     . MyRepeatable . class ,     . MyRepeatableContainer . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map (  . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "set    =    AnnotationUtils . getRepeatableAnnotations (  . MyRepeatableClass . class ,     . MyRepeatable . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map (  . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotationsDeclaredOnClass"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    clazz    =    AnnotationUtilsTests . SubMyRepeatableWithAdditionalLocalDeclarationsClass . class ;", "final   List < String >    expectedValuesJava    =    Arrays . asList (  \" X \"  ,     \" Y \"  ,     \" Z \"  )  ;", "final   List < String >    expectedValuesSpring    =    Arrays . asList (  \" X \"  ,     \" Y \"  ,     \" Z \"  ,     \" meta 2  \"  )  ;", "AnnotationUtilsTests . MyRepeatable [  ]    array    =    clazz . getAnnotationsByType ( AnnotationUtilsTests . MyRepeatable . class )  ;", "assertNotNull ( array )  ;", "List < String >    values    =    Arrays . stream ( array )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesJava )  )  ;", "Set < AnnotationUtilsTests . MyRepeatable >    set    =    AnnotationUtils . getRepeatableAnnotations ( clazz ,    AnnotationUtilsTests . MyRepeatable . class ,    AnnotationUtilsTests . MyRepeatableContainer . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "set    =    AnnotationUtils . getRepeatableAnnotations ( clazz ,    AnnotationUtilsTests . MyRepeatable . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotationsDeclaredOnClassAndSuperclass"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    expectedLocations    =    Arrays . asList (  \" A \"  ,     \" B \"  )  ;", "Set <  . ContextConfig >    annotations    =    AnnotationUtils . getRepeatableAnnotations (  . ConfigHierarchyTestCase . class ,     . ContextConfig . class ,    null )  ;", "assertNotNull ( annotations )  ;", "assertEquals (  \" size   if   container   type   is   omitted :     \"  ,     0  ,    annotations . size (  )  )  ;", "annotations    =    AnnotationUtils . getRepeatableAnnotations (  . ConfigHierarchyTestCase . class ,     . ContextConfig . class ,     . Hierarchy . class )  ;", "assertNotNull ( annotations )  ;", "List < String >    locations    =    annotations . stream (  )  . map (  . ContextConfig :  : location )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( locations ,    is ( expectedLocations )  )  ;", "List < String >    values    =    annotations . stream (  )  . map (  . ContextConfig :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedLocations )  )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Attribute    ' value '    in \"  )  )  ;", "exception . expectMessage ( containsString (  . BrokenContextConfig . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \"  @ AliasFor    [ location ]  \"  )  )  ;", "AnnotationUtils . getRepeatableAnnotations (  . BrokenConfigHierarchyTestCase . class ,     . BrokenContextConfig . class ,     . BrokenHierarchy . class )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotationsDeclaredOnClassWithMissingAttributeAliasDeclaration"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationUtilsTests . InterfaceWithRepeated . class . getMethod (  \" foo \"  )  ;", "Set < AnnotationUtilsTests . MyRepeatable >    annotations    =    AnnotationUtils . getRepeatableAnnotations ( method ,    AnnotationUtilsTests . MyRepeatable . class ,    AnnotationUtilsTests . MyRepeatableContainer . class )  ;", "assertNotNull ( annotations )  ;", "List < String >    values    =    annotations . stream (  )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( Arrays . asList (  \" A \"  ,     \" B \"  ,     \" C \"  ,     \" meta 1  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotationsDeclaredOnMethod"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    clazz    =    AnnotationUtilsTests . SubSubMyRepeatableWithAdditionalLocalDeclarationsClass . class ;", "final   List < String >    expectedValuesJava    =    Arrays . asList (  \" X \"  ,     \" Y \"  ,     \" Z \"  )  ;", "final   List < String >    expectedValuesSpring    =    Arrays . asList (  \" X \"  ,     \" Y \"  ,     \" Z \"  ,     \" meta 2  \"  )  ;", "AnnotationUtilsTests . MyRepeatable [  ]    array    =    clazz . getAnnotationsByType ( AnnotationUtilsTests . MyRepeatable . class )  ;", "assertNotNull ( array )  ;", "List < String >    values    =    Arrays . stream ( array )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesJava )  )  ;", "Set < AnnotationUtilsTests . MyRepeatable >    set    =    AnnotationUtils . getRepeatableAnnotations ( clazz ,    AnnotationUtilsTests . MyRepeatable . class ,    AnnotationUtilsTests . MyRepeatableContainer . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "set    =    AnnotationUtils . getRepeatableAnnotations ( clazz ,    AnnotationUtilsTests . MyRepeatable . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotationsDeclaredOnMultipleSuperclasses"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    clazz    =    AnnotationUtilsTests . SubMyRepeatableClass . class ;", "final   List < String >    expectedValuesJava    =    Arrays . asList (  \" A \"  ,     \" B \"  ,     \" C \"  )  ;", "final   List < String >    expectedValuesSpring    =    Arrays . asList (  \" A \"  ,     \" B \"  ,     \" C \"  ,     \" meta 1  \"  )  ;", "AnnotationUtilsTests . MyRepeatable [  ]    array    =    clazz . getAnnotationsByType ( AnnotationUtilsTests . MyRepeatable . class )  ;", "assertNotNull ( array )  ;", "List < String >    values    =    Arrays . stream ( array )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesJava )  )  ;", "Set < AnnotationUtilsTests . MyRepeatable >    set    =    AnnotationUtils . getRepeatableAnnotations ( clazz ,    AnnotationUtilsTests . MyRepeatable . class ,    AnnotationUtilsTests . MyRepeatableContainer . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "set    =    AnnotationUtils . getRepeatableAnnotations ( clazz ,    AnnotationUtilsTests . MyRepeatable . class )  ;", "assertNotNull ( set )  ;", "values    =    set . stream (  )  . map ( AnnotationUtilsTests . MyRepeatable :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedValuesSpring )  )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotationsDeclaredOnSuperclass"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationUtilsTests . SimpleFoo . class . getMethod (  \" something \"  ,    Object . class )  ;", "Order   order    =    AnnotationUtils . findAnnotation ( method ,    Order . class )  ;", "assertEquals (  1  ,    AnnotationUtils . getValue ( order ,    AnnotationUtils . VALUE )  )  ;", "assertEquals (  1  ,    AnnotationUtils . getValue ( order )  )  ;", "}", "METHOD_END"], "methodName": ["getValueFromAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    declaredAnnotations    =    NonPublicAnnotatedClass . class . getDeclaredAnnotations (  )  ;", "assertEquals (  1  ,    declaredAnnotations . length )  ;", "Annotation   annotation    =    declaredAnnotations [  0  ]  ;", "assertNotNull ( annotation )  ;", "assertEquals (  \" NonPublicAnnotation \"  ,    annotation . annotationType (  )  . getSimpleName (  )  )  ;", "assertEquals (  4  2  ,     . getValue ( annotation ,     . VALUE )  )  ;", "assertEquals (  4  2  ,     . getValue ( annotation )  )  ;", "}", "METHOD_END"], "methodName": ["getValueFromNonPublicAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   methodWithPath    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithPathAttribute \"  )  ;", "AnnotationUtilsTests . WebMapping   webMappingWithAliases    =    methodWithPath . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "assertNotNull ( webMappingWithAliases )  ;", "Method   methodWithPathAndValue    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithSamePathAndValueAttributes \"  )  ;", "AnnotationUtilsTests . WebMapping   webMappingWithPathAndValue    =    methodWithPathAndValue . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "assertNotNull ( webMappingWithPathAndValue )  ;", "AnnotationUtilsTests . WebMapping   synthesizedWebMapping 1     =    AnnotationUtils . synthesizeAnnotation ( webMappingWithAliases )  ;", "assertNotNull ( synthesizedWebMapping 1  )  ;", "AnnotationUtilsTests . WebMapping   synthesizedWebMapping 2     =    AnnotationUtils . synthesizeAnnotation ( webMappingWithAliases )  ;", "assertNotNull ( synthesizedWebMapping 2  )  ;", "assertThat ( webMappingWithAliases . hashCode (  )  ,    is ( webMappingWithAliases . hashCode (  )  )  )  ;", "assertThat ( webMappingWithPathAndValue . hashCode (  )  ,    is ( webMappingWithPathAndValue . hashCode (  )  )  )  ;", "assertThat ( webMappingWithAliases . hashCode (  )  ,    is ( not ( webMappingWithPathAndValue . hashCode (  )  )  )  )  ;", "assertThat ( webMappingWithPathAndValue . hashCode (  )  ,    is ( not ( webMappingWithAliases . hashCode (  )  )  )  )  ;", "assertThat ( synthesizedWebMapping 1  . hashCode (  )  ,    is ( synthesizedWebMapping 1  . hashCode (  )  )  )  ;", "assertThat ( synthesizedWebMapping 2  . hashCode (  )  ,    is ( synthesizedWebMapping 2  . hashCode (  )  )  )  ;", "assertThat ( synthesizedWebMapping 1  . hashCode (  )  ,    is ( synthesizedWebMapping 2  . hashCode (  )  )  )  ;", "assertThat ( synthesizedWebMapping 2  . hashCode (  )  ,    is ( synthesizedWebMapping 1  . hashCode (  )  )  )  ;", "assertThat ( synthesizedWebMapping 1  . hashCode (  )  ,    is ( webMappingWithPathAndValue . hashCode (  )  )  )  ;", "assertThat ( webMappingWithPathAndValue . hashCode (  )  ,    is ( synthesizedWebMapping 1  . hashCode (  )  )  )  ;", "assertThat ( synthesizedWebMapping 1  . hashCode (  )  ,    is ( not ( webMappingWithAliases . hashCode (  )  )  )  )  ;", "assertThat ( webMappingWithAliases . hashCode (  )  ,    is ( not ( synthesizedWebMapping 1  . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeForSynthesizedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( AnnotationUtils . getAnnotatedMethodsInBaseType ( AnnotationUtilsTests . NonAnnotatedInterface . class )  . isEmpty (  )  )  ;", "assertFalse ( AnnotationUtils . getAnnotatedMethodsInBaseType ( AnnotationUtilsTests . AnnotatedInterface . class )  . isEmpty (  )  )  ;", "assertTrue ( AnnotationUtils . getAnnotatedMethodsInBaseType ( AnnotationUtilsTests . NullableAnnotatedInterface . class )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["interfaceWithAnnotatedMethods"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( AnnotationUtils . isAnnotationDeclaredLocally ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . NonAnnotatedInterface . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationDeclaredLocally ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . NonAnnotatedClass . class )  )  ;", "assertTrue ( AnnotationUtils . isAnnotationDeclaredLocally ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . InheritedAnnotationInterface . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationDeclaredLocally ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . SubInheritedAnnotationInterface . class )  )  ;", "assertTrue ( AnnotationUtils . isAnnotationDeclaredLocally ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . InheritedAnnotationClass . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationDeclaredLocally ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . SubInheritedAnnotationClass . class )  )  ;", "assertTrue ( AnnotationUtils . isAnnotationDeclaredLocally ( Order . class ,    AnnotationUtilsTests . NonInheritedAnnotationInterface . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationDeclaredLocally ( Order . class ,    AnnotationUtilsTests . SubNonInheritedAnnotationInterface . class )  )  ;", "assertTrue ( AnnotationUtils . isAnnotationDeclaredLocally ( Order . class ,    AnnotationUtilsTests . NonInheritedAnnotationClass . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationDeclaredLocally ( Order . class ,    AnnotationUtilsTests . SubNonInheritedAnnotationClass . class )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationDeclaredLocallyForAllScenarios"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( AnnotationUtils . isAnnotationInherited ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . NonAnnotatedInterface . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationInherited ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . NonAnnotatedClass . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationInherited ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . InheritedAnnotationInterface . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationInherited ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . SubInheritedAnnotationInterface . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationInherited ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . InheritedAnnotationClass . class )  )  ;", "assertTrue ( AnnotationUtils . isAnnotationInherited ( AnnotationUtilsTests . Transactional . class ,    AnnotationUtilsTests . SubInheritedAnnotationClass . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationInherited ( Order . class ,    AnnotationUtilsTests . NonInheritedAnnotationInterface . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationInherited ( Order . class ,    AnnotationUtilsTests . SubNonInheritedAnnotationInterface . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationInherited ( Order . class ,    AnnotationUtilsTests . NonInheritedAnnotationClass . class )  )  ;", "assertFalse ( AnnotationUtils . isAnnotationInherited ( Order . class ,    AnnotationUtilsTests . SubNonInheritedAnnotationClass . class )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationInheritedForAllScenarios"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithValueAttribute \"  )  ;", "AnnotationUtilsTests . WebMapping   webMapping    =    method . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "assertNotNull ( webMapping )  ;", "AnnotationUtilsTests . WebMapping   synthesizedWebMapping    =    AnnotationUtils . synthesizeAnnotation ( webMapping )  ;", "assertNotSame ( webMapping ,    synthesizedWebMapping )  ;", "AnnotationUtilsTests . WebMapping   synthesizedAgainWebMapping    =    AnnotationUtils . synthesizeAnnotation ( synthesizedWebMapping )  ;", "assertThat ( synthesizedAgainWebMapping ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", "assertSame ( synthesizedWebMapping ,    synthesizedAgainWebMapping )  ;", "assertEquals (  \" name   attribute :     \"  ,     \" foo \"  ,    synthesizedAgainWebMapping . name (  )  )  ;", "assertArrayEquals (  \" aliased   path   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    synthesizedAgainWebMapping . path (  )  )  ;", "assertArrayEquals (  \" actual   value   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    synthesizedAgainWebMapping . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAlreadySynthesizedAnnotation"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtilsTests . WebController . class . getAnnotation ( Component . class )  ;", "assertNotNull ( component )  ;", "AnnotationAttributes   attributes    =    AnnotationUtils . getAnnotationAttributes ( AnnotationUtilsTests . WebController . class ,    component )  ;", "assertNotNull ( attributes )  ;", "Component   synthesizedComponent    =    AnnotationUtils . synthesizeAnnotation ( attributes ,    Component . class ,    AnnotationUtilsTests . WebController . class )  ;", "assertNotNull ( synthesizedComponent )  ;", "assertNotSame ( component ,    synthesizedComponent )  ;", "assertEquals ( component ,    synthesizedComponent )  ;", "assertEquals (  \" value   from   component :     \"  ,     \" webController \"  ,    component . value (  )  )  ;", "assertEquals (  \" value   from   synthesized   component :     \"  ,     \" webController \"  ,    synthesizedComponent . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . ContextConfig   contextConfig    =    AnnotationUtils . synthesizeAnnotation ( AnnotationUtilsTests . ContextConfig . class )  ;", "assertNotNull ( contextConfig )  ;", "assertEquals (  \" value :     \"  ,     \"  \"  ,    contextConfig . value (  )  )  ;", "assertEquals (  \" location :     \"  ,     \"  \"  ,    contextConfig . location (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromDefaultsWithAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AnnotationWithDefaults   annotationWithDefaults    =    AnnotationUtils . synthesizeAnnotation ( AnnotationUtilsTests . AnnotationWithDefaults . class )  ;", "assertNotNull ( annotationWithDefaults )  ;", "assertEquals (  \" text :     \"  ,     \" enigma \"  ,    annotationWithDefaults . text (  )  )  ;", "assertTrue (  \" predicate :     \"  ,    annotationWithDefaults . predicate (  )  )  ;", "assertArrayEquals (  \" characters :     \"  ,    new   char [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  ,    annotationWithDefaults . characters (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromDefaultsWithoutAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    Collections . singletonMap (  \" value \"  ,     \"  / foo \"  )  ;", ". Get   get    =    AnnotationUtils . synthesizeAnnotation ( map ,     . Get . class ,    null )  ;", "assertNotNull ( get )  ;", "assertEquals (  \" value :     \"  ,     \"  / foo \"  ,    get . value (  )  )  ;", "assertEquals (  \" path :     \"  ,     \"  / foo \"  ,    get . path (  )  )  ;", "map    =    Collections . singletonMap (  \" path \"  ,     \"  / foo \"  )  ;", "get    =    AnnotationUtils . synthesizeAnnotation ( map ,     . Get . class ,    null )  ;", "assertNotNull ( get )  ;", "assertEquals (  \" value :     \"  ,     \"  / foo \"  ,    get . value (  )  )  ;", "assertEquals (  \" path :     \"  ,     \"  / foo \"  ,    get . path (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    Collections . singletonMap ( AnnotationUtils . VALUE ,     4  2 L )  ;", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Attributes   map \"  )  )  ;", "exception . expectMessage ( containsString (  \" returned   a   value   of   type    [ Long ]  \"  )  )  ;", "exception . expectMessage ( containsString (  \" for   attribute    ' value '  \"  )  )  ;", "exception . expectMessage ( containsString (  \" but   a   value   of   type    [ String ]    is   required \"  )  )  ;", "exception . expectMessage ( containsString (  (  (  \" as   defined   by   annotation   type    [  \"     +     ( Component . class . getName (  )  )  )     +     \"  ]  \"  )  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( map ,    Component . class ,    null )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromMapWithAttributeOfIncorrectType"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAnnotationSynthesisFromMapWithImplicitAliases (  \" value \"  )  ;", "assertAnnotationSynthesisFromMapWithImplicitAliases (  \" location 1  \"  )  ;", "assertAnnotationSynthesisFromMapWithImplicitAliases (  \" location 2  \"  )  ;", "assertAnnotationSynthesisFromMapWithImplicitAliases (  \" location 3  \"  )  ;", "assertAnnotationSynthesisFromMapWithImplicitAliases (  \" xmlFile \"  )  ;", "assertAnnotationSynthesisFromMapWithImplicitAliases (  \" groovyScript \"  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromMapWithImplicitAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    Collections . singletonMap (  \" location \"  ,     \" test . xml \"  )  ;", ". ContextConfig   contextConfig    =    AnnotationUtils . synthesizeAnnotation ( map ,     . ContextConfig . class ,    null )  ;", "assertNotNull ( contextConfig )  ;", "assertEquals (  \" value :     \"  ,     \" test . xml \"  ,    contextConfig . value (  )  )  ;", "assertEquals (  \" location :     \"  ,     \" test . xml \"  ,    contextConfig . location (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertMissingTextAttribute ( Collections . emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromMapWithMissingAttributeValue"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . ComponentScan   componentScan    =    AnnotationUtilsTests . ComponentScanClass . class . getAnnotation ( AnnotationUtilsTests . ComponentScan . class )  ;", "assertNotNull ( componentScan )  ;", "AnnotationAttributes   attributes    =    AnnotationUtils . getAnnotationAttributes ( AnnotationUtilsTests . ComponentScanClass . class ,    componentScan ,    false ,    true )  ;", "assertNotNull ( attributes )  ;", "assertEquals ( AnnotationUtilsTests . ComponentScan . class ,    attributes . annotationType (  )  )  ;", "Map < String ,    Object >  [  ]    filters    =     (  ( Map [  ]  )     ( attributes . get (  \" excludeFilters \"  )  )  )  ;", "assertNotNull ( filters )  ;", "List < String >    patterns    =    Arrays . stream ( filters )  . map (  (    m )     -  >     (  ( String )     ( m . get (  \" pattern \"  )  )  )  )  . collect ( Collectors . toList (  )  )  ;", "assertEquals ( Arrays . asList (  \"  * Foo \"  ,     \"  * Bar \"  )  ,    patterns )  ;", "filters [  0  ]  . put (  \" pattern \"  ,     \" newFoo \"  )  ;", "filters [  0  ]  . put (  \" enigma \"  ,     4  2  )  ;", "filters [  1  ]  . put (  \" pattern \"  ,     \" newBar \"  )  ;", "filters [  1  ]  . put (  \" enigma \"  ,     4  2  )  ;", "AnnotationUtilsTests . ComponentScan   synthesizedComponentScan    =    AnnotationUtils . synthesizeAnnotation ( attributes ,    AnnotationUtilsTests . ComponentScan . class ,    AnnotationUtilsTests . ComponentScanClass . class )  ;", "assertNotNull ( synthesizedComponentScan )  ;", "assertNotSame ( componentScan ,    synthesizedComponentScan )  ;", "patterns    =    Arrays . stream ( synthesizedComponentScan . excludeFilters (  )  )  . map ( AnnotationUtilsTests . Filter :  : pattern )  . collect ( Collectors . toList (  )  )  ;", "assertEquals ( Arrays . asList (  \" newFoo \"  ,     \" newBar \"  )  ,    patterns )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromMapWithNestedArrayOfMaps"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . ComponentScanSingleFilter   componentScan    =    AnnotationUtilsTests . ComponentScanSingleFilterClass . class . getAnnotation ( AnnotationUtilsTests . ComponentScanSingleFilter . class )  ;", "assertNotNull ( componentScan )  ;", "assertEquals (  \" value   from   ComponentScan :     \"  ,     \"  * Foo \"  ,    componentScan . value (  )  . pattern (  )  )  ;", "AnnotationAttributes   attributes    =    AnnotationUtils . getAnnotationAttributes ( AnnotationUtilsTests . ComponentScanSingleFilterClass . class ,    componentScan ,    false ,    true )  ;", "assertNotNull ( attributes )  ;", "assertEquals ( AnnotationUtilsTests . ComponentScanSingleFilter . class ,    attributes . annotationType (  )  )  ;", "Map < String ,    Object >    filterMap    =     (  ( Map < String ,    Object >  )     ( attributes . get (  \" value \"  )  )  )  ;", "assertNotNull ( filterMap )  ;", "assertEquals (  \"  * Foo \"  ,    filterMap . get (  \" pattern \"  )  )  ;", "filterMap . put (  \" pattern \"  ,     \" newFoo \"  )  ;", "filterMap . put (  \" enigma \"  ,     4  2  )  ;", "AnnotationUtilsTests . ComponentScanSingleFilter   synthesizedComponentScan    =    AnnotationUtils . synthesizeAnnotation ( attributes ,    AnnotationUtilsTests . ComponentScanSingleFilter . class ,    AnnotationUtilsTests . ComponentScanSingleFilterClass . class )  ;", "assertNotNull ( synthesizedComponentScan )  ;", "assertNotSame ( componentScan ,    synthesizedComponentScan )  ;", "assertEquals (  \" value   from   synthesized   ComponentScan :     \"  ,     \" newFoo \"  ,    synthesizedComponentScan . value (  )  . pattern (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromMapWithNestedMap"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    Collections . singletonMap (  \" text \"  ,    null )  ;", "assertTrue ( map . containsKey (  \" text \"  )  )  ;", "assertMissingTextAttribute ( map )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromMapWithNullAttributeValue"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtilsTests . WebController . class . getAnnotation ( Component . class )  ;", "assertNotNull ( component )  ;", "Map < String ,    Object >    map    =    Collections . singletonMap ( AnnotationUtils . VALUE ,     \" webController \"  )  ;", "Component   synthesizedComponent    =    AnnotationUtils . synthesizeAnnotation ( map ,    Component . class ,    AnnotationUtilsTests . WebController . class )  ;", "assertNotNull ( synthesizedComponent )  ;", "assertNotSame ( component ,    synthesizedComponent )  ;", "assertEquals (  \" value   from   component :     \"  ,     \" webController \"  ,    component . value (  )  )  ;", "assertEquals (  \" value   from   synthesized   component :     \"  ,     \" webController \"  ,    synthesizedComponent . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationFromMapWithoutAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AliasForWithDuplicateAttributeDeclaration   annotation    =    AnnotationUtilsTests . AliasForWithDuplicateAttributeDeclarationClass . class . getAnnotation ( AnnotationUtilsTests . AliasForWithDuplicateAttributeDeclaration . class )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" In    @ AliasFor   declared   on   attribute    ' foo '    in   annotation \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . AliasForWithDuplicateAttributeDeclaration . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" attribute    ' attribute '    and   its   alias    ' value '    are   present   with   values   of    [ baz ]    and    [ bar ]  \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWhereAliasForHasDuplicateAttributeDeclaration"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AliasForWithMissingAttributeDeclaration   annotation    =    AnnotationUtilsTests . AliasForWithMissingAttributeDeclarationClass . class . getAnnotation ( AnnotationUtilsTests . AliasForWithMissingAttributeDeclaration . class )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \"  @ AliasFor   declaration   on   attribute    ' foo '    in   annotation \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . AliasForWithMissingAttributeDeclaration . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" points   to   itself \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWhereAliasForIsMissingAttributeDeclaration"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    expectedLocations    =    Arrays . asList (  \" A \"  ,     \" B \"  )  ;", ". Hierarchy   hierarchy    =     . ConfigHierarchyTestCase . class . getAnnotation (  . Hierarchy . class )  ;", "assertNotNull ( hierarchy )  ;", ". Hierarchy   synthesizedHierarchy    =    AnnotationUtils . synthesizeAnnotation ( hierarchy )  ;", "assertThat ( synthesizedHierarchy ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", ". ContextConfig   contextConfig    =     . SimpleConfigTestCase . class . getAnnotation (  . ContextConfig . class )  ;", "assertNotNull ( contextConfig )  ;", ". ContextConfig [  ]    configs    =    synthesizedHierarchy . value (  )  ;", "List < String >    locations    =    Arrays . stream ( configs )  . map (  . ContextConfig :  : location )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( locations ,    is ( expectedLocations )  )  ;", "configs [  0  ]     =    contextConfig ;", "configs    =    synthesizedHierarchy . value (  )  ;", "List < String >    values    =    Arrays . stream ( configs )  . map (  . ContextConfig :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedLocations )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithArrayOfAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . CharsContainer   charsContainer    =    AnnotationUtilsTests . GroupOfCharsClass . class . getAnnotation ( AnnotationUtilsTests . CharsContainer . class )  ;", "assertNotNull ( charsContainer )  ;", "AnnotationUtilsTests . CharsContainer   synthesizedCharsContainer    =    AnnotationUtils . synthesizeAnnotation ( charsContainer )  ;", "assertThat ( synthesizedCharsContainer ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", "char [  ]    chars    =    synthesizedCharsContainer . chars (  )  ;", "assertArrayEquals ( new   char [  ]  {     ' x '  ,     ' y '  ,     ' z '     }  ,    chars )  ;", "chars [  0  ]     =     '  ?  '  ;", "chars    =    synthesizedCharsContainer . chars (  )  ;", "assertArrayEquals ( new   char [  ]  {     ' x '  ,     ' y '  ,     ' z '     }  ,    chars )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithArrayOfChars"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AliasForAttributeOfDifferentType   annotation    =    AnnotationUtilsTests . AliasForAttributeOfDifferentTypeClass . class . getAnnotation ( AnnotationUtilsTests . AliasForAttributeOfDifferentType . class )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Misconfigured   aliases \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . AliasForAttributeOfDifferentType . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" attribute    ' foo '  \"  )  )  ;", "exception . expectMessage ( containsString (  \" attribute    ' bar '  \"  )  )  ;", "exception . expectMessage ( containsString (  \" same   return   type \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliasForAttributeOfDifferentType"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AliasForAttributeWithDifferentDefaultValue   annotation    =    AnnotationUtilsTests . AliasForAttributeWithDifferentDefaultValueClass . class . getAnnotation ( AnnotationUtilsTests . AliasForAttributeWithDifferentDefaultValue . class )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Misconfigured   aliases \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . AliasForAttributeWithDifferentDefaultValue . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" attribute    ' foo '    in   annotation \"  )  )  ;", "exception . expectMessage ( containsString (  \" attribute    ' bar '    in   annotation \"  )  )  ;", "exception . expectMessage ( containsString (  \" same   default   value \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliasForAttributeWithDifferentDefaultValue"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AliasedComposedContextConfigNotMetaPresent   annotation    =    AnnotationUtilsTests . AliasedComposedContextConfigNotMetaPresentClass . class . getAnnotation ( AnnotationUtilsTests . AliasedComposedContextConfigNotMetaPresent . class )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \"  @ AliasFor   declaration   on   attribute    ' xmlConfigFile '    in   annotation \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . AliasedComposedContextConfigNotMetaPresent . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" declares   an   alias   for   attribute    ' location '    in   meta - annotation \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . ContextConfig . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" not   meta - present \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliasForMetaAnnotationThatIsNotMetaPresent"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AliasForNonexistentAttribute   annotation    =    AnnotationUtilsTests . AliasForNonexistentAttributeClass . class . getAnnotation ( AnnotationUtilsTests . AliasForNonexistentAttribute . class )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Attribute    ' foo '    in \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . AliasForNonexistentAttribute . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" is   declared   as   an    @ AliasFor   nonexistent   attribute    ' bar '  \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliasForNonexistentAttribute"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AliasForWithMissingDefaultValues   annotation    =    AnnotationUtilsTests . AliasForWithMissingDefaultValuesClass . class . getAnnotation ( AnnotationUtilsTests . AliasForWithMissingDefaultValues . class )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Misconfigured   aliases \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . AliasForWithMissingDefaultValues . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" attribute    ' foo '    in   annotation \"  )  )  ;", "exception . expectMessage ( containsString (  \" attribute    ' bar '    in   annotation \"  )  )  ;", "exception . expectMessage ( containsString (  \" default   values \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliasForWithMissingDefaultValues"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AliasForWithMirroredAliasForWrongAttribute   annotation    =    AnnotationUtilsTests . AliasForWithMirroredAliasForWrongAttributeClass . class . getAnnotation ( AnnotationUtilsTests . AliasForWithMirroredAliasForWrongAttribute . class )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Attribute    ' bar '    in \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . AliasForWithMirroredAliasForWrongAttribute . class . getName (  )  )  )  ;", "exception . expectMessage ( either ( containsString (  \" must   be   declared   as   an    @ AliasFor    [ foo ]  ,    not    [ quux ]  \"  )  )  . or ( containsString (  \" is   declared   as   an    @ AliasFor   nonexistent   attribute    ' quux '  \"  )  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliasWithMirroredAliasForWrongAttribute"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . AliasForWithoutMirroredAliasFor   annotation    =    AnnotationUtilsTests . AliasForWithoutMirroredAliasForClass . class . getAnnotation ( AnnotationUtilsTests . AliasForWithoutMirroredAliasFor . class )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Attribute    ' bar '    in \"  )  )  ;", "exception . expectMessage ( containsString ( AnnotationUtilsTests . AliasForWithoutMirroredAliasFor . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \"  @ AliasFor    [ foo ]  \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliasWithoutMirroredAliasFor"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithValueAttribute \"  )  ;", "AnnotationUtilsTests . WebMapping   webMapping    =    method . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "assertNotNull ( webMapping )  ;", "AnnotationUtilsTests . WebMapping   synthesizedWebMapping 1     =    AnnotationUtils . synthesizeAnnotation ( webMapping )  ;", "assertThat ( synthesizedWebMapping 1  ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", "assertNotSame ( webMapping ,    synthesizedWebMapping 1  )  ;", "assertEquals (  \" name   attribute :     \"  ,     \" foo \"  ,    synthesizedWebMapping 1  . name (  )  )  ;", "assertArrayEquals (  \" aliased   path   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    synthesizedWebMapping 1  . path (  )  )  ;", "assertArrayEquals (  \" actual   value   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    synthesizedWebMapping 1  . value (  )  )  ;", "AnnotationUtilsTests . WebMapping   synthesizedWebMapping 2     =    AnnotationUtils . synthesizeAnnotation ( webMapping )  ;", "assertThat ( synthesizedWebMapping 2  ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", "assertNotSame ( webMapping ,    synthesizedWebMapping 2  )  ;", "assertEquals (  \" name   attribute :     \"  ,     \" foo \"  ,    synthesizedWebMapping 2  . name (  )  )  ;", "assertArrayEquals (  \" aliased   path   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    synthesizedWebMapping 2  . path (  )  )  ;", "assertArrayEquals (  \" actual   value   attribute :     \"  ,    AnnotationUtilsTests . asArray (  \"  / test \"  )  ,    synthesizedWebMapping 2  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    expectedLocations    =    Arrays . asList (  \" A \"  ,     \" B \"  )  ;", ". Hierarchy   hierarchy    =     . ConfigHierarchyTestCase . class . getAnnotation (  . Hierarchy . class )  ;", "assertNotNull ( hierarchy )  ;", ". Hierarchy   synthesizedHierarchy    =    AnnotationUtils . synthesizeAnnotation ( hierarchy )  ;", "assertNotSame ( hierarchy ,    synthesizedHierarchy )  ;", "assertThat ( synthesizedHierarchy ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", ". ContextConfig [  ]    configs    =    synthesizedHierarchy . value (  )  ;", "assertNotNull ( configs )  ;", "assertTrue (  \" nested   annotations   must   be   synthesized \"  ,    Arrays . stream ( configs )  . allMatch (  (    c )     -  >    c   instanceof   SynthesizedAnnotation )  )  ;", "List < String >    locations    =    Arrays . stream ( configs )  . map (  . ContextConfig :  : location )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( locations ,    is ( expectedLocations )  )  ;", "List < String >    values    =    Arrays . stream ( configs )  . map (  . ContextConfig :  : value )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( values ,    is ( expectedLocations )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliasesInNestedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtilsTests . ContextConfig   contextConfig    =    AnnotationUtils . synthesizeAnnotation ( AnnotationUtilsTests . ContextConfigMismatch . class . getAnnotation ( AnnotationUtilsTests . ContextConfig . class )  )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "AnnotationUtils . getValue ( contextConfig )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithAttributeAliasesWithDifferentValues"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAnnotationSynthesisWithImplicitAliases ( AnnotationUtilsTests . ValueImplicitAliasesContextConfigClass . class ,     \" value \"  )  ;", "assertAnnotationSynthesisWithImplicitAliases ( AnnotationUtilsTests . Location 1 ImplicitAliasesContextConfigClass . class ,     \" location 1  \"  )  ;", "assertAnnotationSynthesisWithImplicitAliases ( AnnotationUtilsTests . XmlImplicitAliasesContextConfigClass . class ,     \" xmlFile \"  )  ;", "assertAnnotationSynthesisWithImplicitAliases ( AnnotationUtilsTests . GroovyImplicitAliasesContextConfigClass . class ,     \" groovyScript \"  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithImplicitAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    AnnotationUtilsTests . ImplicitAliasesForAliasPairContextConfigClass . class ;", "AnnotationUtilsTests . ImplicitAliasesForAliasPairContextConfig   config    =    clazz . getAnnotation ( AnnotationUtilsTests . ImplicitAliasesForAliasPairContextConfig . class )  ;", "assertNotNull ( config )  ;", "AnnotationUtilsTests . ImplicitAliasesForAliasPairContextConfig   synthesizedConfig    =    AnnotationUtils . synthesizeAnnotation ( config )  ;", "assertThat ( synthesizedConfig ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", "assertEquals (  \" xmlFile :     \"  ,     \" test . xml \"  ,    synthesizedConfig . xmlFile (  )  )  ;", "assertEquals (  \" groovyScript :     \"  ,     \" test . xml \"  ,    synthesizedConfig . groovyScript (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithImplicitAliasesForAliasPair"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    AnnotationUtilsTests . ImplicitAliasesWithDifferentDefaultValuesContextConfigClass . class ;", "Class < AnnotationUtilsTests . ImplicitAliasesWithDifferentDefaultValuesContextConfig >    annotationType    =    AnnotationUtilsTests . ImplicitAliasesWithDifferentDefaultValuesContextConfig . class ;", "AnnotationUtilsTests . ImplicitAliasesWithDifferentDefaultValuesContextConfig   config    =    clazz . getAnnotation ( annotationType )  ;", "assertNotNull ( config )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Misconfigured   aliases :  \"  )  )  ;", "exception . expectMessage ( containsString (  (  (  \" attribute    ' location 1  '    in   annotation    [  \"     +     ( annotationType . getName (  )  )  )     +     \"  ]  \"  )  )  )  ;", "exception . expectMessage ( containsString (  (  (  \" attribute    ' location 2  '    in   annotation    [  \"     +     ( annotationType . getName (  )  )  )     +     \"  ]  \"  )  )  )  ;", "exception . expectMessage ( containsString (  \" same   default   value \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( config ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    AnnotationUtilsTests . ImplicitAliasesWithDuplicateValuesContextConfigClass . class ;", "Class < AnnotationUtilsTests . ImplicitAliasesWithDuplicateValuesContextConfig >    annotationType    =    AnnotationUtilsTests . ImplicitAliasesWithDuplicateValuesContextConfig . class ;", "AnnotationUtilsTests . ImplicitAliasesWithDuplicateValuesContextConfig   config    =    clazz . getAnnotation ( annotationType )  ;", "assertNotNull ( config )  ;", "AnnotationUtilsTests . ImplicitAliasesWithDuplicateValuesContextConfig   synthesizedConfig    =    AnnotationUtils . synthesizeAnnotation ( config ,    clazz )  ;", "assertNotNull ( synthesizedConfig )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" In   annotation \"  )  )  ;", "exception . expectMessage ( containsString ( annotationType . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" declared   on   class \"  )  )  ;", "exception . expectMessage ( containsString ( clazz . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" and   synthesized   from \"  )  )  ;", "exception . expectMessage ( either ( containsString (  \" attribute    ' location 1  '    and   its   alias    ' location 2  '  \"  )  )  . or ( containsString (  \" attribute    ' location 2  '    and   its   alias    ' location 1  '  \"  )  )  )  ;", "exception . expectMessage ( either ( containsString (  \" are   present   with   values   of    [  1  ]    and    [  2  ]  \"  )  )  . or ( containsString (  \" are   present   with   values   of    [  2  ]    and    [  1  ]  \"  )  )  )  ;", "synthesizedConfig . location 1  (  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithImplicitAliasesWithDuplicateValues"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted ( AnnotationUtilsTests . ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass . class ,     \" value \"  )  ;", "assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted ( AnnotationUtilsTests . LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass . class ,     \" location \"  )  ;", "assertAnnotationSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted ( AnnotationUtilsTests . XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass . class ,     \" xmlFile \"  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithImplicitAliasesWithImpliedAliasNamesOmitted"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    AnnotationUtilsTests . ImplicitAliasesWithMissingDefaultValuesContextConfigClass . class ;", "Class < AnnotationUtilsTests . ImplicitAliasesWithMissingDefaultValuesContextConfig >    annotationType    =    AnnotationUtilsTests . ImplicitAliasesWithMissingDefaultValuesContextConfig . class ;", "AnnotationUtilsTests . ImplicitAliasesWithMissingDefaultValuesContextConfig   config    =    clazz . getAnnotation ( annotationType )  ;", "assertNotNull ( config )  ;", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Misconfigured   aliases :  \"  )  )  ;", "exception . expectMessage ( containsString (  (  (  \" attribute    ' location 1  '    in   annotation    [  \"     +     ( annotationType . getName (  )  )  )     +     \"  ]  \"  )  )  )  ;", "exception . expectMessage ( containsString (  (  (  \" attribute    ' location 2  '    in   annotation    [  \"     +     ( annotationType . getName (  )  )  )     +     \"  ]  \"  )  )  )  ;", "exception . expectMessage ( containsString (  \" default   values \"  )  )  ;", "AnnotationUtils . synthesizeAnnotation ( config ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    AnnotationUtilsTests . TransitiveImplicitAliasesContextConfigClass . class ;", "AnnotationUtilsTests . TransitiveImplicitAliasesContextConfig   config    =    clazz . getAnnotation ( AnnotationUtilsTests . TransitiveImplicitAliasesContextConfig . class )  ;", "assertNotNull ( config )  ;", "AnnotationUtilsTests . TransitiveImplicitAliasesContextConfig   synthesizedConfig    =    AnnotationUtils . synthesizeAnnotation ( config )  ;", "assertThat ( synthesizedConfig ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", "assertEquals (  \" xml :     \"  ,     \" test . xml \"  ,    synthesizedConfig . xml (  )  )  ;", "assertEquals (  \" groovy :     \"  ,     \" test . xml \"  ,    synthesizedConfig . groovy (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithTransitiveImplicitAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    AnnotationUtilsTests . TransitiveImplicitAliasesForAliasPairContextConfigClass . class ;", "AnnotationUtilsTests . TransitiveImplicitAliasesForAliasPairContextConfig   config    =    clazz . getAnnotation ( AnnotationUtilsTests . TransitiveImplicitAliasesForAliasPairContextConfig . class )  ;", "assertNotNull ( config )  ;", "AnnotationUtilsTests . TransitiveImplicitAliasesForAliasPairContextConfig   synthesizedConfig    =    AnnotationUtils . synthesizeAnnotation ( config )  ;", "assertThat ( synthesizedConfig ,    instanceOf ( SynthesizedAnnotation . class )  )  ;", "assertEquals (  \" xml :     \"  ,     \" test . xml \"  ,    synthesizedConfig . xml (  )  )  ;", "assertEquals (  \" groovy :     \"  ,     \" test . xml \"  ,    synthesizedConfig . groovy (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithTransitiveImplicitAliasesForAliasPair"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Component   component    =    AnnotationUtilsTests . WebController . class . getAnnotation ( Component . class )  ;", "assertNotNull ( component )  ;", "Component   synthesizedComponent    =    AnnotationUtils . synthesizeAnnotation ( component )  ;", "assertNotNull ( synthesizedComponent )  ;", "assertSame ( component ,    synthesizedComponent )  ;", "assertEquals (  \" value   attribute :     \"  ,     \" webController \"  ,    synthesizedComponent . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeAnnotationWithoutAttributeAliases"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    ClassUtils . forName (  \" NonPublicAliasedAnnotatedClass \"  ,    null )  ;", "Class <  ?    extends   Annotation >    annotationType    =     (  ( Class <  ?    extends   Annotation >  )     ( ClassUtils . forName (  \" NonPublicAliasedAnnotation \"  ,    null )  )  )  ;", "Annotation   annotation    =    clazz . getAnnotation ( annotationType )  ;", "assertNotNull ( annotation )  ;", "Annotation   synthesizedAnnotation    =    AnnotationUtils . synthesizeAnnotation ( annotation )  ;", "assertNotSame ( annotation ,    synthesizedAnnotation )  ;", "assertNotNull ( synthesizedAnnotation )  ;", "assertEquals (  \" name   attribute :     \"  ,     \" test \"  ,    AnnotationUtils . getValue ( synthesizedAnnotation ,     \" name \"  )  )  ;", "assertEquals (  \" aliased   path   attribute :     \"  ,     \"  / test \"  ,    AnnotationUtils . getValue ( synthesizedAnnotation ,     \" path \"  )  )  ;", "assertEquals (  \" aliased   path   attribute :     \"  ,     \"  / test \"  ,    AnnotationUtils . getValue ( synthesizedAnnotation ,     \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["synthesizeNonPublicAnnotationWithAttributeAliasesFromDifferentPackage"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   methodWithPath    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithPathAttribute \"  )  ;", "AnnotationUtilsTests . WebMapping   webMappingWithAliases    =    methodWithPath . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "assertNotNull ( webMappingWithAliases )  ;", "Method   methodWithPathAndValue    =    AnnotationUtilsTests . WebController . class . getMethod (  \" handleMappedWithSamePathAndValueAttributes \"  )  ;", "AnnotationUtilsTests . WebMapping   webMappingWithPathAndValue    =    methodWithPathAndValue . getAnnotation ( AnnotationUtilsTests . WebMapping . class )  ;", "assertNotNull ( webMappingWithPathAndValue )  ;", "AnnotationUtilsTests . WebMapping   synthesizedWebMapping 1     =    AnnotationUtils . synthesizeAnnotation ( webMappingWithAliases )  ;", "assertNotNull ( synthesizedWebMapping 1  )  ;", "AnnotationUtilsTests . WebMapping   synthesizedWebMapping 2     =    AnnotationUtils . synthesizeAnnotation ( webMappingWithAliases )  ;", "assertNotNull ( synthesizedWebMapping 2  )  ;", "assertThat ( webMappingWithAliases . toString (  )  ,    is ( not ( synthesizedWebMapping 1  . toString (  )  )  )  )  ;", "assertToStringForWebMappingWithPathAndValue ( synthesizedWebMapping 1  )  ;", "assertToStringForWebMappingWithPathAndValue ( synthesizedWebMapping 2  )  ;", "}", "METHOD_END"], "methodName": ["toStringForSynthesizedAnnotations"], "fileName": "org.springframework.core.annotation.AnnotationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( element )  ;", "Set <  . PeteRepeat >    peteRepeats    =    AnnotatedElementUtils . findMergedRepeatableAnnotations ( element ,     . PeteRepeat . class )  ;", "assertNotNull ( peteRepeats )  ;", "assertEquals (  3  ,    peteRepeats . size (  )  )  ;", "Iterator <  . PeteRepeat >    iterator    =    peteRepeats . iterator (  )  ;", "assertEquals (  \" A \"  ,    iterator . next (  )  . value (  )  )  ;", "assertEquals (  \" B \"  ,    iterator . next (  )  . value (  )  )  ;", "assertEquals (  \" C \"  ,    iterator . next (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertFindRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( element )  ;", "Set <  . PeteRepeat >    peteRepeats    =    AnnotatedElementUtils . getMergedRepeatableAnnotations ( element ,     . PeteRepeat . class )  ;", "assertNotNull ( peteRepeats )  ;", "assertEquals (  3  ,    peteRepeats . size (  )  )  ;", "Iterator <  . PeteRepeat >    iterator    =    peteRepeats . iterator (  )  ;", "assertEquals (  \" A \"  ,    iterator . next (  )  . value (  )  )  ;", "assertEquals (  \" B \"  ,    iterator . next (  )  . value (  )  )  ;", "assertEquals (  \" C \"  ,    iterator . next (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertGetRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( annotations )  ;", "assertEquals (  3  ,    annotations . size (  )  )  ;", "Iterator <  . Noninherited >    iterator    =    annotations . iterator (  )  ;", "assertEquals (  \" A \"  ,    iterator . next (  )  . value (  )  )  ;", "assertEquals (  \" B \"  ,    iterator . next (  )  . value (  )  )  ;", "assertEquals (  \" C \"  ,    iterator . next (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNoninheritedRepeatableAnnotations"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Invalid   declaration   of   container   type \"  )  )  ;", "exception . expectMessage ( containsString (  . ContainerMissingValueAttribute . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" for   repeatable   annotation \"  )  )  ;", "exception . expectMessage ( containsString (  . InvalidRepeatable . class . getName (  )  )  )  ;", "exception . expectCause ( isA ( NoSuchMethodException . class )  )  ;", "}", "METHOD_END"], "methodName": ["expectContainerMissingValueAttribute"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Container   type \"  )  )  ;", "exception . expectMessage ( containsString (  . ContainerWithArrayValueAttributeButWrongComponentType . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" must   declare   a    ' value '    attribute   for   an   array   of   type \"  )  )  ;", "exception . expectMessage ( containsString (  . InvalidRepeatable . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["expectContainerWithArrayValueAttributeButWrongComponentType"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( AnnotationConfigurationException . class )  ;", "exception . expectMessage ( startsWith (  \" Container   type \"  )  )  ;", "exception . expectMessage ( containsString (  . ContainerWithNonArrayValueAttribute . class . getName (  )  )  )  ;", "exception . expectMessage ( containsString (  \" must   declare   a    ' value '    attribute   for   an   array   of   type \"  )  )  ;", "exception . expectMessage ( containsString (  . InvalidRepeatable . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["expectContainerWithNonArrayValueAttribute"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( startsWith (  \" Annotation   type   must   be   a   repeatable   annotation \"  )  )  ;", "exception . expectMessage ( containsString (  \" failed   to   resolve   container   type   for \"  )  )  ;", "exception . expectMessage ( containsString (  . NonRepeatable . class . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["expectNonRepeatableAnnotation"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertFindRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . ComposedContainerClass . class )  ;", "}", "METHOD_END"], "methodName": ["findComposedContainerForRepeatableAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertFindRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . ComposedRepeatableMixedWithContainerClass . class )  ;", "}", "METHOD_END"], "methodName": ["findComposedRepeatableAnnotationsMixedWithContainerOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertFindRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . ComposedRepeatableClass . class )  ;", "}", "METHOD_END"], "methodName": ["findComposedRepeatableAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "expectContainerMissingValueAttribute (  )  ;", "AnnotatedElementUtils . findMergedRepeatableAnnotations ( getClass (  )  ,     . InvalidRepeatable . class ,     . ContainerMissingValueAttribute . class )  ;", "}", "METHOD_END"], "methodName": ["findInvalidRepeatableAnnotationContainerMissingValueAttribute"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "expectContainerWithArrayValueAttributeButWrongComponentType (  )  ;", "AnnotatedElementUtils . findMergedRepeatableAnnotations ( getClass (  )  ,     . InvalidRepeatable . class ,     . ContainerWithArrayValueAttributeButWrongComponentType . class )  ;", "}", "METHOD_END"], "methodName": ["findInvalidRepeatableAnnotationContainerWithArrayValueAttributeButWrongComponentType"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "expectContainerWithNonArrayValueAttribute (  )  ;", "AnnotatedElementUtils . findMergedRepeatableAnnotations ( getClass (  )  ,     . InvalidRepeatable . class ,     . ContainerWithNonArrayValueAttribute . class )  ;", "}", "METHOD_END"], "methodName": ["findInvalidRepeatableAnnotationContainerWithNonArrayValueAttribute"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "expectNonRepeatableAnnotation (  )  ;", "AnnotatedElementUtils . findMergedRepeatableAnnotations ( getClass (  )  ,     . NonRepeatable . class )  ;", "}", "METHOD_END"], "methodName": ["findNonRepeatableAnnotation"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    ComposedRepeatableAnnotationsTests . NoninheritedRepeatableClass . class ;", "Set < ComposedRepeatableAnnotationsTests . Noninherited >    annotations    =    AnnotatedElementUtils . findMergedRepeatableAnnotations ( element ,    ComposedRepeatableAnnotationsTests . Noninherited . class )  ;", "assertNoninheritedRepeatableAnnotations ( annotations )  ;", "}", "METHOD_END"], "methodName": ["findNoninheritedComposedRepeatableAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    ComposedRepeatableAnnotationsTests . SubNoninheritedRepeatableClass . class ;", "Set < ComposedRepeatableAnnotationsTests . Noninherited >    annotations    =    AnnotatedElementUtils . findMergedRepeatableAnnotations ( element ,    ComposedRepeatableAnnotationsTests . Noninherited . class )  ;", "assertNoninheritedRepeatableAnnotations ( annotations )  ;", "}", "METHOD_END"], "methodName": ["findNoninheritedComposedRepeatableAnnotationsOnSuperclass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertFindRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . RepeatableClass . class )  ;", "}", "METHOD_END"], "methodName": ["findRepeatableAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertFindRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . SubRepeatableClass . class )  ;", "}", "METHOD_END"], "methodName": ["findRepeatableAnnotationsOnSuperclass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . ComposedContainerClass . class )  ;", "}", "METHOD_END"], "methodName": ["getComposedContainerForRepeatableAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . ComposedRepeatableMixedWithContainerClass . class )  ;", "}", "METHOD_END"], "methodName": ["getComposedRepeatableAnnotationsMixedWithContainerOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . ComposedRepeatableClass . class )  ;", "}", "METHOD_END"], "methodName": ["getComposedRepeatableAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "expectContainerMissingValueAttribute (  )  ;", "AnnotatedElementUtils . getMergedRepeatableAnnotations ( getClass (  )  ,     . InvalidRepeatable . class ,     . ContainerMissingValueAttribute . class )  ;", "}", "METHOD_END"], "methodName": ["getInvalidRepeatableAnnotationContainerMissingValueAttribute"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "expectContainerWithArrayValueAttributeButWrongComponentType (  )  ;", "AnnotatedElementUtils . getMergedRepeatableAnnotations ( getClass (  )  ,     . InvalidRepeatable . class ,     . ContainerWithArrayValueAttributeButWrongComponentType . class )  ;", "}", "METHOD_END"], "methodName": ["getInvalidRepeatableAnnotationContainerWithArrayValueAttributeButWrongComponentType"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "expectContainerWithNonArrayValueAttribute (  )  ;", "AnnotatedElementUtils . getMergedRepeatableAnnotations ( getClass (  )  ,     . InvalidRepeatable . class ,     . ContainerWithNonArrayValueAttribute . class )  ;", "}", "METHOD_END"], "methodName": ["getInvalidRepeatableAnnotationContainerWithNonArrayValueAttribute"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "expectNonRepeatableAnnotation (  )  ;", "AnnotatedElementUtils . getMergedRepeatableAnnotations ( getClass (  )  ,     . NonRepeatable . class )  ;", "}", "METHOD_END"], "methodName": ["getNonRepeatableAnnotation"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    ComposedRepeatableAnnotationsTests . NoninheritedRepeatableClass . class ;", "Set < ComposedRepeatableAnnotationsTests . Noninherited >    annotations    =    AnnotatedElementUtils . getMergedRepeatableAnnotations ( element ,    ComposedRepeatableAnnotationsTests . Noninherited . class )  ;", "assertNoninheritedRepeatableAnnotations ( annotations )  ;", "}", "METHOD_END"], "methodName": ["getNoninheritedComposedRepeatableAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    ComposedRepeatableAnnotationsTests . SubNoninheritedRepeatableClass . class ;", "Set < ComposedRepeatableAnnotationsTests . Noninherited >    annotations    =    AnnotatedElementUtils . getMergedRepeatableAnnotations ( element ,    ComposedRepeatableAnnotationsTests . Noninherited . class )  ;", "assertNotNull ( annotations )  ;", "assertEquals (  0  ,    annotations . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNoninheritedComposedRepeatableAnnotationsOnSuperclass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . RepeatableClass . class )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "assertGetRepeatableAnnotations ( ComposedRepeatableAnnotationsTests . SubRepeatableClass . class )  ;", "}", "METHOD_END"], "methodName": ["getRepeatableAnnotationsOnSuperclass"], "fileName": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   LinkedHashMap <  >  ( originalAttributes )  ;", "Map < String ,    List < String >  >    attributeAliasMap    =    AnnotationUtils . getAttributeAliasMap ( annotationType )  ;", "for    ( Method   attributeMethod    :    AnnotationUtils . getAttributeMethods ( annotationType )  )     {", "String   attributeName    =    attributeMethod . getName (  )  ;", "Object   attributeValue    =    attributes . get ( attributeName )  ;", "if    ( attributeValue    =  =    null )     {", "List < String >    aliasNames    =    attributeAliasMap . get ( attributeName )  ;", "if    ( aliasNames    !  =    null )     {", "for    ( String   aliasName    :    aliasNames )     {", "Object   aliasValue    =    attributes . get ( aliasName )  ;", "if    ( aliasValue    !  =    null )     {", "attributeValue    =    aliasValue ;", "attributes . put ( attributeName ,    attributeValue )  ;", "break ;", "}", "}", "}", "}", "if    ( attributeValue    =  =    null )     {", "Object   defaultValue    =    AnnotationUtils . getDefaultValue ( annotationType ,    attributeName )  ;", "if    ( defaultValue    !  =    null )     {", "attributeValue    =    defaultValue ;", "attributes . put ( attributeName ,    attributeValue )  ;", "}", "}", "Assert . notNull ( attributeValue ,     (  )     -  >    String . format (  \" Attributes   map    % s   returned   null   for   required   attribute    '  % s '    defined   by   annotation   type    [  % s ]  .  \"  ,    attributes ,    attributeName ,    annotationType . getName (  )  )  )  ;", "Class <  ?  >    requiredReturnType    =    attributeMethod . getReturnType (  )  ;", "Class <  ?  >    actualReturnType    =    attributeValue . getClass (  )  ;", "if    (  !  ( ClassUtils . isAssignable ( requiredReturnType ,    actualReturnType )  )  )     {", "boolean   converted    =    false ;", "if    (  ( requiredReturnType . isArray (  )  )     &  &     (  ( requiredReturnType . getComponentType (  )  )     =  =    actualReturnType )  )     {", "Object   array    =    Array . newInstance ( requiredReturnType . getComponentType (  )  ,     1  )  ;", "Array . set ( array ,     0  ,    attributeValue )  ;", "attributes . put ( attributeName ,    array )  ;", "converted    =    true ;", "} else", "if    (  ( Annotation . class . isAssignableFrom ( requiredReturnType )  )     &  &     ( Map . class . isAssignableFrom ( actualReturnType )  )  )     {", "Class <  ?    extends   Annotation >    nestedAnnotationType    =     (  ( Class <  ?    extends   Annotation >  )     ( requiredReturnType )  )  ;", "Map < String ,    Object >    map    =     (  ( Map < String ,    Object >  )     ( attributeValue )  )  ;", "attributes . put ( attributeName ,    AnnotationUtils . synthesizeAnnotation ( map ,    nestedAnnotationType ,    null )  )  ;", "converted    =    true ;", "} else", "if    (  (  (  ( requiredReturnType . isArray (  )  )     &  &     ( actualReturnType . isArray (  )  )  )     &  &     ( Annotation . class . isAssignableFrom ( requiredReturnType . getComponentType (  )  )  )  )     &  &     ( Map . class . isAssignableFrom ( actualReturnType . getComponentType (  )  )  )  )     {", "Class <  ?    extends   Annotation >    nestedAnnotationType    =     (  ( Class <  ?    extends   Annotation >  )     ( requiredReturnType . getComponentType (  )  )  )  ;", "Map < String ,    Object >  [  ]    maps    =     (  ( Map < String ,    Object >  [  ]  )     ( attributeValue )  )  ;", "attributes . put ( attributeName ,    AnnotationUtils . synthesizerray ( maps ,    nestedAnnotationType )  )  ;", "converted    =    true ;", "}", "Assert . isTrue ( converted ,     (  )     -  >    String . format (  (  \" Attributes   map    % s   returned   a   value   of   type    [  % s ]    for   attribute    '  % s '  ,     \"     +     \" but   a   value   of   type    [  % s ]    is   required   as   defined   by   annotation   type    [  % s ]  .  \"  )  ,    attributes ,    actualReturnType . getName (  )  ,    attributeName ,    requiredReturnType . getName (  )  ,    annotationType . getName (  )  )  )  ;", "}", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["enrichAndValidateAttributes"], "fileName": "org.springframework.core.annotation.MapAnnotationAttributeExtractor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Annotation >    annotationType    =    AnnotationUtilsTests . ImplicitAliasesContextConfig . class ;", "Field   cacheField    =    AnnotationUtils . class . getDeclaredField (  \" attributeAliasesCache \"  )  ;", "cacheField . setAccessible ( true )  ;", "Map < Class <  ?    extends   Annotation >  ,    MultiValueMap < String ,    String >  >    attributeAliasesCache    =     (  ( Map < Class <  ?    extends   Annotation >  ,    MultiValueMap < String ,    String >  >  )     ( cacheField . get ( null )  )  )  ;", "MultiValueMap < String ,    String >    aliases    =    new   LinkedMultiValueMap <  >  (  )  ;", "aliases . put (  \" xmlFile \"  ,    Arrays . asList (  \" value \"  ,     \" groovyScript \"  ,     \" location 1  \"  ,     \" location 2  \"  ,     \" location 3  \"  )  )  ;", "aliases . put (  \" groovyScript \"  ,    Arrays . asList (  \" value \"  ,     \" xmlFile \"  ,     \" location 1  \"  ,     \" location 2  \"  ,     \" location 3  \"  )  )  ;", "aliases . put (  \" value \"  ,    Arrays . asList (  \" xmlFile \"  ,     \" groovyScript \"  ,     \" location 1  \"  ,     \" location 2  \"  ,     \" location 3  \"  )  )  ;", "aliases . put (  \" location 1  \"  ,    Arrays . asList (  \" xmlFile \"  ,     \" groovyScript \"  ,     \" value \"  ,     \" location 2  \"  ,     \" location 3  \"  )  )  ;", "aliases . put (  \" location 2  \"  ,    Arrays . asList (  \" xmlFile \"  ,     \" groovyScript \"  ,     \" value \"  ,     \" location 1  \"  ,     \" location 3  \"  )  )  ;", "aliases . put (  \" location 3  \"  ,    Arrays . asList (  \" xmlFile \"  ,     \" groovyScript \"  ,     \" value \"  ,     \" location 1  \"  ,     \" location 2  \"  )  )  ;", "attributeAliasesCache . put ( annotationType ,    aliases )  ;", "extractor    =    new    ( sourceAttributes ,    annotationType ,    null )  ;", "Map < String ,    Object >    enriched    =    extractor . getSource (  )  ;", "assertEquals (  \" attribute   map   size \"  ,    expected . size (  )  ,    enriched . size (  )  )  ;", "expected . forEach (  (    attr ,    expectedValue )     -  >    assertThat (  (  (  \" for   attribute    '  \"     +    attr )     +     \"  '  \"  )  ,    enriched . get ( attr )  ,    is ( expectedValue )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEnrichAndValidateAttributes"], "fileName": "org.springframework.core.annotation.MapAnnotationAttributeExtractorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationUtils . clearCache (  )  ;", "}", "METHOD_END"], "methodName": ["clearCacheBeforeTests"], "fileName": "org.springframework.core.annotation.MapAnnotationAttributeExtractorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" groovyScript \"  ,     \" groovy !  \"  )  ;", "}", "}  ;", "Map < String ,    Object >    expecteds    =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" groovyScript \"  ,     \" groovy !  \"  )  ;", "put (  \" xmlFile \"  ,     \" groovy !  \"  )  ;", "put (  \" value \"  ,     \" groovy !  \"  )  ;", "put (  \" location 1  \"  ,     \" groovy !  \"  )  ;", "put (  \" location 2  \"  ,     \" groovy !  \"  )  ;", "put (  \" location 3  \"  ,     \" groovy !  \"  )  ;", "put (  \" nonAliased \"  ,     \"  \"  )  ;", "put (  \" configClass \"  ,    Object . class )  ;", "}", "}  ;", "assertEnrichAndValidates ( attributes ,    expecteds )  ;", "}", "METHOD_END"], "methodName": ["enrichAndValidateAttributesWithImplicitAliases"], "fileName": "org.springframework.core.annotation.MapAnnotationAttributeExtractorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap <  >  (  )  ;", "Map < String ,    Object >    expecteds    =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" groovyScript \"  ,     \"  \"  )  ;", "put (  \" xmlFile \"  ,     \"  \"  )  ;", "put (  \" value \"  ,     \"  \"  )  ;", "put (  \" location 1  \"  ,     \"  \"  )  ;", "put (  \" location 2  \"  ,     \"  \"  )  ;", "put (  \" location 3  \"  ,     \"  \"  )  ;", "put (  \" nonAliased \"  ,     \"  \"  )  ;", "put (  \" configClass \"  ,    Object . class )  ;", "}", "}  ;", "assertEnrichAndValidates ( attributes ,    expecteds )  ;", "}", "METHOD_END"], "methodName": ["enrichAndValidateAttributesWithImplicitAliasesAndMinimalAttributes"], "fileName": "org.springframework.core.annotation.MapAnnotationAttributeExtractorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" value \"  ,     \"  / foo \"  )  ;", "put (  \" name \"  ,     \" test \"  )  ;", "}", "}  ;", "Map < String ,    Object >    expected    =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" value \"  ,    AnnotationUtilsTests . asArray (  \"  / foo \"  )  )  ;", "put (  \" path \"  ,    AnnotationUtilsTests . asArray (  \"  / foo \"  )  )  ;", "put (  \" name \"  ,     \" test \"  )  ;", "put (  \" method \"  ,    new   AnnotationUtilsTests . RequestMethod [  0  ]  )  ;", "}", "}  ;", "extractor    =    new    ( attributes ,    AnnotationUtilsTests . WebMapping . class ,    null )  ;", "Map < String ,    Object >    enriched    =    extractor . getSource (  )  ;", "assertEquals (  \" attribute   map   size \"  ,    expected . size (  )  ,    enriched . size (  )  )  ;", "expected . forEach (  (    attr ,    expectedValue )     -  >    assertThat (  (  (  \" for   attribute    '  \"     +    attr )     +     \"  '  \"  )  ,    enriched . get ( attr )  ,    is ( expectedValue )  )  )  ;", "}", "METHOD_END"], "methodName": ["enrichAndValidateAttributesWithSingleElementThatOverridesAnArray"], "fileName": "org.springframework.core.annotation.MapAnnotationAttributeExtractorTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( element )  ;", "Set <  . Cacheable >    cacheables    =    AnnotatedElementUtils . findAllMergedAnnotations ( element ,     . Cacheable . class )  ;", "assertNotNull ( cacheables )  ;", "assertEquals (  2  ,    cacheables . size (  )  )  ;", "Iterator <  . Cacheable >    iterator    =    cacheables . iterator (  )  ;", ". Cacheable   fooCacheable    =    iterator . next (  )  ;", ". Cacheable   barCacheable    =    iterator . next (  )  ;", "assertEquals (  \" fooKey \"  ,    fooCacheable . key (  )  )  ;", "assertEquals (  \" fooCache \"  ,    fooCacheable . value (  )  )  ;", "assertEquals (  \" barKey \"  ,    barCacheable . key (  )  )  ;", "assertEquals (  \" barCache \"  ,    barCacheable . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertFindAllMergedAnnotationsBehavior"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( element )  ;", "Set <  . Cacheable >    cacheables    =    AnnotatedElementUtils . getAllMergedAnnotations ( element ,     . Cacheable . class )  ;", "assertNotNull ( cacheables )  ;", "assertEquals (  2  ,    cacheables . size (  )  )  ;", "Iterator <  . Cacheable >    iterator    =    cacheables . iterator (  )  ;", ". Cacheable   fooCacheable    =    iterator . next (  )  ;", ". Cacheable   barCacheable    =    iterator . next (  )  ;", "assertEquals (  \" fooKey \"  ,    fooCacheable . key (  )  )  ;", "assertEquals (  \" fooCache \"  ,    fooCacheable . value (  )  )  ;", "assertEquals (  \" barKey \"  ,    barCacheable . key (  )  )  ;", "assertEquals (  \" barCache \"  ,    barCacheable . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertGetAllMergedAnnotationsBehavior"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertFindAllMergedAnnotationsBehavior ( MultipleComposedAnnotationsOnSingleAnnotatedElementTests . ComposedCacheOnInterfaceAndLocalCacheClass . class )  ;", "}", "METHOD_END"], "methodName": ["findComposedCacheOnInterfaceAndLocalCacheOnClass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertFindAllMergedAnnotationsBehavior ( MultipleComposedAnnotationsOnSingleAnnotatedElementTests . ComposedPlusLocalCachesClass . class )  ;", "}", "METHOD_END"], "methodName": ["findComposedPlusLocalAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElement   element    =    getClass (  )  . getDeclaredMethod (  \" composedPlusLocalCachesMethod \"  )  ;", "assertFindAllMergedAnnotationsBehavior ( element )  ;", "}", "METHOD_END"], "methodName": ["findComposedPlusLocalAnnotationsOnMethod"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertFindAllMergedAnnotationsBehavior ( getBridgeMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["findMultipleComposedAnnotationsOnBridgeMethod"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertFindAllMergedAnnotationsBehavior ( MultipleComposedAnnotationsOnSingleAnnotatedElementTests . MultipleComposedCachesClass . class )  ;", "}", "METHOD_END"], "methodName": ["findMultipleComposedAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertFindAllMergedAnnotationsBehavior ( MultipleComposedAnnotationsOnSingleAnnotatedElementTests . MultipleComposedCachesOnInterfaceClass . class )  ;", "}", "METHOD_END"], "methodName": ["findMultipleComposedAnnotationsOnInterface"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElement   element    =    getClass (  )  . getDeclaredMethod (  \" multipleComposedCachesMethod \"  )  ;", "assertFindAllMergedAnnotationsBehavior ( element )  ;", "}", "METHOD_END"], "methodName": ["findMultipleComposedAnnotationsOnMethod"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertFindAllMergedAnnotationsBehavior ( MultipleComposedAnnotationsOnSingleAnnotatedElementTests . SubMultipleComposedCachesClass . class )  ;", "}", "METHOD_END"], "methodName": ["findMultipleInheritedComposedAnnotationsOnSuperclass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . MultipleNoninheritedComposedCachesClass . class ;", "Set < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable >    cacheables    =    AnnotatedElementUtils . findAllMergedAnnotations ( element ,    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable . class )  ;", "assertNotNull ( cacheables )  ;", "assertEquals (  2  ,    cacheables . size (  )  )  ;", "Iterator < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable >    iterator    =    cacheables . iterator (  )  ;", "MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable   cacheable 1     =    iterator . next (  )  ;", "MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable   cacheable 2     =    iterator . next (  )  ;", "assertEquals (  \" noninheritedCache 1  \"  ,    cacheable 1  . value (  )  )  ;", "assertEquals (  \" noninheritedCache 2  \"  ,    cacheable 2  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["findMultipleNoninheritedComposedAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . SubMultipleNoninheritedComposedCachesClass . class ;", "Set < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable >    cacheables    =    AnnotatedElementUtils . findAllMergedAnnotations ( element ,    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable . class )  ;", "assertNotNull ( cacheables )  ;", "assertEquals (  2  ,    cacheables . size (  )  )  ;", "Iterator < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable >    iterator    =    cacheables . iterator (  )  ;", "MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable   cacheable 1     =    iterator . next (  )  ;", "MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable   cacheable 2     =    iterator . next (  )  ;", "assertEquals (  \" noninheritedCache 1  \"  ,    cacheable 1  . value (  )  )  ;", "assertEquals (  \" noninheritedCache 2  \"  ,    cacheable 2  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["findMultipleNoninheritedComposedAnnotationsOnSuperclass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . StringGenericParameter . class . getMethods (  )  ;", "Method   bridgeMethod    =    null ;", "Method   bridgedMethod    =    null ;", "for    ( Method   method    :    methods )     {", "if    (  (  \" getFor \"  . equals ( method . getName (  )  )  )     &  &     (  !  ( method . getParameterTypes (  )  [  0  ]  . equals ( Integer . class )  )  )  )     {", "if    ( method . getReturnType (  )  . equals ( Object . class )  )     {", "bridgeMethod    =    method ;", "} else    {", "bridgedMethod    =    method ;", "}", "}", "}", "assertTrue (  (  ( bridgeMethod    !  =    null )     &  &     ( bridgeMethod . isBridge (  )  )  )  )  ;", "assertTrue (  (  ( bridgedMethod    !  =    null )     &  &     (  !  ( bridgedMethod . isBridge (  )  )  )  )  )  ;", "return   bridgeMethod ;", "}", "METHOD_END"], "methodName": ["getBridgeMethod"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertGetAllMergedAnnotationsBehavior ( MultipleComposedAnnotationsOnSingleAnnotatedElementTests . ComposedPlusLocalCachesClass . class )  ;", "}", "METHOD_END"], "methodName": ["getComposedPlusLocalAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElement   element    =    getClass (  )  . getDeclaredMethod (  \" composedPlusLocalCachesMethod \"  )  ;", "assertGetAllMergedAnnotationsBehavior ( element )  ;", "}", "METHOD_END"], "methodName": ["getComposedPlusLocalAnnotationsOnMethod"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "Set < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable >    cacheables    =    AnnotatedElementUtils . getAllMergedAnnotations ( getBridgeMethod (  )  ,    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable . class )  ;", "assertNotNull ( cacheables )  ;", "assertEquals (  0  ,    cacheables . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMultipleComposedAnnotationsOnBridgeMethod"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertGetAllMergedAnnotationsBehavior ( MultipleComposedAnnotationsOnSingleAnnotatedElementTests . MultipleComposedCachesClass . class )  ;", "}", "METHOD_END"], "methodName": ["getMultipleComposedAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "Class < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . MultipleComposedCachesOnInterfaceClass >    element    =    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . MultipleComposedCachesOnInterfaceClass . class ;", "Set < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable >    cacheables    =    AnnotatedElementUtils . getAllMergedAnnotations ( element ,    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable . class )  ;", "assertNotNull ( cacheables )  ;", "assertEquals (  0  ,    cacheables . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMultipleComposedAnnotationsOnInterface"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElement   element    =    getClass (  )  . getDeclaredMethod (  \" multipleComposedCachesMethod \"  )  ;", "assertGetAllMergedAnnotationsBehavior ( element )  ;", "}", "METHOD_END"], "methodName": ["getMultipleComposedAnnotationsOnMethod"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "assertGetAllMergedAnnotationsBehavior ( MultipleComposedAnnotationsOnSingleAnnotatedElementTests . SubMultipleComposedCachesClass . class )  ;", "}", "METHOD_END"], "methodName": ["getMultipleInheritedComposedAnnotationsOnSuperclass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . MultipleNoninheritedComposedCachesClass . class ;", "Set < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable >    cacheables    =    AnnotatedElementUtils . getAllMergedAnnotations ( element ,    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable . class )  ;", "assertNotNull ( cacheables )  ;", "assertEquals (  2  ,    cacheables . size (  )  )  ;", "Iterator < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable >    iterator    =    cacheables . iterator (  )  ;", "MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable   cacheable 1     =    iterator . next (  )  ;", "MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable   cacheable 2     =    iterator . next (  )  ;", "assertEquals (  \" noninheritedCache 1  \"  ,    cacheable 1  . value (  )  )  ;", "assertEquals (  \" noninheritedCache 2  \"  ,    cacheable 2  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMultipleNoninheritedComposedAnnotationsOnClass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    element    =    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . SubMultipleNoninheritedComposedCachesClass . class ;", "Set < MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable >    cacheables    =    AnnotatedElementUtils . getAllMergedAnnotations ( element ,    MultipleComposedAnnotationsOnSingleAnnotatedElementTests . Cacheable . class )  ;", "assertNotNull ( cacheables )  ;", "assertEquals (  0  ,    cacheables . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMultipleNoninheritedComposedAnnotationsOnSuperclass"], "fileName": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests"}, {"methodBody": ["METHOD_START", "{", "OrderSourceProviderTests . A   a    =    new   OrderSourceProviderTests . A (  )  ;", "OrderSourceProviderTests . C   c    =    new   OrderSourceProviderTests . C (  3  )  ;", "OrderSourceProviderTests . B   b    =    new   OrderSourceProviderTests . B (  )  ;", "Object [  ]    items    =    new   Object [  ]  {    a ,    c ,    b    }  ;", "Arrays . sort ( items ,    comparator . withSourceProvider (  (    obj )     -  >     {", "if    ( obj    =  =    a )     {", "return   new   OrderSourceProviderTests . C (  4  )  ;", "}", "if    ( obj    =  =    b )     {", "return   new   OrderSourceProviderTests . C (  2  )  ;", "}", "return   null ;", "}  )  )  ;", "assertOrder ( items ,    b ,    c ,    a )  ;", "}", "METHOD_END"], "methodName": ["arrayFactoryMethod"], "fileName": "org.springframework.core.annotation.OrderSourceProviderTests"}, {"methodBody": ["METHOD_START", "{", "OrderSourceProviderTests . A   a    =    new   OrderSourceProviderTests . A (  )  ;", "OrderSourceProviderTests . C   c    =    new   OrderSourceProviderTests . C (  5  )  ;", "OrderSourceProviderTests . C   c 2     =    new   OrderSourceProviderTests . C (  (  -  5  )  )  ;", "Object [  ]    items    =    new   Object [  ]  {    a ,    c ,    c 2     }  ;", "Arrays . sort ( items ,    comparator . withSourceProvider (  (    obj )     -  >     {", "if    ( obj    =  =    a )     {", "return    4  ;", "}", "if    ( obj    =  =    c 2  )     {", "return    2  ;", "}", "return   null ;", "}  )  )  ;", "assertOrder ( items ,    c 2  ,    a ,    c )  ;", "}", "METHOD_END"], "methodName": ["arrayFactoryMethodOverridesStaticOrder"], "fileName": "org.springframework.core.annotation.OrderSourceProviderTests"}, {"methodBody": ["METHOD_START", "{", "OrderSourceProviderTests . A   a    =    new   OrderSourceProviderTests . A (  )  ;", "OrderSourceProviderTests . C   c    =    new   OrderSourceProviderTests . C (  (  -  5  0  )  )  ;", "OrderSourceProviderTests . B   b    =    new   OrderSourceProviderTests . B (  )  ;", "Object [  ]    items    =    new   Object [  ]  {    a ,    c ,    b    }  ;", "Arrays . sort ( items ,    comparator . withSourceProvider (  (    obj )     -  >    null )  )  ;", "assertOrder ( items ,    c ,    a ,    b )  ;", "}", "METHOD_END"], "methodName": ["arrayNoFactoryMethod"], "fileName": "org.springframework.core.annotation.OrderSourceProviderTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( actual . length )  ;    i +  +  )     {", "assertS (  (  (  \" Wrong   instance   at   index    '  \"     +    i )     +     \"  '  \"  )  ,    expected [ i ]  ,    actual [ i ]  )  ;", "}", "assertEquals (  \" Wrong   number   of   items \"  ,    expected . length ,    expected . length )  ;", "}", "METHOD_END"], "methodName": ["assertOrder"], "fileName": "org.springframework.core.annotation.OrderSourceProviderTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( actual . size (  )  )  ;    i +  +  )     {", "assertS (  (  (  \" Wrong   instance   at   index    '  \"     +    i )     +     \"  '  \"  )  ,    expected [ i ]  ,    actual . get ( i )  )  ;", "}", "assertEquals (  \" Wrong   number   of   items \"  ,    expected . length ,    actual . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertOrder"], "fileName": "org.springframework.core.annotation.OrderSourceProviderTests"}, {"methodBody": ["METHOD_START", "{", "OrderSourceProviderTests . A   a    =    new   OrderSourceProviderTests . A (  )  ;", "OrderSourceProviderTests . C   c    =    new   OrderSourceProviderTests . C (  3  )  ;", "OrderSourceProviderTests . B   b    =    new   OrderSourceProviderTests . B (  )  ;", "List <  ?  >    items    =    Arrays . asList ( a ,    c ,    b )  ;", "Collections . sort ( items ,    comparator . withSourceProvider (  (    obj )     -  >     {", "if    ( obj    =  =    a )     {", "return   new   OrderSourceProviderTests . C (  4  )  ;", "}", "if    ( obj    =  =    b )     {", "return   new   OrderSourceProviderTests . C (  2  )  ;", "}", "return   null ;", "}  )  )  ;", "assertOrder ( items ,    b ,    c ,    a )  ;", "}", "METHOD_END"], "methodName": ["listFactoryMethod"], "fileName": "org.springframework.core.annotation.OrderSourceProviderTests"}, {"methodBody": ["METHOD_START", "{", "OrderSourceProviderTests . A   a    =    new   OrderSourceProviderTests . A (  )  ;", "OrderSourceProviderTests . C   c    =    new   OrderSourceProviderTests . C (  5  )  ;", "OrderSourceProviderTests . C   c 2     =    new   OrderSourceProviderTests . C (  (  -  5  )  )  ;", "List <  ?  >    items    =    Arrays . asList ( a ,    c ,    c 2  )  ;", "Collections . sort ( items ,    comparator . withSourceProvider (  (    obj )     -  >     {", "if    ( obj    =  =    a )     {", "return    4  ;", "}", "if    ( obj    =  =    c 2  )     {", "return    2  ;", "}", "return   null ;", "}  )  )  ;", "assertOrder ( items ,    c 2  ,    a ,    c )  ;", "}", "METHOD_END"], "methodName": ["listFactoryMethodOverridesStaticOrder"], "fileName": "org.springframework.core.annotation.OrderSourceProviderTests"}, {"methodBody": ["METHOD_START", "{", "OrderSourceProviderTests . A   a    =    new   OrderSourceProviderTests . A (  )  ;", "OrderSourceProviderTests . C   c    =    new   OrderSourceProviderTests . C (  (  -  5  0  )  )  ;", "OrderSourceProviderTests . B   b    =    new   OrderSourceProviderTests . B (  )  ;", "List <  ?  >    items    =    Arrays . asList ( a ,    c ,    b )  ;", "Collections . sort ( items ,    comparator . withSourceProvider (  (    obj )     -  >    null )  )  ;", "assertOrder ( items ,    c ,    a ,    b )  ;", "}", "METHOD_END"], "methodName": ["listNoFactoryMethod"], "fileName": "org.springframework.core.annotation.OrderSourceProviderTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    items    =    new   ArrayList <  >  (  )  ;", ". C   c    =    new    . C (  5  )  ;", ". C   c 2     =    new    . C (  (  -  5  )  )  ;", "items . add ( c )  ;", "items . add ( c 2  )  ;", "Collections . sort ( items ,    comparator )  ;", "assertOrder ( items ,    c 2  ,    c )  ;", "}", "METHOD_END"], "methodName": ["plainComparator"], "fileName": "org.springframework.core.annotation.OrderSourceProviderTests"}, {"methodBody": ["METHOD_START", "{", "Order   order    =    AnnotationUtils . findAnnotation ( type ,    Order . class )  ;", "if    ( order    !  =    null )     {", "return   order . value (  )  ;", "}", "Integer   priorityOrder    =     . getPriority ( type )  ;", "if    ( priorityOrder    !  =    null )     {", "return   priorityOrder ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.core.annotation.OrderUtils"}, {"methodBody": ["METHOD_START", "{", "Integer   order    =    OrderUtils . getOrder ( type )  ;", "return   order    !  =    null    ?    order    :    defaultOrder ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.core.annotation.OrderUtils"}, {"methodBody": ["METHOD_START", "{", "Integer   order    =    OrderUtils . getOrder ( type )  ;", "return   order    !  =    null    ?    order    :    defaultOrder ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.core.annotation.OrderUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( OrderUtils . priorityAnnotationType )     !  =    null )     {", "Annotation   priority    =    AnnotationUtils . findAnnotation ( type ,    OrderUtils . priorityAnnotationType )  ;", "if    ( priority    !  =    null )     {", "return    (  ( Integer )     ( AnnotationUtils . getValue ( priority )  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPriority"], "fileName": "org.springframework.core.annotation.OrderUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  3  3  ,    OrderUtils . getOrder ( OrderUtilsTests . NoOrder . class ,     3  3  )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultOrder"], "fileName": "org.springframework.core.annotation.OrderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Integer . valueOf (  5  0  )  ,    OrderUtils . getOrder ( OrderUtilsTests . OrderAndPriority . class ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["getOrderWithBoth"], "fileName": "org.springframework.core.annotation.OrderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Integer . valueOf (  5  5  )  ,    OrderUtils . getOrder ( OrderUtilsTests . SimplePriority . class ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["getPriorityOrder"], "fileName": "org.springframework.core.annotation.OrderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Integer . valueOf (  5  5  )  ,    OrderUtils . getPriority ( OrderUtilsTests . OrderAndPriority . class )  )  ;", "}", "METHOD_END"], "methodName": ["getPriorityValue"], "fileName": "org.springframework.core.annotation.OrderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( OrderUtils . getPriority ( OrderUtilsTests . SimpleOrder . class )  )  ;", "}", "METHOD_END"], "methodName": ["getPriorityValueNoAnnotation"], "fileName": "org.springframework.core.annotation.OrderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Integer . valueOf (  5  0  )  ,    OrderUtils . getOrder ( OrderUtilsTests . SimpleOrder . class ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleOrder"], "fileName": "org.springframework.core.annotation.OrderUtilsTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    other )     {", "return   true ;", "}", "if    (  !  ( Type (  )  . isInstance ( other )  )  )     {", "return   false ;", "}", "for    ( Method   attributeMethod    :    AnnotationUtils . getAttributeMethods ( Type (  )  )  )     {", "Object   thisValue    =    getAttributeValue ( attributeMethod )  ;", "Object   otherValue    =    ReflectionUtils . invokeMethod ( attributeMethod ,    other )  ;", "if    (  !  ( ObjectUtils . nullSafeEquals ( thisValue ,    otherValue )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["annotationEquals"], "fileName": "org.springframework.core.annotation.SynthesizedAnnotationInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "for    ( Method   attributeMethod    :    AnnotationUtils . getAttributeMethods ( Type (  )  )  )     {", "Object   value    =    getAttributeValue ( attributeMethod )  ;", "int   hashCode ;", "if    ( value . getClass (  )  . isArray (  )  )     {", "hashCode    =    hashCodeForArray ( value )  ;", "} else    {", "hashCode    =    value . hashCode (  )  ;", "}", "result    +  =     (  1  2  7     *     ( attributeMethod . getName (  )  . hashCode (  )  )  )     ^    hashCode ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["annotationHashCode"], "fileName": "org.springframework.core.annotation.SynthesizedAnnotationInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  \"  @  \"  )  . append ( annotationType (  )  . getName (  )  )  . append (  \"  (  \"  )  ;", "Iterator < Method >    iterator    =    AnnotationUtils . getAttributeMethods ( annotationType (  )  )  . iterator (  )  ;", "while    ( iterator . hasNext (  )  )     {", "Method   attributeMethod    =    iterator . next (  )  ;", "sb . append ( attributeMethod . getName (  )  )  ;", "sb . append (  '  =  '  )  ;", "sb . append ( attributeValueToString ( getAttributeValue ( attributeMethod )  )  )  ;", "sb . append (  ( iterator . hasNext (  )     ?     \"  ,     \"     :     \"  \"  )  )  ;", "}", "return   sb . append (  \"  )  \"  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["annotationToString"], "fileName": "org.springframework.core.annotation.SynthesizedAnnotationInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . attributeExtractor . getAnnotationType (  )  ;", "}", "METHOD_END"], "methodName": ["annotationType"], "fileName": "org.springframework.core.annotation.SynthesizedAnnotationInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   Object [  ]  )     {", "return    (  \"  [  \"     +     ( StUtils . arrayToDelimitedSt (  (  ( Object [  ]  )     ( value )  )  ,     \"  ,     \"  )  )  )     +     \"  ]  \"  ;", "}", "return   St . valueOf ( value )  ;", "}", "METHOD_END"], "methodName": ["attributeValueToString"], "fileName": "org.springframework.core.annotation.SynthesizedAnnotationInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( array   instanceof   boolean [  ]  )     {", "return    (  ( boolean [  ]  )     ( array )  )  . clone (  )  ;", "}", "if    ( array   instanceof   byte [  ]  )     {", "return    (  ( byte [  ]  )     ( array )  )  . clone (  )  ;", "}", "if    ( array   instanceof   char [  ]  )     {", "return    (  ( char [  ]  )     ( array )  )  . clone (  )  ;", "}", "if    ( array   instanceof   double [  ]  )     {", "return    (  ( double [  ]  )     ( array )  )  . clone (  )  ;", "}", "if    ( array   instanceof   float [  ]  )     {", "return    (  ( float [  ]  )     ( array )  )  . clone (  )  ;", "}", "if    ( array   instanceof   int [  ]  )     {", "return    (  ( int [  ]  )     ( array )  )  . clone (  )  ;", "}", "if    ( array   instanceof   long [  ]  )     {", "return    (  ( long [  ]  )     ( array )  )  . clone (  )  ;", "}", "if    ( array   instanceof   short [  ]  )     {", "return    (  ( short [  ]  )     ( array )  )  . clone (  )  ;", "}", "return    (  ( Object [  ]  )     ( array )  )  . clone (  )  ;", "}", "METHOD_END"], "methodName": ["cloneArray"], "fileName": "org.springframework.core.annotation.SynthesizedAnnotationInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "String   attributeName    =    attributeMethod . getName (  )  ;", "Object   value    =    this . valueCache . get ( attributeName )  ;", "if    ( value    =  =    null )     {", "value    =    this . attributeExtractor . getAttributeValue ( attributeMethod )  ;", "if    ( value    =  =    null )     {", "String   msg    =    String . format (  \"  % s   returned   null   for   attribute   name    [  % s ]    from   attribute   source    [  % s ]  \"  ,    this . attributeExtractor . getClass (  )  . getName (  )  ,    attributeName ,    this . attributeExtractor . getSource (  )  )  ;", "throw   new   IllegalStateException ( msg )  ;", "}", "if    ( value   instanceof    )     {", "value    =    Utils . synthesize (  (  (  )     ( value )  )  ,    this . attributeExtractor . getAnnotatedElement (  )  )  ;", "} else", "if    ( value   instanceof    [  ]  )     {", "value    =    Utils . synthesizeArray (  (  (  [  ]  )     ( value )  )  ,    this . attributeExtractor . getAnnotatedElement (  )  )  ;", "}", "this . valueCache . put ( attributeName ,    value )  ;", "}", "if    ( value . getClass (  )  . isArray (  )  )     {", "value    =    cloneArray ( value )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["getAttributeValue"], "fileName": "org.springframework.core.annotation.SynthesizedAnnotationInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( array   instanceof   boolean [  ]  )     {", "return   Arrays . hashCode (  (  ( boolean [  ]  )     ( array )  )  )  ;", "}", "if    ( array   instanceof   byte [  ]  )     {", "return   Arrays . hashCode (  (  ( byte [  ]  )     ( array )  )  )  ;", "}", "if    ( array   instanceof   char [  ]  )     {", "return   Arrays . hashCode (  (  ( char [  ]  )     ( array )  )  )  ;", "}", "if    ( array   instanceof   double [  ]  )     {", "return   Arrays . hashCode (  (  ( double [  ]  )     ( array )  )  )  ;", "}", "if    ( array   instanceof   float [  ]  )     {", "return   Arrays . hashCode (  (  ( float [  ]  )     ( array )  )  )  ;", "}", "if    ( array   instanceof   int [  ]  )     {", "return   Arrays . hashCode (  (  ( int [  ]  )     ( array )  )  )  ;", "}", "if    ( array   instanceof   long [  ]  )     {", "return   Arrays . hashCode (  (  ( long [  ]  )     ( array )  )  )  ;", "}", "if    ( array   instanceof   short [  ]  )     {", "return   Arrays . hashCode (  (  ( short [  ]  )     ( array )  )  )  ;", "}", "return   Arrays . hashCode (  (  ( Object [  ]  )     ( array )  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeForArray"], "fileName": "org.springframework.core.annotation.SynthesizedAnnotationInvocationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( executable   instanceof   Method )     {", "return   new    (  (  ( Method )     ( executable )  )  ,    parameterIndex )  ;", "} else", "if    ( executable   instanceof   Constructor )     {", "return   new    (  (  ( Constructor <  ?  >  )     ( executable )  )  ,    parameterIndex )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Not   a   Method / Constructor :     \"     +    executable )  )  ;", "}", "}", "METHOD_END"], "methodName": ["forExecutable"], "fileName": "org.springframework.core.annotation.SynthesizingMethodParameter"}, {"methodBody": ["METHOD_START", "{", "return   SynthesizingMethodParameter . forExecutable ( parameter . getDeclaringExecutable (  )  ,    MethodParameter . findParameterIndex ( parameter )  )  ;", "}", "METHOD_END"], "methodName": ["forParameter"], "fileName": "org.springframework.core.annotation.SynthesizingMethodParameter"}, {"methodBody": ["METHOD_START", "{", "return    4  2  ;", "}", "METHOD_END"], "methodName": ["method"], "fileName": "org.springframework.core.annotation.SynthesizingMethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "method    =    getClass (  )  . getMethod (  \" method \"  ,    String . class ,    Long . TYPE )  ;", "stringParameter    =    new    ( method ,     0  )  ;", "longParameter    =    new    ( method ,     1  )  ;", "intReturnType    =    new    ( method ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.core.annotation.SynthesizingMethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( stringParameter ,    stringParameter )  ;", "assertEquals ( longParameter ,    longParameter )  ;", "assertEquals ( intReturnType ,    intReturnType )  ;", "assertFalse ( stringParameter . equals ( longParameter )  )  ;", "assertFalse ( stringParameter . equals ( intReturnType )  )  ;", "assertFalse ( longParameter . equals ( stringParameter )  )  ;", "assertFalse ( longParameter . equals ( intReturnType )  )  ;", "assertFalse ( intReturnType . equals ( stringParameter )  )  ;", "assertFalse ( intReturnType . equals ( longParameter )  )  ;", "Method   method    =    getClass (  )  . getMethod (  \" method \"  ,    String . class ,    Long . TYPE )  ;", "MethodParameter   methodParameter    =    new    ( method ,     0  )  ;", "assertEquals ( stringParameter ,    methodParameter )  ;", "assertEquals ( methodParameter ,    stringParameter )  ;", "assertNotEquals ( longParameter ,    methodParameter )  ;", "assertNotEquals ( methodParameter ,    longParameter )  ;", "methodParameter    =    new   MethodParameter ( method ,     0  )  ;", "assertEquals ( stringParameter ,    methodParameter )  ;", "assertEquals ( methodParameter ,    stringParameter )  ;", "assertNotEquals ( longParameter ,    methodParameter )  ;", "assertNotEquals ( methodParameter ,    longParameter )  ;", "}", "METHOD_END"], "methodName": ["testEquals"], "fileName": "org.springframework.core.annotation.SynthesizingMethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( stringParameter ,    SynthesizingMethodParameter . forExecutable ( method ,     0  )  )  ;", "assertEquals ( longParameter ,    SynthesizingMethodParameter . forExecutable ( method ,     1  )  )  ;", "assertEquals ( stringParameter ,    SynthesizingMethodParameter . forParameter ( method . getParameters (  )  [  0  ]  )  )  ;", "assertEquals ( longParameter ,    SynthesizingMethodParameter . forParameter ( method . getParameters (  )  [  1  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryMethods"], "fileName": "org.springframework.core.annotation.SynthesizingMethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( stringParameter . hashCode (  )  ,    stringParameter . hashCode (  )  )  ;", "assertEquals ( longParameter . hashCode (  )  ,    longParameter . hashCode (  )  )  ;", "assertEquals ( intReturnType . hashCode (  )  ,    intReturnType . hashCode (  )  )  ;", "Method   method    =    getClass (  )  . getMethod (  \" method \"  ,    String . class ,    Long . TYPE )  ;", "methodParameter    =    new    ( method ,     0  )  ;", "assertEquals ( stringParameter . hashCode (  )  ,    methodParameter . hashCode (  )  )  ;", "assertNotEquals ( longParameter . hashCode (  )  ,    methodParameter . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHashCode"], "fileName": "org.springframework.core.annotation.SynthesizingMethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "new   SynthesizingMethodParameter ( method ,     2  )  ;", "}", "METHOD_END"], "methodName": ["testIndexValidation"], "fileName": "org.springframework.core.annotation.SynthesizingMethodParameterTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( byte [  ]  . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertFalse ( this . decoder . canDecode ( ResolvableType . forClass ( Integer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( byte [  ]  . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "}", "METHOD_END"], "methodName": ["canDecode"], "fileName": "org.springframework.core.codec.ByteArrayDecoderTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   fooBuffer    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   barBuffer    =    stringBuffer (  \" bar \"  )  ;", "Flux < DataBuffer >    source    =    Flux . just ( fooBuffer ,    barBuffer )  ;", "Flux < byte [  ]  >    output    =    this . d . decode ( source ,    ResolvableType . forClassWithGenerics ( Publisher . class ,    byte [  ]  . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith (  (    bytes )     -  >    assertArrayEquals (  \" foo \"  . getBytes (  )  ,    bytes )  )  . consumeNextWith (  (    bytes )     -  >    assertArrayEquals (  \" bar \"  . getBytes (  )  ,    bytes )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.core.codec.ByteArrayDecoderTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   fooBuffer    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   barBuffer    =    stringBuffer (  \" bar \"  )  ;", "Flux < DataBuffer >    source    =    Flux . just ( fooBuffer ,    barBuffer )  ;", "Mono < byte [  ]  >    output    =    this . d . decodeToMono ( source ,    ResolvableType . forClassWithGenerics ( Publisher . class ,    byte [  ]  . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith (  (    bytes )     -  >    assertArrayEquals (  \" foobar \"  . getBytes (  )  ,    bytes )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeToMono"], "fileName": "org.springframework.core.codec.ByteArrayDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( byte [  ]  . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( Integer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( byte [  ]  . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . NONE ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canEncode"], "fileName": "org.springframework.core.codec.ByteArrayEncoderTests"}, {"methodBody": ["METHOD_START", "{", "this . encoder    =    new   ByteArrayEncoder (  )  ;", "}", "METHOD_END"], "methodName": ["createEncoder"], "fileName": "org.springframework.core.codec.ByteArrayEncoderTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    fooBytes    =     \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "byte [  ]    barBytes    =     \" bar \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "Flux < byte [  ]  >    source    =    Flux . just ( fooBytes ,    barBytes )  ;", "Flux < DataBuffer >    output    =    this . e . encode ( source ,    this . bufferFactory ,    ResolvableType . forClassWithGenerics ( Publisher . class ,    ByteBuffer . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith (  (    b )     -  >     {", "byte [  ]    buf    =    new   byte [  3  ]  ;", "b . read ( buf )  ;", "assertArrayEquals ( fooBytes ,    buf )  ;", "}  )  . consumeNextWith (  (    b )     -  >     {", "byte [  ]    buf    =    new   byte [  3  ]  ;", "b . read ( buf )  ;", "assertArrayEquals ( barBytes ,    buf )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.core.codec.ByteArrayEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( ByteBuffer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertFalse ( this . decoder . canDecode ( ResolvableType . forClass ( Integer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( ByteBuffer . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "}", "METHOD_END"], "methodName": ["canDecode"], "fileName": "org.springframework.core.codec.ByteBufferDecoderTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   fooBuffer    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   barBuffer    =    stringBuffer (  \" bar \"  )  ;", "Flux < DataBuffer >    source    =    Flux . just ( fooBuffer ,    barBuffer )  ;", "Flux <  >    output    =    this . decoder . decode ( source ,    ResolvableType . forClassWithGenerics ( Publisher . class ,     . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext (  . wrap (  \" foo \"  . getBytes (  )  )  ,     . wrap (  \" bar \"  . getBytes (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.core.codec.ByteBufferDecoderTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   fooBuffer    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   barBuffer    =    stringBuffer (  \" bar \"  )  ;", "Flux < DataBuffer >    source    =    Flux . just ( fooBuffer ,    barBuffer )  ;", "Mono <  >    output    =    this . decoder . decodeToMono ( source ,    ResolvableType . forClassWithGenerics ( Publisher . class ,     . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext (  . wrap (  \" foobar \"  . getBytes (  )  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeToMono"], "fileName": "org.springframework.core.codec.ByteBufferDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( ByteBuffer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( Integer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( ByteBuffer . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . NONE ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canEncode"], "fileName": "org.springframework.core.codec.ByteBufferEncoderTests"}, {"methodBody": ["METHOD_START", "{", "this . encoder    =    new   ByteBufferEncoder (  )  ;", "}", "METHOD_END"], "methodName": ["createEncoder"], "fileName": "org.springframework.core.codec.ByteBufferEncoderTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    fooBytes    =     \" foo \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "byte [  ]    barBytes    =     \" bar \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "Flux <  >    source    =    Flux . just (  . wrap ( fooBytes )  ,     . wrap ( barBytes )  )  ;", "Flux < DataBuffer >    output    =    this . encoder . encode ( source ,    this . bufferFactory ,    ResolvableType . forClassWithGenerics ( Publisher . class ,     . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith (  (    b )     -  >     {", "byte [  ]    buf    =    new   byte [  3  ]  ;", "b . read ( buf )  ;", "assertArrayEquals ( fooBytes ,    buf )  ;", "}  )  . consumeNextWith (  (    b )     -  >     {", "byte [  ]    buf    =    new   byte [  3  ]  ;", "b . read ( buf )  ;", "assertArrayEquals ( barBytes ,    buf )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.core.codec.ByteBufferEncoderTests"}, {"methodBody": ["METHOD_START", "{", "return   new   CharSequenceEncoder ( new   MimeType (  \" text \"  ,     \" plain \"  ,    CharSequenceEncoder . DEFAULT _ CHARSET )  ,    MimeTypeUtils . ALL )  ;", "}", "METHOD_END"], "methodName": ["allMimeTypes"], "fileName": "org.springframework.core.codec.CharSequenceEncoder"}, {"methodBody": ["METHOD_START", "{", "Charset   charset ;", "if    (  ( mimeType    !  =    null )     &  &     (  ( mimeType . getCharset (  )  )     !  =    null )  )     {", "charset    =    mimeType . getCharset (  )  ;", "} else    {", "charset    =     . DEFAULT _ CHARSET ;", "}", "return   charset ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.core.codec.CharSequenceEncoder"}, {"methodBody": ["METHOD_START", "{", "return   new   CharSequenceEncoder ( new   MimeType (  \" text \"  ,     \" plain \"  ,    CharSequenceEncoder . DEFAULT _ CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["textPlainOnly"], "fileName": "org.springframework.core.codec.CharSequenceEncoder"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( StringBuilder . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( StringBuffer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( Integer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( String . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . NONE ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canWrite"], "fileName": "org.springframework.core.codec.CharSequenceEncoderTests"}, {"methodBody": ["METHOD_START", "{", "this . encoder    =    CharSequenceEncoder . textPlainOnly (  )  ;", "}", "METHOD_END"], "methodName": ["createEncoder"], "fileName": "org.springframework.core.codec.CharSequenceEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < String >    stringFlux    =    Flux . just (  \" foo \"  )  ;", "Flux < DataBuffer >    output    =    Flux . from ( this . e . encode ( stringFlux ,    this . bufferFactory ,    null ,    null ,    Collections . emptyMap (  )  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "org.springframework.core.codec.CharSequenceEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < StringBuilder >    stringBuilderFlux    =    Flux . just ( new   StringBuilder (  \" foo \"  )  )  ;", "Flux < DataBuffer >    output    =    Flux . from ( this . e . encode ( stringBuilderFlux ,    this . bufferFactory ,    null ,    null ,    Collections . emptyMap (  )  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["writeStringBuilder"], "fileName": "org.springframework.core.codec.CharSequenceEncoderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( DataBuffer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "assertFalse ( this . decoder . canDecode ( ResolvableType . forClass ( Integer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( DataBuffer . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "}", "METHOD_END"], "methodName": ["canDecode"], "fileName": "org.springframework.core.codec.DataBufferDecoderTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   fooBuffer    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   barBuffer    =    stringBuffer (  \" bar \"  )  ;", "Flux < DataBuffer >    source    =    Flux . just ( fooBuffer ,    barBuffer )  ;", "Flux < DataBuffer >    output    =    this . decoder . decode ( source ,    ResolvableType . forClassWithGenerics ( Publisher . class ,    DataBuffer . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "assertSame ( source ,    output )  ;", "release ( fooBuffer ,    barBuffer )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.core.codec.DataBufferDecoderTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   fooBuffer    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   barBuffer    =    stringBuffer (  \" bar \"  )  ;", "Flux < DataBuffer >    source    =    Flux . just ( fooBuffer ,    barBuffer )  ;", "Mono < DataBuffer >    output    =    this . decoder . decodeToMono ( source ,    ResolvableType . forClassWithGenerics ( Publisher . class ,    DataBuffer . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "DataBuffer   outputBuffer    =    output . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  \" foobar \"  ,    DataBufferTestUtils . dumpString ( outputBuffer ,    StandardCharsets . UTF _  8  )  )  ;", "release ( outputBuffer )  ;", "}", "METHOD_END"], "methodName": ["decodeToMono"], "fileName": "org.springframework.core.codec.DataBufferDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( DataBuffer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( Integer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( DataBuffer . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "assertFalse ( this . encoder . canEncode ( ResolvableType . NONE ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canEncode"], "fileName": "org.springframework.core.codec.DataBufferEncoderTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   fooBuffer    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   barBuffer    =    stringBuffer (  \" bar \"  )  ;", "Flux < DataBuffer >    source    =    Flux . just ( fooBuffer ,    barBuffer )  ;", "Flux < DataBuffer >    output    =    this . encoder . encode ( source ,    this . bufferFactory ,    ResolvableType . forClassWithGenerics ( Publisher . class ,    ByteBuffer . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "assertSame ( source ,    output )  ;", "release ( fooBuffer ,    barBuffer )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.core.codec.DataBufferEncoderTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.core.codec.Encoder"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( InputStreamResource . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( ByteArrayResource . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( Resource . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( InputStreamResource . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "assertFalse ( this . decoder . canDecode ( ResolvableType . forClass ( Object . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "}", "METHOD_END"], "methodName": ["canDecode"], "fileName": "org.springframework.core.codec.ResourceDecoderTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   fooBuffer    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   barBuffer    =    stringBuffer (  \" bar \"  )  ;", "Flux < DataBuffer >    source    =    Flux . just ( fooBuffer ,    barBuffer )  ;", "Flux <  >    result    =    this . decoder . decode ( source ,    ResolvableType . forClass (  . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( result )  . consumeNextWith (  (    resource )     -  >     {", "try    {", "byte [  ]    bytes    =    StreamUtils . copyToByteArray ( resource . getInputStream (  )  )  ;", "assertEquals (  \" foobar \"  ,    new   String ( bytes )  )  ;", "}    catch    (    e )     {", "fail ( e . getMessage (  )  )  ;", "}", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.core.codec.ResourceDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( InputStreamResource . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( ByteArrayResource . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( Resource . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "Assert . assertTrue ( this . encoder . canEncode ( ResolvableType . forClass ( InputStreamResource . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . NONE ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canEncode"], "fileName": "org.springframework.core.codec.ResourceEncoderTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" foo \"  ;", "resource    =    new   ByteArray ( s . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "Mono <  >    source    =    Mono . just ( resource )  ;", "Flux < DataBuffer >    output    =    this . encoder . encode ( source ,    this . bufferFactory ,    ResolvableType . forClass (  . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . consumeNextWith ( stringConsumer ( s )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.core.codec.ResourceEncoderTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( InputStreamResource . class )     !  =     ( resource . getClass (  )  )  )     {", "try    {", "return   OptionalLong . of ( resource . contentLength (  )  )  ;", "}    catch    ( IOException   ignored )     {", "}", "}", "return   OptionalLong . empty (  )  ;", "}", "METHOD_END"], "methodName": ["contentLength"], "fileName": "org.springframework.core.codec.ResourceRegionEncoder"}, {"methodBody": ["METHOD_START", "{", "return   in . getBytes ( StandardCharsets . US _ ASCII )  ;", "}", "METHOD_END"], "methodName": ["getAsciiBytes"], "fileName": "org.springframework.core.codec.ResourceRegionEncoder"}, {"methodBody": ["METHOD_START", "{", "long   start    =    region . getPosition (  )  ;", "long   end    =     ( start    +     ( region . getCount (  )  )  )     -     1  ;", "OptionalLong   contentLength    =    contentLength ( region . get (  )  )  ;", "if    ( contentLength . isPresent (  )  )     {", "return   getAsciiBytes (  (  (  (  (  (  (  \" Content - Range :    bytes    \"     +    start )     +     '  -  '  )     +    end )     +     '  /  '  )     +     ( contentLength . getAsLong (  )  )  )     +     \"  \\ r \\ n \\ r \\ n \"  )  )  ;", "} else    {", "return   getAsciiBytes (  (  (  (  (  \" Content - Range :    bytes    \"     +    start )     +     '  -  '  )     +    end )     +     \"  \\ r \\ n \\ r \\ n \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getContentRangeHeader"], "fileName": "org.springframework.core.codec.ResourceRegionEncoder"}, {"methodBody": ["METHOD_START", "{", "return   Flux . just ( bufferFactory . allocateBuffer ( startBoundary . length )  . write ( startBoundary )  ,    bufferFactory . allocateBuffer ( contentType . length )  . write ( contentType )  ,    bufferFactory . wrap ( ByteBuffer . wrap ( getContentRangeHeader ( region )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRegionPrefix"], "fileName": "org.springframework.core.codec.ResourceRegionEncoder"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    endBoundary    =    getAsciiBytes (  (  (  \"  \\ r \\ n -  -  \"     +    boundaryString )     +     \"  -  -  \"  )  )  ;", "return   Flux . just ( bufferFactory . allocateBuffer ( endBoundary . length )  . write ( endBoundary )  )  ;", "}", "METHOD_END"], "methodName": ["getRegionSuffix"], "fileName": "org.springframework.core.codec.ResourceRegionEncoder"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    region . getResource (  )  ;", "long   position    =    region . getPosition (  )  ;", "Flux < DataBuffer >    in    =    DataBufferUtils . read ( resource ,    position ,    bufferFactory ,    this . bufferSize )  ;", "return   DataBufferUtils . takeUntilByteCount ( in ,    region . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeResourceRegion"], "fileName": "org.springframework.core.codec.ResourceRegionEncoder"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   resourceRegion    =    ResolvableType . forClass ( ResourceRegion . class )  ;", "MimeType   allMimeType    =    MimeType . valueOf (  \"  *  /  *  \"  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( Resource . class )  ,    MimeTypeUtils . APPLICATION _ OCTET _ STREAM )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . forClass ( Resource . class )  ,    allMimeType )  )  ;", "Assert . assertTrue ( this . encoder . canEncode ( resourceRegion ,    MimeTypeUtils . APPLICATION _ OCTET _ STREAM )  )  ;", "Assert . assertTrue ( this . encoder . canEncode ( resourceRegion ,    allMimeType )  )  ;", "Assert . assertFalse ( this . encoder . canEncode ( ResolvableType . NONE ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["canEncode"], "fileName": "org.springframework.core.codec.ResourceRegionEncoderTests"}, {"methodBody": ["METHOD_START", "{", "this . encoder    =    new   ResourceRegionEncoder (  )  ;", "this . bufferFactory    =    new   DefaultDataBufferFactory (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.core.codec.ResourceRegionEncoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < ResourceRegion >    regions    =    Flux . just ( new   ResourceRegion ( resource ,     0  ,     6  )  ,    new   ResourceRegion ( resource ,     7  ,     9  )  ,    new   ResourceRegion ( resource ,     1  7  ,     4  )  ,    new   ResourceRegion ( resource ,     2  2  ,     1  7  )  )  ;", "String   boundary    =    MimeTypeUtils . generateMultipartBoundaryString (  )  ;", "Flux < DataBuffer >    result    =    this . encoder . encode ( regions ,    this . bufferFactory ,    ResolvableType . forClass ( ResourceRegion . class )  ,    MimeType . valueOf (  \" text / plain \"  )  ,    Collections . singletonMap (  . BOUNDARY _ STRING _ HINT ,    boundary )  )  ;", "Mono < DataBuffer >    reduced    =    result . reduce ( bufferFactory . allocateBuffer (  )  ,     (    previous ,    current )     -  >     {", "previous . write ( current )  ;", "DataBufferUtils . release ( current )  ;", "return   previous ;", "}  )  ;", "StepVerifier . create ( reduced )  . consumeNextWith (  (    buf )     -  >     {", "String   content    =    DataBufferTestUtils . dumpString ( buf ,    StandardCharsets . UTF _  8  )  ;", "String [  ]    ranges    =    StringUtils . tokenizeToStringArray ( content ,     \"  \\ r \\ n \"  ,    false ,    true )  ;", "String [  ]    expected    =    new   String [  ]  {     \"  -  -  \"     +    boundary ,     \" Content - Type :    text / plain \"  ,     \" Content - Range :    bytes    0  -  5  /  3  9  \"  ,     \" Spring \"  ,     \"  -  -  \"     +    boundary ,     \" Content - Type :    text / plain \"  ,     \" Content - Range :    bytes    7  -  1  5  /  3  9  \"  ,     \" Framework \"  ,     \"  -  -  \"     +    boundary ,     \" Content - Type :    text / plain \"  ,     \" Content - Range :    bytes    1  7  -  2  0  /  3  9  \"  ,     \" test \"  ,     \"  -  -  \"     +    boundary ,     \" Content - Type :    text / plain \"  ,     \" Content - Range :    bytes    2  2  -  3  8  /  3  9  \"  ,     \" resource   content .  \"  ,     (  \"  -  -  \"     +    boundary )     +     \"  -  -  \"     }  ;", "assertArrayEquals ( expected ,    ranges )  ;", "}  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["shouldEncodeMultipleResourceRegions"], "fileName": "org.springframework.core.codec.ResourceRegionEncoderTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \" Spring   Framework   test   resource   content .  \"  ;", "shouldEncodeMultiples ( new   ByteArrayResource ( content . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldEncodeMultipleResourceRegionsByteArrayResource"], "fileName": "org.springframework.core.codec.ResourceRegionEncoderTests"}, {"methodBody": ["METHOD_START", "{", "shouldEncodeMultipleResourceRegions ( new   ClassPathResource (  \" ResourceRegionEncoderTests . txt \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldEncodeMultipleResourceRegionsFileResource"], "fileName": "org.springframework.core.codec.ResourceRegionEncoderTests"}, {"methodBody": ["METHOD_START", "{", "ResourceRegion   region    =    new   ResourceRegion ( resource ,     0  ,     6  )  ;", "Flux < DataBuffer >    result    =    this . encoder . encode ( Mono . just ( region )  ,    this . bufferFactory ,    ResolvableType . forClass ( ResourceRegion . class )  ,    MimeTypeUtils . APPLICATION _ OCTET _ STREAM ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( result )  . consumeNextWith ( stringConsumer (  \" Spring \"  )  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["shouldEncodeResourceRegion"], "fileName": "org.springframework.core.codec.ResourceRegionEncoderTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \" Spring   Framework   test   resource   content .  \"  ;", "shouldEncode ( new   ByteArrayResource ( content . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldEncodeResourceRegionByteArrayResource"], "fileName": "org.springframework.core.codec.ResourceRegionEncoderTests"}, {"methodBody": ["METHOD_START", "{", "shouldEncodeResourceRegion ( new   ClassPathResource (  \" ResourceRegionEncoderTests . txt \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldEncodeResourceRegionFileResource"], "fileName": "org.springframework.core.codec.ResourceRegionEncoderTests"}, {"methodBody": ["METHOD_START", "{", "return   StringDecoder . allMimeTypes ( StringDecoder . DEFAULT _ DELIMITERS ,    true )  ;", "}", "METHOD_END"], "methodName": ["allMimeTypes"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "return   StringDecoder . allMimeTypes (  )  ;", "}", "METHOD_END"], "methodName": ["allMimeTypes"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "return   new   StringDecoder ( delimiters ,    stripDelimiter ,    new   MimeType (  \" text \"  ,     \" plain \"  ,    StringDecoder . DEFAULT _ CHARSET )  ,    MimeTypeUtils . ALL )  ;", "}", "METHOD_END"], "methodName": ["allMimeTypes"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mimeType    !  =    null )     &  &     (  ( mimeType . getCharset (  )  )     !  =    null )  )     {", "return   mimeType . getCharset (  )  ;", "} else    {", "return    . DEFAULT _ CHARSET ;", "}", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    StringDecoder . getCharset ( mimeType )  ;", "return   this . delimiters . stream (  )  . map (  (    s )     -  >    s . getBytes ( charset )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDelimiterBytes"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =    dataBuffer . readPosition (  )  ;    i    <     ( dataBuffer . writePosition (  )  )  ;    i +  +  )     {", "int   dataBufferPos    =    i ;", "int   delimiterPos    =     0  ;", "while    ( delimiterPos    <     ( delimiter . length )  )     {", "if    (  ( dataBuffer . getByte ( dataBufferPos )  )     !  =     ( delimiter [ delimiterPos ]  )  )     {", "break ;", "} else    {", "dataBufferPos +  +  ;", "if    (  ( dataBufferPos    =  =     ( dataBuffer . writePosition (  )  )  )     &  &     ( delimiterPos    !  =     (  ( delimiter . length )     -     1  )  )  )     {", "return    -  1  ;", "}", "}", "delimiterPos +  +  ;", "}", "if    ( delimiterPos    =  =     ( delimiter . length )  )     {", "return   i    -     ( dataBuffer . readPosition (  )  )  ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "return   dataBuffer    =  =     ( StringDecoder . END _ FRAME )  ;", "}", "METHOD_END"], "methodName": ["isEndFrame"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( dataBuffers . isEmpty (  )  )  )     {", "int   lastIdx    =     ( dataBuffers . size (  )  )     -     1  ;", "if    (  . isEndFrame ( dataBuffers . get ( lastIdx )  )  )     {", "dataBuffers . remove ( lastIdx )  ;", "}", "}", "Flux < DataBuffer >    flux    =    Flux . fromIterable ( dataBuffers )  ;", "return   DataBufferUtils . join ( flux )  ;", "}", "METHOD_END"], "methodName": ["joinUntilEndFrame"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "List < DataBuffer >    frames    =    new   ArrayList <  >  (  )  ;", "do    {", "int   length    =    Integer . MAX _ VALUE ;", "byte [  ]    matchingDelimiter    =    null ;", "for    ( byte [  ]    delimiter    :    delimiterBytes )     {", "int   idx    =     . indexOf ( dataBuffer ,    delimiter )  ;", "if    (  ( idx    >  =     0  )     &  &     ( idx    <    length )  )     {", "length    =    idx ;", "matchingDelimiter    =    delimiter ;", "}", "}", "DataBuffer   frame ;", "int   readPosition    =    dataBuffer . readPosition (  )  ;", "if    ( matchingDelimiter    !  =    null )     {", "if    ( this . stripDelimiter )     {", "frame    =    dataBuffer . slice ( readPosition ,    length )  ;", "} else    {", "frame    =    dataBuffer . slice ( readPosition ,     ( length    +     ( matchingDelimiter . length )  )  )  ;", "}", "dataBuffer . readPosition (  (  ( readPosition    +    length )     +     ( matchingDelimiter . length )  )  )  ;", "frames . add ( DataBufferUtils . retain ( frame )  )  ;", "frames . add (  . END _ FRAME )  ;", "} else    {", "frame    =    dataBuffer . slice ( readPosition ,    dataBuffer . readableByteCount (  )  )  ;", "dataBuffer . readPosition (  ( readPosition    +     ( dataBuffer . readableByteCount (  )  )  )  )  ;", "frames . add ( DataBufferUtils . retain ( frame )  )  ;", "}", "}    while    (  ( dataBuffer . readableByteCount (  )  )     >     0     )  ;", "DataBufferUtils . release ( dataBuffer )  ;", "return   Flux . fromIterable ( frames )  ;", "}", "METHOD_END"], "methodName": ["splitOnDelimiter"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "return   StringDecoder . textPlainOnly ( StringDecoder . DEFAULT _ DELIMITERS ,    true )  ;", "}", "METHOD_END"], "methodName": ["textPlainOnly"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "return   StringDecoder . textPlainOnly (  )  ;", "}", "METHOD_END"], "methodName": ["textPlainOnly"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "return   new   StringDecoder ( delimiters ,    stripDelimiter ,    new   MimeType (  \" text \"  ,     \" plain \"  ,    StringDecoder . DEFAULT _ CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["textPlainOnly"], "fileName": "org.springframework.core.codec.StringDecoder"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    MimeTypeUtils . TEXT _ HTML )  )  ;", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "assertTrue ( this . decoder . canDecode ( ResolvableType . forClass ( String . class )  ,    MimeTypeUtils . parseMimeType (  \" text / plain ; charset = utf -  8  \"  )  )  )  ;", "assertFalse ( this . decoder . canDecode ( ResolvableType . forClass ( Integer . class )  ,    MimeTypeUtils . TEXT _ PLAIN )  )  ;", "assertFalse ( this . decoder . canDecode ( ResolvableType . forClass ( Object . class )  ,    MimeTypeUtils . APPLICATION _ JSON )  )  ;", "}", "METHOD_END"], "methodName": ["canDecode"], "fileName": "org.springframework.core.codec.StringDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  \"  )  )  ;", "Flux <  >    output    =    this . decoder . decode ( source ,    ResolvableType . forClass (  . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext (  \"  \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeEmptyDataBuffer"], "fileName": "org.springframework.core.codec.StringDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . empty (  )  ;", "Flux <  >    output    =    this . decoder . decode ( source ,    ResolvableType . forClass (  . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeEmptyFlux"], "fileName": "org.springframework.core.codec.StringDecoderTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \"  \u00a8\u00b9  \u00a8\u00a6  ?  \"  ;", "Flux < DataBuffer >    source    =    toSingleByteDataBuffers ( s )  ;", "Flux < String >    output    =    this . decoder . decode ( source ,    ResolvableType . forClass ( String . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext ( s )  . verifyComplete (  )  ;", "}", "METHOD_END"], "methodName": ["decodeMultibyteCharacter"], "fileName": "org.springframework.core.codec.StringDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  \\ r \\ nabc \\ n \"  )  ,    stringBuffer (  \" def \"  )  ,    stringBuffer (  \" ghi \\ r \\ n \\ n \"  )  ,    stringBuffer (  \" jkl \"  )  ,    stringBuffer (  \" mno \\ npqr \\ n \"  )  ,    stringBuffer (  \" stu \"  )  ,    stringBuffer (  \" vw \"  )  ,    stringBuffer (  \" xyz \"  )  )  ;", "Flux <  >    output    =    this . decoder . decode ( source ,    ResolvableType . forClass (  . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext (  \"  \"  )  . expectNext (  \" abc \"  )  . expectNext (  \" defghi \"  )  . expectNext (  \"  \"  )  . expectNext (  \" jklmno \"  )  . expectNext (  \" pqr \"  )  . expectNext (  \" stuvwxyz \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeNewLine"], "fileName": "org.springframework.core.codec.StringDecoderTests"}, {"methodBody": ["METHOD_START", "{", "decoder    =    StringDecoder . allMimeTypes ( StringDecoder . DEFAULT _ DELIMITERS ,    false )  ;", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \"  \\ r \\ nabc \\ n \"  )  ,    stringBuffer (  \" def \"  )  ,    stringBuffer (  \" ghi \\ r \\ n \\ n \"  )  ,    stringBuffer (  \" jkl \"  )  ,    stringBuffer (  \" mno \\ npqr \\ n \"  )  ,    stringBuffer (  \" stu \"  )  ,    stringBuffer (  \" vw \"  )  ,    stringBuffer (  \" xyz \"  )  )  ;", "Flux < String >    output    =    this . decoder . decode ( source ,    ResolvableType . forClass ( String . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext (  \"  \\ r \\ n \"  )  . expectNext (  \" abc \\ n \"  )  . expectNext (  \" defghi \\ r \\ n \"  )  . expectNext (  \"  \\ n \"  )  . expectNext (  \" jklmno \\ n \"  )  . expectNext (  \" pqr \\ n \"  )  . expectNext (  \" stuvwxyz \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeNewLineIncludeDelimiters"], "fileName": "org.springframework.core.codec.StringDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . just ( stringBuffer (  \" foo \"  )  ,    stringBuffer (  \" bar \"  )  ,    stringBuffer (  \" baz \"  )  )  ;", "Mono <  >    output    =    this . decoder . decodeToMono ( source ,    ResolvableType . forClass (  . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNext (  \" foobarbaz \"  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeToMono"], "fileName": "org.springframework.core.codec.StringDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    source    =    Flux . empty (  )  ;", "Mono <  >    output    =    this . decoder . decodeToMono ( source ,    ResolvableType . forClass (  . class )  ,    null ,    Collections . emptyMap (  )  )  ;", "StepVerifier . create ( output )  . expectNextCount (  0  )  . expectComplete (  )  . verify (  )  ;", "}", "METHOD_END"], "methodName": ["decodeToMonoWithEmptyFlux"], "fileName": "org.springframework.core.codec.StringDecoderTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    s . getBytes ( StandardCharsets . UTF _  8  )  ;", "List < DataBuffer >    dataBuffers    =    new   ArrayList <  >  (  )  ;", "for    ( byte   b    :    bytes )     {", "dataBuffers . add ( this . bufferFactory . wrap ( new   byte [  ]  {    b    }  )  )  ;", "}", "return   Flux . fromIterable ( dataBuffers )  ;", "}", "METHOD_END"], "methodName": ["toSingleByteDataBuffers"], "fileName": "org.springframework.core.codec.StringDecoderTests"}, {"methodBody": ["METHOD_START", "{", "return   this . sourceType ;", "}", "METHOD_END"], "methodName": ["getSourceType"], "fileName": "org.springframework.core.convert.ConversionFailedException"}, {"methodBody": ["METHOD_START", "{", "return   this . targetType ;", "}", "METHOD_END"], "methodName": ["getTargetType"], "fileName": "org.springframework.core.convert.ConversionFailedException"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.core.convert.ConversionFailedException"}, {"methodBody": ["METHOD_START", "{", "return   this . sourceType ;", "}", "METHOD_END"], "methodName": ["getSourceType"], "fileName": "org.springframework.core.convert.ConverterNotFoundException"}, {"methodBody": ["METHOD_START", "{", "return   this . targetType ;", "}", "METHOD_END"], "methodName": ["getTargetType"], "fileName": "org.springframework.core.convert.ConverterNotFoundException"}, {"methodBody": ["METHOD_START", "{", "if    ( object    !  =    null )     {", "f    ( Annotation   annotation    :    object . getAnnotations (  )  )     {", "annotationMap . put ( annotation . annotationType (  )  ,    annotation )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addAnnotationsToMap"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getReadMethod (  )  )     !  =    null )     {", "return   getReadMethod (  )  . getDeclaClass (  )  ;", "} else", "if    (  ( getWriteMethod (  )  )     !  =    null )     {", "return   getWriteMethod (  )  . getDeclaClass (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["declaringClass"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . annotations )     =  =    null )     {", "this . annotations    =    resolveAnnotations (  )  ;", "}", "return   this . annotations ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "String   name    =    getName (  )  ;", "if    (  !  ( StringUtils . hasLength ( name )  )  )     {", "return   null ;", "}", "Field   field    =    null ;", "Class <  ?  >    declaringClass    =    declaringClass (  )  ;", "if    ( declaringClass    !  =    null )     {", "field    =    ReflectionUtils . findField ( declaringClass ,    name )  ;", "if    ( field    =  =    null )     {", "field    =    ReflectionUtils . findField ( declaringClass ,    StringUtils . uncapitalize ( name )  )  ;", "if    ( field    =  =    null )     {", "field    =    ReflectionUtils . findField ( declaringClass ,    StringUtils . capitalize ( name )  )  ;", "}", "}", "}", "return   field ;", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "return   this . methodParameter ;", "}", "METHOD_END"], "methodName": ["getMethodParameter"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "return   this . objectType ;", "}", "METHOD_END"], "methodName": ["getObjectType"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "return   this . readMethod ;", "}", "METHOD_END"], "methodName": ["getReadMethod"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "return   this . methodParameter . getParameterType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "return   this . writeMethod ;", "}", "METHOD_END"], "methodName": ["getWriteMethod"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    annotations    =    Property . annotationCache . get ( this )  ;", "if    ( annotations    =  =    null )     {", "Map < Class <  ?    extends   Annotation >  ,    Annotation >    annotationMap    =    new   LinkedHashMap <  >  (  )  ;", "addAnnotationsToMap ( annotationMap ,    getReadMethod (  )  )  ;", "addAnnotationsToMap ( annotationMap ,    getWriteMethod (  )  )  ;", "addAnnotationsToMap ( annotationMap ,    getField (  )  )  ;", "annotations    =    annotationMap . values (  )  . toArray ( new   Annotation [  0  ]  )  ;", "Property . annotationCache . put ( this ,    annotations )  ;", "}", "return   annotations ;", "}", "METHOD_END"], "methodName": ["resolveAnnotations"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   read    =    resolveReadMethodParameter (  )  ;", "MethodParameter   write    =    resolveWriteMethodParameter (  )  ;", "if    ( write    =  =    null )     {", "if    ( read    =  =    null )     {", "throw   new   IllegalStateException (  \"    is   neither   readable   nor   writeable \"  )  ;", "}", "return   read ;", "}", "if    ( read    !  =    null )     {", "Class <  ?  >    readType    =    read . getParameterType (  )  ;", "Class <  ?  >    writeType    =    write . getParameterType (  )  ;", "if    (  (  !  ( writeType . equals ( readType )  )  )     &  &     ( writeType . isAssignableFrom ( readType )  )  )     {", "return   read ;", "}", "}", "return   write ;", "}", "METHOD_END"], "methodName": ["resolveMethodParameter"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . readMethod )     !  =    null )     {", "int   index    =    this . readMethod . getName (  )  . indexOf (  \" get \"  )  ;", "if    ( index    !  =     (  -  1  )  )     {", "index    +  =     3  ;", "} else    {", "index    =    this . readMethod . getName (  )  . indexOf (  \" is \"  )  ;", "if    ( index    =  =     (  -  1  )  )     {", "throw   new   IllegalArgumentException (  \" Not   a   getter   method \"  )  ;", "}", "index    +  =     2  ;", "}", "return   StringUtils . uncapitalize ( this . readMethod . getName (  )  . substring ( index )  )  ;", "} else", "if    (  ( this . writeMethod )     !  =    null )     {", "int   index    =    this . writeMethod . getName (  )  . indexOf (  \" set \"  )  ;", "if    ( index    =  =     (  -  1  )  )     {", "throw   new   IllegalArgumentException (  \" Not   a   setter   method \"  )  ;", "}", "index    +  =     3  ;", "return   StringUtils . uncapitalize ( this . writeMethod . getName (  )  . substring ( index )  )  ;", "} else    {", "throw   new   IllegalStateException (  \"    is   neither   readable   nor   writeable \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveName"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "GenericTypeResolver . resolveParameterType ( parameter ,    getObjectType (  )  )  ;", "return   parameter ;", "}", "METHOD_END"], "methodName": ["resolveParameterType"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getReadMethod (  )  )     =  =    null )     {", "return   null ;", "}", "return   resolvePaterType ( new   MethodPater ( getReadMethod (  )  ,     (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveReadMethodParameter"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getWriteMethod (  )  )     =  =    null )     {", "return   null ;", "}", "return   resolvePaterType ( new   MethodPater ( getWriteMethod (  )  ,     0  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWriteMethodParameter"], "fileName": "org.springframework.core.convert.Property"}, {"methodBody": ["METHOD_START", "{", "return    ( ann    =  =    otherAnn )     |  |     (  (  ( ann . getClass (  )  )     =  =     ( otherAnn . getClass (  )  )  )     &  &     ( ann . equals ( otherAnn )  )  )  ;", "}", "METHOD_END"], "methodName": ["annotationEquals"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    anns    =    getAnnotations (  )  ;", "Annotation [  ]    otherAnns    =    other . getAnnotations (  )  ;", "if    ( anns    =  =    otherAnns )     {", "return   true ;", "}", "if    (  ( anns . length )     !  =     ( otherAnns . length )  )     {", "return   false ;", "}", "if    (  ( anns . length )     >     0  )     {", "for    ( int   i    =     0  ;    i    <     ( anns . length )  ;    i +  +  )     {", "if    (  !  ( annotationEquals ( anns [ i ]  ,    otherAnns [ i ]  )  )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["annotationsMatch"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( elementTypeDescriptor    =  =    null )     {", "return   null ;", "}", "return   new   TypeDescriptor ( ResolvableType . forArrayComponent ( elementTypeDescriptor . resolvableType )  ,    null ,    elementTypeDescriptor . getAnnotations (  )  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( collectionType ,     \" Collection   type   must   not   be   null \"  )  ;", "if    (  !  ( Collection . class . isAssignableFrom ( collectionType )  )  )     {", "throw   new   IllegalArgumentException (  \" Collection   type   must   be   a    [ Collection ]  \"  )  ;", "}", "ResolvableType   element    =     ( element    !  =    null )     ?    element . resolvableType    :    null ;", "return   new    ( ResolvableType . forClassWithGenerics ( collectionType ,    element )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["collection"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   narrow ( element ,    getElementTypeDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["elementTypeDescriptor"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   source    !  =    null    ?    TypeDescriptor . valueOf ( source . getClass (  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["forObject"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( this . annotatedElement . isEmpty (  )  )     {", "return   null ;", "}", "return   AnnotatedElementUtils . getMergedAnnotation ( this . annotatedElement ,    annotation )  ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . annotatedElement . getAnnotations (  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( getResolvableType (  )  . isArray (  )  )     {", "return   new    ( getResolvableType (  )  . getComponentType (  )  ,    null ,    getAnnotations (  )  )  ;", "}", "if    ( Stream . class . isAssignableFrom ( getType (  )  )  )     {", "return    . getRelatedIfResolvable ( this ,    getResolvableType (  )  . as ( Stream . class )  . getGeneric (  0  )  )  ;", "}", "return    . getRelatedIfResolvable ( this ,    getResolvableType (  )  . asCollection (  )  . getGeneric (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getElementTypeDescriptor"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( isMap (  )  ,     \" Not   a    [ Map ]  \"  )  ;", "return    . getRelatedIfResolvable ( this ,    getResolvableType (  )  . asMap (  )  . getGeneric (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getMapKeyTypeDescriptor"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   narrow ( mapKey ,    getMapKeyTypeDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMapKeyTypeDescriptor"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( isMap (  )  ,     \" Not   a    [ Map ]  \"  )  ;", "return    . getRelatedIfResolvable ( this ,    getResolvableType (  )  . asMap (  )  . getGeneric (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["getMapValueTypeDescriptor"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   narrow ( mapValue ,    getMapValueTypeDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMapValueTypeDescriptor"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getQualifiedName ( getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . resolvePrimitiveIfNecessary ( getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getObjectType"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type . resolve (  )  )     =  =    null )     {", "return   null ;", "}", "return   new    ( type ,    null ,    source . getAnnotations (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRelatedIfResolvable"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . resolvableType ;", "}", "METHOD_END"], "methodName": ["getResolvableType"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . resolvableType . getSource (  )  ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( this . annotatedElement . isEmpty (  )  )     {", "return   false ;", "}", "return   AnnotatedElementUtils . isAnnotated ( this . annotatedElement ,    annotation )  ;", "}", "METHOD_END"], "methodName": ["hasAnnotation"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   getType (  )  . isArray (  )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "boolean   typesAssignable    =    typeDescriptor . getObjectType (  )  . isAssignableFrom ( getObjectType (  )  )  ;", "if    (  ! typesAssignable )     {", "return   false ;", "}", "if    (  ( isArray (  )  )     &  &     ( typeDescriptor . isArray (  )  )  )     {", "return   isNestedAssignable ( getElement (  )  ,    typeDescriptor . getElement (  )  )  ;", "} else", "if    (  ( isCollection (  )  )     &  &     ( typeDescriptor . isCollection (  )  )  )     {", "return   isNestedAssignable ( getElement (  )  ,    typeDescriptor . getElement (  )  )  ;", "} else", "if    (  ( isMap (  )  )     &  &     ( typeDescriptor . isMap (  )  )  )     {", "return    ( isNestedAssignable ( getMapKey (  )  ,    typeDescriptor . getMapKey (  )  )  )     &  &     ( isNestedAssignable ( getMapValue (  )  ,    typeDescriptor . getMapValue (  )  )  )  ;", "} else    {", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["isAssignableTo"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   Collection . class . isAssignableFrom ( getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isCollection"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   Map . class . isAssignableFrom ( getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isMap"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( nestedTypeDescriptor    =  =    null )     |  |     ( otherNestedTypeDescriptor    =  =    null )  )     |  |     ( nestedTypeDescriptor . isAssignableTo ( otherNestedTypeDescriptor )  )  ;", "}", "METHOD_END"], "methodName": ["isNestedAssignable"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   getType (  )  . isPrimitive (  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitive"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mapType ,     \" Map   type   must   not   be   null \"  )  ;", "if    (  !  ( Map . class . isAssignableFrom ( mapType )  )  )     {", "throw   new   IllegalArgumentException (  \" Map   type   must   be   a    [ Map ]  \"  )  ;", "}", "ResolvableType   key    =     ( key    !  =    null )     ?    key . resolvableType    :    null ;", "ResolvableType   value    =     ( value    !  =    null )     ?    value . resolvableType    :    null ;", "return   new    ( ResolvableType . forClassWithGenerics ( mapType ,    key ,    value )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return   this ;", "}", "ResolvableType   narrowed    =    ResolvableType . forType ( value . getClass (  )  ,    getResolvableType (  )  )  ;", "return   new    ( narrowed ,    value . getClass (  )  ,    getAnnotations (  )  )  ;", "}", "METHOD_END"], "methodName": ["narrow"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( typeDescriptor    !  =    null )     {", "return   typeDescriptor . narrow ( value )  ;", "}", "if    ( value    !  =    null )     {", "return   narrow ( value )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["narrow"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   TypeDescriptor . nested ( new   TypeDescriptor ( field )  ,    nestingLevel )  ;", "}", "METHOD_END"], "methodName": ["nested"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( methodParameter . getNestingLevel (  )  )     !  =     1  )     {", "throw   new   IllegalArgumentException (  (  \" MethodParameter   nesting   level   must   be    1  :     \"     +     \" use   the   nestingLevel   parameter   to   specify   the   desired   nestingLevel   for   nested   type   traversal \"  )  )  ;", "}", "return    . nested ( new    ( methodParameter )  ,    nestingLevel )  ;", "}", "METHOD_END"], "methodName": ["nested"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   TypeDescriptor . nested ( new   TypeDescriptor ( property )  ,    nestingLevel )  ;", "}", "METHOD_END"], "methodName": ["nested"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   nested    =    typeDescriptor . resolvableType ;", "for    ( int   i    =     0  ;    i    <    nestingLevel ;    i +  +  )     {", "if    (  ( Object . class )     =  =     ( nested . getType (  )  )  )     {", "} else    {", "nested    =    nested . getNested (  2  )  ;", "}", "}", "if    ( nested    =  =     ( ResolvableType . NONE )  )     {", "return   null ;", "}", "return    . getRelatedIfResolvable ( typeDescriptor ,    nested )  ;", "}", "METHOD_END"], "methodName": ["nested"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( superType    =  =    null )     {", "return   null ;", "}", "Assert . isAssignable ( superType ,    getType (  )  )  ;", "return   new    ( getResolvableType (  )  . as ( superType )  ,    superType ,    getAnnotations (  )  )  ;", "}", "METHOD_END"], "methodName": ["upcast"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )     {", "type    =    Object . class ;", "}", "desc    =     . commonTypesCache . get ( type )  ;", "return   desc    !  =    null    ?    desc    :    new    ( ResolvableType . forClass ( type )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["valueOf"], "fileName": "org.springframework.core.convert.TypeDescriptor"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( new   MethodParameter ( getClass (  )  . getMethod ( methodName )  ,     (  -  1  )  )  )  ;", "assertNotNull (  (  (  (  (  \" Should   have   found    @  \"     +     ( annotationType . getSimpleName (  )  )  )     +     \"    on    \"  )     +    methodName )     +     \"  .  \"  )  ,    typeDescriptor . getAnnotation ( annotationType )  )  ;", "}", "METHOD_END"], "methodName": ["assertAnnotationFoundOnMethod"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . collection ( List . class ,    TypeDescriptor . valueOf ( Integer . class )  )  ;", "assertEquals ( List . class ,    desc . getType (  )  )  ;", "assertEquals ( List . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" List \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" List < Integer >  \"  ,    desc . toString (  )  )  ;", "assertTrue (  (  !  ( desc . isPrimitive (  )  )  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertTrue ( desc . isCollection (  )  )  ;", "assertFalse ( desc . isArray (  )  )  ;", "assertEquals ( Integer . class ,    desc . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( TypeDescriptor . valueOf ( Integer . class )  ,    desc . getElementTypeDescriptor (  )  )  ;", "assertFalse ( desc . isMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["collection"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . collection ( List . class ,    TypeDescriptor . collection ( List . class ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "assertEquals ( List . class ,    desc . getType (  )  )  ;", "assertEquals ( List . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" List \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" List < List < Integer >  >  \"  ,    desc . toString (  )  )  ;", "assertTrue (  (  !  ( desc . isPrimitive (  )  )  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertTrue ( desc . isCollection (  )  )  ;", "assertFalse ( desc . isArray (  )  )  ;", "assertEquals ( List . class ,    desc . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( TypeDescriptor . valueOf ( Integer . class )  ,    desc . getElementTypeDescriptor (  )  . getElementTypeDescriptor (  )  )  ;", "assertFalse ( desc . isMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["collectionNested"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    TypeDescriptor . collection ( List . class ,    null )  ;", "assertThat ( typeDescriptor . getElementTypeDescriptor (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCollectionWithNullElement"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   mapType    =    TypeDescriptor . map ( LinkedHashMap . class ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  ;", "TypeDescriptor   arrayType    =    TypeDescriptor . array ( mapType )  ;", "assertEquals ( arrayType . getType (  )  ,    LinkedHashMap [  ]  . class )  ;", "assertEquals ( arrayType . getElementTypeDescriptor (  )  ,    mapType )  ;", "}", "METHOD_END"], "methodName": ["createMapArray"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    TypeDescriptor . map ( LinkedHashMap . class ,    null ,    null )  ;", "assertThat ( typeDescriptor . getMapKeyTypeDescriptor (  )  ,    nullValue (  )  )  ;", "assertThat ( typeDescriptor . getMapValueTypeDescriptor (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["createMapWithNullElements"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( TypeDescriptor . array ( null )  )  ;", "}", "METHOD_END"], "methodName": ["createNullArray"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   arrayType    =    TypeDescriptor . array ( TypeDescriptor . valueOf ( String . class )  )  ;", "assertEquals ( arrayType ,    TypeDescriptor . valueOf ( String [  ]  . class )  )  ;", "}", "METHOD_END"], "methodName": ["createStringArray"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . valueOf ( List . class )  ;", "Integer   value    =    Integer . valueOf (  3  )  ;", "desc    =    desc . elementTypeDescriptor ( value )  ;", "assertEquals ( Integer . class ,    desc . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["elementType"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" serial \"  )", "class   CustomSet   extends   HashSet < String >     {  }", "assertEquals (  . valueOf ( CustomSet . class )  . getElement (  )  ,     . valueOf ( String . class )  )  ;", "assertEquals (  . forObject ( new   CustomSet (  )  )  . getElement (  )  ,     . valueOf ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["elementTypeForCollectionSubclass"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" serial \"  )", "class   CustomMap   extends   HashMap < String ,    Integer >     {  }", "assertEquals (  . valueOf ( CustomMap . class )  . getMapKey (  )  ,     . valueOf ( String . class )  )  ;", "assertEquals (  . valueOf ( CustomMap . class )  . getMapValue (  )  ,     . valueOf ( Integer . class )  )  ;", "assertEquals (  . forObject ( new   CustomMap (  )  )  . getMapKey (  )  ,     . valueOf ( String . class )  )  ;", "assertEquals (  . forObject ( new   CustomMap (  )  )  . getMapValue (  )  ,     . valueOf ( Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["elementTypeForMapSubclass"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    new   TypeDescriptor ( getClass (  )  . getField (  \" listPreserveContext \"  )  )  ;", "assertEquals ( Integer . class ,    desc . getElementTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "List < Integer >    value    =    new   ArrayList <  >  (  3  )  ;", "desc    =    desc . elementTypeDescriptor ( value )  ;", "assertEquals ( Integer . class ,    desc . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertNotNull ( desc . getAnnotation (  . FieldAnnotation . class )  )  ;", "}", "METHOD_END"], "methodName": ["elementTypePreserveContext"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   t 1     =    TypeDescriptor . valueOf ( String . class )  ;", "TypeDescriptor   t 2     =    TypeDescriptor . valueOf ( String . class )  ;", "TypeDescriptor   t 3     =    TypeDescriptor . valueOf ( Date . class )  ;", "TypeDescriptor   t 4     =    TypeDescriptor . valueOf ( Date . class )  ;", "TypeDescriptor   t 5     =    TypeDescriptor . valueOf ( List . class )  ;", "TypeDescriptor   t 6     =    TypeDescriptor . valueOf ( List . class )  ;", "TypeDescriptor   t 7     =    TypeDescriptor . valueOf ( Map . class )  ;", "TypeDescriptor   t 8     =    TypeDescriptor . valueOf ( Map . class )  ;", "assertEquals ( t 1  ,    t 2  )  ;", "assertEquals ( t 3  ,    t 4  )  ;", "assertEquals ( t 5  ,    t 6  )  ;", "assertEquals ( t 7  ,    t 8  )  ;", "TypeDescriptor   t 9     =    new   TypeDescriptor ( getClass (  )  . getField (  \" listField \"  )  )  ;", "TypeDescriptor   t 1  0     =    new   TypeDescriptor ( getClass (  )  . getField (  \" listField \"  )  )  ;", "assertEquals ( t 9  ,    t 1  0  )  ;", "TypeDescriptor   t 1  1     =    new   TypeDescriptor ( getClass (  )  . getField (  \" mapField \"  )  )  ;", "TypeDescriptor   t 1  2     =    new   TypeDescriptor ( getClass (  )  . getField (  \" mapField \"  )  )  ;", "assertEquals ( t 1  1  ,    t 1  2  )  ;", "MethodParameter   testAnnotatedMethod    =    new   MethodParameter ( getClass (  )  . getMethod (  \" testAnnotatedMethod \"  ,    String . class )  ,     0  )  ;", "TypeDescriptor   t 1  3     =    new   TypeDescriptor ( testAnnotatedMethod )  ;", "TypeDescriptor   t 1  4     =    new   TypeDescriptor ( testAnnotatedMethod )  ;", "assertEquals ( t 1  3  ,    t 1  4  )  ;", "TypeDescriptor   t 1  5     =    new   TypeDescriptor ( testAnnotatedMethod )  ;", "TypeDescriptor   t 1  6     =    new   TypeDescriptor ( new   MethodParameter ( getClass (  )  . getMethod (  \" testAnnotatedMethodDifferentAnnotationValue \"  ,    String . class )  ,     0  )  )  ;", "assertNotEquals ( t 1  5  ,    t 1  6  )  ;", "TypeDescriptor   t 1  7     =    new   TypeDescriptor ( testAnnotatedMethod )  ;", "TypeDescriptor   t 1  8     =    new   TypeDescriptor ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 5  \"  ,    String . class )  ,     0  )  )  ;", "assertNotEquals ( t 1  7  ,    t 1  8  )  ;", "}", "METHOD_END"], "methodName": ["equality"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( getClass (  )  . getField (  \" fieldAnnotated \"  )  )  ;", "assertEquals (  1  ,    typeDescriptor . getAnnotations (  )  . length )  ;", "assertNotNull ( typeDescriptor . getAnnotation (  . FieldAnnotation . class )  )  ;", "}", "METHOD_END"], "methodName": ["fieldAnnotated"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( TypeDescriptorTests . class . getDeclaredField (  \" intArray \"  )  )  ;", "assertTrue ( typeDescriptor . isArray (  )  )  ;", "assertEquals ( Integer . TYPE ,    typeDescriptor . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \" int [  ]  \"  ,    typeDescriptor . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldArray"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( TypeDescriptorTests . class . getDeclaredField (  \" arrayOfListOfString \"  )  )  ;", "assertTrue ( typeDescriptor . isArray (  )  )  ;", "assertEquals ( List . class ,    typeDescriptor . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( String . class ,    typeDescriptor . getElementTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \" List < String >  [  ]  \"  ,    typeDescriptor . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldComplexTypeDescriptor"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( TypeDescriptorTests . class . getDeclaredField (  \" nestedMapField \"  )  )  ;", "assertTrue ( typeDescriptor . isMap (  )  )  ;", "assertEquals ( String . class ,    typeDescriptor . getMapKeyTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( List . class ,    typeDescriptor . getMapValueTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Integer . class ,    typeDescriptor . getMapValueTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \" Map < String ,    List < Integer >  >  \"  ,    typeDescriptor . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldComplexTypeDescriptor2"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( TypeDescriptorTests . class . getDeclaredField (  \" listOfString \"  )  )  ;", "assertFalse ( typeDescriptor . isArray (  )  )  ;", "assertEquals ( List . class ,    typeDescriptor . getType (  )  )  ;", "assertEquals ( String . class ,    typeDescriptor . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \" List < String >  \"  ,    typeDescriptor . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldList"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( TypeDescriptorTests . class . getDeclaredField (  \" listOfListOfString \"  )  )  ;", "assertFalse ( typeDescriptor . isArray (  )  )  ;", "assertEquals ( List . class ,    typeDescriptor . getType (  )  )  ;", "assertEquals ( List . class ,    typeDescriptor . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( String . class ,    typeDescriptor . getElementTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \" List < List < String >  >  \"  ,    typeDescriptor . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldListOfListOfString"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( TypeDescriptorTests . class . getDeclaredField (  \" listOfListOfUnknown \"  )  )  ;", "assertFalse ( typeDescriptor . isArray (  )  )  ;", "assertEquals ( List . class ,    typeDescriptor . getType (  )  )  ;", "assertEquals ( List . class ,    typeDescriptor . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertNull ( typeDescriptor . getElementTypeDescriptor (  )  . getElementTypeDescriptor (  )  )  ;", "assertEquals (  \" List < List <  ?  >  >  \"  ,    typeDescriptor . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldListOfListUnknown"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    new   TypeDescriptor ( TypeDescriptorTests . class . getField (  \" fieldMap \"  )  )  ;", "assertTrue ( desc . isMap (  )  )  ;", "assertEquals ( Integer . class ,    desc . getMapKeyTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Long . class ,    desc . getMapValueTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldMap"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( getClass (  )  . getField (  \" fieldScalar \"  )  )  ;", "assertFalse ( typeDescriptor . isPrimitive (  )  )  ;", "assertFalse ( typeDescriptor . isArray (  )  )  ;", "assertFalse ( typeDescriptor . isCollection (  )  )  ;", "assertFalse ( typeDescriptor . isMap (  )  )  ;", "assertEquals ( Integer . class ,    typeDescriptor . getType (  )  )  ;", "assertEquals ( Integer . class ,    typeDescriptor . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["fieldScalar"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . forObject (  \"  3  \"  )  ;", "assertEquals ( String . class ,    desc . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["forObject"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . forObject ( null )  ;", "assertNull ( desc )  ;", "}", "METHOD_END"], "methodName": ["forObjectNullTypeDescriptor"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "assertAnnotationFoundOnMethod ( TypeDescriptorTests . MethodAnnotation 1  . class ,     \" methodWithLocalAnnotation \"  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationOnMethodThatIsLocallyAnnotated"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "assertAnnotationFoundOnMethod ( TypeDescriptorTests . MethodAnnotation 1  . class ,     \" methodWithComposedAnnotation \"  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationOnMethodThatIsMetaAnnotated"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "assertAnnotationFoundOnMethod ( TypeDescriptorTests . MethodAnnotation 1  . class ,     \" methodWithComposedComposedAnnotation \"  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotationOnMethodThatIsMetaMetaAnnotated"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getComplexProperty"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "return   property ;", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    getClass (  )  . getField (  \" fieldScalar \"  )  ;", "MethodParameter   methodParameter    =    new   MethodParameter ( getClass (  )  . getMethod (  \" testParameterPrimitive \"  ,    int . class )  ,     0  )  ;", "assertThat ( new    ( field )  . getSource (  )  ,    equalTo (  (  ( Object )     ( field )  )  )  )  ;", "assertThat ( new    ( methodParameter )  . getSource (  )  ,    equalTo (  (  ( Object )     ( methodParameter )  )  )  )  ;", "assertThat (  . valueOf ( Integer . class )  . getSource (  )  ,    equalTo (  (  ( Object )     ( Integer . class )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getTest4"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( new   TypeDescriptor ( getClass (  )  . getField (  \" listField \"  )  )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" listField \"  )  )  )  )  ;", "assertTrue ( new   TypeDescriptor ( getClass (  )  . getField (  \" notGenericList \"  )  )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" listField \"  )  )  )  )  ;", "assertTrue ( new   TypeDescriptor ( getClass (  )  . getField (  \" listField \"  )  )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" notGenericList \"  )  )  )  )  ;", "assertFalse ( new   TypeDescriptor ( getClass (  )  . getField (  \" isAssignableElementTypes \"  )  )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" listField \"  )  )  )  )  ;", "assertTrue ( TypeDescriptor . valueOf ( List . class )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" listField \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableElementTypes"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( new   TypeDescriptor ( getClass (  )  . getField (  \" mapField \"  )  )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" mapField \"  )  )  )  )  ;", "assertTrue ( new   TypeDescriptor ( getClass (  )  . getField (  \" notGenericMap \"  )  )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" mapField \"  )  )  )  )  ;", "assertTrue ( new   TypeDescriptor ( getClass (  )  . getField (  \" mapField \"  )  )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" notGenericMap \"  )  )  )  )  ;", "assertFalse ( new   TypeDescriptor ( getClass (  )  . getField (  \" isAssignableMapKeyValueTypes \"  )  )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" mapField \"  )  )  )  )  ;", "assertTrue ( TypeDescriptor . valueOf ( Map . class )  . isAssignableTo ( new   TypeDescriptor ( getClass (  )  . getField (  \" mapField \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableMapKeyValueTypes"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TypeDescriptor . valueOf ( Integer . class )  . isAssignableTo ( TypeDescriptor . valueOf ( Number . class )  )  )  ;", "assertFalse ( TypeDescriptor . valueOf ( Number . class )  . isAssignableTo ( TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "assertFalse ( TypeDescriptor . valueOf ( String . class )  . isAssignableTo ( TypeDescriptor . valueOf ( String [  ]  . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableTypes"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . map ( Map . class ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  ;", "assertEquals ( Map . class ,    desc . getType (  )  )  ;", "assertEquals ( Map . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" Map \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" Map < String ,    Integer >  \"  ,    desc . toString (  )  )  ;", "assertTrue (  (  !  ( desc . isPrimitive (  )  )  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertFalse ( desc . isCollection (  )  )  ;", "assertFalse ( desc . isArray (  )  )  ;", "assertTrue ( desc . isMap (  )  )  ;", "assertEquals ( String . class ,    desc . getMapKeyTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Integer . class ,    desc . getMapValueTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . valueOf ( Map . class )  ;", "Integer   value    =    Integer . valueOf (  3  )  ;", "desc    =    desc . getMapKeyTypeDescriptor ( value )  ;", "assertEquals ( Integer . class ,    desc . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["mapKeyType"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    new   TypeDescriptor ( getClass (  )  . getField (  \" mapPreserveContext \"  )  )  ;", "assertEquals ( Integer . class ,    desc . getMapKeyTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "List < Integer >    value    =    new   ArrayList <  >  (  3  )  ;", "desc    =    desc . getMapKeyTypeDescriptor ( value )  ;", "assertEquals ( Integer . class ,    desc . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertNotNull ( desc . getAnnotation (  . FieldAnnotation . class )  )  ;", "}", "METHOD_END"], "methodName": ["mapKeyTypePreserveContext"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . map ( Map . class ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . map ( Map . class ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "assertEquals ( Map . class ,    desc . getType (  )  )  ;", "assertEquals ( Map . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" Map \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" Map < String ,    Map < String ,    Integer >  >  \"  ,    desc . toString (  )  )  ;", "assertTrue (  (  !  ( desc . isPrimitive (  )  )  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertFalse ( desc . isCollection (  )  )  ;", "assertFalse ( desc . isArray (  )  )  ;", "assertTrue ( desc . isMap (  )  )  ;", "assertEquals ( String . class ,    desc . getMapKeyTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( String . class ,    desc . getMapValueTypeDescriptor (  )  . getMapKeyTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Integer . class ,    desc . getMapValueTypeDescriptor (  )  . getMapValueTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["mapNested"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . valueOf ( Map . class )  ;", "Integer   value    =    Integer . valueOf (  3  )  ;", "desc    =    desc . getMapValueTypeDescriptor ( value )  ;", "assertEquals ( Integer . class ,    desc . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["mapValueType"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    new   TypeDescriptor ( getClass (  )  . getField (  \" mapPreserveContext \"  )  )  ;", "assertEquals ( Integer . class ,    desc . getMapValueTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "List < Integer >    value    =    new   ArrayList <  >  (  3  )  ;", "desc    =    desc . getMapValueTypeDescriptor ( value )  ;", "assertEquals ( Integer . class ,    desc . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertNotNull ( desc . getAnnotation (  . FieldAnnotation . class )  )  ;", "}", "METHOD_END"], "methodName": ["mapValueTypePreserveContext"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   td    =    new   TypeDescriptor ( getClass (  )  . getField (  \" multiValueMap \"  )  )  ;", "assertTrue ( td . isMap (  )  )  ;", "assertEquals ( String . class ,    td . getMapKeyTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( List . class ,    td . getMapValueTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Integer . class ,    td . getMapValueTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["multiValueMap"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    TypeDescriptor . valueOf ( Number . class )  ;", "Integer   value    =    Integer . valueOf (  3  )  ;", "desc    =    desc . narrow ( value )  ;", "assertEquals ( Integer . class ,    desc . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["narrow"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   t 1     =    TypeDescriptor . nested ( getClass (  )  . getField (  \" test 4  \"  )  ,     2  )  ;", "assertEquals ( String . class ,    t 1  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["nestedFieldTypeMapTwoLevels"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor . nested ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 4  \"  ,    List . class )  ,     0  ,     2  )  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["nestedMethodParameterNot1NestedLevel"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   t 1     =    TypeDescriptor . nested ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 2  \"  ,    List . class )  ,     0  )  ,     2  )  ;", "assertEquals ( String . class ,    t 1  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["nestedMethodParameterType2Levels"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor . nested ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 5  \"  ,    String . class )  ,     0  ,     2  )  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["nestedMethodParameterTypeInvalidNestingLevel"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   t 1     =    TypeDescriptor . nested ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 3  \"  ,    Map . class )  ,     0  )  ,     1  )  ;", "assertEquals ( String . class ,    t 1  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["nestedMethodParameterTypeMap"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   t 1     =    TypeDescriptor . nested ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 4  \"  ,    List . class )  ,     0  )  ,     2  )  ;", "assertEquals ( String . class ,    t 1  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["nestedMethodParameterTypeMapTwoLevels"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   t 1     =    TypeDescriptor . nested ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 5  \"  ,    String . class )  ,     0  )  ,     2  )  ;", "assertNull ( t 1  )  ;", "}", "METHOD_END"], "methodName": ["nestedMethodParameterTypeNotNestable"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   t 1     =    TypeDescriptor . nested ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 6  \"  ,    List . class )  ,     0  )  ,     1  )  ;", "assertEquals ( List . class ,    t 1  . getType (  )  )  ;", "assertEquals (  \" List <  ?  >  \"  ,    t 1  . toString (  )  )  ;", "TypeDescriptor   t 2     =    TypeDescriptor . nested ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 6  \"  ,    List . class )  ,     0  )  ,     2  )  ;", "assertNull ( t 2  )  ;", "}", "METHOD_END"], "methodName": ["nestedNotParameterized"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "Property   property    =    new   Property ( getClass (  )  ,    getClass (  )  . getMethod (  \" getTest 4  \"  )  ,    getClass (  )  . getMethod (  \" setTest 4  \"  ,    List . class )  )  ;", "t 1     =     . nested ( property ,     2  )  ;", "assertEquals ( String . class ,    t 1  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["nestedPropertyTypeMapTwoLevels"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   t 1     =    TypeDescriptor . nested ( new   MethodParameter ( getClass (  )  . getMethod (  \" test 4  \"  ,    List . class )  ,     0  )  ,     3  )  ;", "assertNull ( t 1  )  ;", "}", "METHOD_END"], "methodName": ["nestedTooManyLevels"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   t 1     =    new   TypeDescriptor ( new   MethodParameter ( getClass (  )  . getMethod (  \" testAnnotatedMethod \"  ,    String . class )  ,     0  )  )  ;", "assertEquals ( String . class ,    t 1  . getType (  )  )  ;", "assertEquals (  1  ,    t 1  . getAnnotations (  )  . length )  ;", "assertNotNull ( t 1  . getAnnotation (  . ParameterAnnotation . class )  )  ;", "assertTrue ( t 1  . hasAnnotation (  . ParameterAnnotation . class )  )  ;", "assertEquals (  1  2  3  ,    t 1  . getAnnotation (  . ParameterAnnotation . class )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterAnnotated"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   methodParameter    =    new   MethodParameter ( getClass (  )  . getMethod (  \" testParameterArray \"  ,    Integer [  ]  . class )  ,     0  )  ;", "desc    =    new    ( methodParameter )  ;", "assertEquals ( Integer [  ]  . class ,    desc . getType (  )  )  ;", "assertEquals ( Integer [  ]  . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" Integer [  ]  \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" Integer [  ]  \"  ,    desc . toString (  )  )  ;", "assertTrue (  (  !  ( desc . isPrimitive (  )  )  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertFalse ( desc . isCollection (  )  )  ;", "assertTrue ( desc . isArray (  )  )  ;", "assertEquals ( Integer . class ,    desc . getElement (  )  . getType (  )  )  ;", "assertEquals (  . valueOf ( Integer . class )  ,    desc . getElement (  )  )  ;", "assertFalse ( desc . isMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterArray"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   methodParameter    =    new   MethodParameter ( getClass (  )  . getMethod (  \" testParameterList \"  ,    List . class )  ,     0  )  ;", "desc    =    new    ( methodParameter )  ;", "assertEquals ( List . class ,    desc . getType (  )  )  ;", "assertEquals ( List . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" List \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" List < List < Map < Integer ,    Enum <  ?  >  >  >  >  \"  ,    desc . toString (  )  )  ;", "assertTrue (  (  !  ( desc . isPrimitive (  )  )  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertTrue ( desc . isCollection (  )  )  ;", "assertFalse ( desc . isArray (  )  )  ;", "assertEquals ( List . class ,    desc . getElement (  )  . getType (  )  )  ;", "assertEquals (  . nested ( methodParameter ,     1  )  ,    desc . getElement (  )  )  ;", "assertEquals (  . nested ( methodParameter ,     2  )  ,    desc . getElement (  )  . getElement (  )  )  ;", "assertEquals (  . nested ( methodParameter ,     3  )  ,    desc . getElement (  )  . getElement (  )  . getMapValue (  )  )  ;", "assertEquals ( Integer . class ,    desc . getElement (  )  . getElement (  )  . getMapKey (  )  . getType (  )  )  ;", "assertEquals ( Enum . class ,    desc . getElement (  )  . getElement (  )  . getMapValue (  )  . getType (  )  )  ;", "assertFalse ( desc . isMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterList"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   methodParameter    =    new   MethodParameter ( getClass (  )  . getMethod (  \" testParameterListNoParamTypes \"  ,    List . class )  ,     0  )  ;", "desc    =    new    ( methodParameter )  ;", "assertEquals ( List . class ,    desc . getType (  )  )  ;", "assertEquals ( List . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" List \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" List <  ?  >  \"  ,    desc . toString (  )  )  ;", "assertTrue (  (  !  ( desc . isPrimitive (  )  )  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertTrue ( desc . isCollection (  )  )  ;", "assertFalse ( desc . isArray (  )  )  ;", "assertNull ( desc . getElement (  )  )  ;", "assertFalse ( desc . isMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterListNoParamTypes"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "MethodParameter   methodParameter    =    new   MethodParameter ( getClass (  )  . getMethod (  \" testParameterMap \"  ,    Map . class )  ,     0  )  ;", "desc    =    new    ( methodParameter )  ;", "assertEquals ( Map . class ,    desc . getType (  )  )  ;", "assertEquals ( Map . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" Map \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" Map < Integer ,    List < String >  >  \"  ,    desc . toString (  )  )  ;", "assertTrue (  (  !  ( desc . isPrimitive (  )  )  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertFalse ( desc . isCollection (  )  )  ;", "assertFalse ( desc . isArray (  )  )  ;", "assertTrue ( desc . isMap (  )  )  ;", "assertEquals (  . nested ( methodParameter ,     1  )  ,    desc . getMapValue (  )  )  ;", "assertEquals (  . nested ( methodParameter ,     2  )  ,    desc . getMapValue (  )  . getElement (  )  )  ;", "assertEquals ( Integer . class ,    desc . getMapKey (  )  . getType (  )  )  ;", "assertEquals ( List . class ,    desc . getMapValue (  )  . getType (  )  )  ;", "assertEquals ( String . class ,    desc . getMapValue (  )  . getElement (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterMap"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    new   TypeDescriptor ( new   MethodParameter ( getClass (  )  . getMethod (  \" testParameterPrimitive \"  ,    int . class )  ,     0  )  )  ;", "assertEquals ( int . class ,    desc . getType (  )  )  ;", "assertEquals ( Integer . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" int \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" int \"  ,    desc . toString (  )  )  ;", "assertTrue ( desc . isPrimitive (  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertFalse ( desc . isCollection (  )  )  ;", "assertFalse ( desc . isMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterPrimitive"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    new   TypeDescriptor ( new   MethodParameter ( getClass (  )  . getMethod (  \" testParameterScalar \"  ,    String . class )  ,     0  )  )  ;", "assertEquals ( String . class ,    desc . getType (  )  )  ;", "assertEquals ( String . class ,    desc . getObjectType (  )  )  ;", "assertEquals (  \" String \"  ,    desc . getName (  )  )  ;", "assertEquals (  \" String \"  ,    desc . toString (  )  )  ;", "assertTrue (  (  !  ( desc . isPrimitive (  )  )  )  )  ;", "assertEquals (  0  ,    desc . getAnnotations (  )  . length )  ;", "assertFalse ( desc . isCollection (  )  )  ;", "assertFalse ( desc . isArray (  )  )  ;", "assertFalse ( desc . isMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterScalar"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   td    =    new   TypeDescriptor ( getClass (  )  . getField (  \" passDownGeneric \"  )  )  ;", "assertEquals ( List . class ,    td . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Set . class ,    td . getElementTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Integer . class ,    td . getElementTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["passDownGeneric"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "Property   property    =    new   Property ( getClass (  )  ,    getClass (  )  . getMethod (  \" getProperty \"  )  ,    getClass (  )  . getMethod (  \" setProperty \"  ,    Map . class )  )  ;", "TypeDescriptor   desc    =    new   TypeDescriptor ( property )  ;", "assertEquals ( Map . class ,    desc . getType (  )  )  ;", "assertEquals ( Integer . class ,    desc . getMapKeyTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Long . class ,    desc . getMapValueTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertNotNull ( desc . getAnnotation (  . MethodAnnotation 1  . class )  )  ;", "assertNotNull ( desc . getAnnotation (  . MethodAnnotation 2  . class )  )  ;", "assertNotNull ( desc . getAnnotation (  . MethodAnnotation 3  . class )  )  ;", "}", "METHOD_END"], "methodName": ["property"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "Property   property    =    new   Property ( getClass (  )  ,    getClass (  )  . getMethod (  \" getComplexProperty \"  )  ,    getClass (  )  . getMethod (  \" setComplexProperty \"  ,    Map . class )  )  ;", "desc    =    new    ( property )  ;", "assertEquals ( String . class ,    desc . getMapKey (  )  . getType (  )  )  ;", "assertEquals ( Integer . class ,    desc . getMapValue (  )  . getElement (  )  . getElement (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyComplex"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptorTests . IntegerClass   genericBean    =    new   TypeDescriptorTests . IntegerClass (  )  ;", "Property   property    =    new   Property ( genericBean . getClass (  )  ,    genericBean . getClass (  )  . getMethod (  \" getListProperty \"  )  ,    genericBean . getClass (  )  . getMethod (  \" setListProperty \"  ,    List . class )  )  ;", "TypeDescriptor   desc    =    new   TypeDescriptor ( property )  ;", "assertEquals ( List . class ,    desc . getType (  )  )  ;", "assertEquals ( Integer . class ,    desc . getElementTypeDescriptor (  )  . getType (  )  )  ;", "assertNotNull ( desc . getAnnotation ( TypeDescriptorTests . MethodAnnotation 1  . class )  )  ;", "assertTrue ( desc . hasAnnotation ( TypeDescriptorTests . MethodAnnotation 1  . class )  )  ;", "}", "METHOD_END"], "methodName": ["propertyGenericClassList"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptorTests . GenericType < Integer >    genericBean    =    new   TypeDescriptorTests . IntegerType (  )  ;", "Property   property    =    new   Property ( getClass (  )  ,    genericBean . getClass (  )  . getMethod (  \" getProperty \"  )  ,    genericBean . getClass (  )  . getMethod (  \" setProperty \"  ,    Integer . class )  )  ;", "TypeDescriptor   desc    =    new   TypeDescriptor ( property )  ;", "assertEquals ( Integer . class ,    desc . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyGenericType"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptorTests . GenericType < Integer >    genericBean    =    new   TypeDescriptorTests . IntegerType (  )  ;", "Property   property    =    new   Property ( getClass (  )  ,    genericBean . getClass (  )  . getMethod (  \" getListProperty \"  )  ,    genericBean . getClass (  )  . getMethod (  \" setListProperty \"  ,    List . class )  )  ;", "TypeDescriptor   desc    =    new   TypeDescriptor ( property )  ;", "assertEquals ( List . class ,    desc . getType (  )  )  ;", "assertEquals ( Integer . class ,    desc . getElementTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyGenericTypeList"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptorTests . GenericType < Number >    genericBean    =    new   TypeDescriptorTests . NumberType (  )  ;", "Property   property    =    new   Property ( getClass (  )  ,    genericBean . getClass (  )  . getMethod (  \" getProperty \"  )  ,    genericBean . getClass (  )  . getMethod (  \" setProperty \"  ,    Number . class )  )  ;", "TypeDescriptor   desc    =    new   TypeDescriptor ( property )  ;", "assertEquals ( Integer . class ,    desc . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyTypeCovariance"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    TypeDescriptor . forObject (  \"  \"  )  ;", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  )  ;", "ObjectOutputStream   outputStream    =    new   ObjectOutputStream ( out )  ;", "outputStream . writeObject ( typeDescriptor )  ;", "ObjectInputStream   inputStream    =    new   ObjectInputStream ( new   ByteArrayInputStream ( out . toByteArray (  )  )  )  ;", "TypeDescriptor   readObject    =     (  ( TypeDescriptor )     ( inputStream . readObject (  )  )  )  ;", "assertThat ( readObject ,    equalTo ( typeDescriptor )  )  ;", "}", "METHOD_END"], "methodName": ["serializable"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "this . property    =    property ;", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "Property   property    =    new   Property ( getClass (  )  ,    getClass (  )  . getMethod (  \" getProperty \"  )  ,    getClass (  )  . getMethod (  \" setProperty \"  ,    Map . class )  )  ;", "TypeDescriptor   typeDescriptor    =    new   TypeDescriptor ( property )  ;", "TypeDescriptor   upCast    =    typeDescriptor . upcast ( Object . class )  ;", "assertTrue (  (  ( upCast . getAnnotation (  . MethodAnnotation 1  . class )  )     !  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["testUpCast"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "Property   property    =    new   Property ( getClass (  )  ,    getClass (  )  . getMethod (  \" getProperty \"  )  ,    getClass (  )  . getMethod (  \" setProperty \"  ,    Map . class )  )  ;", "typeDescriptor    =    new    ( property )  ;", "try    {", "typeDescriptor . upcast ( Collection . class )  ;", "fail (  \" Did   not   throw \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertEquals (  \" interface   Collection \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUpCastNotSuper"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    TypeDescriptor . valueOf ( int [  ]  . class )  ;", "assertTrue ( typeDescriptor . isArray (  )  )  ;", "assertFalse ( typeDescriptor . isCollection (  )  )  ;", "assertFalse ( typeDescriptor . isMap (  )  )  ;", "assertEquals ( Integer . TYPE ,    typeDescriptor . getElementTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["valueOfArray"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    TypeDescriptor . valueOf ( Collection . class )  ;", "assertTrue ( typeDescriptor . isCollection (  )  )  ;", "assertFalse ( typeDescriptor . isArray (  )  )  ;", "assertFalse ( typeDescriptor . isMap (  )  )  ;", "assertNull ( typeDescriptor . getElementTypeDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["valueOfCollection"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    TypeDescriptor . valueOf ( int . class )  ;", "assertTrue ( typeDescriptor . isPrimitive (  )  )  ;", "assertFalse ( typeDescriptor . isArray (  )  )  ;", "assertFalse ( typeDescriptor . isCollection (  )  )  ;", "assertFalse ( typeDescriptor . isMap (  )  )  ;", "assertEquals ( Integer . TYPE ,    typeDescriptor . getType (  )  )  ;", "assertEquals ( Integer . class ,    typeDescriptor . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["valueOfPrimitive"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   typeDescriptor    =    TypeDescriptor . valueOf ( Integer . class )  ;", "assertFalse ( typeDescriptor . isPrimitive (  )  )  ;", "assertFalse ( typeDescriptor . isArray (  )  )  ;", "assertFalse ( typeDescriptor . isCollection (  )  )  ;", "assertFalse ( typeDescriptor . isMap (  )  )  ;", "assertEquals ( Integer . class ,    typeDescriptor . getType (  )  )  ;", "assertEquals ( Integer . class ,    typeDescriptor . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["valueOfScalar"], "fileName": "org.springframework.core.convert.TypeDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ConvertingComparator <  >  ( comparator ,    Map . Entry :  : getKey )  ;", "}", "METHOD_END"], "methodName": ["mapEntryKeys"], "fileName": "org.springframework.core.convert.converter.ConvertingComparator"}, {"methodBody": ["METHOD_START", "{", "return   new   ConvertingComparator <  >  ( comparator ,    Map . Entry :  : getValue )  ;", "}", "METHOD_END"], "methodName": ["mapEntryValues"], "fileName": "org.springframework.core.convert.converter.ConvertingComparator"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Integer >    map    =    new   LinkedHashMap <  >  (  )  ;", "map . put (  \" b \"  ,     2  )  ;", "map . put (  \" a \"  ,     1  )  ;", "ArrayList < Map . Entry < String ,    Integer >  >    list    =    new   ArrayList <  >  ( map . entrySet (  )  )  ;", "assertThat ( list . get (  0  )  . getKey (  )  ,    is (  \" b \"  )  )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["createReverseOrderMapEntryList"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "testConversion ( new   ConvertingComparator <  >  ( comparator ,    converter )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetForConverter"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "ArrayList < Map . Entry < String ,    Integer >  >    list    =    createReverseOrderMapEntryList (  )  ;", "Comparator < Map . Entry < String ,    Integer >  >    comparator    =     . mapEntryKeys ( new   ComparableComparator < String >  (  )  )  ;", "Collections . sort ( list ,    comparator )  ;", "assertThat ( list . get (  0  )  . getKey (  )  ,    is (  \" a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetMapEntryKeys"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "ArrayList < Map . Entry < String ,    Integer >  >    list    =    createReverseOrderMapEntryList (  )  ;", "Comparator < Map . Entry < String ,    Integer >  >    comparator    =     . mapEntryValues ( new   ComparableComparator < Integer >  (  )  )  ;", "Collections . sort ( list ,    comparator )  ;", "assertThat ( list . get (  0  )  . getValue (  )  ,    is (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetMapEntryValues"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "new   ConvertingComparator <  >  ( null ,    this . converter )  ;", "}", "METHOD_END"], "methodName": ["shouldThrowOnNullComparator"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "new   ConvertingComparator < String ,    Integer >  ( this . comparator ,    null ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["shouldThrowOnNullConversionService"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "new   ConvertingComparator < String ,    Integer >  ( this . comparator ,    null )  ;", "}", "METHOD_END"], "methodName": ["shouldThrowOnNullConverter"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "new   ConvertingComparator < String ,    Integer >  ( this . comparator ,    this . conversionService ,    null )  ;", "}", "METHOD_END"], "methodName": ["shouldThrowOnNullType"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "ConvertingComparator < String ,    Integer >    convertingComparator    =    new   ConvertingComparator <  >  ( comparator ,    conversionService ,    Integer . class )  ;", "testConversion ( convertingComparator )  ;", "}", "METHOD_END"], "methodName": ["shouldUseConversionServiceOnCompare"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "ConvertingComparator < String ,    Integer >    convertingComparator    =    new   ConvertingComparator <  >  ( this . comparator ,    this . converter )  ;", "testConversion ( convertingComparator )  ;", "}", "METHOD_END"], "methodName": ["shouldUseConverterOnCompare"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( convertingComparator . compare (  \"  0  \"  ,     \"  0  \"  )  ,    is (  0  )  )  ;", "assertThat ( convertingComparator . compare (  \"  0  \"  ,     \"  1  \"  )  ,    is (  (  -  1  )  )  )  ;", "assertThat ( convertingComparator . compare (  \"  1  \"  ,     \"  0  \"  )  ,    is (  1  )  )  ;", "comparator . assertCalled (  )  ;", "}", "METHOD_END"], "methodName": ["testConversion"], "fileName": "org.springframework.core.convert.converter.ConvertingComparatorTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    strings    =    new   ArrayList <  >  (  )  ;", "strings . add (  \"  3  \"  )  ;", "strings . add (  \"  9  \"  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < Integer >    integers    =     (  ( List < Integer >  )     ( c . convert ( strings ,    TypeDescriptor . collection ( List . class ,    TypeDescriptor . valueOf ( Integer . class )  )  )  )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    integers . get (  0  )  )  ;", "assertEquals ( Integer . valueOf (  9  )  ,    integers . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["collection"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  ,    AbstractList . class )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToAbstractCollection"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Integer [  ]    result    =    conversionService . convert ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  ,    Integer [  ]  . class )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    result [  0  ]  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    result [  1  ]  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    result [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    conversionService . convert ( new   int [  ]  {     1  ,     2  ,     3     }  ,    int [  ]  . class )  ;", "assertEquals (  1  ,    result [  0  ]  )  ;", "assertEquals (  2  ,    result [  1  ]  )  ;", "assertEquals (  3  ,    result [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToArrayAssignable"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "List < Integer >    result    =     (  ( List < Integer >  )     ( c . convert ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  ,    TypeDescriptor . valueOf ( String [  ]  . class )  ,    new   TypeDescriptor ( getClass (  )  . getDeclaredField (  \" genericList \"  )  )  )  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    result . get (  0  )  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    result . get (  1  )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    result . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToCollectionGenericTypeConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "LinkedList <  ?  >    result    =    conversionService . convert ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  ,    LinkedList . class )  ;", "assertEquals (  \"  1  \"  ,    result . get (  0  )  )  ;", "assertEquals (  \"  2  \"  ,    result . get (  1  )  )  ;", "assertEquals (  \"  3  \"  ,    result . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToCollectionImpl"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    result    =    conversionService . convert ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  ,    List . class )  ;", "assertEquals (  \"  1  \"  ,    result . get (  0  )  )  ;", "assertEquals (  \"  2  \"  ,    result . get (  1  )  )  ;", "assertEquals (  \"  3  \"  ,    result . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToCollectionInterface"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    array    =    new   Object [  ]  {     3 L    }  ;", "Object   result    =    c . convert ( array ,    Long . class )  ;", "assertEquals (  3 L ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToObject"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Long [  ]    array    =    new   Long [  ]  {     3 L    }  ;", "Long [  ]    result    =     (  ( Long [  ]  )     ( c . convert ( array ,    Object . class )  )  )  ;", "assertArrayEquals ( array ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToObjectAssignableTargetType"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    array    =    new   String [  ]  {     \"  3  \"     }  ;", "Integer   result    =    c . convert ( array ,    Integer . class )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToObjectWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    conversionService . convert ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  ,    int [  ]  . class )  ;", "assertEquals (  1  ,    result [  0  ]  )  ;", "assertEquals (  2  ,    result [  1  ]  )  ;", "assertEquals (  3  ,    result [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToPrimitiveArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    source    =    new   String [  ]  {     \"  1  \"  ,     \"  3  \"  ,     \"  4  \"     }  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Stream < Integer >    result    =     (  ( Stream < Integer >  )     ( this . c . convert ( source ,    TypeDescriptor . valueOf ( String [  ]  . class )  ,    new   TypeDescriptor ( getClass (  )  . getDeclaredField (  \" genericStream \"  )  )  )  )  )  ;", "assertEquals (  8  ,    result . mapToInt (  (    x )     -  >    x )  . sum (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToStream"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   result    =    conversionService . convert ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  ,    String . class )  ;", "assertEquals (  \"  1  ,  2  ,  3  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   result    =    conversionService . convert ( new   Integer [  ]  {     1  ,     2  ,     3     }  ,    String . class )  ;", "assertEquals (  \"  1  ,  2  ,  3  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToStringWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    byteArray    =    new   byte [  ]  {     1  ,     2  ,     3     }  ;", "Byte [  ]    converted    =    c . convert ( byteArray ,    Byte [  ]  . class )  ;", "assertThat ( converted ,    equalTo ( new   Byte [  ]  {     1  ,     2  ,     3     }  )  )  ;", "}", "METHOD_END"], "methodName": ["convertArrayToWrapperArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   Converter < Byte ,    Byte >  (  )     {", "@ Override", "public   Byte   convert ( Byte   source )     {", "return    (  ( byte )     ( source    +     1  )  )  ;", "}", "}  )  ;", "byte [  ]    byteArray    =    new   byte [  ]  {     1  ,     2  ,     3     }  ;", "byte [  ]    converted    =    conversionService . convert ( byteArray ,    byte [  ]  . class )  ;", "assertNotSame ( byteArray ,    converted )  ;", "assertTrue ( Arrays . equals ( new   byte [  ]  {     2  ,     3  ,     4     }  ,    converted )  )  ;", "}", "METHOD_END"], "methodName": ["convertCannotOptimizeArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   converted    =    conversionService . convert ( new   char [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  ,    String . class )  ;", "assertThat ( converted ,    equalTo (  \" a , b , c \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertCharArrayToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  \"  1  \"  )  ;", "list . add (  \"  2  \"  )  ;", "list . add (  \"  3  \"  )  ;", "String [  ]    result    =    c . convert ( list ,    String [  ]  . class )  ;", "assertEquals (  \"  1  \"  ,    result [  0  ]  )  ;", "assertEquals (  \"  2  \"  ,    result [  1  ]  )  ;", "assertEquals (  \"  3  \"  ,    result [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  \"  1  \"  )  ;", "list . add (  \"  2  \"  )  ;", "list . add (  \"  3  \"  )  ;", "Integer [  ]    result    =    c . convert ( list ,    Integer [  ]  . class )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    result [  0  ]  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    result [  1  ]  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    result [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToArrayWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    foo    =    new   LinkedHashSet <  >  (  )  ;", "foo . add (  \"  1  \"  )  ;", "foo . add (  \"  2  \"  )  ;", "foo . add (  \"  3  \"  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < Integer >    bar    =     (  ( List < Integer >  )     ( c . convert ( foo ,    TypeDescriptor . forObject ( foo )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericList \"  )  )  )  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    bar . get (  0  )  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    bar . get (  1  )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    bar . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToCollection"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    foo    =    new   LinkedHashSet <  >  (  )  ;", "foo . add (  \"  1  \"  )  ;", "foo . add (  \"  2  \"  )  ;", "foo . add (  \"  3  \"  )  ;", "List   bar    =     (  ( List )     ( c . convert ( foo ,    TypeDescriptor . valueOf ( LinkedHashSet . class )  ,    TypeDescriptor . valueOf ( List . class )  )  )  )  ;", "assertEquals (  \"  1  \"  ,    bar . get (  0  )  )  ;", "assertEquals (  \"  2  \"  ,    bar . get (  1  )  )  ;", "assertEquals (  \"  3  \"  ,    bar . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToCollectionNotGeneric"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "List < Integer >    bar    =     (  ( List < Integer >  )     ( c . convert ( null ,    TypeDescriptor . valueOf ( LinkedHashSet . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericList \"  )  )  )  )  )  ;", "assertNull ( bar )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToCollectionNull"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Map   map    =    new   LinkedHashMap (  )  ;", "map . put (  \"  1  \"  ,     \"  1  \"  )  ;", "map . put (  \"  2  \"  ,     \"  2  \"  )  ;", "map . put (  \"  3  \"  ,     \"  3  \"  )  ;", "Collection   values    =    map . values (  )  ;", "List < Integer >    bar    =     (  ( List < Integer >  )     ( c . convert ( values ,    TypeDescriptor . forObject ( values )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericList \"  )  )  )  )  )  ;", "assertEquals (  3  ,    bar . size (  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    bar . get (  0  )  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    bar . get (  1  )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    bar . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToCollectionSpecialCaseSourceImpl"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < Long >    list    =    Collections . singletonList (  3 L )  ;", "Long   result    =    c . convert ( list ,    Long . class )  ;", "assertEquals ( Long . valueOf (  3  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToObject"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    source    =    new   ArrayList <  >  (  )  ;", "source . add (  \" foo \"  )  ;", "Object   result    =    c . convert ( source ,    new   TypeDescriptor ( getClass (  )  . getField (  \" assignableTarget \"  )  )  )  ;", "assertEquals ( source ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToObjectAssignableTarget"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    source    =    new   ArrayList <  >  (  )  ;", "source . add (  \" A \"  )  ;", "source . add (  \" B \"  )  ;", "conversionService . addConverter ( new   Converter < List ,     . ListWrapper >  (  )     {", "@ Override", "public    . ListWrapper   convert ( List   source )     {", "return   new    . ListWrapper ( source )  ;", "}", "}  )  ;", ". ListWrapper   result    =    conversionService . convert ( source ,     . ListWrapper . class )  ;", "assertSame ( source ,    result . getList (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToObjectWithCustomConverter"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    Collections . singletonList (  \"  3  \"  )  ;", "Integer   result    =    c . convert ( list ,    Integer . class )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToObjectWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    Arrays . asList (  \" foo \"  ,     \" bar \"  )  ;", "String   result    =    c . convert ( list ,    String . class )  ;", "assertEquals (  \" foo , bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    list    =    Arrays . asList (  3  ,     5  )  ;", "String   result    =     (  ( String )     ( c . convert ( list ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericList \"  )  )  ,    TypeDescriptor . valueOf ( String . class )  )  )  )  ;", "assertEquals (  \"  3  ,  5  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertCollectionToStringWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   result    =    conversionService . convert ( new   String [  0  ]  ,    String . class )  ;", "assertEquals (  \"  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertEmptyArrayToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    result    =    conversionService . convert (  \"  \"  ,    String [  ]  . class )  ;", "assertEquals (  0  ,    result . length )  ;", "}", "METHOD_END"], "methodName": ["convertEmptyStringToArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Collection   result    =    conversionService . convert (  \"  \"  ,    Collection . class )  ;", "assertEquals (  0  ,    result . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertEmptyStringToCollection"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( Optional . empty (  )  ,    conversionService . convert ( Optional . empty (  )  ,    TypeDescriptor . valueOf ( Object . class )  ,    TypeDescriptor . valueOf ( Optional . class )  )  )  ;", "assertSame ( Optional . empty (  )  ,    conversionService . convert ( Optional . empty (  )  ,    Optional . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertExistingOptional"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Integer >    hashMap    =    new   LinkedHashMap <  >  (  )  ;", "hashMap . put (  \"  1  \"  ,     1  )  ;", "hashMap . put (  \"  2  \"  ,     2  )  ;", "List   converted    =    c . convert ( hashMap . values (  )  ,    List . class )  ;", "assertEquals ( Arrays . asList (  1  ,     2  )  ,    converted )  ;", "}", "METHOD_END"], "methodName": ["convertHashMapValuesToList"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list 1     =    Arrays . asList (  \" Foo \"  ,     \" Bar \"  )  ;", "List < String >    list 2     =    Arrays . asList (  \" Baz \"  ,     \" Boop \"  )  ;", "List < List < String >  >    list    =    Arrays . asList ( list 1  ,    list 2  )  ;", "assertTrue ( c . canConvert ( list . getClass (  )  ,    String . class )  )  ;", "String   result    =    c . convert ( list ,    String . class )  ;", "assertEquals (  \" Foo , Bar , Baz , Boop \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertListOfListToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    list    =    Arrays . asList ( new   DefaultConversionServiceTests . TestEntity (  1 L )  ,    new   DefaultConversionServiceTests . TestEntity (  2 L )  )  ;", "assertTrue ( conversionService . canConvert ( list . getClass (  )  ,    String . class )  )  ;", "try    {", "conversionService . convert ( list ,    String . class )  ;", "}    catch    ( ConversionFailedException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains ( list . getClass (  )  . getName (  )  )  )  ;", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   ConverterNotFoundException )  )  ;", "assertTrue ( ex . getCause (  )  . getMessage (  )  . contains ( DefaultConversionServiceTests . TestEntity . class . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["convertListOfNonStringifiable"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    Arrays . asList (  \" Foo \"  ,     \" Bar \"  )  ;", "assertTrue ( c . canConvert ( list . getClass (  )  ,    String . class )  )  ;", "String   result    =    c . convert ( list ,    String . class )  ;", "assertEquals (  \" Foo , Bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertListOfStringToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    foo    =    new   HashMap <  >  (  )  ;", "foo . put (  \"  1  \"  ,     \" BAR \"  )  ;", "foo . put (  \"  2  \"  ,     \" BAZ \"  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < Integer ,     . FooEnum >    map    =     (  ( Map < Integer ,     . FooEnum >  )     ( conversionService . convert ( foo ,    TypeDescriptor . forObject ( foo )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericMap \"  )  )  )  )  )  ;", "assertEquals (  . FooEnum . BAR ,    map . get (  1  )  )  ;", "assertEquals (  . FooEnum . BAZ ,    map . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["convertMapToMap"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    result    =    conversionService . convert (  3 L ,    Object [  ]  . class )  ;", "assertEquals (  1  ,    result . length )  ;", "assertEquals (  3 L ,    result [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Integer [  ]    result    =    conversionService . convert (  3 L ,    Integer [  ]  . class )  ;", "assertEquals (  1  ,    result . length )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    result [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToArrayWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List   result    =    conversionService . convert (  3 L ,    List . class )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "assertEquals (  3 L ,    result . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToCollection"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "List < Integer >    result    =     (  ( List < Integer >  )     ( c . convert (  3 L ,    TypeDescriptor . valueOf ( Long . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericList \"  )  )  )  )  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    result . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToCollectionWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionServiceTests . TestEntity   e    =    conversionService . convert (  1 L ,    DefaultConversionServiceTests . TestEntity . class )  ;", "assertEquals ( Long . valueOf (  1  )  ,    e . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToObjectFinderMethod"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionServiceTests . TestEntity   entity    =    conversionService . convert (  \"  1  \"  ,    DefaultConversionServiceTests . TestEntity . class )  ;", "assertEquals ( Long . valueOf (  1  )  ,    entity . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToObjectFinderMethodWithIdConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionServiceTests . TestEntity   entity    =     (  ( DefaultConversionServiceTests . TestEntity )     ( conversionService . convert ( null ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( DefaultConversionServiceTests . TestEntity . class )  )  )  )  ;", "assertNull ( entity )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToObjectFinderMethodWithNull"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert ( Long . valueOf (  3  )  ,    DefaultConversionServiceTests . SSN . class )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToObjectNoValueOfMethodOrConstructor"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionServiceTests . SSN . reset (  )  ;", "assertEquals ( new   DefaultConversionServiceTests . SSN (  \"  1  2  3  4  5  6  7  8  9  \"  )  ,    conversionService . convert (  \"  1  2  3  4  5  6  7  8  9  \"  ,    DefaultConversionServiceTests . SSN . class )  )  ;", "assertEquals (  \" constructor   invocations \"  ,     2  ,    DefaultConversionServiceTests . SSN . constructorCount )  ;", "assertEquals (  \" toString (  )    invocations \"  ,     0  ,    DefaultConversionServiceTests . SSN . toStringCount )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToObjectUsingObjectConstructor"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionServiceTests . ISBN . reset (  )  ;", "assertEquals ( new   DefaultConversionServiceTests . ISBN (  \"  1  2  3  4  5  6  7  8  9  \"  )  ,    conversionService . convert (  \"  1  2  3  4  5  6  7  8  9  \"  ,    DefaultConversionServiceTests . ISBN . class )  )  ;", "assertEquals (  \" valueOf (  )    invocations \"  ,     1  ,    DefaultConversionServiceTests . ISBN . valueOfCount )  ;", "assertEquals (  \" constructor   invocations \"  ,     2  ,    DefaultConversionServiceTests . ISBN . constructorCount )  ;", "assertEquals (  \" toString (  )    invocations \"  ,     0  ,    DefaultConversionServiceTests . ISBN . toStringCount )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToObjectUsingValueOfMethod"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( ZoneId . of (  \" GMT +  1  \"  )  ,    conversionService . convert (  \" GMT +  1  \"  ,    ZoneId . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToObjectWithJavaTimeOfMethod"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ClassUtils . getMethod ( DefaultConversionServiceTests . TestEntity . class ,     \" handleOptionalValue \"  ,    Optional . class )  ;", "MethodParameter   parameter    =    new   MethodParameter ( method ,     0  )  ;", "TypeDescriptor   descriptor    =    new   TypeDescriptor ( parameter )  ;", "Object   actual    =    conversionService . convert (  \"  1  ,  2  ,  3  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    descriptor )  ;", "assertEquals ( Optional . class ,    actual . getClass (  )  )  ;", "assertEquals ( Arrays . asList (  1  ,     2  ,     3  )  ,     (  ( Optional < List < Integer >  >  )     ( actual )  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToOptional"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( Optional . empty (  )  ,    conversionService . convert ( null ,    TypeDescriptor . valueOf ( Object . class )  ,    TypeDescriptor . valueOf ( Optional . class )  )  )  ;", "assertSame ( Optional . empty (  )  ,    conversionService . convert ( null ,    Optional . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToOptionalNull"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( conversionService . canConvert ( DefaultConversionServiceTests . TestEntity . class ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToStringNotSupported"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionServiceTests . SSN . reset (  )  ;", "assertEquals (  \"  1  2  3  4  5  6  7  8  9  \"  ,    conversionService . convert ( new   DefaultConversionServiceTests . SSN (  \"  1  2  3  4  5  6  7  8  9  \"  )  ,    String . class )  )  ;", "assertEquals (  \" constructor   invocations \"  ,     1  ,    DefaultConversionServiceTests . SSN . constructorCount )  ;", "assertEquals (  \" toString (  )    invocations \"  ,     1  ,    DefaultConversionServiceTests . SSN . toStringCount )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToStringUsingToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( conversionService . convert ( ZoneId . of (  \" GMT +  1  \"  )  ,    String . class )  . startsWith (  \" GMT +  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToStringWithJavaTimeOfMethodPresent"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionServiceTests . ISBN . reset (  )  ;", "assertEquals (  \"  1  2  3  4  5  6  7  8  9  \"  ,    conversionService . convert ( new   DefaultConversionServiceTests . ISBN (  \"  1  2  3  4  5  6  7  8  9  \"  )  ,    String . class )  )  ;", "assertEquals (  \" constructor   invocations \"  ,     1  ,    DefaultConversionServiceTests . ISBN . constructorCount )  ;", "assertEquals (  \" valueOf (  )    invocations \"  ,     0  ,    DefaultConversionServiceTests . ISBN . valueOfCount )  ;", "assertEquals (  \" toString (  )    invocations \"  ,     1  ,    DefaultConversionServiceTests . ISBN . toStringCount )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToStringWithValueOfMethodPresentUsingToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Properties   foo    =    new   Properties (  )  ;", "foo . setProperty (  \"  1  \"  ,     \" BAR \"  )  ;", "foo . setProperty (  \"  2  \"  ,     \" BAZ \"  )  ;", "String   result    =    c . convert ( foo ,    String . class )  ;", "assertTrue ( result . contains (  \"  1  = BAR \"  )  )  ;", "assertTrue ( result . contains (  \"  2  = BAZ \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertPropertiesToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    result    =    conversionService . convert (  \"  1  ,  2  ,  3  \"  ,    String [  ]  . class )  ;", "assertEquals (  3  ,    result . length )  ;", "assertEquals (  \"  1  \"  ,    result [  0  ]  )  ;", "assertEquals (  \"  2  \"  ,    result [  1  ]  )  ;", "assertEquals (  \"  3  \"  ,    result [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Integer [  ]    result    =    conversionService . convert (  \"  1  ,  2  ,  3  \"  ,    Integer [  ]  . class )  ;", "assertEquals (  3  ,    result . length )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    result [  0  ]  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    result [  1  ]  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    result [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToArrayWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "char [  ]    converted    =    conversionService . convert (  \" a , b , c \"  ,    char [  ]  . class )  ;", "assertThat ( converted ,    equalTo ( new   char [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  )  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToCharArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List   result    =    conversionService . convert (  \"  1  ,  2  ,  3  \"  ,    List . class )  ;", "assertEquals (  3  ,    result . size (  )  )  ;", "assertEquals (  \"  1  \"  ,    result . get (  0  )  )  ;", "assertEquals (  \"  2  \"  ,    result . get (  1  )  )  ;", "assertEquals (  \"  3  \"  ,    result . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToCollection"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List   result    =     (  ( List )     ( conversionService . convert (  \"  1  ,  2  ,  3  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericList \"  )  )  )  )  )  ;", "assertEquals (  3  ,    result . size (  )  )  ;", "assertEquals (  1  ,    result . get (  0  )  )  ;", "assertEquals (  2  ,    result . get (  1  )  )  ;", "assertEquals (  3  ,    result . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToCollectionWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   Converter < String ,    char [  ]  >  (  )     {", "@ Override", "public   char [  ]    convert ( String   source )     {", "return   source . toCharArray (  )  ;", "}", "}  )  ;", "char [  ]    converted    =    conversionService . convert (  \" abc \"  ,    char [  ]  . class )  ;", "assertThat ( converted ,    equalTo ( new   char [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  )  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToCustomCharArray"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    conversionService . convert (  \"  1  ,  2  ,  3  \"  ,    int [  ]  . class )  ;", "assertEquals (  3  ,    result . length )  ;", "assertEquals (  1  ,    result [  0  ]  )  ;", "assertEquals (  2  ,    result [  1  ]  )  ;", "assertEquals (  3  ,    result [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToPrimitiveArrayWithElementConversion"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Properties   result    =    conversionService . convert (  \" a = b \\ nc =  2  \\ nd =  \"  ,    Properties . class )  ;", "assertEquals (  3  ,    result . size (  )  )  ;", "assertEquals (  \" b \"  ,    result . getProperty (  \" a \"  )  )  ;", "assertEquals (  \"  2  \"  ,    result . getProperty (  \" c \"  )  )  ;", "assertEquals (  \"  \"  ,    result . getProperty (  \" d \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToProperties"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Properties   result    =    conversionService . convert (  \"          foo = bar \\ n         bar = baz \\ n            baz = boop \"  ,    Properties . class )  ;", "assertEquals (  \" bar \"  ,    result . get (  \" foo \"  )  )  ;", "assertEquals (  \" baz \"  ,    result . get (  \" bar \"  )  )  ;", "assertEquals (  \" boop \"  ,    result . get (  \" baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToPropertiesWithSpaces"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" GMT +  0  2  :  0  0  \"  ,    conversionService . convert (  \" GMT +  2  \"  ,    TimeZone . class )  . getID (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertStringToTimezone"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    strings    =    new   HashMap <  >  (  )  ;", "strings . put (  \"  3  \"  ,     \"  9  \"  )  ;", "strings . put (  \"  6  \"  ,     \"  3  1  \"  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < Integer ,    Integer >    integers    =     (  ( Map < Integer ,    Integer >  )     ( c . convert ( strings ,    TypeDescriptor . map ( Map . class ,    TypeDescriptor . valueOf ( Integer . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  )  )  )  ;", "assertEquals ( Integer . valueOf (  9  )  ,    integers . get (  3  )  )  ;", "assertEquals ( Integer . valueOf (  3  1  )  ,    integers . get (  6  )  )  ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]  [  ]    grid    =    new   String [  ]  [  ]  {    new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"  ,     \"  4  \"     }  ,    new   String [  ]  {     \"  5  \"  ,     \"  6  \"  ,     \"  7  \"  ,     \"  8  \"     }  ,    new   String [  ]  {     \"  9  \"  ,     \"  1  0  \"  ,     \"  1  1  \"  ,     \"  1  2  \"     }     }  ;", "List < String [  ]  >    converted    =    c . convert ( grid ,    List . class )  ;", "String [  ]  [  ]    convertedBack    =    c . convert ( converted ,    String [  ]  [  ]  . class )  ;", "assertArrayEquals ( grid ,    convertedBack )  ;", "}", "METHOD_END"], "methodName": ["multidimensionalArrayToListConversionShouldConvertEntriesCorrectly"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  1  0  0  .  0  0  \"  ,    conversionService . convert ( new   BigDecimal (  \"  1  0  0  .  0  0  \"  )  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testBigDecimalToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  1  0  0  \"  ,    conversionService . convert ( new   BigInteger (  \"  1  0  0  \"  )  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testBigIntegerToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" true \"  ,    conversionService . convert ( true ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  6  5  \"  ,    conversionService . convert (  \" A \"  . getBytes (  )  [  0  ]  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testByteToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Integer . valueOf (  6  5  )  ,    conversionService . convert (  ' A '  ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCharacterToNumber"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  3  \"  ,    conversionService . convert (  '  3  '  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCharacterToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" UTF -  8  \"  ,    conversionService . convert ( StandardCharsets . UTF _  8  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCharsetToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" USD \"  ,    conversionService . convert ( Currency . getInstance (  \" USD \"  )  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCurrencyToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  1  .  0  \"  ,    conversionService . convert ( Double . valueOf (  \"  1  .  0  \"  )  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Integer . valueOf (  0  )  ,    conversionService . convert ( DefaultConversionServiceTests . Foo . BAR ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["testEnumToInteger"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" BAR \"  ,    conversionService . convert ( DefaultConversionServiceTests . Foo . BAR ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testEnumToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  1  .  0  \"  ,    conversionService . convert ( Float . valueOf (  \"  1  .  0  \"  )  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testFloatToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( DefaultConversionServiceTests . Foo . BAR ,    conversionService . convert (  0  ,    DefaultConversionServiceTests . Foo . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegerToEnum"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    conversionService . convert ( null ,    DefaultConversionServiceTests . Foo . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegerToEnumNull"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( DefaultConversionServiceTests . SubFoo . BAZ ,    conversionService . convert (  1  ,    DefaultConversionServiceTests . SubFoo . BAR . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegerToEnumWithSubclass"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  3  \"  ,    conversionService . convert (  3  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegerToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  3  \"  ,    conversionService . convert (  3 L ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testLongToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Character . valueOf (  ' A '  )  ,    conversionService . convert (  6  5  ,    Character . class )  )  ;", "}", "METHOD_END"], "methodName": ["testNumberToCharacter"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Long . valueOf (  1  )  ,    conversionService . convert (  1  ,    Long . class )  )  ;", "}", "METHOD_END"], "methodName": ["testNumberToNumber"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert (  1  ,    DefaultConversionServiceTests . CustomNumber . class )  ;", "}", "METHOD_END"], "methodName": ["testNumberToNumberNotSupportedNumber"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( TestGroup . PERFORMANCE )  ;", "StopWatch   watch    =    new   StopWatch (  \" integer -  > string   conversionPerformance \"  )  ;", "watch . start (  \" convert    4  ,  0  0  0  ,  0  0  0    with   conversion   service \"  )  ;", "for    ( int   i    =     0  ;    i    <     4  0  0  0  0  0  0  ;    i +  +  )     {", "c . convert (  3  ,    String . class )  ;", "}", "watch . stop (  )  ;", "watch . start (  \" convert    4  ,  0  0  0  ,  0  0  0    manually \"  )  ;", "for    ( int   i    =     0  ;    i    <     4  0  0  0  0  0  0  ;    i +  +  )     {", "Integer . valueOf (  3  )  . toString (  )  ;", "}", "watch . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testPerformance1"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "short   three    =     3  ;", "assertEquals (  \"  3  \"  ,    c . convert ( three ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testShortToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "ConverterRegistry   registry    =    conversionService ;", "registry . addConverter ( new    . ColorConverter (  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < Color >    colors    =     (  ( List < Color >  )     ( conversionService . convert ( new   String [  ]  {     \" ffffff \"  ,     \"  #  0  0  0  0  0  0  \"     }  ,    TypeDescriptor . valueOf ( String [  ]  . class )  ,    new   TypeDescriptor ( new   MethodParameter ( getClass (  )  . getMethod (  \" handlerMethod \"  ,    List . class )  ,     0  )  )  )  )  )  ;", "assertEquals (  2  ,    colors . size (  )  )  ;", "assertEquals ( Color . WHITE ,    colors . get (  0  )  )  ;", "assertEquals ( Color . BLACK ,    colors . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpr7766"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   BigDecimal (  \"  1  .  0  \"  )  ,    conversionService . convert (  \"  1  .  0  \"  ,    BigDecimal . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToBigDecimal"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   BigInteger (  \"  1  \"  )  ,    conversionService . convert (  \"  1  \"  ,    BigInteger . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToBigInteger"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    conversionService . convert (  \"  \"  ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToBooleanEmptyString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( false ,    conversionService . convert (  \" false \"  ,    Boolean . class )  )  ;", "assertEquals ( false ,    conversionService . convert (  \" off \"  ,    Boolean . class )  )  ;", "assertEquals ( false ,    conversionService . convert (  \" no \"  ,    Boolean . class )  )  ;", "assertEquals ( false ,    conversionService . convert (  \"  0  \"  ,    Boolean . class )  )  ;", "assertEquals ( false ,    conversionService . convert (  \" FALSE \"  ,    Boolean . class )  )  ;", "assertEquals ( false ,    conversionService . convert (  \" OFF \"  ,    Boolean . class )  )  ;", "assertEquals ( false ,    conversionService . convert (  \" NO \"  ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToBooleanFalse"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert (  \" invalid \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testStringToBooleanInvalidString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( true ,    conversionService . convert (  \" true \"  ,    Boolean . class )  )  ;", "assertEquals ( true ,    conversionService . convert (  \" on \"  ,    Boolean . class )  )  ;", "assertEquals ( true ,    conversionService . convert (  \" yes \"  ,    Boolean . class )  )  ;", "assertEquals ( true ,    conversionService . convert (  \"  1  \"  ,    Boolean . class )  )  ;", "assertEquals ( true ,    conversionService . convert (  \" TRUE \"  ,    Boolean . class )  )  ;", "assertEquals ( true ,    conversionService . convert (  \" ON \"  ,    Boolean . class )  )  ;", "assertEquals ( true ,    conversionService . convert (  \" YES \"  ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToBooleanTrue"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Byte . valueOf (  \"  1  \"  )  ,    conversionService . convert (  \"  1  \"  ,    Byte . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToByte"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Character . valueOf (  '  1  '  )  ,    conversionService . convert (  \"  1  \"  ,    Character . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToCharacter"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    conversionService . convert (  \"  \"  ,    Character . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToCharacterEmptyString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert (  \" invalid \"  ,    Character . class )  ;", "}", "METHOD_END"], "methodName": ["testStringToCharacterInvalidString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( StandardCharsets . UTF _  8  ,    conversionService . convert (  \" UTF -  8  \"  ,    Charset . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToCharset"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Currency . getInstance (  \" EUR \"  )  ,    conversionService . convert (  \" EUR \"  ,    Currency . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToCurrency"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Double . valueOf (  \"  1  .  0  \"  )  ,    conversionService . convert (  \"  1  .  0  \"  ,    Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToDouble"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( DefaultConversionServiceTests . Foo . BAR ,    conversionService . convert (  \" BAR \"  ,    DefaultConversionServiceTests . Foo . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToEnum"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    conversionService . convert (  \"  \"  ,    DefaultConversionServiceTests . Foo . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToEnumEmptyString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( EnumSet . of ( DefaultConversionServiceTests . Foo . BAR )  ,    conversionService . convert (  \" BAR \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" enumSet \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToEnumSet"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( DefaultConversionServiceTests . SubFoo . BAZ ,    conversionService . convert (  \" BAZ \"  ,    DefaultConversionServiceTests . SubFoo . BAR . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToEnumWithSubclass"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Float . valueOf (  \"  1  .  0  \"  )  ,    conversionService . convert (  \"  1  .  0  \"  ,    Float . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToFloat"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Integer . valueOf (  1  )  ,    conversionService . convert (  \"  1  \"  ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToInteger"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Locale . ENGLISH ,    conversionService . convert (  \" en \"  ,    Locale . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToLocale"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Locale . US ,    conversionService . convert (  \" en _ US \"  ,    Locale . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToLocaleWithCountry"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Locale . US ,    conversionService . convert (  \" en - US \"  ,    Locale . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToLocaleWithLanguageTag"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Long . valueOf (  1  )  ,    conversionService . convert (  \"  1  \"  ,    Long . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToLong"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   BigDecimal (  \"  1  .  0  \"  )  ,    conversionService . convert (  \"  1  .  0  \"  ,    Number . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToNumber"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    conversionService . convert (  \"  \"  ,    Number . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToNumberEmptyString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Short . valueOf (  \"  1  \"  )  ,    conversionService . convert (  \"  1  \"  ,    Short . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToShort"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   str    =     \" test \"  ;", "assertSame ( str ,    c . convert ( str ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToString"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "UUID   uuid    =    UUID . randomUUID (  )  ;", "String   convertToString    =    c . convert ( uuid ,    String . class )  ;", "UUID   convertToUUID    =    c . convert ( convertToString ,    UUID . class )  ;", "assertEquals ( uuid ,    convertToUUID )  ;", "}", "METHOD_END"], "methodName": ["testUuidToStringAndStringToUuid"], "fileName": "org.springframework.core.convert.converter.DefaultConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [ source . remaining (  )  ]  ;", "source . get ( bytes )  ;", "if    ( targetType . isAssignableTo (  . BYTE _ ARRAY _ TYPE )  )     {", "return   bytes ;", "}", "return   this . conversionService . convert ( bytes ,     . BYTE _ ARRAY _ TYPE ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["convertFromByteBuffer"], "fileName": "org.springframework.core.convert.support.ByteBufferConverter"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =     (  ( byte [  ]  )     (  ( source   instanceof   byte [  ]  )     ?    source    :    this . conversionService . convert ( source ,    sourceType ,    ByteBufferConverter . BYTE _ ARRAY _ TYPE )  )  )  ;", "if    ( bytes    =  =    null )     {", "return   ByteBuffer . wrap ( new   byte [  0  ]  )  ;", "}", "ByteBuffer   byteBuffer    =    ByteBuffer . allocate ( bytes . length )  ;", "byteBuffer . put ( bytes )  ;", "return    (  ( Buffer )     ( byteBuffer )  )  . rewind (  )  ;", "}", "METHOD_END"], "methodName": ["convertToByteBuffer"], "fileName": "org.springframework.core.convert.support.ByteBufferConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( targetType . isAssignableTo ( ByteBufferConverter . BYTE _ ARRAY _ TYPE )  )     |  |     ( this . conversionService . canConvert ( ByteBufferConverter . BYTE _ ARRAY _ TYPE ,    targetType )  )  ;", "}", "METHOD_END"], "methodName": ["matchesFromByteBuffer"], "fileName": "org.springframework.core.convert.support.ByteBufferConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( sourceType . isAssignableTo ( ByteBufferConverter . BYTE _ ARRAY _ TYPE )  )     |  |     ( this . conversionService . canConvert ( sourceType ,    ByteBufferConverter . BYTE _ ARRAY _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["matchesToByteBuffer"], "fileName": "org.springframework.core.convert.support.ByteBufferConverter"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  ]  {     1  ,     2  ,     3     }  ;", "convert    =    this . conversionService . convert ( bytes ,     . class )  ;", "assertThat ( convert . array (  )  ,    not ( sameInstance ( bytes )  )  )  ;", "assertThat ( convert . array (  )  ,    equalTo ( bytes )  )  ;", "}", "METHOD_END"], "methodName": ["byteArrayToByteBuffer"], "fileName": "org.springframework.core.convert.support.ByteBufferConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  ]  {     1  ,     2  ,     3     }  ;", "byteBuffer    =     . wrap ( bytes )  ;", "byte [  ]    convert    =    this . conversionService . convert ( byteBuffer ,    byte [  ]  . class )  ;", "assertThat ( convert ,    not ( sameInstance ( bytes )  )  )  ;", "assertThat ( convert ,    equalTo ( bytes )  )  ;", "}", "METHOD_END"], "methodName": ["byteBufferToByteArray"], "fileName": "org.springframework.core.convert.support.ByteBufferConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  ]  {     1  ,     2  ,     3     }  ;", "byteBuffer    =     . wrap ( bytes )  ;", "convert    =    this . conversionService . convert ( byteBuffer ,     . class )  ;", "assertThat ( convert ,    not ( sameInstance ( byteBuffer . rewind (  )  )  )  )  ;", "assertThat ( convert ,    equalTo ( byteBuffer . rewind (  )  )  )  ;", "assertThat ( convert ,    equalTo (  . wrap ( bytes )  )  )  ;", "assertThat ( convert . array (  )  ,    equalTo ( bytes )  )  ;", "}", "METHOD_END"], "methodName": ["byteBufferToByteBuffer"], "fileName": "org.springframework.core.convert.support.ByteBufferConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  ]  {     1  ,     2  ,     3     }  ;", "ByteBuffer   byteBuffer    =    ByteBuffer . wrap ( bytes )  ;", ". OtherType   convert    =    this . conversionService . convert ( byteBuffer ,     . OtherType . class )  ;", "assertThat ( convert . bytes ,    not ( sameInstance ( bytes )  )  )  ;", "assertThat ( convert . bytes ,    equalTo ( bytes )  )  ;", "}", "METHOD_END"], "methodName": ["byteBufferToOtherType"], "fileName": "org.springframework.core.convert.support.ByteBufferConverterTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  ]  {     1  ,     2  ,     3     }  ;", ". OtherType   otherType    =    new    . OtherType ( bytes )  ;", "ByteBuffer   convert    =    this . conversionService . convert ( otherType ,    ByteBuffer . class )  ;", "assertThat ( convert . array (  )  ,    not ( sameInstance ( bytes )  )  )  ;", "assertThat ( convert . array (  )  ,    equalTo ( bytes )  )  ;", "}", "METHOD_END"], "methodName": ["otherTypeToByteBuffer"], "fileName": "org.springframework.core.convert.support.ByteBufferConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . conversionService    =    new   DefaultConversionService (  )  ;", "this . conversionService . addConverter ( new    . ByteArrayToOtherTypeConverter (  )  )  ;", "this . conversionService . addConverter ( new    . OtherTypeToByteArrayConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.core.convert.support.ByteBufferConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < Resource >    resources    =    new   ArrayList <  >  (  )  ;", "resources . add ( null )  ;", "resources . add ( null )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( resources )  ;", "assertSame ( resources ,    conversionServic ( resources ,    sourceType ,    new   TypeDescriptor ( getClass (  )  . getField (  \" resources \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["allNulls"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < String >  [  ]    array    =    new   List [  2  ]  ;", "array [  0  ]     =    Arrays . asList (  \"  9  \"  ,     \"  1  2  \"  )  ;", "array [  1  ]     =    Arrays . asList (  \"  3  7  \"  ,     \"  2  3  \"  )  ;", "conversionService . addConverter ( new   Array ( conversionService )  )  ;", "conversionService . addConverter ( new   CollectionToObjectConverter ( conversionService )  )  ;", "assertTrue ( conversionService . canConvert ( String [  ]  . class ,    List . class )  )  ;", "assertEquals ( Arrays . asList ( array )  ,    conversionService . convert ( array ,    List . class )  )  ;", "}", "METHOD_END"], "methodName": ["arrayCollectionToObjectInteraction"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < List < String >  >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( Arrays . asList (  \"  9  \"  ,     \"  1  2  \"  )  )  ;", "list . add ( Arrays . asList (  \"  3  7  \"  ,     \"  2  3  \"  )  )  ;", "conversionService . addConverter ( new   ObjectConverter ( conversionService )  )  ;", "assertTrue ( conversionService . canConvert ( List . class ,    List . class )  )  ;", "assertSame ( list ,    conversionService . convert ( list ,    List . class )  )  ;", "}", "METHOD_END"], "methodName": ["collectionToObjectInteraction"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "Vector < String >    vector    =    new   Vector <  >  (  )  ;", "vector . add (  \" Element \"  )  ;", "testsionToArrayList ( vector )  ;", "}", "METHOD_END"], "methodName": ["convertEmptyVector_shouldReturnEmptyArrayList"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "Vector < String >    vector    =    new   Vector <  >  (  )  ;", "vector . add (  \" Element \"  )  ;", "testsionToArrayList ( vector )  ;", "}", "METHOD_END"], "methodName": ["convertNonEmptyVector_shouldReturnNonEmptyArrayList"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < Resource >    resources    =    new   ArrayList <  >  (  )  ;", "resources . add ( new   ClassPathResource (  \" test \"  )  )  ;", "resources . add ( new   FileSystemResource (  \" test \"  )  )  ;", "resources . add ( new    . TestResource (  )  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( resources )  ;", "assertSame ( resources ,    conversionService . convert ( resources ,    sourceType ,    new   TypeDescriptor ( getClass (  )  . getField (  \" resources \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["differentImpls"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    resources    =    new   ArrayList <  >  (  )  ;", "resources . add ( null )  ;", "resources . add ( null )  ;", "TypeDescriptor   sourceType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" strings \"  )  )  ;", "assertEquals ( resources ,    conversionServic ( resources ,    sourceType ,    new   TypeDescriptor ( getClass (  )  . getField (  \" resources \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["elementTypesNotConvertible"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   CollectionToCollectionConverter ( conversionService )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( list )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" emptyListTarget \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "assertEquals ( list ,    conversionService . convert ( list ,    sourceType ,    targetType )  )  ;", "}", "METHOD_END"], "methodName": ["emptyListToList"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   CollectionToCollectionConverter ( conversionService )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( list )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" emptyListDifferentTarget \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "LinkedList < Integer >    result    =     (  ( LinkedList < Integer >  )     ( conversionService . convert ( list ,    sourceType ,    targetType )  )  )  ;", "assertEquals ( LinkedList . class ,    result . getClass (  )  )  ;", "assertTrue ( result . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyListToListDifferentTargetType"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List <  ?  >    input    =    new   ArrayList <  >  ( Arrays . asList (  \" foo \"  ,     \" bar \"  )  )  ;", "assertSame ( input ,    conversionService . convert ( input ,    TypeDescriptor . forObject ( input )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" wildcard \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["listToCollectionNoCopyRequired"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < Resource >    resources    =    new   ArrayList <  >  (  )  ;", "resources . add ( new   ClassPathResource (  \" test \"  )  )  ;", "resources . add ( null )  ;", "resources . add ( new   FileSystemResource (  \" test \"  )  )  ;", "resources . add ( new    . TestResource (  )  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( resources )  ;", "assertSame ( resources ,    conversionService . convert ( resources ,    sourceType ,    new   TypeDescriptor ( getClass (  )  . getField (  \" resources \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mixedInNulls"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    resources    =    new   ArrayList <  >  (  )  ;", "resources . add ( new   ClassPathResource (  \" test \"  )  )  ;", "resources . add (  3  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( resources )  ;", "assertEquals ( resources ,    conversionServic ( resources ,    sourceType ,    new   TypeDescriptor ( getClass (  )  . getField (  \" resources \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nothingInCommon"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < List < String >  >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( Arrays . asList (  \"  9  \"  ,     \"  1  2  \"  )  )  ;", "list . add ( Arrays . asList (  \"  3  7  \"  ,     \"  2  3  \"  )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "conversionService . addConverter ( new   Object ( conversionService )  )  ;", "conversionService . addConverter ( new   CollectionToObjectConverter ( conversionService )  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( list )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" objectToCollection \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "List < List < List < Integer >  >  >    result    =     (  ( List < List < List < Integer >  >  >  )     ( conversionService . convert ( list ,    sourceType ,    targetType )  )  )  ;", "assertEquals (  (  ( Integer )     (  9  )  )  ,    result . get (  0  )  . get (  0  )  . get (  0  )  )  ;", "assertEquals (  (  ( Integer )     (  1  2  )  )  ,    result . get (  0  )  . get (  1  )  . get (  0  )  )  ;", "assertEquals (  (  ( Integer )     (  3  7  )  )  ,    result . get (  1  )  . get (  0  )  . get (  0  )  )  ;", "assertEquals (  (  ( Integer )     (  2  3  )  )  ,    result . get (  1  )  . get (  1  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["objectToCollection"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  \"  9  \"  )  ;", "list . add (  \"  3  7  \"  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( list )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" scalarListTarget \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "try    {", "conversionServic ( list ,    sourceType ,    targetType )  ;", "}    catch    ( ConversionFailedException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   ConverterNotFoundException )  )  ;", "}", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < Integer >    result    =     (  ( List < Integer >  )     ( conversionServic ( list ,    sourceType ,    targetType )  )  )  ;", "assertFalse ( list . equals ( result )  )  ;", "assertEquals (  9  ,    result . get (  0  )  . intValue (  )  )  ;", "assertEquals (  3  7  ,    result . get (  1  )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["scalarList"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   CollectionToCollectionConverter ( conversionService )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < List < String >  >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( Arrays . asList (  \"  9  ,  1  2  \"  )  )  ;", "list . add ( Arrays . asList (  \"  3  7  ,  2  3  \"  )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "conversionService . addConverter ( new   String ( conversionService )  )  ;", "conversionService . addConverter ( new   Object ( conversionService )  )  ;", "conversionService . addConverter ( new   CollectionToObjectConverter ( conversionService )  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( list )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" objectToCollection \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "List < List < List < Integer >  >  >    result    =     (  ( List < List < List < Integer >  >  >  )     ( conversionService . convert ( list ,    sourceType ,    targetType )  )  )  ;", "assertEquals (  (  ( Integer )     (  9  )  )  ,    result . get (  0  )  . get (  0  )  . get (  0  )  )  ;", "assertEquals (  (  ( Integer )     (  1  2  )  )  ,    result . get (  0  )  . get (  0  )  . get (  1  )  )  ;", "assertEquals (  (  ( Integer )     (  3  7  )  )  ,    result . get (  1  )  . get (  0  )  . get (  0  )  )  ;", "assertEquals (  (  ( Integer )     (  2  3  )  )  ,    result . get (  1  )  . get (  0  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["stringToCollection"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "Object   myConverted    =    new   CollectionToCollectionConverter ( new   GenericConversionService (  )  )  . convert ( aSource ,    TypeDescriptor . forObject ( aSource )  ,    TypeDescriptor . forObject ( new   ArrayList (  )  )  )  ;", "assertTrue (  ( myConverted   instanceof   ArrayList <  ?  >  )  )  ;", "assertEquals ( aSource . size (  )  ,     (  ( ArrayList <  ?  >  )     ( myConverted )  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionConversionToArrayList"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "CollectionToCollectionConverter   converter    =    new   CollectionToCollectionConverter ( new   GenericConversionService (  )  )  ;", "TypeDescriptor   type    =    new   TypeDescriptor ( getClass (  )  . getField (  \" list \"  )  )  ;", "converter . convert ( list ,    type ,    TypeDescriptor . valueOf ( Class . forName (  \" Collections $ EmptyList \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionsEmptyList"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverterFactory ( new   StringToEnumConverterFactory (  )  )  ;", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  \" A \"  )  ;", "list . add (  \" C \"  )  ;", "assertEquals ( EnumSet . of (  . MyEnum . A ,     . MyEnum . C )  ,    conversionService . convert ( list ,    TypeDescriptor . forObject ( list )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" enumSet \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToEnumSet"], "fileName": "org.springframework.core.convert.support.CollectionToCollectionConverterTests"}, {"methodBody": ["METHOD_START", "{", "if    ( converters    !  =    null )     {", "for    ( Object   converter    :    converters )     {", "if    ( converter   instanceof   GenericConverter )     {", "registry . addConverter (  (  ( GenericConverter )     ( converter )  )  )  ;", "} else", "if    ( converter   instanceof   converter . Converter <  ?  ,     ?  >  )     {", "registry . addConverter (  (  ( converter . Converter <  ?  ,     ?  >  )     ( converter )  )  )  ;", "} else", "if    ( converter   instanceof   converter . ConverterFactory <  ?  ,     ?  >  )     {", "registry . addConverterFactory (  (  ( converter . ConverterFactory <  ?  ,     ?  >  )     ( converter )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Each   converter   object   must   implement   one   of   the    \"     +     \" Converter ,    ConverterFactory ,    or   GenericConverter   interfaces \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["registerConverters"], "fileName": "org.springframework.core.convert.support.ConversionServiceFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( targetElementType    =  =    null )     {", "return   true ;", "}", "if    ( sourceElementType    =  =    null )     {", "return   true ;", "}", "if    ( cService . canConvert ( sourceElementType ,    targetElementType )  )     {", "return   true ;", "} else", "if    ( sourceElementType . getType (  )  . isAssignableFrom ( targetElementType . getType (  )  )  )     {", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["canConvertElements"], "fileName": "org.springframework.core.convert.support.ConversionUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    enumType    =    targetType ;", "while    (  ( enumType    !  =    null )     &  &     (  !  ( enumType . isEnum (  )  )  )  )     {", "enumType    =    enumType . getSuperclass (  )  ;", "}", "AssnotNull ( enumType ,     (  )     -  >     (  \" The   target   type    \"     +     ( targetType . getName (  )  )  )     +     \"    does   not   refer   to   an   enum \"  )  ;", "return   enumType ;", "}", "METHOD_END"], "methodName": ["getEnumType"], "fileName": "org.springframework.core.convert.support.ConversionUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   converter . convert ( source ,    sourceType ,    targetType )  ;", "}    catch    ( FailedException   ex )     {", "throw   ex ;", "}    catch    ( Throwable   ex )     {", "throw   new   FailedException ( sourceType ,    targetType ,    source ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeConverter"], "fileName": "org.springframework.core.convert.support.ConversionUtils"}, {"methodBody": ["METHOD_START", "{", "ConversionService   conversionService    =     (  ( ConversionService )     ( converterRegistry )  )  ;", "converterRegistry . addConverter ( new   ArrayToCollectionConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   CollectionToArrayConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   ArrayToArrayConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   CollectionToCollectionConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   MapToMapConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   ArrayToStringConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   StringToArrayConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   ArrayToObjectConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   ObjectToArrayConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   CollectionToStringConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   StringToCollectionConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   CollectionToObjectConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   ObjectToCollectionConverter ( conversionService )  )  ;", "converterRegistry . addConverter ( new   StreamConverter ( conversionService )  )  ;", "}", "METHOD_END"], "methodName": ["addCollectionConverters"], "fileName": "org.springframework.core.convert.support.DefaultConversionService"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionService . addScalarConverters ( converterRegistry )  ;", "DefaultConversionService . addCollectionConverters ( converterRegistry )  ;", "converterRegistry . addConverter ( new   ByteBufferConverter (  (  ( ConversionService )     ( converterRegistry )  )  )  )  ;", "converterRegistry . addConverter ( new   StringToTimeZoneConverter (  )  )  ;", "converterRegistry . addConverter ( new   ZoneIdToTimeZoneConverter (  )  )  ;", "converterRegistry . addConverter ( new   ZonedDateTimeToCalendarConverter (  )  )  ;", "converterRegistry . addConverter ( new   ObjectToObjectConverter (  )  )  ;", "converterRegistry . addConverter ( new   IdToEntityConverter (  (  ( ConversionService )     ( converterRegistry )  )  )  )  ;", "converterRegistry . addConverter ( new   FallbackObjectToStringConverter (  )  )  ;", "converterRegistry . addConverter ( new   ObjectToOptionalConverter (  (  ( ConversionService )     ( converterRegistry )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addDefaultConverters"], "fileName": "org.springframework.core.convert.support.DefaultConversionService"}, {"methodBody": ["METHOD_START", "{", "converterRegistry . addConverterFactory ( new   NumberToNumberConverterFactory (  )  )  ;", "converterRegistry . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "converterRegistry . addConverter ( Number . class ,    String . class ,    new   ObjectToStringConverter (  )  )  ;", "converterRegistry . addConverter ( new   StringToCharacterConverter (  )  )  ;", "converterRegistry . addConverter ( Character . class ,    String . class ,    new   ObjectToStringConverter (  )  )  ;", "converterRegistry . addConverter ( new   NumberToCharacterConverter (  )  )  ;", "converterRegistry . addConverterFactory ( new   CharacterToNumberFactory (  )  )  ;", "converterRegistry . addConverter ( new   StringToBooleanConverter (  )  )  ;", "converterRegistry . addConverter ( Boolean . class ,    String . class ,    new   ObjectToStringConverter (  )  )  ;", "converterRegistry . addConverterFactory ( new   StringToEnumConverterFactory (  )  )  ;", "converterRegistry . addConverter ( new   EnumToStringConverter (  (  (  )     ( converterRegistry )  )  )  )  ;", "converterRegistry . addConverterFactory ( new   IntegerToEnumConverterFactory (  )  )  ;", "converterRegistry . addConverter ( new   EnumToIntegerConverter (  (  (  )     ( converterRegistry )  )  )  )  ;", "converterRegistry . addConverter ( new   StringToLocaleConverter (  )  )  ;", "converterRegistry . addConverter ( Locale . class ,    String . class ,    new   ObjectToStringConverter (  )  )  ;", "converterRegistry . addConverter ( new   StringToCharsetConverter (  )  )  ;", "converterRegistry . addConverter ( Charset . class ,    String . class ,    new   ObjectToStringConverter (  )  )  ;", "converterRegistry . addConverter ( new   StringToCurrencyConverter (  )  )  ;", "converterRegistry . addConverter ( Currency . class ,    String . class ,    new   ObjectToStringConverter (  )  )  ;", "converterRegistry . addConverter ( new   StringToPropertiesConverter (  )  )  ;", "converterRegistry . addConverter ( new   PropertiesToStringConverter (  )  )  ;", "converterRegistry . addConverter ( new   StringToUUIDConverter (  )  )  ;", "converterRegistry . addConverter ( UUID . class ,    String . class ,    new   ObjectToStringConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["addScalarConverters"], "fileName": "org.springframework.core.convert.support.DefaultConversionService"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionService   cs    =    DefaultConversionService . sharedInstance ;", "if    ( cs    =  =    null )     {", "synchronized ( DefaultConversionService . class )     {", "cs    =    DefaultConversionService . sharedInstance ;", "if    ( cs    =  =    null )     {", "cs    =    new   DefaultConversionService (  )  ;", "DefaultConversionService . sharedInstance    =    cs ;", "}", "}", "}", "return   cs ;", "}", "METHOD_END"], "methodName": ["getSharedInstance"], "fileName": "org.springframework.core.convert.support.DefaultConversionService"}, {"methodBody": ["METHOD_START", "{", "if    ( targetType . isPrimitive (  )  )     {", "throw   new   FailedException ( sourceType ,    targetType ,    null ,    new   IllegalArgumentException (  \" A   null   value   cannot   be   assigned   to   a   primitive   type \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertNotPrimitiveTargetType"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( targetType ,     \" Target   type   to   convert   to   cannot   be   null \"  )  ;", "if    ( sourceType    =  =    null )     {", "return   true ;", "}", "GenericConverter   converter    =    getConverter ( sourceType ,    targetType )  ;", "return   converter    =  =     (  . NO _ OP _ CONVERTER )  ;", "}", "METHOD_END"], "methodName": ["canBypassConvert"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "return   convert ( source ,    TypeDescriptor . forObject ( source )  ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "if    (  ( targetType . getObjectType (  )  )     =  =     ( Optional . class )  )     {", "return   Optional . empty (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["convertNullSource"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "GenericConversionService . ConverterCacheKey   key    =    new   GenericConversionService . ConverterCacheKey ( sourceType ,    targetType )  ;", "GenericConverter   converter    =    this . converterCache . get ( key )  ;", "if    ( converter    !  =    null )     {", "return   converter    !  =     ( GenericConversionService . NO _ MATCH )     ?    converter    :    null ;", "}", "converter    =    this . converters . find ( sourceType ,    targetType )  ;", "if    ( converter    =  =    null )     {", "converter    =    getDefaultConverter ( sourceType ,    targetType )  ;", "}", "if    ( converter    !  =    null )     {", "this . converterCache . put ( key ,    converter )  ;", "return   converter ;", "}", "this . converterCache . put ( key ,    GenericConversionService . NO _ MATCH )  ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getConverter"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "return   sourceType . isAssignableTo ( targetType )     ?    GenericConversionService . NO _ OP _ CONVERTER    :    null ;", "}", "METHOD_END"], "methodName": ["getDefaultConverter"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   resolvableType    =    ResolvableType . forClass ( converterClass )  . as ( genericIfc )  ;", "ResolvableType [  ]    generics    =    resolvableType . getGenerics (  )  ;", "if    (  ( generics . length )     <     2  )     {", "return   null ;", "}", "Class <  ?  >    sourceType    =    generics [  0  ]  . resolve (  )  ;", "Class <  ?  >    targetType    =    generics [  1  ]  . resolve (  )  ;", "if    (  ( sourceType    =  =    null )     |  |     ( targetType    =  =    null )  )     {", "return   null ;", "}", "return   generics ;", "}", "METHOD_END"], "methodName": ["getRequiredTypeInfo"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "if    ( source    =  =    null )     {", "assertNotPrimitiveTargetType ( sourceType ,    targetType )  ;", "return   null ;", "}", "if    (  (  ( sourceType    =  =    null )     |  |     ( sourceType . isAssignableTo ( targetType )  )  )     &  &     ( targetType . getObjectType (  )  . isInstance ( source )  )  )     {", "return   source ;", "}", "throw   new   CerNotFoundException ( sourceType ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["handleConverterNotFound"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "if    ( result    =  =    null )     {", "assNotPrimitiveTargetType ( sourceType ,    targetType )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["handleResult"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "this . converterCache . clear (  )  ;", "}", "METHOD_END"], "methodName": ["invalidateCache"], "fileName": "org.springframework.core.convert.support.GenericConversionService"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringToStringCollectionConverter (  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" stringCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" rawCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" stringCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" rawCollection \"  )  )  )  )  ;", "try    {", "conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" integerCollection \"  )  )  )  ;", "fail (  \" Should   have   thrown   ConverterNotFoundException \"  )  ;", "}    catch    ( ConverterNotFoundException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["adaptedCollectionTypesFromSameSourceType"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . UntypedConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["addConverterNoSourceTargetClassInfoAvailable"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( conversionService . canConvert ( String . class ,    Integer . class )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertTrue ( conversionService . canConvert ( String . class ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["canConvert"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( conversionService . canConvert ( String . class ,    String . class )  )  ;", "assertTrue ( conversionService . canConvert ( Integer . class ,    Number . class )  )  ;", "assertTrue ( conversionService . canConvert ( boolean . class ,    boolean . class )  )  ;", "assertTrue ( conversionService . canConvert ( boolean . class ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["canConvertAssignable"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . canConvert ( String . class ,    null )  ;", "}", "METHOD_END"], "methodName": ["canConvertFromClassSourceTypeToNullTargetType"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . canConvert ( TypeDescriptor . valueOf ( String . class )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["canConvertFromTypeDescriptorSourceTypeToNullTargetType"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . canConvert ( String . class ,    null )  ;", "}", "METHOD_END"], "methodName": ["canConvertIllegalArgumentNullTargetTypeFromClass"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . canConvert ( TypeDescriptor . valueOf ( String . class )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["canConvertIllegalArgumentNullTargetTypeFromTypeDescriptor"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( conversionService . canConvert ( null ,    Integer . class )  )  ;", "assertTrue ( conversionService . canConvert ( null ,    TypeDescriptor . valueOf ( Integer . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["canConvertNullSourceType"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "GenericConversionServiceTests . MyConditionalGenericConverter   converter    =    new   GenericConversionServiceTests . MyConditionalGenericConverter (  )  ;", "conversionService . addConverter ( converter )  ;", "assertEquals (  (  ( Integer )     (  3  )  )  ,    conversionService . convert (  3  ,    Integer . class )  )  ;", "assertThat ( converter . getSourceTypes (  )  . size (  )  ,    greaterThan (  2  )  )  ;", "assertTrue ( converter . getSourceTypes (  )  . stream (  )  . allMatch (  (    td )     -  >    Integer . class . equals ( td . getType (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionalConversionForAllTypes"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "GenericConversionServiceTests . MyConditionalConverter   converter    =    new   GenericConversionServiceTests . MyConditionalConverter (  )  ;", "conversionService . addConverter ( new   GenericConversionServiceTests . ColorConverter (  )  )  ;", "conversionService . addConverter ( converter )  ;", "assertEquals ( Color . BLACK ,    conversionService . convert (  \"  #  0  0  0  0  0  0  \"  ,    Color . class )  )  ;", "assertTrue (  (  ( converter . getMatchAttempts (  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionalConverter"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . ColorConverter (  )  )  ;", "conversionService . addConverter ( new   GenericConversionServiceTests . MyConditionalColorConverter (  )  )  ;", "assertEquals ( Color . BLACK ,    conversionService . convert (  \"  0  0  0  0  0  0 xxxx \"  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" activeColor \"  )  )  )  )  ;", "assertEquals ( Color . BLACK ,    conversionService . convert (  \"     #  0  0  0  0  0  0     \"  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" inactiveColor \"  )  )  )  )  ;", "assertEquals ( Color . BLACK ,    conversionService . convert (  \"  0  0  0  0  0  0 yyyy \"  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" activeColor \"  )  )  )  )  ;", "assertEquals ( Color . BLACK ,    conversionService . convert (  \"        #  0  0  0  0  0  0        \"  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" inactiveColor \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionalConverterCachingForDifferentAnnotationAttributes"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "GenericConversionServiceTests . MyConditionalConverterFactory   converter    =    new   GenericConversionServiceTests . MyConditionalConverterFactory (  )  ;", "conversionService . addConverter ( new   GenericConversionServiceTests . ColorConverter (  )  )  ;", "conversionService . addConverterFactory ( converter )  ;", "assertEquals ( Color . BLACK ,    conversionService . convert (  \"  #  0  0  0  0  0  0  \"  ,    Color . class )  )  ;", "assertTrue (  (  ( converter . getMatchAttempts (  )  )     >     0  )  )  ;", "assertTrue (  (  ( converter . getNestedMatchAttempts (  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["conditionalConverterFactory"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    conversionService . convert (  \"  3  \"  ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Boolean . FALSE ,    conversionService . convert ( false ,    boolean . class )  )  ;", "assertEquals ( Boolean . FALSE ,    conversionService . convert ( false ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertAssignableSource"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert (  \"  3  \"  ,    null ,    TypeDescriptor . valueOf ( int . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertNotNullSourceNullSourceTypeDescriptor"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( conversionService . convert ( null ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertNull"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   source    =    null ;", "TypeDescriptor   sourceType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" annotatedString \"  )  )  ;", "TypeDescriptor   targetType    =    TypeDescriptor . valueOf ( String . class )  ;", "c . convert ( source ,    sourceType ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["convertNullAnnotatedStringToString"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    conversionService . convert ( null ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertNullSource"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert ( null ,    int . class )  ;", "}", "METHOD_END"], "methodName": ["convertNullSourcePrimitiveTarget"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert ( null ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( int . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertNullSourcePrimitiveTargetTypeDescriptor"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( conversionService . canConvert ( String . class ,    boolean . class )  )  ;", "conversionService . addConverter ( new   StringToBooleanConverter (  )  )  ;", "assertTrue ( conversionService . canConvert ( String . class ,    boolean . class )  )  ;", "Boolean   b    =    conversionService . convert (  \" true \"  ,    boolean . class )  ;", "assertTrue ( b )  ;", "assertTrue ( conversionService . canConvert ( TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( boolean . class )  )  )  ;", "b    =     (  ( Boolean )     ( conversionService . convert (  \" true \"  ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( boolean . class )  )  )  )  ;", "assertTrue ( b )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToPrimitive"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( conversionService . canConvert ( String . class ,    int . class )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertTrue ( conversionService . canConvert ( String . class ,    int . class )  )  ;", "Integer   three    =    conversionService . convert (  \"  3  \"  ,    int . class )  ;", "assertEquals (  3  ,    three . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToPrimitiveViaConverterFactory"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    byteArray    =    new   byte [  ]  {     1  ,     2  ,     3     }  ;", "byte [  ]    converted    =    c . convert ( byteArray ,    byte [  ]  . class )  ;", "assertSame ( byteArray ,    converted )  ;", "}", "METHOD_END"], "methodName": ["convertOptimizeArray"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   Converter < CharSequence ,    Integer >  (  )     {", "@ Override", "public   Integer   convert ( CharSequence   source )     {", "return   Integer . valueOf ( source . toString (  )  )  ;", "}", "}  )  ;", "Integer   result    =    conversionService . convert (  \"  3  \"  ,    Integer . class )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["convertSuperSourceType"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . ColorConverter (  )  )  ;", "conversionService . convert (  \"  #  0  0  0  0  0  0  \"  ,    SystemColor . class )  ;", "}", "METHOD_END"], "methodName": ["convertSuperTarget"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert (  \"  3  \"  ,     (  ( Class <  ?  >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["convertToNullTargetClass"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert (  \"  3  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["convertToNullTargetTypeDescriptor"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert (  \"  3  \"  ,    TypeDescriptor . valueOf ( Integer . class )  ,    TypeDescriptor . valueOf ( Long . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertWrongSourceTypeDescriptor"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "conversionService . convert (  \" BOGUS \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["convertWrongTypeArgument"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . convert (  \"  3  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["converterNotFound"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   CollectionToArrayConverter ( conversionService )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( list )  ;", "TypeDescriptor   targetType    =    TypeDescriptor . valueOf ( String [  ]  . class )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "assertEquals (  0  ,     (  ( String [  ]  )     ( conversionService . convert ( list ,    sourceType ,    targetType )  )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["emptyListToArray"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   CollectionToObjectConverter ( conversionService )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( list )  ;", "TypeDescriptor   targetType    =    TypeDescriptor . valueOf ( Integer . class )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "assertNull ( conversionService . convert ( list ,    sourceType ,    targetType )  )  ;", "}", "METHOD_END"], "methodName": ["emptyListToObject"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringToGenericCollectionConverter (  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" stringCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" rawCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" integerCollection \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["genericCollectionAsSource"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   ObjectToArrayConverter ( conversionService )  )  ;", "assertFalse ( conversionService . canConvert ( String . class ,    Integer [  ]  . class )  )  ;", "conversionService . convert (  \"  3  ,  4  ,  5  \"  ,    Integer [  ]  . class )  ;", "}", "METHOD_END"], "methodName": ["genericConverterDelegatingBackToConversionServiceConverterNotFound"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringToRawCollectionConverter (  )  )  ;", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringToGenericCollectionConverter (  )  )  ;", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringToStringCollectionConverter (  )  )  ;", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringToIntegerCollectionConverter (  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" stringCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  4  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" integerCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  4  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" rawCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  4  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  4  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" rawCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" stringCollection \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multipleCollectionTypesFromSameSourceType"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringToRawCollectionConverter (  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" stringCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" genericCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" rawCollection \"  )  )  )  )  ;", "assertEquals ( Collections . singleton (  \" testX \"  )  ,    conversionService . convert (  \" test \"  ,    TypeDescriptor . valueOf ( String . class )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" integerCollection \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["rawCollectionAsSource"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . ColorConverter (  )  )  ;", "assertTrue ( conversionService . canConvert ( String . class ,    Color . class )  )  ;", "conversionService . removeConvertible ( String . class ,    Color . class )  ;", "assertFalse ( conversionService . canConvert ( String . class ,    Color . class )  )  ;", "}", "METHOD_END"], "methodName": ["removeConvertible"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "GenericConverter   converter    =    new   GenericConversionServiceTests . NonConditionalGenericConverter (  )  ;", "try    {", "conversionService . addConverter ( converter )  ;", "fail (  \" Did   not   throw   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \" Only   conditional   converters   may   return   null   convertible   types \"  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["shouldNotSupportNullConvertibleTypesFromNonConditionalGenericConverter"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( conversionService . canConvert ( void . class ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["sourceTypeIsVoid"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   StringToArrayConverter ( conversionService )  )  ;", "assertFalse ( conversionService . canConvert ( String . class ,    Integer [  ]  . class )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertTrue ( conversionService . canConvert ( String . class ,    Integer [  ]  . class )  )  ;", "}", "METHOD_END"], "methodName": ["stringToArrayCanConvert"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   StringToCollectionConverter ( conversionService )  )  ;", "assertTrue ( conversionService . canConvert ( String . class ,    Collection . class )  )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" integerCollection \"  )  )  ;", "assertFalse ( conversionService . canConvert ( TypeDescriptor . valueOf ( String . class )  ,    targetType )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertTrue ( conversionService . canConvert ( TypeDescriptor . valueOf ( String . class )  ,    targetType )  )  ;", "}", "METHOD_END"], "methodName": ["stringToCollectionCanConvert"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( conversionService . canConvert ( String . class ,    void . class )  )  ;", "}", "METHOD_END"], "methodName": ["targetTypeIsVoid"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "GenericConverter . ConvertiblePair   pair    =    new   GenericConverter . ConvertiblePair ( Number . class ,    String . class )  ;", "GenericConverter . ConvertiblePair   pairOpposite    =    new   GenericConverter . ConvertiblePair ( String . class ,    Number . class )  ;", "assertFalse ( pair . equals ( pairOpposite )  )  ;", "assertFalse (  (  ( pair . hashCode (  )  )     =  =     ( pairOpposite . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testConvertiblePairDifferentEqualsAndHash"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "GenericConverter . ConvertiblePair   pair    =    new   GenericConverter . ConvertiblePair ( Number . class ,    String . class )  ;", "GenericConverter . ConvertiblePair   pairEqual    =    new   GenericConverter . ConvertiblePair ( Number . class ,    String . class )  ;", "assertEquals ( pair ,    pairEqual )  ;", "assertEquals ( pair . hashCode (  )  ,    pairEqual . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConvertiblePairEqualsAndHash"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Set < GenericConverter . ConvertiblePair >    set    =    new   HashSet <  >  (  )  ;", "set . add ( new   GenericConverter . ConvertiblePair ( Number . class ,    String . class )  )  ;", "assert   set . contains ( new   GenericConverter . ConvertiblePair ( Number . class ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testConvertiblePairsInSet"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   EnumToStringConverter ( conversionService )  )  ;", "assertEquals (  \" A \"  ,    conversionService . convert (  . MyEnum . A ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testEnumToStringConversion"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   EnumToStringConverter ( conversionService )  )  ;", "conversionService . addConverter ( new    . MyEnumInterfaceToStringConverter <  . MyEnum >  (  )  )  ;", "assertEquals (  \"  1  \"  ,    conversionService . convert (  . MyEnum . A ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testEnumWithInterfaceToStringConversion"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "GenericConversionServiceTests . WithCopyConstructor   value    =    new   GenericConversionServiceTests . WithCopyConstructor (  )  ;", "Object   result    =    conversionService . convert ( value ,    GenericConversionServiceTests . WithCopyConstructor . class )  ;", "assertSame ( value ,    result )  ;", "}", "METHOD_END"], "methodName": ["testIgnoreCopyConstructor"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyBaseInterfaceToStringConverter (  )  )  ;", "conversionService . addConverter ( new   ArrayToArrayConverter ( conversionService )  )  ;", "String [  ]    converted    =    conversionService . convert ( new   GenericConversionServiceTests . MyInterface [  ]  {    new   GenericConversionServiceTests . MyInterfaceImplementer (  )     }  ,    String [  ]  . class )  ;", "assertEquals (  \" RESULT \"  ,    converted [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testInterfaceArrayToStringArray"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyBaseInterfaceToStringConverter (  )  )  ;", "conversionService . addConverter ( new   ObjectToStringConverter (  )  )  ;", "Object   converted    =    conversionService . convert ( new   GenericConversionServiceTests . MyInterfaceImplementer (  )  ,    String . class )  ;", "assertEquals (  \" RESULT \"  ,    converted )  ;", "}", "METHOD_END"], "methodName": ["testInterfaceToString"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    raw    =    new   ArrayList <  >  (  )  ;", "raw . add (  \" one \"  )  ;", "raw . add (  \" two \"  )  ;", "Object   converted    =    c . convert ( raw ,    Iterable . class )  ;", "assertSame ( raw ,    converted )  ;", "}", "METHOD_END"], "methodName": ["testListToIterableConversion"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    raw    =    new   ArrayList <  >  (  )  ;", "raw . add (  \" one \"  )  ;", "raw . add (  \" two \"  )  ;", "Object   converted    =    c . convert ( raw ,    Object . class )  ;", "assertSame ( raw ,    converted )  ;", "}", "METHOD_END"], "methodName": ["testListToObjectConversion"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Map < Object ,    Object >    raw    =    new   HashMap <  >  (  )  ;", "raw . put (  \" key \"  ,     \" value \"  )  ;", "Object   converted    =    c . convert ( raw ,    Object . class )  ;", "assertSame ( raw ,    converted )  ;", "}", "METHOD_END"], "methodName": ["testMapToObjectConversion"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyBaseInterfaceToStringConverter (  )  )  ;", "conversionService . addConverter ( new   ArrayToArrayConverter ( conversionService )  )  ;", "String [  ]    converted    =    conversionService . convert ( new   GenericConversionServiceTests . MyInterfaceImplementer [  ]  {    new   GenericConversionServiceTests . MyInterfaceImplementer (  )     }  ,    String [  ]  . class )  ;", "assertEquals (  \" RESULT \"  ,    converted [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testObjectArrayToStringArray"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( TestGroup . PERFORMANCE )  ;", "StopWatch   watch    =    new   StopWatch (  \" list < string >     -  >    list < integer >    conversionPerformance \"  )  ;", "watch . start (  \" convert    4  ,  0  0  0  ,  0  0  0    with   conversion   service \"  )  ;", "List < String >    source    =    new   LinkedList <  >  (  )  ;", "source . add (  \"  1  \"  )  ;", "source . add (  \"  2  \"  )  ;", "source . add (  \"  3  \"  )  ;", "TypeDescriptor   td    =    new   TypeDescriptor ( getClass (  )  . getField (  \" list \"  )  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "c . convert ( source ,    TypeDescriptor . forObject ( source )  ,    td )  ;", "}", "watch . stop (  )  ;", "watch . start (  \" convert    4  ,  0  0  0  ,  0  0  0    manually \"  )  ;", "for    ( int   i    =     0  ;    i    <     4  0  0  0  0  0  0  ;    i +  +  )     {", "List < Integer >    target    =    new   ArrayList <  >  ( source . size (  )  )  ;", "for    ( String   element    :    source )     {", "target . add ( Integer . valueOf ( element )  )  ;", "}", "}", "watch . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testPerformance2"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( TestGroup . PERFORMANCE )  ;", "StopWatch   watch    =    new   StopWatch (  \" map < string ,    string >     -  >    map < string ,    integer >    conversionPerformance \"  )  ;", "watch . start (  \" convert    4  ,  0  0  0  ,  0  0  0    with   conversion   service \"  )  ;", "Map < String ,    String >    source    =    new   HashMap <  >  (  )  ;", "source . put (  \"  1  \"  ,     \"  1  \"  )  ;", "source . put (  \"  2  \"  ,     \"  2  \"  )  ;", "source . put (  \"  3  \"  ,     \"  3  \"  )  ;", "TypeDescriptor   td    =    new   TypeDescriptor ( getClass (  )  . getField (  \" map \"  )  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "c . convert ( source ,    TypeDescriptor . forObject ( source )  ,    td )  ;", "}", "watch . stop (  )  ;", "watch . start (  \" convert    4  ,  0  0  0  ,  0  0  0    manually \"  )  ;", "for    ( int   i    =     0  ;    i    <     4  0  0  0  0  0  0  ;    i +  +  )     {", "Map < String ,    Integer >    target    =    new   HashMap <  >  ( source . size (  )  )  ;", "source . forEach (  (    k ,    v )     -  >    target . put ( k ,    Integer . valueOf ( v )  )  )  ;", "}", "watch . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testPerformance3"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringArrayToIntegerArrayConverter (  )  )  ;", "Integer [  ]    converted    =    conversionService . convert ( new   String [  ]  {     \" x 1  \"  ,     \" z 3  \"     }  ,    Integer [  ]  . class )  ;", "assertArrayEquals ( new   Integer [  ]  {     1  ,     3     }  ,    converted )  ;", "}", "METHOD_END"], "methodName": ["testStringArrayToIntegerArray"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringArrayToResourceArrayConverter (  )  )  ;", "Resource [  ]    converted    =    conversionService . convert ( new   String [  ]  {     \" x 1  \"  ,     \" z 3  \"     }  ,    Resource [  ]  . class )  ;", "List < String >    descriptions    =    Arrays . stream ( converted )  . map ( Resource :  : getDescription )  . sorted ( Comparator . naturalOrder (  )  )  . collect ( Collectors . toList (  )  )  ;", "assertEquals ( Arrays . asList (  \"  1  \"  ,     \"  3  \"  )  ,    descriptions )  ;", "}", "METHOD_END"], "methodName": ["testStringArrayToResourceArray"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverterFactory ( new   StringToEnumConverterFactory (  )  )  ;", "conversionService . addConverterFactory ( new    . StringToMyEnumBaseInterfaceConverterFactory (  )  )  ;", "assertEquals (  . MyEnum . A ,    conversionService . convert (  \" base 1  \"  ,     . MyEnum . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToEnumWithBaseInterfaceConversion"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverterFactory ( new   StringToEnumConverterFactory (  )  )  ;", "conversionService . addConverterFactory ( new    . StringToMyEnumInterfaceConverterFactory (  )  )  ;", "assertEquals (  . MyEnum . A ,    conversionService . convert (  \"  1  \"  ,     . MyEnum . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToEnumWithInterfaceConversion"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   GenericConversionServiceTests . MyStringToIntegerArrayConverter (  )  )  ;", "Integer [  ]    converted    =    conversionService . convert (  \" x 1  , z 3  \"  ,    Integer [  ]  . class )  ;", "assertArrayEquals ( new   Integer [  ]  {     1  ,     3     }  ,    converted )  ;", "}", "METHOD_END"], "methodName": ["testStringToIntegerArray"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   value    =     \" myValue \"  ;", "Object   result    =    c . convert ( value ,    Object . class )  ;", "assertSame ( value ,    result )  ;", "}", "METHOD_END"], "methodName": ["testStringToObject"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   value    =     \" myValue \"  ;", "String   result    =    c . convert ( value ,    String . class )  ;", "assertSame ( value ,    result )  ;", "}", "METHOD_END"], "methodName": ["testStringToString"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   EnumToStringConverter ( conversionService )  )  ;", "assertEquals (  \" FIRST \"  ,    conversionService . convert (  . EnumWithSubclass . FIRST ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testSubclassOfEnumToString"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    input    =    new   LinkedHashMap <  >  (  )  ;", "input . put (  \" key \"  ,     \" value \"  )  ;", "Object   converted    =    c . convert ( input ,    TypeDescriptor . forObject ( input )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" wildcardMap \"  )  )  )  ;", "assertEquals ( input ,    converted )  ;", "}", "METHOD_END"], "methodName": ["testWildcardMap"], "fileName": "org.springframework.core.convert.support.GenericConversionServiceTests"}, {"methodBody": ["METHOD_START", "{", "String   shortName    =    ClassUtils . getShortName ( entityClass )  ;", "int   lastDot    =    shortName . lastIndexOf (  '  .  '  )  ;", "if    ( lastDot    !  =     (  -  1  )  )     {", "return   shortName . substring (  ( lastDot    +     1  )  )  ;", "} else    {", "return   shortName ;", "}", "}", "METHOD_END"], "methodName": ["getEntityName"], "fileName": "org.springframework.core.convert.support.IdToEntityConverter"}, {"methodBody": ["METHOD_START", "{", "String   finderMethod    =     \" find \"     +     ( getEntityName ( entityClass )  )  ;", "Method [  ]    methods ;", "boolean   localOnlyFiltered ;", "try    {", "methods    =    entityClass . getDeclaredMethods (  )  ;", "localOnlyFiltered    =    true ;", "}    catch    ( SecurityException   ex )     {", "methods    =    entityClass . getMethods (  )  ;", "localOnlyFiltered    =    false ;", "}", "for    ( Method   method    :    methods )     {", "if    (  (  (  (  ( Modifier . isStatic ( method . getModifiers (  )  )  )     &  &     ( method . getName (  )  . equals ( finderMethod )  )  )     &  &     (  ( method . getParameterCount (  )  )     =  =     1  )  )     &  &     ( method . getReturnType (  )  . equals ( entityClass )  )  )     &  &     ( localOnlyFiltered    |  |     ( method . getDeclaringClass (  )  . equals ( entityClass )  )  )  )     {", "return   method ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getFinder"], "fileName": "org.springframework.core.convert.support.IdToEntityConverter"}, {"methodBody": ["METHOD_START", "{", "return   ConversionUtils . canConvertElements ( sourceType . getMapKeyTypeDescriptor (  )  ,    targetType . getMapKeyTypeDescriptor (  )  ,    this . conversionService )  ;", "}", "METHOD_END"], "methodName": ["canConvertKey"], "fileName": "org.springframework.core.convert.support.MapToMapConverter"}, {"methodBody": ["METHOD_START", "{", "return   ConversionUtils . canConvertElements ( sourceType . getMapValueTypeDescriptor (  )  ,    targetType . getMapValueTypeDescriptor (  )  ,    this . conversionService )  ;", "}", "METHOD_END"], "methodName": ["canConvertValue"], "fileName": "org.springframework.core.convert.support.MapToMapConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( targetType    =  =    null )     {", "return   sourceKey ;", "}", "return   this . conversionServic ( sourceKey ,    sourceType . getMapKeyTypeDescriptor ( sourceKey )  ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["convertKey"], "fileName": "org.springframework.core.convert.support.MapToMapConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( targetType    =  =    null )     {", "return   sourceValue ;", "}", "return   this . conversionServic ( sourceValue ,    sourceType . getMapValueTypeDescriptor ( sourceValue )  ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["convertValue"], "fileName": "org.springframework.core.convert.support.MapToMapConverter"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  1  \"  ,    Arrays . asList (  \"  9  \"  ,     \"  1  2  \"  )  )  ;", "map . put (  \"  2  \"  ,    Arrays . asList (  \"  3  7  \"  ,     \"  2  3  \"  )  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( map )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" collectionMapTarget \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "try    {", "conversionServic ( map ,    sourceType ,    targetType )  ;", "}    catch    ( ConversionFailedException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   ConverterNotFoundException )  )  ;", "}", "conversionService . addConverter ( new   CollectionToCollectionConverter ( conversionService )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < Integer ,    List < Integer >  >    result    =     (  ( Map < Integer ,    List < Integer >  >  )     ( conversionServic ( map ,    sourceType ,    targetType )  )  )  ;", "assertFalse ( map . equals ( result )  )  ;", "assertEquals ( Arrays . asList (  9  ,     1  2  )  ,    result . get (  1  )  )  ;", "assertEquals ( Arrays . asList (  3  7  ,     2  3  )  ,    result . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["collectionMap"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  1  \"  ,    Arrays . asList (  \"  9  \"  ,     \"  1  2  \"  )  )  ;", "map . put (  \"  2  \"  ,    Arrays . asList (  \"  3  7  \"  ,     \"  2  3  \"  )  )  ;", "assertTrue ( conversionService . canConvert ( Map . class ,    Map . class )  )  ;", "assertSame ( map ,    conversionServic ( map ,    Map . class )  )  ;", "}", "METHOD_END"], "methodName": ["collectionMapNotGenericTarget"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  1  \"  ,    Arrays . asList (  \"  9  \"  ,     \"  1  2  \"  )  )  ;", "map . put (  \"  2  \"  ,    Arrays . asList (  \"  3  7  \"  ,     \"  2  3  \"  )  )  ;", "conversionService . add ( new   CollectionToCollection ( conversionService )  )  ;", "conversionService . add ( new   CollectionToObject ( conversionService )  )  ;", "assertTrue ( conversionService . canConvert ( Map . class ,    Map . class )  )  ;", "assertSame ( map ,    conversionService . convert ( map ,    Map . class )  )  ;", "}", "METHOD_END"], "methodName": ["collectionMapNotGenericTargetCollectionToObjectInteraction"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  1  \"  ,    Arrays . asList (  \"  9  \"  ,     \"  1  2  \"  )  )  ;", "map . put (  \"  2  \"  ,    Arrays . asList (  \"  3  7  \"  ,     \"  2  3  \"  )  )  ;", "TypeDescriptor   sourceType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" sourceCollectionMapTarget \"  )  )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" collectionMapTarget \"  )  )  ;", "assertFalse ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "try    {", "conversionServic ( map ,    sourceType ,    targetType )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( ConverterNotFoundException   ex )     {", "}", "conversionService . addConverter ( new   CollectionToCollectionConverter ( conversionService )  )  ;", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < Integer ,    List < Integer >  >    result    =     (  ( Map < Integer ,    List < Integer >  >  )     ( conversionServic ( map ,    sourceType ,    targetType )  )  )  ;", "assertFalse ( map . equals ( result )  )  ;", "assertEquals ( Arrays . asList (  9  ,     1  2  )  ,    result . get (  1  )  )  ;", "assertEquals ( Arrays . asList (  3  7  ,     2  3  )  ,    result . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["collectionMapSourceTarget"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( map )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" emptyMapTarget \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "assertSame ( map ,    conversionServic ( map ,    sourceType ,    targetType )  )  ;", "}", "METHOD_END"], "methodName": ["emptyMap"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( map )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" emptyMapDifferentTarget \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "LinkedHashMap < String ,    String >    result    =     (  ( LinkedHashMap < String ,    String >  )     ( conversionServic ( map ,    sourceType ,    targetType )  )  )  ;", "assertEquals ( map ,    result )  ;", "assertEquals ( LinkedHashMap . class ,    result . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyMapDifferentTargetImplType"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "assertTrue ( conversionService . canConvert ( Map . class ,    Map . class )  )  ;", "assertSame ( map ,    conversionServic ( map ,    Map . class )  )  ;", "}", "METHOD_END"], "methodName": ["emptyMapNoTargetGenericInfo"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "Map < String ,    Integer >    source    =    new   HashMap <  >  (  )  ;", "source . put (  \" a \"  ,     1  )  ;", "source . put (  \" b \"  ,     2  )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" multiValueMapTarget \"  )  )  ;", "MultiValueMap < String ,    String >    converted    =     (  ( MultiValueMap < String ,    String >  )     ( conversionService . convert ( source ,    targetType )  )  )  ;", "assertThat ( converted . size (  )  ,    equalTo (  2  )  )  ;", "assertThat ( converted . get (  \" a \"  )  ,    equalTo ( Arrays . asList (  \"  1  \"  )  )  )  ;", "assertThat ( converted . get (  \" b \"  )  ,    equalTo ( Arrays . asList (  \"  2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mapToMultiValueMap"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "DefaultConversionService . addDefaultConverters ( conversionService )  ;", "MultiValueMap < String ,    Integer >    source    =    new   LinkedMultiValueMap <  >  (  )  ;", "source . put (  \" a \"  ,    Arrays . asList (  1  ,     2  ,     3  )  )  ;", "source . put (  \" b \"  ,    Arrays . asList (  4  ,     5  ,     6  )  )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" multiValueMapTarget \"  )  )  ;", "MultiValueMap < String ,    String >    converted    =     (  ( MultiValueMap < String ,    String >  )     ( conversionService . convert ( source ,    targetType )  )  )  ;", "assertThat ( converted . size (  )  ,    equalTo (  2  )  )  ;", "assertThat ( converted . get (  \" a \"  )  ,    equalTo ( Arrays . asList (  \"  1  \"  ,     \"  2  \"  ,     \"  3  \"  )  )  )  ;", "assertThat ( converted . get (  \" b \"  )  ,    equalTo ( Arrays . asList (  \"  4  \"  ,     \"  5  \"  ,     \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["multiValueMapToMultiValueMap"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "MapToMapConverterTests . NoDefaultConstructorMap < String ,    Integer >    map    =    new   MapToMapConverterTests . NoDefaultConstructorMap <  >  ( Collections .  < String ,    Integer > singletonMap (  \"  1  \"  ,     1  )  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . map ( MapToMapConverterTests . NoDefaultConstructorMap . class ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  ;", "TypeDescriptor   targetType    =    TypeDescriptor . map ( MapToMapConverterTests . NoDefaultConstructorMap . class ,    TypeDescriptor . valueOf ( String . class )  ,    TypeDescriptor . valueOf ( Integer . class )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    Integer >    result    =     (  ( Map < String ,    Integer >  )     ( conversionService . convert ( map ,    sourceType ,    targetType )  )  )  ;", "assertEquals ( map ,    result )  ;", "assertEquals ( MapToMapConverterTests . NoDefaultConstructorMap . class ,    result . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["noDefaultConstructorCopyNotRequired"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  1  \"  ,     \"  9  \"  )  ;", "map . put (  \"  2  \"  ,     \"  3  7  \"  )  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( map )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" scalarMapTarget \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "try    {", "conversionServic ( map ,    sourceType ,    targetType )  ;", "}    catch    ( ConversionFailedException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   ConverterNotFoundException )  )  ;", "}", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < Integer ,    Integer >    result    =     (  ( Map < Integer ,    Integer >  )     ( conversionServic ( map ,    sourceType ,    targetType )  )  )  ;", "assertFalse ( map . equals ( result )  )  ;", "assertEquals (  (  ( Integer )     (  9  )  )  ,    result . get (  1  )  )  ;", "assertEquals (  (  ( Integer )     (  3  7  )  )  ,    result . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["scalarMap"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  1  \"  ,     \"  9  \"  )  ;", "map . put (  \"  2  \"  ,     \"  3  7  \"  )  ;", "TypeDescriptor   sourceType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" notGenericMapSource \"  )  )  ;", "TypeDescriptor   targetType    =    new   TypeDescriptor ( getClass (  )  . getField (  \" scalarMapTarget \"  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "try    {", "conversionServic ( map ,    sourceType ,    targetType )  ;", "}    catch    ( ConversionFailedException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   ConverterNotFoundException )  )  ;", "}", "conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "assertTrue ( conversionService . canConvert ( sourceType ,    targetType )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < Integer ,    Integer >    result    =     (  ( Map < Integer ,    Integer >  )     ( conversionServic ( map ,    sourceType ,    targetType )  )  )  ;", "assertFalse ( map . equals ( result )  )  ;", "assertEquals (  (  ( Integer )     (  9  )  )  ,    result . get (  1  )  )  ;", "assertEquals (  (  ( Integer )     (  3  7  )  )  ,    result . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["scalarMapNotGenericSourceField"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \"  1  \"  ,     \"  9  \"  )  ;", "map . put (  \"  2  \"  ,     \"  3  7  \"  )  ;", "assertTrue ( conversionService . canConvert ( Map . class ,    Map . class )  )  ;", "assertSame ( map ,    conversionServic ( map ,    Map . class )  )  ;", "}", "METHOD_END"], "methodName": ["scalarMapNotGenericTarget"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverter ( new   MapToMapConverter ( conversionService )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "conversionService . addConverterFactory ( new   StringToEnumConverterFactory (  )  )  ;", "Map < String ,    Integer >    source    =    new   HashMap <  >  (  )  ;", "source . put (  \" A \"  ,     1  )  ;", "source . put (  \" C \"  ,     2  )  ;", "EnumMap <  . MyEnum ,    Integer >    result    =    new   EnumMap <  >  (  . MyEnum . class )  ;", "result . put (  . MyEnum . A ,     1  )  ;", "result . put (  . MyEnum . C ,     2  )  ;", "assertEquals ( result ,    conversionService . convert ( source ,    TypeDescriptor . forObject ( source )  ,    new   TypeDescriptor ( getClass (  )  . getField (  \" enumMap \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringToEnumMap"], "fileName": "org.springframework.core.convert.support.MapToMapConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getConstructorIfAvailable ( targetClass ,    sourceClass )  ;", "}", "METHOD_END"], "methodName": ["determineFactoryConstructor"], "fileName": "org.springframework.core.convert.support.ObjectToObjectConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( String . class )     =  =    targetClass )     {", "return   null ;", "}", "Method   method    =    ClassUtils . getStaticMethod ( targetClass ,     \" valueOf \"  ,    sourceClass )  ;", "if    ( method    =  =    null )     {", "method    =    ClassUtils . getStaticMethod ( targetClass ,     \" of \"  ,    sourceClass )  ;", "if    ( method    =  =    null )     {", "method    =    ClassUtils . getStaticMethod ( targetClass ,     \" from \"  ,    sourceClass )  ;", "}", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["determineFactoryMethod"], "fileName": "org.springframework.core.convert.support.ObjectToObjectConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( String . class )     =  =    targetClass )     |  |     (  ( String . class )     =  =    sourceClass )  )     {", "return   null ;", "}", "Method   method    =    ClassUtils . getMethodIfAvailable ( sourceClass ,     (  \" to \"     +     ( targetClass . getSimpleName (  )  )  )  )  ;", "return    (  ( method    !  =    null )     &  &     (  !  ( Modifier . isStatic ( method . getModifiers (  )  )  )  )  )     &  &     ( ClassUtils . isAssignable ( targetClass ,    method . getReturnType (  )  )  )     ?    method    :    null ;", "}", "METHOD_END"], "methodName": ["determineToMethod"], "fileName": "org.springframework.core.convert.support.ObjectToObjectConverter"}, {"methodBody": ["METHOD_START", "{", "Member   member    =    ObjectToObjectConverter . conversionMemberCache . get ( targetClass )  ;", "if    ( ObjectToObjectConverter . isApplicable ( member ,    sourceClass )  )     {", "return   member ;", "}", "member    =    ObjectToObjectConverter . determineToMethod ( targetClass ,    sourceClass )  ;", "if    ( member    =  =    null )     {", "member    =    ObjectToObjectConverter . determineFactoryMethod ( targetClass ,    sourceClass )  ;", "if    ( member    =  =    null )     {", "member    =    ObjectToObjectConverter . determineFactoryConstructor ( targetClass ,    sourceClass )  ;", "if    ( member    =  =    null )     {", "return   null ;", "}", "}", "}", "ObjectToObjectConverter . conversionMemberCache . put ( targetClass ,    member )  ;", "return   member ;", "}", "METHOD_END"], "methodName": ["getValidatedMember"], "fileName": "org.springframework.core.convert.support.ObjectToObjectConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( ObjectToObjectConverter . getValidatedMember ( targetClass ,    sourceClass )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasConversionMethodOrConstructor"], "fileName": "org.springframework.core.convert.support.ObjectToObjectConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( member   instanceof   Method )     {", "Method   method    =     (  ( Method )     ( member )  )  ;", "return    !  ( Modifier . isStatic ( method . getModifiers (  )  )  )     ?    ClassUtils . isAssignable ( method . getDeclaClass (  )  ,    sourceClass )     :     ( method . getParameterTypes (  )  [  0  ]  )     =  =    sourceClass ;", "} else", "if    ( member   instanceof   Constructor )     {", "Constructor <  ?  >    ctor    =     (  ( Constructor <  ?  >  )     ( member )  )  ;", "return    ( ctor . getParameterTypes (  )  [  0  ]  )     =  =    sourceClass ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isApplicable"], "fileName": "org.springframework.core.convert.support.ObjectToObjectConverter"}, {"methodBody": ["METHOD_START", "{", "CompletableFuture < Integer >    future    =    new   CompletableFuture <  >  (  )  ;", "future . complete (  1  )  ;", "Object   target    =    get ( CompletableFuture . class )  . toPublisher ( future )  ;", "Assert . assertTrue (  (  \" Expected   Mono   Publisher :     \"     +     ( target . getClass (  )  . getName (  )  )  )  ,     ( target   instanceof   Mono )  )  ;", "Assert . assertEquals ( Integer . valueOf (  1  )  ,     (  ( Mono < Integer >  )     ( target )  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["CompletableFutureToPublisher"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertNotNull ( getAdapter ( Mono . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Flux . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Publisher . class )  )  ;", "Assert . assertNotNull ( getAdapter ( CompletableFuture . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Observable . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Single . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Completable . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Flowable . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Observable . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Single . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Maybe . class )  )  ;", "Assert . assertNotNull ( getAdapter ( Completable . class )  )  ;", "}", "METHOD_END"], "methodName": ["defaultAdapterRegistrations"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "return   this . registry . getAdapter ( reactiveType )  ;", "}", "METHOD_END"], "methodName": ["getAdapter"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "ReactiveAdapter   adapter 1     =    getAdapter ( Flux . class )  ;", "ReactiveAdapter   adapter 2     =    getAdapter ( FluxProcessor . class )  ;", "Assert . assertSame ( adapter 1  ,    adapter 2  )  ;", "this . registry . registerReactiveType ( ReactiveTypeDescriptor . multiValue ( FluxProcessor . class ,    FluxProcessor :  : empty )  ,     (    o )     -  >     (  ( FluxProcessor <  ?  ,     ?  >  )     ( o )  )  ,    FluxProcessor :  : from )  ;", "ReactiveAdapter   adapter 3     =    getAdapter ( FluxProcessor . class )  ;", "Assert . assertNotNull ( adapter 3  )  ;", "Assert . assertNotSame ( adapter 1  ,    adapter 3  )  ;", "}", "METHOD_END"], "methodName": ["getAdapterForReactiveSubType"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Publisher < Integer >    source    =    Flowable . fromArray (  1  ,     2  ,     3  )  ;", "Object   target    =    get ( CompletableFuture . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   CompletableFuture )  )  ;", "Assert . assertEquals ( Integer . valueOf (  1  )  ,     (  ( CompletableFuture < Integer >  )     ( target )  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToCompletableFuture"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    sequence    =    Arrays . asList (  1  ,     2  ,     3  )  ;", "Publisher < Integer >    source    =    Flowable . fromIterable ( sequence )  ;", "Object   target    =    get ( Flux . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   Flux )  )  ;", "Assert . assertEquals ( sequence ,     (  ( Flux < Integer >  )     ( target )  )  . collectList (  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToFlux"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Publisher < Integer >    source    =    Flowable . fromArray (  1  ,     2  ,     3  )  ;", "Object   target    =    get ( Mono . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   Mono )  )  ;", "Assert . assertEquals ( Integer . valueOf (  1  )  ,     (  ( Mono < Integer >  )     ( target )  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToMono"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Publisher < Integer >    source    =    Flowable . fromArray (  1  ,     2  ,     3  )  ;", "Object   target    =    get ( Completable . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   io . reactivex . Completable )  )  ;", "Assert . assertNull (  (  ( io . reactivex . Completable )     ( target )  )  . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToReactivexCompletable"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    sequence    =    Arrays . asList (  1  ,     2  ,     3  )  ;", "Publisher < Integer >    source    =    Flux . fromIterable ( sequence )  ;", "Object   target    =    get ( Flowable . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   Flowable )  )  ;", "Assert . assertEquals ( sequence ,     (  ( Flowable <  ?  >  )     ( target )  )  . toList (  )  . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToReactivexFlowable"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    sequence    =    Arrays . asList (  1  ,     2  ,     3  )  ;", "Publisher < Integer >    source    =    Flowable . fromIterable ( sequence )  ;", "Object   target    =    get ( Observable . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   io . reactivex . Observable )  )  ;", "Assert . assertEquals ( sequence ,     (  ( io . reactivex . Observable <  ?  >  )     ( target )  )  . toList (  )  . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToReactivexObservable"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Publisher < Integer >    source    =    Flowable . fromArray (  1  )  ;", "Object   target    =    get ( Single . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   io . reactivex . Single )  )  ;", "Assert . assertEquals ( Integer . valueOf (  1  )  ,     (  ( io . reactivex . Single < Integer >  )     ( target )  )  . blockingGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToReactivexSingle"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Publisher < Integer >    source    =    Flowable . fromArray (  1  ,     2  ,     3  )  ;", "Object   target    =    get ( Completable . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   Completable )  )  ;", "Assert . assertNull (  (  ( Completable )     ( target )  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToRxCompletable"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    sequence    =    Arrays . asList (  1  ,     2  ,     3  )  ;", "Publisher < Integer >    source    =    Flowable . fromIterable ( sequence )  ;", "Object   target    =    get ( Observable . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   Observable )  )  ;", "Assert . assertEquals ( sequence ,     (  ( Observable <  ?  >  )     ( target )  )  . toList (  )  . toBlocking (  )  . first (  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToRxObservable"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Publisher < Integer >    source    =    Flowable . fromArray (  1  )  ;", "Object   target    =    get ( Single . class )  . fromPublisher ( source )  ;", "Assert . assertTrue (  ( target   instanceof   Single )  )  ;", "Assert . assertEquals ( Integer . valueOf (  1  )  ,     (  ( Single < Integer >  )     ( target )  )  . toBlocking (  )  . value (  )  )  ;", "}", "METHOD_END"], "methodName": ["publisherToRxSingle"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Object   source    =    Completable . complete (  )  ;", "Object   target    =    get ( rx . Completable . class )  . toPublisher ( source )  ;", "Assert . assertTrue (  (  \" Expected   Mono   Publisher :     \"     +     ( target . getClass (  )  . getName (  )  )  )  ,     ( target   instanceof   Mono )  )  ;", "(  ( Mono < Void >  )     ( target )  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["reactivexCompletableToPublisher"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    sequence    =    Arrays . asList (  1  ,     2  ,     3  )  ;", "Object   source    =    Flowable . fromIterable ( sequence )  ;", "Object   target    =    get ( Flowable . class )  . toPublisher ( source )  ;", "Assert . assertTrue (  (  \" Expected   Flux   Publisher :     \"     +     ( target . getClass (  )  . getName (  )  )  )  ,     ( target   instanceof   Flux )  )  ;", "Assert . assertEquals ( sequence ,     (  ( Flux < Integer >  )     ( target )  )  . collectList (  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["reactivexFlowableToPublisher"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    sequence    =    Arrays . asList (  1  ,     2  ,     3  )  ;", "Object   source    =    Observable . fromIterable ( sequence )  ;", "Object   target    =    get ( rx . Observable . class )  . toPublisher ( source )  ;", "Assert . assertTrue (  (  \" Expected   Flux   Publisher :     \"     +     ( target . getClass (  )  . getName (  )  )  )  ,     ( target   instanceof   Flux )  )  ;", "Assert . assertEquals ( sequence ,     (  ( Flux < Integer >  )     ( target )  )  . collectList (  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["reactivexObservableToPublisher"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Object   source    =    Single . just (  1  )  ;", "Object   target    =    get ( rx . Single . class )  . toPublisher ( source )  ;", "Assert . assertTrue (  (  \" Expected   Mono   Publisher :     \"     +     ( target . getClass (  )  . getName (  )  )  )  ,     ( target   instanceof   Mono )  )  ;", "Assert . assertEquals ( Integer . valueOf (  1  )  ,     (  ( Mono < Integer >  )     ( target )  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["reactivexSingleToPublisher"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Object   source    =    Completable . complete (  )  ;", "Object   target    =    get ( Completable . class )  . toPublisher ( source )  ;", "Assert . assertTrue (  (  \" Expected   Mono   Publisher :     \"     +     ( target . getClass (  )  . getName (  )  )  )  ,     ( target   instanceof   Mono )  )  ;", "(  ( Mono < Void >  )     ( target )  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["rxCompletableToPublisher"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    sequence    =    Arrays . asList (  1  ,     2  ,     3  )  ;", "Object   source    =    Observable . from ( sequence )  ;", "Object   target    =    get ( Observable . class )  . toPublisher ( source )  ;", "Assert . assertTrue (  (  \" Expected   Flux   Publisher :     \"     +     ( target . getClass (  )  . getName (  )  )  )  ,     ( target   instanceof   Flux )  )  ;", "Assert . assertEquals ( sequence ,     (  ( Flux < Integer >  )     ( target )  )  . collectList (  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["rxObservableToPublisher"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Object   source    =    Single . just (  1  )  ;", "Object   target    =    get ( Single . class )  . toPublisher ( source )  ;", "Assert . assertTrue (  (  \" Expected   Mono   Publisher :     \"     +     ( target . getClass (  )  . getName (  )  )  )  ,     ( target   instanceof   Mono )  )  ;", "Assert . assertEquals ( Integer . valueOf (  1  )  ,     (  ( Mono < Integer >  )     ( target )  )  . block ( Duration . ofMillis (  1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["rxSingleToPublisher"], "fileName": "org.springframework.core.convert.support.ReactiveAdapterRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < Object >    content    =     ( source    !  =    null )     ?    source . collect ( Collectors .  < Object > toList (  )  )     :    Collections . emptyList (  )  ;", "TypeDescriptor   listType    =    TypeDescriptor . collection ( List . class ,    streamType . getElementTypeDescriptor (  )  )  ;", "return   this . conversionServic ( content ,    listType ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["convertFromStream"], "fileName": "org.springframework.core.convert.support.StreamConverter"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   targetCollection    =    TypeDescriptor . collection ( List . class ,    streamType . getElementTypeDescriptor (  )  )  ;", "List <  ?  >    target    =     (  ( List <  ?  >  )     ( this . conversionServic ( source ,    sourceType ,    targetCollection )  )  )  ;", "if    ( target    =  =    null )     {", "target    =    Collections . emptyList (  )  ;", "}", "return   target . stream (  )  ;", "}", "METHOD_END"], "methodName": ["convertToStream"], "fileName": "org.springframework.core.convert.support.StreamConverter"}, {"methodBody": ["METHOD_START", "{", "Set < GenericConverter . ConvertiblePair >    convertiblePairs    =    new   HashSet <  >  (  )  ;", "convertiblePairs . add ( new   GenericConverter . ConvertiblePair ( Stream . class ,    Collection . class )  )  ;", "convertiblePairs . add ( new   GenericConverter . ConvertiblePair ( Stream . class ,    Object [  ]  . class )  )  ;", "convertiblePairs . add ( new   GenericConverter . ConvertiblePair ( Collection . class ,    Stream . class )  )  ;", "convertiblePairs . add ( new   GenericConverter . ConvertiblePair ( Object [  ]  . class ,    Stream . class )  )  ;", "return   convertiblePairs ;", "}", "METHOD_END"], "methodName": ["createConvertibleTypes"], "fileName": "org.springframework.core.convert.support.StreamConverter"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   collectionOfElement    =    TypeDescriptor . collection ( Collection . class ,    elementType )  ;", "return   thissionService . canConvert ( collectionOfElement ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["matchesFromStream"], "fileName": "org.springframework.core.convert.support.StreamConverter"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   collectionOfElement    =    TypeDescriptor . collection ( Collection . class ,    elementType )  ;", "return   thissionService . canConvert ( sourceType ,    collectionOfElement )  ;", "}", "METHOD_END"], "methodName": ["matchesToStream"], "fileName": "org.springframework.core.convert.support.StreamConverter"}, {"methodBody": ["METHOD_START", "{", "Integer [  ]    stream    =    new   Integer [  ]  {     1  ,     0  ,     1     }  ;", "this . conversionService . addConverter ( new   Converter < Integer ,    Boolean >  (  )     {", "@ Override", "public   Boolean   convert ( Integer   source )     {", "return   source    =  =     1  ;", "}", "}  )  ;", "TypeDescriptor   streamOfBoolean    =    new   TypeDescriptor (  . Types . class . getField (  \" streamOfBooleans \"  )  )  ;", "Object   result    =    this . conversionService . convert ( stream ,    streamOfBoolean )  ;", "assertNotNull (  \" Converted   object   must   not   be   null \"  ,    result )  ;", "assertTrue (  \" Converted   object   must   be   a   stream \"  ,     ( result   instanceof   Stream )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Stream < Boolean >    content    =     (  ( Stream < Boolean >  )     ( result )  )  ;", "assertEquals (  2  ,    content . filter (  (    x )     -  >    x )  . count (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertFromArrayToStream"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    stream    =    Arrays . asList (  \"  1  \"  ,     \"  2  \"  ,     \"  3  \"  )  ;", "TypeDescriptor   streamOfInteger    =    new   TypeDescriptor (  . Types . class . getField (  \" rawStream \"  )  )  ;", "Object   result    =    this . conversionService . convert ( stream ,    streamOfInteger )  ;", "assertNotNull (  \" Converted   object   must   not   be   null \"  ,    result )  ;", "assertTrue (  \" Converted   object   must   be   a   stream \"  ,     ( result   instanceof   Stream )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Stream < Object >    content    =     (  ( Stream < Object >  )     ( result )  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "content . forEach ( sb :  : append )  ;", "assertEquals (  \"  1  2  3  \"  ,    sb . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertFromListToRawStream"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . conversionService . addConverterFactory ( new   StringToNumberConverterFactory (  )  )  ;", "List < String >    stream    =    Arrays . asList (  \"  1  \"  ,     \"  2  \"  ,     \"  3  \"  )  ;", "TypeDescriptor   streamOfInteger    =    new   TypeDescriptor (  . Types . class . getField (  \" streamOfIntegers \"  )  )  ;", "Object   result    =    this . conversionService . convert ( stream ,    streamOfInteger )  ;", "assertNotNull (  \" Converted   object   must   not   be   null \"  ,    result )  ;", "assertTrue (  \" Converted   object   must   be   a   stream \"  ,     ( result   instanceof   Stream )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Stream < Integer >    content    =     (  ( Stream < Integer >  )     ( result )  )  ;", "assertEquals (  6  ,    content . mapToInt (  (    x )     -  >    x )  . sum (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertFromListToStream"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . conversionService . addConverterFactory ( new   NumberToNumberConverterFactory (  )  )  ;", "Stream < Integer >    stream    =    Arrays . asList (  1  ,     2  ,     3  )  . stream (  )  ;", "TypeDescriptor   arrayOfLongs    =    new   TypeDescriptor (  . Types . class . getField (  \" arrayOfLongs \"  )  )  ;", "Object   result    =    this . conversionService . convert ( stream ,    arrayOfLongs )  ;", "assertNotNull (  \" Converted   object   must   not   be   null \"  ,    result )  ;", "assertTrue (  \" Converted   object   must   be   an   array \"  ,    result . getClass (  )  . isArray (  )  )  ;", "Long [  ]    content    =     (  ( Long [  ]  )     ( result )  )  ;", "assertEquals ( Long . valueOf (  1 L )  ,    content [  0  ]  )  ;", "assertEquals ( Long . valueOf (  2 L )  ,    content [  1  ]  )  ;", "assertEquals ( Long . valueOf (  3 L )  ,    content [  2  ]  )  ;", "assertEquals (  \" Wrong   number   of   elements \"  ,     3  ,    content . length )  ;", "}", "METHOD_END"], "methodName": ["convertFromStreamToArray"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "Stream < Integer >    stream    =    Arrays . asList (  1  ,     2  ,     3  )  . stream (  )  ;", "TypeDescriptor   arrayOfLongs    =    new   TypeDescriptor (  . Types . class . getField (  \" arrayOfLongs \"  )  )  ;", "thrown . expect ( ConversionFailedException . class )  ;", "thrown . expectCause ( is ( instanceOf ( ConverterNotFoundException . class )  )  )  ;", "this . conversionService . convert ( stream ,    arrayOfLongs )  ;", "}", "METHOD_END"], "methodName": ["convertFromStreamToArrayNoConverter"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . conversionService . addConverter ( Number . class ,    String . class ,    new   ObjectToStringConverter (  )  )  ;", "Stream < Integer >    stream    =    Arrays . asList (  1  ,     2  ,     3  )  . stream (  )  ;", "TypeDescriptor   listOfStrings    =    new   TypeDescriptor (  . Types . class . getField (  \" listOfStrings \"  )  )  ;", "Object   result    =    this . conversionService . convert ( stream ,    listOfStrings )  ;", "assertNotNull (  \" Converted   object   must   not   be   null \"  ,    result )  ;", "assertTrue (  \" Converted   object   must   be   a   list \"  ,     ( result   instanceof   List )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < String >    content    =     (  ( List < String >  )     ( result )  )  ;", "assertEquals (  \"  1  \"  ,    content . get (  0  )  )  ;", "assertEquals (  \"  2  \"  ,    content . get (  1  )  )  ;", "assertEquals (  \"  3  \"  ,    content . get (  2  )  )  ;", "assertEquals (  \" Wrong   number   of   elements \"  ,     3  ,    content . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertFromStreamToList"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "Stream < Integer >    stream    =    Arrays . asList (  1  ,     2  ,     3  )  . stream (  )  ;", "TypeDescriptor   listOfStrings    =    new   TypeDescriptor (  . Types . class . getField (  \" rawList \"  )  )  ;", "Object   result    =    this . conversionService . convert ( stream ,    listOfStrings )  ;", "assertNotNull (  \" Converted   object   must   not   be   null \"  ,    result )  ;", "assertTrue (  \" Converted   object   must   be   a   list \"  ,     ( result   instanceof   List )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < Object >    content    =     (  ( List < Object >  )     ( result )  )  ;", "assertEquals (  1  ,    content . get (  0  )  )  ;", "assertEquals (  2  ,    content . get (  1  )  )  ;", "assertEquals (  3  ,    content . get (  2  )  )  ;", "assertEquals (  \" Wrong   number   of   elements \"  ,     3  ,    content . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertFromStreamToRawList"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" Should   not   match   non   stream   type \"  ,    this . streamConverter . matches ( new   TypeDescriptor ( StreamConverterTests . Types . class . getField (  \" listOfStrings \"  )  )  ,    new   TypeDescriptor ( StreamConverterTests . Types . class . getField (  \" arrayOfLongs \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotMatchIfNoStream"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . conversionService . addConverter ( new   CollectionToCollectionConverter ( this . conversionService )  )  ;", "this . conversionService . addConverter ( new   ArrayToCollectionConverter ( this . conversionService )  )  ;", "this . conversionService . addConverter ( new   CollectionToArrayConverter ( this . conversionService )  )  ;", "this . conversionService . addConverter ( this . s )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalStateException . class )  ;", "this . streamConverter . convert ( new   Object (  )  ,    new   TypeDescriptor (  . Types . class . getField (  \" listOfStrings \"  )  )  ,    new   TypeDescriptor (  . Types . class . getField (  \" arrayOfLongs \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldFailToConvertIfNoStream"], "fileName": "org.springframework.core.convert.support.StreamConverterTests"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . activeProfiles )     {", "if    ( this . activeProfiles . isEmpty (  )  )     {", "String   profiles    =    getProperty (  . ACTIVE _ PROFILES _ PROPERTY _ NAME )  ;", "if    ( StringUtils . hasText ( profiles )  )     {", "setActiveProfiles ( StringUtils . commaDelimitedListToStringArray ( StringUtils . trimAllWhitespace ( profiles )  )  )  ;", "}", "}", "return   this . activeProfiles ;", "}", "}", "METHOD_END"], "methodName": ["doGetActiveProfiles"], "fileName": "org.springframework.core.env.AbstractEnvironment"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . defaultProfiles )     {", "if    ( this . defaultProfiles . equals ( getReservedDefaultProfiles (  )  )  )     {", "String   profiles    =    getProperty (  . DEFAULT _ PROFILES _ PROPERTY _ NAME )  ;", "if    ( StringUtils . hasText ( profiles )  )     {", "setDefaultProfiles ( StringUtils . commaDelimitedListToStringArray ( StringUtils . trimAllWhitespace ( profiles )  )  )  ;", "}", "}", "return   this . defaultProfiles ;", "}", "}", "METHOD_END"], "methodName": ["doGetDefaultProfiles"], "fileName": "org.springframework.core.env.AbstractEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   Collections . singleton ( AbstractEnvironment . RESERVED _ DEFAULT _ PROFILE _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getReservedDefaultProfiles"], "fileName": "org.springframework.core.env.AbstractEnvironment"}, {"methodBody": ["METHOD_START", "{", "validateProfile ( profile )  ;", "Set < St >    currentActiveProfiles    =    doGetActiveProfiles (  )  ;", "return    ( currentActiveProfiles . contains ( profile )  )     |  |     (  ( currentActiveProfiles . isEmpty (  )  )     &  &     ( doGetDefaultProfiles (  )  . contains ( profile )  )  )  ;", "}", "METHOD_END"], "methodName": ["isProfileActive"], "fileName": "org.springframework.core.env.AbstractEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   SpringProperties . getFlag ( AbstractEnvironment . IGNORE _ GETENV _ PROPERTY _ NAME )  ;", "}", "METHOD_END"], "methodName": ["suppressGetenvAccess"], "fileName": "org.springframework.core.env.AbstractEnvironment"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasText ( profile )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   profile    [  \"     +    profile )     +     \"  ]  :    must   contain   text \"  )  )  ;", "}", "if    (  ( profile . charAt (  0  )  )     =  =     '  !  '  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   profile    [  \"     +    profile )     +     \"  ]  :    must   not   begin   with    !    operator \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateProfile"], "fileName": "org.springframework.core.env.AbstractEnvironment"}, {"methodBody": ["METHOD_START", "{", "if    ( targetType    =  =    null )     {", "return    (  ( T )     ( value )  )  ;", "}", "ConversionServicenversionServiceToUse    =    thisnversionService ;", "if   nversionServiceToUse    =  =    null )     {", "if    ( ClassUtils . isAssignableValue ( targetType ,    value )  )     {", "return    (  ( T )     ( value )  )  ;", "}", "nversionServiceToUse    =    DefaultConversionService . getSharedInstance (  )  ;", "}", "returnnversionServiceToUsenvert ( value ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["convertValueIfNecessary"], "fileName": "org.springframework.core.env.AbstractPropertyResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   PropertyPlaceholderHelper ( this . placeholderPrefix ,    this . placeholderSuffix ,    this . valueSeparator ,    ignoreUnresolvablePlaceholders )  ;", "}", "METHOD_END"], "methodName": ["createPlaceholderHelper"], "fileName": "org.springframework.core.env.AbstractPropertyResolver"}, {"methodBody": ["METHOD_START", "{", "return   helper . replacePlaceholders ( text ,    this :  : getPropertyAsRawString )  ;", "}", "METHOD_END"], "methodName": ["doResolvePlaceholders"], "fileName": "org.springframework.core.env.AbstractPropertyResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . ignoreUnresolvableNestedPlaceholders    ?    resolvePlaceholders ( value )     :    resolveRequiredPlaceholders ( value )  ;", "}", "METHOD_END"], "methodName": ["resolveNestedPlaceholders"], "fileName": "org.springframework.core.env.AbstractPropertyResolver"}, {"methodBody": ["METHOD_START", "{", "this . nonOptionArgs . add ( value )  ;", "}", "METHOD_END"], "methodName": ["addNonOptionArg"], "fileName": "org.springframework.core.env.CommandLineArgs"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . optionArgs . containsKey ( optionName )  )  )     {", "this . optionArgs . put ( optionName ,    new   ArrayList <  >  (  )  )  ;", "}", "if    ( optionValue    !  =    null )     {", "this . optionArgs . get ( optionName )  . add ( optionValue )  ;", "}", "}", "METHOD_END"], "methodName": ["addOptionArg"], "fileName": "org.springframework.core.env.CommandLineArgs"}, {"methodBody": ["METHOD_START", "{", "return   this . optionArgs . containsKey ( optionName )  ;", "}", "METHOD_END"], "methodName": ["containsOption"], "fileName": "org.springframework.core.env.CommandLineArgs"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . nonOptionArgs )  ;", "}", "METHOD_END"], "methodName": ["getNonOptionArgs"], "fileName": "org.springframework.core.env.CommandLineArgs"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . optionArgs . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getOptionNames"], "fileName": "org.springframework.core.env.CommandLineArgs"}, {"methodBody": ["METHOD_START", "{", "return   this . optionArgs . get ( optionName )  ;", "}", "METHOD_END"], "methodName": ["getOptionValues"], "fileName": "org.springframework.core.env.CommandLineArgs"}, {"methodBody": ["METHOD_START", "{", "this . nonOptionArgsPropertyName    =    nonOptionArgsPropertyName ;", "}", "METHOD_END"], "methodName": ["setNonOptionArgsPropertyName"], "fileName": "org.springframework.core.env.CommandLinePropertySource"}, {"methodBody": ["METHOD_START", "{", "List < PropertySource <  ?  >  >    existing    =    new   ArrayList <  >  ( this . propertySources )  ;", "this . propertySources . clear (  )  ;", "this . propertySources . add ( propertySource )  ;", "this . propertySources . addAll ( existing )  ;", "}", "METHOD_END"], "methodName": ["addFirstPropertySource"], "fileName": "org.springframework.core.env.CompositePropertySource"}, {"methodBody": ["METHOD_START", "{", "this . propertySources . add ( propertySource )  ;", "}", "METHOD_END"], "methodName": ["addPropertySource"], "fileName": "org.springframework.core.env.CompositePropertySource"}, {"methodBody": ["METHOD_START", "{", "return   this . propertySources ;", "}", "METHOD_END"], "methodName": ["getPropertySources"], "fileName": "org.springframework.core.env.CompositePropertySource"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    p 1     =    new   MapPropertySource (  \" p 1  \"  ,    Collections . emptyMap (  )  )  ;", "PropertySource <  ?  >    p 2     =    new   MapPropertySource (  \" p 2  \"  ,    Collections . emptyMap (  )  )  ;", "PropertySource <  ?  >    p 3     =    new   MapPropertySource (  \" p 3  \"  ,    Collections . emptyMap (  )  )  ;", "composite    =    new    (  \" c \"  )  ;", "composite . addPropertySource ( p 2  )  ;", "composite . addPropertySource ( p 3  )  ;", "composite . addPropertySource ( p 1  )  ;", "composite . addFirstPropertySource ( p 1  )  ;", "String   s    =    composite . toString (  )  ;", "int   i 1     =    s . indexOf (  \" name =  ' p 1  '  \"  )  ;", "int   i 2     =    s . indexOf (  \" name =  ' p 2  '  \"  )  ;", "int   i 3     =    s . indexOf (  \" name =  ' p 3  '  \"  )  ;", "assertTrue (  (  \" Bad   order :     \"     +    s )  ,     (  ( i 1     <    i 2  )     &  &     ( i 2     <    i 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addFirst"], "fileName": "org.springframework.core.env.CompositePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "Environment   env    =    new   AbstractEnvironment (  )     {  }  ;", "assertThat ( env . acceptsProfiles ( AbstractEnvironment . RESERVED _ DEFAULT _ PROFILE _ NAME )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["control"], "fileName": "org.springframework.core.env.CustomEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "class   CustomEnvironment   extends   AbstractEnvironment    {", "@ Override", "@ SuppressWarnings (  \" serial \"  )", "protected   Set < String >    getReservedDefaultProfiles (  )     {", "return   new   HashSet < String >  (  )     {", "{", "add (  \" rd 1  \"  )  ;", "add (  \" rd 2  \"  )  ;", "}", "}  ;", "}", "}", "ConfigurableEnvironment   env    =    new   CustomEnvironment (  )  ;", "assertThat ( env . acceptsProfiles ( AbstractEnvironment . RESERVED _ DEFAULT _ PROFILE _ NAME )  ,    is ( false )  )  ;", "assertThat ( env . acceptsProfiles (  \" rd 1  \"  ,     \" rd 2  \"  )  ,    is ( true )  )  ;", "env . setDefaultProfiles (  \" d 1  \"  )  ;", "assertThat ( env . acceptsProfiles (  \" rd 1  \"  ,     \" rd 2  \"  )  ,    is ( false )  )  ;", "assertThat ( env . acceptsProfiles (  \" d 1  \"  )  ,    is ( true )  )  ;", "env . setActiveProfiles (  \" a 1  \"  ,     \" a 2  \"  )  ;", "assertThat ( env . acceptsProfiles (  \" d 1  \"  )  ,    is ( false )  )  ;", "assertThat ( env . acceptsProfiles (  \" a 1  \"  ,     \" a 2  \"  )  ,    is ( true )  )  ;", "env . setActiveProfiles (  )  ;", "assertThat ( env . acceptsProfiles (  \" d 1  \"  )  ,    is ( true )  )  ;", "assertThat ( env . acceptsProfiles (  \" a 1  \"  ,     \" a 2  \"  )  ,    is ( false )  )  ;", "env . setDefaultProfiles (  )  ;", "assertThat ( env . acceptsProfiles ( AbstractEnvironment . RESERVED _ DEFAULT _ PROFILE _ NAME )  ,    is ( false )  )  ;", "assertThat ( env . acceptsProfiles (  \" rd 1  \"  ,     \" rd 2  \"  )  ,    is ( false )  )  ;", "assertThat ( env . acceptsProfiles (  \" d 1  \"  )  ,    is ( false )  )  ;", "assertThat ( env . acceptsProfiles (  \" a 1  \"  ,     \" a 2  \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["withMultiCustomReservedDefaultProfile"], "fileName": "org.springframework.core.env.CustomEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "class   CustomEnvironment   extends   AbstractEnvironment    {", "@ Override", "protected   Set < String >    getReservedDefaultProfiles (  )     {", "return   Collections . emptySet (  )  ;", "}", "}", "Environment   env    =    new   CustomEnvironment (  )  ;", "assertThat ( env . acceptsProfiles ( AbstractEnvironment . RESERVED _ DEFAULT _ PROFILE _ NAME )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["withNoReservedDefaultProfile"], "fileName": "org.springframework.core.env.CustomEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "class   CustomEnvironment   extends   AbstractEnvironment    {", "@ Override", "protected   Set < String >    getReservedDefaultProfiles (  )     {", "return   Collections . singleton (  \" rd 1  \"  )  ;", "}", "}", "Environment   env    =    new   CustomEnvironment (  )  ;", "assertThat ( env . acceptsProfiles ( AbstractEnvironment . RESERVED _ DEFAULT _ PROFILE _ NAME )  ,    is ( false )  )  ;", "assertThat ( env . acceptsProfiles (  \" rd 1  \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["withSingleCustomReservedDefaultProfile"], "fileName": "org.springframework.core.env.CustomEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" o 1  \"  )  . withRequiredArg (  )  ;", "parser . accepts (  \" o 2  \"  )  ;", "OptionSet   optionSet    =    parser . parse (  \"  -  - o 1  = v 1  \"  ,     \" noa 1  \"  ,     \"  -  - o 2  \"  ,     \" noa 2  \"  )  ;", "CommandLinePropertySource <  ?  >    ps    =    new    ( optionSet )  ;", "ps . setNonOptionArgsPropertyName (  \" NOA \"  )  ;", "assertThat ( ps . containsProperty (  \" nonOptionArgs \"  )  ,    is ( false )  )  ;", "assertThat ( ps . containsProperty (  \" NOA \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 2  \"  )  ,    is ( true )  )  ;", "String   nonOptionArgs    =    ps . getProperty (  \" NOA \"  )  ;", "assertThat ( nonOptionArgs ,    equalTo (  \" noa 1  , noa 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withCustomNonOptionArgsNameAndNoNonOptionArgsPresent"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . acceptsAll ( Arrays . asList (  \" o 1  \"  ,     \" option 1  \"  )  )  . withRequiredArg (  )  ;", "parser . accepts (  \" o 2  \"  )  ;", "OptionSet   optionSet    =    parser . parse (  \"  -  - o 1  = v 1  \"  ,     \"  -  - o 2  \"  )  ;", "EnumerablePropertySource <  ?  >    ps    =    new    ( optionSet )  ;", "assertThat ( ps . containsProperty (  \" nonOptionArgs \"  )  ,    is ( false )  )  ;", "assertThat ( ps . containsProperty (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" nonOptionArgs \"  )  ,    is ( false )  )  ;", "assertThat ( ps . getProperty (  \" nonOptionArgs \"  )  ,    nullValue (  )  )  ;", "assertThat ( ps . getPropertyNames (  )  . length ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaultNonOptionArgsNameAndNoNonOptionArgsPresent"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" o 1  \"  )  . withRequiredArg (  )  ;", "parser . accepts (  \" o 2  \"  )  ;", "OptionSet   optionSet    =    parser . parse (  \"  -  - o 1  = v 1  \"  ,     \" noa 1  \"  ,     \"  -  - o 2  \"  ,     \" noa 2  \"  )  ;", "PropertySource <  ?  >    ps    =    new    ( optionSet )  ;", "assertThat ( ps . containsProperty (  \" nonOptionArgs \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 2  \"  )  ,    is ( true )  )  ;", "String   nonOptionArgs    =     (  ( String )     ( ps . getProperty (  \" nonOptionArgs \"  )  )  )  ;", "assertThat ( nonOptionArgs ,    equalTo (  \" noa 1  , noa 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaultNonOptionArgsNameAndNonOptionArgsPresent"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" spring . profiles . active \"  )  . withRequiredArg (  )  ;", "OptionSet   options    =    parser . parse (  \"  -  - spring . profiles . active = p 1  \"  )  ;", "CommandLinePropertySource <  ?  >    ps    =    new    ( options )  ;", "assertThat ( ps . getProperty (  \" spring . profiles . active \"  )  ,    equalTo (  \" p 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withDottedOptionName"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" foo \"  )  . withRequiredArg (  )  . withValuesSeparatedBy (  '  ,  '  )  ;", "OptionSet   options    =    parser . parse (  )  ;", "PropertySource <  ?  >    ps    =    new    ( options )  ;", "assertThat ( ps . getProperty (  \" foo \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withMissingOption"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" o 1  \"  )  ;", "parser . accepts (  \" o 2  \"  )  ;", "OptionSet   options    =    parser . parse (  \"  -  - o 1  \"  )  ;", "PropertySource <  ?  >    ps    =    new    ( options )  ;", "assertThat ( ps . containsProperty (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 2  \"  )  ,    is ( false )  )  ;", "assertThat (  (  ( String )     ( ps . getProperty (  \" o 1  \"  )  )  )  ,    equalTo (  \"  \"  )  )  ;", "assertThat ( ps . getProperty (  \" o 2  \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withNoArg"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" foo \"  )  . withOptionalArg (  )  ;", "OptionSet   options    =    parser . parse (  \"  -  - foo \"  )  ;", "PropertySource <  ?  >    ps    =    new    ( options )  ;", "assertThat ( ps . containsProperty (  \" foo \"  )  ,    is ( true )  )  ;", "assertThat (  (  ( String )     ( ps . getProperty (  \" foo \"  )  )  )  ,    equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withOptionalArg_andArgIsMissing"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" foo \"  )  . withRequiredArg (  )  ;", "OptionSet   options    =    parser . parse (  \"  -  - foo = bar \"  )  ;", "PropertySource <  ?  >    ps    =    new    ( options )  ;", "assertThat (  (  ( String )     ( ps . getProperty (  \" foo \"  )  )  )  ,    equalTo (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withRequiredArg_andArgIsPresent"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" foo \"  )  . withRequiredArg (  )  . withValuesSeparatedBy (  '  ,  '  )  ;", "OptionSet   options    =    parser . parse (  \"  -  - foo = bar , baz , biz \"  )  ;", "CommandLinePropertySource <  ?  >    ps    =    new    ( options )  ;", "assertEquals ( Arrays . asList (  \" bar \"  ,     \" baz \"  ,     \" biz \"  )  ,    ps . getOptionValues (  \" foo \"  )  )  ;", "assertThat ( ps . getProperty (  \" foo \"  )  ,    equalTo (  \" bar , baz , biz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withRequiredArg_andMultipleArgsPresent_usingDelimiter"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" foo \"  )  . withRequiredArg (  )  . withValuesSeparatedBy (  '  ,  '  )  ;", "OptionSet   options    =    parser . parse (  \"  -  - foo = bar \"  ,     \"  -  - foo = baz \"  ,     \"  -  - foo = biz \"  )  ;", "CommandLinePropertySource <  ?  >    ps    =    new    ( options )  ;", "assertEquals ( Arrays . asList (  \" bar \"  ,     \" baz \"  ,     \" biz \"  )  ,    ps . getOptionValues (  \" foo \"  )  )  ;", "assertThat ( ps . getProperty (  \" foo \"  )  ,    equalTo (  \" bar , baz , biz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withRequiredArg_andMultipleArgsPresent_usingRepeatedOption"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "OptionParser   parser    =    new   OptionParser (  )  ;", "parser . accepts (  \" o 1  \"  )  . withRequiredArg (  )  . ofType (  . OptionEnum . class )  ;", "OptionSet   options    =    parser . parse (  \"  -  - o 1  = VAL _  1  \"  )  ;", "PropertySource <  ?  >    ps    =    new   JOptCommandLinePropertySource ( options )  ;", "assertThat ( ps . getProperty (  \" o 1  \"  )  ,    equalTo (  \" VAL _  1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withRequiredArg_ofTypeEnum"], "fileName": "org.springframework.core.env.JOptCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "this . missingRequiredProperties . add ( key )  ;", "}", "METHOD_END"], "methodName": ["addMissingRequiredProperty"], "fileName": "org.springframework.core.env.MissingRequiredPropertiesException"}, {"methodBody": ["METHOD_START", "{", "return   this . missingRequiredProperties ;", "}", "METHOD_END"], "methodName": ["getMissingRequiredProperties"], "fileName": "org.springframework.core.env.MissingRequiredPropertiesException"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Adding   PropertySource    '  \"     +     ( propertySource . getName (  )  )  )     +     \"  '    with   search   precedence   immediately   lower   than    '  \"  )     +    relativName )     +     \"  '  \"  )  )  ;", "}", "assertLegalRelativeAddition ( relativName ,    propertySource )  ;", "removeIfPresent ( propertySource )  ;", "int   index    =    assertPresentAndGetIndex ( relativName )  ;", "addAtIndex (  ( index    +     1  )  ,    propertySource )  ;", "}", "METHOD_END"], "methodName": ["addAfter"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "removeIfPresent ( propertySource )  ;", "this . propertySourceList . add ( index ,    propertySource )  ;", "}", "METHOD_END"], "methodName": ["addAtIndex"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Adding   PropertySource    '  \"     +     ( propertySource . getName (  )  )  )     +     \"  '    with   search   precedence   immediately   higher   than    '  \"  )     +    relativName )     +     \"  '  \"  )  )  ;", "}", "assertLegalRelativeAddition ( relativName ,    propertySource )  ;", "removeIfPresent ( propertySource )  ;", "int   index    =    assertPresentAndGetIndex ( relativName )  ;", "addAtIndex ( index ,    propertySource )  ;", "}", "METHOD_END"], "methodName": ["addBefore"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Adding       '  \"     +     ( propertySource . getName (  )  )  )     +     \"  '    with   highest   search   precedence \"  )  )  ;", "}", "removeIfPresent ( propertySource )  ;", "this . propertySourceList . add (  0  ,    propertySource )  ;", "}", "METHOD_END"], "methodName": ["addFirst"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Adding       '  \"     +     ( propertySource . getName (  )  )  )     +     \"  '    with   lowest   search   precedence \"  )  )  ;", "}", "removeIfPresent ( propertySource )  ;", "this . propertySourceList . add ( propertySource )  ;", "}", "METHOD_END"], "methodName": ["addLast"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "String   newPropertySourceName    =    propertySource . getName (  )  ;", "if    ( relativName . equals ( newPropertySourceName )  )     {", "throw   new   IllegalArgumentException (  (  (  \" PropertySource   named    '  \"     +    newPropertySourceName )     +     \"  '    cannot   be   added   relative   to   itself \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertLegalRelativeAddition"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "int   index    =    this . propertySourceList . indexOf ( PropertySource . named ( name )  )  ;", "if    ( index    =  =     (  -  1  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" PropertySource   named    '  \"     +    name )     +     \"  '    does   not   exist \"  )  )  ;", "}", "return   index ;", "}", "METHOD_END"], "methodName": ["assertPresentAndGetIndex"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "return   this . propertySourceList . indexOf ( propertySource )  ;", "}", "METHOD_END"], "methodName": ["precedenceOf"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Removing       '  \"     +    name )     +     \"  '  \"  )  )  ;", "}", "int   index    =    this . propertySourceList . indexOf (  . named ( name )  )  ;", "return   index    !  =     (  -  1  )     ?    this . propertySourceList . remove ( index )     :    null ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "this . propertySourceList . remove ( propertySource )  ;", "}", "METHOD_END"], "methodName": ["removeIfPresent"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Replacing       '  \"     +    name )     +     \"  '    with    '  \"  )     +     ( propertySource . getName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "int   index    =    assertPresentAndGetIndex ( name )  ;", "this . propertySourceList . set ( index ,    propertySource )  ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "return   this . propertySourceList . size (  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.springframework.core.env.MutablePropertySources"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   sources    =    new   MutablePropertySources (  )  ;", "assertThat ( sources . get (  \" bogus \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNonExistentPropertySourceReturnsNull"], "fileName": "org.springframework.core.env.MutablePropertySourcesTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   sources    =    new   MutablePropertySources (  )  ;", "sources . addLast ( new   MockPropertySource (  \" b \"  )  . withProperty (  \" p 1  \"  ,     \" bValue \"  )  )  ;", "sources . addLast ( new   MockPropertySource (  \" d \"  )  . withProperty (  \" p 1  \"  ,     \" dValue \"  )  )  ;", "sources . addLast ( new   MockPropertySource (  \" f \"  )  . withProperty (  \" p 1  \"  ,     \" fValue \"  )  )  ;", "assertThat ( sources . size (  )  ,    equalTo (  3  )  )  ;", "assertThat ( sources . contains (  \" a \"  )  ,    is ( false )  )  ;", "assertThat ( sources . contains (  \" b \"  )  ,    is ( true )  )  ;", "assertThat ( sources . contains (  \" c \"  )  ,    is ( false )  )  ;", "assertThat ( sources . contains (  \" d \"  )  ,    is ( true )  )  ;", "assertThat ( sources . contains (  \" e \"  )  ,    is ( false )  )  ;", "assertThat ( sources . contains (  \" f \"  )  ,    is ( true )  )  ;", "assertThat ( sources . contains (  \" g \"  )  ,    is ( false )  )  ;", "assertThat ( sources . get (  \" b \"  )  ,    not ( nullValue (  )  )  )  ;", "assertThat ( sources . get (  \" b \"  )  . getProperty (  \" p 1  \"  )  ,    equalTo (  (  ( Object )     (  \" bValue \"  )  )  )  )  ;", "assertThat ( sources . get (  \" d \"  )  ,    not ( nullValue (  )  )  )  ;", "assertThat ( sources . get (  \" d \"  )  . getProperty (  \" p 1  \"  )  ,    equalTo (  (  ( Object )     (  \" dValue \"  )  )  )  )  ;", "sources . addBefore (  \" b \"  ,    new   MockPropertySource (  \" a \"  )  )  ;", "sources . addAfter (  \" b \"  ,    new   MockPropertySource (  \" c \"  )  )  ;", "assertThat ( sources . size (  )  ,    equalTo (  5  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" a \"  )  )  ,    is (  0  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" b \"  )  )  ,    is (  1  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" c \"  )  )  ,    is (  2  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" d \"  )  )  ,    is (  3  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" f \"  )  )  ,    is (  4  )  )  ;", "sources . addBefore (  \" f \"  ,    new   MockPropertySource (  \" e \"  )  )  ;", "sources . addAfter (  \" f \"  ,    new   MockPropertySource (  \" g \"  )  )  ;", "assertThat ( sources . size (  )  ,    equalTo (  7  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" a \"  )  )  ,    is (  0  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" b \"  )  )  ,    is (  1  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" c \"  )  )  ,    is (  2  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" d \"  )  )  ,    is (  3  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" e \"  )  )  ,    is (  4  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" f \"  )  )  ,    is (  5  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" g \"  )  )  ,    is (  6  )  )  ;", "sources . addLast ( new   MockPropertySource (  \" a \"  )  )  ;", "assertThat ( sources . size (  )  ,    equalTo (  7  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" b \"  )  )  ,    is (  0  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" c \"  )  )  ,    is (  1  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" d \"  )  )  ,    is (  2  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" e \"  )  )  ,    is (  3  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" f \"  )  )  ,    is (  4  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" g \"  )  )  ,    is (  5  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" a \"  )  )  ,    is (  6  )  )  ;", "sources . addFirst ( new   MockPropertySource (  \" a \"  )  )  ;", "assertThat ( sources . size (  )  ,    equalTo (  7  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" a \"  )  )  ,    is (  0  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" b \"  )  )  ,    is (  1  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" c \"  )  )  ,    is (  2  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" d \"  )  )  ,    is (  3  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" e \"  )  )  ,    is (  4  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" f \"  )  )  ,    is (  5  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" g \"  )  )  ,    is (  6  )  )  ;", "assertEquals ( sources . remove (  \" a \"  )  ,    PropertySource . named (  \" a \"  )  )  ;", "assertThat ( sources . size (  )  ,    equalTo (  6  )  )  ;", "assertThat ( sources . contains (  \" a \"  )  ,    is ( false )  )  ;", "assertNull ( sources . remove (  \" a \"  )  )  ;", "assertThat ( sources . size (  )  ,    equalTo (  6  )  )  ;", "String   bogusPS    =     \" bogus \"  ;", "try    {", "sources . addAfter ( bogusPS ,    new   MockPropertySource (  \" h \"  )  )  ;", "fail (  \" expected   non - existent   PropertySource   exception \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" does   not   exist \"  )  )  ;", "}", "sources . addFirst ( new   MockPropertySource (  \" a \"  )  )  ;", "assertThat ( sources . size (  )  ,    equalTo (  7  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" a \"  )  )  ,    is (  0  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" b \"  )  )  ,    is (  1  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" c \"  )  )  ,    is (  2  )  )  ;", "sources . replace (  \" a \"  ,    new   MockPropertySource (  \" a - replaced \"  )  )  ;", "assertThat ( sources . size (  )  ,    equalTo (  7  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" a - replaced \"  )  )  ,    is (  0  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" b \"  )  )  ,    is (  1  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named (  \" c \"  )  )  ,    is (  2  )  )  ;", "sources . replace (  \" a - replaced \"  ,    new   MockPropertySource (  \" a \"  )  )  ;", "try    {", "sources . replace ( bogusPS ,    new   MockPropertySource (  \" bogus - replaced \"  )  )  ;", "fail (  \" expected   non - existent   PropertySource   exception \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" does   not   exist \"  )  )  ;", "}", "try    {", "sources . addBefore (  \" b \"  ,    new   MockPropertySource (  \" b \"  )  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" cannot   be   added   relative   to   itself \"  )  )  ;", "}", "try    {", "sources . addAfter (  \" b \"  ,    new   MockPropertySource (  \" b \"  )  )  ;", "fail (  \" expected   exception \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" cannot   be   added   relative   to   itself \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.core.env.MutablePropertySourcesTests"}, {"methodBody": ["METHOD_START", "{", "return    ( getProperty ( name )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["containsProperty"], "fileName": "org.springframework.core.env.PropertySource"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.core.env.PropertySource"}, {"methodBody": ["METHOD_START", "{", "return   this . source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.springframework.core.env.PropertySource"}, {"methodBody": ["METHOD_START", "{", "return   new   PropertySource . ComparisonPropertySource ( name )  ;", "}", "METHOD_END"], "methodName": ["named"], "fileName": "org.springframework.core.env.PropertySource"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map 1     =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" a \"  ,     \" b \"  )  ;", "}", "}  ;", "Map < String ,    Object >    map 2     =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" c \"  ,     \" d \"  )  ;", "}", "}  ;", "<  ?  >    ps 1     =    new   Map (  \" ps 1  \"  ,    map 1  )  ;", "ps 1  . getSource (  )  ;", "List <  <  ?  >  >    propertySources    =    new   ArrayList <  >  (  )  ;", "assertThat ( propertySources . add ( ps 1  )  ,    equalTo ( true )  )  ;", "assertThat ( propertySources . contains ( ps 1  )  ,    is ( true )  )  ;", "assertThat ( propertySources . contains (  . named (  \" ps 1  \"  )  )  ,    is ( true )  )  ;", "<  ?  >    ps 1 replacement    =    new   Map (  \" ps 1  \"  ,    map 2  )  ;", "assertThat ( propertySources . add ( ps 1 replacement )  ,    is ( true )  )  ;", "assertThat ( propertySources . size (  )  ,    is (  2  )  )  ;", "assertThat ( propertySources . remove (  . named (  \" ps 1  \"  )  )  ,    is ( true )  )  ;", "assertThat ( propertySources . size (  )  ,    is (  1  )  )  ;", "assertThat ( propertySources . remove (  . named (  \" ps 1  \"  )  )  ,    is ( true )  )  ;", "assertThat ( propertySources . size (  )  ,    is (  0  )  )  ;", "<  ?  >    ps 2     =    new   Map (  \" ps 2  \"  ,    map 2  )  ;", "propertySources . add ( ps 1  )  ;", "propertySources . add ( ps 2  )  ;", "assertThat ( propertySources . indexOf (  . named (  \" ps 1  \"  )  )  ,    is (  0  )  )  ;", "assertThat ( propertySources . indexOf (  . named (  \" ps 2  \"  )  )  ,    is (  1  )  )  ;", "propertySources . clear (  )  ;", "}", "METHOD_END"], "methodName": ["collectionsOperations"], "fileName": "org.springframework.core.env.PropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map 1     =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" a \"  ,     \" b \"  )  ;", "}", "}  ;", "Map < String ,    Object >    map 2     =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" c \"  ,     \" d \"  )  ;", "}", "}  ;", "Properties   props 1     =    new   Properties (  )     {", "{", "setProperty (  \" a \"  ,     \" b \"  )  ;", "}", "}  ;", "Properties   props 2     =    new   Properties (  )     {", "{", "setProperty (  \" c \"  ,     \" d \"  )  ;", "}", "}  ;", "Map   mps    =    new   Map (  \" mps \"  ,    map 1  )  ;", "assertThat ( mps ,    equalTo ( mps )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals ( new   Map (  \" x \"  ,    map 1  )  )  ,    is ( true )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals ( new   Map (  \" x \"  ,    map 2  )  )  ,    is ( true )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals ( new   Properties (  \" x \"  ,    props 1  )  )  ,    is ( true )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals ( new   Properties (  \" x \"  ,    props 2  )  )  ,    is ( true )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals ( new   Object (  )  )  ,    is ( false )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals (  \" x \"  )  ,    is ( false )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals ( new   Map (  \" y \"  ,    map 1  )  )  ,    is ( false )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals ( new   Map (  \" y \"  ,    map 2  )  )  ,    is ( false )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals ( new   Properties (  \" y \"  ,    props 1  )  )  ,    is ( false )  )  ;", "assertThat ( new   Map (  \" x \"  ,    map 1  )  . equals ( new   Properties (  \" y \"  ,    props 2  )  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.springframework.core.env.PropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . propertySources )     !  =    null )     {", "for    ( PropertySource <  ?  >    propertySource    :    this . propertySources )     {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  \" Searching   for   key    '  \"     +    key )     +     \"  '    in   PropertySource    '  \"  )     +     ( propertySource . getName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "Object   value    =    propertySource . getProperty ( key )  ;", "if    ( value    !  =    null )     {", "if    ( resolveNestedPlaceholders    &  &     ( value   instanceof   String )  )     {", "value    =    resolveNestedPlaceholders (  (  ( String )     ( value )  )  )  ;", "}", "logKeyFound ( key ,    propertySource ,    value )  ;", "return   convertValueIfNecessary ( value ,    targetValueType )  ;", "}", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Could   not   find   key    '  \"     +    key )     +     \"  '    in   any   property   source \"  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  \" Found   key    '  \"     +    key )     +     \"  '    in       '  \"  )     +     ( propertySource . getName (  )  )  )     +     \"  '    with   value   of   type    \"  )     +     ( value . getClass (  )  . getSimpleName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["logKeyFound"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolver"}, {"methodBody": ["METHOD_START", "{", "assertThat ( propertyResolver . containsProperty (  \" foo \"  )  ,    is ( false )  )  ;", "testProperties . put (  \" foo \"  ,     \" bar \"  )  ;", "assertThat ( propertyResolver . containsProperty (  \" foo \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["containsProperty"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( propertyResolver . getProperty (  \" foo \"  )  ,    nullValue (  )  )  ;", "testProperties . put (  \" foo \"  ,     \" bar \"  )  ;", "assertThat ( propertyResolver . getProperty (  \" foo \"  )  ,    is (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "propertySources    =    new   MutablePropertySources (  )  ;", "propertyResolver    =    new    ( propertySources )  ;", "propertySources . addLast ( new   MockPropertySource (  \" local \"  )  . withProperty (  \" foo \"  ,     \" localValue \"  )  )  ;", "propertySources . addLast ( new   MockPropertySource (  \" system \"  )  . withProperty (  \" foo \"  ,     \" systemValue \"  )  )  ;", "assertThat ( propertyResolver . getProperty (  \" foo \"  )  ,    equalTo (  \" localValue \"  )  )  ;", "propertySources . replace (  \" local \"  ,    new   MockPropertySource (  \" new \"  )  . withProperty (  \" foo \"  ,     \" newValue \"  )  )  ;", "assertThat ( propertyResolver . getProperty (  \" foo \"  )  ,    equalTo (  \" newValue \"  )  )  ;", "assertThat ( propertySources . size (  )  ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertySources_replacePropertySource"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "HashMap < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addFirst ( new   MapPropertySource (  \" testProperties \"  ,    map )  )  ;", "PropertyResolver   propertyResolver    =    new    ( propertySources )  ;", "assertThat ( propertyResolver . getProperty (  \" foo \"  )  ,    equalTo ( null )  )  ;", "map . put (  \" foo \"  ,     \"  4  2  \"  )  ;", "assertThat ( propertyResolver . getProperty (  \" foo \"  )  ,    equalTo (  \"  4  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getProperty_doesNotCache_addNewKeyPostConstruction"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   key    =     \" foo \"  ;", "String   value 1     =     \" bar \"  ;", "String   value 2     =     \" biz \"  ;", "HashMap < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( key ,    value 1  )  ;", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addFirst ( new   MapPropertySource (  \" testProperties \"  ,    map )  )  ;", "PropertyResolver   propertyResolver    =    new    ( propertySources )  ;", "assertThat ( propertyResolver . getProperty ( key )  ,    equalTo ( value 1  )  )  ;", "map . put ( key ,    value 2  )  ;", "assertThat ( propertyResolver . getProperty ( key )  ,    equalTo ( value 2  )  )  ;", "}", "METHOD_END"], "methodName": ["getProperty_doesNotCache_replaceExistingKeyPostConstruction"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   sources    =    new   MutablePropertySources (  )  ;", "PropertyResolver   resolver    =    new    ( sources )  ;", "sources . addFirst ( new   MockPropertySource (  \" ps 1  \"  )  . withProperty (  \" pName \"  ,     \" ps 1 Value \"  )  )  ;", "assertThat ( resolver . getProperty (  \" pName \"  )  ,    equalTo (  \" ps 1 Value \"  )  )  ;", "sources . addFirst ( new   MockPropertySource (  \" ps 2  \"  )  . withProperty (  \" pName \"  ,     \" ps 2 Value \"  )  )  ;", "assertThat ( resolver . getProperty (  \" pName \"  )  ,    equalTo (  \" ps 2 Value \"  )  )  ;", "sources . addFirst ( new   MockPropertySource (  \" ps 3  \"  )  . withProperty (  \" pName \"  ,     \" ps 3 Value \"  )  )  ;", "assertThat ( resolver . getProperty (  \" pName \"  )  ,    equalTo (  \" ps 3 Value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getProperty_propertySourceSearchOrderIsFIFO"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( propertyResolver . getProperty (  \" foo \"  ,     \" myDefault \"  )  ,    is (  \" myDefault \"  )  )  ;", "testProperties . put (  \" foo \"  ,     \" bar \"  )  ;", "assertThat ( propertyResolver . getProperty (  \" foo \"  )  ,    is (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getProperty_withDefaultValue"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    nullableProperties    =    new   HashMap <  >  (  )  ;", "propertySources . addLast ( new   MapPropertySource (  \" nullableProperties \"  ,    nullableProperties )  )  ;", "nullableProperties . put (  \" foo \"  ,    null )  ;", "assertThat ( p . getProperty (  \" foo \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getProperty_withExplicitNullValue"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "testProperties . put (  \" foo \"  ,     \" bar \"  )  ;", "class   TestType    {  }", "try    {", "p . getProperty (  \" foo \"  ,    TestType . class )  ;", "fail (  \" Expected   ConverterNotFoundException   due   to   non - convertible   types \"  )  ;", "}    catch    ( ConverterNotFoundException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["getProperty_withNonConvertibleTargetType"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "testProperties . put (  \" foo \"  ,     \" bar , baz \"  )  ;", "assertThat ( p . getProperty (  \" foo \"  ,    String [  ]  . class )  ,    equalTo ( new   String [  ]  {     \" bar \"  ,     \" baz \"     }  )  )  ;", "}", "METHOD_END"], "methodName": ["getProperty_withStringArrayConversion"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( propertyResolver . getProperty (  \" foo \"  ,    Integer . class ,     4  2  )  ,    equalTo (  4  2  )  )  ;", "testProperties . put (  \" foo \"  ,     1  3  )  ;", "assertThat ( propertyResolver . getProperty (  \" foo \"  ,    Integer . class ,     4  2  )  ,    equalTo (  1  3  )  )  ;", "}", "METHOD_END"], "methodName": ["getProperty_withTargetType_andDefaultValue"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "testProperties . put (  \" exists \"  ,     \" xyz \"  )  ;", "assertThat ( p . getRequiredProperty (  \" exists \"  )  ,    is (  \" xyz \"  )  )  ;", "try    {", "p . getRequiredProperty (  \" bogus \"  )  ;", "fail (  \" expected   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["getRequiredProperty"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "testProperties . put (  \" exists \"  ,     \" abc ,  1  2  3  \"  )  ;", "assertThat ( p . getRequiredProperty (  \" exists \"  ,    String [  ]  . class )  ,    equalTo ( new   String [  ]  {     \" abc \"  ,     \"  1  2  3  \"     }  )  )  ;", "try    {", "p . getRequiredProperty (  \" bogus \"  ,    String [  ]  . class )  ;", "fail (  \" expected   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["getRequiredProperty_withStringArrayConversion"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   ps    =    new   MutablePropertySources (  )  ;", "ps . addFirst ( new   MockPropertySource (  )  . withProperty (  \" p 1  \"  ,     \" v 1  \"  )  . withProperty (  \" p 2  \"  ,     \" v 2  \"  )  . withProperty (  \" p 3  \"  ,     \"  $  { p 1  }  :  $  { p 2  }  :  $  { bogus : def }  \"  )  . withProperty (  \" p 4  \"  ,     \"  $  { p 1  }  :  $  { p 2  }  :  $  { bogus }  \"  )  )  ;", "ConfigurablePropertyResolver   pr    =    new    ( ps )  ;", "assertThat ( pr . getProperty (  \" p 1  \"  )  ,    equalTo (  \" v 1  \"  )  )  ;", "assertThat ( pr . getProperty (  \" p 2  \"  )  ,    equalTo (  \" v 2  \"  )  )  ;", "assertThat ( pr . getProperty (  \" p 3  \"  )  ,    equalTo (  \" v 1  : v 2  : def \"  )  )  ;", "try    {", "pr . getProperty (  \" p 4  \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertThat ( ex . getMessage (  )  ,    containsString (  \" Could   not   resolve   placeholder    \\  ' bogus \\  '    in   value    \\  \"  $  { p 1  }  :  $  { p 2  }  :  $  { bogus }  \\  \"  \"  )  )  ;", "}", "pr . setIgnoreUnresolvableNestedPlaceholders ( true )  ;", "assertThat ( pr . getProperty (  \" p 4  \"  )  ,    equalTo (  \" v 1  : v 2  :  $  { bogus }  \"  )  )  ;", "assertThat ( pr . resolvePlaceholders (  \"  $  { p 1  }  :  $  { p 2  }  :  $  { bogus }  \"  )  ,    equalTo (  \" v 1  : v 2  :  $  { bogus }  \"  )  )  ;", "try    {", "pr . resolveRequiredPlaceholders (  \"  $  { p 1  }  :  $  { p 2  }  :  $  { bogus }  \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertThat ( ex . getMessage (  )  ,    containsString (  \" Could   not   resolve   placeholder    \\  ' bogus \\  '    in   value    \\  \"  $  { p 1  }  :  $  { p 2  }  :  $  { bogus }  \\  \"  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["ignoreUnresolvableNestedPlaceholdersIsConfigurable"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   ps    =    new   MutablePropertySources (  )  ;", "ps . addFirst ( new   MockPropertySource (  )  . withProperty (  \" p 1  \"  ,     \" v 1  \"  )  . withProperty (  \" p 2  \"  ,     \" v 2  \"  )  . withProperty (  \" p 3  \"  ,     \"  $  { p 1  }  :  $  { p 2  }  \"  )  . withProperty (  \" p 4  \"  ,     \"  $  { p 3  }  \"  )  . withProperty (  \" p 5  \"  ,     \"  $  { p 1  }  :  $  { p 2  }  :  $  { bogus }  \"  )  . withProperty (  \" p 6  \"  ,     \"  $  { p 1  }  :  $  { p 2  }  :  $  { bogus : def }  \"  )  . withProperty (  \" pL \"  ,     \"  $  { pR }  \"  )  . withProperty (  \" pR \"  ,     \"  $  { pL }  \"  )  )  ;", "ConfigurablePropertyResolver   pr    =    new    ( ps )  ;", "assertThat ( pr . getProperty (  \" p 1  \"  )  ,    equalTo (  \" v 1  \"  )  )  ;", "assertThat ( pr . getProperty (  \" p 2  \"  )  ,    equalTo (  \" v 2  \"  )  )  ;", "assertThat ( pr . getProperty (  \" p 3  \"  )  ,    equalTo (  \" v 1  : v 2  \"  )  )  ;", "assertThat ( pr . getProperty (  \" p 4  \"  )  ,    equalTo (  \" v 1  : v 2  \"  )  )  ;", "try    {", "pr . getProperty (  \" p 5  \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertThat ( ex . getMessage (  )  ,    containsString (  \" Could   not   resolve   placeholder    \\  ' bogus \\  '    in   value    \\  \"  $  { p 1  }  :  $  { p 2  }  :  $  { bogus }  \\  \"  \"  )  )  ;", "}", "assertThat ( pr . getProperty (  \" p 6  \"  )  ,    equalTo (  \" v 1  : v 2  : def \"  )  )  ;", "try    {", "pr . getProperty (  \" pL \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue ( ex . getMessage (  )  . toLowerCase (  )  . contains (  \" circular \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveNestedPropertyPlaceholders"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addFirst ( new   MockPropertySource (  )  . withProperty (  \" key \"  ,     \" value \"  )  )  ;", "PropertyResolver   resolver    =    new    ( propertySources )  ;", "assertThat ( resolver . resolvePlaceholders (  \" Replace   this    $  { key }  \"  )  ,    equalTo (  \" Replace   this   value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholders"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addFirst ( new   MockPropertySource (  )  . withProperty (  \" key \"  ,     \" value \"  )  )  ;", "PropertyResolver   resolver    =    new    ( propertySources )  ;", "assertThat ( resolver . resolvePlaceholders (  \" Replace   this    $  { key }    plus    $  { unknown : defaultValue }  \"  )  ,    equalTo (  \" Replace   this   value   plus   defaultValue \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholders_withDefaultValue"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   PropertySourcesPropertyResolver ( new   MutablePropertySources (  )  )  . resolvePlaceholders ( null )  ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholders_withNullInput"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addFirst ( new   MockPropertySource (  )  . withProperty (  \" key \"  ,     \" value \"  )  )  ;", "PropertyResolver   resolver    =    new    ( propertySources )  ;", "assertThat ( resolver . resolvePlaceholders (  \" Replace   this    $  { key }    plus    $  { unknown }  \"  )  ,    equalTo (  \" Replace   this   value   plus    $  { unknown }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholders_withUnresolvable"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addFirst ( new   MockPropertySource (  )  . withProperty (  \" key \"  ,     \" value \"  )  )  ;", "PropertyResolver   resolver    =    new    ( propertySources )  ;", "assertThat ( resolver . resolveRequiredPlaceholders (  \" Replace   this    $  { key }  \"  )  ,    equalTo (  \" Replace   this   value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveRequiredPlaceholders"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addFirst ( new   MockPropertySource (  )  . withProperty (  \" key \"  ,     \" value \"  )  )  ;", "PropertyResolver   resolver    =    new    ( propertySources )  ;", "assertThat ( resolver . resolveRequiredPlaceholders (  \" Replace   this    $  { key }    plus    $  { unknown : defaultValue }  \"  )  ,    equalTo (  \" Replace   this   value   plus   defaultValue \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveRequiredPlaceholders_withDefaultValue"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   PropertySourcesPropertyResolver ( new   MutablePropertySources (  )  )  . resolveRequiredPlaceholders ( null )  ;", "}", "METHOD_END"], "methodName": ["resolveRequiredPlaceholders_withNullInput"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertySources   propertySources    =    new   MutablePropertySources (  )  ;", "propertySources . addFirst ( new   MockPropertySource (  )  . withProperty (  \" key \"  ,     \" value \"  )  )  ;", "PropertyResolver   resolver    =    new    ( propertySources )  ;", "resolver . resolveRequiredPlaceholders (  \" Replace   this    $  { key }    plus    $  { unknown }  \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveRequiredPlaceholders_withUnresolvable"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "propertyResolver . validateRequiredProperties (  )  ;", "propertyResolver . setRequiredProperties (  \" foo \"  ,     \" bar \"  )  ;", "try    {", "propertyResolver . validateRequiredProperties (  )  ;", "fail (  \" expected   validation   exception \"  )  ;", "}    catch    ( MissingRequiredPropertiesException   ex )     {", "assertThat ( ex . getMessage (  )  ,    equalTo (  (  \" The   following   properties   were   declared   as   required    \"     +     \" but   could   not   be   resolved :     [ foo ,    bar ]  \"  )  )  )  ;", "}", "testProperties . put (  \" foo \"  ,     \" fooValue \"  )  ;", "try    {", "propertyResolver . validateRequiredProperties (  )  ;", "fail (  \" expected   validation   exception \"  )  ;", "}    catch    ( MissingRequiredPropertiesException   ex )     {", "assertThat ( ex . getMessage (  )  ,    equalTo (  (  \" The   following   properties   were   declared   as   required    \"     +     \" but   could   not   be   resolved :     [ bar ]  \"  )  )  )  ;", "}", "testProperties . put (  \" bar \"  ,     \"  \"  )  ;", "propertyResolver . validateRequiredProperties (  )  ;", "}", "METHOD_END"], "methodName": ["setRequiredProperties_andValidateRequiredProperties"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "propertySources    =    new   MutablePropertySources (  )  ;", "propertyResolver    =    new    ( propertySources )  ;", "testProperties    =    new   Properties (  )  ;", "propertySources . addFirst ( new   PropertiesPropertySource (  \" testProperties \"  ,    testProperties )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.core.env.PropertySourcesPropertyResolverTests"}, {"methodBody": ["METHOD_START", "{", "CommandLineArgs   commandLineArgs    =    new   CommandLineArgs (  )  ;", "for    ( String   arg    :    args )     {", "if    ( arg . startsWith (  \"  -  -  \"  )  )     {", "String   optionText    =    arg . substring (  2  ,    arg . length (  )  )  ;", "String   optionName ;", "String   optionValue    =    null ;", "if    ( optionText . contains (  \"  =  \"  )  )     {", "optionName    =    optionText . substring (  0  ,    optionText . indexOf (  '  =  '  )  )  ;", "optionValue    =    optionText . substring (  (  ( optionText . indexOf (  '  =  '  )  )     +     1  )  ,    optionText . length (  )  )  ;", "} else    {", "optionName    =    optionText ;", "}", "if    (  ( optionName . isEmpty (  )  )     |  |     (  ( optionValue    !  =    null )     &  &     ( optionValue . isEmpty (  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Invalid   argument   syntax :     \"     +    arg )  )  ;", "}", "commandLineArgs . addOptionArg ( optionName ,    optionValue )  ;", "} else    {", "commandLineArgs . addNonOptionArg ( arg )  ;", "}", "}", "return   commandLineArgs ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.core.env.SimpleCommandLineArgsParser"}, {"methodBody": ["METHOD_START", "{", "CommandLineArgs   args    =    new   SimpleCommandLineArgsParser (  )  . parse (  )  ;", "args . getNonOptionArgs (  )  . add (  \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["assertNonOptionArgsIsUnmodifiable"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "CommandLineArgs   args    =    new   SimpleCommandLineArgsParser (  )  . parse (  )  ;", "args . getOptionNames (  )  . add (  \" bogus \"  )  ;", "}", "METHOD_END"], "methodName": ["assertOptionNamesIsUnmodifiable"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCommandLineArgsParser   parser    =    new   SimpleCommandLineArgsParser (  )  ;", "parser . parse (  \"  -  -  = v 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["withEmptyOptionName"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCommandLineArgsParser   parser    =    new   SimpleCommandLineArgsParser (  )  ;", "parser . parse (  \"  -  -  =  \"  )  ;", "}", "METHOD_END"], "methodName": ["withEmptyOptionNameAndEmptyOptionValue"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCommandLineArgsParser   parser    =    new   SimpleCommandLineArgsParser (  )  ;", "parser . parse (  \"  -  -  \"  )  ;", "}", "METHOD_END"], "methodName": ["withEmptyOptionText"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCommandLineArgsParser   parser    =    new   SimpleCommandLineArgsParser (  )  ;", "parser . parse (  \"  -  - o 1  =  \"  )  ;", "}", "METHOD_END"], "methodName": ["withEmptyOptionValue"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCommandLineArgsParser   parser    =    new   SimpleCommandLineArgsParser (  )  ;", "CommandLineArgs   args    =    parser . parse (  \"  -  - o 1  = v 1  \"  ,     \"  -  - o 2  \"  )  ;", "assertThat ( args . containsOption (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( args . containsOption (  \" o 2  \"  )  ,    is ( true )  )  ;", "assertThat ( args . containsOption (  \" o 3  \"  )  ,    is ( false )  )  ;", "assertThat ( args . getOptionValues (  \" o 1  \"  )  . get (  0  )  ,    equalTo (  \" v 1  \"  )  )  ;", "assertThat ( args . getOptionValues (  \" o 2  \"  )  ,    equalTo ( Collections . EMPTY _ LIST )  )  ;", "assertThat ( args . getOptionValues (  \" o 3  \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withMixOfOptionsHavingValueAndOptionsHavingNoValue"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCommandLineArgsParser   parser    =    new   SimpleCommandLineArgsParser (  )  ;", "assertThat ( parser . parse (  )  . getOptionValues (  \" foo \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withNoOptions"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCommandLineArgsParser   parser    =    new   SimpleCommandLineArgsParser (  )  ;", "CommandLineArgs   args    =    parser . parse (  \"  -  - o 1  = v 1  \"  ,     \" noa 1  \"  ,     \"  -  - o 2  = v 2  \"  ,     \" noa 2  \"  )  ;", "assertThat ( args . getOptionValues (  \" o 1  \"  )  . get (  0  )  ,    equalTo (  \" v 1  \"  )  )  ;", "assertThat ( args . getOptionValues (  \" o 2  \"  )  . get (  0  )  ,    equalTo (  \" v 2  \"  )  )  ;", "List < String >    nonOptions    =    args . getNonOptionArgs (  )  ;", "assertThat ( nonOptions . get (  0  )  ,    equalTo (  \" noa 1  \"  )  )  ;", "assertThat ( nonOptions . get (  1  )  ,    equalTo (  \" noa 2  \"  )  )  ;", "assertThat ( nonOptions . size (  )  ,    equalTo (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["withNonOptionArguments"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCommandLineArgsParser   parser    =    new   SimpleCommandLineArgsParser (  )  ;", "CommandLineArgs   args    =    parser . parse (  \"  -  - o 1  \"  )  ;", "assertThat ( args . containsOption (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( args . getOptionValues (  \" o 1  \"  )  ,    equalTo ( Collections . EMPTY _ LIST )  )  ;", "}", "METHOD_END"], "methodName": ["withSingleOptionAndNoValue"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCommandLineArgsParser   parser    =    new   SimpleCommandLineArgsParser (  )  ;", "CommandLineArgs   args    =    parser . parse (  \"  -  - o 1  = v 1  \"  )  ;", "assertThat ( args . containsOption (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( args . getOptionValues (  \" o 1  \"  )  . get (  0  )  ,    equalTo (  \" v 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withSingleOptionAndValue"], "fileName": "org.springframework.core.env.SimpleCommandLineParserTests"}, {"methodBody": ["METHOD_START", "{", "CommandLinePropertySource <  ?  >    ps    =    new   SimpleCommandLinePropertySource (  \"  -  - o 1  = v 1  \"  ,     \" noa 1  \"  ,     \"  -  - o 2  \"  ,     \" noa 2  \"  )  ;", "StandardEnvironment   env    =    new   StandardEnvironment (  )  ;", "env . getPropertySources (  )  . addFirst ( ps )  ;", "String   nonOptionArgs    =    env . getProperty (  \" nonOptionArgs \"  )  ;", "assertThat ( nonOptionArgs ,    equalTo (  \" noa 1  , noa 2  \"  )  )  ;", "String [  ]    nonOptionArgsArray    =    env . getProperty (  \" nonOptionArgs \"  ,    String [  ]  . class )  ;", "assertThat ( nonOptionArgsArray [  0  ]  ,    equalTo (  \" noa 1  \"  )  )  ;", "assertThat ( nonOptionArgsArray [  1  ]  ,    equalTo (  \" noa 2  \"  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "List < String >    nonOptionArgsList    =    env . getProperty (  \" nonOptionArgs \"  ,    List . class )  ;", "assertThat ( nonOptionArgsList . get (  0  )  ,    equalTo (  \" noa 1  \"  )  )  ;", "assertThat ( nonOptionArgsList . get (  1  )  ,    equalTo (  \" noa 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["covertNonOptionArgsToStringArrayAndList"], "fileName": "org.springframework.core.env.SimpleCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   SimpleCommandLinePropertySource (  \" ps 1  \"  ,    new   String [  0  ]  )  ;", "assertThat ( ps . getName (  )  ,    equalTo (  \" ps 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withCustomName"], "fileName": "org.springframework.core.env.SimpleCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "CommandLinePropertySource <  ?  >    ps    =    new   SimpleCommandLinePropertySource (  \"  -  - o 1  = v 1  \"  ,     \" noa 1  \"  ,     \"  -  - o 2  \"  ,     \" noa 2  \"  )  ;", "ps . setNonOptionArgsPropertyName (  \" NOA \"  )  ;", "assertThat ( ps . containsProperty (  \" nonOptionArgs \"  )  ,    is ( false )  )  ;", "assertThat ( ps . containsProperty (  \" NOA \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 2  \"  )  ,    is ( true )  )  ;", "String   nonOptionArgs    =    ps . getProperty (  \" NOA \"  )  ;", "assertThat ( nonOptionArgs ,    equalTo (  \" noa 1  , noa 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withCustomNonOptionArgsNameAndNoNonOptionArgsPresent"], "fileName": "org.springframework.core.env.SimpleCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   SimpleCommandLinePropertySource (  )  ;", "assertThat ( ps . getName (  )  ,    equalTo ( CommandLinePropertySource . COMMAND _ LINE _ PROPERTY _ SOURCE _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaultName"], "fileName": "org.springframework.core.env.SimpleCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "EnumerablePropertySource <  ?  >    ps    =    new   SimpleCommandLinePropertySource (  \"  -  - o 1  = v 1  \"  ,     \"  -  - o 2  \"  )  ;", "assertThat ( ps . containsProperty (  \" nonOptionArgs \"  )  ,    is ( false )  )  ;", "assertThat ( ps . containsProperty (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" nonOptionArgs \"  )  ,    is ( false )  )  ;", "assertThat ( ps . getProperty (  \" nonOptionArgs \"  )  ,    nullValue (  )  )  ;", "assertThat ( ps . getPropertyNames (  )  . length ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaultNonOptionArgsNameAndNoNonOptionArgsPresent"], "fileName": "org.springframework.core.env.SimpleCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "CommandLinePropertySource <  ?  >    ps    =    new   SimpleCommandLinePropertySource (  \"  -  - o 1  = v 1  \"  ,     \" noa 1  \"  ,     \"  -  - o 2  \"  ,     \" noa 2  \"  )  ;", "assertThat ( ps . containsProperty (  \" nonOptionArgs \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 2  \"  )  ,    is ( true )  )  ;", "String   nonOptionArgs    =    ps . getProperty (  \" nonOptionArgs \"  )  ;", "assertThat ( nonOptionArgs ,    equalTo (  \" noa 1  , noa 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaultNonOptionArgsNameAndNonOptionArgsPresent"], "fileName": "org.springframework.core.env.SimpleCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   SimpleCommandLinePropertySource (  )  ;", "assertThat ( ps . containsProperty (  \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( ps . getProperty (  \" foo \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withNoArgs"], "fileName": "org.springframework.core.env.SimpleCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "CommandLinePropertySource <  ?  >    ps    =    new   SimpleCommandLinePropertySource (  \"  -  - o 1  = v 1  \"  ,     \"  -  - o 2  \"  )  ;", "assertThat ( ps . containsProperty (  \" o 1  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 2  \"  )  ,    is ( true )  )  ;", "assertThat ( ps . containsProperty (  \" o 3  \"  )  ,    is ( false )  )  ;", "assertThat ( ps . getProperty (  \" o 1  \"  )  ,    equalTo (  \" v 1  \"  )  )  ;", "assertThat ( ps . getProperty (  \" o 2  \"  )  ,    equalTo (  \"  \"  )  )  ;", "assertThat ( ps . getProperty (  \" o 3  \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withOptionArgsOnly"], "fileName": "org.springframework.core.env.SimpleCommandLinePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . acceptsProfiles (  \" p 1  \"  ,     \" p 2  \"  )  ,    is ( false )  )  ;", "environment . setActiveProfiles (  \" p 1  \"  )  ;", "assertThat ( environment . acceptsProfiles (  \" p 1  \"  ,     \" p 2  \"  )  ,    is ( true )  )  ;", "environment . setActiveProfiles (  \" p 2  \"  )  ;", "assertThat ( environment . acceptsProfiles (  \" p 1  \"  ,     \" p 2  \"  )  ,    is ( true )  )  ;", "environment . setActiveProfiles (  \" p 1  \"  ,     \" p 2  \"  )  ;", "assertThat ( environment . acceptsProfiles (  \" p 1  \"  ,     \" p 2  \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["acceptsProfiles_activeProfileSetProgrammatically"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . acceptsProfiles (  \" p 1  \"  )  ,    is ( false )  )  ;", "environment . getPropertySources (  )  . addFirst ( new   MockPropertySource (  )  . withProperty ( Abstract . ACTIVE _ PROFILES _ PROPERTY _ NAME ,     \" p 1  \"  )  )  ;", "assertThat ( environment . acceptsProfiles (  \" p 1  \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["acceptsProfiles_activeProfileSetViaProperty"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . acceptsProfiles (  \" pd \"  )  ,    is ( false )  )  ;", "environment . setDefaultProfiles (  \" pd \"  )  ;", "assertThat ( environment . acceptsProfiles (  \" pd \"  )  ,    is ( true )  )  ;", "environment . setActiveProfiles (  \" p 1  \"  )  ;", "assertThat ( environment . acceptsProfiles (  \" pd \"  )  ,    is ( false )  )  ;", "assertThat ( environment . acceptsProfiles (  \" p 1  \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["acceptsProfiles_defaultProfile"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . acceptsProfiles (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["acceptsProfiles_withEmptyArgument"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . acceptsProfiles (  )  ;", "}", "METHOD_END"], "methodName": ["acceptsProfiles_withEmptyArgumentList"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . acceptsProfiles (  \" p 1  \"  ,     \"  !  \"  )  ;", "}", "METHOD_END"], "methodName": ["acceptsProfiles_withInvalidNotOperator"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . acceptsProfiles (  \" p 1  \"  )  ,    is ( false )  )  ;", "assertThat ( environment . acceptsProfiles (  \"  ! p 1  \"  )  ,    is ( true )  )  ;", "environment . addActiveProfile (  \" p 1  \"  )  ;", "assertThat ( environment . acceptsProfiles (  \" p 1  \"  )  ,    is ( true )  )  ;", "assertThat ( environment . acceptsProfiles (  \"  ! p 1  \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["acceptsProfiles_withNotOperator"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . acceptsProfiles (  (  ( String )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptsProfiles_withNullArgument"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . acceptsProfiles (  (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["acceptsProfiles_withNullArgumentList"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . getActiveProfiles (  )  . length ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["activeProfilesIsEmptyByDefault"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . getActiveProfiles (  )  . length ,    is (  0  )  )  ;", "environment . setActiveProfiles (  \" local \"  ,     \" embedded \"  )  ;", "assertThat ( Arrays . asList ( environment . getActiveProfiles (  )  )  ,    hasItems (  \" local \"  ,     \" embedded \"  )  )  ;", "assertThat ( environment . getActiveProfiles (  )  . length ,    is (  2  )  )  ;", "environment . addActiveProfile (  \" p 1  \"  )  ;", "assertThat ( Arrays . asList ( environment . getActiveProfiles (  )  )  ,    hasItems (  \" p 1  \"  )  )  ;", "assertThat ( environment . getActiveProfiles (  )  . length ,    is (  3  )  )  ;", "environment . addActiveProfile (  \" p 2  \"  )  ;", "environment . addActiveProfile (  \" p 3  \"  )  ;", "assertThat ( Arrays . asList ( environment . getActiveProfiles (  )  )  ,    hasItems (  \" p 2  \"  ,     \" p 3  \"  )  )  ;", "assertThat ( environment . getActiveProfiles (  )  . length ,    is (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["addActiveProfile"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "assertThat ( env . getProperty ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME )  ,    nullValue (  )  )  ;", "env . getPropertySources (  )  . addFirst ( new   MockPropertySource (  )  . withProperty ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME ,     \" p 1  \"  )  )  ;", "assertThat ( env . getProperty ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME )  ,    equalTo (  \" p 1  \"  )  )  ;", "env . addActiveProfile (  \" p 2  \"  )  ;", "assertThat ( env . getActiveProfiles (  )  ,    arrayContaining (  \" p 1  \"  ,     \" p 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addActiveProfile_whenActiveProfilesPropertyIsAlreadySet"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( AbstractEnvironment . DEFAULT _ PROFILES _ PROPERTY _ NAME ,     \"  $  { spring . profiles . default }  \"  )  ;", "try    {", "environment . getDefaultProfiles (  )  ;", "}    finally    {", "System . getProperties (  )  . remove ( AbstractEnvironment . DEFAULT _ PROFILES _ PROPERTY _ NAME )  ;", "}", "}", "METHOD_END"], "methodName": ["defaultProfileWithCircularPlaceholder"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . getDefaultProfiles (  )  . length ,    is (  1  )  )  ;", "assertThat ( environment . getDefaultProfiles (  )  [  0  ]  ,    equalTo (  \" default \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultProfilesContainsDefaultProfileByDefault"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableEnvironment   env    =    new   AbstractEnvironment (  )     {", "@ Override", "protected   void   validateProfile ( String   profile )     {", "super . validateProfile ( profile )  ;", "if    ( profile . contains (  \"  -  \"  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   profile    [  \"     +    profile )     +     \"  ]  :    must   not   contain   dash   character \"  )  )  ;", "}", "}", "}  ;", "env . addActiveProfile (  \" validProfile \"  )  ;", "try    {", "env . addActiveProfile (  \" invalid - profile \"  )  ;", "fail (  \" expected   validation   exception \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertThat ( ex . getMessage (  )  ,    equalTo (  \" Invalid   profile    [ invalid - profile ]  :    must   not   contain   dash   character \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["environmentSubclass_withCustomProfileValidation"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME ,     \" foo \"  )  ;", "assertThat ( Arrays . asList ( environment . getActiveProfiles (  )  )  ,    hasItem (  \" foo \"  )  )  ;", "System . getProperties (  )  . remove ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getActiveProfiles_fromSystemProperties"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME ,     \"    bar    ,    baz    \"  )  ;", "assertThat ( Arrays . asList ( environment . getActiveProfiles (  )  )  ,    hasItems (  \" bar \"  ,     \" baz \"  )  )  ;", "System . getProperties (  )  . remove ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getActiveProfiles_fromSystemProperties_withMulitpleProfiles_withWhitespace"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME ,     \" foo , bar \"  )  ;", "assertThat ( Arrays . asList ( environment . getActiveProfiles (  )  )  ,    hasItems (  \" foo \"  ,     \" bar \"  )  )  ;", "System . getProperties (  )  . remove ( AbstractEnvironment . ACTIVE _ PROFILES _ PROPERTY _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getActiveProfiles_fromSystemProperties_withMultipleProfiles"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . getActiveProfiles (  )  . length ,    is (  0  )  )  ;", "System . setProperty ( Abstract . ACTIVE _ PROFILES _ PROPERTY _ NAME ,     \"  \"  )  ;", "assertThat ( environment . getActiveProfiles (  )  . length ,    is (  0  )  )  ;", "System . getProperties (  )  . remove ( Abstract . ACTIVE _ PROFILES _ PROPERTY _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getActiveProfiles_systemPropertiesEmpty"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . getDefaultProfiles (  )  ,    equalTo ( new   String [  ]  {    AbstractEnvironment . RESERVED _ DEFAULT _ PROFILE _ NAME    }  )  )  ;", "environment . getPropertySources (  )  . addFirst ( new   MockPropertySource (  )  . withProperty ( AbstractEnvironment . DEFAULT _ PROFILES _ PROPERTY _ NAME ,     \" pd 1  \"  )  )  ;", "assertThat ( environment . getDefaultProfiles (  )  . length ,    is (  1  )  )  ;", "assertThat ( Arrays . asList ( environment . getDefaultProfiles (  )  )  ,    hasItem (  \" pd 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultProfiles"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes    =    Collections . class . getDeclaredClasses (  )  ;", "Map < String ,    String >    env    =    System . getenv (  )  ;", "for    ( Class <  ?  >    cl    :    classes )     {", "if    (  \" Collections $ UnmodifiableMap \"  . equals ( cl . getName (  )  )  )     {", "try    {", "Field   field    =    cl . getDeclaredField (  \" m \"  )  ;", "field . setAccessible ( true )  ;", "Object   obj    =    field . get ( env )  ;", "if    (  ( obj    !  =    null )     &  &     ( obj . getClass (  )  . getName (  )  . equals (  \" Process $ String \"  )  )  )     {", "return    (  ( Map < String ,    String >  )     ( obj )  )  ;", "}", "}    catch    ( Exception   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "}", "}", "Class <  ?  >    processClass ;", "try    {", "processClass    =    Class . forName (  \" Process \"  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "try    {", "Field   theCaseInsensitiveField    =    processClass . getDeclaredField (  \" theCaseInsensitive \"  )  ;", "theCaseInsensitiveField . setAccessible ( true )  ;", "Object   obj    =    theCaseInsensitiveField . get ( null )  ;", "return    (  ( Map < String ,    String >  )     ( obj )  )  ;", "}    catch    ( NoSuchFieldException   ex )     {", "}    catch    ( Exception   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "try    {", "Field   theField    =    processClass . getDeclaredField (  \" the \"  )  ;", "theField . setAccessible ( true )  ;", "Object   obj    =    theField . get ( null )  ;", "return    (  ( Map < String ,    String >  )     ( obj )  )  ;", "}    catch    ( NoSuchFieldException   ex )     {", "}    catch    ( Exception   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "throw   new   IllegalStateException (  )  ;", "}", "METHOD_END"], "methodName": ["getModifiableSystemEnvironment"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "StandardEnvironmentTests . getModifiableSystemEnvironment (  )  . put ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ NAME ,    StandardEnvironmentTests . ALLOWED _ PROPERTY _ VALUE )  ;", "StandardEnvironmentTests . getModifiableSystemEnvironment (  )  . put ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME ,    StandardEnvironmentTests . DISALLOWED _ PROPERTY _ VALUE )  ;", "{", "Map < String ,    Object >    systemEnvironment    =    environment . getSystemEnvironment (  )  ;", "assertThat ( systemEnvironment ,    notNullValue (  )  )  ;", "assertSame ( systemEnvironment ,    System . getenv (  )  )  ;", "}", "SecurityManager   oldSecurityManager    =    System . getSecurityManager (  )  ;", "SecurityManager   securityManager    =    new   SecurityManager (  )     {", "@ Override", "public   void   checkPermission ( Permission   perm )     {", "if    (  \" getenv .  *  \"  . equals ( perm . getName (  )  )  )     {", "throw   new   AccessControlException (  \" Accessing   the   system   environment   is   disallowed \"  )  ;", "}", "if    (  (  \" getenv .  \"     +     ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME )  )  . equals ( perm . getName (  )  )  )     {", "throw   new   AccessControlException ( String . format (  \" Accessing   the   system   environment   variable    [  % s ]    is   disallowed \"  ,    StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME )  )  ;", "}", "}", "}  ;", "System . setSecurityManager ( securityManager )  ;", "{", "Map < String ,    Object >    systemEnvironment    =    environment . getSystemEnvironment (  )  ;", "assertThat ( systemEnvironment ,    notNullValue (  )  )  ;", "assertThat ( systemEnvironment ,    instanceOf ( ReadOnlySystemAttributesMap . class )  )  ;", "assertThat ( systemEnvironment . get ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ NAME )  ,    equalTo (  (  ( Object )     ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ VALUE )  )  )  )  ;", "assertThat ( systemEnvironment . get ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME )  ,    nullValue (  )  )  ;", "}", "System . setSecurityManager ( oldSecurityManager )  ;", "StandardEnvironmentTests . getModifiableSystemEnvironment (  )  . remove ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ NAME )  ;", "StandardEnvironmentTests . getModifiableSystemEnvironment (  )  . remove ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getSystemEnvironment_withAndWithoutSecurityManager"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ NAME ,    StandardEnvironmentTests . ALLOWED _ PROPERTY _ VALUE )  ;", "System . setProperty ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME ,    StandardEnvironmentTests . DISALLOWED _ PROPERTY _ VALUE )  ;", "System . getProperties (  )  . put ( StandardEnvironmentTests . STRING _ PROPERTY _ NAME ,    StandardEnvironmentTests . NON _ STRING _ PROPERTY _ VALUE )  ;", "System . getProperties (  )  . put ( StandardEnvironmentTests . NON _ STRING _ PROPERTY _ NAME ,    StandardEnvironmentTests . STRING _ PROPERTY _ VALUE )  ;", "{", "Map <  ?  ,     ?  >    systemProperties    =    environment . getSystemProperties (  )  ;", "assertThat ( systemProperties ,    notNullValue (  )  )  ;", "assertSame ( systemProperties ,    System . getProperties (  )  )  ;", "assertThat ( systemProperties . get ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ NAME )  ,    equalTo (  (  ( Object )     ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ VALUE )  )  )  )  ;", "assertThat ( systemProperties . get ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME )  ,    equalTo (  (  ( Object )     ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ VALUE )  )  )  )  ;", "assertThat ( systemProperties . get ( StandardEnvironmentTests . STRING _ PROPERTY _ NAME )  ,    equalTo ( StandardEnvironmentTests . NON _ STRING _ PROPERTY _ VALUE )  )  ;", "assertThat ( systemProperties . get ( StandardEnvironmentTests . NON _ STRING _ PROPERTY _ NAME )  ,    equalTo (  (  ( Object )     ( StandardEnvironmentTests . STRING _ PROPERTY _ VALUE )  )  )  )  ;", "}", "SecurityManager   oldSecurityManager    =    System . getSecurityManager (  )  ;", "SecurityManager   securityManager    =    new   SecurityManager (  )     {", "@ Override", "public   void   checkPropertiesAccess (  )     {", "throw   new   AccessControlException (  \" Accessing   the   system   properties   is   disallowed \"  )  ;", "}", "@ Override", "public   void   checkPropertyAccess ( String   key )     {", "if    ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME . equals ( key )  )     {", "throw   new   AccessControlException ( String . format (  \" Accessing   the   system   property    [  % s ]    is   disallowed \"  ,    StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME )  )  ;", "}", "}", "@ Override", "public   void   checkPermission ( Permission   perm )     {", "}", "}  ;", "System . setSecurityManager ( securityManager )  ;", "{", "Map <  ?  ,     ?  >    systemProperties    =    environment . getSystemProperties (  )  ;", "assertThat ( systemProperties ,    notNullValue (  )  )  ;", "assertThat ( systemProperties ,    instanceOf ( ReadOnlySystemAttributesMap . class )  )  ;", "assertThat (  (  ( String )     ( systemProperties . get ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ NAME )  )  )  ,    equalTo ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ VALUE )  )  ;", "assertThat ( systemProperties . get ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME )  ,    equalTo ( null )  )  ;", "assertThat ( systemProperties . get ( StandardEnvironmentTests . STRING _ PROPERTY _ NAME )  ,    nullValue (  )  )  ;", "try    {", "systemProperties . get ( StandardEnvironmentTests . NON _ STRING _ PROPERTY _ NAME )  ;", "fail (  \" Expected   IllegalArgumentException   when   searching   with   non - string   key   against   ReadOnlySystemAttributesMap \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "System . setSecurityManager ( oldSecurityManager )  ;", "System . clearProperty ( StandardEnvironmentTests . ALLOWED _ PROPERTY _ NAME )  ;", "System . clearProperty ( StandardEnvironmentTests . DISALLOWED _ PROPERTY _ NAME )  ;", "System . getProperties (  )  . remove ( StandardEnvironmentTests . STRING _ PROPERTY _ NAME )  ;", "System . getProperties (  )  . remove ( StandardEnvironmentTests . NON _ STRING _ PROPERTY _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getSystemProperties_withAndWithoutSecurityManager"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableEnvironment   child    =    new   StandardEnvironment (  )  ;", "child . setActiveProfiles (  \" c 1  \"  ,     \" c 2  \"  )  ;", "child . getPropertySources (  )  . addLast ( new   MockPropertySource (  \" childMock \"  )  . withProperty (  \" childKey \"  ,     \" childVal \"  )  . withProperty (  \" bothKey \"  ,     \" childBothVal \"  )  )  ;", "ConfigurableEnvironment   parent    =    new   StandardEnvironment (  )  ;", "parent . setActiveProfiles (  \" p 1  \"  ,     \" p 2  \"  )  ;", "parent . getPropertySources (  )  . addLast ( new   MockPropertySource (  \" parentMock \"  )  . withProperty (  \" parentKey \"  ,     \" parentVal \"  )  . withProperty (  \" bothKey \"  ,     \" parentBothVal \"  )  )  ;", "assertThat ( child . getProperty (  \" childKey \"  )  ,    is (  \" childVal \"  )  )  ;", "assertThat ( child . getProperty (  \" parentKey \"  )  ,    nullValue (  )  )  ;", "assertThat ( child . getProperty (  \" bothKey \"  )  ,    is (  \" childBothVal \"  )  )  ;", "assertThat ( parent . getProperty (  \" childKey \"  )  ,    nullValue (  )  )  ;", "assertThat ( parent . getProperty (  \" parentKey \"  )  ,    is (  \" parentVal \"  )  )  ;", "assertThat ( parent . getProperty (  \" bothKey \"  )  ,    is (  \" parentBothVal \"  )  )  ;", "assertThat ( child . getActiveProfiles (  )  ,    equalTo ( new   String [  ]  {     \" c 1  \"  ,     \" c 2  \"     }  )  )  ;", "assertThat ( parent . getActiveProfiles (  )  ,    equalTo ( new   String [  ]  {     \" p 1  \"  ,     \" p 2  \"     }  )  )  ;", "child . merge ( parent )  ;", "assertThat ( child . getProperty (  \" childKey \"  )  ,    is (  \" childVal \"  )  )  ;", "assertThat ( child . getProperty (  \" parentKey \"  )  ,    is (  \" parentVal \"  )  )  ;", "assertThat ( child . getProperty (  \" bothKey \"  )  ,    is (  \" childBothVal \"  )  )  ;", "assertThat ( parent . getProperty (  \" childKey \"  )  ,    nullValue (  )  )  ;", "assertThat ( parent . getProperty (  \" parentKey \"  )  ,    is (  \" parentVal \"  )  )  ;", "assertThat ( parent . getProperty (  \" bothKey \"  )  ,    is (  \" parentBothVal \"  )  )  ;", "assertThat ( child . getActiveProfiles (  )  ,    equalTo ( new   String [  ]  {     \" c 1  \"  ,     \" c 2  \"  ,     \" p 1  \"  ,     \" p 2  \"     }  )  )  ;", "assertThat ( parent . getActiveProfiles (  )  ,    equalTo ( new   String [  ]  {     \" p 1  \"  ,     \" p 2  \"     }  )  )  ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "MutablePropertySources   sources    =    env . getPropertySources (  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named ( StandardEnvironment . SYSTEM _ PROPERTIES _ PROPERTY _ SOURCE _ NAME )  )  ,    equalTo (  0  )  )  ;", "assertThat ( sources . precedenceOf ( PropertySource . named ( StandardEnvironment . SYSTEM _ ENVIRONMENT _ PROPERTY _ SOURCE _ NAME )  )  ,    equalTo (  1  )  )  ;", "assertThat ( sources . size (  )  ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["propertySourceOrder"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "MutablePropertySources   sources    =    env . getPropertySources (  )  ;", "assertThat ( sources . get ( StandardEnvironment . SYSTEM _ ENVIRONMENT _ PROPERTY _ SOURCE _ NAME )  ,    instanceOf ( SystemEnvironmentPropertySource . class )  )  ;", "}", "METHOD_END"], "methodName": ["propertySourceTypes"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( environment . getDefaultProfiles (  )  ,    equalTo ( new   String [  ]  {    AbstractEnvironment . RESERVED _ DEFAULT _ PROFILE _ NAME    }  )  )  ;", "System . setProperty ( AbstractEnvironment . DEFAULT _ PROFILES _ PROPERTY _ NAME ,     \" d 0  \"  )  ;", "assertThat ( environment . getDefaultProfiles (  )  ,    equalTo ( new   String [  ]  {     \" d 0  \"     }  )  )  ;", "environment . setDefaultProfiles (  \" d 1  \"  ,     \" d 2  \"  )  ;", "assertThat ( environment . getDefaultProfiles (  )  ,    equalTo ( new   String [  ]  {     \" d 1  \"  ,     \" d 2  \"     }  )  )  ;", "System . getProperties (  )  . remove ( AbstractEnvironment . DEFAULT _ PROFILES _ PROPERTY _ NAME )  ;", "}", "METHOD_END"], "methodName": ["reservedDefaultProfile"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setActiveProfiles (  \" local \"  ,     \" embedded \"  )  ;", "String [  ]    activeProfiles    =    environment . getActiveProfiles (  )  ;", "assertThat ( Arrays . asList ( activeProfiles )  ,    hasItems (  \" local \"  ,     \" embedded \"  )  )  ;", "assertThat ( activeProfiles . length ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["setActiveProfiles"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setActiveProfiles (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["setActiveProfiles_withEmptyProfile"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setActiveProfiles (  \" p 1  \"  ,     \"  ! p 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["setActiveProfiles_withNotOperator"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setActiveProfiles (  (  ( String )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["setActiveProfiles_withNullProfile"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setActiveProfiles (  (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["setActiveProfiles_withNullProfileArray"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setDefaultProfiles (  )  ;", "assertThat ( environment . getDefaultProfiles (  )  . length ,    is (  0  )  )  ;", "environment . setDefaultProfiles (  \" pd 1  \"  )  ;", "assertThat ( Arrays . asList ( environment . getDefaultProfiles (  )  )  ,    hasItem (  \" pd 1  \"  )  )  ;", "environment . setDefaultProfiles (  \" pd 2  \"  ,     \" pd 3  \"  )  ;", "assertThat ( Arrays . asList ( environment . getDefaultProfiles (  )  )  ,    not ( hasItem (  \" pd 1  \"  )  )  )  ;", "assertThat ( Arrays . asList ( environment . getDefaultProfiles (  )  )  ,    hasItems (  \" pd 2  \"  ,     \" pd 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultProfiles"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setDefaultProfiles (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultProfiles_withEmptyProfile"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setDefaultProfiles (  \" d 1  \"  ,     \"  ! d 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultProfiles_withNotOperator"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setDefaultProfiles (  (  ( String )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultProfiles_withNullProfile"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "environment . setDefaultProfiles (  (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultProfiles_withNullProfileArray"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "SpringProperties . setFlag (  \" spring . getenv . ignore \"  )  ;", "assertTrue ( environment . getSystem (  )  . isEmpty (  )  )  ;", "SpringProperties . setProperty (  \" spring . getenv . ignore \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["suppressGetenvAccessThroughSpringFlag"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "SpringProperties . setProperty (  \" spring . getenv . ignore \"  ,     \" true \"  )  ;", "assertTrue ( environment . getSystem (  )  . isEmpty (  )  )  ;", "SpringProperties . setProperty (  \" spring . getenv . ignore \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["suppressGetenvAccessThroughSpringProperty"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" spring . getenv . ignore \"  ,     \" true \"  )  ;", "assertTrue ( environment . getSystem (  )  . isEmpty (  )  )  ;", "System . clearProperty (  \" spring . getenv . ignore \"  )  ;", "}", "METHOD_END"], "methodName": ["suppressGetenvAccessThroughSystemProperty"], "fileName": "org.springframework.core.env.StandardEnvironmentTests"}, {"methodBody": ["METHOD_START", "{", "if    ( containsKey ( name )  )     {", "return   name ;", "}", "St   noDotName    =    name . replace (  '  .  '  ,     '  _  '  )  ;", "if    (  (  !  ( name . equals ( noDotName )  )  )     &  &     ( containsKey ( noDotName )  )  )     {", "return   noDotName ;", "}", "St   noHyphenName    =    name . replace (  '  -  '  ,     '  _  '  )  ;", "if    (  (  !  ( name . equals ( noHyphenName )  )  )     &  &     ( containsKey ( noHyphenName )  )  )     {", "return   noHyphenName ;", "}", "St   noDotNoHyphenName    =    noDotName . replace (  '  -  '  ,     '  _  '  )  ;", "if    (  (  !  ( noDotName . equals ( noDotNoHyphenName )  )  )     &  &     ( containsKey ( noDotNoHyphenName )  )  )     {", "return   noDotNoHyphenName ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["checkPropertyName"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySource"}, {"methodBody": ["METHOD_START", "{", "return   isSecurityManagerPresent (  )     ?    this . source . keySet (  )  . contains ( name )     :    this . source . containsKey ( name )  ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySource"}, {"methodBody": ["METHOD_START", "{", "return    ( System . getSecurityManager (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isSecurityManagerPresent"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Property   name   must   not   be   null \"  )  ;", "String   resolvedName    =    checkPropertyName ( name )  ;", "if    ( resolvedName    !  =    null )     {", "return   resolvedName ;", "}", "String   uppercasedName    =    name . toUpperCase (  )  ;", "if    (  !  ( name . equals ( uppercasedName )  )  )     {", "resolvedName    =    checkPropertyName ( uppercasedName )  ;", "if    ( resolvedName    !  =    null )     {", "return   resolvedName ;", "}", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["resolvePropertyName"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySource"}, {"methodBody": ["METHOD_START", "{", "assertThat ( ps . containsProperty (  \" a . key \"  )  ,    equalTo ( false )  )  ;", "assertThat ( ps . ge (  \" a . key \"  )  ,    equalTo ( null )  )  ;", "}", "METHOD_END"], "methodName": ["none"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "envMap . put (  \" a . key \"  ,     \" a . value \"  )  ;", "assertThat ( ps . containsProperty (  \" a . key \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . ge (  \" a . key \"  )  ,    equalTo (  (  ( Object )     (  \" a . value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["normalWithPeriod"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "envMap . put (  \" akey \"  ,     \" avalue \"  )  ;", "assertThat ( ps . containsProperty (  \" akey \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . ge (  \" akey \"  )  ,    equalTo (  (  ( Object )     (  \" avalue \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["normalWithoutPeriod"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "envMap    =    new   HashMap <  >  (  )  ;", "ps    =    new    (  \" sysEnv \"  ,    envMap )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "envMap . put (  \" a _ key \"  ,     \" a _ value \"  )  ;", "envMap . put (  \" a . key \"  ,     \" a . value \"  )  ;", "assertThat ( ps . ge (  \" a _ key \"  )  ,    equalTo (  (  ( Object )     (  \" a _ value \"  )  )  )  )  ;", "assertThat ( ps . ge (  \" a . key \"  )  ,    equalTo (  (  ( Object )     (  \" a . value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withBothPeriodAndUnderscore"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "envMap    =    new   HashMap < String ,    Object >  (  )     {", "@ Override", "public   boolean   containsKey ( Object   key )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "@ Override", "public   Set < String >    keySet (  )     {", "return   new   HashSet <  >  ( super . keySet (  )  )  ;", "}", "}  ;", "envMap . put (  \" A _ KEY \"  ,     \" a _ value \"  )  ;", "ps    =    new    (  \" sysEnv \"  ,    envMap )     {", "@ Override", "protected   boolean   isSecurityManagerPresent (  )     {", "return   true ;", "}", "}  ;", "assertThat ( ps . containsProperty (  \" A _ KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . getProperty (  \" A _ KEY \"  )  ,    equalTo (  (  ( Object )     (  \" a _ value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withSecurityConstraints"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "envMap . put (  \" a _ key \"  ,     \" a _ value \"  )  ;", "assertThat ( ps . containsProperty (  \" a _ key \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" a . key \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . ge (  \" a _ key \"  )  ,    equalTo (  (  ( Object )     (  \" a _ value \"  )  )  )  )  ;", "assertThat ( ps . ge (  \" a . key \"  )  ,    equalTo (  (  ( Object )     (  \" a _ value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withUnderscore"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "envMap . put (  \" A _ KEY \"  ,     \" a _ value \"  )  ;", "envMap . put (  \" A _ LONG _ KEY \"  ,     \" a _ long _ value \"  )  ;", "envMap . put (  \" A _ DOT . KEY \"  ,     \" a _ dot _ value \"  )  ;", "envMap . put (  \" A _ HYPHEN - KEY \"  ,     \" a _ hyphen _ value \"  )  ;", "assertThat ( ps . containsProperty (  \" A _ KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A . KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A - KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" a _ key \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" a . key \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" a - key \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A _ LONG _ KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A . LONG . KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A - LONG - KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A . LONG - KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A - LONG . KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A _ long _ KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A . long . KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A - long - KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A . long - KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A - long . KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A _ DOT . KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A - DOT . KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A _ dot . KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A - dot . KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A _ HYPHEN - KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A . HYPHEN - KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A _ hyphen - KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . containsProperty (  \" A . hyphen - KEY \"  )  ,    equalTo ( true )  )  ;", "assertThat ( ps . ge (  \" A _ KEY \"  )  ,    equalTo (  \" a _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A . KEY \"  )  ,    equalTo (  \" a _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A - KEY \"  )  ,    equalTo (  \" a _ value \"  )  )  ;", "assertThat ( ps . ge (  \" a _ key \"  )  ,    equalTo (  \" a _ value \"  )  )  ;", "assertThat ( ps . ge (  \" a . key \"  )  ,    equalTo (  \" a _ value \"  )  )  ;", "assertThat ( ps . ge (  \" a - key \"  )  ,    equalTo (  \" a _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A _ LONG _ KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A . LONG . KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A - LONG - KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A . LONG - KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A - LONG . KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A _ long _ KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A . long . KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A - long - KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A . long - KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A - long . KEY \"  )  ,    equalTo (  \" a _ long _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A _ DOT . KEY \"  )  ,    equalTo (  \" a _ dot _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A - DOT . KEY \"  )  ,    equalTo (  \" a _ dot _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A _ dot . KEY \"  )  ,    equalTo (  \" a _ dot _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A - dot . KEY \"  )  ,    equalTo (  \" a _ dot _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A _ HYPHEN - KEY \"  )  ,    equalTo (  \" a _ hyphen _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A . HYPHEN - KEY \"  )  ,    equalTo (  \" a _ hyphen _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A _ hyphen - KEY \"  )  ,    equalTo (  \" a _ hyphen _ value \"  )  )  ;", "assertThat ( ps . ge (  \" A . hyphen - KEY \"  )  ,    equalTo (  \" a _ hyphen _ value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withUppercase"], "fileName": "org.springframework.core.env.SystemEnvironmentPropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "con . setRequestMethod (  \" HEAD \"  )  ;", "}", "METHOD_END"], "methodName": ["customizeConnection"], "fileName": "org.springframework.core.io.AbstractFileResolvingResource"}, {"methodBody": ["METHOD_START", "{", "ResourceUtils . useCachesIfNecessary ( con )  ;", "if    ( con   instanceof   HttpURLConnection )     {", "customizeConnection (  (  ( HttpURLConnection )     ( con )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["customizeConnection"], "fileName": "org.springframework.core.io.AbstractFileResolvingResource"}, {"methodBody": ["METHOD_START", "{", "if    ( uri . getScheme (  )  . startsWith ( ResourceUtils . URL _ PROTOCOL _ VFS )  )     {", "return    . VfsResourceDelegate . getResource ( uri )  . getFile (  )  ;", "}", "return   ResourceUtils . getFile ( uri ,    getDescription (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.springframework.core.io.AbstractFileResolvingResource"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( uri . getScheme (  )  . startsWith ( ResourceUtils . URL _ PROTOCOL _ VFS )  )     {", "return    . VfsResourceDelegate . getResource ( uri )  . isFile (  )  ;", "}", "return   ResourceUtils . URL _ PROTOCOL _ FILE . equals ( uri . getScheme (  )  )  ;", "}    catch    ( IOException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isFile"], "fileName": "org.springframework.core.io.AbstractFileResolvingResource"}, {"methodBody": ["METHOD_START", "{", "return   getFile (  )  ;", "}", "METHOD_END"], "methodName": ["getFileForLastModifiedCheck"], "fileName": "org.springframework.core.io.AbstractResource"}, {"methodBody": ["METHOD_START", "{", "return   this . byteArray ;", "}", "METHOD_END"], "methodName": ["getByteArray"], "fileName": "org.springframework.core.io.ByteArrayResource"}, {"methodBody": ["METHOD_START", "{", "return    ( this . clazz )     !  =    null    ?    this . clazz . getClassLoader (  )     :    this . classLoader ;", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.springframework.core.io.ClassPathResource"}, {"methodBody": ["METHOD_START", "{", "return   this . path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.springframework.core.io.ClassPathResource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . clazz )     !  =    null )     {", "return   this . clazz . get ( this . path )  ;", "} else", "if    (  ( this . classLoader )     !  =    null )     {", "return   this . classLoader . get ( this . path )  ;", "} else    {", "return   ClassLoader . getSystem ( this . path )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveURL"], "fileName": "org.springframework.core.io.ClassPathResource"}, {"methodBody": ["METHOD_START", "{", "Matcher   matcher    =    ClassPathResourceTests . DESCRIPTION _ PATTERN . matcher ( resource . getDescription (  )  )  ;", "assertTrue ( matcher . matches (  )  )  ;", "assertEquals (  1  ,    matcher . groupCount (  )  )  ;", "String   match    =    matcher . group (  1  )  ;", "assertEquals ( expectedPath ,    match )  ;", "}", "METHOD_END"], "methodName": ["assertDescriptionContainsExpectedPath"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "resource . getInputStream (  )  ;", "fail (  (  \" FileNotFoundException   expected   for   resource :     \"     +    resource )  )  ;", "}    catch    ( IOException   ex )     {", "assertThat ( ex ,    instanceOf ( FileNotFoundException . class )  )  ;", "assertThat ( ex . getMessage (  )  ,    containsString (  . FQ _ RESOURCE _ PATH )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertExceptionContainsFullyQualifiedPath"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertExceptionContainsFullyQualifiedPath ( new   ClassPathResource ( ClassPathResourceTests . NONEXISTENT _ RESOURCE _ NAME ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["classLiteralConstructorRaisesExceptionWithFullyQualifiedPath"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertExceptionContainsFullyQualifiedPath ( new   ClassPathResource ( ClassPathResourceTests . FQ _ RESOURCE _ PATH ,    getClass (  )  . getClassLoader (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["classLoaderConstructorRaisesExceptionWithFullyQualifiedPath"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" test . html \"  ,    new   ClassPathResource (  \"  / test . html \"  )  . getPath (  )  )  ;", "assertEquals (  \" test . html \"  ,     (  ( ClassPathResource )     ( new   ClassPathResource (  \"  \"  )  . createRelative (  \"  / test . html \"  )  )  )  . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["dropLeadingSlashForClassLoaderAccess"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertDescriptionContainsExpectedPath ( new   ClassPathResource ( ClassPathResourceTests . NONEXISTENT _ RESOURCE _ NAME ,    getClass (  )  )  ,    ClassPathResourceTests . FQ _ RESOURCE _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getDescriptionWithClassLiteralConstructor"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertDescriptionContainsExpectedPath ( new   ClassPathResource ( ClassPathResourceTests . FQ _ RESOURCE _ PATH _ WITH _ LEADING _ SLASH ,    getClass (  )  )  ,    ClassPathResourceTests . FQ _ RESOURCE _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getDescriptionWithClassLiteralConstructorAndLeadingSlash"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertDescriptionContainsExpectedPath ( new   ClassPathResource ( ClassPathResourceTests . FQ _ RESOURCE _ PATH ,    getClass (  )  . getClassLoader (  )  )  ,    ClassPathResourceTests . FQ _ RESOURCE _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getDescriptionWithClassLoaderConstructor"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertDescriptionContainsExpectedPath ( new   ClassPathResource ( ClassPathResourceTests . FQ _ RESOURCE _ PATH _ WITH _ LEADING _ SLASH ,    getClass (  )  . getClassLoader (  )  )  ,    ClassPathResourceTests . FQ _ RESOURCE _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getDescriptionWithClassLoaderConstructorAndLeadingSlash"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertDescriptionContainsExpectedPath ( new   ClassPathResource ( ClassPathResourceTests . FQ _ RESOURCE _ PATH )  ,    ClassPathResourceTests . FQ _ RESOURCE _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getDescriptionWithStringConstructor"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertDescriptionContainsExpectedPath ( new   ClassPathResource ( ClassPathResourceTests . FQ _ RESOURCE _ PATH _ WITH _ LEADING _ SLASH )  ,    ClassPathResourceTests . FQ _ RESOURCE _ PATH )  ;", "}", "METHOD_END"], "methodName": ["getDescriptionWithStringConstructorAndLeadingSlash"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  / test . html \"  ,    new   ClassPathResource (  \"  / test . html \"  ,    getClass (  )  )  . getPath (  )  )  ;", "assertEquals (  \"  / test . html \"  ,     (  ( ClassPathResource )     ( new   ClassPathResource (  \"  \"  ,    getClass (  )  )  . createRelative (  \"  / test . html \"  )  )  )  . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["preserveLeadingSlashForClassRelativeAccess"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertExceptionContainsFullyQualifiedPath ( new   ClassPathResource ( ClassPathResourceTests . FQ _ RESOURCE _ PATH )  )  ;", "}", "METHOD_END"], "methodName": ["stringConstructorRaisesExceptionWithFullyQualifiedPath"], "fileName": "org.springframework.core.io.ClassPathResourceTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resolver ,     \" ProtocolResolver   must   not   be   null \"  )  ;", "this . protocolResolvers . add ( resolver )  ;", "}", "METHOD_END"], "methodName": ["addProtocolResolver"], "fileName": "org.springframework.core.io.DefaultResourceLoader"}, {"methodBody": ["METHOD_START", "{", "this . resourceCaches . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearResourceCaches"], "fileName": "org.springframework.core.io.DefaultResourceLoader"}, {"methodBody": ["METHOD_START", "{", "return   this . protocolResolvers ;", "}", "METHOD_END"], "methodName": ["getProtocolResolvers"], "fileName": "org.springframework.core.io.DefaultResourceLoader"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResourceLoader . ClassPathContextResource ( path ,    getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["getResourceByPath"], "fileName": "org.springframework.core.io.DefaultResourceLoader"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Map < Resource ,    T >  )     ( this . resourceCaches . computeIfAbsent ( valueType ,     (    key )     -  >    new   ConcurrentHashMap <  >  (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getResourceCache"], "fileName": "org.springframework.core.io.DefaultResourceLoader"}, {"methodBody": ["METHOD_START", "{", "this . classLoader    =    classLoader ;", "}", "METHOD_END"], "methodName": ["setClassLoader"], "fileName": "org.springframework.core.io.DefaultResourceLoader"}, {"methodBody": ["METHOD_START", "{", "return   this . path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.springframework.core.io.FileSystemResource"}, {"methodBody": ["METHOD_START", "{", "return   this . path . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.springframework.core.io.PathResource"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "File   file    =    new   File ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . contentLength (  )  ,    equalTo ( file . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLength"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ DIR )  ;", "File   file    =    new   File ( PathResourceTests . TEST _ DIR )  ;", "assertThat ( resource . contentLength (  )  ,    equalTo ( file . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contentLengthForDirectory"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "Path   path    =    Paths . get ( PathResourceTests . TEST _ FILE )  ;", "PathResource   resource    =    new   PathResource ( path )  ;", "assertThat ( resource . getPath (  )  ,    equalTo ( PathResourceTests . TEST _ FILE )  )  ;", "}", "METHOD_END"], "methodName": ["createFromPath"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . getPath (  )  ,    equalTo ( PathResourceTests . TEST _ FILE )  )  ;", "}", "METHOD_END"], "methodName": ["createFromString"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File ( PathResourceTests . TEST _ FILE )  ;", "PathResource   resource    =    new   PathResource ( file . toURI (  )  )  ;", "assertThat ( resource . getPath (  )  ,    equalTo ( file . getAbsoluteFile (  )  . toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createFromUri"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   PathResource ( PathResourceTests . TEST _ DIR )  . createRelative (  \" example . properties \"  )  ;", "assertThat ( resource ,    equalTo (  (  ( Resource )     ( new   PathResource ( PathResourceTests . TEST _ FILE )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createRelativeFromDir"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  . createRelative (  \"  .  .  / example . properties \"  )  ;", "assertThat ( resource ,    equalTo (  (  ( Resource )     ( new   PathResource ( PathResourceTests . TEST _ FILE )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createRelativeFromFile"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . getDescription (  )  ,    containsString (  \" path    [  \"  )  )  ;", "assertThat ( resource . getDescription (  )  ,    containsString ( PathResourceTests . TEST _ FILE )  )  ;", "}", "METHOD_END"], "methodName": ["description"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ DIR )  ;", "assertThat ( resource . exists (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["dirExists"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ DIR )  ;", "assertThat ( resource . isReadable (  )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["directoryIsNotReadable"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ DIR )  ;", "assertThat ( resource . isWritable (  )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["directoryIsNotWritable"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ DIR )  ;", "thrown . expect ( FileNotFoundException . class )  ;", "resource . getOutputStream (  )  ;", "}", "METHOD_END"], "methodName": ["directoryOutputStream"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . NON _ EXISTING _ FILE )  ;", "assertThat ( resource . isReadable (  )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistIsNotReadable"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "File   file    =    temporaryFolder . newFile (  \" test \"  )  ;", "file . delete (  )  ;", "resource    =    new    ( file . toPath (  )  )  ;", "FileCopyUtils . copy (  \" test \"  . getBytes (  )  ,    resource . getOutputStream (  )  )  ;", "assertThat ( resource . contentLength (  )  ,    equalTo (  4 L )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotExistOutputStream"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . NON _ EXISTING _ FILE )  ;", "assertThat ( resource . exists (  )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["fileDoesNotExist"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . exists (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["fileExists"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . isReadable (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["fileIsReadable"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . isWritable (  )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["fileIsWritable"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . getFilename (  )  ,    equalTo (  \" example . properties \"  )  )  ;", "}", "METHOD_END"], "methodName": ["filename"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "File   file    =    new   File ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . getFile (  )  . getAbsoluteFile (  )  ,    equalTo ( file . getAbsoluteFile (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "Path   path    =    mock ( Path . class )  ;", "given ( path . normalize (  )  )  . willReturn ( path )  ;", "given ( path . toFile (  )  )  . willThrow ( new   UnsupportedOperationException (  )  )  ;", "resource    =    new    ( path )  ;", "thrown . expect ( FileNotFoundException . class )  ;", "resource . getFile (  )  ;", "}", "METHOD_END"], "methodName": ["getFileUnsupported"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "byte [  ]    bytes    =    FileCopyUtils . copyToByteArray ( resource . getInputStream (  )  )  ;", "assertThat ( bytes . length ,    greaterThan (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["getInputStream"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . NON _ EXISTING _ FILE )  ;", "thrown . expect ( FileNotFoundException . class )  ;", "resource . getInputStream (  )  ;", "}", "METHOD_END"], "methodName": ["getInputStreamDoesNotExist"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ DIR )  ;", "thrown . expect ( FileNotFoundException . class )  ;", "resource . getInputStream (  )  ;", "}", "METHOD_END"], "methodName": ["getInputStreamForDir"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ DIR )  ;", "assertThat ( resource . getPath (  )  ,    equalTo ( PathResourceTests . TEST _ DIR )  )  ;", "}", "METHOD_END"], "methodName": ["getPathForDir"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . getPath (  )  ,    equalTo ( PathResourceTests . TEST _ FILE )  )  ;", "}", "METHOD_END"], "methodName": ["getPathForFile"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "ReadableByteChannel   channel    =    null ;", "try    {", "channel    =    resource . readableChannel (  )  ;", "ByteBuffer   buffer    =    ByteBuffer . allocate (  (  ( int )     ( resource . contentLength (  )  )  )  )  ;", "channel . read ( buffer )  ;", "buffer . rewind (  )  ;", "assertThat ( buffer . limit (  )  ,    greaterThan (  0  )  )  ;", "}    finally    {", "if    ( channel    !  =    null )     {", "channel . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getReadableByteChannel"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . NON _ EXISTING _ FILE )  ;", "thrown . expect ( FileNotFoundException . class )  ;", "resource . readableChannel (  )  ;", "}", "METHOD_END"], "methodName": ["getReadableByteChannelDoesNotExist"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ DIR )  ;", "try    {", "resource . readableChannel (  )  ;", "}    catch    ( AccessDeniedException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["getReadableByteChannelForDir"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . getURI (  )  . toString (  )  ,    Matchers . endsWith (  \" core / io / example . properties \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "assertThat ( resource . getURL (  )  . toString (  )  ,    Matchers . endsWith (  \" core / io / example . properties \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( temporaryFolder . newFile (  \" test \"  )  . toPath (  )  )  ;", "ByteBuffer   buffer    =    ByteBuffer . wrap (  \" test \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "WritableByteChannel   channel    =    null ;", "try    {", "channel    =    resource . writableChannel (  )  ;", "channel . write ( buffer )  ;", "}    finally    {", "if    ( channel    !  =    null )     {", "channel . close (  )  ;", "}", "}", "assertThat ( resource . contentLength (  )  ,    equalTo (  4 L )  )  ;", "}", "METHOD_END"], "methodName": ["getWritableChannel"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( PathResourceTests . TEST _ FILE )  ;", "File   file    =    new   File ( PathResourceTests . TEST _ FILE )  ;", "assertThat (  (  ( resource . lastModified (  )  )     /     1  0  0  0  )  ,    equalTo (  (  ( file . lastModified (  )  )     /     1  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["lastModified"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Path   must   not   be   null \"  )  ;", "new    (  (  ( Path )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullPath"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Path   must   not   be   null \"  )  ;", "new    (  (  ( String )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullPathString"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" URI   must   not   be   null \"  )  ;", "new    (  (  ( URI )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullUri"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "PathResource   resource    =    new   PathResource ( temporaryFolder . newFile (  \" test \"  )  . toPath (  )  )  ;", "FileCopyUtils . copy (  \" test \"  . getBytes ( StandardCharsets . UTF _  8  )  ,    resource . getOutputStream (  )  )  ;", "assertThat ( resource . contentLength (  )  ,    equalTo (  4 L )  )  ;", "}", "METHOD_END"], "methodName": ["outputStream"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "return   string . replace (  '  /  '  ,    File . separatorChar )  ;", "}", "METHOD_END"], "methodName": ["platformPath"], "fileName": "org.springframework.core.io.PathResourceTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isFile"], "fileName": "org.springframework.core.io.Resource"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isOpen"], "fileName": "org.springframework.core.io.Resource"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isReadable"], "fileName": "org.springframework.core.io.Resource"}, {"methodBody": ["METHOD_START", "{", "return   Channels . newChannel ( getInputStream (  )  )  ;", "}", "METHOD_END"], "methodName": ["readableChannel"], "fileName": "org.springframework.core.io.Resource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . propertyResolver )     =  =    null )     {", "this . propertyResolver    =    new   StandardEnvironment (  )  ;", "}", "return   this . ignoreUnresolvablePlaceholders    ?    this . propertyResolver . resolvePlaceholders ( path )     :    this . propertyResolver . resolveRequiredPlaceholders ( path )  ;", "}", "METHOD_END"], "methodName": ["resolvePath"], "fileName": "org.springframework.core.io.ResourceEditor"}, {"methodBody": ["METHOD_START", "{", "new   ResourceEditor ( null ,    null )  ;", "}", "METHOD_END"], "methodName": ["ctorWithNullCtorArgs"], "fileName": "org.springframework.core.io.ResourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    new   ResourceEditor (  )  ;", "editor . setAsText ( null )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setAndGetAsTextWithNull"], "fileName": "org.springframework.core.io.ResourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    new   ResourceEditor (  )  ;", "editor . setAsText (  \"        \"  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setAndGetAsTextWithWhitespaceResource"], "fileName": "org.springframework.core.io.ResourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    new   ResourceEditor (  )  ;", "editor . setAsText (  \" classpath : org / springframework / core / io /  . class \"  )  ;", "Resource   resource    =     (  ( Resource )     ( editor . getValue (  )  )  )  ;", "assertNotNull ( resource )  ;", "assertTrue ( resource . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["sunnyDay"], "fileName": "org.springframework.core.io.ResourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    new   ResourceEditor ( new   DefaultResourceLoader (  )  ,    new   StandardEnvironment (  )  ,    false )  ;", "System . setProperty (  \" test . prop \"  ,     \" foo \"  )  ;", "try    {", "editor . setAsText (  \"  $  { test . prop }  -  $  { bar }  \"  )  ;", "Resource   resolved    =     (  ( Resource )     ( editor . getValue (  )  )  )  ;", "assertEquals (  \" foo -  $  { bar }  \"  ,    resolved . getFilename (  )  )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" test . prop \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testStrictSystemPropertyReplacement"], "fileName": "org.springframework.core.io.ResourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    new   ResourceEditor (  )  ;", "System . setProperty (  \" test . prop \"  ,     \" foo \"  )  ;", "try    {", "editor . setAsText (  \"  $  { test . prop }  -  $  { bar }  \"  )  ;", "Resource   resolved    =     (  ( Resource )     ( editor . getValue (  )  )  )  ;", "assertEquals (  \" foo -  $  { bar }  \"  ,    resolved . getFilename (  )  )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" test . prop \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSystemPropertyReplacement"], "fileName": "org.springframework.core.io.ResourceEditorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Resource . class \"  ,    resource . getFilename (  )  )  ;", "assertTrue ( resource . getURL (  )  . getFile (  )  . endsWith (  \" Resource . class \"  )  )  ;", "Resource   relative 1     =    resource . createRelative (  \" ClassPathResource . class \"  )  ;", "assertEquals (  \" ClassPathResource . class \"  ,    relative 1  . getFilename (  )  )  ;", "assertTrue ( relative 1  . getURL (  )  . getFile (  )  . endsWith (  \" ClassPathResource . class \"  )  )  ;", "assertTrue ( relative 1  . exists (  )  )  ;", "Resource   relative 2     =    resource . createRelative (  \" support / ResourcePatternResolver . class \"  )  ;", "assertEquals (  \" ResourcePatternResolver . class \"  ,    relative 2  . getFilename (  )  )  ;", "assertTrue ( relative 2  . getURL (  )  . getFile (  )  . endsWith (  \" ResourcePatternResolver . class \"  )  )  ;", "assertTrue ( relative 2  . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =     \" test - resource \"  ;", "resource    =    new   Abstract (  )     {", "@ Override", "public   String   getDescription (  )     {", "return   name ;", "}", "@ Override", "public   InputStream   getInputStream (  )    throws   IOException    {", "throw   new   FileNotFoundException (  )  ;", "}", "}  ;", "try    {", "resource . getURL (  )  ;", "fail (  \" FileNotFoundException   should   have   been   thrown \"  )  ;", "}    catch    ( FileNotFoundException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains ( name )  )  ;", "}", "try    {", "resource . getFile (  )  ;", "fail (  \" FileNotFoundException   should   have   been   thrown \"  )  ;", "}    catch    ( FileNotFoundException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains ( name )  )  ;", "}", "try    {", "resource . createRelative (  \"  / testing \"  )  ;", "fail (  \" FileNotFoundException   should   have   been   thrown \"  )  ;", "}    catch    ( FileNotFoundException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains ( name )  )  ;", "}", "assertThat ( resource . getFilename (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAbstractResourceExceptions"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ByteArrayResource (  \" testString \"  . getBytes (  )  )  ;", "assertTrue ( resource . exists (  )  )  ;", "assertFalse ( resource . isOpen (  )  )  ;", "String   content    =    FileCopyUtils . copyToString ( new   InputStreamReader ( resource . getInputStream (  )  )  )  ;", "assertEquals (  \" testString \"  ,    content )  ;", "assertEquals ( resource ,    new   ByteArrayResource (  \" testString \"  . getBytes (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testByteArrayResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ByteArrayResource (  \" testString \"  . getBytes (  )  ,     \" my   description \"  )  ;", "assertTrue ( resource . exists (  )  )  ;", "assertFalse ( resource . isOpen (  )  )  ;", "String   content    =    FileCopyUtils . copyToString ( new   InputStreamReader ( resource . getInputStream (  )  )  )  ;", "assertEquals (  \" testString \"  ,    content )  ;", "assertTrue ( resource . getDescription (  )  . contains (  \" my   description \"  )  )  ;", "assertEquals ( resource ,    new   ByteArrayResource (  \" testString \"  . getBytes (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testByteArrayResourceWithDescription"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ClassPathResource (  \" org / springframework / core / io / Resource . class \"  )  ;", "doTestResource ( resource )  ;", "Resource   resource 2     =    new   ClassPathResource (  \" org / springframework / core /  .  .  / core / io /  .  / Resource . class \"  )  ;", "assertEquals ( resource ,    resource 2  )  ;", "Resource   resource 3     =    new   ClassPathResource (  \" org / springframework / core /  \"  )  . createRelative (  \"  .  .  / core / io /  .  / Resource . class \"  )  ;", "assertEquals ( resource ,    resource 3  )  ;", "HashSet < Resource >    resources    =    new   HashSet <  >  (  )  ;", "resources . add ( resource )  ;", "resources . add ( resource 2  )  ;", "assertEquals (  1  ,    resources . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassPathResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ClassPathResource (  \" Resource . class \"  ,    getClass (  )  )  ;", "doTestResource ( resource )  ;", "assertEquals ( resource ,    new   ClassPathResource (  \" Resource . class \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassPathResourceWithClass"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ClassPathResource (  \" org / springframework / core / io / Resource . class \"  ,    getClass (  )  . getClassLoader (  )  )  ;", "doTestResource ( resource )  ;", "assertEquals ( resource ,    new   ClassPathResource (  \" org / springframework / core /  .  .  / core / io /  .  / Resource . class \"  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassPathResourceWithClassLoader"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ClassPathResource (  \" dir /  \"  )  ;", "Resource   relative    =    resource . createRelative (  \" subdir \"  )  ;", "assertEquals ( new   ClassPathResource (  \" dir / subdir \"  )  ,    relative )  ;", "}", "METHOD_END"], "methodName": ["testClassPathResourceWithRelativePath"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "AbstractResource   resource    =    new   AbstractResource (  )     {", "@ Override", "public   InputStream   getInputStream (  )     {", "return   new   ByteArrayInputStream ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  )  ;", "}", "@ Override", "public   String   getDescription (  )     {", "return    \"  \"  ;", "}", "}  ;", "assertThat ( resource . contentLength (  )  ,    is (  3 L )  )  ;", "}", "METHOD_END"], "methodName": ["testContentLength"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   FileSystemResource ( getClass (  )  . getResource (  \" Resource . class \"  )  . getFile (  )  )  ;", "doTestResource ( resource )  ;", "assertEquals ( new   FileSystemResource ( getClass (  )  . getResource (  \" Resource . class \"  )  . getFile (  )  )  ,    resource )  ;", "Resource   resource 2     =    new   FileSystemResource (  \" core / io / Resource . class \"  )  ;", "assertEquals ( resource 2  ,    new   FileSystemResource (  \" core /  .  .  / core / io /  .  / Resource . class \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFileSystemResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   FileSystemResource (  \" dir /  \"  )  ;", "Resource   relative    =    resource . createRelative (  \" subdir \"  )  ;", "assertEquals ( new   FileSystemResource (  \" dir / subdir \"  )  ,    relative )  ;", "}", "METHOD_END"], "methodName": ["testFileSystemResourceWithRelativePath"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathResource (  \" Resource . class \"  ,    getClass (  )  )  . createRelative (  \" X \"  )  . getInputStream (  )  ;", "}", "METHOD_END"], "methodName": ["testInputStreamNotFoundOnClassPathResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "new   FileSystemResource ( getClass (  )  . getResource (  \" Resource . class \"  )  . getFile (  )  )  . createRelative (  \" X \"  )  . getInputStream (  )  ;", "}", "METHOD_END"], "methodName": ["testInputStreamNotFoundOnFileSystemResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   is    =    new   ByteArrayInputStream (  \" testString \"  . getBytes (  )  )  ;", "resource    =    new   InputStream ( is )  ;", "assertTrue ( resource . exists (  )  )  ;", "assertTrue ( resource . isOpen (  )  )  ;", "String   content    =    FileCopyUtils . copyToString ( new   InputStreamReader ( resource . getInputStream (  )  )  )  ;", "assertEquals (  \" testString \"  ,    content )  ;", "assertEquals ( resource ,    new   InputStream ( is )  )  ;", "}", "METHOD_END"], "methodName": ["testInputStreamResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   is    =    new   ByteArrayInputStream (  \" testString \"  . getBytes (  )  )  ;", "resource    =    new   InputStream ( is ,     \" my   description \"  )  ;", "assertTrue ( resource . exists (  )  )  ;", "assertTrue ( resource . isOpen (  )  )  ;", "String   content    =    FileCopyUtils . copyToString ( new   InputStreamReader ( resource . getInputStream (  )  )  )  ;", "assertEquals (  \" testString \"  ,    content )  ;", "assertTrue ( resource . getDescription (  )  . contains (  \" my   description \"  )  )  ;", "assertEquals ( resource ,    new   InputStream ( is )  )  ;", "}", "METHOD_END"], "methodName": ["testInputStreamResourceWithDescription"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   UrlResource (  \" http :  /  / www . springframework . org \"  )  ;", "assertTrue ( resource . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonFileResourceExists"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   FileSystemResource ( getClass (  )  . getResource (  \" Resource . class \"  )  . getFile (  )  )  ;", "ReadableByteChannel   channel    =    null ;", "try    {", "channel    =    resource . readableChannel (  )  ;", "ByteBuffer   buffer    =    ByteBuffer . allocate (  (  ( int )     ( resource . contentLength (  )  )  )  )  ;", "channel . read ( buffer )  ;", "buffer . rewind (  )  ;", "assertTrue (  (  ( buffer . limit (  )  )     >     0  )  )  ;", "}    finally    {", "if    ( channel    !  =    null )     {", "channel . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testReadableChannel"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathResource (  \" Resource . class \"  ,    getClass (  )  )  . createRelative (  \" X \"  )  . readableChannel (  )  ;", "}", "METHOD_END"], "methodName": ["testReadableChannelNotFoundOnClassPathResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "new   FileSystemResource ( getClass (  )  . getResource (  \" Resource . class \"  )  . getFile (  )  )  . createRelative (  \" X \"  )  . readableChannel (  )  ;", "}", "METHOD_END"], "methodName": ["testReadableChannelNotFoundOnFileSystemResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   UrlResource ( getClass (  )  . getResource (  \" Resource . class \"  )  )  ;", "doTestResource ( resource )  ;", "assertEquals ( new   UrlResource ( getClass (  )  . getResource (  \" Resource . class \"  )  )  ,    resource )  ;", "Resource   resource 2     =    new   UrlResource (  \" file : core / io / Resource . class \"  )  ;", "assertEquals ( resource 2  ,    new   UrlResource (  \" file : core /  .  .  / core / io /  .  / Resource . class \"  )  )  ;", "assertEquals (  \" test . txt \"  ,    new   UrlResource (  \" file :  / dir / test . txt ? argh \"  )  . getFilename (  )  )  ;", "assertEquals (  \" test . txt \"  ,    new   UrlResource (  \" file :  \\  \\ dir \\  \\ test . txt ? argh \"  )  . getFilename (  )  )  ;", "assertEquals (  \" test . txt \"  ,    new   UrlResource (  \" file :  \\  \\ dir / test . txt ? argh \"  )  . getFilename (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUrlResource"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   UrlResource (  \" file : dir /  \"  )  ;", "Resource   relative    =    resource . createRelative (  \" subdir \"  )  ;", "assertEquals ( new   UrlResource (  \" file : dir / subdir \"  )  ,    relative )  ;", "}", "METHOD_END"], "methodName": ["testUrlResourceWithRelativePath"], "fileName": "org.springframework.core.io.ResourceTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   URL ( StUtils . cleanPath ( originalPath )  )  ;", "}    catch    ( MalformedURLException   ex )     {", "return   originalUrl ;", "}", "}", "METHOD_END"], "methodName": ["getCleanedUrl"], "fileName": "org.springframework.core.io.UrlResource"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( ReflectionUtils . invokeMethod ( VfsUtils . VIRTUAL _ FILE _ METHOD _ GET _ PATH _ NAME ,    resource )  )  )  ;", "}", "METHOD_END"], "methodName": ["doGetPath"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtils . getField ( VfsUtils . VISITOR _ ATTRIBUTES _ FIELD _ RECURSE ,    null )  ;", "}", "METHOD_END"], "methodName": ["doGetVisitorAttributes"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( Boolean )     (  . invokeVfsMethod (  . VIRTUAL _ FILE _ METHOD _ EXISTS ,    vfsResource )  )  )  ;", "}    catch    ( IOException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return   VfsUtils . invokeVfsMethod ( VfsUtils . VIRTUAL _ FILE _ METHOD _ GET _ CHILD ,    vfsResource ,    path )  ;", "}", "METHOD_END"], "methodName": ["getChild"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( File )     ( VfsUtils . invokeVfsMethod ( VfsUtils . GET _ PHYSICAL _ FILE ,    vfsResource )  )  )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( InputStream )     ( VfsUtils . invokeVfsMethod ( VfsUtils . VIRTUAL _ FILE _ METHOD _ GET _ INPUT _ STREAM ,    vfsResource )  )  )  ;", "}", "METHOD_END"], "methodName": ["getInputStream"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Long )     ( VfsUtils . invokeVfsMethod ( VfsUtils . VIRTUAL _ FILE _ METHOD _ GET _ LAST _ MODIFIED ,    vfsResource )  )  )  ;", "}", "METHOD_END"], "methodName": ["getLastModified"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( String )     (  . invokeVfsMethod (  . VIRTUAL _ FILE _ METHOD _ GET _ NAME ,    vfsResource )  )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  \" Cannot   get   resource   name \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return   VfsUtils . invokeVfsMethod ( VfsUtils . VFS _ METHOD _ GET _ ROOT _ URL ,    null ,    url )  ;", "}", "METHOD_END"], "methodName": ["getRelative"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return   VfsUtils . invokeVfsMethod ( VfsUtils . VFS _ METHOD _ GET _ ROOT _ URI ,    null ,    url )  ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return   VfsUtils . invokeVfsMethod ( VfsUtils . VFS _ METHOD _ GET _ ROOT _ URL ,    null ,    url )  ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Long )     ( VfsUtils . invokeVfsMethod ( VfsUtils . VIRTUAL _ FILE _ METHOD _ GET _ SIZE ,    vfsResource )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( URI )     ( VfsUtils . invokeVfsMethod ( VfsUtils . VIRTUAL _ FILE _ METHOD _ TO _ URI ,    vfsResource )  )  )  ;", "}", "METHOD_END"], "methodName": ["getURI"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( URL )     ( VfsUtils . invokeVfsMethod ( VfsUtils . VIRTUAL _ FILE _ METHOD _ TO _ URL ,    vfsResource )  )  )  ;", "}", "METHOD_END"], "methodName": ["getURL"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   method . invoke ( target ,    args )  ;", "}    catch    ( InvocationTargetException   ex )     {", "Throwable   targetEx    =    ex . getTargetException (  )  ;", "if    ( targetEx   instanceof   IOException )     {", "throw    (  ( IOException )     ( targetEx )  )  ;", "}", "Reflection . handleInvocationTargetException ( ex )  ;", "}    catch    ( Exception   ex )     {", "Reflection . handleReflectionException ( ex )  ;", "}", "throw   new   IllegalStateException (  \" Invalid   code   path   reached \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeVfsMethod"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( Long )     (  . invokeVfsMethod (  . VIRTUAL _ FILE _ METHOD _ GET _ SIZE ,    vfsResource )  )  )     >     0  ;", "}    catch    ( IOException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isReadable"], "fileName": "org.springframework.core.io.VfsUtils"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isWritable"], "fileName": "org.springframework.core.io.WritableResource"}, {"methodBody": ["METHOD_START", "{", "return   Channels . newChannel ( getOutputStream (  )  )  ;", "}", "METHOD_END"], "methodName": ["writableChannel"], "fileName": "org.springframework.core.io.WritableResource"}, {"methodBody": ["METHOD_START", "{", "return   this . bufferFactory . allocateBuffer ( capacity )  ;", "}", "METHOD_END"], "methodName": ["createDataBuffer"], "fileName": "org.springframework.core.io.buffer.AbstractDataBufferAllocatingTestCase"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  [  ]  {    new   Object [  ]  {    new   NettyDataBufferFactory ( new   UnpooledByteBufAllocator ( true )  )     }  ,    new   Object [  ]  {    new   NettyDataBufferFactory ( new   UnpooledByteBufAllocator ( false )  )     }  ,    new   Object [  ]  {    new   NettyDataBufferFactory ( new   PooledByteBufAllocator ( true ,     1  ,     1  ,     8  1  9  2  ,     1  1  ,     0  ,     0  ,     0  ,    true )  )     }  ,    new   Object [  ]  {    new   NettyDataBufferFactory ( new   PooledByteBufAllocator ( false ,     1  ,     1  ,     8  1  9  2  ,     1  1  ,     0  ,     0  ,     0  ,    true )  )     }  ,    new   Object [  ]  {    new   DefaultDataBufferFactory ( true )     }  ,    new   Object [  ]  {    new   DefaultDataBufferFactory ( false )     }     }  ;", "}", "METHOD_END"], "methodName": ["dataBufferFactories"], "fileName": "org.springframework.core.io.buffer.AbstractDataBufferAllocatingTestCase"}, {"methodBody": ["METHOD_START", "{", "Arrays . stream ( buffers )  . forEach ( DataBufferUtils :  : release )  ;", "}", "METHOD_END"], "methodName": ["release"], "fileName": "org.springframework.core.io.buffer.AbstractDataBufferAllocatingTestCase"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    value . getBytes ( StandardCharsets . UTF _  8  )  ;", "buffer    =    this . bufferFactory . allocateBuffer ( bytes . length )  ;", "buffer . write ( bytes )  ;", "return   buffer ;", "}", "METHOD_END"], "methodName": ["stringBuffer"], "fileName": "org.springframework.core.io.buffer.AbstractDataBufferAllocatingTestCase"}, {"methodBody": ["METHOD_START", "{", "return    (    dataBuffer )     -  >     {", "String   value    =    TestUtils . dumpString ( dataBuffer ,    StandardCharsets . UTF _  8  )  ;", "Utils . release ( dataBuffer )  ;", "assertEquals ( expected ,    value )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["stringConsumer"], "fileName": "org.springframework.core.io.buffer.AbstractDataBufferAllocatingTestCase"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  4  )  ;", "buffer . write ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  )  ;", "buffer . read (  )  ;", "ByteBuffer   result    =    buffer . asByteBuffer (  )  ;", "assertEquals (  2  ,    result . capacity (  )  )  ;", "buffer . write (  (  ( byte )     (  ' d '  )  )  )  ;", "assertEquals (  2  ,    result . remaining (  )  )  ;", "byte [  ]    resultBytes    =    new   byte [  2  ]  ;", "result . get ( resultBytes )  ;", "assertArrayEquals ( new   byte [  ]  {     ' b '  ,     ' c '     }  ,    resultBytes )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["asByteBuffer"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  3  )  ;", "buffer . write ( new   byte [  ]  {     ' a '  ,     ' b '     }  )  ;", "ByteBuffer   result    =    buffer . asByteBuffer (  1  ,     2  )  ;", "assertEquals (  2  ,    result . capacity (  )  )  ;", "buffer . write (  (  ( byte )     (  ' c '  )  )  )  ;", "assertEquals (  2  ,    result . remaining (  )  )  ;", "byte [  ]    resultBytes    =    new   byte [  2  ]  ;", "result . get ( resultBytes )  ;", "assertArrayEquals ( new   byte [  ]  {     ' b '  ,     ' c '     }  ,    resultBytes )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["asByteBufferIndexLength"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   dataBuffer    =    createDataBuffer (  1  )  ;", "ByteBuffer   byteBuffer    =    dataBuffer . asByteBuffer (  0  ,     1  )  ;", "dataBuffer . write (  (  ( byte )     (  ' a '  )  )  )  ;", "assertEquals (  1  ,    byteBuffer . limit (  )  )  ;", "byte   b    =    byteBuffer . get (  )  ;", "assertEquals (  ' a '  ,    b )  ;", "release ( dataBuffer )  ;", "}", "METHOD_END"], "methodName": ["byteBufferContainsDataBufferChanges"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  2  )  ;", "assertEquals (  0  ,    buffer . readPosition (  )  )  ;", "assertEquals (  0  ,    buffer . writePosition (  )  )  ;", "assertEquals (  0  ,    buffer . readableByteCount (  )  )  ;", "assertEquals (  2  ,    buffer . writableByteCount (  )  )  ;", "assertEquals (  2  ,    buffer . capacity (  )  )  ;", "buffer . write (  (  ( byte )     (  ' a '  )  )  )  ;", "assertEquals (  0  ,    buffer . readPosition (  )  )  ;", "assertEquals (  1  ,    buffer . writePosition (  )  )  ;", "assertEquals (  1  ,    buffer . readableByteCount (  )  )  ;", "assertEquals (  1  ,    buffer . writableByteCount (  )  )  ;", "assertEquals (  2  ,    buffer . capacity (  )  )  ;", "buffer . write (  (  ( byte )     (  ' b '  )  )  )  ;", "assertEquals (  0  ,    buffer . readPosition (  )  )  ;", "assertEquals (  2  ,    buffer . writePosition (  )  )  ;", "assertEquals (  2  ,    buffer . readableByteCount (  )  )  ;", "assertEquals (  0  ,    buffer . writableByteCount (  )  )  ;", "assertEquals (  2  ,    buffer . capacity (  )  )  ;", "buffer . read (  )  ;", "assertEquals (  1  ,    buffer . readPosition (  )  )  ;", "assertEquals (  2  ,    buffer . writePosition (  )  )  ;", "assertEquals (  1  ,    buffer . readableByteCount (  )  )  ;", "assertEquals (  0  ,    buffer . writableByteCount (  )  )  ;", "assertEquals (  2  ,    buffer . capacity (  )  )  ;", "buffer . read (  )  ;", "assertEquals (  2  ,    buffer . readPosition (  )  )  ;", "assertEquals (  2  ,    buffer . writePosition (  )  )  ;", "assertEquals (  0  ,    buffer . readableByteCount (  )  )  ;", "assertEquals (  0  ,    buffer . writableByteCount (  )  )  ;", "assertEquals (  2  ,    buffer . capacity (  )  )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["byteCountsAndPositions"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  1  )  ;", "try    {", "buffer . capacity (  (  -  1  )  )  ;", "fail (  \" IllegalArgumentException   expected \"  )  ;", "}    catch    ( IllegalArgumentException   ignored )     {", "}    finally    {", "release ( buffer )  ;", "}", "}", "METHOD_END"], "methodName": ["capacityLessThanZero"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "return   ByteBuffer . allocate ( capacity )  ;", "}", "METHOD_END"], "methodName": ["createByteBuffer"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   dataBuffer    =    createDataBuffer (  1  )  ;", "ByteBuffer   byteBuffer    =    dataBuffer . asByteBuffer (  0  ,     1  )  ;", "byteBuffer . put (  (  ( byte )     (  ' a '  )  )  )  ;", "dataBuffer . writePosition (  1  )  ;", "byte   b    =    dataBuffer . read (  )  ;", "assertEquals (  ' a '  ,    b )  ;", "release ( dataBuffer )  ;", "}", "METHOD_END"], "methodName": ["dataBufferContainsByteBufferChanges"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  2  )  ;", "buffer . writePosition (  2  )  ;", "buffer . readPosition (  2  )  ;", "buffer . capacity (  1  )  ;", "assertEquals (  1  ,    buffer . capacity (  )  )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["decreaseCapacityHighReadPosition"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  2  )  ;", "buffer . writePosition (  2  )  ;", "buffer . capacity (  1  )  ;", "assertEquals (  1  ,    buffer . capacity (  )  )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["decreaseCapacityLowReadPosition"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  1  )  ;", "ByteBuffer   result    =    buffer . asByteBuffer (  )  ;", "assertEquals (  0  ,    result . capacity (  )  )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["emptyAsByteBuffer"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  1  )  ;", "buffer . write (  (  ( byte )     (  ' a '  )  )  )  ;", "assertEquals (  1  ,    buffer . capacity (  )  )  ;", "buffer . write (  (  ( byte )     (  ' b '  )  )  )  ;", "assertTrue (  (  ( buffer . capacity (  )  )     >     1  )  )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    stringBuffer (  \" abc \"  )  ;", "assertEquals (  ' a '  ,    buffer . getByte (  0  )  )  ;", "assertEquals (  ' b '  ,    buffer . getByte (  1  )  )  ;", "assertEquals (  ' c '  ,    buffer . getByte (  2  )  )  ;", "try    {", "buffer . getByte (  (  -  1  )  )  ;", "fail (  \" IndexOutOfBoundsException   expected \"  )  ;", "}    catch    ( IndexOutOfBoundsException   ignored )     {", "}", "try    {", "buffer . getByte (  3  )  ;", "fail (  \" IndexOutOfBoundsException   expected \"  )  ;", "}    catch    ( IndexOutOfBoundsException   ignored )     {", "}", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["getByte"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  1  )  ;", "assertEquals (  1  ,    buffer . capacity (  )  )  ;", "buffer . capacity (  2  )  ;", "assertEquals (  2  ,    buffer . capacity (  )  )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["increaseCapacity"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  3  )  ;", "buffer . write ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  )  ;", "int   result    =    buffer . indexOf (  (    b )     -  >    b    =  =     ' c '  ,     0  )  ;", "assertEquals (  2  ,    result )  ;", "result    =    buffer . indexOf (  (    b )     -  >    b    =  =     ' c '  ,    Integer . MIN _ VALUE )  ;", "assertEquals (  2  ,    result )  ;", "result    =    buffer . indexOf (  (    b )     -  >    b    =  =     ' c '  ,    Integer . MAX _ VALUE )  ;", "assertEquals (  (  -  1  )  ,    result )  ;", "result    =    buffer . indexOf (  (    b )     -  >    b    =  =     ' z '  ,     0  )  ;", "assertEquals (  (  -  1  )  ,    result )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  4  )  ;", "buffer . write ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '  ,     ' d '  ,     ' e '     }  )  ;", "buffer . readPosition (  1  )  ;", "InputStream   inputStream    =    buffer . asInputStream (  )  ;", "assertEquals (  4  ,    inputStream . available (  )  )  ;", "int   result    =    inputStream . read (  )  ;", "assertEquals (  ' b '  ,    result )  ;", "assertEquals (  3  ,    inputStream . available (  )  )  ;", "byte [  ]    bytes    =    new   byte [  2  ]  ;", "int   len    =    inputStream . read ( bytes )  ;", "assertEquals (  2  ,    len )  ;", "assertArrayEquals ( new   byte [  ]  {     ' c '  ,     ' d '     }  ,    bytes )  ;", "assertEquals (  1  ,    inputStream . available (  )  )  ;", "Arrays . fill ( bytes ,     (  ( byte )     (  0  )  )  )  ;", "len    =    inputStream . read ( bytes )  ;", "assertEquals (  1  ,    len )  ;", "assertArrayEquals ( new   byte [  ]  {     ' e '  ,     (  ( byte )     (  0  )  )     }  ,    bytes )  ;", "assertEquals (  0  ,    inputStream . available (  )  )  ;", "assertEquals (  (  -  1  )  ,    inputStream . read (  )  )  ;", "assertEquals (  (  -  1  )  ,    inputStream . read ( bytes )  )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["inputStream"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  3  )  ;", "byte [  ]    bytes    =    new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  ;", "buffer . write ( bytes )  ;", "InputStream   inputStream    =    buffer . asInputStream ( true )  ;", "try    {", "byte [  ]    result    =    new   byte [  3  ]  ;", "int   len    =    inputStream . read ( result )  ;", "assertEquals (  3  ,    len )  ;", "assertArrayEquals ( bytes ,    result )  ;", "}    finally    {", "inputStream . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["inputStreamReleaseOnClose"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   composite    =    this . bufferFactory . join ( Arrays . asList ( stringBuffer (  \" a \"  )  ,    stringBuffer (  \" b \"  )  ,    stringBuffer (  \" c \"  )  )  )  ;", "assertEquals (  3  ,    composite . readableByteCount (  )  )  ;", "byte [  ]    bytes    =    new   byte [  3  ]  ;", "composite . read ( bytes )  ;", "assertArrayEquals ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  ,    bytes )  ;", "release ( composite )  ;", "}", "METHOD_END"], "methodName": ["join"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  3  )  ;", "buffer . write ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  )  ;", "int   result    =    buffer . lastIndexOf (  (    b )     -  >    b    =  =     ' b '  ,     2  )  ;", "assertEquals (  1  ,    result )  ;", "result    =    buffer . lastIndexOf (  (    b )     -  >    b    =  =     ' c '  ,     2  )  ;", "assertEquals (  2  ,    result )  ;", "result    =    buffer . lastIndexOf (  (    b )     -  >    b    =  =     ' b '  ,    Integer . MAX _ VALUE )  ;", "assertEquals (  1  ,    result )  ;", "result    =    buffer . lastIndexOf (  (    b )     -  >    b    =  =     ' c '  ,    Integer . MAX _ VALUE )  ;", "assertEquals (  2  ,    result )  ;", "result    =    buffer . lastIndexOf (  (    b )     -  >    b    =  =     ' b '  ,    Integer . MIN _ VALUE )  ;", "assertEquals (  (  -  1  )  ,    result )  ;", "result    =    buffer . lastIndexOf (  (    b )     -  >    b    =  =     ' c '  ,    Integer . MIN _ VALUE )  ;", "assertEquals (  (  -  1  )  ,    result )  ;", "result    =    buffer . lastIndexOf (  (    b )     -  >    b    =  =     ' z '  ,     0  )  ;", "assertEquals (  (  -  1  )  ,    result )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  4  )  ;", "buffer . write (  (  ( byte )     (  ' a '  )  )  )  ;", "OutputStream   outputStream    =    buffer . asOutputStream (  )  ;", "outputStream . write (  ' b '  )  ;", "outputStream . write ( new   byte [  ]  {     ' c '  ,     ' d '     }  )  ;", "buffer . write (  (  ( byte )     (  ' e '  )  )  )  ;", "byte [  ]    bytes    =    new   byte [  5  ]  ;", "buffer . read ( bytes )  ;", "assertArrayEquals ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '  ,     ' d '  ,     ' e '     }  ,    bytes )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["outputStream"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  1  )  ;", "try    {", "buffer . readPosition (  1  )  ;", "fail (  \" IndexOutOfBoundsException   expected \"  )  ;", "}    catch    ( IndexOutOfBoundsException   ignored )     {", "}    finally    {", "release ( buffer )  ;", "}", "}", "METHOD_END"], "methodName": ["readPositionGreaterThanWritePosition"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  1  )  ;", "try    {", "buffer . readPosition (  (  -  1  )  )  ;", "fail (  \" IndexOutOfBoundsException   expected \"  )  ;", "}    catch    ( IndexOutOfBoundsException   ignored )     {", "}    finally    {", "release ( buffer )  ;", "}", "}", "METHOD_END"], "methodName": ["readPositionSmallerThanZero"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  3  )  ;", "buffer . write ( new   byte [  ]  {     ' a '  ,     ' b '     }  )  ;", "DataBuffer   slice    =    buffer . slice (  1  ,     2  )  ;", "assertEquals (  2  ,    slice . readableByteCount (  )  )  ;", "try    {", "slice . write (  (  ( byte )     (  0  )  )  )  ;", "fail (  \" Exception   expected \"  )  ;", "}    catch    ( Exception   ignored )     {", "}", "buffer . write (  (  ( byte )     (  ' c '  )  )  )  ;", "assertEquals (  3  ,    buffer . readableByteCount (  )  )  ;", "byte [  ]    result    =    new   byte [  3  ]  ;", "buffer . read ( result )  ;", "assertArrayEquals ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  ,    result )  ;", "assertEquals (  2  ,    slice . readableByteCount (  )  )  ;", "result    =    new   byte [  2  ]  ;", "slice . read ( result )  ;", "assertArrayEquals ( new   byte [  ]  {     ' b '  ,     ' c '     }  ,    result )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  6  )  ;", "byte [  ]    bytes    =    new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '  ,     ' d '  ,     ' e '  ,     ' f '     }  ;", "buffer . write ( bytes )  ;", "DataBuffer   slice    =    buffer . slice (  3  ,     3  )  ;", "buffer . writePosition (  3  )  ;", "buffer . write ( slice )  ;", "assertEquals (  6  ,    buffer . readableByteCount (  )  )  ;", "byte [  ]    result    =    new   byte [  6  ]  ;", "buffer . read ( result )  ;", "assertArrayEquals ( bytes ,    result )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["spr16351"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  5  )  ;", "buffer . write ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  )  ;", "int   ch    =    buffer . read (  )  ;", "assertEquals (  ' a '  ,    ch )  ;", "buffer . write (  (  ( byte )     (  ' d '  )  )  )  ;", "buffer . write (  (  ( byte )     (  ' e '  )  )  )  ;", "byte [  ]    result    =    new   byte [  4  ]  ;", "buffer . read ( result )  ;", "assertArrayEquals ( new   byte [  ]  {     ' b '  ,     ' c '  ,     ' d '  ,     ' e '     }  ,    result )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["writeAndRead"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer 1     =    createDataBuffer (  1  )  ;", "buffer 1  . write (  (  ( byte )     (  ' a '  )  )  )  ;", "ByteBuffer   buffer 2     =    createByteBuffer (  2  )  ;", "buffer 2  . put (  (  ( byte )     (  ' b '  )  )  )  ;", "buffer 2  . flip (  )  ;", "ByteBuffer   buffer 3     =    createByteBuffer (  3  )  ;", "buffer 3  . put (  (  ( byte )     (  ' c '  )  )  )  ;", "buffer 3  . flip (  )  ;", "buffer 1  . write ( buffer 2  ,    buffer 3  )  ;", "buffer 1  . write (  (  ( byte )     (  ' d '  )  )  )  ;", "assertEquals (  4  ,    buffer 1  . readableByteCount (  )  )  ;", "byte [  ]    result    =    new   byte [  4  ]  ;", "buffer 1  . read ( result )  ;", "assertArrayEquals ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '  ,     ' d '     }  ,    result )  ;", "release ( buffer 1  )  ;", "}", "METHOD_END"], "methodName": ["writeByteBuffer"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer 1     =    createDataBuffer (  1  )  ;", "buffer 1  . write (  (  ( byte )     (  ' a '  )  )  )  ;", "DataBuffer   buffer 2     =    createDataBuffer (  2  )  ;", "buffer 2  . write (  (  ( byte )     (  ' b '  )  )  )  ;", "DataBuffer   buffer 3     =    createDataBuffer (  3  )  ;", "buffer 3  . write (  (  ( byte )     (  ' c '  )  )  )  ;", "buffer 1  . write ( buffer 2  ,    buffer 3  )  ;", "buffer 1  . write (  (  ( byte )     (  ' d '  )  )  )  ;", "assertEquals (  4  ,    buffer 1  . readableByteCount (  )  )  ;", "byte [  ]    result    =    new   byte [  4  ]  ;", "buffer 1  . read ( result )  ;", "assertArrayEquals ( new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '  ,     ' d '     }  ,    result )  ;", "release ( buffer 1  ,    buffer 2  ,    buffer 3  )  ;", "}", "METHOD_END"], "methodName": ["writeDataBuffer"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  1  )  ;", "try    {", "buffer . writePosition (  2  )  ;", "fail (  \" IndexOutOfBoundsException   expected \"  )  ;", "}    catch    ( IndexOutOfBoundsException   ignored )     {", "}    finally    {", "release ( buffer )  ;", "}", "}", "METHOD_END"], "methodName": ["writePositionGreaterThanCapacity"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    createDataBuffer (  2  )  ;", "try    {", "buffer . write (  (  ( byte )     (  ' a '  )  )  )  ;", "buffer . read (  )  ;", "buffer . writePosition (  0  )  ;", "fail (  \" IndexOutOfBoundsException   expected \"  )  ;", "}    catch    ( IndexOutOfBoundsException   ignored )     {", "}    finally    {", "release ( buffer )  ;", "}", "}", "METHOD_END"], "methodName": ["writePositionSmallerThanReadPosition"], "fileName": "org.springframework.core.io.buffer.DataBufferTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( channel    !  =    null )     &  &     ( channel . isOpen (  )  )  )     {", "try    {", "channel . close (  )  ;", "}    catch    ( IOException   ignd )     {", "}", "}", "}", "METHOD_END"], "methodName": ["closeChannel"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( dataBuffers ,     \"  ' dataBuffers '    must   not   be   null \"  )  ;", "return   Flux . from ( dataBuffers )  . collectList (  )  . filter (  (    list )     -  >     !  ( list . isEmpty (  )  )  )  . map (  (    list )     -  >     {", "Factory   bufferFactory    =    list . get (  0  )  . factory (  )  ;", "return   bufferFactory . join ( list )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["join"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   DataBufferUtils . readInputStream (  (  )     -  >    inputStream ,    dataBufferFactory ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   DataBufferUtils . readAsynchronousFileChannel (  (  )     -  >    channel ,    position ,    dataBufferFactory ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   DataBufferUtils . readAsynchronousFileChannel (  (  )     -  >    channel ,    dataBufferFactory ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   DataBufferUtils . readByteChannel (  (  )     -  >    channel ,    dataBufferFactory ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( resource . isFile (  )  )     {", "File   file    =    resource . getFile (  )  ;", "return    . readAsynchronousFileChannel (  (  )     -  >    AsynchronousFileChannel . open ( file . toPath (  )  ,    StandardOpenOption . READ )  ,    position ,    dataBufferFactory ,    bufferSize )  ;", "}", "}    catch    ( IOException   ignore )     {", "}", "Flux < DataBuffer >    result    =     . readByteChannel ( resource :  : readableChannel ,    dataBufferFactory ,    bufferSize )  ;", "return   position    =  =     0     ?    result    :     . skipUntilByteCount ( result ,    position )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   DataBufferUtils . read ( resource ,     0  ,    dataBufferFactory ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( channelSupplier ,     \"  ' channelSupplier '    must   not   be   null \"  )  ;", "Assert . notNull ( dataBufferFactory ,     \"  ' dataBufferFactory '    must   not   be   null \"  )  ;", "Assert . isTrue (  ( position    >  =     0  )  ,     \"  ' position '    must   be    >  =     0  \"  )  ;", "Assert . isTrue (  ( bufferSize    >     0  )  ,     \"  ' bufferSize '    must   be    >     0  \"  )  ;", "DataBuffer   dataBuffer    =    dataBufferFactory . allocateBuffer ( bufferSize )  ;", "ByteBuffer   byteBuffer    =    dataBuffer . asByteBuffer (  0  ,    bufferSize )  ;", "return   Flux . using ( channelSupplier ,     (    channel )     -  >    Flux . create (  (    sink )     -  >     {", "CompletionHandler < Integer ,    DataBuffer >    completionHandler    =    new   AsynchronousFileChannelReadCompletionHandler ( channel ,    sink ,    position ,    dataBufferFactory ,    bufferSize )  ;", "channel . read ( byteBuffer ,    position ,    dataBuffer ,    completionHandler )  ;", "}  )  ,     :  : closeChannel )  ;", "}", "METHOD_END"], "methodName": ["readAsynchronousFileChannel"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   DataBufferUtils . readAsynchronousFileChannel ( channelSupplier ,     0  ,    dataBufferFactory ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["readAsynchronousFileChannel"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( channelSupplier ,     \"  ' channelSupplier '    must   not   be   null \"  )  ;", "Assert . notNull ( dataBufferFactory ,     \"  ' dataBufferFactory '    must   not   be   null \"  )  ;", "Assert . isTrue (  ( bufferSize    >     0  )  ,     \"  ' bufferSize '    must   be    >     0  \"  )  ;", "return   Flux . using ( channelSupplier ,     (    channel )     -  >     {", "ReadableByteChannelGenerator   generator    =    new   ReadableByteChannelGenerator ( channel ,    dataBufferFactory ,    bufferSize )  ;", "return   Flux . generate ( generator )  ;", "}  ,     :  : closeChannel )  ;", "}", "METHOD_END"], "methodName": ["readByteChannel"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( inputStreamSupplier ,     \"  ' inputStreamSupplier '    must   not   be   null \"  )  ;", "return    . readByteChannel (  (  )     -  >    Channels . newChannel ( inputStreamSupplier . call (  )  )  ,    dataBufferFactory ,    bufferSize )  ;", "}", "METHOD_END"], "methodName": ["readInputStream"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( dataBuffer   instanceof   PooledDataBuffer )     &  &     (  (  ( PooledDataBuffer )     ( dataBuffer )  )  . release (  )  )  ;", "}", "METHOD_END"], "methodName": ["release"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "return   DataBufferUtils . RELEASE _ CONSUMER ;", "}", "METHOD_END"], "methodName": ["releaseConsumer"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( dataBuffer   instanceof   PooledDataBuffer )     {", "return    (  ( T )     (  (  ( PooledDataBuffer )     ( dataBuffer )  )  . retain (  )  )  )  ;", "} else    {", "return   dataBuffer ;", "}", "}", "METHOD_END"], "methodName": ["retain"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( publisher ,     \" Publisher   must   not   be   null \"  )  ;", "Assert . isTrue (  ( maxByteCount    >  =     0  )  ,     \"  ' maxByteCount '    must   be   a   positive   number \"  )  ;", "AtomicLong   byteCountDown    =    new   AtomicLong ( maxByteCount )  ;", "return   Flux . from ( publisher )  . skipUntil (  (    dataBuffer )     -  >     {", "int   delta    =     -  ( dataBuffer . readableByteCount (  )  )  ;", "long   currentCount    =    byteCountDown . addAndGet ( delta )  ;", "if    ( currentCount    <     0  )     {", "return   true ;", "} else    {", ". release ( dataBuffer )  ;", "return   false ;", "}", "}  )  . map (  (    dataBuffer )     -  >     {", "long   currentCount    =    byteCountDown . get (  )  ;", "if    ( currentCount    <     0  )     {", "int   skip    =     (  ( int )     ( currentCount    +     ( dataBuffer . readableByteCount (  )  )  )  )  ;", "byteCountDown . set (  0  )  ;", "return   dataBuffer . slice ( skip ,     (  ( dataBuffer . readableByteCount (  )  )     -    skip )  )  ;", "}", "return   dataBuffer ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["skipUntilByteCount"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( publisher ,     \" Publisher   must   not   be   null \"  )  ;", "Assert . isTrue (  ( maxByteCount    >  =     0  )  ,     \"  ' maxByteCount '    must   be   a   positive   number \"  )  ;", "AtomicLong   byteCountDown    =    new   AtomicLong ( maxByteCount )  ;", "return   Flux . from ( publisher )  . takeWhile (  (    d )     -  >     {", "int   delta    =     -  ( d . readableByteCount (  )  )  ;", "long   currentCount    =    byteCountDown . getAndAdd ( delta )  ;", "return   currentCount    >  =     0  ;", "}  )  . map (  (    d )     -  >     {", "long   currentCount    =    byteCountDown . get (  )  ;", "if    ( currentCount    >  =     0  )     {", "return   d ;", "} else    {", "int   size    =     (  ( int )     ( currentCount    +     ( d . readableByteCount (  )  )  )  )  ;", "return   d . slice (  0  ,    size )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["takeUntilByteCount"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( source ,     \"  ' source '    must   not   be   null \"  )  ;", "Assert . notNull ( outputStream ,     \"  ' outputStream '    must   not   be   null \"  )  ;", "WritableByteChannel   channel    =    Channels . newChannel ( outputStream )  ;", "return    . write ( source ,    channel )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( source ,     \"  ' source '    must   not   be   null \"  )  ;", "Assert . notNull ( channel ,     \"  ' channel '    must   not   be   null \"  )  ;", "Assert . isTrue (  ( position    >  =     0  )  ,     \"  ' position '    must   be    >  =     0  \"  )  ;", "Flux <  >    flux    =    Flux . from ( source )  ;", "return   Flux . create (  (    sink )     -  >    flux . subscribe ( new   AsynchronousFileChannelWriteCompletionHandler ( sink ,    channel ,    position )  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( source ,     \"  ' source '    must   not   be   null \"  )  ;", "Assert . notNull ( channel ,     \"  ' channel '    must   not   be   null \"  )  ;", "Flux <  >    flux    =    Flux . from ( source )  ;", "return   Flux . create (  (    sink )     -  >    flux . subscribe (  (    dataBuffer )     -  >     {", "try    {", "ByteBuffer   byteBuffer    =    dataBuffer . asByteBuffer (  )  ;", "while    ( byteBuffer . hasRemaining (  )  )     {", "channel . write ( byteBuffer )  ;", "}", "sink . next ( dataBuffer )  ;", "}    catch    (    ex )     {", "sink . error ( ex )  ;", "}", "}  ,    sink :  : error ,    sink :  : complete )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.core.io.buffer.DataBufferUtils"}, {"methodBody": ["METHOD_START", "{", "ReadableByteChannel   channel    =    mock ( ReadableByteChannel . class )  ;", "when ( channel . read ( any (  )  )  )  . thenAnswer ( putByte (  ' a '  )  )  . thenAnswer ( putByte (  ' b '  )  )  . thenAnswer ( putByte (  ' c '  )  )  . thenReturn (  (  -  1  )  )  ;", "Flux < DataBuffer >    read    =     . readByteChannel (  (  )     -  >    channel ,    this . bufferFactory ,     1  )  ;", "StepVerifier . create ( read )  . consumeNextWith ( stringConsumer (  \" a \"  )  )  . consumeNextWith ( stringConsumer (  \" b \"  )  )  . consumeNextWith ( stringConsumer (  \" c \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR16070"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "if    ( dataBuffer   instanceof   NettyDataBuffer )     {", "ByteBuf   byteBuf    =     (  ( NettyDataBuffer )     ( dataBuffer )  )  . getNativeBuffer (  )  ;", "assertEquals (  0  ,    byteBuf . refCnt (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertReleased"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   foo    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   bar    =    stringBuffer (  \" bar \"  )  ;", "DataBuffer   baz    =    stringBuffer (  \" baz \"  )  ;", "Flux < DataBuffer >    flux    =    Flux . just ( foo ,    bar ,    baz )  ;", "DataBuffer   result    =     . join ( flux )  . block ( Duration . ofSeconds (  5  )  )  ;", "assertEquals (  \" foobarbaz \"  ,    DataBufferTestUtils . dumpString ( result ,    StandardCharsets . UTF _  8  )  )  ;", "release ( result )  ;", "}", "METHOD_END"], "methodName": ["join"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return    (    invocation )     -  >     {", "ByteBuffer    =    invocation . getArgument (  0  )  ;", "put (  (  ( byte )     ( b )  )  )  ;", "return    1  ;", "}  ;", "}", "METHOD_END"], "methodName": ["putByte"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    DataBufferUtilsTests . class . getResource (  \" DataBufferUtilsTests . txt \"  )  . toURI (  )  ;", "Flux < DataBuffer >    flux    =    DataBufferUtils . readAsynchronousFileChannel (  (  )     -  >    AsynchronousFileChannel . open ( Paths . get ( uri )  ,    StandardOpenOption . READ )  ,    this . bufferFactory ,     3  )  ;", "StepVerifier . create ( flux )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . consumeNextWith ( stringConsumer (  \" bar \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . consumeNextWith ( stringConsumer (  \" qux \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["readAsynchronousFileChannel"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    DataBufferUtilsTests . class . getResource (  \" DataBufferUtilsTests . txt \"  )  . toURI (  )  ;", "Flux < DataBuffer >    flux    =    DataBufferUtils . readAsynchronousFileChannel (  (  )     -  >    AsynchronousFileChannel . open ( Paths . get ( uri )  ,    StandardOpenOption . READ )  ,     3  ,    this . bufferFactory ,     3  )  ;", "StepVerifier . create ( flux )  . consumeNextWith ( stringConsumer (  \" bar \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . consumeNextWith ( stringConsumer (  \" qux \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["readAsynchronousFileChannelPosition"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    DataBufferUtilsTests . class . getResource (  \" DataBufferUtilsTests . txt \"  )  . toURI (  )  ;", "Flux < DataBuffer >    flux    =    DataBufferUtils . readByteChannel (  (  )     -  >    FileChannel . open ( Paths . get ( uri )  ,    StandardOpenOption . READ )  ,    this . bufferFactory ,     3  )  ;", "StepVerifier . create ( flux )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . consumeNextWith ( stringConsumer (  \" bar \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . consumeNextWith ( stringConsumer (  \" qux \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["readByteChannel"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Flux < DataBuffer >    flux    =    DataBufferUtils . readInputStream (  (  )     -  >    DataBufferUtilsTests . class . getResourceAsStream (  \" DataBufferUtilsTests . txt \"  )  ,    this . bufferFactory ,     3  )  ;", "StepVerifier . create ( flux )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . consumeNextWith ( stringConsumer (  \" bar \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . consumeNextWith ( stringConsumer (  \" qux \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["readInputStream"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ClassPathResource (  \" DataBufferUtilsTests . txt \"  ,    getClass (  )  )  ;", "Flux < DataBuffer >    flux    =    DataBufferUtils . read ( resource ,    this . bufferFactory ,     3  )  ;", "StepVerifier . create ( flux )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . consumeNextWith ( stringConsumer (  \" bar \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . consumeNextWith ( stringConsumer (  \" qux \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["readResource"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ClassPathResource (  \" DataBufferUtilsTests . txt \"  ,    getClass (  )  )  ;", "Flux < DataBuffer >    flux    =    DataBufferUtils . read ( resource ,     3  ,    this . bufferFactory ,     3  )  ;", "StepVerifier . create ( flux )  . consumeNextWith ( stringConsumer (  \" bar \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . consumeNextWith ( stringConsumer (  \" qux \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["readResourcePosition"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   foo    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   bar    =    stringBuffer (  \" bar \"  )  ;", "DataBuffer   baz    =    stringBuffer (  \" baz \"  )  ;", "Flux < DataBuffer >    flux    =    Flux . just ( foo ,    bar ,    baz )  ;", "flux . subscribe ( DataBufferUtils . releaseConsumer (  )  )  ;", ". assertReleased ( foo )  ;", ". assertReleased ( bar )  ;", ". assertReleased ( baz )  ;", "}", "METHOD_END"], "methodName": ["releaseConsumer"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   foo    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   bar    =    stringBuffer (  \" bar \"  )  ;", "DataBuffer   baz    =    stringBuffer (  \" baz \"  )  ;", "Flux < DataBuffer >    flux    =    Flux . just ( foo ,    bar ,    baz )  ;", "Flux < DataBuffer >    result    =     . skipUntilByteCount ( flux ,     5 L )  ;", "StepVerifier . create ( result )  . consumeNextWith ( stringConsumer (  \" r \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["skipUntilByteCount"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   foo    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   bar    =    stringBuffer (  \" bar \"  )  ;", "DataBuffer   baz    =    stringBuffer (  \" baz \"  )  ;", "Flux < DataBuffer >    flux    =    Flux . just ( foo ,    bar ,    baz )  ;", "Flux < DataBuffer >    result    =     . skipUntilByteCount ( flux ,     9 L )  ;", "StepVerifier . create ( result )  . expectNextCount (  0  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "}", "METHOD_END"], "methodName": ["skipUntilByteCountShouldSkipAll"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   foo    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   bar    =    stringBuffer (  \" bar \"  )  ;", "DataBuffer   baz    =    stringBuffer (  \" baz \"  )  ;", "Flux < DataBuffer >    flux    =    Flux . just ( foo ,    bar ,    baz )  ;", "Flux < DataBuffer >    result    =     . takeUntilByteCount ( flux ,     5 L )  ;", "StepVerifier . create ( result )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . consumeNextWith ( stringConsumer (  \" ba \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "release ( baz )  ;", "}", "METHOD_END"], "methodName": ["takeUntilByteCount"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   foo    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   bar    =    stringBuffer (  \" bar \"  )  ;", "DataBuffer   baz    =    stringBuffer (  \" baz \"  )  ;", "DataBuffer   qux    =    stringBuffer (  \" qux \"  )  ;", "Flux < DataBuffer >    flux    =    Flux . just ( foo ,    bar ,    baz ,    qux )  ;", "Path   tempFile    =    Files . createTempFile (  \"  \"  ,    null )  ;", "AsynchronousFileChannel   channel    =    AsynchronousFileChannel . open ( tempFile ,    StandardOpenOption . WRITE )  ;", "Flux < DataBuffer >    writeResult    =    DataBufferUtils . write ( flux ,    channel ,     0  )  ;", "StepVerifier . create ( writeResult )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . consumeNextWith ( stringConsumer (  \" bar \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . consumeNextWith ( stringConsumer (  \" qux \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "String   result    =    Files . readAllLines ( tempFile )  . stream (  )  . collect ( Collectors . joining (  )  )  ;", "assertEquals (  \" foobarbazqux \"  ,    result )  ;", "channel . close (  )  ;", "}", "METHOD_END"], "methodName": ["writeAsynchronousFileChannel"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   foo    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   bar    =    stringBuffer (  \" bar \"  )  ;", "DataBuffer   baz    =    stringBuffer (  \" baz \"  )  ;", "DataBuffer   qux    =    stringBuffer (  \" qux \"  )  ;", "Flux < DataBuffer >    flux    =    Flux . just ( foo ,    bar ,    baz ,    qux )  ;", "Path   tempFile    =    Files . createTempFile (  \"  \"  ,    null )  ;", "OutputStream   os    =    Files . newOutputStream ( tempFile )  ;", "Flux < DataBuffer >    writeResult    =    DataBufferUtils . write ( flux ,    os )  ;", "StepVerifier . create ( writeResult )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . consumeNextWith ( stringConsumer (  \" bar \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . consumeNextWith ( stringConsumer (  \" qux \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "String   result    =    Files . readAllLines ( tempFile )  . stream (  )  . collect ( Collectors . joining (  )  )  ;", "assertEquals (  \" foobarbazqux \"  ,    result )  ;", "os . close (  )  ;", "}", "METHOD_END"], "methodName": ["writeOutputStream"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   foo    =    stringBuffer (  \" foo \"  )  ;", "DataBuffer   bar    =    stringBuffer (  \" bar \"  )  ;", "DataBuffer   baz    =    stringBuffer (  \" baz \"  )  ;", "DataBuffer   qux    =    stringBuffer (  \" qux \"  )  ;", "Flux < DataBuffer >    flux    =    Flux . just ( foo ,    bar ,    baz ,    qux )  ;", "Path   tempFile    =    Files . createTempFile (  \"  \"  ,    null )  ;", "WritableByteChannel   channel    =    Files . newByteChannel ( tempFile ,    StandardOpenOption . WRITE )  ;", "Flux < DataBuffer >    writeResult    =    DataBufferUtils . write ( flux ,    channel )  ;", "StepVerifier . create ( writeResult )  . consumeNextWith ( stringConsumer (  \" foo \"  )  )  . consumeNextWith ( stringConsumer (  \" bar \"  )  )  . consumeNextWith ( stringConsumer (  \" baz \"  )  )  . consumeNextWith ( stringConsumer (  \" qux \"  )  )  . expectComplete (  )  . verify ( Duration . ofSeconds (  5  )  )  ;", "String   result    =    Files . readAllLines ( tempFile )  . stream (  )  . collect ( Collectors . joining (  )  )  ;", "assertEquals (  \" foobarbazqux \"  ,    result )  ;", "channel . close (  )  ;", "}", "METHOD_END"], "methodName": ["writeWritableByteChannel"], "fileName": "org.springframework.core.io.buffer.DataBufferUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   direct    ?    ByteBuffer . allocateDirect ( capacity )     :    ByteBuffer . allocate ( capacity )  ;", "}", "METHOD_END"], "methodName": ["allocate"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ! expression )     {", "St   message    =    St . format ( format ,    args )  ;", "throw   new   IndexOutOfBoundsException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["assertIndex"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( neededCapacity    >  =     0  )  ,     \"  ' neededCapacity '    must    >  =     0  \"  )  ;", "if    ( neededCapacity    =  =     (  . CAPACITY _ THRESHOLD )  )     {", "return    . CAPACITY _ THRESHOLD ;", "} else", "if    ( neededCapacity    >     (  . CAPACITY _ THRESHOLD )  )     {", "int   newCapacity    =     ( neededCapacity    /     (  . CAPACITY _ THRESHOLD )  )     *     (  . CAPACITY _ THRESHOLD )  ;", "if    ( newCapacity    >     (  (  . MAX _ CAPACITY )     -     (  . CAPACITY _ THRESHOLD )  )  )     {", "newCapacity    =     . MAX _ CAPACITY ;", "} else    {", "newCapacity    +  =     . CAPACITY _ THRESHOLD ;", "}", "return   newCapacity ;", "} else    {", "int   newCapacity    =     6  4  ;", "while    ( newCapacity    <    neededCapacity )     {", "newCapacity    <  <  =     1  ;", "}", "return   Math . min ( newCapacity ,     . MAX _ CAPACITY )  ;", "}", "}", "METHOD_END"], "methodName": ["calculateCapacity"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBuffer . assertIndex (  ( index    >  =     0  )  ,     \" index    % d   must   be    >  =     0  \"  ,    index )  ;", "DefaultDataBuffer . assertIndex (  ( length    >  =     0  )  ,     \" length    % d   must   be    >  =     0  \"  ,    index )  ;", "DefaultDataBuffer . assertIndex (  ( index    <  =     ( this . capacity )  )  ,     \" index    % d   must   be    <  =     % d \"  ,    index ,    this . capacity )  ;", "DefaultDataBuffer . assertIndex (  ( length    <  =     ( this . capacity )  )  ,     \" length    % d   must   be    <  =     % d \"  ,    index ,    this . capacity )  ;", "}", "METHOD_END"], "methodName": ["checkIndex"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "if    ( length    <  =     ( writableByteCount (  )  )  )     {", "return ;", "}", "int   newCapacity    =    calculateCapacity (  (  ( this . writePosition )     +    length )  )  ;", "capacity ( newCapacity )  ;", "}", "METHOD_END"], "methodName": ["ensureCapacity"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDataBuffer ( dataBufferFactory ,    byteBuffer )  ;", "}", "METHOD_END"], "methodName": ["fromEmptyByteBuffer"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "DefaultDataBuffer   dataBuffer    =    new   DefaultDataBuffer ( dataBufferFactory ,    byteBuffer )  ;", "dataBuffer . writePosition ( byteBuffer . remaining (  )  )  ;", "return   dataBuffer ;", "}", "METHOD_END"], "methodName": ["fromFilledByteBuffer"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "return   this . byteBuffer ;", "}", "METHOD_END"], "methodName": ["getNativeBuffer"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "this . byteBuffer    =    byteBuffer ;", "this . capacity    =    byteBuffer . remaining (  )  ;", "}", "METHOD_END"], "methodName": ["setNativeBuffer"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "int   length    =    source . remaining (  )  ;", "Byte   tmp    =    this . byte . duplicate (  )  ;", "int   limit    =     ( this . writePosition )     +     ( source . remaining (  )  )  ;", "(  (  )     ( tmp )  )  . clear (  )  . position ( this . writePosition )  . limit ( limit )  ;", "tmp . put ( source )  ;", "this . writePosition    +  =    length ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.core.io.buffer.DefaultDataBuffer"}, {"methodBody": ["METHOD_START", "{", "return   this . byteBuf ;", "}", "METHOD_END"], "methodName": ["getNativeBuffer"], "fileName": "org.springframework.core.io.buffer.NettyDataBuffer"}, {"methodBody": ["METHOD_START", "{", "for    ( DataBuffer   dataBuffer    :    dataBuffers )     {", "if    (  !  ( dataBuffer   instanceof    )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["hasNettyDataBuffers"], "fileName": "org.springframework.core.io.buffer.NettyDataBuffer"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( byteBufs ,     \"  ' byteBufs '    must   not   be   null \"  )  ;", "for    ( ByteBuf   byteBuf    :    byteBufs )     {", "this . byteBuf . writeBytes ( byteBuf )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.core.io.buffer.NettyDataBuffer"}, {"methodBody": ["METHOD_START", "{", "return   this . byteBufAllocator ;", "}", "METHOD_END"], "methodName": ["getByteBufAllocator"], "fileName": "org.springframework.core.io.buffer.NettyDataBufferFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( buffer   instanceof   NettyDataBuffer )     {", "return    (  ( NettyDataBuffer )     ( buffer )  )  . getNativeBuffer (  )  ;", "} else    {", "return   Unpooled . wrappedBuffer ( buffer . asByteBuffer (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toByteBuf"], "fileName": "org.springframework.core.io.buffer.NettyDataBufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   NettyDataBuffer ( byteBuf ,    this )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.springframework.core.io.buffer.NettyDataBufferFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   Object [  ]  [  ]  {    new   Object [  ]  {    new   NettyDataBufferFactory ( new   UnpooledByteBufAllocator ( true )  )     }  ,    new   Object [  ]  {    new   NettyDataBufferFactory ( new   UnpooledByteBufAllocator ( false )  )     }  ,    new   Object [  ]  {    new   NettyDataBufferFactory ( new   PooledByteBufAllocator ( true )  )     }  ,    new   Object [  ]  {    new   NettyDataBufferFactory ( new   PooledByteBufAllocator ( false )  )     }     }  ;", "}", "METHOD_END"], "methodName": ["buffers"], "fileName": "org.springframework.core.io.buffer.PooledDataBufferTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( PooledDataBuffer )     ( dataBufferFactory . allocateBuffer ( capacity )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDataBuffer"], "fileName": "org.springframework.core.io.buffer.PooledDataBufferTests"}, {"methodBody": ["METHOD_START", "{", "PooledDataBuffer   buffer    =    createDataBuffer (  1  )  ;", "buffer . write (  (  ( byte )     (  ' a '  )  )  )  ;", "buffer . retain (  )  ;", "boolean   result    =    buffer . release (  )  ;", "Assert . assertFalse ( result )  ;", "result    =    buffer . release (  )  ;", "Assert . assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["retainAndRelease"], "fileName": "org.springframework.core.io.buffer.PooledDataBufferTests"}, {"methodBody": ["METHOD_START", "{", "PooledDataBuffer   buffer    =    createDataBuffer (  1  )  ;", "buffer . write (  (  ( byte )     (  ' a '  )  )  )  ;", "buffer . release (  )  ;", "buffer . release (  )  ;", "}", "METHOD_END"], "methodName": ["tooManyReleases"], "fileName": "org.springframework.core.io.buffer.PooledDataBufferTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull (     \"  '    must   not   be   null \"  )  ;", "byte [  ]    bytes    =    new   byte [ readableByteCount (  )  ]  ;", "read ( bytes )  ;", "return   bytes ;", "}", "METHOD_END"], "methodName": ["dumpBytes"], "fileName": "org.springframework.core.io.buffer.support.DataBufferTestUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( charset ,     \"  ' charset '    must   not   be   null \"  )  ;", "byte [  ]    bytes    =     . dumpBytes ( buffer )  ;", "return   new   String ( bytes ,    charset )  ;", "}", "METHOD_END"], "methodName": ["dumpString"], "fileName": "org.springframework.core.io.buffer.support.DataBufferTestUtils"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    this . bufferFactory . allocateBuffer (  4  )  ;", "byte [  ]    source    =    new   byte [  ]  {     ' a '  ,     ' b '  ,     ' c '  ,     ' d '     }  ;", "buffer . write ( source )  ;", "byte [  ]    result    =     . dumpBytes ( buffer )  ;", "Assert . assertArrayEquals ( source ,    result )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["dumpBytes"], "fileName": "org.springframework.core.io.buffer.support.DataBufferTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DataBuffer   buffer    =    this . bufferFactory . allocateBuffer (  4  )  ;", "String   source    =     \" abcd \"  ;", "buffer . write ( source . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "String   result    =     . dumpString ( buffer ,    StandardCharsets . UTF _  8  )  ;", "Assert . assertEquals ( source ,    result )  ;", "release ( buffer )  ;", "}", "METHOD_END"], "methodName": ["dumpString"], "fileName": "org.springframework.core.io.buffer.support.DataBufferTestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . charset ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.core.io.support.EncodedResource"}, {"methodBody": ["METHOD_START", "{", "return   this . encoding ;", "}", "METHOD_END"], "methodName": ["getEncoding"], "fileName": "org.springframework.core.io.support.EncodedResource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . charset )     !  =    null )     {", "return   new   InputStreamReader ( this . r . getInputStream (  )  ,    this . charset )  ;", "} else", "if    (  ( this . encoding )     !  =    null )     {", "return   new   InputStreamReader ( this . r . getInputStream (  )  ,    this . encoding )  ;", "} else    {", "return   new   InputStreamReader ( this . r . getInputStream (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getReader"], "fileName": "org.springframework.core.io.support.EncodedResource"}, {"methodBody": ["METHOD_START", "{", "return   this . resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.core.io.support.EncodedResource"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . encoding )     !  =    null )     |  |     (  ( this . charset )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["requiresReader"], "fileName": "org.springframework.core.io.support.EncodedResource"}, {"methodBody": ["METHOD_START", "{", "EncodedResource   er 1     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 8  _ CS )  ;", "EncodedResource   er 2     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 1  6  _ CS )  ;", "assertNotEquals ( er 1  ,    er 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithDifferentCharset"], "fileName": "org.springframework.core.io.support.EncodedResourceTests"}, {"methodBody": ["METHOD_START", "{", "EncodedResource   er 1     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 8  )  ;", "EncodedResource   er 2     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 1  6  )  ;", "assertNotEquals ( er 1  ,    er 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithDifferentEncoding"], "fileName": "org.springframework.core.io.support.EncodedResourceTests"}, {"methodBody": ["METHOD_START", "{", "EncodedResource   er 1     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 8  )  ;", "EncodedResource   er 2     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 8  _ CS )  ;", "assertNotEquals ( er 1  ,    er 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithEncodingAndCharset"], "fileName": "org.springframework.core.io.support.EncodedResourceTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( new   EncodedResource ( resource )  . equals ( null )  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithNullOtherObject"], "fileName": "org.springframework.core.io.support.EncodedResourceTests"}, {"methodBody": ["METHOD_START", "{", "EncodedResource   er 1     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 8  _ CS )  ;", "EncodedResource   er 2     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 8  _ CS )  ;", "assertEquals ( er 1  ,    er 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameCharset"], "fileName": "org.springframework.core.io.support.EncodedResourceTests"}, {"methodBody": ["METHOD_START", "{", "EncodedResource   er 1     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 8  )  ;", "EncodedResource   er 2     =    new   EncodedResource ( resource ,    EncodedResourceTests . UTF 8  )  ;", "assertEquals ( er 1  ,    er 2  )  ;", "}", "METHOD_END"], "methodName": ["equalsWithSameEncoding"], "fileName": "org.springframework.core.io.support.EncodedResourceTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Name   must   not   be   null \"  )  ;", "Assert . notNull ( extension ,     \" Extension   must   not   be   null \"  )  ;", "resource    =    null ;", "if    ( locale    !  =    null )     {", "String   lang    =    locale . getLanguage (  )  ;", "String   country    =    locale . getCountry (  )  ;", "String   variant    =    locale . getVariant (  )  ;", "if    (  ( variant . length (  )  )     >     0  )     {", "String   location    =     (  (  (  (  (  ( name    +     ( this . separator )  )     +    lang )     +     ( this . separator )  )     +    country )     +     ( this . separator )  )     +    variant )     +    extension ;", "resource    =    this . resourceLoader . get ( location )  ;", "}", "if    (  (  ( resource    =  =    null )     |  |     (  !  ( resource . exists (  )  )  )  )     &  &     (  ( country . length (  )  )     >     0  )  )     {", "String   location    =     (  (  (  ( name    +     ( this . separator )  )     +    lang )     +     ( this . separator )  )     +    country )     +    extension ;", "resource    =    this . resourceLoader . get ( location )  ;", "}", "if    (  (  ( resource    =  =    null )     |  |     (  !  ( resource . exists (  )  )  )  )     &  &     (  ( lang . length (  )  )     >     0  )  )     {", "String   location    =     (  ( name    +     ( this . separator )  )     +    lang )     +    extension ;", "resource    =    this . resourceLoader . get ( location )  ;", "}", "}", "if    (  ( resource    =  =    null )     |  |     (  !  ( resource . exists (  )  )  )  )     {", "String   location    =    name    +    extension ;", "resource    =    this . resourceLoader . get ( location )  ;", "}", "return   resource ;", "}", "METHOD_END"], "methodName": ["findLocalizedResource"], "fileName": "org.springframework.core.io.support.LocalizedResourceHelper"}, {"methodBody": ["METHOD_START", "{", "this . separator    =     ( separator    !  =    null )     ?    separator    :    LocalizedResourceHelper . DEFAULT _ SEPARATOR ;", "}", "METHOD_END"], "methodName": ["setSeparator"], "fileName": "org.springframework.core.io.support.LocalizedResourceHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( classLoader   instanceof   URLClassLoader )     {", "try    {", "for    ( URL   url    :     (  ( URLClassLoader )     ( classLoader )  )  . getURLs (  )  )     {", "try    {", "UrlResource   jarResource    =    new   UrlResource (  (  (  ( ResourceUtils . JAR _ URL _ PREFIX )     +    url )     +     ( ResourceUtils . JAR _ URL _ SEPARATOR )  )  )  ;", "if    ( jarResource . exists (  )  )     {", "result . add ( jarResource )  ;", "}", "}    catch    ( MalformedURLException   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Cannot   search   for   matching   files   underneath    [  \"     +    url )     +     \"  ]    because   it   cannot   be   converted   to   a   valid    ' jar :  '    URL :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "}", "}    catch    ( Exception   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Cannot   introspect   jar   files   since   ClassLoader    [  \"     +    classLoader )     +     \"  ]    does   not   support    ' getURLs (  )  '  :     \"  )     +    ex )  )  ;", "}", "}", "}", "if    ( classLoader    =  =     ( ClassLoader . getSystemClassLoader (  )  )  )     {", "addClassPathManifestEntries ( result )  ;", "}", "if    ( classLoader    !  =    null )     {", "try    {", "addAllClassLoaderJarRoots ( classLoader . getParent (  )  ,    result )  ;", "}    catch    ( Exception   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Cannot   introspect   jar   files   in   parent   ClassLoader   since    [  \"     +    classLoader )     +     \"  ]    does   not   support    ' getParent (  )  '  :     \"  )     +    ex )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["addAllClassLoaderJarRoots"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   javaClassPathProperty    =    System . getProperty (  \" path \"  )  ;", "for    ( String   path    :    StringUtils . delimitedListToStringArray ( javaClassPathProperty ,    System . getProperty (  \" path . separator \"  )  )  )     {", "try    {", "String   filePath    =    new   File ( path )  . getAbsolutePath (  )  ;", "int   prefixIndex    =    filePath . indexOf (  '  :  '  )  ;", "if    ( prefixIndex    =  =     1  )     {", "filePath    =    StringUtils . capitalize ( filePath )  ;", "}", "UrlResource   jarResource    =    new   UrlResource (  (  (  (  ( ResourceUtils . JAR _ URL _ PREFIX )     +     ( ResourceUtils . FILE _ URL _ PREFIX )  )     +    filePath )     +     ( ResourceUtils . JAR _ URL _ SEPARATOR )  )  )  ;", "if    (  (  (  !  ( result . contains ( jarResource )  )  )     &  &     (  !  ( hasDuplicate ( filePath ,    result )  )  )  )     &  &     ( jarResource . exists (  )  )  )     {", "result . add ( jarResource )  ;", "}", "}    catch    ( MalformedURLException   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Cannot   search   for   matching   files   underneath    [  \"     +    path )     +     \"  ]    because   it   cannot   be   converted   to   a   valid    ' jar :  '    URL :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "}", "}    catch    ( Exception   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Failed   to   evaluate    ' path '    manifest   entries :     \"     +    ex )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addClassPathManifestEntries"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   UrlResource ( url )  ;", "}", "METHOD_END"], "methodName": ["convertClassLoaderURL"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "int   prefixEnd    =     ( location . indexOf (  '  :  '  )  )     +     1  ;", "int   rootDirEnd    =    location . length (  )  ;", "while    (  ( rootDirEnd    >    prefixEnd )     &  &     ( geter (  )  . isPattern ( location . substring ( prefixEnd ,    rootDirEnd )  )  )  )     {", "rootDirEnd    =     ( location . lastIndexOf (  '  /  '  ,     ( rootDirEnd    -     2  )  )  )     +     1  ;", "}", "if    ( rootDirEnd    =  =     0  )     {", "rootDirEnd    =    prefixEnd ;", "}", "return   location . substring (  0  ,    rootDirEnd )  ;", "}", "METHOD_END"], "methodName": ["determineRootDir"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "Set < Resource >    result    =    new   LinkedHashSet <  >  (  1  6  )  ;", "ClassLoader   cl    =    getClassLoader (  )  ;", "Enumeration < URL >    resourceUrls    =     ( cl    !  =    null )     ?    cl . getResources ( path )     :    ClassLoader . getSystemResources ( path )  ;", "while    ( resourceUrls . hasMoreElements (  )  )     {", "URL   url    =    resourceUrls . nextElement (  )  ;", "result . add ( convertClassLoaderURL ( url )  )  ;", "}", "if    (  \"  \"  . equals ( path )  )     {", "addAllClassLoaderJarRoots ( cl ,    result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["doFindAllClassPathResources"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( PathMatchingResourcePatternResolver . logger . isDebugEnabled (  )  )     {", "PathMatchingResourcePatternResolver . logger . debug (  (  (  \" Looking   for   matching   resources   in   directory   tree    [  \"     +     ( rootDir . getPath (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "Set < File >    matchingFiles    =    retrieveMatchingFiles ( rootDir ,    subPattern )  ;", "Set < Resource >    result    =    new   LinkedHashSet <  >  ( matchingFiles . size (  )  )  ;", "for    ( File   file    :    matchingFiles )     {", "result . add ( new   FileSystemResource ( file )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["doFindMatchingFileSystemResources"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "File   rootDir ;", "try    {", "rootDir    =    rootDirResource . getFile (  )  . getAbsoluteFile (  )  ;", "}    catch    ( IOException   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  (  \" Cannot   search   for   matching   files   underneath    \"     +    rootDirResource )     +     \"    because   it   does   not   correspond   to   a   directory   in   the   file   system \"  )  ,    ex )  ;", "}", "return   Collections . emptySet (  )  ;", "}", "return   doFindMatchingFileSystemResources ( rootDir ,    subPattern )  ;", "}", "METHOD_END"], "methodName": ["doFindPathMatchingFileResources"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "URLConnection   con    =    rootDirURL . openConnection (  )  ;", "JarFile   jarFile ;", "String   jarFileUrl ;", "String   rootEntryPath ;", "boolean   closeJarFile ;", "if    ( con   instanceof   JarURLConnection )     {", "JarURLConnection   jarCon    =     (  ( JarURLConnection )     ( con )  )  ;", "ResourceUtils . useCachesIfNecessary ( jarCon )  ;", "jarFile    =    jarCon . getJarFile (  )  ;", "jarFileUrl    =    jarCon . getJarFileURL (  )  . toExternalForm (  )  ;", "JarEntry   jarEntry    =    jarCon . getJarEntry (  )  ;", "rootEntryPath    =     ( jarEntry    !  =    null )     ?    jarEntry . getName (  )     :     \"  \"  ;", "closeJarFile    =     !  ( jarCon . getUseCaches (  )  )  ;", "} else    {", "String   urlFile    =    rootDirURL . getFile (  )  ;", "try    {", "int   separatorIndex    =    urlFile . indexOf ( ResourceUtils . WAR _ URL _ SEPARATOR )  ;", "if    ( separatorIndex    =  =     (  -  1  )  )     {", "separatorIndex    =    urlFile . indexOf ( ResourceUtils . JAR _ URL _ SEPARATOR )  ;", "}", "if    ( separatorIndex    !  =     (  -  1  )  )     {", "jarFileUrl    =    urlFile . substring (  0  ,    separatorIndex )  ;", "rootEntryPath    =    urlFile . substring (  ( separatorIndex    +     2  )  )  ;", "jarFile    =    getJarFile ( jarFileUrl )  ;", "} else    {", "jarFile    =    new   JarFile ( urlFile )  ;", "jarFileUrl    =    urlFile ;", "rootEntryPath    =     \"  \"  ;", "}", "closeJarFile    =    true ;", "}    catch    ( ZipException   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Skipping   invalid   jar   classpath   entry    [  \"     +    urlFile )     +     \"  ]  \"  )  )  ;", "}", "return   Collections . emptySet (  )  ;", "}", "}", "try    {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Looking   for   matching   resources   in   jar   file    [  \"     +    jarFileUrl )     +     \"  ]  \"  )  )  ;", "}", "if    (  (  !  (  \"  \"  . equals ( rootEntryPath )  )  )     &  &     (  !  ( rootEntryPath . endsWith (  \"  /  \"  )  )  )  )     {", "rootEntryPath    =    rootEntryPath    +     \"  /  \"  ;", "}", "Set < Resource >    result    =    new   LinkedHashSet <  >  (  8  )  ;", "for    ( Enumeration < JarEntry >    entries    =    jarFile . entries (  )  ;    entries . hasMoreElements (  )  ;  )     {", "JarEntry   entry    =    entries . nextElement (  )  ;", "String   entryPath    =    entry . getName (  )  ;", "if    ( entryPath . startsWith ( rootEntryPath )  )     {", "String   relativePath    =    entryPath . substring ( rootEntryPath . length (  )  )  ;", "if    ( getPathMatcher (  )  . match ( subPattern ,    relativePath )  )     {", "result . add ( rootDirResource . createRelative ( relativePath )  )  ;", "}", "}", "}", "return   result ;", "}    finally    {", "if    ( closeJarFile )     {", "jarFile . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doFindPathMatchingJarResources"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( PathMatchingResourcePatternResolver . logger . isDebugEnabled (  )  )     {", "PathMatchingResourcePatternResolver . logger . debug (  (  (  (  (  \" Searching   directory    [  \"     +     ( dir . getAbsolutePath (  )  )  )     +     \"  ]    for   files   matching   pattern    [  \"  )     +    fullPattern )     +     \"  ]  \"  )  )  ;", "}", "File [  ]    dirContents    =    dir . listFiles (  )  ;", "if    ( dirContents    =  =    null )     {", "if    ( PathMatchingResourcePatternResolver . logger . isWarnEnabled (  )  )     {", "PathMatchingResourcePatternResolver . logger . warn (  (  (  \" Could   not   retrieve   contents   of   directory    [  \"     +     ( dir . getAbsolutePath (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return ;", "}", "Arrays . sort ( dirContents )  ;", "for    ( File   content    :    dirContents )     {", "String   currPath    =    StringUtils . replace ( content . getAbsolutePath (  )  ,    File . separator ,     \"  /  \"  )  ;", "if    (  ( content . isDirectory (  )  )     &  &     ( getPathMatcher (  )  . matchStart ( fullPattern ,     ( currPath    +     \"  /  \"  )  )  )  )     {", "if    (  !  ( content . canRead (  )  )  )     {", "if    ( PathMatchingResourcePatternResolver . logger . isDebugEnabled (  )  )     {", "PathMatchingResourcePatternResolver . logger . debug (  (  (  \" Skipping   subdirectory    [  \"     +     ( dir . getAbsolutePath (  )  )  )     +     \"  ]    because   the   application   is   not   allowed   to   read   the   directory \"  )  )  ;", "}", "} else    {", "doRetrieveMatchingFiles ( fullPattern ,    content ,    result )  ;", "}", "}", "if    ( getPathMatcher (  )  . match ( fullPattern ,    currPath )  )     {", "result . add ( content )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doRetrieveMatchingFiles"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "String   path    =    location ;", "if    ( path . startsWith (  \"  /  \"  )  )     {", "path    =    path . substring (  1  )  ;", "}", "Set < Resource >    result    =    doFindAllClassPathResources ( path )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Resolved   classpath   location    [  \"     +    location )     +     \"  ]    to   resources    \"  )     +    result )  )  ;", "}", "return   result . toArray ( new   Resource [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["findAllClassPathResources"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "String   rootDirPath    =    determineRootDir ( locationPattern )  ;", "String   subPattern    =    locationPattern . substring ( rootDirPath . length (  )  )  ;", "Resource [  ]    rootDirResources    =    getResources ( rootDirPath )  ;", "Set < Resource >    result    =    new   LinkedHashSet <  >  (  1  6  )  ;", "for    ( Resource   rootDirResource    :    rootDirResources )     {", "rootDirResource    =    resolveRootDirResource ( rootDirResource )  ;", "URL   rootDirUrl    =    rootDirResource . getURL (  )  ;", "if    (  (  (  . equinoxResolveMethod )     !  =    null )     &  &     ( rootDirUrl . getProtocol (  )  . startsWith (  \" bundle \"  )  )  )     {", "URL   resolvedUrl    =     (  ( URL )     ( ReflectionUtils . invokeMethod (  . equinoxResolveMethod ,    null ,    rootDirUrl )  )  )  ;", "if    ( resolvedUrl    !  =    null )     {", "rootDirUrl    =    resolvedUrl ;", "}", "rootDirResource    =    new   UrlResource ( rootDirUrl )  ;", "}", "if    ( rootDirUrl . getProtocol (  )  . startsWith ( ResourceUtils . URL _ PROTOCOL _ VFS )  )     {", "result . addAll (  . VfsResourceMatchingDelegate . findMatchingResources ( rootDirUrl ,    subPattern ,    getPathMatcher (  )  )  )  ;", "} else", "if    (  ( ResourceUtils . isJarURL ( rootDirUrl )  )     |  |     ( isJarResource ( rootDirResource )  )  )     {", "result . addAll ( doFindPathMatchingJarResources ( rootDirResource ,    rootDirUrl ,    subPattern )  )  ;", "} else    {", "result . addAll ( doFindPathMatchingFileResources ( rootDirResource ,    subPattern )  )  ;", "}", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Resolved   location   pattern    [  \"     +    locationPattern )     +     \"  ]    to   resources    \"  )     +    result )  )  ;", "}", "return   result . toArray ( new   Resource [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["findPathMatchingResources"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( jarFileUrl . startsWith ( ResourceUtils . FILE _ URL _ PREFIX )  )     {", "try    {", "return   new   JarFile ( ResourceUtils . toURI ( jarFileUrl )  . getSchemeSpecificPart (  )  )  ;", "}    catch    ( URISyntaxException   ex )     {", "return   new   JarFile ( jarFileUrl . substring ( ResourceUtils . FILE _ URL _ PREFIX . length (  )  )  )  ;", "}", "} else    {", "return   new   JarFile ( jarFileUrl )  ;", "}", "}", "METHOD_END"], "methodName": ["getJarFile"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . pathMatcher ;", "}", "METHOD_END"], "methodName": ["getPathMatcher"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceLoader ;", "}", "METHOD_END"], "methodName": ["getResourceLoader"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( result . isEmpty (  )  )     {", "return   false ;", "}", "String   duplicatePath    =     ( filePath . startsWith (  \"  /  \"  )  )     ?    filePath . substring (  1  )     :     \"  /  \"     +    filePath ;", "try    {", "return   result . contains ( new   Url (  (  (  (  ( Utils . JAR _ URL _ PREFIX )     +     ( Utils . FILE _ URL _ PREFIX )  )     +    duplicatePath )     +     ( Utils . JAR _ URL _ SEPARATOR )  )  )  )  ;", "}    catch    ( MalformedURLException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["hasDuplicate"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isJarResource"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "return   original ;", "}", "METHOD_END"], "methodName": ["resolveRootDirResource"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( rootDir . exists (  )  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Skipping    [  \"     +     ( rootDir . getAbsolutePath (  )  )  )     +     \"  ]    because   it   does   not   exist \"  )  )  ;", "}", "return   Collections . emptySet (  )  ;", "}", "if    (  !  ( rootDir . isDirectory (  )  )  )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  (  \" Skipping    [  \"     +     ( rootDir . getAbsolutePath (  )  )  )     +     \"  ]    because   it   does   not   denote   a   directory \"  )  )  ;", "}", "return   Collections . emptySet (  )  ;", "}", "if    (  !  ( rootDir . canRead (  )  )  )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  (  \" Cannot   search   for   matching   files   underneath   directory    [  \"     +     ( rootDir . getAbsolutePath (  )  )  )     +     \"  ]    because   the   application   is   not   allowed   to   read   the   directory \"  )  )  ;", "}", "return   Collections . emptySet (  )  ;", "}", "String   fullPattern    =    StringUtils . replace ( rootDir . getAbsolutePath (  )  ,    File . separator ,     \"  /  \"  )  ;", "if    (  !  ( pattern . startsWith (  \"  /  \"  )  )  )     {", "fullPattern    +  =     \"  /  \"  ;", "}", "fullPattern    =    fullPattern    +     ( StringUtils . replace ( pattern ,    File . separator ,     \"  /  \"  )  )  ;", "Set < File >    result    =    new   LinkedHashSet <  >  (  8  )  ;", "doRetrieveMatchingFiles ( fullPattern ,    rootDir ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["retrieveMatchingFiles"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( pathMatcher ,     \" PathMatcher   must   not   be   null \"  )  ;", "this . pathMatcher    =    pathMatcher ;", "}", "METHOD_END"], "methodName": ["setPathMatcher"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolver"}, {"methodBody": ["METHOD_START", "{", "String   filename    =    resource . getFilename (  )  ;", "assertTrue (  ( resource    +     \"    does   not   have   a   filename   that   matches   any   of   the   specified   names \"  )  ,    Arrays . stream ( filenames )  . anyMatch ( filename :  : endsWith )  )  ;", "}", "METHOD_END"], "methodName": ["assertFilenameIn"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Correct   number   of   files   found \"  ,    filenames . length ,    resources . length )  ;", "for    (    resource    :    resources )     {", "String   actualProtocol    =    resource . getURL (  )  . getProtocol (  )  ;", "assertEquals ( protocol ,    actualProtocol )  ;", "assertFilenameIn ( resource ,    filenames )  ;", "}", "}", "METHOD_END"], "methodName": ["assertProtocolAndFilenames"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource [  ]    resources    =    resolver . getResources (  \" classpath *  : org / reactivestreams /  *  . class \"  )  ;", "assertProtocolAndFilenames ( resources ,     \" jar \"  ,     . CLASSES _ IN _ REACTIVESTREAMS )  ;", "}", "METHOD_END"], "methodName": ["classpathStarWithPatternInJar"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource [  ]    resources    =    resolver . getResources (  \" classpath *  : org / springframework / core / io / sup *  /  *  . class \"  )  ;", "List < Resource >    noCloverResources    =    new   ArrayList <  >  (  )  ;", "for    ( Resource   resource    :    resources )     {", "if    (  !  ( resource . getFilename (  )  . contains (  \"  $  _  _ CLOVER _  \"  )  )  )     {", "noCloverResources . add ( resource )  ;", "}", "}", "resources    =    noCloverResources . toArray ( new   Resource [ noCloverResources . size (  )  ]  )  ;", "assertProtocolAndFilenames ( resources ,     \" file \"  ,    StringUtils . concatenateStringArrays (  . CLASSES _ IN _ CORE _ IO _ SUPPORT ,     . TEST _ CLASSES _ IN _ CORE _ IO _ SUPPORT )  )  ;", "}", "METHOD_END"], "methodName": ["classpathStarWithPatternOnFileSystem"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource [  ]    resources    =    resolver . getResources (  \" classpath : org / reactivestreams /  *  . class \"  )  ;", "assertProtocolAndFilenames ( resources ,     \" jar \"  ,     . CLASSES _ IN _ REACTIVESTREAMS )  ;", "}", "METHOD_END"], "methodName": ["classpathWithPatternInJar"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests"}, {"methodBody": ["METHOD_START", "{", "resolver . getResources (  \" xx *  *  :  *  *  /  *  . xy \"  )  ;", "}", "METHOD_END"], "methodName": ["invalidPrefixWithPatternElementInIt"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource [  ]    resources    =    resolver . getResources (  \" classpath *  :  *  . dtd \"  )  ;", "boolean   found    =    false ;", "for    ( Resource   resource    :    resources )     {", "if    ( resource . getFilename (  )  . equals (  \" aspectj _  1  _  5  _  0  . dtd \"  )  )     {", "found    =    true ;", "}", "}", "assertTrue (  \" Could   not   find   aspectj _  1  _  5  _  0  . dtd   in   the   root   of   the   aspectjweaver   jar \"  ,    found )  ;", "}", "METHOD_END"], "methodName": ["rootPatternRetrievalInJarFiles"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource [  ]    resources    =    resolver . getResources (  \" org / reactivestreams / Publisher . class \"  )  ;", "assertEquals (  1  ,    resources . length )  ;", "assertProtocolAndFilenames ( resources ,     \" jar \"  ,     \" Publisher . class \"  )  ;", "}", "METHOD_END"], "methodName": ["singleResourceInJar"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests"}, {"methodBody": ["METHOD_START", "{", "Resource [  ]    resources    =    resolver . getResources (  \" org / springframework / core / io / support / PathMatchingResourcePatternResolverTests . class \"  )  ;", "assertEquals (  1  ,    resources . length )  ;", "assertProtocolAndFilenames ( resources ,     \" file \"  ,     \" PathMatchingResourcePatternResolverTests . class \"  )  ;", "}", "METHOD_END"], "methodName": ["singleResourceOnFileSystem"], "fileName": "org.springframework.core.io.support.PathMatchingResourcePatternResolverTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . locations )     !  =    null )     {", "for    ( Resource   location    :    this . locations )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Loading   properties   file   from    \"     +    location )  )  ;", "}", "try    {", "Utils . fillProperties ( props ,    new   EncodedResource ( location ,    this . fileEncoding )  ,    this . propertiesPersister )  ;", "}    catch    ( FileNotFoundException    |    UnknownHostException   ex )     {", "if    ( this . ignoreResourceNotFound )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Properties   resource   not   found :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "} else    {", "throw   ex ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["loadProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "Properties   result    =    new   Properties (  )  ;", "if    ( this . localOverride )     {", "loadProperties ( result )  ;", "}", "if    (  ( this . localProperties )     !  =    null )     {", "for    ( Properties   localProp    :    this . localProperties )     {", "CollectionUtils . mergePropertiesIntoMap ( localProp ,    result )  ;", "}", "}", "if    (  !  ( this . localOverride )  )     {", "loadProperties ( result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["mergeProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "this . fileEncoding    =    encoding ;", "}", "METHOD_END"], "methodName": ["setFileEncoding"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "this . ignoreResourceNotFound    =    ignoreResourceNotFound ;", "}", "METHOD_END"], "methodName": ["setIgnoreResourceNotFound"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "this . localOverride    =    localOverride ;", "}", "METHOD_END"], "methodName": ["setLocalOverride"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "this . locations    =    new   Resource [  ]  {    location    }  ;", "}", "METHOD_END"], "methodName": ["setLocation"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "this . locations    =    locations ;", "}", "METHOD_END"], "methodName": ["setLocations"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "this . localProperties    =    new   Properties [  ]  {    properties    }  ;", "}", "METHOD_END"], "methodName": ["setProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "this . localProperties    =    propertiesArray ;", "}", "METHOD_END"], "methodName": ["setPropertiesArray"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "this . propertiesPersister    =     ( propertiesPersister    !  =    null )     ?    propertiesPersister    :    new   DefaultPropertiesPersister (  )  ;", "}", "METHOD_END"], "methodName": ["setPropertiesPersister"], "fileName": "org.springframework.core.io.support.PropertiesLoaderSupport"}, {"methodBody": ["METHOD_START", "{", "InputStream   is    =    resource . getInputStream (  )  ;", "try    {", "String   filename    =    resource . getFilename (  )  ;", "if    (  ( filename    !  =    null )     &  &     ( filename . endsWith (  . XML _ FILE _ EXTENSION )  )  )     {", "props . loadFromXML ( is )  ;", "} else    {", "props . load ( is )  ;", "}", "}    finally    {", "is . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["fillProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "PropertiesLoaderUtils . fillProperties ( props ,    resource ,    new   DefaultPropertiesPersister (  )  )  ;", "}", "METHOD_END"], "methodName": ["fillProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "InputStream   stream    =    null ;", "Reader   reader    =    null ;", "try    {", "String   filename    =    resource . getResource (  )  . getFilename (  )  ;", "if    (  ( filename    !  =    null )     &  &     ( filename . endsWith (  . XML _ FILE _ EXTENSION )  )  )     {", "stream    =    resource . getInputStream (  )  ;", "persister . loadFromXml ( props ,    stream )  ;", "} else", "if    ( resource . requiresReader (  )  )     {", "reader    =    resource . getReader (  )  ;", "persister . load ( props ,    reader )  ;", "} else    {", "stream    =    resource . getInputStream (  )  ;", "persister . load ( props ,    stream )  ;", "}", "}    finally    {", "if    ( stream    !  =    null )     {", "stream . close (  )  ;", "}", "if    ( reader    !  =    null )     {", "reader . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["fillProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "return   PropertiesLoaderUtils . loadAllProperties ( resourceName ,    null )  ;", "}", "METHOD_END"], "methodName": ["loadAllProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourceName ,     \" Resource   name   must   not   be   null \"  )  ;", "ClassLoader   classLoaderToUse    =    classLoader ;", "if    ( classLoaderToUse    =  =    null )     {", "classLoaderToUse    =    ClassUtils . getDefaultClassLoader (  )  ;", "}", "Enumeration < URL >    urls    =     ( classLoaderToUse    !  =    null )     ?    classLoaderToUse . getResources ( resourceName )     :    ClassLoader . getSystemResources ( resourceName )  ;", "Properties   props    =    new   Properties (  )  ;", "while    ( urls . hasMoreElements (  )  )     {", "URL   url    =    urls . nextElement (  )  ;", "URLConnection   con    =    url . openConnection (  )  ;", "ResourceUtils . useCachesIfNecessary ( con )  ;", "InputStream   is    =    con . getInputStream (  )  ;", "try    {", "if    ( resourceName . endsWith (  . XML _ FILE _ EXTENSION )  )     {", "props . loadFromXML ( is )  ;", "} else    {", "props . load ( is )  ;", "}", "}    finally    {", "is . close (  )  ;", "}", "}", "return   props ;", "}", "METHOD_END"], "methodName": ["loadAllProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", ". fillProperties ( props ,    resource )  ;", "return   props ;", "}", "METHOD_END"], "methodName": ["loadProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", ". fillProperties ( props ,    resource )  ;", "return   props ;", "}", "METHOD_END"], "methodName": ["loadProperties"], "fileName": "org.springframework.core.io.support.PropertiesLoaderUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . propertyResolver )     =  =    null )     {", "this . propertyResolver    =    new   StandardEnvironment (  )  ;", "}", "return   this . ignoreUnresolvablePlaceholders    ?    this . propertyResolver . resolvePlaceholders ( path )     :    this . propertyResolver . resolveRequiredPlaceholders ( path )  ;", "}", "METHOD_END"], "methodName": ["resolvePath"], "fileName": "org.springframework.core.io.support.ResourceArrayPropertyEditor"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    new   ResourceArrayPropertyEditor (  )  ;", "editor . setAsText (  \" classpath *  : org / springframework / core / io / support / Resource * Editor . class \"  )  ;", "Resource [  ]    resources    =     (  ( Resource [  ]  )     ( editor . getValue (  )  )  )  ;", "assertNotNull ( resources )  ;", "assertTrue ( resources [  0  ]  . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternResource"], "fileName": "org.springframework.core.io.support.ResourceArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    new   ResourceArrayPropertyEditor ( new   PathMatchingResourcePatternResolver (  )  ,    new   StandardEnvironment (  )  ,    false )  ;", "System . setProperty (  \" test . prop \"  ,     \" foo \"  )  ;", "try    {", "editor . setAsText (  \"  $  { test . prop }  -  $  { bar }  \"  )  ;", "Resource [  ]    resources    =     (  ( Resource [  ]  )     ( editor . getValue (  )  )  )  ;", "assertEquals (  \" foo -  $  { bar }  \"  ,    resources [  0  ]  . getFilename (  )  )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" test . prop \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testStrictSystemPropertyReplacement"], "fileName": "org.springframework.core.io.support.ResourceArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    new   ResourceArrayPropertyEditor (  )  ;", "System . setProperty (  \" test . prop \"  ,     \" foo \"  )  ;", "try    {", "editor . setAsText (  \"  $  { test . prop }  -  $  { bar }  \"  )  ;", "Resource [  ]    resources    =     (  ( Resource [  ]  )     ( editor . getValue (  )  )  )  ;", "assertEquals (  \" foo -  $  { bar }  \"  ,    resources [  0  ]  . getFilename (  )  )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" test . prop \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSystemPropertyReplacement"], "fileName": "org.springframework.core.io.support.ResourceArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    new   ResourceArrayPropertyEditor (  )  ;", "editor . setAsText (  \" classpath : org / springframework / core / io / support / ResourceArrayPropertyEditor . class \"  )  ;", "Resource [  ]    resources    =     (  ( Resource [  ]  )     ( editor . getValue (  )  )  )  ;", "assertNotNull ( resources )  ;", "assertTrue ( resources [  0  ]  . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testVanillaResource"], "fileName": "org.springframework.core.io.support.ResourceArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( resourceLoader   instanceof   ResourcePatternResolver )     {", "return    (  ( ResourcePatternResolver )     ( resourceLoader )  )  ;", "} else", "if    ( resourceLoader    !  =    null )     {", "return   new   PathMatchingResourcePatternResolver ( resourceLoader )  ;", "} else    {", "return   new   PathMatchingResourcePatternResolver (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getResourcePatternResolver"], "fileName": "org.springframework.core.io.support.ResourcePatternUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( resourceLocation    !  =    null )     &  &     (  ( resourceLocation . startsWith ( ResourcePatternResolver . CLASSPATH _ ALL _ URL _ PREFIX )  )     |  |     ( ResourceUtils . isUrl ( resourceLocation )  )  )  ;", "}", "METHOD_END"], "methodName": ["isUrl"], "fileName": "org.springframework.core.io.support.ResourcePatternUtils"}, {"methodBody": ["METHOD_START", "{", "String   name    =    resource . getDescription (  )  ;", "if    (  !  ( StringUtils . hasText ( name )  )  )     {", "name    =     (  ( resource . getClass (  )  . getSimpleName (  )  )     +     \"  @  \"  )     +     ( System . identityHashCode ( resource )  )  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["getNameForResource"], "fileName": "org.springframework.core.io.support.ResourcePropertySource"}, {"methodBody": ["METHOD_START", "{", "if    ( this . name . equals ( name )  )     {", "return   this ;", "}", "if    (  ( this . resourceName )     !  =    null )     {", "if    ( this . resourceName . equals ( name )  )     {", "return   new    ( this . resourceName ,    null ,    this . source )  ;", "} else    {", "return   new    ( name ,    this . resourceName ,    this . source )  ;", "}", "} else    {", "return   new    ( name ,    this . name ,    this . source )  ;", "}", "}", "METHOD_END"], "methodName": ["withName"], "fileName": "org.springframework.core.io.support.ResourcePropertySource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . resourceName )     =  =    null )     {", "return   this ;", "}", "return   new    ( this . resourceName ,    null ,    this . source )  ;", "}", "METHOD_END"], "methodName": ["withResourceName"], "fileName": "org.springframework.core.io.support.ResourcePropertySource"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   ResourcePropertySource (  \" ps 1  \"  ,    ResourcePropertySourceTests . PROPERTIES _ LOCATION )  ;", "assertEquals (  \" bar \"  ,    ps . getProperty (  \" foo \"  )  )  ;", "assertThat ( ps . getName (  )  ,    is (  \" ps 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withLocationAndExplicitName"], "fileName": "org.springframework.core.io.support.ResourcePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   ResourcePropertySource (  \" ps 1  \"  ,    ResourcePropertySourceTests . PROPERTIES _ LOCATION ,    getClass (  )  . getClassLoader (  )  )  ;", "assertEquals (  \" bar \"  ,    ps . getProperty (  \" foo \"  )  )  ;", "assertThat ( ps . getName (  )  ,    is (  \" ps 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withLocationAndExplicitNameAndExplicitClassLoader"], "fileName": "org.springframework.core.io.support.ResourcePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   ResourcePropertySource ( ResourcePropertySourceTests . PROPERTIES _ LOCATION )  ;", "assertEquals (  \" bar \"  ,    ps . getProperty (  \" foo \"  )  )  ;", "assertThat ( ps . getName (  )  ,    is ( ResourcePropertySourceTests . PROPERTIES _ RESOURCE _ DESCRIPTION )  )  ;", "}", "METHOD_END"], "methodName": ["withLocationAndGeneratedName"], "fileName": "org.springframework.core.io.support.ResourcePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   ResourcePropertySource ( ResourcePropertySourceTests . PROPERTIES _ LOCATION ,    getClass (  )  . getClassLoader (  )  )  ;", "assertEquals (  \" bar \"  ,    ps . getProperty (  \" foo \"  )  )  ;", "assertThat ( ps . getName (  )  ,    is ( ResourcePropertySourceTests . PROPERTIES _ RESOURCE _ DESCRIPTION )  )  ;", "}", "METHOD_END"], "methodName": ["withLocationAndGeneratedNameAndExplicitClassLoader"], "fileName": "org.springframework.core.io.support.ResourcePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   ResourcePropertySource (  \" ps 1  \"  ,    new   ClassPathResource ( ResourcePropertySourceTests . PROPERTIES _ PATH )  )  ;", "assertEquals (  \" bar \"  ,    ps . getProperty (  \" foo \"  )  )  ;", "assertThat ( ps . getName (  )  ,    is (  \" ps 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withResourceAndExplicitName"], "fileName": "org.springframework.core.io.support.ResourcePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   ResourcePropertySource ( new   ClassPathResource ( ResourcePropertySourceTests . PROPERTIES _ PATH )  )  ;", "assertEquals (  \" bar \"  ,    ps . getProperty (  \" foo \"  )  )  ;", "assertThat ( ps . getName (  )  ,    is ( ResourcePropertySourceTests . PROPERTIES _ RESOURCE _ DESCRIPTION )  )  ;", "}", "METHOD_END"], "methodName": ["withResourceAndGeneratedName"], "fileName": "org.springframework.core.io.support.ResourcePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   ResourcePropertySource ( new   ByteArrayResource (  \" foo = bar \"  . getBytes (  )  ,     \"  \"  )  )  ;", "assertEquals (  \" bar \"  ,    ps . getProperty (  \" foo \"  )  )  ;", "assertEquals (  \" Byte   array   resource    [  ]  \"  ,    ps . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["withResourceHavingNoDescription"], "fileName": "org.springframework.core.io.support.ResourcePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "PropertySource <  ?  >    ps    =    new   ResourcePropertySource ( ResourcePropertySourceTests . XML _ PROPERTIES _ LOCATION )  ;", "assertEquals (  \" bar \"  ,    ps . getProperty (  \" foo \"  )  )  ;", "assertThat ( ps . getName (  )  ,    is ( ResourcePropertySourceTests . XML _ PROPERTIES _ RESOURCE _ DESCRIPTION )  )  ;", "}", "METHOD_END"], "methodName": ["xmlWithLocationAndGeneratedName"], "fileName": "org.springframework.core.io.support.ResourcePropertySourceTests"}, {"methodBody": ["METHOD_START", "{", "return   this . count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.core.io.support.ResourceRegion"}, {"methodBody": ["METHOD_START", "{", "return   this . position ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "org.springframework.core.io.support.ResourceRegion"}, {"methodBody": ["METHOD_START", "{", "return   this . resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.core.io.support.ResourceRegion"}, {"methodBody": ["METHOD_START", "{", "new   ResourceRegion ( mock ( Resource . class )  ,     0  ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldThrowExceptionForNegativeCount"], "fileName": "org.springframework.core.io.support.ResourceRegionTests"}, {"methodBody": ["METHOD_START", "{", "new   ResourceRegion ( mock ( Resource . class )  ,     (  -  1  )  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["shouldThrowExceptionForNegativePosition"], "fileName": "org.springframework.core.io.support.ResourceRegionTests"}, {"methodBody": ["METHOD_START", "{", "new   ResourceRegion ( null ,     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["shouldThrowExceptionWithNullResource"], "fileName": "org.springframework.core.io.support.ResourceRegionTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?  >    instanceClass    =    ClassUtils . forName ( instanceClassName ,    clas )  ;", "if    (  !  ( factoryClass . isAssignableFrom ( instanceClass )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Class    [  \"     +    instanceClassName )     +     \"  ]    is   not   assignable   to    [  \"  )     +     ( factoryClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return    (  ( T )     ( ReflectionUtils . accessibleConstructor ( instanceClass )  . newInstance (  )  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  \" Unable   to   instantiate   factory   class :     \"     +     ( factoryClass . getName (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["instantiateFactory"], "fileName": "org.springframework.core.io.support.SpringFactoriesLoader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( factoryClass ,     \"  ' factoryClass '    must   not   be   null \"  )  ;", "ClassLoader   classLoaderToUse    =    classLoader ;", "if    ( classLoaderToUse    =  =    null )     {", "classLoaderToUse    =     . class . getClassLoader (  )  ;", "}", "List < String >    factoryNames    =     . loadFactoryNames ( factoryClass ,    classLoaderToUse )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  (  \" Loaded    [  \"     +     ( factoryClass . getName (  )  )  )     +     \"  ]    names :     \"  )     +    factoryNames )  )  ;", "}", "List < T >    result    =    new   ArrayList <  >  ( factoryNames . size (  )  )  ;", "for    ( String   factoryName    :    factoryNames )     {", "result . add (  . instantiateFactory ( factoryName ,    factoryClass ,    classLoaderToUse )  )  ;", "}", "AnnotationAwareOrderComparator . sort ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["loadFactories"], "fileName": "org.springframework.core.io.support.SpringFactoriesLoader"}, {"methodBody": ["METHOD_START", "{", "String   factoryClassName    =    factoryClass . getName (  )  ;", "return    . loadSpringFactories ( classLoader )  . getOrDefault ( factoryClassName ,    Collections . emptyList (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadFactoryNames"], "fileName": "org.springframework.core.io.support.SpringFactoriesLoader"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    result    =    SpringFactoriesLoader . cache . get ( classLoader )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "try    {", "Enumeration < URL >    urls    =     ( classLoader    !  =    null )     ?    classLoader . getResources ( SpringFactoriesLoader . FACTORIES _ RESOURCE _ LOCATION )     :    ClassLoader . getSystemResources ( SpringFactoriesLoader . FACTORIES _ RESOURCE _ LOCATION )  ;", "result    =    new   LinkedMultiValueMap <  >  (  )  ;", "while    ( urls . hasMoreElements (  )  )     {", "URL   url    =    urls . nextElement (  )  ;", "UrlResource   resource    =    new   UrlResource ( url )  ;", "Properties   properties    =    PropertiesLoaderUtils . loadProperties ( resource )  ;", "for    ( Map . Entry <  ?  ,     ?  >    entry    :    properties . entrySet (  )  )     {", "List < String >    factoryClassNames    =    Arrays . asList ( StringUtils . commaDelimitedListToStringArray (  (  ( String )     ( entry . getValue (  )  )  )  )  )  ;", "result . addAll (  (  ( String )     ( entry . getKey (  )  )  )  ,    factoryClassNames )  ;", "}", "}", "SpringFactoriesLoader . cache . put ( classLoader ,    result )  ;", "return   result ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalArgumentException (  (  (  \" Unable   to   load   factories   from   location    [  \"     +     ( SpringFactoriesLoader . FACTORIES _ RESOURCE _ LOCATION )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["loadSpringFactories"], "fileName": "org.springframework.core.io.support.SpringFactoriesLoader"}, {"methodBody": ["METHOD_START", "{", "List < DummyFactory >    factories    =    SpringFactoriesLoader . loadFactories ( DummyFactory . class ,    null )  ;", "assertEquals (  2  ,    factories . size (  )  )  ;", "assertTrue (  (  ( factories . get (  0  )  )    instanceof   MyDummyFactory 1  )  )  ;", "assertTrue (  (  ( factories . get (  1  )  )    instanceof   MyDummyFactory 2  )  )  ;", "}", "METHOD_END"], "methodName": ["loadFactoriesInCorrectOrder"], "fileName": "org.springframework.core.io.support.SpringFactoriesLoaderTests"}, {"methodBody": ["METHOD_START", "{", "SpringFactoriesLoader . loadFactories ( String . class ,    null )  ;", "}", "METHOD_END"], "methodName": ["loadInvalid"], "fileName": "org.springframework.core.io.support.SpringFactoriesLoaderTests"}, {"methodBody": ["METHOD_START", "{", "List < DummyPackagePrivateFactory >    factories    =    SpringFactoriesLoader . loadFactories ( DummyPackagePrivateFactory . class ,    null )  ;", "assertEquals (  1  ,    factories . size (  )  )  ;", "assertTrue (  (  (  ( factories . get (  0  )  . getClass (  )  . getModifiers (  )  )     &     ( Modifier . PUBLIC )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["loadPackagePrivateFactory"], "fileName": "org.springframework.core.io.support.SpringFactoriesLoaderTests"}, {"methodBody": ["METHOD_START", "{", "return   VfsUtils . getRoot ( url )  ;", "}", "METHOD_END"], "methodName": ["findRoot"], "fileName": "org.springframework.core.io.support.VfsPatternUtils"}, {"methodBody": ["METHOD_START", "{", "String   path    =    VfsUtils . doGetPath ( resource )  ;", "return   path    !  =    null    ?    path    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.springframework.core.io.support.VfsPatternUtils"}, {"methodBody": ["METHOD_START", "{", "return   VfsUtils . doGetVisitorAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["getVisitorAttributes"], "fileName": "org.springframework.core.io.support.VfsPatternUtils"}, {"methodBody": ["METHOD_START", "{", "Object   visitorProxy    =    Proxy . newProxyInstance ( VfsUtils . VIRTUAL _ FILE _ VISITOR _ INTERFACE . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    VfsUtils . VIRTUAL _ FILE _ VISITOR _ INTERFACE    }  ,    visitor )  ;", "VfsUtils . invokeVfsMethod ( VfsUtils . VIRTUAL _ FILE _ METHOD _ VISIT ,    resource ,    visitorProxy )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.springframework.core.io.support.VfsPatternUtils"}, {"methodBody": ["METHOD_START", "{", "DeserializingConverter   fromBytes    =    new   DeserializingConverter (  )  ;", "fromBytes . convert (  \" Junk \"  . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["deserializationFailure"], "fileName": "org.springframework.core.serializer.SerializationConverterTests"}, {"methodBody": ["METHOD_START", "{", "SerializingConverter   toBytes    =    new   SerializingConverter (  )  ;", "try    {", "toBytes . convert ( new    . UnSerializable (  )  )  ;", "fail (  \" Expected   SerializationFailureException \"  )  ;", "}    catch    ( SerializationFailedException   e )     {", "assertNotNull ( e . getCause (  )  )  ;", "assertTrue (  (  ( e . getCause (  )  )    instanceof   NotSerializableException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["nonSerializableField"], "fileName": "org.springframework.core.serializer.SerializationConverterTests"}, {"methodBody": ["METHOD_START", "{", "SerializingConverter   toBytes    =    new   SerializingConverter (  )  ;", "try    {", "toBytes . convert ( new   Object (  )  )  ;", "fail (  \" Expected   IllegalArgumentException \"  )  ;", "}    catch    ( FailedException   e )     {", "assertNotNull ( e . getCause (  )  )  ;", "assertTrue (  (  ( e . getCause (  )  )    instanceof   IllegalArgumentException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["nonSerializableObject"], "fileName": "org.springframework.core.serializer.SerializationConverterTests"}, {"methodBody": ["METHOD_START", "{", "SerializingConverter   toBytes    =    new   SerializingConverter (  )  ;", "byte [  ]    bytes    =    toBytes . convert (  \" Testing \"  )  ;", "DeserializingConverter   fromBytes    =    new   DeserializingConverter (  )  ;", "assertEquals (  \" Testing \"  ,    fromBytes . convert ( bytes )  )  ;", "}", "METHOD_END"], "methodName": ["serializeAndDeserializeString"], "fileName": "org.springframework.core.serializer.SerializationConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . valueStyler ;", "}", "METHOD_END"], "methodName": ["getValueStyler"], "fileName": "org.springframework.core.style.DefaultToStringStyler"}, {"methodBody": ["METHOD_START", "{", "buffer . append (  '     '  )  . append ( fieldName )  . append (  \"     =     \"  )  ;", "}", "METHOD_END"], "methodName": ["styleFieldStart"], "fileName": "org.springframework.core.style.DefaultToStringStyler"}, {"methodBody": ["METHOD_START", "{", "buffer . append (  '  @  '  )  ;", "buffer . append ( ObjectUtils . getIdentityHex ( obj )  )  ;", "}", "METHOD_END"], "methodName": ["styleIdentityHashCode"], "fileName": "org.springframework.core.style.DefaultToStringStyler"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   List )     {", "return    . LIST ;", "} else", "if    ( value   instanceof   Set )     {", "return    . SET ;", "} else    {", "return    . COLLECTION ;", "}", "}", "METHOD_END"], "methodName": ["getCollectionTypeString"], "fileName": "org.springframework.core.style.DefaultValueStyler"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  (  (  ( value . size (  )  )     *     8  )     +     1  6  )  )  ;", "result . append ( getCollectionTypeString ( value )  )  . append (  '  [  '  )  ;", "for    ( Iterator <  ?  >    i    =    value . iterator (  )  ;    i . hasNext (  )  ;  )     {", "result . append ( style ( i . next (  )  )  )  ;", "if    ( i . hasNext (  )  )     {", "result . append (  '  ,  '  )  . append (  '     '  )  ;", "}", "}", "if    ( value . isEmpty (  )  )     {", "result . append (  . EMPTY )  ;", "}", "result . append (  \"  ]  \"  )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["style"], "fileName": "org.springframework.core.style.DefaultValueStyler"}, {"methodBody": ["METHOD_START", "{", "return    (  ( style ( value . getKey (  )  )  )     +     \"     -  >     \"  )     +     ( style ( value . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["style"], "fileName": "org.springframework.core.style.DefaultValueStyler"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  (  (  ( value . size (  )  )     *     8  )     +     1  6  )  )  ;", "result . append (  (  (  . MAP )     +     \"  [  \"  )  )  ;", "for    ( Iterator < Map . Entry < K ,    V >  >    it    =    value . entrySet (  )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Map . Entry < K ,    V >    entry    =    it . next (  )  ;", "result . append ( style ( entry )  )  ;", "if    ( it . hasNext (  )  )     {", "result . append (  '  ,  '  )  . append (  '     '  )  ;", "}", "}", "if    ( value . isEmpty (  )  )     {", "result . append (  . EMPTY )  ;", "}", "result . append (  \"  ]  \"  )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["style"], "fileName": "org.springframework.core.style.DefaultValueStyler"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  (  (  ( array . length )     *     8  )     +     1  6  )  )  ;", "result . append (  (  (  . ARRAY )     +     \"  <  \"  )  )  . append ( ClassUtils . getShortName ( array . getClass (  )  . getComponentType (  )  )  )  . append (  \"  >  [  \"  )  ;", "for    ( int   i    =     0  ;    i    <     (  ( array . length )     -     1  )  ;    i +  +  )     {", "result . append ( style ( array [ i ]  )  )  ;", "result . append (  '  ,  '  )  . append (  '     '  )  ;", "}", "if    (  ( array . length )     >     0  )     {", "result . append ( style ( array [  (  ( array . length )     -     1  )  ]  )  )  ;", "} else    {", "result . append (  . EMPTY )  ;", "}", "result . append (  \"  ]  \"  )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["styleArray"], "fileName": "org.springframework.core.style.DefaultValueStyler"}, {"methodBody": ["METHOD_START", "{", "return   StylerUtils . DEFAULT _ VALUE _ STYLER . style ( value )  ;", "}", "METHOD_END"], "methodName": ["style"], "fileName": "org.springframework.core.style.StylerUtils"}, {"methodBody": ["METHOD_START", "{", "this . styler . styleValue ( this . buffer ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "return   append ( fieldName ,    Boolean . valueOf ( value )  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "return   append ( fieldName ,    Byte . valueOf ( value )  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "return   append ( fieldName ,    Double . valueOf ( value )  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "return   append ( fieldName ,    Float . valueOf ( value )  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "return   append ( fieldName ,    Integer . valueOf ( value )  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "printFieldSeparatorIfNecessary (  )  ;", "thisrField ( this . buffer ,    fieldName ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "return   append ( fieldName ,    Long . valueOf ( value )  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "return   append ( fieldName ,    Short . valueOf ( value )  )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "if    ( this . styledFirstField )     {", "this . styler . styleFieldSeparator ( this . buffer )  ;", "} else    {", "this . styledFirstField    =    true ;", "}", "}", "METHOD_END"], "methodName": ["printFieldSeparatorIfNecessary"], "fileName": "org.springframework.core.style.ToStringCreator"}, {"methodBody": ["METHOD_START", "{", "String   str    =    new   ToStringCreator ( this )  . append (  \" myClass \"  ,    this . getClass (  )  )  . toString (  )  ;", "assertEquals (  (  (  \"  [  @  \"     +     ( ObjectUtils . getIdentityHexString ( this )  )  )     +     \"    myClass    =     ]  \"  )  ,    str )  ;", "}", "METHOD_END"], "methodName": ["appendClass"], "fileName": "org.springframework.core.style.ToStringCreatorTests"}, {"methodBody": ["METHOD_START", "{", "List < ToStringCreatorTests . SomeObject >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( s 1  )  ;", "list . add ( s 2  )  ;", "list . add ( s 3  )  ;", "String   str    =    new   ToStringCreator ( this )  . append (  \" myLetters \"  ,    list )  . toString (  )  ;", "assertEquals (  (  (  \"  [ ToStringCreatorTests @  \"     +     ( ObjectUtils . getIdentityHexString ( this )  )  )     +     \"    myLetters    =    list [ A ,    B ,    C ]  ]  \"  )  ,    str )  ;", "}", "METHOD_END"], "methodName": ["appendList"], "fileName": "org.springframework.core.style.ToStringCreatorTests"}, {"methodBody": ["METHOD_START", "{", "String   str    =    new   ToStringCreator ( this )  . append (  \" myMethod \"  ,    this . getClass (  )  . getMethod (  \" appendMethod \"  )  )  . toString (  )  ;", "assertEquals (  (  (  \"  [  @  \"     +     ( ObjectUtils . getIdentityHexString ( this )  )  )     +     \"    myMethod    =    appendMethod @  ]  \"  )  ,    str )  ;", "}", "METHOD_END"], "methodName": ["appendMethod"], "fileName": "org.springframework.core.style.ToStringCreatorTests"}, {"methodBody": ["METHOD_START", "{", "Set < ToStringCreatorTests . SomeObject >    set    =    new   LinkedHashSet <  >  (  )  ;", "set . add ( s 1  )  ;", "set . add ( s 2  )  ;", "set . add ( s 3  )  ;", "String   str    =    new   ToStringCreator ( this )  . append (  \" myLetters \"  ,    set )  . toString (  )  ;", "assertEquals (  (  (  \"  [ ToStringCreatorTests @  \"     +     ( ObjectUtils . getIdentityHexString ( this )  )  )     +     \"    myLetters    =    set [ A ,    B ,    C ]  ]  \"  )  ,    str )  ;", "}", "METHOD_END"], "methodName": ["appendSet"], "fileName": "org.springframework.core.style.ToStringCreatorTests"}, {"methodBody": ["METHOD_START", "{", "ToStringCreatorTests . SomeObject [  ]    array    =    new   ToStringCreatorTests . SomeObject [  ]  {    s 1  ,    s 2  ,    s 3     }  ;", "String   str    =    new   ToStringCreator ( array )  . toString (  )  ;", "assertEquals (  (  (  \"  [  @  \"     +     ( ObjectUtils . getIdentityHexString ( array )  )  )     +     \"    array < ToStringCreatorTests . SomeObject >  [ A ,    B ,    C ]  ]  \"  )  ,    str )  ;", "}", "METHOD_END"], "methodName": ["defaultStyleArray"], "fileName": "org.springframework.core.style.ToStringCreatorTests"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    String >    map    =    getMap (  )  ;", "Object   stringy    =    new   Object (  )     {", "@ Override", "public   String   toString (  )     {", "return   new   ToStringCreator ( this )  . append (  \" familyFavoriteSport \"  ,    map )  . toString (  )  ;", "}", "}  ;", "assertEquals (  (  (  \"  [  .  4  @  \"     +     ( ObjectUtils . getIdentityHexString ( stringy )  )  )     +     \"    familyFavoriteSport    =    map [  ' Keri '     -  >     ' Softball '  ,     ' Scot '     -  >     ' Fishing '  ,     ' Keith '     -  >     ' Flag   Football '  ]  ]  \"  )  ,    stringy . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultStyleMap"], "fileName": "org.springframework.core.style.ToStringCreatorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   LinkedHashMap <  >  (  )  ;", "map . put (  \" Keri \"  ,     \" Softball \"  )  ;", "map . put (  \" Scot \"  ,     \" Fishing \"  )  ;", "map . put (  \" Keith \"  ,     \" Flag   Football \"  )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["getMap"], "fileName": "org.springframework.core.style.ToStringCreatorTests"}, {"methodBody": ["METHOD_START", "{", "int [  ]    integers    =    new   int [  ]  {     0  ,     1  ,     2  ,     3  ,     4     }  ;", "String   str    =    new    ( integers )  . toString (  )  ;", "assertEquals (  (  (  \"  [  @  \"     +     ( ObjectUtils . getIdentityHexString ( integers )  )  )     +     \"    array < Integer >  [  0  ,     1  ,     2  ,     3  ,     4  ]  ]  \"  )  ,    str )  ;", "}", "METHOD_END"], "methodName": ["primitiveArrays"], "fileName": "org.springframework.core.style.ToStringCreatorTests"}, {"methodBody": ["METHOD_START", "{", "s 1     =    new   ToStringCreatorTests . SomeObject (  )     {", "@ Override", "public   String   toString (  )     {", "return    \" A \"  ;", "}", "}  ;", "s 2     =    new   ToStringCreatorTests . SomeObject (  )     {", "@ Override", "public   String   toString (  )     {", "return    \" B \"  ;", "}", "}  ;", "s 3     =    new   ToStringCreatorTests . SomeObject (  )     {", "@ Override", "public   String   toString (  )     {", "return    \" C \"  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.core.style.ToStringCreatorTests"}, {"methodBody": ["METHOD_START", "{", "Thread   thread    =     (  ( this . threadFactory )     !  =    null )     ?    this . threadFactory . newThread ( task )     :    createThread ( task )  ;", "thread . start (  )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . concurrencyThrottle . getConcurrencyLimit (  )  ;", "}", "METHOD_END"], "methodName": ["getConcurrencyLimit"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . threadFactory ;", "}", "METHOD_END"], "methodName": ["getThreadFactory"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . concurrencyThrottle . isThrottleActive (  )  ;", "}", "METHOD_END"], "methodName": ["isThrottleActive"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . concurrencyThrottle . setConcurrencyLimit ( concurrencyLimit )  ;", "}", "METHOD_END"], "methodName": ["setConcurrencyLimit"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . taskDecorator    =    taskDecorator ;", "}", "METHOD_END"], "methodName": ["setTaskDecorator"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . threadFactory    =    threadFactory ;", "}", "METHOD_END"], "methodName": ["setThreadFactory"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "SimpleAsyncTaskExecutor   executor    =    new   SimpleAsyncTaskExecutor (  )  ;", "executor . setConcurrencyLimit ( ConcurrencyThrottleSupport . NO _ CONCURRENCY )  ;", "assertTrue ( executor . isThrottleActive (  )  )  ;", "exception . expect ( IllegalStateException . class )  ;", "executor . execute ( new    . NoOpRunnable (  )  )  ;", "}", "METHOD_END"], "methodName": ["cannotExecuteWhenConcurrencyIsSwitchedOff"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "synchronized ( monitor )     {", "e . execute ( task )  ;", "try    {", "monitor . wait (  )  ;", "}    catch    ( InterruptedException   ignored )     {", "}", "}", "}", "METHOD_END"], "methodName": ["executeAndWait"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "final   Object   monitor    =    new   Object (  )  ;", "SimpleAsyncTaskExecutor   executor    =    new   SimpleAsyncTaskExecutor ( new   ThreadFactory (  )     {", "@ Override", "public   Thread   newThread ( Runnable   r )     {", "return   new   Thread ( r ,     \" test \"  )  ;", "}", "}  )  ;", ". ThreadNameHarvester   task    =    new    . ThreadNameHarvester ( monitor )  ;", "executeAndWait ( executor ,    task ,    monitor )  ;", "assertEquals (  \" test \"  ,    task . getThreadName (  )  )  ;", "}", "METHOD_END"], "methodName": ["threadFactoryOverridesDefaults"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "final   String   customPrefix    =     \" chankPop #  \"  ;", "final   Object   monitor    =    new   Object (  )  ;", "SimpleAsyncTaskExecutor   executor    =    new   SimpleAsyncTaskExecutor ( customPrefix )  ;", ". ThreadNameHarvester   task    =    new    . ThreadNameHarvester ( monitor )  ;", "executeAndWait ( executor ,    task ,    monitor )  ;", "assertThat ( task . getThreadName (  )  ,    startsWith ( customPrefix )  )  ;", "}", "METHOD_END"], "methodName": ["threadNameGetsSetCorrectly"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "SimpleAsyncTaskExecutor   executor    =    new   SimpleAsyncTaskExecutor (  )  ;", "assertFalse (  \" Concurrency   throttle   must   not   default   to   being   active    ( on )  \"  ,    executor . isThrottleActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["throttleIsNotActiveByDefault"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "new    (  )  . execute ( null )  ;", "}", "METHOD_END"], "methodName": ["throwsExceptionWhenSuppliedWithNullRunnable"], "fileName": "org.springframework.core.task.SimpleAsyncTaskExecutorTests"}, {"methodBody": ["METHOD_START", "{", "concurrentExecutor . execute (  ( taskDecorator    !  =    null    ?    taskDecorator . decorate ( runnable )     :    runnable )  )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.core.task.support.TaskExecutorAdapter"}, {"methodBody": ["METHOD_START", "{", "this . taskDecorator    =    taskDecorator ;", "}", "METHOD_END"], "methodName": ["setTaskDecorator"], "fileName": "org.springframework.core.task.support.TaskExecutorAdapter"}, {"methodBody": ["METHOD_START", "{", "ClassMetadata   metadata    =    getClassMetadataFor ( AbstractClassMetadataMemberClassTests . L 0  _ b . L 1  . class )  ;", "String [  ]    nestedClasses    =    metadata . getMemberClassNames (  )  ;", "assertThat ( nestedClasses ,    equalTo ( new   String [  ]  {        }  )  )  ;", "}", "METHOD_END"], "methodName": ["againstMemberClass"], "fileName": "org.springframework.core.type.AbstractClassMetadataMemberClassTests"}, {"methodBody": ["METHOD_START", "{", "ClassMetadata   metadata    =    getClassMetadataFor ( AbstractClassMetadataMemberClassTests . L 0  _ a . class )  ;", "String [  ]    nestedClasses    =    metadata . getMemberClassNames (  )  ;", "assertThat ( nestedClasses ,    equalTo ( new   String [  ]  {        }  )  )  ;", "}", "METHOD_END"], "methodName": ["withNoMemberClasses"], "fileName": "org.springframework.core.type.AbstractClassMetadataMemberClassTests"}, {"methodBody": ["METHOD_START", "{", "ClassMetadata   metadata    =    getClassMetadataFor ( AbstractClassMetadataMemberClassTests . L 0  _ c . class )  ;", "String [  ]    nestedClasses    =    metadata . getMemberClassNames (  )  ;", "assertThat ( nestedClasses ,    equalTo ( new   String [  ]  {    AbstractClassMetadataMemberClassTests . L 0  _ c . L 1  . class . getName (  )     }  )  )  ;", "}", "METHOD_END"], "methodName": ["withNonPublicMemberClasses"], "fileName": "org.springframework.core.type.AbstractClassMetadataMemberClassTests"}, {"methodBody": ["METHOD_START", "{", "ClassMetadata   metadata    =    getClassMetadataFor ( AbstractClassMetadataMemberClassTests . L 0  _ b . class )  ;", "String [  ]    nestedClasses    =    metadata . getMemberClassNames (  )  ;", "assertThat ( nestedClasses ,    equalTo ( new   String [  ]  {    AbstractClassMetadataMemberClassTests . L 0  _ b . L 1  . class . getName (  )     }  )  )  ;", "}", "METHOD_END"], "methodName": ["withPublicMemberClasses"], "fileName": "org.springframework.core.type.AbstractClassMetadataMemberClassTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader (  . AnnotatedComponent . class . getName (  )  )  ;", "AnnotationMetadata   metadata    =    metadataReader . getAnnotationMetadata (  )  ;", "doTestAnnotationInfo ( metadata )  ;", "doTestMethodAnnotationInfo ( metadata )  ;", "}", "METHOD_END"], "methodName": ["asmAnnotationMetadata"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( Component . class . getName (  )  )  ;", "metadata    =    metadataReader . get (  )  ;", "doTestMetadataForAnnotationClass ( metadata )  ;", "}", "METHOD_END"], "methodName": ["asmAnnotationMetadataForAnnotation"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader (  . class . getName (  )  )  ;", "metadata    =    metadataReader . get (  )  ;", "doTestMetadataForInterfaceClass ( metadata )  ;", "}", "METHOD_END"], "methodName": ["asmAnnotationMetadataForInterface"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader (  . AnnotatedComponentSubClass . class . getName (  )  )  ;", "AnnotationMetadata   metadata    =    metadataReader . getAnnotationMetadata (  )  ;", "doTestSubClassAnnotationInfo ( metadata )  ;", "}", "METHOD_END"], "methodName": ["asmAnnotationMetadataForSubclass"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes    =     (  ( AnnotationAttributes )     ( metadata . getAnnotationAttributes ( AnnotationMetadataTests . TestComponentScan . class . getName (  )  ,    false )  )  )  ;", "String [  ]    basePackages    =    attributes . getStringArray (  \" basePackages \"  )  ;", "assertThat (  \" length   of   basePackages [  ]  \"  ,    basePackages . length ,    is (  1  )  )  ;", "assertThat (  \" basePackages [  0  ]  \"  ,    basePackages [  0  ]  ,    is (  \" componentscan \"  )  )  ;", "String [  ]    value    =    attributes . getStringArray (  \" value \"  )  ;", "assertThat (  \" length   of   value [  ]  \"  ,    value . length ,    is (  0  )  )  ;", "Class <  ?  >  [  ]    basePackageClasses    =    attributes . getClassArray (  \" basePackageClasses \"  )  ;", "assertThat (  \" length   of   basePackageClasses [  ]  \"  ,    basePackageClasses . length ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMetaAnnotationOverrides"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attributes 1     =     (  ( AnnotationAttributes )     ( metadata . getAnnotationAttributes ( AnnotationMetadataTests . NamedAnnotation 1  . class . getName (  )  ,    false )  )  )  ;", "String   name 1     =    attributes 1  . getString (  \" name \"  )  ;", "assertThat (  \" name   of   NamedAnnotation 1  \"  ,    name 1  ,    is (  \" name    1  \"  )  )  ;", "AnnotationAttributes   attributes 2     =     (  ( AnnotationAttributes )     ( metadata . getAnnotationAttributes ( AnnotationMetadataTests . NamedAnnotation 2  . class . getName (  )  ,    false )  )  )  ;", "String   name 2     =    attributes 2  . getString (  \" name \"  )  ;", "assertThat (  \" name   of   NamedAnnotation 2  \"  ,    name 2  ,    is (  \" name    2  \"  )  )  ;", "AnnotationAttributes   attributes 3     =     (  ( AnnotationAttributes )     ( metadata . getAnnotationAttributes ( AnnotationMetadataTests . NamedAnnotation 3  . class . getName (  )  ,    false )  )  )  ;", "String   name 3     =    attributes 3  . getString (  \" name \"  )  ;", "assertThat (  \" name   of   NamedAnnotation 3  \"  ,    name 3  ,    is (  \" name    3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMultipleAnnotationsWithIdenticalAttributeNames"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader (  . NamedComposedAnnotationClass . class . getName (  )  )  ;", "AnnotationMetadata   metadata    =    metadataReader . getAnnotationMetadata (  )  ;", "assertMultipleAnnotationsWithIdenticalAttributeNames ( metadata )  ;", "}", "METHOD_END"], "methodName": ["composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingAnnotationMetadataReadingVisitor"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    new   StandardAnnotationMetadata ( AnnotationMetadataTests . NamedComposedAnnotationClass . class )  ;", "assertMultipleAnnotationsWithIdenticalAttributeNames ( metadata )  ;", "}", "METHOD_END"], "methodName": ["composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( metadata . getClassName (  )  ,    is ( AnnotationMetadataTests . AnnotatedComponent . class . getName (  )  )  )  ;", "assertThat ( metadata . isInterface (  )  ,    is ( false )  )  ;", "assertThat ( metadata . isAnnotation (  )  ,    is ( false )  )  ;", "assertThat ( metadata . isAbstract (  )  ,    is ( false )  )  ;", "assertThat ( metadata . isConcrete (  )  ,    is ( true )  )  ;", "assertThat ( metadata . hasSuperClass (  )  ,    is ( true )  )  ;", "assertThat ( metadata . getSuperClassName (  )  ,    is ( Object . class . getName (  )  )  )  ;", "assertThat ( metadata . getInterfaceNames (  )  . length ,    is (  1  )  )  ;", "assertThat ( metadata . getInterfaceNames (  )  [  0  ]  ,    is ( Serializable . class . getName (  )  )  )  ;", "assertThat ( metadata . hasAnnotation ( Component . class . getName (  )  )  ,    is ( true )  )  ;", "assertThat ( metadata . hasAnnotation ( Scope . class . getName (  )  )  ,    is ( true )  )  ;", "assertThat ( metadata . hasAnnotation ( AnnotationMetadataTests . SpecialAttr . class . getName (  )  )  ,    is ( true )  )  ;", "assertThat ( metadata . getAnnotationTypes (  )  . size (  )  ,    is (  6  )  )  ;", "assertThat ( metadata . getAnnotationTypes (  )  . contains ( Component . class . getName (  )  )  ,    is ( true )  )  ;", "assertThat ( metadata . getAnnotationTypes (  )  . contains ( Scope . class . getName (  )  )  ,    is ( true )  )  ;", "assertThat ( metadata . getAnnotationTypes (  )  . contains ( AnnotationMetadataTests . SpecialAttr . class . getName (  )  )  ,    is ( true )  )  ;", "AnnotationAttributes   compAttrs    =     (  ( AnnotationAttributes )     ( metadata . getAnnotationAttributes ( Component . class . getName (  )  )  )  )  ;", "assertThat ( compAttrs . size (  )  ,    is (  1  )  )  ;", "assertThat ( compAttrs . getString (  \" value \"  )  ,    is (  \" myName \"  )  )  ;", "AnnotationAttributes   scopeAttrs    =     (  ( AnnotationAttributes )     ( metadata . getAnnotationAttributes ( Scope . class . getName (  )  )  )  )  ;", "assertThat ( scopeAttrs . size (  )  ,    is (  1  )  )  ;", "assertThat ( scopeAttrs . getString (  \" value \"  )  ,    is (  \" myScope \"  )  )  ;", "Set < MethodMetadata >    methods    =    metadata . getAnnotatedMethods ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  ;", "MethodMetadata   method    =    methods . iterator (  )  . next (  )  ;", "assertEquals (  \" direct \"  ,    method . getAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . get (  \" value \"  )  )  ;", "assertEquals (  \" direct \"  ,    method . getAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . get (  \" myValue \"  )  )  ;", "List < Object >    allMeta    =    method . getAllAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . get (  \" value \"  )  ;", "assertThat ( new   HashSet ( allMeta )  ,    is ( equalTo ( new   HashSet < Object >  ( Arrays . asList (  \" direct \"  ,     \" meta \"  )  )  )  )  )  ;", "allMeta    =    method . getAllAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . get (  \" additional \"  )  ;", "assertThat ( new   HashSet ( allMeta )  ,    is ( equalTo ( new   HashSet < Object >  ( Arrays . asList (  \" direct \"  )  )  )  )  )  ;", "assertTrue ( metadata . isAnnotated ( AnnotationMetadataTests . IsAnnotatedAnnotation . class . getName (  )  )  )  ;", "{", "AnnotationAttributes   specialAttrs    =     (  ( AnnotationAttributes )     ( metadata . getAnnotationAttributes ( AnnotationMetadataTests . SpecialAttr . class . getName (  )  )  )  )  ;", "assertThat ( specialAttrs . size (  )  ,    is (  6  )  )  ;", "assertTrue ( String . class . isAssignableFrom ( specialAttrs . getClass (  \" clazz \"  )  )  )  ;", "assertTrue ( specialAttrs . getEnum (  \" state \"  )  . equals ( Thread . State . NEW )  )  ;", "AnnotationAttributes   nestedAnno    =    specialAttrs . getAnnotation (  \" nestedAnno \"  )  ;", "assertThat (  \" na \"  ,    is ( nestedAnno . getString (  \" value \"  )  )  )  ;", "assertTrue ( nestedAnno . getEnum (  \" anEnum \"  )  . equals ( AnnotationMetadataTests . SomeEnum . LABEL 1  )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    String . class    }  ,     (  ( Class <  ?  >  [  ]  )     ( nestedAnno . get (  \" classArray \"  )  )  )  )  ;", "AnnotationAttributes [  ]    nestedAnnoArray    =    specialAttrs . getAnnotationArray (  \" nestedAnnoArray \"  )  ;", "assertThat ( nestedAnnoArray . length ,    is (  2  )  )  ;", "assertThat ( nestedAnnoArray [  0  ]  . getString (  \" value \"  )  ,    is (  \" default \"  )  )  ;", "assertTrue ( nestedAnnoArray [  0  ]  . getEnum (  \" anEnum \"  )  . equals ( AnnotationMetadataTests . SomeEnum . DEFAULT )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    Void . class    }  ,     (  ( Class <  ?  >  [  ]  )     ( nestedAnnoArray [  0  ]  . get (  \" classArray \"  )  )  )  )  ;", "assertThat ( nestedAnnoArray [  1  ]  . getString (  \" value \"  )  ,    is (  \" na 1  \"  )  )  ;", "assertTrue ( nestedAnnoArray [  1  ]  . getEnum (  \" anEnum \"  )  . equals ( AnnotationMetadataTests . SomeEnum . LABEL 2  )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    Number . class    }  ,     (  ( Class <  ?  >  [  ]  )     ( nestedAnnoArray [  1  ]  . get (  \" classArray \"  )  )  )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    Number . class    }  ,    nestedAnnoArray [  1  ]  . getClassArray (  \" classArray \"  )  )  ;", "AnnotationAttributes   optional    =    specialAttrs . getAnnotation (  \" optional \"  )  ;", "assertThat ( optional . getString (  \" value \"  )  ,    is (  \" optional \"  )  )  ;", "assertTrue ( optional . getEnum (  \" anEnum \"  )  . equals ( AnnotationMetadataTests . SomeEnum . DEFAULT )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    Void . class    }  ,     (  ( Class <  ?  >  [  ]  )     ( optional . get (  \" classArray \"  )  )  )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    Void . class    }  ,    optional . getClassArray (  \" classArray \"  )  )  ;", "AnnotationAttributes [  ]    optionalArray    =    specialAttrs . getAnnotationArray (  \" optionalArray \"  )  ;", "assertThat ( optionalArray . length ,    is (  1  )  )  ;", "assertThat ( optionalArray [  0  ]  . getString (  \" value \"  )  ,    is (  \" optional \"  )  )  ;", "assertTrue ( optionalArray [  0  ]  . getEnum (  \" anEnum \"  )  . equals ( AnnotationMetadataTests . SomeEnum . DEFAULT )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    Void . class    }  ,     (  ( Class <  ?  >  [  ]  )     ( optionalArray [  0  ]  . get (  \" classArray \"  )  )  )  )  ;", "assertArrayEquals ( new   Class <  ?  >  [  ]  {    Void . class    }  ,    optionalArray [  0  ]  . getClassArray (  \" classArray \"  )  )  ;", "assertEquals (  \" direct \"  ,    metadata . getAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . get (  \" value \"  )  )  ;", "allMeta    =    metadata . getAllAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . get (  \" value \"  )  ;", "assertThat ( new   HashSet ( allMeta )  ,    is ( equalTo ( new   HashSet < Object >  ( Arrays . asList (  \" direct \"  ,     \" meta \"  )  )  )  )  )  ;", "allMeta    =    metadata . getAllAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . get (  \" additional \"  )  ;", "assertThat ( new   HashSet ( allMeta )  ,    is ( equalTo ( new   HashSet < Object >  ( Arrays . asList (  \" direct \"  )  )  )  )  )  ;", "}", "{", "AnnotationAttributes   specialAttrs    =     (  ( AnnotationAttributes )     ( metadata . getAnnotationAttributes ( AnnotationMetadataTests . SpecialAttr . class . getName (  )  ,    true )  )  )  ;", "assertThat ( specialAttrs . size (  )  ,    is (  6  )  )  ;", "assertThat ( specialAttrs . get (  \" clazz \"  )  ,    is (  (  ( Object )     ( String . class . getName (  )  )  )  )  )  ;", "assertThat ( specialAttrs . getString (  \" clazz \"  )  ,    is ( String . class . getName (  )  )  )  ;", "AnnotationAttributes   nestedAnno    =    specialAttrs . getAnnotation (  \" nestedAnno \"  )  ;", "assertArrayEquals ( new   String [  ]  {    String . class . getName (  )     }  ,    nestedAnno . getStringArray (  \" classArray \"  )  )  ;", "assertArrayEquals ( new   String [  ]  {    String . class . getName (  )     }  ,    nestedAnno . getStringArray (  \" classArray \"  )  )  ;", "AnnotationAttributes [  ]    nestedAnnoArray    =    specialAttrs . getAnnotationArray (  \" nestedAnnoArray \"  )  ;", "assertArrayEquals ( new   String [  ]  {    Void . class . getName (  )     }  ,     (  ( String [  ]  )     ( nestedAnnoArray [  0  ]  . get (  \" classArray \"  )  )  )  )  ;", "assertArrayEquals ( new   String [  ]  {    Void . class . getName (  )     }  ,    nestedAnnoArray [  0  ]  . getStringArray (  \" classArray \"  )  )  ;", "assertArrayEquals ( new   String [  ]  {    Number . class . getName (  )     }  ,     (  ( String [  ]  )     ( nestedAnnoArray [  1  ]  . get (  \" classArray \"  )  )  )  )  ;", "assertArrayEquals ( new   String [  ]  {    Number . class . getName (  )     }  ,    nestedAnnoArray [  1  ]  . getStringArray (  \" classArray \"  )  )  ;", "AnnotationAttributes   optional    =    specialAttrs . getAnnotation (  \" optional \"  )  ;", "assertArrayEquals ( new   String [  ]  {    Void . class . getName (  )     }  ,     (  ( String [  ]  )     ( optional . get (  \" classArray \"  )  )  )  )  ;", "assertArrayEquals ( new   String [  ]  {    Void . class . getName (  )     }  ,    optional . getStringArray (  \" classArray \"  )  )  ;", "AnnotationAttributes [  ]    optionalArray    =    specialAttrs . getAnnotationArray (  \" optionalArray \"  )  ;", "assertArrayEquals ( new   String [  ]  {    Void . class . getName (  )     }  ,     (  ( String [  ]  )     ( optionalArray [  0  ]  . get (  \" classArray \"  )  )  )  )  ;", "assertArrayEquals ( new   String [  ]  {    Void . class . getName (  )     }  ,    optionalArray [  0  ]  . getStringArray (  \" classArray \"  )  )  ;", "assertEquals (  \" direct \"  ,    metadata . getAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . get (  \" value \"  )  )  ;", "allMeta    =    metadata . getAllAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . get (  \" value \"  )  ;", "assertThat ( new   HashSet ( allMeta )  ,    is ( equalTo ( new   HashSet < Object >  ( Arrays . asList (  \" direct \"  ,     \" meta \"  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestAnnotationInfo"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( metadata . getClassName (  )  ,    is ( Component . class . getName (  )  )  )  ;", "assertThat ( metadata . isInterface (  )  ,    is ( true )  )  ;", "assertThat ( metadata . isAnnotation (  )  ,    is ( true )  )  ;", "assertThat ( metadata . isAbstract (  )  ,    is ( true )  )  ;", "assertThat ( metadata . isConcrete (  )  ,    is ( false )  )  ;", "assertThat ( metadata . hasSuperClass (  )  ,    is ( false )  )  ;", "assertThat ( metadata . getSuperClassName (  )  ,    nullValue (  )  )  ;", "assertThat ( metadata . getInterfaceNames (  )  . length ,    is (  1  )  )  ;", "assertThat ( metadata . getInterfaceNames (  )  [  0  ]  ,    is ( Annotation . class . getName (  )  )  )  ;", "assertThat ( metadata . isAnnotated ( Documented . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . isAnnotated ( Scope . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . isAnnotated (  . SpecialAttr . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . hasAnnotation ( Documented . class . getName (  )  )  ,    is ( true )  )  ;", "assertThat ( metadata . hasAnnotation ( Scope . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . hasAnnotation (  . SpecialAttr . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . getAnnotationTypes (  )  . size (  )  ,    is (  4  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestMetadataForAnnotationClass"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( metadata . getClassName (  )  ,    is ( AnnotationMetadata . class . getName (  )  )  )  ;", "assertThat ( metadata . isInterface (  )  ,    is ( true )  )  ;", "assertThat ( metadata . isAnnotation (  )  ,    is ( false )  )  ;", "assertThat ( metadata . isAbstract (  )  ,    is ( true )  )  ;", "assertThat ( metadata . isConcrete (  )  ,    is ( false )  )  ;", "assertThat ( metadata . hasSuperClass (  )  ,    is ( false )  )  ;", "assertThat ( metadata . getSuperClassName (  )  ,    nullValue (  )  )  ;", "assertThat ( metadata . getInterfaceNames (  )  . length ,    is (  2  )  )  ;", "assertThat ( metadata . getInterfaceNames (  )  [  0  ]  ,    is ( ClassMetadata . class . getName (  )  )  )  ;", "assertThat ( metadata . getInterfaceNames (  )  [  1  ]  ,    is ( AnnotatedTypeMetadata . class . getName (  )  )  )  ;", "assertThat ( metadata . getAnnotationTypes (  )  . size (  )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestMetadataForInterfaceClass"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "Set < MethodMetadata >    methods    =    classMetadata . getAnnotatedMethods ( TestAutowired . class . getName (  )  )  ;", "assertThat ( methods . size (  )  ,    is (  1  )  )  ;", "for    ( MethodMetadata   methodMetadata    :    methods )     {", "assertThat ( methodMetadata . isAnnotated ( TestAutowired . class . getName (  )  )  ,    is ( true )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestMethodAnnotationInfo"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( metadata . getClassName (  )  ,    is ( AnnotationMetadataTests . AnnotatedComponentSubClass . class . getName (  )  )  )  ;", "assertThat ( metadata . isInterface (  )  ,    is ( false )  )  ;", "assertThat ( metadata . isAnnotation (  )  ,    is ( false )  )  ;", "assertThat ( metadata . isAbstract (  )  ,    is ( false )  )  ;", "assertThat ( metadata . isConcrete (  )  ,    is ( true )  )  ;", "assertThat ( metadata . hasSuperClass (  )  ,    is ( true )  )  ;", "assertThat ( metadata . getSuperClassName (  )  ,    is ( AnnotationMetadataTests . AnnotatedComponent . class . getName (  )  )  )  ;", "assertThat ( metadata . getInterfaceNames (  )  . length ,    is (  0  )  )  ;", "assertThat ( metadata . isAnnotated ( Component . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . isAnnotated ( Scope . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . isAnnotated ( AnnotationMetadataTests . SpecialAttr . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . hasAnnotation ( Component . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . hasAnnotation ( Scope . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . hasAnnotation ( AnnotationMetadataTests . SpecialAttr . class . getName (  )  )  ,    is ( false )  )  ;", "assertThat ( metadata . getAnnotationTypes (  )  . size (  )  ,    is (  0  )  )  ;", "assertThat ( metadata . getAnnotationAttributes ( Component . class . getName (  )  )  ,    nullValue (  )  )  ;", "assertThat ( metadata . getAnnotatedMethods ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  . size (  )  ,    equalTo (  0  )  )  ;", "assertThat ( metadata . isAnnotated ( AnnotationMetadataTests . IsAnnotatedAnnotation . class . getName (  )  )  ,    equalTo ( false )  )  ;", "assertThat ( metadata . getAllAnnotationAttributes ( AnnotationMetadataTests . DirectAnnotation . class . getName (  )  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestSubClassAnnotationInfo"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader (  . ComposedConfigurationWithAttributeOverridesClass . class . getName (  )  )  ;", "AnnotationMetadata   metadata    =    metadataReader . getAnnotationMetadata (  )  ;", "assertMetaAnnotationOverrides ( metadata )  ;", "}", "METHOD_END"], "methodName": ["metaAnnotationOverridesUsingAnnotationMetadataReadingVisitor"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    new   StandardAnnotationMetadata ( AnnotationMetadataTests . ComposedConfigurationWithAttributeOverridesClass . class )  ;", "assertMetaAnnotationOverrides ( metadata )  ;", "}", "METHOD_END"], "methodName": ["metaAnnotationOverridesUsingStandardAnnotationMetadata"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader (  . NamedAnnotationsClass . class . getName (  )  )  ;", "AnnotationMetadata   metadata    =    metadataReader . getAnnotationMetadata (  )  ;", "assertMultipleAnnotationsWithIdenticalAttributeNames ( metadata )  ;", "}", "METHOD_END"], "methodName": ["multipleAnnotationsWithIdenticalAttributeNamesUsingAnnotationMetadataReadingVisitor"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    new   StandardAnnotationMetadata ( AnnotationMetadataTests . NamedAnnotationsClass . class )  ;", "assertMultipleAnnotationsWithIdenticalAttributeNames ( metadata )  ;", "}", "METHOD_END"], "methodName": ["multipleAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    new   StandardAnnotationMetadata ( AnnotationMetadataTests . AnnotatedComponent . class ,    true )  ;", "doTestAnnotationInfo ( metadata )  ;", "doTestMethodAnnotationInfo ( metadata )  ;", "}", "METHOD_END"], "methodName": ["standardAnnotationMetadata"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    new   StandardAnnotationMetadata ( Component . class ,    true )  ;", "doTestMetadataForAnnotationClass ( metadata )  ;", "}", "METHOD_END"], "methodName": ["standardAnnotationMetadataForAnnotation"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    new   StandardAnnotationMetadata ( AnnotationMetadata . class ,    true )  ;", "doTestMetadataForInterfaceClass ( metadata )  ;", "}", "METHOD_END"], "methodName": ["standardAnnotationMetadataForInterface"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    new   StandardAnnotationMetadata ( AnnotationMetadataTests . AnnotatedComponentSubClass . class ,    true )  ;", "doTestSubClassAnnotationInfo ( metadata )  ;", "}", "METHOD_END"], "methodName": ["standardAnnotationMetadataForSubclass"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationMetadata   metadata    =    new   StandardAnnotationMetadata ( AnnotationMetadataTests . AnnotatedComponent . class )  ;", "AnnotationAttributes   specialAttrs    =     (  ( AnnotationAttributes )     ( metadata . getAnnotationAttributes ( AnnotationMetadataTests . SpecialAttr . class . getName (  )  )  )  )  ;", "Annotation [  ]    nestedAnnoArray    =     (  ( Annotation [  ]  )     ( specialAttrs . get (  \" nestedAnnoArray \"  )  )  )  ;", "assertThat ( nestedAnnoArray [  0  ]  ,    instanceOf ( AnnotationMetadataTests . NestedAnno . class )  )  ;", "}", "METHOD_END"], "methodName": ["standardAnnotationMetadata_nestedAnnotationsAsMap_false"], "fileName": "org.springframework.core.type.AnnotationMetadataTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ SomeComponent \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AnnotationTypeFilter   filter    =    new   AnnotationTypeFilter ( AnnotationTypeFilterTests . InheritedAnnotation . class )  ;", "assertTrue ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( classUnderTest )  ;", "}", "METHOD_END"], "methodName": ["testDirectAnnotationMatch"], "fileName": "org.springframework.core.type.AnnotationTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ SomeSubclassOfSomeComponent \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AnnotationTypeFilter   filter    =    new   AnnotationTypeFilter ( AnnotationTypeFilterTests . InheritedAnnotation . class )  ;", "assertTrue ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( classUnderTest )  ;", "}", "METHOD_END"], "methodName": ["testInheritedAnnotationFromBaseClassDoesMatch"], "fileName": "org.springframework.core.type.AnnotationTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ SomeClassWithSomeComponentInterface \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AnnotationTypeFilter   filter    =    new   AnnotationTypeFilter ( AnnotationTypeFilterTests . InheritedAnnotation . class )  ;", "assertFalse ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( classUnderTest )  ;", "}", "METHOD_END"], "methodName": ["testInheritedAnnotationFromInterfaceDoesNotMatch"], "fileName": "org.springframework.core.type.AnnotationTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ SomeClassWithSomeComponentInterface \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AnnotationTypeFilter   filter    =    new   AnnotationTypeFilter ( AnnotationTypeFilterTests . InheritedAnnotation . class ,    false ,    true )  ;", "assertTrue ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( classUnderTest )  ;", "}", "METHOD_END"], "methodName": ["testMatchesInterfacesIfConfigured"], "fileName": "org.springframework.core.type.AnnotationTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ SomeNonCandidateClass \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AnnotationTypeFilter   filter    =    new   AnnotationTypeFilter ( Component . class )  ;", "assertFalse ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( classUnderTest )  ;", "}", "METHOD_END"], "methodName": ["testNonAnnotatedClassDoesntMatch"], "fileName": "org.springframework.core.type.AnnotationTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AnnotationTypeFilter   filter    =    new   AnnotationTypeFilter ( AnnotationTypeFilterTests . NonInheritedAnnotation . class )  ;", "assertFalse ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( classUnderTest )  ;", "}", "METHOD_END"], "methodName": ["testNonInheritedAnnotationDoesNotMatch"], "fileName": "org.springframework.core.type.AnnotationTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassAnnotatedWithComponent \"  ,     \"  @ Component    *  .  .  *  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassAnnotatedWithComponent \"  ,     \"  @  *     *  .  .  *  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassAnnotatedWithComponent \"  ,     \"  @  *  .  .  *     *  .  .  *  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassAnnotatedWithComponent \"  ,     \"  @  *  .  .  * Component    *  .  .  *  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassAnnotatedWithComponent \"  ,     \"  @ Component    *  .  .  * Component \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassAnnotatedWithComponent \"  ,     \"  @ Component    *  \"  )  ;", "}", "METHOD_END"], "methodName": ["annotationPatternMatches"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertNoMatch (  \" AspectJTypeFilterTests $ SomeClassAnnotatedWithComponent \"  ,     \"  @ Repository    *  .  .  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["annotationPatternNoMathces"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( type )  ;", "filter    =    new    ( typePattern ,    getClass (  )  . getClassLoader (  )  )  ;", "assertTrue ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( type )  ;", "}", "METHOD_END"], "methodName": ["assertMatch"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( type )  ;", "filter    =    new    ( typePattern ,    getClass (  )  . getClassLoader (  )  )  ;", "assertFalse ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( type )  ;", "}", "METHOD_END"], "methodName": ["assertNoMatch"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertMatch (  \" AspectJTypeFilterTests $ SomeClass \"  ,     \"  !  *  .  . SomeOtherClass \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClassExtendingSomeClassAndImplemnentingSomeInterface \"  ,     (  \" SomeInterface +     \"     +     (  \"  &  &    SomeClass +     \"     +     \"  &  &    SomeClassExtendingSomeClass +  \"  )  )  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClassExtendingSomeClassAndImplemnentingSomeInterface \"  ,     (  \" SomeInterface +     \"     +     (  \"  |  |    SomeClass +     \"     +     \"  |  |    SomeClassExtendingSomeClass +  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compositionPatternMatches"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertNoMatch (  \" AspectJTypeFilterTests $ SomeClass \"  ,     \"  *  .  . Bogus    &  &    SomeClass \"  )  ;", "}", "METHOD_END"], "methodName": ["compositionPatternNoMatches"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertMatch (  \" AspectJTypeFilterTests $ SomeClass \"  ,     \" SomeClass \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClass \"  ,     \"  *  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClass \"  ,     \"  *  .  . SomeClass \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClass \"  ,     \" SomeClass \"  )  ;", "}", "METHOD_END"], "methodName": ["namePatternMatches"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertNoMatch (  \" AspectJTypeFilterTests $ SomeClass \"  ,     \" SomeClassX \"  )  ;", "}", "METHOD_END"], "methodName": ["namePatternNoMatches"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClass \"  ,     \" SomeClass +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClass \"  ,     \"  *  +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClass \"  ,     \" Object +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassImplementingSomeInterface \"  ,     \" SomeInterface +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassImplementingSomeInterface \"  ,     \"  *  +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassImplementingSomeInterface \"  ,     \" Object +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClassExtendingSomeClassAndImplemnentingSomeInterface \"  ,     \" SomeInterface +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClassExtendingSomeClassAndImplemnentingSomeInterface \"  ,     \" SomeClassExtendingSomeClass +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClassExtendingSomeClassAndImplemnentingSomeInterface \"  ,     \" SomeClass +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClassExtendingSomeClassAndImplemnentingSomeInterface \"  ,     \"  *  +  \"  )  ;", "assertMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClassExtendingSomeClassAndImplemnentingSomeInterface \"  ,     \" Object +  \"  )  ;", "}", "METHOD_END"], "methodName": ["subclassPatternMatches"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertNoMatch (  \" AspectJTypeFilterTests $ SomeClassExtendingSomeClass \"  ,     \" String +  \"  )  ;", "}", "METHOD_END"], "methodName": ["subclassPatternNoMatches"], "fileName": "org.springframework.core.type.AspectJTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ TestNonInheritingClass \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AssignableTypeFilter   matchingFilter    =    new   AssignableTypeFilter ( AssignableTypeFilterTests . TestNonInheritingClass . class )  ;", "AssignableTypeFilter   notMatchingFilter    =    new   AssignableTypeFilter ( AssignableTypeFilterTests . TestInterface . class )  ;", "assertFalse ( notMatchingFilter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "assertTrue ( matchingFilter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "}", "METHOD_END"], "methodName": ["directMatch"], "fileName": "org.springframework.core.type.AssignableTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ TestInterfaceImpl \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AssignableTypeFilter   filter    =    new   AssignableTypeFilter ( AssignableTypeFilterTests . TestInterface . class )  ;", "assertTrue ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( classUnderTest )  ;", "}", "METHOD_END"], "methodName": ["interfaceMatch"], "fileName": "org.springframework.core.type.AssignableTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ SomeDaoLikeImpl \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AssignableTypeFilter   filter    =    new   AssignableTypeFilter ( AssignableTypeFilterTests . JdbcDaoSupport . class )  ;", "assertTrue ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( classUnderTest )  ;", "}", "METHOD_END"], "methodName": ["interfaceThroughSuperClassMatch"], "fileName": "org.springframework.core.type.AssignableTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "MetadataReaderFactory   metadataReaderFactory    =    new   SimpleMetadataReaderFactory (  )  ;", "String   classUnderTest    =     \"  $ SomeDaoLikeImpl \"  ;", "MetadataReader   metadataReader    =    metadataReaderFactory . getMetadataReader ( classUnderTest )  ;", "AssignableTypeFilter   filter    =    new   AssignableTypeFilter ( AssignableTypeFilterTests . SimpleJdbcDaoSupport . class )  ;", "assertTrue ( filter . match ( metadataReader ,    metadataReaderFactory )  )  ;", "ClassloadingAssertions . assertClassNotLoaded ( classUnderTest )  ;", "}", "METHOD_END"], "methodName": ["superClassMatch"], "fileName": "org.springframework.core.type.AssignableTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( TestGroup . LONG _ RUNNING )  ;", "URL   url    =    getClass (  )  . getResource (  \"  / java / awt / Component . class \"  )  ;", "assertThat ( url ,    notNullValue (  )  )  ;", "for    ( int   i    =     0  ;    i    <     (  . ITEMS _ TO _ LOAD )  ;    i +  +  )     {", "Resource   resource    =    new   UrlResource ( url )     {", "@ Override", "public   boolean   equals ( Object   obj )     {", "return   obj    =  =     ( this )  ;", "}", "@ Override", "public   int   hashCode (  )     {", "return   System . identityHashCode ( this )  ;", "}", "}  ;", "MetadataReader   reader    =    mrf . getMetadataReader ( resource )  ;", "assertThat ( reader ,    notNullValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSignificantLoad"], "fileName": "org.springframework.core.type.CachingMetadataReaderLeakTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  (  (  \" Class    [  \"     +    className )     +     \"  ]    should   not   have   been   loaded \"  )  ,    ClassloadingAssertions . isClassLoaded ( className )  )  ;", "}", "METHOD_END"], "methodName": ["assertClassNotLoaded"], "fileName": "org.springframework.core.type.ClassloadingAssertions"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   cl    =    ClassUtils . getDefaultClassLoader (  )  ;", "Method   findLoadedClassMethod    =    ReflectionUtils . findMethod ( cl . getClass (  )  ,     \" findLoadedClass \"  ,    String . class )  ;", "ReflectionUtils . makeAccessible ( findLoadedClassMethod )  ;", "Class <  ?  >    loadedClass    =     (  ( Class <  ?  >  )     ( ReflectionUtils . invokeMethod ( findLoadedClassMethod ,    cl ,    className )  )  )  ;", "return   loadedClass    !  =    null ;", "}", "METHOD_END"], "methodName": ["isClassLoaded"], "fileName": "org.springframework.core.type.ClassloadingAssertions"}, {"methodBody": ["METHOD_START", "{", "return   this . introspectedClass ;", "}", "METHOD_END"], "methodName": ["getIntrospectedClass"], "fileName": "org.springframework.core.type.StandardClassMetadata"}, {"methodBody": ["METHOD_START", "{", "return   this . introspectedMethod ;", "}", "METHOD_END"], "methodName": ["getIntrospectedMethod"], "fileName": "org.springframework.core.type.StandardMethodMetadata"}, {"methodBody": ["METHOD_START", "{", "Object   valueToUse    =    attributeValue ;", "try    {", "Class <  ?  >    enumType    =    ClassUtils . forName ( Type . getType ( asmTypeDescriptor )  . getClassName (  )  ,    this . classLoader )  ;", "Field   enumConstant    =    ReflectionUtils . findField ( enumType ,    attributeValue )  ;", "if    ( enumConstant    !  =    null )     {", "ReflectionUtils . makeAccessible ( enumConstant )  ;", "valueToUse    =    enumConstant . get ( null )  ;", "}", "}    catch    ( ClassNotFoundException    |    NoClassDefFoundError   ex )     {", "logger . debug (  \" Failed   to   classload   enum   type   while   reading   a   metadata \"  ,    ex )  ;", "}    catch    ( IllegalAccessException    |    AccessControlException   ex )     {", "logger . debug (  \" Could   not   access   enum   value   while   reading   a   metadata \"  ,    ex )  ;", "}", "return   valueToUse ;", "}", "METHOD_END"], "methodName": ["getEnumValue"], "fileName": "org.springframework.core.type.classreading.AbstractRecursiveAnnotationVisitor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Annotation >    annotationType    =    annotation . annotationType (  )  ;", "String   annotationName    =    annotationType . getName (  )  ;", "if    (  (  !  ( AnnotationUtils . isInJavaLangAnnotationPackage ( annotationName )  )  )     &  &     ( visited . add ( annotation )  )  )     {", "try    {", "if    ( Modifier . isPublic ( annotationType . getModifiers (  )  )  )     {", "this . attributesMap . add ( annotationName ,    AnnotationUtils . get ( annotation ,    false ,    true )  )  ;", "}", "for    ( Annotation   metaMetaAnnotation    :    annotationType . getAnnotations (  )  )     {", "recursivelyCollectMetaAnnotations ( visited ,    metaMetaAnnotation )  ;", "}", "}    catch    ( Throwable   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Failed   to   introspect   meta - annotations   on    [  \"     +    annotation )     +     \"  ]  :     \"  )     +    ex )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["recursivelyCollectMetaAnnotations"], "fileName": "org.springframework.core.type.classreading.AnnotationAttributesReadingVisitor"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   result    =    new   AnnotationAttributes ( original )  ;", "AnnotationUtils . postProcessAnnotationAttributes ( annotatedElement ,    result ,    classValuesAsString )  ;", "for    ( Map . Entry < String ,    Object >    entry    :    result . entrySet (  )  )     {", "try    {", "Object   value    =    entry . getValue (  )  ;", "if    ( value   instanceof   AnnotationAttributes )     {", "value    =     . convertClassValues ( annotatedElement ,    classLoader ,     (  ( AnnotationAttributes )     ( value )  )  ,    classValuesAsString )  ;", "} else", "if    ( value   instanceof   AnnotationAttributes [  ]  )     {", "AnnotationAttributes [  ]    values    =     (  ( AnnotationAttributes [  ]  )     ( value )  )  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )     {", "values [ i ]     =     . convertClassValues ( annotatedElement ,    classLoader ,    values [ i ]  ,    classValuesAsString )  ;", "}", "value    =    values ;", "} else", "if    ( value   instanceof   Type )     {", "value    =     ( classValuesAsString )     ?     (  ( Type )     ( value )  )  . getClassName (  )     :    forName (  (  ( Type )     ( value )  )  . getClassName (  )  ,    classLoader )  ;", "} else", "if    ( value   instanceof   Type [  ]  )     {", "Type [  ]    array    =     (  ( Type [  ]  )     ( value )  )  ;", "Object [  ]    convArray    =     ( classValuesAsString )     ?    new   String [ array . length ]     :    new   Class <  ?  >  [ array . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "convArray [ i ]     =     ( classValuesAsString )     ?    array [ i ]  . getClassName (  )     :    forName ( array [ i ]  . getClassName (  )  ,    classLoader )  ;", "}", "value    =    convArray ;", "} else", "if    ( classValuesAsString )     {", "if    ( value   instanceof   Class )     {", "value    =     (  ( Class <  ?  >  )     ( value )  )  . getName (  )  ;", "} else", "if    ( value   instanceof   Class [  ]  )     {", "Class <  ?  >  [  ]    clazzArray    =     (  ( Class <  ?  >  [  ]  )     ( value )  )  ;", "String [  ]    newValue    =    new   String [ clazzArray . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( clazzArray . length )  ;    i +  +  )     {", "newValue [ i ]     =    clazzArray [ i ]  . getName (  )  ;", "}", "value    =    newValue ;", "}", "}", "entry . setValue ( value )  ;", "}    catch    ( Throwable   ex )     {", "result . put ( entry . getKey (  )  ,    ex )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["convertClassValues"], "fileName": "org.springframework.core.type.classreading.AnnotationReadingVisitorUtils"}, {"methodBody": ["METHOD_START", "{", "List < AnnotationAttributes >    attributesList    =    attributesMap . get ( annotationName )  ;", "if    (  ( attributesList    =  =    null )     |  |     ( attributesList . isEmpty (  )  )  )     {", "return   null ;", "}", "AnnotationAttributes   result    =    new   AnnotationAttributes ( attributesList . get (  0  )  )  ;", "Set < String >    overridableAttributeNames    =    new   HashSet <  >  ( result . keySet (  )  )  ;", "overridableAttributeNames . remove ( AnnotationUtils . VALUE )  ;", "List < String >    annotationTypes    =    new   ArrayList <  >  ( attributesMap . keySet (  )  )  ;", "Collections . reverse ( annotationTypes )  ;", "annotationTypes . remove ( annotationName )  ;", "for    ( String   currentAnnotationType    :    annotationTypes )     {", "List < AnnotationAttributes >    currentAttributesList    =    attributesMap . get ( currentAnnotationType )  ;", "if    (  !  ( ObjectUtils . isEmpty ( currentAttributesList )  )  )     {", "Set < String >    metaAnns    =    metaAnnotationMap . get ( currentAnnotationType )  ;", "if    (  ( metaAnns    !  =    null )     &  &     ( metaAnns . contains ( annotationName )  )  )     {", "AnnotationAttributes   currentAttributes    =    currentAttributesList . get (  0  )  ;", "for    ( String   overridableAttributeName    :    overridableAttributeNames )     {", "Object   value    =    currentAttributes . get ( overridableAttributeName )  ;", "if    ( value    !  =    null )     {", "result . put ( overridableAttributeName ,    value )  ;", "}", "}", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getMergedAnnotationAttributes"], "fileName": "org.springframework.core.type.classreading.AnnotationReadingVisitorUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . metadataReaderCache )    instanceof   CachingMetadataReaderFactory . LocalResourceCache )     {", "synchronized ( this . metadataReaderCache )     {", "this . metadataReaderCache . clear (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "org.springframework.core.type.classreading.CachingMetadataReaderFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . metadataReaderCache )    instanceof   CachingMetadataReaderFactory . LocalResourceCache )     {", "return    (  ( CachingMetadataReaderFactory . LocalResourceCache )     ( this . metadataReaderCache )  )  . getCacheLimit (  )  ;", "} else    {", "return    ( this . metadataReaderCache )     !  =    null    ?    Integer . MAX _ VALUE    :     0  ;", "}", "}", "METHOD_END"], "methodName": ["getCacheLimit"], "fileName": "org.springframework.core.type.classreading.CachingMetadataReaderFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( cacheLimit    <  =     0  )     {", "this . metadataReaderCache    =    null ;", "} else", "if    (  ( this . metadataReaderCache )    instanceof    . LocalResourceCache )     {", "(  (  . LocalResourceCache )     ( this . metadataReaderCache )  )  . setCacheLimit ( cacheLimit )  ;", "} else    {", "this . metadataReaderCache    =    new    . LocalResourceCache ( cacheLimit )  ;", "}", "}", "METHOD_END"], "methodName": ["setCacheLimit"], "fileName": "org.springframework.core.type.classreading.CachingMetadataReaderFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceLoader ;", "}", "METHOD_END"], "methodName": ["getResourceLoader"], "fileName": "org.springframework.core.type.classreading.SimpleMetadataReaderFactory"}, {"methodBody": ["METHOD_START", "{", "return   match ( metadataReaderFactory . getMetadataReader ( className )  ,    metadataReaderFactory )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["matchClassName"], "fileName": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["matchInterface"], "fileName": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["matchSelf"], "fileName": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["matchSuperClass"], "fileName": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . annotationType ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.springframework.core.type.filter.AnnotationTypeFilter"}, {"methodBody": ["METHOD_START", "{", "if    ( Object . class . getName (  )  . equals ( typeName )  )     {", "return   false ;", "} else", "if    ( typeName . startsWith (  \" java \"  )  )     {", "if    (  !  ( this . annotationType . getName (  )  . startsWith (  \" java \"  )  )  )     {", "return   false ;", "}", "try    {", "Class <  ?  >    clazz    =    forName ( typeName ,    getClass (  )  . getClassLoader (  )  )  ;", "return    ( this . considerMetaAnnotations    ?    annotation . AnnotationUtils . getAnnotation ( clazz ,    this . annotationType )     :    clazz . getAnnotation ( this . annotationType )  )     !  =    null ;", "}    catch    ( Throwable   ex )     {", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["hasAnnotation"], "fileName": "org.springframework.core.type.filter.AnnotationTypeFilter"}, {"methodBody": ["METHOD_START", "{", "return   this . targetType ;", "}", "METHOD_END"], "methodName": ["getTargetType"], "fileName": "org.springframework.core.type.filter.AssignableTypeFilter"}, {"methodBody": ["METHOD_START", "{", "if    ( this . targetType . getName (  )  . equals ( typeName )  )     {", "return   true ;", "} else", "if    ( Object . class . getName (  )  . equals ( typeName )  )     {", "return   false ;", "} else", "if    ( typeName . startsWith (  \" java \"  )  )     {", "try    {", "Class <  ?  >    clazz    =    util . ClassUtils . forName ( typeName ,    getClass (  )  . getClassLoader (  )  )  ;", "return   this . targetType . isAssignableFrom ( clazz )  ;", "}    catch    ( Throwable   ex )     {", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["matchTargetType"], "fileName": "org.springframework.core.type.filter.AssignableTypeFilter"}, {"methodBody": ["METHOD_START", "{", "this . source . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.mock.env.MockPropertySource"}, {"methodBody": ["METHOD_START", "{", "this . setProperty ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withProperty"], "fileName": "org.springframework.mock.env.MockPropertySource"}, {"methodBody": ["METHOD_START", "{", "ObjectInstantiator <  ?  >    instantiator    =    this . cache . get ( clazz )  ;", "if    ( instantiator    =  =    null )     {", "ObjectInstantiator < T >    newInstantiator    =    newInstantiatorOf ( clazz )  ;", "instantiator    =    this . cache . putIfAbsent ( clazz ,    newInstantiator )  ;", "if    ( instantiator    =  =    null )     {", "instantiator    =    newInstantiator ;", "}", "}", "return    (  ( ObjectInstantiator < T >  )     ( instantiator )  )  ;", "}", "METHOD_END"], "methodName": ["getInstantiatorOf"], "fileName": "org.springframework.objenesis.SpringObjenesis"}, {"methodBody": ["METHOD_START", "{", "return    ( this . worthTrying )     !  =     ( Boolean . FALSE )  ;", "}", "METHOD_END"], "methodName": ["isWorthTrying"], "fileName": "org.springframework.objenesis.SpringObjenesis"}, {"methodBody": ["METHOD_START", "{", "return   getInstantiatorOf ( clazz )  . newInstance (  )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.objenesis.SpringObjenesis"}, {"methodBody": ["METHOD_START", "{", "if    (  ! useCache )     {", "return   newInstantiatOf ( clazz )  . newInstance (  )  ;", "}", "return   getInstantiatOf ( clazz )  . newInstance (  )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.objenesis.SpringObjenesis"}, {"methodBody": ["METHOD_START", "{", "Boolean   currentWorthTrying    =    this . worthTrying ;", "try    {", "ObjectInstantiator < T >    instantiator    =    this . strategy . newInstantiatorOf ( clazz )  ;", "if    ( currentWorthTrying    =  =    null )     {", "this . worthTrying    =    Boolean . TRUE ;", "}", "return   instantiator ;", "}    catch    ( Exception   ex )     {", "if    ( currentWorthTrying    =  =    null )     {", "Throwable   cause    =    ex . getCause (  )  ;", "if    (  ( cause   instanceof   ClassNotFoundException )     |  |     ( cause   instanceof   IllegalAccessException )  )     {", "this . worthTrying    =    Boolean . FALSE ;", "}", "}", "throw   ex ;", "}    catch    ( NoClassDefFoundError   err )     {", "if    ( currentWorthTrying    =  =    null )     {", "this . worthTrying    =    Boolean . FALSE ;", "}", "throw   new   Exception ( err )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstantiatorOf"], "fileName": "org.springframework.objenesis.SpringObjenesis"}, {"methodBody": ["METHOD_START", "{", "Set < TestGroup >    testGroups    =    Assume . loadTestGroups (  )  ;", "if    (  !  ( testGroups . contains ( group )  )  )     {", "throw   new   AssumptionViolatedException (  (  (  (  \" Requires   unspecified   group    \"     +    group )     +     \"    from    \"  )     +    testGroups )  )  ;", "}", "}", "METHOD_END"], "methodName": ["group"], "fileName": "org.springframework.tests.Assume"}, {"methodBody": ["METHOD_START", "{", "Set < TestGroup >    testGroups    =    Assume . loadTestGroups (  )  ;", "if    ( testGroups . contains ( group )  )     {", "executable . execute (  )  ;", "}", "}", "METHOD_END"], "methodName": ["group"], "fileName": "org.springframework.tests.Assume"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   TestGroup . parse ( System . getProperty (  . TEST _ GROUPS _ SYSTEM _ PROPERTY )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   IllegalStateException (  (  (  (  \" Failed   to   parse    '  \"     +     (  . TEST _ GROUPS _ SYSTEM _ PROPERTY )  )     +     \"  '    system   property :     \"  )     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["loadTestGroups"], "fileName": "org.springframework.tests.Assume"}, {"methodBody": ["METHOD_START", "{", "assumeFalse ( log . isTraceEnabled (  )  )  ;", "assumeFalse ( log . isDebugEnabled (  )  )  ;", "}", "METHOD_END"], "methodName": ["notLogging"], "fileName": "org.springframework.tests.Assume"}, {"methodBody": ["METHOD_START", "{", "setTestGroups ( testGroups )  ;", "try    {", ". group ( TestGroup . JMXMP )  ;", "fail (  \" assumption   should   have   failed \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertThat ( ex . getMessage (  )  ,    startsWith (  (  (  \" Failed   to   parse    '  \"     +     (  . TEST _ GROUPS _ SYSTEM _ PROPERTY )  )     +     \"  '    system   property :     \"  )  )  )  ;", "assertThat ( ex . getCause (  )  ,    instanceOf ( IllegalArgumentException . class )  )  ;", "assertThat ( ex . getCause (  )  . getMessage (  )  ,    equalTo (  (  (  \" Unable   to   find   test   group    ' bogus '    when   parsing   testGroups   value :     '  \"     +    testGroups )     +     \"  '  .    Available   groups   include :     [ LONG _ RUNNING , PERFORMANCE , JMXMP , CI ]  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertBogusActiveTestGroupBehavior"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "assertBogusActiveTestGroupBehavior (  \" all - bogus \"  )  ;", "}", "METHOD_END"], "methodName": ["assumeGroupWithAllMinusBogusActiveTestGroup"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "assertBogusActiveTestGroupBehavior (  \" bogus \"  )  ;", "}", "METHOD_END"], "methodName": ["assumeGroupWithBogusActiveTestGroup"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "setTestGroups ( TestGroup . JMXMP )  ;", "try    {", ". group ( TestGroup . JMXMP )  ;", "}    catch    ( AssumptionViolatedException   ex )     {", "fail (  \" assumption   should   NOT   have   failed \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["assumeGroupWithMatchingActiveTestGroup"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "setTestGroups (  \"  \"  )  ;", ". group ( TestGroup . JMXMP )  ;", "fail (  \" assumption   should   have   failed \"  )  ;", "}", "METHOD_END"], "methodName": ["assumeGroupWithNoActiveTestGroups"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "setTestGroups ( TestGroup . PERFORMANCE ,    TestGroup . CI )  ;", ". group ( TestGroup . JMXMP )  ;", "fail (  \" assumption   should   have   failed \"  )  ;", "}", "METHOD_END"], "methodName": ["assumeGroupWithNoMatchingActiveTestGroup"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . originalTestGroups )     !  =    null )     {", "setTestGroups ( this . originalTestGroups )  ;", "} else    {", "setTestGroups (  \"  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["restoreOriginalTestGroups"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( Assume . TEST _ GROUPS _ SYSTEM _ PROPERTY ,    testGroups )  ;", "}", "METHOD_END"], "methodName": ["setTestGroups"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "setTestGroups ( Arrays . stream ( testGroups )  . map ( TestGroup :  : name )  . collect ( Collectors . joining (  \"  ,     \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setTestGroups"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "this . originalTestGroups    =    System . getProperty ( Assume . TEST _ GROUPS _ SYSTEM _ PROPERTY )  ;", "}", "METHOD_END"], "methodName": ["trackOriginalTestGroups"], "fileName": "org.springframework.tests.AssumeTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Matcher < T >  )     ( new   BaseMatcher < Object >  (  )     {", "@ Override", "public   boolean   matches ( Object   item )     {", "Throwable   cause    =    null ;", "if    (  ( item    !  =    null )     &  &     ( item   instanceof   Throwable )  )     {", "cause    =     (  ( Throwable )     ( item )  )  . getCause (  )  ;", "}", "return   matcher . matches ( cause )  ;", "}", "@ Override", "public   void   describeTo ( Description   description )     {", "description . appendText (  \" exception   cause    \"  )  . appendDescriptionOf ( matcher )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["exceptionCause"], "fileName": "org.springframework.tests.Matchers"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    arguments    =    invocation . getArguments (  )  ;", "for    (  . InvocationArgumentsAdapter   adapter    :    argumentAdapters )     {", "arguments    =    adapter . adaptArguments ( arguments )  ;", "}", "return   arguments ;", "}", "METHOD_END"], "methodName": ["getInvocationArguments"], "fileName": "org.springframework.tests.MockitoUtils"}, {"methodBody": ["METHOD_START", "{", "assertThat ( expectedInvocation . getMethod (  )  ,    is ( equalTo ( actualInvocation . getMethod (  )  )  )  )  ;", "Object [  ]    expectedArguments    =     . getInvocationArguments ( expectedInvocation ,    argumentAdapters )  ;", "Object [  ]    actualArguments    =     . getInvocationArguments ( actualInvocation ,    argumentAdapters )  ;", "assertThat ( expectedArguments ,    is ( equalTo ( actualArguments )  )  )  ;", "}", "METHOD_END"], "methodName": ["verifySameInvocation"], "fileName": "org.springframework.tests.MockitoUtils"}, {"methodBody": ["METHOD_START", "{", "List < Invocation >    expectedInvocations    =     (  ( InvocationContainerImpl )     ( MockUtil . getMockHandler ( expected )  . getInvocationContainer (  )  )  )  . getInvocations (  )  ;", "List < Invocation >    actualInvocations    =     (  ( InvocationContainerImpl )     ( MockUtil . getMockHandler ( actual )  . getInvocationContainer (  )  )  )  . getInvocations (  )  ;", ". verifySameInvocations ( expectedInvocations ,    actualInvocations ,    argumentAdapters )  ;", "}", "METHOD_END"], "methodName": ["verifySameInvocations"], "fileName": "org.springframework.tests.MockitoUtils"}, {"methodBody": ["METHOD_START", "{", "assertThat ( expectedInvocations . size (  )  ,    is ( equalTo ( actualInvocations . size (  )  )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( expectedInvocations . size (  )  )  ;    i +  +  )     {", ". verifySameInvocation ( expectedInvocations . get ( i )  ,    actualInvocations . get ( i )  ,    argumentAdapters )  ;", "}", "}", "METHOD_END"], "methodName": ["verifySameInvocations"], "fileName": "org.springframework.tests.MockitoUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasText ( value )  )  )     {", "return   Collections . emptySet (  )  ;", "}", "String   originalValue    =    value ;", "value    =    value . trim (  )  ;", "if    (  \" ALL \"  . equalsIgnoreCase ( value )  )     {", "return   EnumSet . allOf (  . class )  ;", "}", "if    ( value . toUpperCase (  )  . startsWith (  \" ALL -  \"  )  )     {", "Set <  >    groups    =    EnumSet . allOf (  . class )  ;", "groups . removeAll (  . parseGroups ( originalValue ,    value . substring (  4  )  )  )  ;", "return   groups ;", "}", "return    . parseGroups ( originalValue ,    value )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.tests.TestGroup"}, {"methodBody": ["METHOD_START", "{", "Set < TestGroup >    groups    =    new   HashSet <  >  (  )  ;", "for    ( String   group    :    value . split (  \"  ,  \"  )  )     {", "try    {", "groups . add ( TestGroup . valueOf ( group . trim (  )  . toUpperCase (  )  )  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   IllegalArgumentException ( String . format (  (  \" Unable   to   find   test   group    '  % s '    when   parsing   testGroups   value :     '  % s '  .     \"     +     \" Available   groups   include :     [  % s ]  \"  )  ,    group . trim (  )  ,    originalValue ,    StringUtils . arrayToCommaDelimitedString ( TestGroup . values (  )  )  )  )  ;", "}", "}", "return   groups ;", "}", "METHOD_END"], "methodName": ["parseGroups"], "fileName": "org.springframework.tests.TestGroup"}, {"methodBody": ["METHOD_START", "{", "assertThat ( TestGroup . parse (  \" all \"  )  ,    equalTo ( EnumSet . allOf ( TestGroup . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseAll"], "fileName": "org.springframework.tests.TestGroupTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  (  \" Unable   to   find   test   group    ' missing '    when   parsing    \"     +     (  \" testGroups   value :     ' all - missing '  .    Available   groups   include :     \"     +     \"  [ LONG _ RUNNING , PERFORMANCE , JMXMP , CI ]  \"  )  )  )  ;", ". parse (  \" all - missing \"  )  ;", "}", "METHOD_END"], "methodName": ["parseAllExceptMissing"], "fileName": "org.springframework.tests.TestGroupTests"}, {"methodBody": ["METHOD_START", "{", "Set < TestGroup >    expected    =    EnumSet . allOf ( TestGroup . class )  ;", "expected . remove ( TestGroup . PERFORMANCE )  ;", "assertThat ( TestGroup . parse (  \" all - performance \"  )  ,    equalTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["parseAllExceptPerformance"], "fileName": "org.springframework.tests.TestGroupTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( TestGroup . parse (  \"                 \"  )  ,    equalTo ( Collections . emptySet (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseBlankString"], "fileName": "org.springframework.tests.TestGroupTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( TestGroup . parse (  \"  \"  )  ,    equalTo ( Collections . emptySet (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseEmptyString"], "fileName": "org.springframework.tests.TestGroupTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( TestGroup . parse (  \" performance ,       PERFormaNCE \"  )  ,    equalTo ( EnumSet . of ( TestGroup . PERFORMANCE )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseInMixedCase"], "fileName": "org.springframework.tests.TestGroupTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  (  \" Unable   to   find   test   group    ' missing '    when   parsing    \"     +     (  \" testGroups   value :     ' performance ,    missing '  .    Available   groups   include :     \"     +     \"  [ LONG _ RUNNING , PERFORMANCE , JMXMP , CI ]  \"  )  )  )  ;", ". parse (  \" performance ,    missing \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMissing"], "fileName": "org.springframework.tests.TestGroupTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( TestGroup . parse ( null )  ,    equalTo ( Collections . emptySet (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseNull"], "fileName": "org.springframework.tests.TestGroupTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( TestGroup . parse (  \"    PERFORMANCE ,       PERFORMANCE    \"  )  ,    equalTo ( EnumSet . of ( TestGroup . PERFORMANCE )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseWithSpaces"], "fileName": "org.springframework.tests.TestGroupTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathResource ( String . format (  \"  % s -  % s \"  ,    clazz . getSimpleName (  )  ,    resourceSuffix )  ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["qualifiedResource"], "fileName": "org.springframework.tests.TestResourceUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceList ;", "}", "METHOD_END"], "methodName": ["getResourceList"], "fileName": "org.springframework.tests.sample.objects.GenericObject"}, {"methodBody": ["METHOD_START", "{", "this . resourceList    =    resourceList ;", "}", "METHOD_END"], "methodName": ["setResourceList"], "fileName": "org.springframework.tests.sample.objects.GenericObject"}, {"methodBody": ["METHOD_START", "{", "boolean   path 1 EndsWithSeparator    =    path 1  . endsWith ( this . pathSeparator )  ;", "boolean   path 2 StartsWithSeparator    =    path 2  . startsWith ( this . pathSeparator )  ;", "if    ( path 1 EndsWithSeparator    &  &    path 2 StartsWithSeparator )     {", "return   path 1     +     ( path 2  . subst (  1  )  )  ;", "} else", "if    ( path 1 EndsWithSeparator    |  |    path 2 StartsWithSeparator )     {", "return   path 1     +    path 2  ;", "} else    {", "return    ( path 1     +     ( this . pathSeparator )  )     +    path 2  ;", "}", "}", "METHOD_END"], "methodName": ["concat"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "this . cachePatterns    =    false ;", "this . tokenizedPatternCache . clear (  )  ;", "this . stringCache . clear (  )  ;", "}", "METHOD_END"], "methodName": ["deactivatePatternCache"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "if    (  ( path . startsWith ( this . pathSeparator )  )     !  =     ( pattern . startsWith ( this . pathSeparator )  )  )     {", "return   false ;", "}", "String [  ]    pattDirs    =    tokenizePattern ( pattern )  ;", "if    (  ( full    &  &     ( this . caseSensitive )  )     &  &     (  !  ( isPotential ( path ,    pattDirs )  )  )  )     {", "return   false ;", "}", "String [  ]    pathDirs    =    tokenizePath ( path )  ;", "int   pattIdxStart    =     0  ;", "int   pattIdxEnd    =     ( pattDirs . length )     -     1  ;", "int   pathIdxStart    =     0  ;", "int   pathIdxEnd    =     ( pathDirs . length )     -     1  ;", "while    (  ( pattIdxStart    <  =    pattIdxEnd )     &  &     ( pathIdxStart    <  =    pathIdxEnd )  )     {", "String   pattDir    =    pattDirs [ pattIdxStart ]  ;", "if    (  \"  *  *  \"  . equals ( pattDir )  )     {", "break ;", "}", "if    (  !  ( matchStrings ( pattDir ,    pathDirs [ pathIdxStart ]  ,    uriTemplateVariables )  )  )     {", "return   false ;", "}", "pattIdxStart +  +  ;", "pathIdxStart +  +  ;", "}", "if    ( pathIdxStart    >    pathIdxEnd )     {", "if    ( pattIdxStart    >    pattIdxEnd )     {", "return    ( pattern . endsWith ( this . pathSeparator )  )     =  =     ( path . endsWith ( this . pathSeparator )  )  ;", "}", "if    (  ! full )     {", "return   true ;", "}", "if    (  (  ( pattIdxStart    =  =    pattIdxEnd )     &  &     ( pattDirs [ pattIdxStart ]  . equals (  \"  *  \"  )  )  )     &  &     ( path . endsWith ( this . pathSeparator )  )  )     {", "return   true ;", "}", "for    ( int   i    =    pattIdxStart ;    i    <  =    pattIdxEnd ;    i +  +  )     {", "if    (  !  ( pattDirs [ i ]  . equals (  \"  *  *  \"  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "} else", "if    ( pattIdxStart    >    pattIdxEnd )     {", "return   false ;", "} else", "if    (  (  ! full )     &  &     (  \"  *  *  \"  . equals ( pattDirs [ pattIdxStart ]  )  )  )     {", "return   true ;", "}", "while    (  ( pattIdxStart    <  =    pattIdxEnd )     &  &     ( pathIdxStart    <  =    pathIdxEnd )  )     {", "String   pattDir    =    pattDirs [ pattIdxEnd ]  ;", "if    ( pattDir . equals (  \"  *  *  \"  )  )     {", "break ;", "}", "if    (  !  ( matchStrings ( pattDir ,    pathDirs [ pathIdxEnd ]  ,    uriTemplateVariables )  )  )     {", "return   false ;", "}", "pattIdxEnd -  -  ;", "pathIdxEnd -  -  ;", "}", "if    ( pathIdxStart    >    pathIdxEnd )     {", "for    ( int   i    =    pattIdxStart ;    i    <  =    pattIdxEnd ;    i +  +  )     {", "if    (  !  ( pattDirs [ i ]  . equals (  \"  *  *  \"  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "while    (  ( pattIdxStart    !  =    pattIdxEnd )     &  &     ( pathIdxStart    <  =    pathIdxEnd )  )     {", "int   patIdxTmp    =     -  1  ;", "for    ( int   i    =    pattIdxStart    +     1  ;    i    <  =    pattIdxEnd ;    i +  +  )     {", "if    ( pattDirs [ i ]  . equals (  \"  *  *  \"  )  )     {", "patIdxTmp    =    i ;", "break ;", "}", "}", "if    ( patIdxTmp    =  =     ( pattIdxStart    +     1  )  )     {", "pattIdxStart +  +  ;", "continue ;", "}", "int   patLength    =     ( patIdxTmp    -    pattIdxStart )     -     1  ;", "int   strLength    =     ( pathIdxEnd    -    pathIdxStart )     +     1  ;", "int   foundIdx    =     -  1  ;", "strLoop    :    for    ( int   i    =     0  ;    i    <  =     ( strLength    -    patLength )  ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <    patLength ;    j +  +  )     {", "String   subPat    =    pattDirs [  (  ( pattIdxStart    +    j )     +     1  )  ]  ;", "String   subStr    =    pathDirs [  (  ( pathIdxStart    +    i )     +    j )  ]  ;", "if    (  !  ( matchStrings ( subPat ,    subStr ,    uriTemplateVariables )  )  )     {", "continue   strLoop ;", "}", "}", "foundIdx    =    pathIdxStart    +    i ;", "break ;", "}", "if    ( foundIdx    =  =     (  -  1  )  )     {", "return   false ;", "}", "pattIdxStart    =    patIdxTmp ;", "pathIdxStart    =    foundIdx    +    patLength ;", "}", "for    ( int   i    =    pattIdxStart ;    i    <  =    pattIdxEnd ;    i +  +  )     {", "if    (  !  ( pattDirs [ i ]  . equals (  \"  *  *  \"  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["doMatch"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "AntPathMatcher . AntPathStringMatcher   matcher    =    null ;", "Boolean   cachePatterns    =    this . cachePatterns ;", "if    (  ( cachePatterns    =  =    null )     |  |     ( cachePatterns . booleanValue (  )  )  )     {", "matcher    =    this . stringMatcherCache . get ( pattern )  ;", "}", "if    ( matcher    =  =    null )     {", "matcher    =    new   AntPathMatcher . AntPathStringMatcher ( pattern ,    this . caseSensitive )  ;", "if    (  ( cachePatterns    =  =    null )     &  &     (  ( this . stringMatcherCache . size (  )  )     >  =     ( AntPathMatcher . CACHE _ TURNOFF _ THRESHOLD )  )  )     {", "deactivatePatternCache (  )  ;", "return   matcher ;", "}", "if    (  ( cachePatterns    =  =    null )     |  |     ( cachePatterns . booleanValue (  )  )  )     {", "this . stringMatcherCache . put ( pattern ,    matcher )  ;", "}", "}", "return   matcher ;", "}", "METHOD_END"], "methodName": ["getStringMatcher"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . trimTokens )  )     {", "int   pos    =     0  ;", "for    ( St   pattDir    :    pattDirs )     {", "int   skipped    =    skipSeparator ( path ,    pos ,    this . pathSeparator )  ;", "pos    +  =    skipped ;", "skipped    =    skipSegment ( path ,    pos ,    pattDir )  ;", "if    ( skipped    <     ( pattDir . length (  )  )  )     {", "return    ( skipped    >     0  )     |  |     (  (  ( pattDir . length (  )  )     >     0  )     &  &     ( isWildcardChar ( pattDir . charAt (  0  )  )  )  )  ;", "}", "pos    +  =    skipped ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isPotentialMatch"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "for    ( char   candidate    :    AntPathMatcher . WILDCARD _ CHARS )     {", "if    ( c    =  =    candidate )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isWildcardChar"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "return   getStringMatcher ( pattern )  . matchStrings ( str ,    uriTemplateVariables )  ;", "}", "METHOD_END"], "methodName": ["matchStrings"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "this . cachePatterns    =    cachePatterns ;", "}", "METHOD_END"], "methodName": ["setCachePatterns"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "this . caseSensitive    =    caseSensitive ;", "}", "METHOD_END"], "methodName": ["setCaseSensitive"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "this . pathSeparator    =     ( pathSeparator    !  =    null )     ?    pathSeparator    :    AntPathMatcher . DEFAULT _ PATH _ SEPARATOR ;", "this . pathSeparatorPatternCache    =    new   AntPathMatcher . PathSeparatorPatternCache ( this . pathSeparator )  ;", "}", "METHOD_END"], "methodName": ["setPathSeparator"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "this . trimTokens    =    trimTokens ;", "}", "METHOD_END"], "methodName": ["setTrimTokens"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "int   skipped    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( prefix . length (  )  )  ;    i +  +  )     {", "char   c    =    prefix . charAt ( i )  ;", "if    ( isWildcardChar ( c )  )     {", "return   skipped ;", "}", "int   currPos    =    pos    +    skipped ;", "if    ( currPos    >  =     ( p . length (  )  )  )     {", "return    0  ;", "}", "if    ( c    =  =     ( p . charAt ( currPos )  )  )     {", "skipped +  +  ;", "}", "}", "return   skipped ;", "}", "METHOD_END"], "methodName": ["skipSegment"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "int   skipped    =     0  ;", "while    ( p . startsWith ( separator ,     ( pos    +    skipped )  )  )     {", "skipped    +  =    separator . length (  )  ;", "}", "return   skipped ;", "}", "METHOD_END"], "methodName": ["skipSeparator"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . tokenizeToStringArray ( path ,    this . pathSeparator ,    this . trimTokens ,    true )  ;", "}", "METHOD_END"], "methodName": ["tokenizePath"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "String [  ]    tokenized    =    null ;", "Boolean   cachePatterns    =    this . cachePatterns ;", "if    (  ( cachePatterns    =  =    null )     |  |     ( cachePatterns . booleanValue (  )  )  )     {", "tokenized    =    this . tokenizedPatternCache . get ( pattern )  ;", "}", "if    ( tokenized    =  =    null )     {", "tokenized    =    tokenizePath ( pattern )  ;", "if    (  ( cachePatterns    =  =    null )     &  &     (  ( this . tokenizedPatternCache . size (  )  )     >  =     (  . CACHE _ TURNOFF _ THRESHOLD )  )  )     {", "deactivatePatternCache (  )  ;", "return   tokenized ;", "}", "if    (  ( cachePatterns    =  =    null )     |  |     ( cachePatterns . booleanValue (  )  )  )     {", "this . tokenizedPatternCache . put ( pattern ,    tokenized )  ;", "}", "}", "return   tokenized ;", "}", "METHOD_END"], "methodName": ["tokenizePattern"], "fileName": "org.springframework.util.AntPathMatcher"}, {"methodBody": ["METHOD_START", "{", "pathMatcher . setCachePatterns ( false )  ;", "match (  )  ;", "assertTrue ( pathMatcher . stringMatcherCache . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["cachePatternsSetToFalse"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "pathMatcher . setCachePatterns ( true )  ;", "match (  )  ;", "assertTrue (  (  ( pathMatcher . stringMatcherCache . size (  )  )     >     2  0  )  )  ;", "for    ( int   i    =     0  ;    i    <     6  5  5  3  6  ;    i +  +  )     {", "pathMatcher . match (  (  \" test \"     +    i )  ,     (  \" test \"     +    i )  )  ;", "}", "assertTrue (  (  ( pathMatcher . stringMatcherCache . size (  )  )     >     6  5  5  3  6  )  )  ;", "}", "METHOD_END"], "methodName": ["cachePatternsSetToTrue"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "pathMatcher . setCaseSensitive ( false )  ;", "assertTrue ( pathMatcher . match (  \"  / group /  { groupName }  / members \"  ,     \"  / group / sales / members \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / group /  { groupName }  / members \"  ,     \"  / Group / Sales / Members \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / Group /  { groupName }  / Members \"  ,     \"  / group / Sales / members \"  )  )  ;", "}", "METHOD_END"], "methodName": ["caseInsensitive"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  \"  ,    pathMatcher . combine ( null ,    null )  )  ;", "assertEquals (  \"  / hotels \"  ,    pathMatcher . combine (  \"  / hotels \"  ,    null )  )  ;", "assertEquals (  \"  / hotels \"  ,    pathMatcher . combine ( null ,     \"  / hotels \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels /  *  \"  ,     \" booking \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels /  *  \"  ,     \"  / booking \"  )  )  ;", "assertEquals (  \"  / hotels /  *  *  / booking \"  ,    pathMatcher . combine (  \"  / hotels /  *  *  \"  ,     \" booking \"  )  )  ;", "assertEquals (  \"  / hotels /  *  *  / booking \"  ,    pathMatcher . combine (  \"  / hotels /  *  *  \"  ,     \"  / booking \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels \"  ,     \"  / booking \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels \"  ,     \" booking \"  )  )  ;", "assertEquals (  \"  / hotels / booking \"  ,    pathMatcher . combine (  \"  / hotels /  \"  ,     \" booking \"  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  \"  ,    pathMatcher . combine (  \"  / hotels /  *  \"  ,     \"  { hotel }  \"  )  )  ;", "assertEquals (  \"  / hotels /  *  *  /  { hotel }  \"  ,    pathMatcher . combine (  \"  / hotels /  *  *  \"  ,     \"  { hotel }  \"  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  \"  ,    pathMatcher . combine (  \"  / hotels \"  ,     \"  { hotel }  \"  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  .  *  \"  ,    pathMatcher . combine (  \"  / hotels \"  ,     \"  { hotel }  .  *  \"  )  )  ;", "assertEquals (  \"  / hotels /  *  / booking /  { booking }  \"  ,    pathMatcher . combine (  \"  / hotels /  *  / booking \"  ,     \"  { booking }  \"  )  )  ;", "assertEquals (  \"  / hotel . html \"  ,    pathMatcher . combine (  \"  /  *  . html \"  ,     \"  / hotel . html \"  )  )  ;", "assertEquals (  \"  / hotel . html \"  ,    pathMatcher . combine (  \"  /  *  . html \"  ,     \"  / hotel \"  )  )  ;", "assertEquals (  \"  / hotel . html \"  ,    pathMatcher . combine (  \"  /  *  . html \"  ,     \"  / hotel .  *  \"  )  )  ;", "assertEquals (  \"  /  *  . html \"  ,    pathMatcher . combine (  \"  /  *  *  \"  ,     \"  /  *  . html \"  )  )  ;", "assertEquals (  \"  /  *  . html \"  ,    pathMatcher . combine (  \"  /  *  \"  ,     \"  /  *  . html \"  )  )  ;", "assertEquals (  \"  /  *  . html \"  ,    pathMatcher . combine (  \"  /  *  .  *  \"  ,     \"  /  *  . html \"  )  )  ;", "assertEquals (  \"  /  { foo }  / bar \"  ,    pathMatcher . combine (  \"  /  { foo }  \"  ,     \"  / bar \"  )  )  ;", "assertEquals (  \"  / user / user \"  ,    pathMatcher . combine (  \"  / user \"  ,     \"  / user \"  )  )  ;", "assertEquals (  \"  /  { foo :  .  *  [  ^  0  -  9  ]  .  *  }  / edit /  \"  ,    pathMatcher . combine (  \"  /  { foo :  .  *  [  ^  0  -  9  ]  .  *  }  \"  ,     \"  / edit /  \"  )  )  ;", "assertEquals (  \"  /  1  .  0  / foo / test \"  ,    pathMatcher . combine (  \"  /  1  .  0  \"  ,     \"  / foo / test \"  )  )  ;", "assertEquals (  \"  / hotel \"  ,    pathMatcher . combine (  \"  /  \"  ,     \"  / hotel \"  )  )  ;", "assertEquals (  \"  / hotel / booking \"  ,    pathMatcher . combine (  \"  / hotel /  \"  ,     \"  / booking \"  )  )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "p . combine (  \"  /  *  . html \"  ,     \"  /  *  . txt \"  )  ;", "}", "METHOD_END"], "methodName": ["combineWithTwoFileExtensionPatterns"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "pathMatcher . setCachePatterns ( true )  ;", "assertEquals (  0  ,    pathMatcher . stringMatcherCache . size (  )  )  ;", "pathMatcher . match (  \" test \"  ,     \" testian \"  )  ;", "pathMatcher . match (  \" test ?  \"  ,     \" testFf \"  )  ;", "pathMatcher . match (  \" test /  *  \"  ,     \" test / dir / name . jpg \"  )  ;", "pathMatcher . match (  \" test /  { name }  . jpg \"  ,     \" test / lorem . jpg \"  )  ;", "pathMatcher . match (  \" bla /  *  *  / test . jpg \"  ,     \" bla / test . jpg \"  )  ;", "pathMatcher . match (  \"  *  *  /  { name }  . jpg \"  ,     \" test / lorem . jpg \"  )  ;", "pathMatcher . match (  \"  /  *  *  /  { name }  . jpg \"  ,     \"  / test / lorem . jpg \"  )  ;", "pathMatcher . match (  \"  /  *  / dir /  { name }  . jpg \"  ,     \"  /  *  / dir / lorem . jpg \"  )  ;", "assertEquals (  7  ,    pathMatcher . stringMatcherCache . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["creatingStringMatchersIfPatternPrefixCannotDetermineIfPathMatch"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "match (  )  ;", "assertTrue (  (  ( p . stringMatcherCache . size (  )  )     >     2  0  )  )  ;", "for    ( int   i    =     0  ;    i    <     6  5  5  3  6  ;    i +  +  )     {", "p . match (  (  \" test \"     +    i )  ,     \" test \"  )  ;", "}", "assertTrue ( p . stringMatcherCache . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultCacheSetting"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "pathMatcher . setPathSeparator (  \"  .  \"  )  ;", "assertEquals (  \" Extension   mapping   should   be   disabled   with    \\  \"  .  \\  \"    as   path   separator \"  ,     \"  /  *  . html . hotel .  *  \"  ,    pathMatcher . combine (  \"  /  *  . html \"  ,     \" hotel .  *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extensionMappingWithDotPathSeparator"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  \"  ,    pathMatcher . extractPathWithinPattern (  \"  / docs / commit . html \"  ,     \"  / docs / commit . html \"  )  )  ;", "assertEquals (  \" cvs / commit \"  ,    pathMatcher . extractPathWithinPattern (  \"  / docs /  *  \"  ,     \"  / docs / cvs / commit \"  )  )  ;", "assertEquals (  \" commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  / docs / cvs /  *  . html \"  ,     \"  / docs / cvs / commit . html \"  )  )  ;", "assertEquals (  \" cvs / commit \"  ,    pathMatcher . extractPathWithinPattern (  \"  / docs /  *  *  \"  ,     \"  / docs / cvs / commit \"  )  )  ;", "assertEquals (  \" cvs / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  / docs /  *  *  /  *  . html \"  ,     \"  / docs / cvs / commit . html \"  )  )  ;", "assertEquals (  \" commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  / docs /  *  *  /  *  . html \"  ,     \"  / docs / commit . html \"  )  )  ;", "assertEquals (  \" commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  /  *  . html \"  ,     \"  / commit . html \"  )  )  ;", "assertEquals (  \" docs / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  /  *  . html \"  ,     \"  / docs / commit . html \"  )  )  ;", "assertEquals (  \"  / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  *  . html \"  ,     \"  / commit . html \"  )  )  ;", "assertEquals (  \"  / docs / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  *  . html \"  ,     \"  / docs / commit . html \"  )  )  ;", "assertEquals (  \"  / docs / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  *  *  /  *  .  *  \"  ,     \"  / docs / commit . html \"  )  )  ;", "assertEquals (  \"  / docs / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  *  \"  ,     \"  / docs / commit . html \"  )  )  ;", "assertEquals (  \"  / docs / cvs / other / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  *  *  / commit . html \"  ,     \"  / docs / cvs / other / commit . html \"  )  )  ;", "assertEquals (  \" cvs / other / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  / docs /  *  *  / commit . html \"  ,     \"  / docs / cvs / other / commit . html \"  )  )  ;", "assertEquals (  \" cvs / other / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  / docs /  *  *  /  *  *  /  *  *  /  *  *  \"  ,     \"  / docs / cvs / other / commit . html \"  )  )  ;", "assertEquals (  \" docs / cvs / commit \"  ,    pathMatcher . extractPathWithinPattern (  \"  / d ? cs /  *  \"  ,     \"  / docs / cvs / commit \"  )  )  ;", "assertEquals (  \" cvs / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  / docs / c ? s /  *  . html \"  ,     \"  / docs / cvs / commit . html \"  )  )  ;", "assertEquals (  \" docs / cvs / commit \"  ,    pathMatcher . extractPathWithinPattern (  \"  / d ? cs /  *  *  \"  ,     \"  / docs / cvs / commit \"  )  )  ;", "assertEquals (  \" docs / cvs / commit . html \"  ,    pathMatcher . extractPathWithinPattern (  \"  / d ? cs /  *  *  /  *  . html \"  ,     \"  / docs / cvs / commit . html \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extractPathWithinPattern"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    result    =    pathMatcher . extractUriTemplateVariables (  \"  / hotels /  { hotel }  \"  ,     \"  / hotels /  1  \"  )  ;", "assertEquals ( Collections . singletonMap (  \" hotel \"  ,     \"  1  \"  )  ,    result )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  / h ? tels /  { hotel }  \"  ,     \"  / hotels /  1  \"  )  ;", "assertEquals ( Collections . singletonMap (  \" hotel \"  ,     \"  1  \"  )  ,    result )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  ,     \"  / hotels /  1  / bookings /  2  \"  )  ;", "Map < String ,    String >    expected    =    new   LinkedHashMap <  >  (  )  ;", "expected . put (  \" hotel \"  ,     \"  1  \"  )  ;", "expected . put (  \" booking \"  ,     \"  2  \"  )  ;", "assertEquals ( expected ,    result )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  /  *  *  / hotels /  *  *  /  { hotel }  \"  ,     \"  / foo / hotels / bar /  1  \"  )  ;", "assertEquals ( Collections . singletonMap (  \" hotel \"  ,     \"  1  \"  )  ,    result )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  /  { page }  . html \"  ,     \"  /  4  2  . html \"  )  ;", "assertEquals ( Collections . singletonMap (  \" page \"  ,     \"  4  2  \"  )  ,    result )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  /  { page }  .  *  \"  ,     \"  /  4  2  . html \"  )  ;", "assertEquals ( Collections . singletonMap (  \" page \"  ,     \"  4  2  \"  )  ,    result )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  / A -  { B }  - C \"  ,     \"  / A - b - C \"  )  ;", "assertEquals ( Collections . singletonMap (  \" B \"  ,     \" b \"  )  ,    result )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  /  { name }  .  { extension }  \"  ,     \"  / test . html \"  )  ;", "expected    =    new   LinkedHashMap <  >  (  )  ;", "expected . put (  \" name \"  ,     \" test \"  )  ;", "expected . put (  \" extension \"  ,     \" html \"  )  ;", "assertEquals ( expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["extractUriTemplateVariables"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    result    =    pathMatcher . extractUriTemplateVariables (  \"  { symbolicName :  [  \\  \\ w \\  \\  .  ]  +  }  -  { version :  [  \\  \\ w \\  \\  .  ]  +  }  . jar \"  ,     \" com . example -  1  .  0  .  0  . jar \"  )  ;", "assertEquals (  \" com . example \"  ,    result . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  \"  ,    result . get (  \" version \"  )  )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  { symbolicName :  [  \\  \\ w \\  \\  .  ]  +  }  - sources -  { version :  [  \\  \\ w \\  \\  .  ]  +  }  . jar \"  ,     \" com . example - sources -  1  .  0  .  0  . jar \"  )  ;", "assertEquals (  \" com . example \"  ,    result . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  \"  ,    result . get (  \" version \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extractUriTemplateVariablesRegex"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( containsString (  \" The   number   of   capturing   groups   in   the   pattern \"  )  )  ;", "p . extractUriTemplateVariables (  \"  / web /  { id : foo ( bar )  ?  }  \"  ,     \"  / web / foobar \"  )  ;", "}", "METHOD_END"], "methodName": ["extractUriTemplateVarsRegexCapturingGroups"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    result    =    pathMatcher . extractUriTemplateVariables (  \"  { symbolicName :  [  \\  \\ p { L }  \\  \\  .  ]  +  }  - sources -  { version :  [  \\  \\ p { N }  \\  \\  .  ]  +  }  . jar \"  ,     \" com . example - sources -  1  .  0  .  0  . jar \"  )  ;", "assertEquals (  \" com . example \"  ,    result . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  \"  ,    result . get (  \" version \"  )  )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  { symbolicName :  [  \\  \\ w \\  \\  .  ]  +  }  - sources -  { version :  [  \\  \\ d \\  \\  .  ]  +  }  -  { year :  \\  \\ d {  4  }  }  { month :  \\  \\ d {  2  }  }  { day :  \\  \\ d {  2  }  }  . jar \"  ,     \" com . example - sources -  1  .  0  .  0  -  2  0  1  0  0  2  2  0  . jar \"  )  ;", "assertEquals (  \" com . example \"  ,    result . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  \"  ,    result . get (  \" version \"  )  )  ;", "assertEquals (  \"  2  0  1  0  \"  ,    result . get (  \" year \"  )  )  ;", "assertEquals (  \"  0  2  \"  ,    result . get (  \" month \"  )  )  ;", "assertEquals (  \"  2  0  \"  ,    result . get (  \" day \"  )  )  ;", "result    =    pathMatcher . extractUriTemplateVariables (  \"  { symbolicName :  [  \\  \\ p { L }  \\  \\  .  ]  +  }  - sources -  { version :  [  \\  \\ p { N }  \\  \\  .  \\  \\  {  \\  \\  }  ]  +  }  . jar \"  ,     \" com . example - sources -  1  .  0  .  0  .  {  1  2  }  . jar \"  )  ;", "assertEquals (  \" com . example \"  ,    result . get (  \" symbolicName \"  )  )  ;", "assertEquals (  \"  1  .  0  .  0  .  {  1  2  }  \"  ,    result . get (  \" version \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extractUriTemplateVarsRegexQualifiers"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( pathMatcher . match (  \" test \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / test \"  ,     \"  / test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" http :  /  / example . org \"  ,     \" http :  /  / example . org \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  / test . jpg \"  ,     \" test . jpg \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test \"  ,     \"  / test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  / test \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" t ? st \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  ?  ? st \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" tes ?  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" te ?  ?  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  ? es ?  \"  ,     \" test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" tes ?  \"  ,     \" tes \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" tes ?  \"  ,     \" testt \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" tes ?  \"  ,     \" tsst \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  *  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" test *  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" test *  \"  ,     \" testTest \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" test /  *  \"  ,     \" test / Test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" test /  *  \"  ,     \" test / t \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" test /  *  \"  ,     \" test /  \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  * test *  \"  ,     \" AnothertestTest \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  * test \"  ,     \" Anothertest \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  *  .  *  \"  ,     \" test .  \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  *  .  *  \"  ,     \" test . test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  *  .  *  \"  ,     \" test . test . test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" test * aaa \"  ,     \" testblaaaa \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test *  \"  ,     \" tst \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test *  \"  ,     \" tsttest \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test *  \"  ,     \" test /  \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test *  \"  ,     \" test / t \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test /  *  \"  ,     \" test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  * test *  \"  ,     \" tsttst \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  * test \"  ,     \" tsttst \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  *  .  *  \"  ,     \" tsttst \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test * aaa \"  ,     \" test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test * aaa \"  ,     \" testblaaab \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  ?  \"  ,     \"  / a \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  ?  / a \"  ,     \"  / a / a \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / a /  ?  \"  ,     \"  / a / b \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  ?  ?  / a \"  ,     \"  / aa / a \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / a /  ?  ?  \"  ,     \"  / a / bb \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  ?  \"  ,     \"  / a \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  *  *  \"  ,     \"  / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  *  /  *  *  \"  ,     \"  / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  *  *  /  *  \"  ,     \"  / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / bla /  *  *  / bla \"  ,     \"  / bla / testing / testing / bla \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / bla /  *  *  / bla \"  ,     \"  / bla / testing / testing / bla / bla \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  *  *  / test \"  ,     \"  / bla / bla / test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / bla /  *  *  /  *  *  / bla \"  ,     \"  / bla / bla / bla / bla / bla / bla \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / bla * bla / test \"  ,     \"  / blaXXXbla / test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  * bla / test \"  ,     \"  / XXXbla / test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  / bla * bla / test \"  ,     \"  / blaXXXbl / test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  /  * bla / test \"  ,     \" XXXblab / test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  /  * bla / test \"  ,     \" XXXbl / test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  /  ?  ?  ?  ?  \"  ,     \"  / bala / bla \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  /  *  *  /  * bla \"  ,     \"  / bla / bla / bla / bbb \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  * bla *  /  *  *  / bla /  *  *  \"  ,     \"  / XXXblaXXXX / testing / testing / bla / testing / testing /  \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  * bla *  /  *  *  / bla /  *  \"  ,     \"  / XXXblaXXXX / testing / testing / bla / testing \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  * bla *  /  *  *  / bla /  *  *  \"  ,     \"  / XXXblaXXXX / testing / testing / bla / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  * bla *  /  *  *  / bla /  *  *  \"  ,     \"  / XXXblaXXXX / testing / testing / bla / testing / testing . jpg \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  * bla *  /  *  *  / bla /  *  *  \"  ,     \" XXXblaXXXX / testing / testing / bla / testing / testing /  \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  * bla *  /  *  *  / bla /  *  \"  ,     \" XXXblaXXXX / testing / testing / bla / testing \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  * bla *  /  *  *  / bla /  *  *  \"  ,     \" XXXblaXXXX / testing / testing / bla / testing / testing \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  * bla *  /  *  *  / bla /  *  \"  ,     \" XXXblaXXXX / testing / testing / bla / testing / testing \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  / x / x /  *  *  / bla \"  ,     \"  / x / x / x /  \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / foo / bar /  *  *  \"  ,     \"  / foo / bar \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  \"  ,     \"  \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  /  { bla }  .  *  \"  ,     \"  / testing . html \"  )  )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "pathMatcher . setTrimTokens ( true )  ;", "assertTrue ( pathMatcher . match (  \"  / foo / bar \"  ,     \"  / foo    / bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["matchWithTrimTokensEnabled"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < String >    comparator    =    pathMatcher . getPatternComparator (  \"  / hotels / new \"  )  ;", "assertEquals (  0  ,    comparator . compare ( null ,    null )  )  ;", "assertEquals (  1  ,    comparator . compare ( null ,     \"  / hotels / new \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels / new \"  ,    null )  )  ;", "assertEquals (  0  ,    comparator . compare (  \"  / hotels / new \"  ,     \"  / hotels / new \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels / new \"  ,     \"  / hotels /  *  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  / hotels /  *  \"  ,     \"  / hotels / new \"  )  )  ;", "assertEquals (  0  ,    comparator . compare (  \"  / hotels /  *  \"  ,     \"  / hotels /  *  \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels / new \"  ,     \"  / hotels /  { hotel }  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  / hotels /  { hotel }  \"  ,     \"  / hotels / new \"  )  )  ;", "assertEquals (  0  ,    comparator . compare (  \"  / hotels /  { hotel }  \"  ,     \"  / hotels /  { hotel }  \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels /  { hotel }  / booking \"  ,     \"  / hotels /  { hotel }  / bookings /  { booking }  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  / hotels /  { hotel }  / bookings /  { booking }  \"  ,     \"  / hotels /  { hotel }  / booking \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels /  { hotel }  / bookings /  { booking }  / cutomers /  { customer }  \"  ,     \"  /  *  *  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  /  *  *  \"  ,     \"  / hotels /  { hotel }  / bookings /  { booking }  / cutomers /  { customer }  \"  )  )  ;", "assertEquals (  0  ,    comparator . compare (  \"  /  *  *  \"  ,     \"  /  *  *  \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels /  { hotel }  \"  ,     \"  / hotels /  *  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  / hotels /  *  \"  ,     \"  / hotels /  { hotel }  \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels /  *  \"  ,     \"  / hotels /  *  /  *  *  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  / hotels /  *  /  *  *  \"  ,     \"  / hotels /  *  \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels / new \"  ,     \"  / hotels / new .  *  \"  )  )  ;", "assertEquals (  2  ,    comparator . compare (  \"  / hotels /  { hotel }  \"  ,     \"  / hotels /  { hotel }  .  *  \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels /  { hotel }  / bookings /  { booking }  / cutomers /  { customer }  \"  ,     \"  / hotels /  *  *  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  / hotels /  *  *  \"  ,     \"  / hotels /  { hotel }  / bookings /  { booking }  / cutomers /  { customer }  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  / hotels / foo / bar /  *  *  \"  ,     \"  / hotels /  { hotel }  \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  / hotels /  { hotel }  \"  ,     \"  / hotels / foo / bar /  *  *  \"  )  )  ;", "assertEquals (  2  ,    comparator . compare (  \"  / hotels /  *  *  / bookings /  *  *  \"  ,     \"  / hotels /  *  *  \"  )  )  ;", "assertEquals (  (  -  2  )  ,    comparator . compare (  \"  / hotels /  *  *  \"  ,     \"  / hotels /  *  *  / bookings /  *  *  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  /  *  *  \"  ,     \"  / hotels /  { hotel }  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  / hotels \"  ,     \"  / hotels 2  \"  )  )  ;", "assertEquals (  (  -  1  )  ,    comparator . compare (  \"  *  \"  ,     \"  *  /  *  *  \"  )  )  ;", "assertEquals (  1  ,    comparator . compare (  \"  *  /  *  *  \"  ,     \"  *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["patternComparator"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < String >    comparator    =    pathMatcher . getPatternComparator (  \"  / hotels / new \"  )  ;", "List < String >    paths    =    new   ArrayList <  >  (  3  )  ;", "paths . add ( null )  ;", "paths . add (  \"  / hotels / new \"  )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels / new \"  ,    paths . get (  0  )  )  ;", "assertNull ( paths . get (  1  )  )  ;", "paths . clear (  )  ;", "paths . add (  \"  / hotels / new \"  )  ;", "paths . add ( null )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels / new \"  ,    paths . get (  0  )  )  ;", "assertNull ( paths . get (  1  )  )  ;", "paths . clear (  )  ;", "paths . add (  \"  / hotels /  *  \"  )  ;", "paths . add (  \"  / hotels / new \"  )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels / new \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  / hotels /  *  \"  ,    paths . get (  1  )  )  ;", "paths . clear (  )  ;", "paths . add (  \"  / hotels / new \"  )  ;", "paths . add (  \"  / hotels /  *  \"  )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels / new \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  / hotels /  *  \"  ,    paths . get (  1  )  )  ;", "paths . clear (  )  ;", "paths . add (  \"  / hotels /  *  *  \"  )  ;", "paths . add (  \"  / hotels /  *  \"  )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels /  *  \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  / hotels /  *  *  \"  ,    paths . get (  1  )  )  ;", "paths . clear (  )  ;", "paths . add (  \"  / hotels /  *  \"  )  ;", "paths . add (  \"  / hotels /  *  *  \"  )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels /  *  \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  / hotels /  *  *  \"  ,    paths . get (  1  )  )  ;", "paths . clear (  )  ;", "paths . add (  \"  / hotels /  { hotel }  \"  )  ;", "paths . add (  \"  / hotels / new \"  )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels / new \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  \"  ,    paths . get (  1  )  )  ;", "paths . clear (  )  ;", "paths . add (  \"  / hotels / new \"  )  ;", "paths . add (  \"  / hotels /  { hotel }  \"  )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels / new \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  \"  ,    paths . get (  1  )  )  ;", "paths . clear (  )  ;", "paths . add (  \"  / hotels /  *  \"  )  ;", "paths . add (  \"  / hotels /  { hotel }  \"  )  ;", "paths . add (  \"  / hotels / new \"  )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels / new \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  \"  ,    paths . get (  1  )  )  ;", "assertEquals (  \"  / hotels /  *  \"  ,    paths . get (  2  )  )  ;", "paths . clear (  )  ;", "paths . add (  \"  / hotels / ne *  \"  )  ;", "paths . add (  \"  / hotels / n *  \"  )  ;", "Collections . shuffle ( paths )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels / ne *  \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  / hotels / n *  \"  ,    paths . get (  1  )  )  ;", "paths . clear (  )  ;", "comparator    =    pathMatcher . getPatternComparator (  \"  / hotels / new . html \"  )  ;", "paths . add (  \"  / hotels / new .  *  \"  )  ;", "paths . add (  \"  / hotels /  { hotel }  \"  )  ;", "Collections . shuffle ( paths )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  / hotels / new .  *  \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  / hotels /  { hotel }  \"  ,    paths . get (  1  )  )  ;", "paths . clear (  )  ;", "comparator    =    pathMatcher . getPatternComparator (  \"  / web / endUser / action / login . html \"  )  ;", "paths . add (  \"  /  *  *  / login .  *  \"  )  ;", "paths . add (  \"  /  *  *  / endUser / action / login .  *  \"  )  ;", "Collections . sort ( paths ,    comparator )  ;", "assertEquals (  \"  /  *  *  / endUser / action / login .  *  \"  ,    paths . get (  0  )  )  ;", "assertEquals (  \"  /  *  *  / login .  *  \"  ,    paths . get (  1  )  )  ;", "paths . clear (  )  ;", "}", "METHOD_END"], "methodName": ["patternComparatorSort"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "pathMatcher . setCachePatterns ( true )  ;", "assertEquals (  0  ,    pathMatcher . stringMatcherCache . size (  )  )  ;", "pathMatcher . match (  \" test ?  \"  ,     \" test \"  )  ;", "assertEquals (  1  ,    pathMatcher . stringMatcherCache . size (  )  )  ;", "pathMatcher . match (  \" test ?  \"  ,     \" best \"  )  ;", "pathMatcher . match (  \" test /  *  \"  ,     \" view / test . jpg \"  )  ;", "pathMatcher . match (  \" test /  *  *  / test . jpg \"  ,     \" view / test . jpg \"  )  ;", "pathMatcher . match (  \" test /  { name }  . jpg \"  ,     \" view / test . jpg \"  )  ;", "assertEquals (  1  ,    pathMatcher . stringMatcherCache . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["preventCreatingStringMatchersIfPathDoesNotStartsWithPatternPrefix"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "pathMatcher . setTrimTokens ( false )  ;", "assertTrue ( pathMatcher . match (  \"  / group /  { groupName }  / members \"  ,     \"  / group / sales / members \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  / group /  { groupName }  / members \"  ,     \"  / group /       sales / members \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  / group /  { groupName }  / members \"  ,     \"  / Group /       Sales / Members \"  )  )  ;", "}", "METHOD_END"], "methodName": ["trimTokensOff"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "pathMatcher . setPathSeparator (  \"  .  \"  )  ;", "assertTrue ( pathMatcher . match (  \" test \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  . test \"  ,     \"  . test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  . test / jpg \"  ,     \" test / jpg \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test \"  ,     \"  . test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  . test \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" t ? st \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  ?  ? st \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" tes ?  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" te ?  ?  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  ? es ?  \"  ,     \" test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" tes ?  \"  ,     \" tes \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" tes ?  \"  ,     \" testt \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" tes ?  \"  ,     \" tsst \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  *  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" test *  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" test *  \"  ,     \" testTest \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  * test *  \"  ,     \" AnothertestTest \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  * test \"  ,     \" Anothertest \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  *  /  *  \"  ,     \" test /  \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  *  /  *  \"  ,     \" test / test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  *  /  *  \"  ,     \" test / test / test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \" test * aaa \"  ,     \" testblaaaa \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test *  \"  ,     \" tst \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test *  \"  ,     \" tsttest \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  * test *  \"  ,     \" tsttst \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  * test \"  ,     \" tsttst \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  *  /  *  \"  ,     \" tsttst \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test * aaa \"  ,     \" test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \" test * aaa \"  ,     \" testblaaab \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  .  ?  \"  ,     \"  . a \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  .  ?  . a \"  ,     \"  . a . a \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  . a .  ?  \"  ,     \"  . a . b \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  .  ?  ?  . a \"  ,     \"  . aa . a \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  . a .  ?  ?  \"  ,     \"  . a . bb \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  .  ?  \"  ,     \"  . a \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  .  *  *  \"  ,     \"  . testing . testing \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  .  *  .  *  *  \"  ,     \"  . testing . testing \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  .  *  *  .  *  \"  ,     \"  . testing . testing \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  . bla .  *  *  . bla \"  ,     \"  . bla . testing . testing . bla \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  . bla .  *  *  . bla \"  ,     \"  . bla . testing . testing . bla . bla \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  .  *  *  . test \"  ,     \"  . bla . bla . test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  . bla .  *  *  .  *  *  . bla \"  ,     \"  . bla . bla . bla . bla . bla . bla \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  . bla * bla . test \"  ,     \"  . blaXXXbla . test \"  )  )  ;", "assertTrue ( pathMatcher . match (  \"  .  * bla . test \"  ,     \"  . XXXbla . test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  . bla * bla . test \"  ,     \"  . blaXXXbl . test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  .  * bla . test \"  ,     \" XXXblab . test \"  )  )  ;", "assertFalse ( pathMatcher . match (  \"  .  * bla . test \"  ,     \" XXXbl . test \"  )  )  ;", "}", "METHOD_END"], "methodName": ["uniqueDeliminator"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( pathMatcher . matchStart (  \" test \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  / test \"  ,     \"  / test \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \"  / test . jpg \"  ,     \" test . jpg \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" test \"  ,     \"  / test \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \"  / test \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" t ? st \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  ?  ? st \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" tes ?  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" te ?  ?  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  ? es ?  \"  ,     \" test \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" tes ?  \"  ,     \" tes \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" tes ?  \"  ,     \" testt \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" tes ?  \"  ,     \" tsst \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  *  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test *  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test *  \"  ,     \" testTest \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test /  *  \"  ,     \" test / Test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test /  *  \"  ,     \" test / t \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test /  *  \"  ,     \" test /  \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  * test *  \"  ,     \" AnothertestTest \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  * test \"  ,     \" Anothertest \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  *  .  *  \"  ,     \" test .  \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  *  .  *  \"  ,     \" test . test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  *  .  *  \"  ,     \" test . test . test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test * aaa \"  ,     \" testblaaaa \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" test *  \"  ,     \" tst \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" test *  \"  ,     \" test /  \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" test *  \"  ,     \" tsttest \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" test *  \"  ,     \" test /  \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" test *  \"  ,     \" test / t \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test /  *  \"  ,     \" test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test / t *  . txt \"  ,     \" test \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \"  * test *  \"  ,     \" tsttst \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \"  * test \"  ,     \" tsttst \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \"  *  .  *  \"  ,     \" tsttst \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" test * aaa \"  ,     \" test \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \" test * aaa \"  ,     \" testblaaab \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  ?  \"  ,     \"  / a \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  ?  / a \"  ,     \"  / a / a \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  / a /  ?  \"  ,     \"  / a / b \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  ?  ?  / a \"  ,     \"  / aa / a \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  / a /  ?  ?  \"  ,     \"  / a / bb \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  ?  \"  ,     \"  / a \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  *  *  \"  ,     \"  / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  *  /  *  *  \"  ,     \"  / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  *  *  /  *  \"  ,     \"  / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test *  /  *  *  \"  ,     \" test /  \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \" test *  /  *  *  \"  ,     \" test / t \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  / bla /  *  *  / bla \"  ,     \"  / bla / testing / testing / bla \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  / bla /  *  *  / bla \"  ,     \"  / bla / testing / testing / bla / bla \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  *  *  / test \"  ,     \"  / bla / bla / test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  / bla /  *  *  /  *  *  / bla \"  ,     \"  / bla / bla / bla / bla / bla / bla \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  / bla * bla / test \"  ,     \"  / blaXXXbla / test \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  * bla / test \"  ,     \"  / XXXbla / test \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \"  / bla * bla / test \"  ,     \"  / blaXXXbl / test \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \"  /  * bla / test \"  ,     \" XXXblab / test \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \"  /  * bla / test \"  ,     \" XXXbl / test \"  )  )  ;", "assertFalse ( pathMatcher . matchStart (  \"  /  ?  ?  ?  ?  \"  ,     \"  / bala / bla \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  *  *  /  * bla \"  ,     \"  / bla / bla / bla / bbb \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  * bla *  /  *  *  / bla /  *  *  \"  ,     \"  / XXXblaXXXX / testing / testing / bla / testing / testing /  \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  * bla *  /  *  *  / bla /  *  \"  ,     \"  / XXXblaXXXX / testing / testing / bla / testing \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  * bla *  /  *  *  / bla /  *  *  \"  ,     \"  / XXXblaXXXX / testing / testing / bla / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  /  * bla *  /  *  *  / bla /  *  *  \"  ,     \"  / XXXblaXXXX / testing / testing / bla / testing / testing . jpg \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  * bla *  /  *  *  / bla /  *  *  \"  ,     \" XXXblaXXXX / testing / testing / bla / testing / testing /  \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  * bla *  /  *  *  / bla /  *  \"  ,     \" XXXblaXXXX / testing / testing / bla / testing \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  * bla *  /  *  *  / bla /  *  *  \"  ,     \" XXXblaXXXX / testing / testing / bla / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  * bla *  /  *  *  / bla /  *  \"  ,     \" XXXblaXXXX / testing / testing / bla / testing / testing \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  / x / x /  *  *  / bla \"  ,     \"  / x / x / x /  \"  )  )  ;", "assertTrue ( pathMatcher . matchStart (  \"  \"  ,     \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withMatchStart"], "fileName": "org.springframework.util.AntPathMatcherTests"}, {"methodBody": ["METHOD_START", "{", "String   result    =     \"  \"  ;", "boolean   defaultMessage    =    true ;", "if    ( StringUtils . hasLength ( msg )  )     {", "if    (  . endsWithSeparator ( msg )  )     {", "result    =    msg    +     \"     \"  ;", "} else    {", "result    =     . messageWithTypeName ( msg ,    subType )  ;", "defaultMessage    =    false ;", "}", "}", "if    ( defaultMessage )     {", "result    =    result    +     (  ( subType    +     \"    is   not   assignable   to    \"  )     +    superType )  ;", "}", "throw   new   IllegalArgumentException ( result )  ;", "}", "METHOD_END"], "methodName": ["assignableCheckFailed"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . doesNotContain ( textToSearch ,    substring ,     (  )     -  >     (  \"  [ Assertion   failed ]     -    this   String   argument   must   not   contain   the   substring    [  \"     +    substring )     +     \"  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContain"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( StringUtils . hasLength ( textToSearch )  )     &  &     ( StringUtils . hasLength ( substring )  )  )     &  &     ( textToSearch . contains ( substring )  )  )     {", "throw   new   IllegalArgumentException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotContain"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( StringUtils . hasLength ( textToSearch )  )     &  &     ( StringUtils . hasLength ( substring )  )  )     &  &     ( textToSearch . contains ( substring )  )  )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotContain"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( msg . endsWith (  \"  :  \"  )  )     |  |     ( msg . endsWith (  \"  ;  \"  )  )  )     |  |     ( msg . endsWith (  \"  ,  \"  )  )  )     |  |     ( msg . endsWith (  \"  .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["endsWithSeparator"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength ( text ,     \"  [ Assertion   failed ]     -    this   String   argument   must   have   length ;    it   must   not   be   null   or   empty \"  )  ;", "}", "METHOD_END"], "methodName": ["hasLength"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( text )  )  )     {", "throw   new   IllegalArgumentException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["hasLength"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( text )  )  )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["hasLength"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( text ,     \"  [ Assertion   failed ]     -    this   String   argument   must   have   text ;    it   must   not   be   null ,    empty ,    or   blank \"  )  ;", "}", "METHOD_END"], "methodName": ["hasText"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasText ( text )  )  )     {", "throw   new   IllegalArgumentException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["hasText"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasText ( text )  )  )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["hasText"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "String   className    =     ( obj    !  =    null )     ?    obj . getClass (  )  . getName (  )     :     \" null \"  ;", "String   result    =     \"  \"  ;", "boolean   defaultMessage    =    true ;", "if    ( StringUtils . hasLength ( msg )  )     {", "if    (  . endsWithSeparator ( msg )  )     {", "result    =    msg    +     \"     \"  ;", "} else    {", "result    =     . messageWithTypeName ( msg ,    className )  ;", "defaultMessage    =    false ;", "}", "}", "if    ( defaultMessage )     {", "result    =    result    +     (  (  (  \" Object   of   class    [  \"     +    className )     +     \"  ]    must   be   an   instance   of    \"  )     +    type )  ;", "}", "throw   new   IllegalArgumentException ( result )  ;", "}", "METHOD_END"], "methodName": ["instanceCheckFailed"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . isAssignable ( superType ,    subType ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignable"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( superType ,     \" Super   type   to   check   against   must   not   be   null \"  )  ;", "if    (  ( subType    =  =    null )     |  |     (  !  ( superType . isAssignableFrom ( subType )  )  )  )     {", "Assert . assignableCheckFailed ( superType ,    subType ,    message )  ;", "}", "}", "METHOD_END"], "methodName": ["isAssignable"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( superType ,     \" Super   type   to   check   against   must   not   be   null \"  )  ;", "if    (  ( subType    =  =    null )     |  |     (  !  ( superType . isAssignableFrom ( subType )  )  )  )     {", "Assert . assignableCheckFailed ( superType ,    subType ,    Assert . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isAssignable"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( type ,    obj ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOf"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( type ,     \" Type   to   check   against   must   not   be   null \"  )  ;", "if    (  !  ( type . isInstance ( obj )  )  )     {", "Assert . instanceCheckFailed ( type ,    obj ,    message )  ;", "}", "}", "METHOD_END"], "methodName": ["isInstanceOf"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( type ,     \" Type   to   check   against   must   not   be   null \"  )  ;", "if    (  !  ( type . isInstance ( obj )  )  )     {", "Assert . instanceCheckFailed ( type ,    obj ,    Assert . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isInstanceOf"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . isNull ( object ,     \"  [ Assertion   failed ]     -    the   object   argument   must   be   null \"  )  ;", "}", "METHOD_END"], "methodName": ["isNull"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( object    !  =    null )     {", "throw   new   IllegalAumentException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["isNull"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( object    !  =    null )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isNull"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue ( expression ,     \"  [ Assertion   failed ]     -    this   expression   must   be   true \"  )  ;", "}", "METHOD_END"], "methodName": ["isTrue"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  ! expression )     {", "throw   new   IllegalArgumentException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["isTrue"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  ! expression )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isTrue"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "return    ( msg    +     ( msg . endsWith (  \"     \"  )     ?     \"  \"     :     \"  :     \"  )  )     +    typeName ;", "}", "METHOD_END"], "methodName": ["messageWithTypeName"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . noNullElements ( array ,     \"  [ Assertion   failed ]     -    this   array   must   not   contain   any   null   elements \"  )  ;", "}", "METHOD_END"], "methodName": ["noNullElements"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( array    !  =    null )     {", "for    ( Object   element    :    array )     {", "if    ( element    =  =    null )     {", "throw   new   IllegalArgumentException ( message )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["noNullElements"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( array    !  =    null )     {", "for    ( Object   element    :    array )     {", "if    ( element    =  =    null )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["noNullElements"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( array ,     \"  [ Assertion   failed ]     -    this   array   must   not   be   empty :    it   must   contain   at   least    1    element \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmpty"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( array )  )     {", "throw   new   IllegalArgumentException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["notEmpty"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( array )  )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["notEmpty"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( collection ,     \"  [ Assertion   failed ]     -    this   collection   must   not   be   empty :    it   must   contain   at   least    1    element \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmpty"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( collection )  )     {", "throw   new   IllegalArgumentException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["notEmpty"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( collection )  )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["notEmpty"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( map ,     \"  [ Assertion   failed ]     -    this   map   must   not   be   empty ;    it   must   contain   at   least   one   entry \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmpty"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( map )  )     {", "throw   new   IllegalArgumentException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["notEmpty"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( map )  )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["notEmpty"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( object ,     \"  [ Assertion   failed ]     -    this   argument   is   required ;    it   must   not   be   null \"  )  ;", "}", "METHOD_END"], "methodName": ["notNull"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )     {", "throw   new   IllegalAumentException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["notNull"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )     {", "throw   new   IllegalArgumentException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["notNull"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "return   messageSupplier    !  =    null    ?    messageSupplier . get (  )     :    null ;", "}", "METHOD_END"], "methodName": ["nullSafeGet"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( expression ,     \"  [ Assertion   failed ]     -    this   state   invariant   must   be   true \"  )  ;", "}", "METHOD_END"], "methodName": ["state"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  ! expression )     {", "throw   new   IllegalStateException ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["state"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "if    (  ! expression )     {", "throw   new   IllegalStateException (  . nullSafeGet ( messageSupplier )  )  ;", "}", "}", "METHOD_END"], "methodName": ["state"], "fileName": "org.springframework.util.Assert"}, {"methodBody": ["METHOD_START", "{", "Assert . doesNotContain (  \" A   cool   chick ' s   name   is   Brod .  \"  ,     \"  \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithEmptySubstring"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . doesNotContain (  \" foo \"  ,     \" bar \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". doesNotContain (  \"  1  2  3  4  \"  ,     \"  2  3  \"  ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . doesNotContain ( null ,     \" rod \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithNullSearchString"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . doesNotContain ( null ,     \" bar \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithNullSearchStringAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . doesNotContain ( null ,    null ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithNullSearchStringAndNullSubstring"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . doesNotContain ( null ,    null ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithNullSearchStringAndNullSubstringAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . doesNotContain (  \" A   cool   chick ' s   name   is   Brod .  \"  ,    null ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithNullSubstring"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . doesNotContain (  \" foo \"  ,    null ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithNullSubstringAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". doesNotContain (  \"  1  2  3  4  \"  ,     \"  2  3  \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotContainWithSubstringPresentInSearchStringAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength (  \" I   Heart    .  .  .  \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasLength"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasLength (  \"  \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasLengthWithEmptyString"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasLength (  \"  \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasLengthWithEmptyStringAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength (  \" foo \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasLengthWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasLength ( null ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasLengthWithNull"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasLength ( null ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasLengthWithNullAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". hasLength ( null ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasLengthWithNullAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength (  \"  \\ t       \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasLengthWithWhitespaceOnly"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength (  \"  \\ t \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasLengthWithWhitespaceOnlyAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText (  \" foo \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasText"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasText (  \"  \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasTextWithEmptyString"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasText (  \"  \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasTextWithEmptyStringAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText (  \" foo \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasTextWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasText ( null ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasTextWithNull"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasText ( null ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasTextWithNullAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". hasText ( null ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasTextWithNullAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasText (  \"  \\ t    \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasTextWithWhitespaceOnly"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". hasText (  \"  \\ t    \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["hasTextWithWhitespaceOnlyAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . isAssignable ( Number . class ,    Integer . class ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignable"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . isAssignable ( Number . class ,    Integer . class ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma :    null \"  )  ;", ". isAssignable ( Integer . class ,    null ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithNullSubtype"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma :    null \"  )  ;", ". isAssignable ( Integer . class ,    null ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithNullSubtypeAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Super   type   to   check   against   must   not   be   null \"  )  ;", ". isAssignable ( null ,    Integer . class ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithNullSupertype"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Super   type   to   check   against   must   not   be   null \"  )  ;", ". isAssignable ( null ,    Integer . class ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithNullSupertypeAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Custom   message :    class   Integer \"  )  ;", ". isAssignable ( String . class ,    Integer . class ,     \" Custom   message \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithTypeMismatchAndCustomMessage"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Custom   message :    class   String \"  )  ;", ". isAssignable ( String . class ,    Integer . class ,     \" Custom   message :  \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithTypeMismatchAndCustomMessageWithSeparator"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Custom   message   for   class   Integer \"  )  ;", ". isAssignable ( String . class ,    Integer . class ,     \" Custom   message   for    \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithTypeMismatchAndCustomMessageWithSpace"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma :    class   Integer \"  )  ;", ". isAssignable ( String . class ,    Integer . class ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithTypeMismatchAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" class   String \"  )  ;", ". isAssignable ( String . class ,    Integer . class ,     (  ( String )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithTypeMismatchAndNullMessage"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" class   String \"  )  ;", ". isAssignable ( String . class ,    Integer . class ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableWithTypeMismatchAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( String . class ,     \" foo \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOf"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . isInstanceOf ( String . class ,     \" foo \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma :    null \"  )  ;", ". isInstanceOf ( String . class ,    null ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithNullInstance"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma :    null \"  )  ;", ". isInstanceOf ( String . class ,    null ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithNullInstanceAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Type   to   check   against   must   not   be   null \"  )  ;", ". isInstanceOf ( null ,     \" foo \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithNullType"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Type   to   check   against   must   not   be   null \"  )  ;", ". isInstanceOf ( null ,     \" foo \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithNullTypeAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Custom   message :    Long \"  )  ;", ". isInstanceOf ( String . class ,     4  2 L ,     \" Custom   message \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithTypeMismatchAndCustomMessage"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Custom   message :    Object   of   class    [ Long ]    must   be   an   instance   of   class   String \"  )  ;", ". isInstanceOf ( String . class ,     4  2 L ,     \" Custom   message :  \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithTypeMismatchAndCustomMessageWithSeparator"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Custom   message   for   Long \"  )  ;", ". isInstanceOf ( String . class ,     4  2 L ,     \" Custom   message   for    \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithTypeMismatchAndCustomMessageWithSpace"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma :    Long \"  )  ;", ". isInstanceOf ( String . class ,     4  2 L ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithTypeMismatchAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Object   of   class    [ Long ]    must   be   an   instance   of   class   String \"  )  ;", ". isInstanceOf ( String . class ,     4  2 L ,     (  ( String )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithTypeMismatchAndNullMessage"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Object   of   class    [ Long ]    must   be   an   instance   of   class   String \"  )  ;", ". isInstanceOf ( String . class ,     4  2 L ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["isInstanceOfWithTypeMismatchAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . isNull ( null ,     \" Bla \"  )  ;", "}", "METHOD_END"], "methodName": ["isNullWithMessage"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . isNull ( null ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isNullWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". isNull (  \" foo \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isNullWithNonNullObjectAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". isNull (  \" foo \"  ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["isNullWithNonNullObjectAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". isTrue ( false ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isTrueWithFalse"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". isTrue ( false ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isTrueWithFalseAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". isTrue ( false ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["isTrueWithFalseAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue ( true ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isTrueWithMessage"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue ( true ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["isTrueWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . noNullElements ( new   String [  ]  {     \"  1  2  3  4  \"     }  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["noNullElements"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . noNullElements ( new   String [  ]  {        }  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["noNullElementsWithEmptyArray"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . noNullElements ( new   String [  ]  {        }  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["noNullElementsWithEmptyArrayAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . noNullElements ( new   String [  ]  {     \"  1  2  3  4  \"     }  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["noNullElementsWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . noNullElements (  (  ( Object [  ]  )     ( null )  )  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["noNullElementsWithNullArrayAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". noNullElements ( new   String [  ]  {     \" foo \"  ,    null ,     \" bar \"     }  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["noNullElementsWithNullElementsAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". noNullElements ( new   String [  ]  {     \" foo \"  ,    null ,     \" bar \"     }  ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["noNullElementsWithNullElementsAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( new   String [  ]  {     \"  1  2  3  4  \"     }  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyArray"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty ( new   String [  ]  {        }  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyArrayWithEmptyArray"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty ( new   String [  ]  {        }  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyArrayWithEmptyArrayAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". notEmpty ( new   String [  ]  {        }  ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyArrayWithEmptyArrayAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( new   String [  ]  {     \"  1  2  3  4  \"     }  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyArrayWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty (  (  ( Object [  ]  )     ( null )  )  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyArrayWithNullArray"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty (  (  ( Object [  ]  )     ( null )  )  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyArrayWithNullArrayAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( Collections . singletonList (  \" foo \"  )  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyCollection"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty ( Collections . emptyList (  )  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyCollectionWithEmptyCollection"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty ( Collections . emptyList (  )  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyCollectionWithEmptyCollectionAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". notEmpty ( Collections . emptyList (  )  ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyCollectionWithEmptyCollectionAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( Collections . singletonList (  \" foo \"  )  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyCollectionWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty (  (  ( Collection <  ?  >  )     ( null )  )  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyCollectionWithNullCollection"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty (  (  ( Collection <  ?  >  )     ( null )  )  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyCollectionWithNullCollectionAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyMap"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty ( Collections . emptyMap (  )  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyMapWithEmptyMap"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty ( Collections . emptyMap (  )  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyMapWithEmptyMapAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". notEmpty ( Collections . emptyMap (  )  ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyMapWithEmptyMapAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyMapWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty (  (  ( Map <  ?  ,     ?  >  )     ( null )  )  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyMapWithNullMap"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notEmpty (  (  ( Map <  ?  ,     ?  >  )     ( null )  )  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notEmptyMapWithNullMapAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull (  \" foo \"  ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notNullWithMessage"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull (  \" foo \"  ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notNullWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". notNull ( null ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["notNullWithNullAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". notNull ( null ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["notNullWithNullAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( true ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["state"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalStateException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". state ( false ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["stateWithFalseExpression"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalStateException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". state ( false ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["stateWithFalseExpressionAndMessage"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalStateException . class )  ;", "thrown . expectMessage (  \" enigma \"  )  ;", ". state ( false ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["stateWithFalseExpressionAndMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalStateException . class )  ;", "thrown . expectMessage ( equalTo ( null )  )  ;", ". state ( false ,     (  ( Supplier < String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["stateWithFalseExpressionAndNullMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( true ,     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["stateWithMessage"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( true ,     (  )     -  >     \" enigma \"  )  ;", "}", "METHOD_END"], "methodName": ["stateWithMessageSupplier"], "fileName": "org.springframework.util.AssertTests"}, {"methodBody": ["METHOD_START", "{", "Object   lastElement    =    null ;", "for    ( int   x    =     0  ;    x    <     1  0  ;    x +  +  )     {", "Object   element    =    list . get ( x )  ;", "assertNotNull (  \" Element   is   null \"  ,    list . get ( x )  )  ;", "assertTrue (  \" Element   is   incorrect   type \"  ,     ( element   instanceof   Object )  )  ;", "assertNotSame ( lastElement ,    element )  ;", "lastElement    =    element ;", "}", "String   helloWorld    =     \" Hello   World !  \"  ;", "list . add (  1  0  ,    null )  ;", "list . add (  1  1  ,    helloWorld )  ;", "assertEquals ( helloWorld ,    list . get (  1  1  )  )  ;", "assertTrue (  (  ( list . get (  1  0  )  )    instanceof   Object )  )  ;", "assertTrue (  (  ( list . get (  1  2  )  )    instanceof   Object )  )  ;", "assertTrue (  (  ( list . get (  1  3  )  )    instanceof   Object )  )  ;", "assertTrue (  (  ( list . get (  2  0  )  )    instanceof   Object )  )  ;", "}", "METHOD_END"], "methodName": ["doTestWithClass"], "fileName": "org.springframework.util.AutoPopulatingListTests"}, {"methodBody": ["METHOD_START", "{", "doTestWithClass ( list )  ;", "for    ( int   x    =     0  ;    x    <     ( list . size (  )  )  ;    x +  +  )     {", "Object   element    =    list . get ( x )  ;", "if    ( element   instanceof   TestObject )     {", "assertEquals ( x ,     (  ( TestObject )     ( element )  )  . getAge (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doTestWithElementFactory"], "fileName": "org.springframework.util.AutoPopulatingListTests"}, {"methodBody": ["METHOD_START", "{", "AutoPopulatingList <  ?  >    list    =    new   AutoPopulatingList < Object >  ( TestObject . class )  ;", "assertEquals ( list ,    SerializationTestUtils . serializeAndDeserialize ( list )  )  ;", "}", "METHOD_END"], "methodName": ["serialization"], "fileName": "org.springframework.util.AutoPopulatingListTests"}, {"methodBody": ["METHOD_START", "{", "doTestWithClass ( new   AutoPopulatingList <  >  ( TestObject . class )  )  ;", "}", "METHOD_END"], "methodName": ["withClass"], "fileName": "org.springframework.util.AutoPopulatingListTests"}, {"methodBody": ["METHOD_START", "{", "doTestWithClass ( new   AutoPopulatingList < Object >  ( new   LinkedList <  >  (  )  ,    TestObject . class )  )  ;", "}", "METHOD_END"], "methodName": ["withClassAndUserSuppliedBackingList"], "fileName": "org.springframework.util.AutoPopulatingListTests"}, {"methodBody": ["METHOD_START", "{", "doTestWithElementFactory ( new   AutoPopulatingList <  >  ( new   AutoPopulatingListTests . MockElementFactory (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withElementFactory"], "fileName": "org.springframework.util.AutoPopulatingListTests"}, {"methodBody": ["METHOD_START", "{", "doTestWithElementFactory ( new   AutoPopulatingList < Object >  ( new   LinkedList <  >  (  )  ,    new   AutoPopulatingListTests . MockElementFactory (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withElementFactoryAndUserSuppliedBackingList"], "fileName": "org.springframework.util.AutoPopulatingListTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( src . length )     =  =     0  )     {", "return   src ;", "}", "return    . getDecoder (  )  . decode ( src )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.util.Base64Utils"}, {"methodBody": ["METHOD_START", "{", "if    ( src . isEmpty (  )  )     {", "return   new   byte [  0  ]  ;", "}", "return    . decode ( src . getBytes (  . DEFAULT _ CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["decodeFromString"], "fileName": "org.springframework.util.Base64Utils"}, {"methodBody": ["METHOD_START", "{", "return   Base 6  4 Utils . decodeUrlSafe ( src . getBytes ( Base 6  4 Utils . DEFAULT _ CHARSET )  )  ;", "}", "METHOD_END"], "methodName": ["decodeFromUrlSafeString"], "fileName": "org.springframework.util.Base64Utils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( src . length )     =  =     0  )     {", "return   src ;", "}", "return    . getUrlDecoder (  )  . decode ( src )  ;", "}", "METHOD_END"], "methodName": ["decodeUrlSafe"], "fileName": "org.springframework.util.Base64Utils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( src . length )     =  =     0  )     {", "return   src ;", "}", "return    . getEncoder (  )  . encode ( src )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.util.Base64Utils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( src . length )     =  =     0  )     {", "return    \"  \"  ;", "}", "return   new   String (  . encode ( src )  ,     . DEFAULT _ CHARSET )  ;", "}", "METHOD_END"], "methodName": ["encodeToString"], "fileName": "org.springframework.util.Base64Utils"}, {"methodBody": ["METHOD_START", "{", "return   new   String ( Base 6  4 Utils . encodeUrlSafe ( src )  ,    Base 6  4 Utils . DEFAULT _ CHARSET )  ;", "}", "METHOD_END"], "methodName": ["encodeToUrlSafeString"], "fileName": "org.springframework.util.Base64Utils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( src . length )     =  =     0  )     {", "return   src ;", "}", "return    . getUrlEncoder (  )  . encode ( src )  ;", "}", "METHOD_END"], "methodName": ["encodeUrlSafe"], "fileName": "org.springframework.util.Base64Utils"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  ]  {     -  7  9  ,     1  0  ,     -  1  1  5  ,     -  7  9  ,     1  0  0  ,     -  3  2  ,     1  1  7  ,     6  5  ,     5  ,     -  7  3  ,     -  8  7  ,     -  1  0  1  ,     -  2  5  ,     4  6  ,     6  3  ,     -  2  7     }  ;", "assertArrayEquals ( bytes ,     . decode (  . encode ( bytes )  )  )  ;", "bytes    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "assertArrayEquals ( bytes ,     . decode (  . encode ( bytes )  )  )  ;", "bytes    =     \" Hello   World \\ r \\ nSecond   Line \"  . getBytes (  \" UTF -  8  \"  )  ;", "assertArrayEquals ( bytes ,     . decode (  . encode ( bytes )  )  )  ;", "bytes    =     \" Hello   World \\ r \\ nSecond   Line \\ r \\ n \"  . getBytes (  \" UTF -  8  \"  )  ;", "assertArrayEquals ( bytes ,     . decode (  . encode ( bytes )  )  )  ;", "bytes    =    new   byte [  ]  {     (  ( byte )     (  2  5  1  )  )  ,     (  ( byte )     (  2  4  0  )  )     }  ;", "assertArrayEquals (  \"  +  / A =  \"  . getBytes (  )  ,     . encode ( bytes )  )  ;", "assertArrayEquals ( bytes ,     . decode (  . encode ( bytes )  )  )  ;", "assertArrayEquals (  \"  -  _ A =  \"  . getBytes (  )  ,     . encodeUrlSafe ( bytes )  )  ;", "assertArrayEquals ( bytes ,     . decodeUrlSafe (  . encodeUrlSafe ( bytes )  )  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.util.Base64UtilsTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  ]  {     (  ( byte )     (  2  5  1  )  )  ,     (  ( byte )     (  2  4  0  )  )     }  ;", "assertArrayEquals (  \"  -  _ A =  \"  . getBytes (  )  ,     . encodeUrlSafe ( bytes )  )  ;", "assertArrayEquals ( bytes ,     . decodeUrlSafe (  . encodeUrlSafe ( bytes )  )  )  ;", "assertEquals (  \"  -  _ A =  \"  ,     . encodeToUrlSafeString ( bytes )  )  ;", "assertArrayEquals ( bytes ,     . decodeFromUrlSafeString (  . encodeToUrlSafeString ( bytes )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeDecodeUrlSafe"], "fileName": "org.springframework.util.Base64UtilsTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [  ]  {     -  7  9  ,     1  0  ,     -  1  1  5  ,     -  7  9  ,     1  0  0  ,     -  3  2  ,     1  1  7  ,     6  5  ,     5  ,     -  7  3  ,     -  8  7  ,     -  1  0  1  ,     -  2  5  ,     4  6  ,     6  3  ,     -  2  7     }  ;", "assertEquals (  . encodeToString ( bytes )  ,    DatatypeConverter . printBase 6  4 Binary ( bytes )  )  ;", "assertArrayEquals ( bytes ,     . decodeFromString (  . encodeToString ( bytes )  )  )  ;", "assertArrayEquals ( bytes ,    DatatypeConverter . parseBase 6  4 Binary ( DatatypeConverter . printBase 6  4 Binary ( bytes )  )  )  ;", "bytes    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "assertEquals (  . encodeToString ( bytes )  ,    DatatypeConverter . printBase 6  4 Binary ( bytes )  )  ;", "assertArrayEquals ( bytes ,     . decodeFromString (  . encodeToString ( bytes )  )  )  ;", "assertArrayEquals ( bytes ,    DatatypeConverter . parseBase 6  4 Binary ( DatatypeConverter . printBase 6  4 Binary ( bytes )  )  )  ;", "bytes    =     \" Hello   World \\ r \\ nSecond   Line \"  . getBytes (  \" UTF -  8  \"  )  ;", "assertEquals (  . encodeToString ( bytes )  ,    DatatypeConverter . printBase 6  4 Binary ( bytes )  )  ;", "assertArrayEquals ( bytes ,     . decodeFromString (  . encodeToString ( bytes )  )  )  ;", "assertArrayEquals ( bytes ,    DatatypeConverter . parseBase 6  4 Binary ( DatatypeConverter . printBase 6  4 Binary ( bytes )  )  )  ;", "bytes    =     \" Hello   World \\ r \\ nSecond   Line \\ r \\ n \"  . getBytes (  \" UTF -  8  \"  )  ;", "assertEquals (  . encodeToString ( bytes )  ,    DatatypeConverter . printBase 6  4 Binary ( bytes )  )  ;", "assertArrayEquals ( bytes ,     . decodeFromString (  . encodeToString ( bytes )  )  )  ;", "assertArrayEquals ( bytes ,    DatatypeConverter . parseBase 6  4 Binary ( DatatypeConverter . printBase 6  4 Binary ( bytes )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeToStringWithJdk8VsJaxb"], "fileName": "org.springframework.util.Base64UtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourceName ,     \" Resource   name   must   not   be   null \"  )  ;", "if    (  !  ( resourceName . startsWith (  \"  /  \"  )  )  )     {", "return    (  (  . classPackageAsResourcePath ( clazz )  )     +     '  /  '  )     +    resourceName ;", "}", "return    (  . classPackageAsResourcePath ( clazz )  )     +    resourceName ;", "}", "METHOD_END"], "methodName": ["addResourcePathToPackagePath"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . classNamesToString ( Arrays . asList ( classes )  )  ;", "}", "METHOD_END"], "methodName": ["classNamesToString"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( classes )  )     {", "return    \"  [  ]  \"  ;", "}", "StringBuilder   sb    =    new   StringBuilder (  \"  [  \"  )  ;", "for    ( Iterator < Class <  ?  >  >    it    =    classes . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Class <  ?  >    clazz    =    it . next (  )  ;", "sb . append ( clazz . getName (  )  )  ;", "if    ( it . hasNext (  )  )     {", "sb . append (  \"  ,     \"  )  ;", "}", "}", "sb . append (  \"  ]  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["classNamesToString"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( clazz    =  =    null )     {", "return    \"  \"  ;", "}", "String   className    =    clazz . getName (  )  ;", "int   packageEndIndex    =    className . lastIndexOf (  . PACKAGE _ SEPARATOR )  ;", "if    ( packageEndIndex    =  =     (  -  1  )  )     {", "return    \"  \"  ;", "}", "String   packageName    =    className . substring (  0  ,    packageEndIndex )  ;", "return   packageName . replace (  . PACKAGE _ SEPARATOR ,     . PATH _ SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["classPackageAsResourcePath"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( className ,     \" Class   name   must   not   be   null \"  )  ;", "return   className . replace (  . PACKAGE _ SEPARATOR ,     . PATH _ SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["convertClassNameToResourcePath"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourcePath ,     \" Resource   path   must   not   be   null \"  )  ;", "return   resourcePath . replace (  . PATH _ SEPARATOR ,     . PACKAGE _ SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["convertResourcePathToClassName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( interfaces ,     \" Interfaces   must   not   be   empty \"  )  ;", "return   Proxy . getProxy ( classLoader ,    interfaces )  ;", "}", "METHOD_END"], "methodName": ["createCompositeInterface"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( clazz 1     =  =    null )     {", "return   clazz 2  ;", "}", "if    ( clazz 2     =  =    null )     {", "return   clazz 1  ;", "}", "if    ( clazz 1  . isAssignableFrom ( clazz 2  )  )     {", "return   clazz 1  ;", "}", "if    ( clazz 2  . isAssignableFrom ( clazz 1  )  )     {", "return   clazz 2  ;", "}", "<  ?  >    ancestor    =    clazz 1  ;", "do    {", "ancestor    =    ancestor . getSuperclass (  )  ;", "if    (  ( ancestor    =  =    null )     |  |     (  ( Object . class )     =  =    ancestor )  )     {", "return   null ;", "}", "}    while    (  !  ( ancestor . isAssignableFrom ( clazz 2  )  )     )  ;", "return   ancestor ;", "}", "METHOD_END"], "methodName": ["determineCommonAncestor"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \" Name   must   not   be   null \"  )  ;", "Class <  ?  >    clazz    =     . resolvePrimitiveClassName ( name )  ;", "if    ( clazz    =  =    null )     {", "clazz    =     . commonClassCache . get ( name )  ;", "}", "if    ( clazz    !  =    null )     {", "return   clazz ;", "}", "if    ( name . endsWith (  . ARRAY _ SUFFIX )  )     {", "String   elementClassName    =    name . substring (  0  ,     (  ( name . length (  )  )     -     (  . ARRAY _ SUFFIX . length (  )  )  )  )  ;", "Class <  ?  >    elementClass    =     . forName ( elementClassName ,    classLoader )  ;", "return   Array . newInstance ( elementClass ,     0  )  . getClass (  )  ;", "}", "if    (  ( name . startsWith (  . NON _ PRIMITIVE _ ARRAY _ PREFIX )  )     &  &     ( name . endsWith (  \"  ;  \"  )  )  )     {", "String   elementName    =    name . substring (  . NON _ PRIMITIVE _ ARRAY _ PREFIX . length (  )  ,     (  ( name . length (  )  )     -     1  )  )  ;", "Class <  ?  >    elementClass    =     . forName ( elementName ,    classLoader )  ;", "return   Array . newInstance ( elementClass ,     0  )  . getClass (  )  ;", "}", "if    ( name . startsWith (  . INTERNAL _ ARRAY _ PREFIX )  )     {", "String   elementName    =    name . substring (  . INTERNAL _ ARRAY _ PREFIX . length (  )  )  ;", "Class <  ?  >    elementClass    =     . forName ( elementName ,    classLoader )  ;", "return   Array . newInstance ( elementClass ,     0  )  . getClass (  )  ;", "}", "ClassLoader   clToUse    =    classLoader ;", "if    ( clToUse    =  =    null )     {", "clToUse    =     . getDefaultClassLoader (  )  ;", "}", "try    {", "return   clToUse    !  =    null    ?    clToUse . loadClass ( name )     :    Class . forName ( name )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "int   lastDotIndex    =    name . lastIndexOf (  . PACKAGE _ SEPARATOR )  ;", "if    ( lastDotIndex    !  =     (  -  1  )  )     {", "String   innerClassName    =     (  ( name . substring (  0  ,    lastDotIndex )  )     +     (  . INNER _ CLASS _ SEPARATOR )  )     +     ( name . substring (  ( lastDotIndex    +     1  )  )  )  ;", "try    {", "return   clToUse    !  =    null    ?    clToUse . loadClass ( innerClassName )     :    Class . forName ( innerClassName )  ;", "}    catch    ( ClassNotFoundException   ex 2  )     {", "}", "}", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( instance ,     \" Instance   must   not   be   null \"  )  ;", "return    . getAllInterfacesForClass ( instance . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllInterfaces"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( instance ,     \" Instance   must   not   be   null \"  )  ;", "return    . getAllInterfacesForClassAsSet ( instance . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllInterfacesAsSet"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getAllInterfacesForClass ( clazz ,    null )  ;", "}", "METHOD_END"], "methodName": ["getAllInterfacesForClass"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . toClassArray ( ClassUtils . getAllInterfacesForClassAsSet ( clazz ,    classLoader )  )  ;", "}", "METHOD_END"], "methodName": ["getAllInterfacesForClass"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getAllInterfacesForClassAsSet ( clazz ,    null )  ;", "}", "METHOD_END"], "methodName": ["getAllInterfacesForClassAsSet"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "if    (  ( clazz . isInterface (  )  )     &  &     (  . isVisible ( clazz ,    classLoader )  )  )     {", "return   Collections . singleton ( clazz )  ;", "}", "Set < Class <  ?  >  >    interfaces    =    new   LinkedHashSet <  >  (  )  ;", "Class <  ?  >    current    =    clazz ;", "while    ( current    !  =    null )     {", "Class <  ?  >  [  ]    ifcs    =    current . getInterfaces (  )  ;", "for    ( Class <  ?  >    ifc    :    ifcs )     {", "if    (  . isVisible ( ifc ,    classLoader )  )     {", "interfaces . add ( ifc )  ;", "}", "}", "current    =    current . getSuperclass (  )  ;", "}", "return   interfaces ;", "}", "METHOD_END"], "methodName": ["getAllInterfacesForClassAsSet"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "String   className    =    clazz . getName (  )  ;", "int   lastDotIndex    =    className . lastIndexOf (  . PACKAGE _ SEPARATOR )  ;", "return    ( className . substring (  ( lastDotIndex    +     1  )  )  )     +     (  . CLASS _ FILE _ SUFFIX )  ;", "}", "METHOD_END"], "methodName": ["getClassFileName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "try    {", "return   clazz . getConstructor ( paramTypes )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getConstructorIfAvailable"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   cl    =    null ;", "try    {", "cl    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "}    catch    ( Throwable   ex )     {", "}", "if    ( cl    =  =    null )     {", "cl    =     . class . getClassLoader (  )  ;", "if    ( cl    =  =    null )     {", "try    {", "cl    =    ClassLoader . getSystemClassLoader (  )  ;", "}    catch    ( Throwable   ex )     {", "}", "}", "}", "return   cl ;", "}", "METHOD_END"], "methodName": ["getDefaultClassLoader"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return   null ;", "}", "<  ?  >    clazz    =    value . get (  )  ;", "if    ( Proxy . isProxy ( clazz )  )     {", "StringBuilder   result    =    new   StringBuilder ( clazz . getName (  )  )  ;", "result . append (  \"    implementing    \"  )  ;", "<  ?  >  [  ]    ifcs    =    clazz . getInterfaces (  )  ;", "for    ( int   i    =     0  ;    i    <     ( ifcs . length )  ;    i +  +  )     {", "result . append ( ifcs [ i ]  . getName (  )  )  ;", "if    ( i    <     (  ( ifcs . length )     -     1  )  )     {", "result . append (  '  ,  '  )  ;", "}", "}", "return   result . toString (  )  ;", "} else    {", "return   clazz . getTypeName (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDescriptiveType"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( methodName ,     \" Method   name   must   not   be   null \"  )  ;", "if    ( paramTypes    !  =    null )     {", "try    {", "return   clazz . getMethod ( methodName ,    paramTypes )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   IllegalStateException (  (  \" Expected   method   not   found :     \"     +    ex )  )  ;", "}", "} else    {", "Set < Method >    candidates    =    new   HashSet <  >  (  1  )  ;", "Method [  ]    methods    =    clazz . getMethods (  )  ;", "for    ( Method   method    :    methods )     {", "if    ( methodName . equals ( method . getName (  )  )  )     {", "candidates . add ( method )  ;", "}", "}", "if    (  ( candidates . size (  )  )     =  =     1  )     {", "return   candidates . iterator (  )  . next (  )  ;", "} else", "if    ( candidates . isEmpty (  )  )     {", "throw   new   IllegalStateException (  (  (  (  \" Expected   method   not   found :     \"     +     ( clazz . getName (  )  )  )     +     '  .  '  )     +    methodName )  )  ;", "} else    {", "throw   new   IllegalStateException (  (  (  (  \" No   unique   method   found :     \"     +     ( clazz . getName (  )  )  )     +     '  .  '  )     +    methodName )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( methodName ,     \" Method   name   must   not   be   null \"  )  ;", "int   count    =     0  ;", "Method [  ]    declaredMethods    =    clazz . getDeclaredMethods (  )  ;", "for    ( Method   method    :    declaredMethods )     {", "if    ( methodName . equals ( method . getName (  )  )  )     {", "count +  +  ;", "}", "}", "Class <  ?  >  [  ]    ifcs    =    clazz . getInterfaces (  )  ;", "for    ( Class <  ?  >    ifc    :    ifcs )     {", "count    +  =     . getMethodCountForName ( ifc ,    methodName )  ;", "}", "if    (  ( clazz . getSuperclass (  )  )     !  =    null )     {", "count    +  =     . getMethodCountForName ( clazz . getSuperclass (  )  ,    methodName )  ;", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["getMethodCountForName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( methodName ,     \" Method   name   must   not   be   null \"  )  ;", "if    ( paramTypes    !  =    null )     {", "try    {", "return   clazz . getMethod ( methodName ,    paramTypes )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "return   null ;", "}", "} else    {", "Set < Method >    candidates    =    new   HashSet <  >  (  1  )  ;", "Method [  ]    methods    =    clazz . getMethods (  )  ;", "for    ( Method   method    :    methods )     {", "if    ( methodName . equals ( method . getName (  )  )  )     {", "candidates . add ( method )  ;", "}", "}", "if    (  ( candidates . size (  )  )     =  =     1  )     {", "return   candidates . iterator (  )  . next (  )  ;", "}", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getMethodIfAvailable"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( targetClass    !  =    null )     &  &     ( targetClass    !  =     ( method . getDeclaringClass (  )  )  )  )     &  &     ( ClassUtils . isOverridable ( method ,    targetClass )  )  )     {", "try    {", "if    ( Modifier . isPublic ( method . getModifiers (  )  )  )     {", "try    {", "return   targetClass . getMethod ( method . getName (  )  ,    method . getParameterTypes (  )  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "return   method ;", "}", "} else    {", "Method   specificMethod    =    ReflectionUtils . findMethod ( targetClass ,    method . getName (  )  ,    method . getParameterTypes (  )  )  ;", "return   specificMethod    !  =    null    ?    specificMethod    :    method ;", "}", "}    catch    ( SecurityException   ex )     {", "}", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["getMostSpecificMethod"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "return    . getPackageName ( clazz . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPackageName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( fqClassName ,     \" Class   name   must   not   be   null \"  )  ;", "int   lastDotIndex    =    fqClassName . lastIndexOf (  . PACKAGE _ SEPARATOR )  ;", "return   lastDotIndex    !  =     (  -  1  )     ?    fqClassName . substring (  0  ,    lastDotIndex )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getPackageName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getQualifiedMethodName ( method ,    null )  ;", "}", "METHOD_END"], "methodName": ["getQualifiedMethodName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "return    (  (  ( clazz    !  =    null    ?    clazz    :    method . getDeclaring (  )  )  . getName (  )  )     +     '  .  '  )     +     ( method . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getQualifiedMethodName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "return   clazz . getTypeName (  )  ;", "}", "METHOD_END"], "methodName": ["getQualifiedName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getShortName ( ClassUtils . getQualifiedName ( clazz )  )  ;", "}", "METHOD_END"], "methodName": ["getShortName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength ( className ,     \" Class   name   must   not   be   empty \"  )  ;", "int   lastDotIndex    =    className . lastIndexOf (  . PACKAGE _ SEPARATOR )  ;", "int   nameEndIndex    =    className . indexOf (  . CGLIB _ CLASS _ SEPARATOR )  ;", "if    ( nameEndIndex    =  =     (  -  1  )  )     {", "nameEndIndex    =    className . length (  )  ;", "}", "String   shortName    =    className . substring (  ( lastDotIndex    +     1  )  ,    nameEndIndex )  ;", "shortName    =    shortName . replace (  . INNER _ CLASS _ SEPARATOR ,     . PACKAGE _ SEPARATOR )  ;", "return   shortName ;", "}", "METHOD_END"], "methodName": ["getShortName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "String   shortName    =    ClassUtils . getShortName ( clazz )  ;", "int   dotIndex    =    shortName . lastIndexOf ( ClassUtils . PACKAGE _ SEPARATOR )  ;", "shortName    =     ( dotIndex    !  =     (  -  1  )  )     ?    shortName . substring (  ( dotIndex    +     1  )  )     :    shortName ;", "return   Introspector . decapitalize ( shortName )  ;", "}", "METHOD_END"], "methodName": ["getShortNameAsProperty"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( methodName ,     \" Method   name   must   not   be   null \"  )  ;", "try    {", "Method   method    =    clazz . getMethod ( methodName ,    args )  ;", "return   Modifier . isStatic ( method . getModifiers (  )  )     ?    method    :    null ;", "}    catch    ( NoSuchMethodException   ex )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getStaticMethod"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( clazz . getName (  )  . contains ( ClassUtils . CGLIB _ CLASS _ SEPARATOR )  )     {", "Class <  ?  >    superclass    =    clazz . getSuperclass (  )  ;", "if    (  ( superclass    !  =    null )     &  &     (  ( Object . class )     !  =    superclass )  )     {", "return   superclass ;", "}", "}", "return   clazz ;", "}", "METHOD_END"], "methodName": ["getUserClass"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( instance ,     \" Instance   must   not   be   null \"  )  ;", "return    . getUserClass ( instance . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUserClass"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( methodName ,     \" Method   name   must   not   be   null \"  )  ;", "Method [  ]    declaredMethods    =    clazz . getDeclaredMethods (  )  ;", "for    ( Method   method    :    declaredMethods )     {", "if    ( method . getName (  )  . equals ( methodName )  )     {", "return   true ;", "}", "}", "Class <  ?  >  [  ]    ifcs    =    clazz . getInterfaces (  )  ;", "for    ( Class <  ?  >    ifc    :    ifcs )     {", "if    (  . hasAtLeastOneMethodWithName ( ifc ,    methodName )  )     {", "return   true ;", "}", "}", "return    (  ( clazz . getSuperclass (  )  )     !  =    null )     &  &     (  . hasAtLeastOneMethodWithName ( clazz . getSuperclass (  )  ,    methodName )  )  ;", "}", "METHOD_END"], "methodName": ["hasAtLeastOneMethodWithName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( ClassUtils . getConstructorIfAvailable ( clazz ,    paramTypes )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasConstructor"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( ClassUtils . getMethodIfAvailable ( clazz ,    methodName ,    paramTypes )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasMethod"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lhsType ,     \" Left - hand   side   type   must   not   be   null \"  )  ;", "Assert . notNull ( rhsType ,     \" Right - hand   side   type   must   not   be   null \"  )  ;", "if    ( lhsType . isAssignableFrom ( rhsType )  )     {", "return   true ;", "}", "if    ( lhsType . isPrimitive (  )  )     {", "Class <  ?  >    resolvedPrimitive    =     . primitiveWrapperTypeMap . get ( rhsType )  ;", "if    ( lhsType    =  =    resolvedPrimitive )     {", "return   true ;", "}", "} else    {", "Class <  ?  >    resolvedWrapper    =     . primitiveTypeToWrapperMap . get ( rhsType )  ;", "if    (  ( resolvedWrapper    !  =    null )     &  &     ( lhsType . isAssignableFrom ( resolvedWrapper )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAssignable"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( type ,     \" Type   must   not   be   null \"  )  ;", "return   value    !  =    null    ?     . isAssignable ( type ,    value . getClass (  )  )     :     !  ( type . isPrimitive (  )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableValue"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "try    {", "ClassLoader   target    =    clazz . getClassLoader (  )  ;", "if    (  ( target    =  =    classLoader )     |  |     ( target    =  =    null )  )     {", "return   true ;", "}", "if    ( classLoader    =  =    null )     {", "return   false ;", "}", "ClassLoader   current    =    classLoader ;", "while    ( current    !  =    null )     {", "current    =    current . getParent (  )  ;", "if    ( current    =  =    target )     {", "return   true ;", "}", "}", "while    ( target    !  =    null )     {", "target    =    target . getParent (  )  ;", "if    ( target    =  =    classLoader )     {", "return   false ;", "}", "}", "}    catch    ( SecurityException   ex )     {", "}", "return    ( classLoader    !  =    null )     &  &     (  . isLoadable ( clazz ,    classLoader )  )  ;", "}", "METHOD_END"], "methodName": ["isCacheSafe"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . isCglibProxyClass ( object . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["isCglibProxy"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( clazz    !  =    null )     &  &     ( ClassUtils . isCglibProxyClassName ( clazz . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isCglibProxyClass"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( className    !  =    null )     &  &     ( className . contains ( ClassUtils . CGLIB _ CLASS _ SEPARATOR )  )  ;", "}", "METHOD_END"], "methodName": ["isCglibProxyClassName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   method . getDeclaringClass (  )  . getName (  )  . equals (  \" groovy . lang . GroovyObject \"  )  ;", "}", "METHOD_END"], "methodName": ["isGroovyObjectMethod"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( clazz . isMemberClass (  )  )     &  &     (  !  ( Modifier . isStatic ( clazz . getModifiers (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isInnerClass"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . contains ( ifc )  ;", "}", "METHOD_END"], "methodName": ["isJavaLanguageInterface"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   clazz    =  =     ( classLoader . load ( clazz . getName (  )  )  )  ;", "}    catch    ( NotFoundException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isLoadable"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( Modifier . isPrivate ( method . getModifiers (  )  )  )     {", "return   false ;", "}", "if    (  ( Modifier . isPublic ( method . getModifiers (  )  )  )     |  |     ( Modifier . isProtected ( method . getModifiers (  )  )  )  )     {", "return   true ;", "}", "return    ( targetClass    =  =    null )     |  |     (  . getPackageName ( method . getDeclaringClass (  )  )  . equals (  . getPackageName ( targetClass )  )  )  ;", "}", "METHOD_END"], "methodName": ["isOverridable"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", ". forName ( className ,    classLoader )  ;", "return   true ;", "}    catch    ( Throwable   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isPresent"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "return    ( clazz . isArray (  )  )     &  &     ( clazz . getComponentType (  )  . isPrimitive (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveArray"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "return    ( clazz . isPrimitive (  )  )     |  |     (  . isPrimitiveWrapper ( clazz )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapper"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "return    . primitiveWrapperTypeMap . containsKey ( clazz )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveWrapper"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "return    ( clazz . isArray (  )  )     &  &     (  . isPrimitiveWrapper ( clazz . getComponentType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveWrapperArray"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "return    ( method . isBridge (  )  )     |  |     (  (  !  ( method . isSynthetic (  )  )  )     &  &     (  !  (  . isGroovyObjectMethod ( method )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isUserLevelMethod"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( classLoader    =  =    null )     {", "return   true ;", "}", "try    {", "if    (  ( clazz . getClassLoader (  )  )     =  =    classLoader )     {", "return   true ;", "}", "}    catch    ( SecurityException   ex )     {", "}", "return    . isLoadable ( clazz ,    classLoader )  ;", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( typeName    !  =    null )     &  &     (  ( typeName . equals ( clazz . getTypeName (  )  )  )     |  |     ( typeName . equals ( clazz . getSimpleName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["matchesTypeName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Thread   currentThread    =    Thread . currentThread (  )  ;", "Loader   threadContextLoader    =    currentThread . getContextLoader (  )  ;", "if    (  ( classLoaderToUse    !  =    null )     &  &     (  !  ( classLoaderToUse . equals ( threadContextLoader )  )  )  )     {", "currentThread . setContextLoader ( classLoaderToUse )  ;", "return   threadContextLoader ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["overrideThreadContextClassLoader"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    clazz    :    commonClasses )     {", ". commonClassCache . put ( clazz . getName (  )  ,    clazz )  ;", "}", "}", "METHOD_END"], "methodName": ["registerCommonClasses"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . forName ( className ,    classLoader )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   IllegalArgumentException (  (  (  \" Could   not   find   class    [  \"     +    className )     +     \"  ]  \"  )  ,    ex )  ;", "}    catch    ( LinkageError   err )     {", "throw   new   IllegalArgumentException (  (  (  \" Unresolvable   class   definition   for   class    [  \"     +    className )     +     \"  ]  \"  )  ,    err )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveClassName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    result    =    null ;", "if    (  ( name    !  =    null )     &  &     (  ( name . length (  )  )     <  =     8  )  )     {", "result    =     . primitiveTypeNameMap . get ( name )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["resolvePrimitiveClassName"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "return    ( clazz . isPrimitive (  )  )     &  &     ( clazz    !  =     ( void . class )  )     ?     . primitiveTypeToWrapperMap . get ( clazz )     :    clazz ;", "}", "METHOD_END"], "methodName": ["resolvePrimitiveIfNecessary"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "return   collection . toArray ( new   Class <  ?  >  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["toClassArray"], "fileName": "org.springframework.util.ClassUtils"}, {"methodBody": ["METHOD_START", "{", "ClassUtilsTests . InnerClass . noArgCalled    =    false ;", "ClassUtilsTests . InnerClass . argCalled    =    false ;", "ClassUtilsTests . InnerClass . overloadedCalled    =    false ;", "}", "METHOD_END"], "methodName": ["clearStatics"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   result    =     \" java / lang / reflect / xyzabc . xml \"  ;", "assertEquals ( result ,     . addResourcePathToPackagePath ( Proxy . class ,     \" xyzabc . xml \"  )  )  ;", "assertEquals ( result ,     . addResourcePathToPackagePath ( Proxy . class ,     \"  / xyzabc . xml \"  )  )  ;", "assertEquals (  \" java / lang / reflect / a / b / c / d . xml \"  ,     . addResourcePathToPackagePath ( Proxy . class ,     \" a / b / c / d . xml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddResourcePathToPackagePath"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ClassUtils . getStaticMethod ( ClassUtilsTests . InnerClass . class ,     \" argStaticMethod \"  ,    String . class )  ;", "method . invoke ( null ,     \" test \"  )  ;", "assertTrue (  \" argument   method   was   not   invoked .  \"  ,    ClassUtilsTests . InnerClass . argCalled )  ;", "}", "METHOD_END"], "methodName": ["testArgsStaticMethod"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    ifcs    =    new   LinkedList <  >  (  )  ;", "ifcs . add ( Serializable . class )  ;", "ifcs . add ( Runnable . class )  ;", "assertEquals (  \"  [ interface   Serializable ,    interface   Runnable ]  \"  ,    ifcs . toString (  )  )  ;", "assertEquals (  \"  [ Serializable ,    Runnable ]  \"  ,     . classNamesToString ( ifcs )  )  ;", "List < Class <  ?  >  >    classes    =    new   LinkedList <  >  (  )  ;", "classes . add ( LinkedList . class )  ;", "classes . add ( Integer . class )  ;", "assertEquals (  \"  [ class   LinkedList ,    class   Integer ]  \"  ,    classes . toString (  )  )  ;", "assertEquals (  \"  [ LinkedList ,    Integer ]  \"  ,     . classNamesToString ( classes )  )  ;", "assertEquals (  \"  [ interface   List ]  \"  ,    Collections . singletonList ( List . class )  . toString (  )  )  ;", "assertEquals (  \"  [ List ]  \"  ,     . classNamesToString ( List . class )  )  ;", "assertEquals (  \"  [  ]  \"  ,    Collections . EMPTY _ LIST . toString (  )  )  ;", "assertEquals (  \"  [  ]  \"  ,     . classNamesToString ( Collections . emptyList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassNamesToString"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   result    =    ClassUtils . classPackageAsResourcePath ( Proxy . class )  ;", "assertEquals (  \" java / lang / reflect \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testClassPackageAsResourcePath"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( ClassUtils . hasAtLeastOneMethodWithName ( TestObject . class ,     \" foobar \"  )  )  ;", "assertTrue ( ClassUtils . hasAtLeastOneMethodWithName ( TestObject . class ,     \" hashCode \"  )  )  ;", "assertTrue ( ClassUtils . hasAtLeastOneMethodWithName ( TestObject . class ,     \" setAge \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCountOverloadedMethods"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Number . class ,    ClassUtils . determineCommonAncestor ( Integer . class ,    Number . class )  )  ;", "assertEquals ( Number . class ,    ClassUtils . determineCommonAncestor ( Number . class ,    Integer . class )  )  ;", "assertEquals ( Number . class ,    ClassUtils . determineCommonAncestor ( Number . class ,    null )  )  ;", "assertEquals ( Integer . class ,    ClassUtils . determineCommonAncestor ( null ,    Integer . class )  )  ;", "assertEquals ( Integer . class ,    ClassUtils . determineCommonAncestor ( Integer . class ,    Integer . class )  )  ;", "assertEquals ( Number . class ,    ClassUtils . determineCommonAncestor ( Integer . class ,    Float . class )  )  ;", "assertEquals ( Number . class ,    ClassUtils . determineCommonAncestor ( Float . class ,    Integer . class )  )  ;", "assertNull ( ClassUtils . determineCommonAncestor ( Integer . class ,    String . class )  )  ;", "assertNull ( ClassUtils . determineCommonAncestor ( String . class ,    Integer . class )  )  ;", "assertEquals ( Collection . class ,    ClassUtils . determineCommonAncestor ( List . class ,    Collection . class )  )  ;", "assertEquals ( Collection . class ,    ClassUtils . determineCommonAncestor ( Collection . class ,    List . class )  )  ;", "assertEquals ( Collection . class ,    ClassUtils . determineCommonAncestor ( Collection . class ,    null )  )  ;", "assertEquals ( List . class ,    ClassUtils . determineCommonAncestor ( null ,    List . class )  )  ;", "assertEquals ( List . class ,    ClassUtils . determineCommonAncestor ( List . class ,    List . class )  )  ;", "assertNull ( ClassUtils . determineCommonAncestor ( List . class ,    Set . class )  )  ;", "assertNull ( ClassUtils . determineCommonAncestor ( Set . class ,    List . class )  )  ;", "assertNull ( ClassUtils . determineCommonAncestor ( List . class ,    Runnable . class )  )  ;", "assertNull ( ClassUtils . determineCommonAncestor ( Runnable . class ,    List . class )  )  ;", "assertEquals ( List . class ,    ClassUtils . determineCommonAncestor ( List . class ,    ArrayList . class )  )  ;", "assertEquals ( List . class ,    ClassUtils . determineCommonAncestor ( ArrayList . class ,    List . class )  )  ;", "assertNull ( ClassUtils . determineCommonAncestor ( List . class ,    String . class )  )  ;", "assertNull ( ClassUtils . determineCommonAncestor ( String . class ,    List . class )  )  ;", "}", "METHOD_END"], "methodName": ["testDetermineCommonAncestor"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( String . class ,    ClassUtils . forName (  \" String \"  ,    classLoader )  )  ;", "assertEquals ( String [  ]  . class ,    ClassUtils . forName (  \" String [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( String [  ]  . class ,    ClassUtils . forName ( String [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( String [  ]  [  ]  . class ,    ClassUtils . forName ( String [  ]  [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( String [  ]  [  ]  [  ]  . class ,    ClassUtils . forName ( String [  ]  [  ]  [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( TestObject . class ,    ClassUtils . forName (  \" tests . sample . objects . TestObject \"  ,    classLoader )  )  ;", "assertEquals ( TestObject [  ]  . class ,    ClassUtils . forName (  \" tests . sample . objects . TestObject [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( TestObject [  ]  . class ,    ClassUtils . forName ( TestObject [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( TestObject [  ]  [  ]  . class ,    ClassUtils . forName (  \" tests . sample . objects . TestObject [  ]  [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( TestObject [  ]  [  ]  . class ,    ClassUtils . forName ( TestObject [  ]  [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( short [  ]  [  ]  [  ]  . class ,    ClassUtils . forName (  \"  [  [  [ S \"  ,    classLoader )  )  ;", "}", "METHOD_END"], "methodName": ["testForName"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( boolean [  ]  . class ,    ClassUtils . forName (  \" boolean [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( byte [  ]  . class ,    ClassUtils . forName (  \" byte [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( char [  ]  . class ,    ClassUtils . forName (  \" char [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( short [  ]  . class ,    ClassUtils . forName (  \" short [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( int [  ]  . class ,    ClassUtils . forName (  \" int [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( long [  ]  . class ,    ClassUtils . forName (  \" long [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( float [  ]  . class ,    ClassUtils . forName (  \" float [  ]  \"  ,    classLoader )  )  ;", "assertEquals ( double [  ]  . class ,    ClassUtils . forName (  \" double [  ]  \"  ,    classLoader )  )  ;", "}", "METHOD_END"], "methodName": ["testForNameWithPrimitiveArrays"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( boolean [  ]  . class ,    ClassUtils . forName ( boolean [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( byte [  ]  . class ,    ClassUtils . forName ( byte [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( char [  ]  . class ,    ClassUtils . forName ( char [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( short [  ]  . class ,    ClassUtils . forName ( short [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( int [  ]  . class ,    ClassUtils . forName ( int [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( long [  ]  . class ,    ClassUtils . forName ( long [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( float [  ]  . class ,    ClassUtils . forName ( float [  ]  . class . getName (  )  ,    classLoader )  )  ;", "assertEquals ( double [  ]  . class ,    ClassUtils . forName ( double [  ]  . class . getName (  )  ,    classLoader )  )  ;", "}", "METHOD_END"], "methodName": ["testForNameWithPrimitiveArraysInternalName"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( boolean . class ,    ClassUtils . forName (  \" boolean \"  ,    classLoader )  )  ;", "assertEquals ( byte . class ,    ClassUtils . forName (  \" byte \"  ,    classLoader )  )  ;", "assertEquals ( char . class ,    ClassUtils . forName (  \" char \"  ,    classLoader )  )  ;", "assertEquals ( short . class ,    ClassUtils . forName (  \" short \"  ,    classLoader )  )  ;", "assertEquals ( int . class ,    ClassUtils . forName (  \" int \"  ,    classLoader )  )  ;", "assertEquals ( long . class ,    ClassUtils . forName (  \" long \"  ,    classLoader )  )  ;", "assertEquals ( float . class ,    ClassUtils . forName (  \" float \"  ,    classLoader )  )  ;", "assertEquals ( double . class ,    ClassUtils . forName (  \" double \"  ,    classLoader )  )  ;", "assertEquals ( void . class ,    ClassUtils . forName (  \" void \"  ,    classLoader )  )  ;", "}", "METHOD_END"], "methodName": ["testForNameWithPrimitiveClasses"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DerivedTestObject   testBean    =    new   DerivedTestObject (  )  ;", "List < Class <  ?  >  >    ifcs    =    Arrays . asList (  . getAllInterfaces ( testBean )  )  ;", "assertEquals (  \" Correct   number   of   interfaces \"  ,     4  ,    ifcs . size (  )  )  ;", "assertTrue (  \" Contains   Serializable \"  ,    ifcs . contains ( Serializable . class )  )  ;", "assertTrue (  \" Contains   ITestBean \"  ,    ifcs . contains ( ITestObject . class )  )  ;", "assertTrue (  \" Contains   IOther \"  ,    ifcs . contains ( ITestInterface . class )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAllInterfaces"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" String . class \"  ,    ClassUtils . getClassFileName ( String . class )  )  ;", "assertEquals (  \"  . class \"  ,    ClassUtils . getClassFileName ( getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetClassFileName"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Verifying   number   of   overloaded    ' print '    methods   for   OverloadedMethodsClass .  \"  ,     2  ,    ClassUtils . getMethodCountForName ( ClassUtilsTests . OverloadedMethodsClass . class ,     \" print \"  )  )  ;", "assertEquals (  \" Verifying   number   of   overloaded    ' print '    methods   for   SubOverloadedMethodsClass .  \"  ,     4  ,    ClassUtils . getMethodCountForName ( ClassUtilsTests . SubOverloadedMethodsClass . class ,     \" print \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetMethodCountForName"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ClassUtils . getMethodIfAvailable ( Collection . class ,     \" size \"  )  ;", "assertNotNull ( method )  ;", "assertEquals (  \" size \"  ,    method . getName (  )  )  ;", "method    =    ClassUtils . getMethodIfAvailable ( Collection . class ,     \" remove \"  ,    Object . class )  ;", "assertNotNull ( method )  ;", "assertEquals (  \" remove \"  ,    method . getName (  )  )  ;", "assertNull ( ClassUtils . getMethodIfAvailable ( Collection . class ,     \" remove \"  )  )  ;", "assertNull ( ClassUtils . getMethodIfAvailable ( Collection . class ,     \" someOtherMethod \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetMethodIfAvailable"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" lang \"  ,    ClassUtils . getPackageName ( String . class )  )  ;", "assertEquals ( getClass (  )  . getPackage (  )  . getName (  )  ,    ClassUtils . getPackageName ( getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetPackageName"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getQualifiedName ( getClass (  )  )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \"  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetQualifiedName"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getQualifiedName ( Object [  ]  [  ]  . class )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" Object [  ]  [  ]  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetQualifiedNameForMultiDimensionalObjectArrayClass"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getQualifiedName ( byte [  ]  [  ]  . class )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" byte [  ]  [  ]  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetQualifiedNameForMultiDimensionalPrimitiveArrayClass"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getQualifiedName ( Object [  ]  . class )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" Object [  ]  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetQualifiedNameForObjectArrayClass"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getQualifiedName ( byte [  ]  . class )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" byte [  ]  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetQualifiedNameForPrimitiveArrayClass"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getShortName ( getClass (  )  )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \"  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetShortName"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   shortName    =    ClassUtils . getShortNameAsProperty ( this . getClass (  )  )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" c \"  ,    shortName )  ;", "}", "METHOD_END"], "methodName": ["testGetShortNameAsProperty"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getShortName ( ClassUtilsTests . InnerClass . class )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" ClassUtilsTests . InnerClass \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetShortNameForInnerClass"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getShortName ( Object [  ]  [  ]  . class )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" Object [  ]  [  ]  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetShortNameForMultiDimensionalObjectArrayClass"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getShortName ( byte [  ]  [  ]  [  ]  . class )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" byte [  ]  [  ]  [  ]  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetShortNameForMultiDimensionalPrimitiveArrayClass"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getShortName ( Object [  ]  . class )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" Object [  ]  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetShortNameForObjectArrayClass"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   className    =    ClassUtils . getShortName ( byte [  ]  . class )  ;", "assertEquals (  \" Class   name   did   not   match \"  ,     \" byte [  ]  \"  ,    className )  ;", "}", "METHOD_END"], "methodName": ["testGetShortNameForPrimitiveArrayClass"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . hasMethod ( Collection . class ,     \" size \"  )  )  ;", "assertTrue ( ClassUtils . hasMethod ( Collection . class ,     \" remove \"  ,    Object . class )  )  ;", "assertFalse ( ClassUtils . hasMethod ( Collection . class ,     \" remove \"  )  )  ;", "assertFalse ( ClassUtils . hasMethod ( Collection . class ,     \" someOtherMethod \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHasMethod"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isAssignable ( Object . class ,    Object . class )  )  ;", "assertTrue ( ClassUtils . isAssignable ( String . class ,    String . class )  )  ;", "assertTrue ( ClassUtils . isAssignable ( Object . class ,    String . class )  )  ;", "assertTrue ( ClassUtils . isAssignable ( Object . class ,    Integer . class )  )  ;", "assertTrue ( ClassUtils . isAssignable ( Number . class ,    Integer . class )  )  ;", "assertTrue ( ClassUtils . isAssignable ( Number . class ,    int . class )  )  ;", "assertTrue ( ClassUtils . isAssignable ( Integer . class ,    int . class )  )  ;", "assertTrue ( ClassUtils . isAssignable ( int . class ,    Integer . class )  )  ;", "assertFalse ( ClassUtils . isAssignable ( String . class ,    Object . class )  )  ;", "assertFalse ( ClassUtils . isAssignable ( Integer . class ,    Number . class )  )  ;", "assertFalse ( ClassUtils . isAssignable ( Integer . class ,    double . class )  )  ;", "assertFalse ( ClassUtils . isAssignable ( double . class ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIsAssignable"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   childLoader 1     =    new   ClassLoader ( classLoader )     {  }  ;", "ClassLoader   childLoader 2     =    new   ClassLoader ( classLoader )     {  }  ;", "ClassLoader   childLoader 3     =    new   ClassLoader ( classLoader )     {", "@ Override", "public   Class <  ?  >    loadClass ( String   name )    throws   ClassNotFoundException    {", "return   childLoader 1  . loadClass ( name )  ;", "}", "}  ;", "Class <  ?  >    composite    =    ClassUtils . createCompositeInterface ( new   Class <  ?  >  [  ]  {    Serializable . class ,    Externalizable . class    }  ,    childLoader 1  )  ;", "assertTrue ( ClassUtils . isCacheSafe ( String . class ,    null )  )  ;", "assertTrue ( ClassUtils . isCacheSafe ( String . class ,    classLoader )  )  ;", "assertTrue ( ClassUtils . isCacheSafe ( String . class ,    childLoader 1  )  )  ;", "assertTrue ( ClassUtils . isCacheSafe ( String . class ,    childLoader 2  )  )  ;", "assertTrue ( ClassUtils . isCacheSafe ( String . class ,    childLoader 3  )  )  ;", "assertFalse ( ClassUtils . isCacheSafe (  . InnerClass . class ,    null )  )  ;", "assertTrue ( ClassUtils . isCacheSafe (  . InnerClass . class ,    classLoader )  )  ;", "assertTrue ( ClassUtils . isCacheSafe (  . InnerClass . class ,    childLoader 1  )  )  ;", "assertTrue ( ClassUtils . isCacheSafe (  . InnerClass . class ,    childLoader 2  )  )  ;", "assertTrue ( ClassUtils . isCacheSafe (  . InnerClass . class ,    childLoader 3  )  )  ;", "assertFalse ( ClassUtils . isCacheSafe ( composite ,    null )  )  ;", "assertFalse ( ClassUtils . isCacheSafe ( composite ,    classLoader )  )  ;", "assertTrue ( ClassUtils . isCacheSafe ( composite ,    childLoader 1  )  )  ;", "assertFalse ( ClassUtils . isCacheSafe ( composite ,    childLoader 2  )  )  ;", "assertTrue ( ClassUtils . isCacheSafe ( composite ,    childLoader 3  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsCacheSafe"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPresent (  \" String \"  ,    classLoader )  )  ;", "assertFalse ( ClassUtils . isPresent (  \" MySpecialString \"  ,    classLoader )  )  ;", "}", "METHOD_END"], "methodName": ["testIsPresent"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ClassUtils . getStaticMethod ( ClassUtilsTests . InnerClass . class ,     \" staticMethod \"  )  ;", "method . invoke ( null ,     (  ( Object [  ]  )     ( null )  )  )  ;", "assertTrue (  \" no   argument   method   was   not   invoked .  \"  ,    ClassUtilsTests . InnerClass . noArgCalled )  ;", "}", "METHOD_END"], "methodName": ["testNoArgsStaticMethod"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ClassUtils . getStaticMethod ( ClassUtilsTests . InnerClass . class ,     \" staticMethod \"  ,    String . class )  ;", "method . invoke ( null ,     \" test \"  )  ;", "assertTrue (  \" argument   method   was   not   invoked .  \"  ,    ClassUtilsTests . InnerClass . overloadedCalled )  ;", "}", "METHOD_END"], "methodName": ["testOverloadedStaticMethod"], "fileName": "org.springframework.util.ClassUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( ObjectUtils . toObjectArray ( source )  )  ;", "}", "METHOD_END"], "methodName": ["arrayToList"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( enumeration    !  =    null )     {", "while    ( enumeration . hasMoreElements (  )  )     {", "Object   candidate    =    enumeration . nextElement (  )  ;", "if    ( Object . nullSafeEquals ( candidate ,    element )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( iterator    !  =    null )     {", "while    ( iterator . hasNext (  )  )     {", "Object   candidate    =    iterator . next (  )  ;", "if    ( Object . nullSafeEquals ( candidate ,    element )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( CollectionUtils . isEmpty ( source )  )     |  |     ( CollectionUtils . isEmpty ( candidates )  )  )     {", "return   false ;", "}", "for    ( Object   candidate    :    candidates )     {", "if    ( source . contains ( candidate )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsAny"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( collection    !  =    null )     {", "for    ( Object   candidate    :    collection )     {", "if    ( candidate    =  =    element )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsInstance"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( collection )  )     {", "return   null ;", "}", "Class <  ?  >    candidate    =    null ;", "for    ( Object   val    :    collection )     {", "if    ( val    !  =    null )     {", "if    ( candidate    =  =    null )     {", "candidate    =    val . getClass (  )  ;", "} else", "if    ( candidate    !  =     ( val . getClass (  )  )  )     {", "return   null ;", "}", "}", "}", "return   candidate ;", "}", "METHOD_END"], "methodName": ["findCommonElementType"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( CollectionUtils . isEmpty ( source )  )     |  |     ( CollectionUtils . isEmpty ( candidates )  )  )     {", "return   null ;", "}", "for    ( Object   candidate    :    candidates )     {", "if    ( source . contains ( candidate )  )     {", "return    (  ( E )     ( candidate )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findFirstMatch"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( collection )  )     {", "return   null ;", "}", "T   value    =    null ;", "for    ( Object   element    :    collection )     {", "if    (  ( type    =  =    null )     |  |     ( type . isInstance ( element )  )  )     {", "if    ( value    !  =    null )     {", "return   null ;", "}", "value    =     (  ( T )     ( element )  )  ;", "}", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["findValueOfType"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( CollectionUtils . isEmpty ( collection )  )     |  |     ( ObjectUtils . isEmpty ( types )  )  )     {", "return   null ;", "}", "for    ( Class <  ?  >    type    :    types )     {", "Object   value    =    CollectionUtils . findValueOfType ( collection ,    type )  ;", "if    ( value    !  =    null )     {", "return   value ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findValueOfType"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( collection )  )     {", "return   false ;", "}", "boolean   hasCandidate    =    false ;", "Object   candidate    =    null ;", "for    ( Object   elem    :    collection )     {", "if    (  ! hasCandidate )     {", "hasCandidate    =    true ;", "candidate    =    elem ;", "} else", "if    ( candidate    !  =    elem )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["hasUniqueObject"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( collection    =  =    null )     |  |     ( collection . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( map    =  =    null )     |  |     ( map . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( list )  )     {", "return   null ;", "}", "return   list . get (  (  ( list . size (  )  )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["lastElement"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( set )  )     {", "return   null ;", "}", "if    ( set   instanceof   SortedSet )     {", "return    (  ( SortedSet < T >  )     ( set )  )  . last (  )  ;", "}", "Iterator < T >    it    =    set . iterator (  )  ;", "T   last    =    null ;", "while    ( it . hasNext (  )  )     {", "last    =    it . next (  )  ;", "}", "return   last ;", "}", "METHOD_END"], "methodName": ["lastElement"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    arr    =    ObjectUtils . toObjectArray ( array )  ;", "for    ( Object   elem    :    arr )     {", "c . add (  (  ( E )     ( elem )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeArrayIntoCollection"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( props    !  =    null )     {", "for    ( Enumera <  ?  >    en    =    props . propertyNames (  )  ;    en . hasMoreElements (  )  ;  )     {", "String   key    =     (  ( String )     ( en . nextElement (  )  )  )  ;", "Object   value    =    props . get ( key )  ;", "if    ( value    =  =    null )     {", "value    =    props . getProperty ( key )  ;", "}", "map . put (  (  ( K )     ( key )  )  ,     (  ( V )     ( value )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["mergePropertiesIntoMap"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "ArrayList < A >    elements    =    new   ArrayList <  >  (  )  ;", "while    ( enumera . hasMoreElements (  )  )     {", "elements . add ( enumera . nextElement (  )  )  ;", "}", "return   elements . toArray ( array )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   CollectionUtils . EnumerationIterator <  >  ( enumeration )  ;", "}", "METHOD_END"], "methodName": ["toIterator"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   CollectionUtils . MultiValueMapAdapter <  >  ( map )  ;", "}", "METHOD_END"], "methodName": ["toMultiValueMap"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( map ,     \"  ' map '    must   not   be   null \"  )  ;", "Map < K ,    List < V >  >    result    =    new   LinkedHashMap <  >  ( map . size (  )  )  ;", "map . forEach (  (    key ,    value )     -  >     {", "List <  ?    extends   V >    values    =    Collections . unmodifiableList ( value )  ;", "result . put ( key ,     (  ( List < V >  )     ( values )  )  )  ;", "}  )  ;", "Map < K ,    List < V >  >    unmodifiableMap    =    Collections . unmodifiableMap ( result )  ;", "return    . toMultiValueMap ( unmodifiableMap )  ;", "}", "METHOD_END"], "methodName": ["unmodifiableMultiValueMap"], "fileName": "org.springframework.util.CollectionUtils"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( CollectionUtils . contains (  (  ( Iterator < String >  )     ( null )  )  ,     \" myElement \"  )  )  ;", "assertFalse ( CollectionUtils . contains (  (  ( Enumeration < String >  )     ( null )  )  ,     \" myElement \"  )  )  ;", "assertFalse ( CollectionUtils . contains ( new   LinkedList < String >  (  )  . iterator (  )  ,     \" myElement \"  )  )  ;", "assertFalse ( CollectionUtils . contains ( new   Hashtable < String ,    Object >  (  )  . keys (  )  ,     \" myElement \"  )  )  ;", "List < String >    list    =    new   LinkedList <  >  (  )  ;", "list . add (  \" myElement \"  )  ;", "assertTrue ( CollectionUtils . contains ( list . iterator (  )  ,     \" myElement \"  )  )  ;", "Hashtable < String ,    String >    ht    =    new   Hashtable <  >  (  )  ;", "ht . put (  \" myElement \"  ,     \" myValue \"  )  ;", "assertTrue ( CollectionUtils . contains ( ht . keys (  )  ,     \" myElement \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testContains"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    source    =    new   ArrayList <  >  (  )  ;", "source . add (  \" abc \"  )  ;", "source . add (  \" def \"  )  ;", "source . add (  \" ghi \"  )  ;", "List < String >    candidates    =    new   ArrayList <  >  (  )  ;", "candidates . add (  \" xyz \"  )  ;", "candidates . add (  \" def \"  )  ;", "candidates . add (  \" abc \"  )  ;", "assertTrue (  . containsAny ( source ,    candidates )  )  ;", "candidates . remove (  \" def \"  )  ;", "assertTrue (  . containsAny ( source ,    candidates )  )  ;", "candidates . remove (  \" abc \"  )  ;", "assertFalse (  . containsAny ( source ,    candidates )  )  ;", "}", "METHOD_END"], "methodName": ["testContainsAny"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < CollectionUtilsTests . Instance >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new   CollectionUtilsTests . Instance (  \" fiona \"  )  )  ;", "assertFalse (  \" Must   return   false   if   instance   is   not   in   the   supplied   Collection   argument \"  ,    CollectionUtils . containsInstance ( list ,    new   CollectionUtilsTests . Instance (  \" fiona \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testContainsInstanceWithInstancesThatAreEqualButDistinct"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" Must   return   false   if   supplied   Collection   argument   is   null \"  ,    CollectionUtils . containsInstance ( null ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["testContainsInstanceWithNullCollection"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < CollectionUtilsTests . Instance >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new   CollectionUtilsTests . Instance (  \" apple \"  )  )  ;", "list . add ( new   CollectionUtilsTests . Instance (  \" fiona \"  )  )  ;", "assertFalse (  \" Must   return   false   if   null   instance   is   supplied \"  ,    CollectionUtils . containsInstance ( list ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testContainsInstanceWithNullInstance"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < CollectionUtilsTests . Instance >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new   CollectionUtilsTests . Instance (  \" apple \"  )  )  ;", "CollectionUtilsTests . Instance   instance    =    new   CollectionUtilsTests . Instance (  \" fiona \"  )  ;", "list . add ( instance )  ;", "assertTrue (  \" Must   return   true   if   instance   is   in   the   supplied   Collection   argument \"  ,    CollectionUtils . containsInstance ( list ,    instance )  )  ;", "}", "METHOD_END"], "methodName": ["testContainsInstanceWithSameInstance"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    source    =    new   ArrayList <  >  (  )  ;", "source . add (  \" abc \"  )  ;", "source . add (  \" def \"  )  ;", "source . add (  \" ghi \"  )  ;", "List < String >    candidates    =    new   ArrayList <  >  (  )  ;", "candidates . add (  \" xyz \"  )  ;", "candidates . add (  \" def \"  )  ;", "candidates . add (  \" abc \"  )  ;", "assertEquals (  \" def \"  ,     . findFirstMatch ( source ,    candidates )  )  ;", "}", "METHOD_END"], "methodName": ["testFindFirstMatch"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    new   LinkedList <  >  (  )  ;", "list . add (  \" myElement \"  )  ;", "list . add (  \" myOtherElement \"  )  ;", "assertFalse (  . hasUniqueObject ( list )  )  ;", "list    =    new   LinkedList <  >  (  )  ;", "list . add (  \" myElement \"  )  ;", "assertTrue (  . hasUniqueObject ( list )  )  ;", "list    =    new   LinkedList <  >  (  )  ;", "list . add (  \" myElement \"  )  ;", "list . add ( null )  ;", "assertFalse (  . hasUniqueObject ( list )  )  ;", "list    =    new   LinkedList <  >  (  )  ;", "list . add ( null )  ;", "list . add (  \" myElement \"  )  ;", "assertFalse (  . hasUniqueObject ( list )  )  ;", "list    =    new   LinkedList <  >  (  )  ;", "list . add ( null )  ;", "list . add ( null )  ;", "assertTrue (  . hasUniqueObject ( list )  )  ;", "list    =    new   LinkedList <  >  (  )  ;", "list . add ( null )  ;", "assertTrue (  . hasUniqueObject ( list )  )  ;", "list    =    new   LinkedList <  >  (  )  ;", "assertFalse (  . hasUniqueObject ( list )  )  ;", "}", "METHOD_END"], "methodName": ["testHasUniqueObject"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( CollectionUtils . isEmpty (  (  ( Set < Object >  )     ( null )  )  )  )  ;", "assertTrue ( CollectionUtils . isEmpty (  (  ( Map < String ,    String >  )     ( null )  )  )  )  ;", "assertTrue ( CollectionUtils . isEmpty ( new   HashMap < String ,    String >  (  )  )  )  ;", "assertTrue ( CollectionUtils . isEmpty ( new   HashSet <  >  (  )  )  )  ;", "List < Object >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   Object (  )  )  ;", "assertFalse ( CollectionUtils . isEmpty ( list )  )  ;", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "assertFalse ( CollectionUtils . isEmpty ( map )  )  ;", "}", "METHOD_END"], "methodName": ["testIsEmpty"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    arr    =    new   Object [  ]  {     \" value 1  \"  ,     \" value 2  \"     }  ;", "List < Comparable <  ?  >  >    list    =    new   LinkedList <  >  (  )  ;", "list . add (  \" value 3  \"  )  ;", ". mergeArrayIntoCollection ( arr ,    list )  ;", "assertEquals (  \" value 3  \"  ,    list . get (  0  )  )  ;", "assertEquals (  \" value 1  \"  ,    list . get (  1  )  )  ;", "assertEquals (  \" value 2  \"  ,    list . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testMergeArrayIntoCollection"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int [  ]    arr    =    new   int [  ]  {     1  ,     2     }  ;", "List < Comparable <  ?  >  >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( Integer . valueOf (  3  )  )  ;", ". mergeArrayIntoCollection ( arr ,    list )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    list . get (  0  )  )  ;", "assertEquals ( Integer . valueOf (  1  )  ,    list . get (  1  )  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    list . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testMergePrimitiveArrayIntoCollection"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Properties   defaults    =    new   Properties (  )  ;", "defaults . setProperty (  \" prop 1  \"  ,     \" value 1  \"  )  ;", "Properties   props    =    new   Properties ( defaults )  ;", "props . setProperty (  \" prop 2  \"  ,     \" value 2  \"  )  ;", "props . put (  \" prop 3  \"  ,    Integer . valueOf (  3  )  )  ;", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" prop 4  \"  ,     \" value 4  \"  )  ;", ". mergePropertiesIntoMap ( props ,    map )  ;", "assertEquals (  \" value 1  \"  ,    map . get (  \" prop 1  \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    map . get (  \" prop 2  \"  )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    map . get (  \" prop 3  \"  )  )  ;", "assertEquals (  \" value 4  \"  ,    map . get (  \" prop 4  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMergePropertiesIntoMap"], "fileName": "org.springframework.util.CollectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ch    =  =     '  \\ n '  )     &  &     (  ( this . buffer . length (  )  )     >     0  )  )     {", "this . logger . debug ( this . buffer . toSt (  )  )  ;", "this . buffer . setLength (  0  )  ;", "} else    {", "this . buffer . append ( ch )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.util.CommonsLogWriter"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  !  ( this . inUse )  )  ,     \" You   can   no   longer   add   iterators   to   a   composite   iterator   that ' s   already   in   use \"  )  ;", "if    ( this . iterators . contains ( iterator )  )     {", "throw   new   IllegalArgumentException (  \" You   cannot   add   the   same   iterator   twice \"  )  ;", "}", "this . iterators . add ( iterator )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.springframework.util.CompositeIterator"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    Arrays . asList (  \"  0  \"  ,     \"  1  \"  )  ;", "Iterator < String >    iterator    =    list . iterator (  )  ;", "< String >    it    =    new    <  >  (  )  ;", "it . add ( iterator )  ;", "it . add ( list . iterator (  )  )  ;", "try    {", "it . add ( iterator )  ;", "fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testDuplicateIterators"], "fileName": "org.springframework.util.CompositeIteratorTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    Arrays . asList (  \"  0  \"  ,     \"  1  \"  )  ;", "< String >    it    =    new    <  >  (  )  ;", "it . add ( list . iterator (  )  )  ;", "it . hasNext (  )  ;", "try    {", "it . add ( list . iterator (  )  )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "it    =    new    <  >  (  )  ;", "it . add ( list . iterator (  )  )  ;", "it . next (  )  ;", "try    {", "it . add ( list . iterator (  )  )  ;", "fail (  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testInUse"], "fileName": "org.springframework.util.CompositeIteratorTests"}, {"methodBody": ["METHOD_START", "{", "CompositeIterator < String >    it    =    new   CompositeIterator <  >  (  )  ;", "it . add ( Arrays . asList (  \"  0  \"  ,     \"  1  \"  )  . iterator (  )  )  ;", "it . add ( Arrays . asList (  \"  2  \"  )  . iterator (  )  )  ;", "it . add ( Arrays . asList (  \"  3  \"  ,     \"  4  \"  )  . iterator (  )  )  ;", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )     {", "assertTrue ( it . hasNext (  )  )  ;", "assertEquals ( String . valueOf ( i )  ,    it . next (  )  )  ;", "}", "assertFalse ( it . hasNext (  )  )  ;", "try    {", "it . next (  )  ;", "fail (  )  ;", "}    catch    ( NoSuchElementException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testMultipleIterators"], "fileName": "org.springframework.util.CompositeIteratorTests"}, {"methodBody": ["METHOD_START", "{", "CompositeIterator < String >    it    =    new   CompositeIterator <  >  (  )  ;", "assertFalse ( it . hasNext (  )  )  ;", "try    {", "it . next (  )  ;", "fail (  )  ;", "}    catch    ( NoSuchElementException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testNoIterators"], "fileName": "org.springframework.util.CompositeIteratorTests"}, {"methodBody": ["METHOD_START", "{", "CompositeIterator < String >    it    =    new   CompositeIterator <  >  (  )  ;", "it . add ( Arrays . asList (  \"  0  \"  ,     \"  1  \"  )  . iterator (  )  )  ;", "for    ( int   i    =     0  ;    i    <     2  ;    i +  +  )     {", "assertTrue ( it . hasNext (  )  )  ;", "assertEquals ( String . valueOf ( i )  ,    it . next (  )  )  ;", "}", "assertFalse ( it . hasNext (  )  )  ;", "try    {", "it . next (  )  ;", "fail (  )  ;", "}    catch    ( NoSuchElementException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testSingleIterator"], "fileName": "org.springframework.util.CompositeIteratorTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . concurrencyLimit )     >  =     0  )     {", "synchronized ( this . monitor )     {", "( this . concurrencyCount )  -  -  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Returning   from   throttle   at   concurrency   count    \"     +     ( this . concurrencyCount )  )  )  ;", "}", "this . monitor . notify (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["afterAccess"], "fileName": "org.springframework.util.ConcurrencyThrottleSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . concurrencyLimit )     =  =     ( ConcurrencyThrottleSupport . NO _ CONCURRENCY )  )     {", "throw   new   IllegalStateException (  \" Currently   no   invocations   allowed    -    concurrency   limit   set   to   NO _ CONCURRENCY \"  )  ;", "}", "if    (  ( this . concurrencyLimit )     >     0  )     {", "boolean   debug    =    logger . isDebugEnabled (  )  ;", "synchronized ( this . monitor )     {", "boolean   interrupted    =    false ;", "while    (  ( this . concurrencyCount )     >  =     ( this . concurrencyLimit )  )     {", "if    ( interrupted )     {", "throw   new   IllegalStateException (  (  \" Thread   was   interrupted   while   waiting   for   invocation   access ,     \"     +     \" but   concurrency   limit   still   does   not   allow   for   entering \"  )  )  ;", "}", "if    ( debug )     {", "logger . debug (  (  (  (  (  \" Concurrency   count    \"     +     ( this . concurrencyCount )  )     +     \"    has   reached   limit    \"  )     +     ( this . concurrencyLimit )  )     +     \"     -    blocking \"  )  )  ;", "}", "try    {", "this . monitor . wait (  )  ;", "}    catch    ( InterruptedException   ex )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "interrupted    =    true ;", "}", "}", "if    ( debug )     {", "logger . debug (  (  \" Entering   throttle   at   concurrency   count    \"     +     ( this . concurrencyCount )  )  )  ;", "}", "( this . concurrencyCount )  +  +  ;", "}", "}", "}", "METHOD_END"], "methodName": ["beforeAccess"], "fileName": "org.springframework.util.ConcurrencyThrottleSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . concurrencyLimit ;", "}", "METHOD_END"], "methodName": ["getConcurrencyLimit"], "fileName": "org.springframework.util.ConcurrencyThrottleSupport"}, {"methodBody": ["METHOD_START", "{", "return    ( this . concurrencyLimit )     >  =     0  ;", "}", "METHOD_END"], "methodName": ["isThrottleActive"], "fileName": "org.springframework.util.ConcurrencyThrottleSupport"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "this . logger    =    LogFacty . getLog ( getClass (  )  )  ;", "this . monit    =    new   Object (  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.util.ConcurrencyThrottleSupport"}, {"methodBody": ["METHOD_START", "{", "this . concurrencyLimit    =    concurrencyLimit ;", "}", "METHOD_END"], "methodName": ["setConcurrencyLimit"], "fileName": "org.springframework.util.ConcurrencyThrottleSupport"}, {"methodBody": ["METHOD_START", "{", "int   shift    =     0  ;", "int   value    =     1  ;", "while    (  ( value    <    minimumValue )     &  &     ( value    <    maximumValue )  )     {", "value    <  <  =     1  ;", "shift +  +  ;", "}", "return   shift ;", "}", "METHOD_END"], "methodName": ["calculateShift"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "return   new   ReferenceManager (  )  ;", "}", "METHOD_END"], "methodName": ["createReferenceManager"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "int   hash    =    getHash ( key )  ;", "return   getSegmentForHash ( hash )  . doTask ( hash ,    key ,    task )  ;", "}", "METHOD_END"], "methodName": ["doTask"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "ConcurrentReferenceHashMap . Reference < K ,    V >    reference    =    getReference ( key ,    ConcurrentReferenceHashMap . Restructure . WHEN _ NECESSARY )  ;", "return   reference    !  =    null    ?    reference . get (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getEntryIfAvailable"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "int   hash    =     ( o    =  =    null )     ?     0     :    o . hashCode (  )  ;", "hash    +  =     ( hash    <  <     1  5  )     ^     -  1  2  9  3  1  ;", "hash    ^  =    hash    >  >  >     1  0  ;", "hash    +  =    hash    <  <     3  ;", "hash    ^  =    hash    >  >  >     6  ;", "hash    +  =     ( hash    <  <     2  )     +     ( hash    <  <     1  4  )  ;", "hash    ^  =    hash    >  >  >     1  6  ;", "return   hash ;", "}", "METHOD_END"], "methodName": ["getHash"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "return   this . loadFactor ;", "}", "METHOD_END"], "methodName": ["getLoadFactor"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "int   hash    =    getHash ( key )  ;", "return   getSegmentForHash ( hash )  . ge ( key ,    hash ,    restructure )  ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "return   this . segments [ index ]  ;", "}", "METHOD_END"], "methodName": ["getSegment"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "return   this . segments [  (  ( hash    >  >  >     (  3  2     -     ( this . shift )  )  )     &     (  ( this . segments . length )     -     1  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["getSegmentForHash"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "return   this . segments . length ;", "}", "METHOD_END"], "methodName": ["getSegmentsSize"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "for    ( ConcurrentReferenceHashMap < K ,    V >  . Segment   segment    :    this . segments )     {", "segment . restructureIfNecessary ( false )  ;", "}", "}", "METHOD_END"], "methodName": ["purgeUnreferencedEntries"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "return   doTask ( key ,    new   Task < V >  ( ConcurrentReferenceHashMap . TaskOption . RESTRUCTURE _ BEFORE ,    ConcurrentReferenceHashMap . TaskOption . RESIZE )     {", "@ Override", "@ Nullable", "protected   V   execute (  @ Nullable", "ConcurrentReferenceHashMap . Reference < K ,    V >    reference ,     @ Nullable", "ConcurrentReferenceHashMap . Entry < K ,    V >    entry ,     @ Nullable", "ConcurrentReferenceHashMap < K ,    V >  . Entries   entries )     {", "if    ( entry    !  =    null )     {", "V   oldValue    =    entry . getValue (  )  ;", "if    ( overwriteExisting )     {", "entry . setValue ( value )  ;", "}", "return   oldValue ;", "}", "Assert . state (  ( entries    !  =    null )  ,     \" No   entries   segment \"  )  ;", "entries . add ( value )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.util.ConcurrentReferenceHashMap"}, {"methodBody": ["METHOD_START", "{", "Integer   key    =     1  2  3  ;", "this . map . put ( key ,     \"  1  2  3  \"  )  ;", "assertThat ( this . map . getSupplimental (  )  ,    is ( not ( key . hashCode (  )  )  )  )  ;", "assertThat (  (  (  ( this . map . getSupplimental (  )  )     >  >     3  0  )     &     2  5  5  )  ,    is ( not (  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldApplySupplimentalHash"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "Map < Integer ,    WeakReference < String >  >    synchronizedMap    =    Collections . synchronizedMap ( new   WeakHashMap < Integer ,    WeakReference < String >  >  (  )  )  ;", "StopWatch   mapTime    =    timeMultiThreaded (  \" SynchronizedMap \"  ,    synchronizedMap ,     (    v )     -  >    new   WeakReference <  >  ( String . valueOf ( v )  )  )  ;", "System . out . println ( mapTime . prettyPrint (  )  )  ;", "this . map . setDisableTestHooks ( true )  ;", "StopWatch   cacheTime    =    timeMultiThreaded (  \" WeakCache \"  ,    this . map ,    String :  : valueOf )  ;", "System . out . println ( cacheTime . prettyPrint (  )  )  ;", "assertThat ( cacheTime . getTotalTimeSeconds (  )  ,    is ( lessThan (  (  ( mapTime . getTotalTimeSeconds (  )  )     /     4  .  0  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldBeFasterThanSynchronizedMap"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "this . map . put (  4  5  6  ,    null )  ;", "this . map . put ( null ,     \"  7  8  9  \"  )  ;", "this . map . clear (  )  ;", "assertThat ( this . map . size (  )  ,    is (  0  )  )  ;", "assertThat ( this . map . containsKey (  1  2  3  )  ,    is ( false )  )  ;", "assertThat ( this . map . containsKey (  4  5  6  )  ,    is ( false )  )  ;", "assertThat ( this . map . containsKey ( null )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["shouldClear"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . containsKey (  1  2  3  )  ,    is ( false )  )  ;", "assertThat ( this . map . containsKey (  4  5  6  )  ,    is ( false )  )  ;", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "this . map . put (  4  5  6  ,    null )  ;", "assertThat ( this . map . containsKey (  1  2  3  )  ,    is ( true )  )  ;", "assertThat ( this . map . containsKey (  4  5  6  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["shouldContainKey"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . containsValue (  \"  1  2  3  \"  )  ,    is ( false )  )  ;", "assertThat ( this . map . containsValue ( null )  ,    is ( false )  )  ;", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "this . map . put (  4  5  6  ,    null )  ;", "assertThat ( this . map . containsValue (  \"  1  2  3  \"  )  ,    is ( true )  )  ;", "assertThat ( this . map . containsValue ( null )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["shouldContainValue"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentReferenceHashMap < Integer ,    String >    map    =    new   ConcurrentReferenceHashMap <  >  (  5  ,     0  .  5 F ,     3  )  ;", "assertThat ( map . getSegmentsSize (  )  ,    is (  4  )  )  ;", "assertThat ( map . getSegment (  0  )  . getSize (  )  ,    is (  2  )  )  ;", "assertThat ( map . getLoadFactor (  )  ,    is (  0  .  5 F )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCreateFullyCustom"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentReferenceHashMap < Integer ,    String >    map    =    new   ConcurrentReferenceHashMap <  >  (  )  ;", "assertThat ( map . getSegmentsSize (  )  ,    is (  1  6  )  )  ;", "assertThat ( map . getSegment (  0  )  . getSize (  )  ,    is (  1  )  )  ;", "assertThat ( map . getLoadFactor (  )  ,    is (  0  .  7  5 F )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCreateWithDefaults"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentReferenceHashMap < Integer ,    String >    map    =    new   ConcurrentReferenceHashMap <  >  (  3  2  )  ;", "assertThat ( map . getSegmentsSize (  )  ,    is (  1  6  )  )  ;", "assertThat ( map . getSegment (  0  )  . getSize (  )  ,    is (  2  )  )  ;", "assertThat ( map . getLoadFactor (  )  ,    is (  0  .  7  5 F )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCreateWithInitialCapacity"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentReferenceHashMap < Integer ,    String >    map    =    new   ConcurrentReferenceHashMap <  >  (  1  6  ,     2  )  ;", "assertThat ( map . getSegmentsSize (  )  ,    is (  2  )  )  ;", "assertThat ( map . getSegment (  0  )  . getSize (  )  ,    is (  8  )  )  ;", "assertThat ( map . getLoadFactor (  )  ,    is (  0  .  7  5 F )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCreateWithInitialCapacityAndConcurrenyLevel"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentReferenceHashMap < Integer ,    String >    map    =    new   ConcurrentReferenceHashMap <  >  (  3  2  ,     0  .  5 F )  ;", "assertThat ( map . getSegmentsSize (  )  ,    is (  1  6  )  )  ;", "assertThat ( map . getSegment (  0  )  . getSize (  )  ,    is (  2  )  )  ;", "assertThat ( map . getLoadFactor (  )  ,    is (  0  .  5 F )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCreateWithInitialCapacityAndLoadFactor"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "this . map . put (  4  5  6  ,    null )  ;", "this . map . put ( null ,     \"  7  8  9  \"  )  ;", "< Integer ,    String >    expected    =    new    <  >  (  )  ;", "expected . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "expected . put (  4  5  6  ,    null )  ;", "expected . put ( null ,     \"  7  8  9  \"  )  ;", "assertThat ( this . map . entrySet (  )  ,    is ( expected . entrySet (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetEntrySet"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map    =    new   ConcurrentReferenceHashMapTests . TestWeakConcurrentCache <  >  (  1  ,     1  0  .  0 F ,     1  )  ;", "this . map . put (  1  ,     \"  1  \"  )  ;", "this . map . put (  2  ,     \"  2  \"  )  ;", "this . map . put (  3  ,     \"  3  \"  )  ;", "HashMap < Integer ,    String >    expected    =    new   HashMap <  >  (  )  ;", "expected . put (  1  ,     \"  1  \"  )  ;", "expected . put (  2  ,     \"  2  \"  )  ;", "expected . put (  3  ,     \"  3  \"  )  ;", "assertThat ( this . map . entrySet (  )  ,    is ( expected . entrySet (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetEntrySetFollowingNext"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map    =    new   ConcurrentReferenceHashMapTests . TestWeakConcurrentCache <  >  (  1  ,     1  0  .  0 F ,     1  )  ;", "this . map . put (  1  ,     \"  1  \"  )  ;", "this . map . put (  2  ,     \"  2  \"  )  ;", "this . map . put (  3  ,     \"  3  \"  )  ;", "assertThat ( this . map . getSegment (  0  )  . getSize (  )  ,    is (  1  )  )  ;", "assertThat ( this . map . get (  1  )  ,    is (  \"  1  \"  )  )  ;", "assertThat ( this . map . get (  2  )  ,    is (  \"  2  \"  )  )  ;", "assertThat ( this . map . get (  3  )  ,    is (  \"  3  \"  )  )  ;", "assertThat ( this . map . get (  4  )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetFollowingNexts"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "this . map . put (  4  5  6  ,    null )  ;", "this . map . put ( null ,     \"  7  8  9  \"  )  ;", "Set < Integer >    expected    =    new   Set <  >  (  )  ;", "expected . add (  1  2  3  )  ;", "expected . add (  4  5  6  )  ;", "expected . add ( null )  ;", "assertThat ( this . map . keySet (  )  ,    is ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetKeySet"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . size (  )  ,    is (  0  )  )  ;", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "this . map . put (  1  2  3  ,    null )  ;", "this . map . put (  4  5  6  ,     \"  4  5  6  \"  )  ;", "assertThat ( this . map . size (  )  ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetSize"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "this . map . put (  4  5  6  ,    null )  ;", "this . map . put ( null ,     \"  7  8  9  \"  )  ;", "List < String >    actual    =    new   ArrayList <  >  ( this . map . values (  )  )  ;", "List < String >    expected    =    new   ArrayList <  >  (  )  ;", "expected . add (  \"  1  2  3  \"  )  ;", "expected . add ( null )  ;", "expected . add (  \"  7  8  9  \"  )  ;", "actual . sort (  . NULL _ SAFE _ STRING _ SORT )  ;", "expected . sort (  . NULL _ SAFE _ STRING _ SORT )  ;", "assertThat ( actual ,    is ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetValues"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . get (  1  2  3  )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldGetWithNoItems"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "new   ConcurrentReferenceHashMap < Integer ,    String >  (  0  ,     1  )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Initial   capacity   must   not   be   negative \"  )  ;", "new    . TestWeakConcurrentCache < Integer ,    String >  (  (  -  1  )  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["shouldNeedNonNegativeInitialCapacity"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "new   ConcurrentReferenceHashMap < Integer ,    String >  (  1  ,     1  )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Concurrency   level   must   be   positive \"  )  ;", "new    . TestWeakConcurrentCache < Integer ,    String >  (  1  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["shouldNeedPositiveConcurrencyLevel"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "new   ConcurrentReferenceHashMap < Integer ,    String >  (  0  ,     0  .  1 F ,     1  )  ;", "this . thrown . expect ( IllegalArgumentException . class )  ;", "this . thrown . expectMessage (  \" Load   factor   must   be   positive \"  )  ;", "new    . TestWeakConcurrentCache < Integer ,    String >  (  0  ,     0  .  0 F ,     1  )  ;", "}", "METHOD_END"], "methodName": ["shouldNeedPositiveLoadFactor"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map    =    new   ConcurrentReferenceHashMapTests . TestWeakConcurrentCache <  >  (  1  ,     0  .  7  5 F ,     1  )  ;", "for    ( int   i    =     1  ;    i    <  =     5  ;    i +  +  )     {", "this . map . put ( i ,    String . valueOf ( i )  )  ;", "}", "this . map . getMockReference (  1  ,    ConcurrentReferenceHashMap . Restructure . NEVER )  . queueForPurge (  )  ;", "this . map . getMockReference (  3  ,    ConcurrentReferenceHashMap . Restructure . NEVER )  . queueForPurge (  )  ;", "this . map . put (  1  ,     \"  1  \"  )  ;", "assertThat ( this . map . get (  1  )  ,    is (  \"  1  \"  )  )  ;", "assertThat ( this . map . get (  2  )  ,    is (  \"  2  \"  )  )  ;", "assertThat ( this . map . getReference (  3  ,    ConcurrentReferenceHashMap . Restructure . WHEN _ NECESSARY )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . get (  4  )  ,    is (  \"  4  \"  )  )  ;", "assertThat ( this . map . get (  5  )  ,    is (  \"  5  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPergeOnPut"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map    =    new   ConcurrentReferenceHashMapTests . TestWeakConcurrentCache <  >  (  1  ,     0  .  7  5 F ,     1  )  ;", "for    ( int   i    =     1  ;    i    <  =     5  ;    i +  +  )     {", "this . map . put ( i ,    String . valueOf ( i )  )  ;", "}", "this . map . getMockReference (  1  ,    ConcurrentReferenceHashMap . Restructure . NEVER )  . queueForPurge (  )  ;", "this . map . getMockReference (  3  ,    ConcurrentReferenceHashMap . Restructure . NEVER )  . queueForPurge (  )  ;", "assertThat ( this . map . getReference (  1  ,    ConcurrentReferenceHashMap . Restructure . WHEN _ NECESSARY )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . get (  2  )  ,    is (  \"  2  \"  )  )  ;", "assertThat ( this . map . getReference (  3  ,    ConcurrentReferenceHashMap . Restructure . WHEN _ NECESSARY )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . get (  4  )  ,    is (  \"  4  \"  )  )  ;", "assertThat ( this . map . get (  5  )  ,    is (  \"  5  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPurgeOnGet"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "Map < Integer ,    String >    m    =    new   HashMap <  >  (  )  ;", "m . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "m . put (  4  5  6  ,    null )  ;", "m . put ( null ,     \"  7  8  9  \"  )  ;", "this . map . putAll ( m )  ;", "assertThat ( this . map . size (  )  ,    is (  3  )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  1  2  3  \"  )  )  ;", "assertThat ( this . map . get (  4  5  6  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . get ( null )  ,    is (  \"  7  8  9  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPutAll"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . size (  )  ,    is (  0  )  )  ;", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  1  2  3  \"  )  )  ;", "assertThat ( this . map . size (  )  ,    is (  1  )  )  ;", "this . map . put (  1  2  3  ,     \"  1  2  3 b \"  )  ;", "assertThat ( this . map . size (  )  ,    is (  1  )  )  ;", "this . map . put (  1  2  3  ,    null )  ;", "assertThat ( this . map . size (  )  ,    is (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPutAndGet"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . putIfAbsent (  1  2  3  ,     \"  1  2  3  \"  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . putIfAbsent (  1  2  3  ,     \"  1  2  3 b \"  )  ,    is (  \"  1  2  3  \"  )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  1  2  3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPutIfAbsent"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . putIfAbsent ( null ,     \"  1  2  3  \"  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . putIfAbsent ( null ,     \"  1  2  3 b \"  )  ,    is (  \"  1  2  3  \"  )  )  ;", "assertThat ( this . map . get ( null )  ,    is (  \"  1  2  3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPutIfAbsentWithNullKey"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . putIfAbsent (  1  2  3  ,    null )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . putIfAbsent (  1  2  3  ,     \"  1  2  3  \"  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPutIfAbsentWithNullValue"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . get ( null )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . getOrDefault ( null ,     \"  4  5  6  \"  )  ,    is (  \"  4  5  6  \"  )  )  ;", "this . map . put ( null ,     \"  1  2  3  \"  )  ;", "assertThat ( this . map . get ( null )  ,    is (  \"  1  2  3  \"  )  )  ;", "assertThat ( this . map . getOrDefault ( null ,     \"  4  5  6  \"  )  ,    is (  \"  1  2  3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPutNullKey"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . get (  1  2  3  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . getOrDefault (  1  2  3  ,     \"  4  5  6  \"  )  ,    is (  \"  4  5  6  \"  )  )  ;", "this . map . put (  1  2  3  ,     \"  3  2  1  \"  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  3  2  1  \"  )  )  ;", "assertThat ( this . map . getOrDefault (  1  2  3  ,     \"  4  5  6  \"  )  ,    is (  \"  3  2  1  \"  )  )  ;", "this . map . put (  1  2  3  ,    null )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . getOrDefault (  1  2  3  ,     \"  4  5  6  \"  )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldPutNullValue"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "assertThat ( this . map . remove (  1  2  3  ,     \"  4  5  6  \"  )  ,    is ( false )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  1  2  3  \"  )  )  ;", "assertThat ( this . map . remove (  1  2  3  ,     \"  1  2  3  \"  )  ,    is ( true )  )  ;", "assertFalse ( this . map . containsKey (  1  2  3  )  )  ;", "assertThat ( this . map . isEmpty (  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["shouldRemoveKeyAndValue"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,    null )  ;", "assertThat ( this . map . remove (  1  2  3  ,     \"  4  5  6  \"  )  ,    is ( false )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . remove (  1  2  3  ,    null )  ,    is ( true )  )  ;", "assertFalse ( this . map . containsKey (  1  2  3  )  )  ;", "assertThat ( this . map . isEmpty (  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["shouldRemoveKeyAndValueWithExistingNull"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  ,     \"  1  \"  )  ;", "this . map . put (  2  ,     \"  2  \"  )  ;", "this . map . put (  3  ,     \"  3  \"  )  ;", "Iterator < Map . Entry < Integer ,    St >  >    iterator    =    this . map . entrySet (  )  . iterator (  )  ;", "iterator . next (  )  ;", "iterator . next (  )  ;", "iterator . remove (  )  ;", "iterator . next (  )  ;", "assertThat ( iterator . hasNext (  )  ,    is ( false )  )  ;", "assertThat ( this . map . size (  )  ,    is (  2  )  )  ;", "assertThat ( this . map . containsKey (  2  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["shouldRemoveViaEntrySet"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,    null )  ;", "this . map . put (  4  5  6  ,     \"  4  5  6  \"  )  ;", "this . map . put ( null ,     \"  7  8  9  \"  )  ;", "assertThat ( this . map . remove (  1  2  3  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . remove (  4  5  6  )  ,    is (  \"  4  5  6  \"  )  )  ;", "assertThat ( this . map . remove ( null )  ,    is (  \"  7  8  9  \"  )  )  ;", "assertThat ( this . map . isEmpty (  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["shouldRemoveWhenKeyIsInMap"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . remove (  1  2  3  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . remove ( null )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . isEmpty (  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["shouldRemoveWhenKeyIsNotInMap"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,    null )  ;", "assertThat ( this . map . replace (  1  2  3  ,     \"  4  5  6  \"  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  4  5  6  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldReplaceNullValue"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,    null )  ;", "assertThat ( this . map . replace (  1  2  3  ,     \"  4  5  6  \"  ,     \"  7  8  9  \"  )  ,    is ( false )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is ( nullValue (  )  )  )  ;", "assertThat ( this . map . replace (  1  2  3  ,    null ,     \"  7  8  9  \"  )  ,    is ( true )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  7  8  9  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldReplaceOldNullValueWithNewValue"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "assertThat ( this . map . replace (  1  2  3  ,     \"  4  5  6  \"  ,     \"  7  8  9  \"  )  ,    is ( false )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  1  2  3  \"  )  )  ;", "assertThat ( this . map . replace (  1  2  3  ,     \"  1  2  3  \"  ,     \"  7  8  9  \"  )  ,    is ( true )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  7  8  9  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldReplaceOldValueWithNewValue"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,     \"  3  2  1  \"  )  ;", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  1  2  3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldReplaceOnDoublePut"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "assertThat ( this . map . replace (  1  2  3  ,     \"  4  5  6  \"  )  ,    is (  \"  1  2  3  \"  )  )  ;", "assertThat ( this . map . get (  1  2  3  )  ,    is (  \"  4  5  6  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldReplaceValue"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map    =    new   ConcurrentReferenceHashMapTests . TestWeakConcurrentCache <  >  (  1  ,     0  .  7  5 F ,     1  )  ;", "this . map . put (  1  ,     \"  1  \"  )  ;", "assertThat ( this . map . getSegment (  0  )  . getSize (  )  ,    is (  1  )  )  ;", "assertThat ( this . map . get (  1  )  ,    is (  \"  1  \"  )  )  ;", "this . map . put (  2  ,     \"  2  \"  )  ;", "assertThat ( this . map . getSegment (  0  )  . getSize (  )  ,    is (  2  )  )  ;", "assertThat ( this . map . get (  1  )  ,    is (  \"  1  \"  )  )  ;", "assertThat ( this . map . get (  2  )  ,    is (  \"  2  \"  )  )  ;", "this . map . put (  3  ,     \"  3  \"  )  ;", "assertThat ( this . map . getSegment (  0  )  . getSize (  )  ,    is (  4  )  )  ;", "assertThat ( this . map . get (  1  )  ,    is (  \"  1  \"  )  )  ;", "assertThat ( this . map . get (  2  )  ,    is (  \"  2  \"  )  )  ;", "assertThat ( this . map . get (  3  )  ,    is (  \"  3  \"  )  )  ;", "this . map . put (  4  ,     \"  4  \"  )  ;", "assertThat ( this . map . getSegment (  0  )  . getSize (  )  ,    is (  8  )  )  ;", "assertThat ( this . map . get (  4  )  ,    is (  \"  4  \"  )  )  ;", "for    ( int   i    =     1  ;    i    <  =     5  ;    i +  +  )     {", "this . map . put ( i ,    String . valueOf ( i )  )  ;", "}", "assertThat ( this . map . getSegment (  0  )  . getSize (  )  ,    is (  8  )  )  ;", "assertThat ( this . map . get (  5  )  ,    is (  \"  5  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldResize"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "this . map . put (  1  ,     \"  1  \"  )  ;", "this . map . put (  2  ,     \"  2  \"  )  ;", "this . map . put (  3  ,     \"  3  \"  )  ;", "Iterator < Map . Entry < Integer ,    St >  >    iterator    =    this . map . entrySet (  )  . iterator (  )  ;", "iterator . next (  )  ;", "iterator . next (  )  . setValue (  \"  2 b \"  )  ;", "iterator . next (  )  ;", "assertThat ( iterator . hasNext (  )  ,    is ( false )  )  ;", "assertThat ( this . map . size (  )  ,    is (  3  )  )  ;", "assertThat ( this . map . get (  2  )  ,    is (  \"  2 b \"  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSetViaEntrySet"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . map . isEmpty (  )  ,    is ( true )  )  ;", "this . map . put (  1  2  3  ,     \"  1  2  3  \"  )  ;", "this . map . put (  1  2  3  ,    null )  ;", "this . map . put (  4  5  6  ,     \"  4  5  6  \"  )  ;", "assertThat ( this . map . isEmpty (  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportIsEmpty"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "map . createReferenceManager (  )  . createReference ( null ,     1  2  3  4  ,    null )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportNullReference"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "StopWatch   stopWatch    =    new   StopWatch ( id )  ;", "for    ( int   i    =     0  ;    i    <     5  0  0  ;    i +  +  )     {", "map . put ( i ,    factory . newValue ( i )  )  ;", "}", "Thread [  ]    threads    =    new   Thread [  3  0  ]  ;", "stopWatch . start (  \" Runn   threads \"  )  ;", "for    ( int   threadIndex    =     0  ;    threadIndex    <     ( threads . length )  ;    threadIndex +  +  )     {", "threads [ threadIndex ]     =    new   Thread (  (  \" Cache   access   thread    \"     +    threadIndex )  )     {", "@ Override", "public   void   run (  )     {", "for    ( int   j    =     0  ;    j    <     1  0  0  0  ;    j +  +  )     {", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "map . get ( i )  ;", "}", "}", "}", "}  ;", "}", "for    ( Thread   thread    :    threads )     {", "thread . start (  )  ;", "}", "for    ( Thread   thread    :    threads )     {", "if    ( thread . isAlive (  )  )     {", "thread . join (  2  0  0  0  )  ;", "}", "}", "stopWatch . stop (  )  ;", "return   stopWatch ;", "}", "METHOD_END"], "methodName": ["timeMultiThreaded"], "fileName": "org.springframework.util.ConcurrentReferenceHashMapTests"}, {"methodBody": ["METHOD_START", "{", "Thread   thread    =    new   Thread ( getThreadGroup (  )  ,    runnable ,    nextThreadName (  )  )  ;", "thread . setPriority ( getThreadPriority (  )  )  ;", "thread . setDaemon ( isDaemon (  )  )  ;", "return   thread ;", "}", "METHOD_END"], "methodName": ["createThread"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "return    ( ClassUtils . getShortName ( getClass (  )  )  )     +     \"  -  \"  ;", "}", "METHOD_END"], "methodName": ["getDefaultThreadNamePrefix"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "return   this . threadGroup ;", "}", "METHOD_END"], "methodName": ["getThreadGroup"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "return   this . threadNamePrefix ;", "}", "METHOD_END"], "methodName": ["getThreadNamePrefix"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "return   this . threadPriority ;", "}", "METHOD_END"], "methodName": ["getThreadPriority"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "return   this . daemon ;", "}", "METHOD_END"], "methodName": ["isDaemon"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "return    ( getThreadNamePrefix (  )  )     +     ( this . threadCount . incrementAndGet (  )  )  ;", "}", "METHOD_END"], "methodName": ["nextThreadName"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "this . daemon    =    daemon ;", "}", "METHOD_END"], "methodName": ["setDaemon"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "this . threadGroup    =    threadGroup ;", "}", "METHOD_END"], "methodName": ["setThreadGroup"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "this . threadGroup    =    new   ThreadGroup ( name )  ;", "}", "METHOD_END"], "methodName": ["setThreadGroupName"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "this . threadNamePrefix    =     ( threadNamePrefix    !  =    null )     ?    threadNamePrefix    :    getDefaultThreadNamePrefix (  )  ;", "}", "METHOD_END"], "methodName": ["setThreadNamePrefix"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "this . threadPriority    =    threadPriority ;", "}", "METHOD_END"], "methodName": ["setThreadPriority"], "fileName": "org.springframework.util.CustomizableThreadCreator"}, {"methodBody": ["METHOD_START", "{", "char [  ]    hexDigest    =    DigestUtils . digestAsHexChars ( algorithm ,    bytes )  ;", "return   builder . append ( hexDigest )  ;", "}", "METHOD_END"], "methodName": ["appendDigestAsHex"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "char [  ]    hexDigest    =    DigestUtils . digestAsHexChars ( algorithm ,    inputStream )  ;", "return   builder . append ( hexDigest )  ;", "}", "METHOD_END"], "methodName": ["appendDigestAsHex"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "return   DigestUtils . appendDigestAsHex ( DigestUtils . MD 5  _ ALGORITHM _ NAME ,    bytes ,    builder )  ;", "}", "METHOD_END"], "methodName": ["appendMd5DigestAsHex"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "return   DigestUtils . appendDigestAsHex ( DigestUtils . MD 5  _ ALGORITHM _ NAME ,    inputStream ,    builder )  ;", "}", "METHOD_END"], "methodName": ["appendMd5DigestAsHex"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "return   DigestUtils . getDigest ( algorithm )  . digest ( bytes )  ;", "}", "METHOD_END"], "methodName": ["digest"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "MessageDigest   messageDigest    =    DigestUtils . getDigest ( algorithm )  ;", "if    ( inputStream   instanceof   UpdateMessageDigestInputStream )     {", "(  ( UpdateMessageDigestInputStream )     ( inputStream )  )  . updateMessageDigest ( messageDigest )  ;", "return   messageDigest . digest (  )  ;", "} else    {", "final   byte [  ]    buffer    =    new   byte [ StreamUtils . BUFFER _ SIZE ]  ;", "int   bytesRead    =     -  1  ;", "while    (  ( bytesRead    =    inputStream . read ( buffer )  )     !  =     (  -  1  )  )     {", "messageDigest . update ( buffer ,     0  ,    bytesRead )  ;", "}", "return   messageDigest . digest (  )  ;", "}", "}", "METHOD_END"], "methodName": ["digest"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    digest    =    DigestUtils . digest ( algorithm ,    bytes )  ;", "return   DigestUtils . encodeHex ( digest )  ;", "}", "METHOD_END"], "methodName": ["digestAsHexChars"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    digest    =    DigestUtils . digest ( algorithm ,    inputStream )  ;", "return   DigestUtils . encodeHex ( digest )  ;", "}", "METHOD_END"], "methodName": ["digestAsHexChars"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "char [  ]    hexDigest    =    DigestUtils . digestAsHexChars ( algorithm ,    bytes )  ;", "return   new   String ( hexDigest )  ;", "}", "METHOD_END"], "methodName": ["digestAsHexString"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "char [  ]    hexDigest    =    DigestUtils . digestAsHexChars ( algorithm ,    inputStream )  ;", "return   new   String ( hexDigest )  ;", "}", "METHOD_END"], "methodName": ["digestAsHexString"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "char [  ]    chars    =    new   char [  3  2  ]  ;", "for    ( int   i    =     0  ;    i    <     ( chars . length )  ;    i    =    i    +     2  )     {", "byte   b    =    bytes [  ( i    /     2  )  ]  ;", "chars [ i ]     =     . HEX _ CHARS [  (  ( b    >  >  >     4  )     &     1  5  )  ]  ;", "chars [  ( i    +     1  )  ]     =     . HEX _ CHARS [  ( b    &     1  5  )  ]  ;", "}", "return   chars ;", "}", "METHOD_END"], "methodName": ["encodeHex"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Message . getInstance ( algorithm )  ;", "}    catch    ( NoSuchAlgorithmException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Could   not   find   Message   with   algorithm    \\  \"  \"     +    algorithm )     +     \"  \\  \"  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getDigest"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "return   DigestUtils . digest ( DigestUtils . MD 5  _ ALGORITHM _ NAME ,    bytes )  ;", "}", "METHOD_END"], "methodName": ["md5Digest"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "return   DigestUtils . digest ( DigestUtils . MD 5  _ ALGORITHM _ NAME ,    inputStream )  ;", "}", "METHOD_END"], "methodName": ["md5Digest"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "return   DigestUtils . digestAsHexString ( DigestUtils . MD 5  _ ALGORITHM _ NAME ,    bytes )  ;", "}", "METHOD_END"], "methodName": ["md5DigestAsHex"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "return   DigestUtils . digestAsHexString ( DigestUtils . MD 5  _ ALGORITHM _ NAME ,    inputStream )  ;", "}", "METHOD_END"], "methodName": ["md5DigestAsHex"], "fileName": "org.springframework.util.DigestUtils"}, {"methodBody": ["METHOD_START", "{", "bytes    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "}", "METHOD_END"], "methodName": ["createBytes"], "fileName": "org.springframework.util.DigestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    expected    =    new   byte [  ]  {     -  7  9  ,     1  0  ,     -  1  1  5  ,     -  7  9  ,     1  0  0  ,     -  3  2  ,     1  1  7  ,     6  5  ,     5  ,     -  7  3  ,     -  8  7  ,     -  1  0  1  ,     -  2  5  ,     4  6  ,     6  3  ,     -  2  7     }  ;", "byte [  ]    result    =     . md 5 Digest ( bytes )  ;", "assertArrayEquals (  \" Invalid   hash \"  ,    expected ,    result )  ;", "result    =     . md 5 Digest ( new   ByteArrayInputStream ( bytes )  )  ;", "assertArrayEquals (  \" Invalid   hash \"  ,    expected ,    result )  ;", "}", "METHOD_END"], "methodName": ["md5"], "fileName": "org.springframework.util.DigestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \"  ;", "String   hash    =     . md 5 DigestAsHex ( bytes )  ;", "assertEquals (  \" Invalid   hash \"  ,    expected ,    hash )  ;", "hash    =     . md 5 DigestAsHex ( new   ByteArrayInputStream ( bytes )  )  ;", "assertEquals (  \" Invalid   hash \"  ,    expected ,    hash )  ;", "}", "METHOD_END"], "methodName": ["md5Hex"], "fileName": "org.springframework.util.DigestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expected    =     \" b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \"  ;", "StringBuilder   builder    =    new   StringBuilder (  )  ;", ". appendMd 5 DigestAsHex ( bytes ,    builder )  ;", "assertEquals (  \" Invalid   hash \"  ,    expected ,    builder . toString (  )  )  ;", "builder    =    new   StringBuilder (  )  ;", ". appendMd 5 DigestAsHex ( new   ByteArrayInputStream ( bytes )  ,    builder )  ;", "assertEquals (  \" Invalid   hash \"  ,    expected ,    builder . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["md5StringBuilder"], "fileName": "org.springframework.util.DigestUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ExceptionTypeFilter   filter    =    new   ExceptionTypeFilter ( Arrays . asList ( RuntimeException . class )  ,    null ,    true )  ;", "assertTrue ( filter . match ( RuntimeException . class )  )  ;", "assertTrue ( filter . match ( IllegalStateException . class )  )  ;", "}", "METHOD_END"], "methodName": ["subClassMatch"], "fileName": "org.springframework.util.ExceptionTypeFilterTests"}, {"methodBody": ["METHOD_START", "{", "ExponentialBackOff   backOff    =    new   ExponentialBackOff (  )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  2  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  3  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  4  5  0  0 L ,    execution . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultInstance"], "fileName": "org.springframework.util.ExponentialBackOffTests"}, {"methodBody": ["METHOD_START", "{", "ExponentialBackOff   backOff    =    new   ExponentialBackOff (  1  0  0 L ,     1  .  0  )  ;", "backOff . setMaxElapsedTime (  3  0  0 L )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  1  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  1  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  1  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals ( BackOffExecution . STOP ,    execution . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["fixedIncrease"], "fileName": "org.springframework.util.ExponentialBackOffTests"}, {"methodBody": ["METHOD_START", "{", "ExponentialBackOff   backOff    =    new   ExponentialBackOff (  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "backOff . setMultiplier (  0  .  9  )  ;", "}", "METHOD_END"], "methodName": ["invalidInterval"], "fileName": "org.springframework.util.ExponentialBackOffTests"}, {"methodBody": ["METHOD_START", "{", "ExponentialBackOff   backOff    =    new   ExponentialBackOff (  2  0  0  0 L ,     2  .  0  )  ;", "backOff . setMaxElapsedTime (  4  0  0  0 L )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  2  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  4  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals ( BackOffExecution . STOP ,    execution . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["maxAttemptsReached"], "fileName": "org.springframework.util.ExponentialBackOffTests"}, {"methodBody": ["METHOD_START", "{", "ExponentialBackOff   backOff    =    new   ExponentialBackOff (  2  0  0  0 L ,     2  .  0  )  ;", "backOff . setMaxInterval (  4  0  0  0 L )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  2  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  4  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  4  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  4  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["maxIntervalReached"], "fileName": "org.springframework.util.ExponentialBackOffTests"}, {"methodBody": ["METHOD_START", "{", "ExponentialBackOff   backOff    =    new   ExponentialBackOff (  1  0  0  0 L ,     2  .  0  )  ;", "backOff . setMaxInterval (  5  0 L )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  5  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  5  0 L ,    execution . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["maxIntervalReachedImmediately"], "fileName": "org.springframework.util.ExponentialBackOffTests"}, {"methodBody": ["METHOD_START", "{", "ExponentialBackOff   backOff    =    new   ExponentialBackOff (  1  0  0 L ,     2  .  0  )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  1  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  2  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  4  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  8  0  0 L ,    execution . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleIncrease"], "fileName": "org.springframework.util.ExponentialBackOffTests"}, {"methodBody": ["METHOD_START", "{", "ExponentialBackOff   backOff    =    new   ExponentialBackOff (  )  ;", "backOff . setInitialInterval (  2  0  0  0 L )  ;", "backOff . setMultiplier (  2  .  0  )  ;", "backOff . setMaxElapsedTime (  4  0  0  0 L )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "BackOffExecution   execution 2     =    backOff . start (  )  ;", "assertEquals (  2  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  2  0  0  0 L ,    execution 2  . nextBackOff (  )  )  ;", "assertEquals (  4  0  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  4  0  0  0 L ,    execution 2  . nextBackOff (  )  )  ;", "assertEquals ( BackOffExecution . STOP ,    execution . nextBackOff (  )  )  ;", "assertEquals ( BackOffExecution . STOP ,    execution 2  . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["startReturnDifferentInstances"], "fileName": "org.springframework.util.ExponentialBackOffTests"}, {"methodBody": ["METHOD_START", "{", "ExponentialBackOff   backOff    =    new   ExponentialBackOff (  2  0  0  0 L ,     2  .  0  )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  \" ExponentialBackOff { currentInterval = n / a ,    multiplier =  2  .  0  }  \"  ,    execution . toString (  )  )  ;", "execution . nextBackOff (  )  ;", "assertEquals (  \" ExponentialBackOff { currentInterval =  2  0  0  0 ms ,    multiplier =  2  .  0  }  \"  ,    execution . toString (  )  )  ;", "execution . nextBackOff (  )  ;", "assertEquals (  \" ExponentialBackOff { currentInterval =  4  0  0  0 ms ,    multiplier =  2  .  0  }  \"  ,    execution . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStringContent"], "fileName": "org.springframework.util.ExponentialBackOffTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . buffers . peekLast (  )  )     !  =    null )     {", "this . alreadyBufferedSize    +  =    this . index ;", "this . index    =     0  ;", "}", "if    (  ( this . nextBlockSize )     <    minCapacity )     {", "this . nextBlockSize    =     . nextPowerOf 2  ( minCapacity )  ;", "}", "this . buffers . add ( new   byte [ this . nextBlockSize ]  )  ;", "this . nextBlockSize    *  =     2  ;", "}", "METHOD_END"], "methodName": ["addBuffer"], "fileName": "org.springframework.util.FastByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "return   new   FastByteArrayOutputStream . FastByteArrayInputStream ( this )  ;", "}", "METHOD_END"], "methodName": ["getInputStream"], "fileName": "org.springframework.util.FastByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "val -  -  ;", "val    =     ( val    >  >     1  )     |    val ;", "val    =     ( val    >  >     2  )     |    val ;", "val    =     ( val    >  >     4  )     |    val ;", "val    =     ( val    >  >     8  )     |    val ;", "val    =     ( val    >  >     1  6  )     |    val ;", "val +  +  ;", "turn   val ;", "}", "METHOD_END"], "methodName": ["nextPowerOf2"], "fileName": "org.springframework.util.FastByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "this . buffers . clear (  )  ;", "this . nextBlockSize    =    this . initialBlockSize ;", "this . closed    =    false ;", "this . index    =     0  ;", "this . aldyBufferedSize    =     0  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.util.FastByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( targetCapacity    >  =     ( size (  )  )  )  ,     \" New   capacity   must   not   be   smaller   than   current   size \"  )  ;", "if    (  ( this . buffers . peekFirst (  )  )     =  =    null )     {", "this . nextBlockSize    =    targetCapacity    -     ( size (  )  )  ;", "} else", "if    (  (  ( size (  )  )     =  =    targetCapacity )     &  &     (  ( this . buffers . getFirst (  )  . length )     =  =    targetCapacity )  )     {", "} else    {", "int   totalSize    =    size (  )  ;", "byte [  ]    data    =    new   byte [ targetCapacity ]  ;", "int   pos    =     0  ;", "javaIterator < byte [  ]  >    it    =    this . buffers . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "byte [  ]    bytes    =    it . next (  )  ;", "if    ( it . hasNext (  )  )     {", "System . arraycopy ( bytes ,     0  ,    data ,    pos ,    bytes . length )  ;", "pos    +  =    bytes . length ;", "} else    {", "System . arraycopy ( bytes ,     0  ,    data ,    pos ,    this . index )  ;", "}", "}", "this . buffers . clear (  )  ;", "this . buffers . add ( data )  ;", "this . index    =    totalSize ;", "this . alreadyBufferedSize    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "org.springframework.util.FastByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "return    ( this . alreadyBufferedSize )     +     ( this . index )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.springframework.util.FastByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytesUnsafe    =    toByteArrayUnsafe (  )  ;", "byte [  ]    ret    =    new   byte [ bytesUnsafe . length ]  ;", "System . arraycopy ( bytesUnsafe ,     0  ,    ret ,     0  ,    bytesUnsafe . length )  ;", "return   ret ;", "}", "METHOD_END"], "methodName": ["toByteArray"], "fileName": "org.springframework.util.FastByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "int   totalSize    =    size (  )  ;", "if    ( totalSize    =  =     0  )     {", "return   new   b [  0  ]  ;", "}", "resize ( totalSize )  ;", "return   this . buffers . getFirst (  )  ;", "}", "METHOD_END"], "methodName": ["toByteArrayUnsafe"], "fileName": "org.springframework.util.FastByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "Iterator < byte [  ]  >    it    =    this . buffers . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "byte [  ]    bytes    =    it . next (  )  ;", "if    ( it . hasNext (  )  )     {", "out . write ( bytes ,     0  ,    bytes . length )  ;", "} else    {", "out . write ( bytes ,     0  ,    this . index )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeTo"], "fileName": "org.springframework.util.FastByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "assertArrayEquals ( this . helloBytes ,    actual . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertByteArrayEqualsString"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . resize (  1  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "this . os . write (  1  )  ;", "}", "assertEquals (  1  0  ,    this . os . size (  )  )  ;", "assertArrayEquals ( this . os . to (  )  ,    new   byte [  ]  {     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1  ,     1     }  )  ;", "}", "METHOD_END"], "methodName": ["autoGrow"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . close (  )  ;", "this . os . write ( this . hellos )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "this . os . resize (  5  )  ;", "}", "METHOD_END"], "methodName": ["failResize"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "assertNotNull ( this . os . getIn (  )  )  ;", "}", "METHOD_END"], "methodName": ["getInputStream"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "assertEquals ( this . os . getIn (  )  . available (  )  ,    this . helloBytes . length )  ;", "}", "METHOD_END"], "methodName": ["getInputStreamAvailable"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "In   in    =    this . os . getIn (  )  ;", "assertEquals ( in . read (  )  ,    this . helloBytes [  0  ]  )  ;", "assertEquals ( in . read (  )  ,    this . helloBytes [  1  ]  )  ;", "assertEquals ( in . read (  )  ,    this . helloBytes [  2  ]  )  ;", "assertEquals ( in . read (  )  ,    this . helloBytes [  3  ]  )  ;", "}", "METHOD_END"], "methodName": ["getInputStreamRead"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "In   in    =    this . os . getIn (  )  ;", "byte [  ]    actual    =    new   byte [ in . available (  )  ]  ;", "int   bytesRead    =    in . read ( actual )  ;", "assertEquals ( this . helloBytes . length ,    bytesRead )  ;", "assertArrayEquals ( this . helloBytes ,    actual )  ;", "assertEquals (  0  ,    in . available (  )  )  ;", "}", "METHOD_END"], "methodName": ["getInputStreamReadAll"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "In   in    =    os . getIn (  )  ;", "byte [  ]    actual    =    new   byte [  ( in . available (  )  )     +     1  ]  ;", "int   bytesRead    =    in . read ( actual )  ;", "assertEquals ( this . helloBytes . length ,    bytesRead )  ;", "for    ( int   i    =     0  ;    i    <    bytesRead ;    i +  +  )     {", "assertEquals ( this . helloBytes [ i ]  ,    actual [ i ]  )  ;", "}", "assertEquals (  0  ,    actual [ this . helloBytes . length ]  )  ;", "assertEquals (  0  ,    in . available (  )  )  ;", "}", "METHOD_END"], "methodName": ["getInputStreamReadBeyondEndOfStream"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "In   in    =    this . os . getIn (  )  ;", "assertEquals ( in . read (  )  ,    this . helloBytes [  0  ]  )  ;", "assertEquals (  1  ,    in . skip (  1  )  )  ;", "assertEquals ( in . read (  )  ,    this . helloBytes [  2  ]  )  ;", "assertEquals (  (  ( this . helloBytes . length )     -     3  )  ,    in . available (  )  )  ;", "}", "METHOD_END"], "methodName": ["getInputStreamSkip"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "In   in    =    this . os . getIn (  )  ;", "assertEquals ( in . skip (  1  0  0  0  )  ,    this . helloBytes . length )  ;", "assertEquals (  0  ,    in . available (  )  )  ;", "}", "METHOD_END"], "methodName": ["getInputStreamSkipAll"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "asserEqualsString ( this . os )  ;", "this . os . reset (  )  ;", "assertEquals (  0  ,    this . os . size (  )  )  ;", "this . os . write ( this . helloBytes )  ;", "asserEqualsString ( this . os )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "int   sizeBefore    =    this . os . size (  )  ;", "this . os . resize (  6  4  )  ;", "asserEqualsString ( this . os )  ;", "assertEquals ( sizeBefore ,    this . os . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os    =    new   FastByteArrayOutputStream ( FastByteArrayOutputStreamTests . INITIAL _ CAPACITY )  ;", "this . helloBytes    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "assertEquals ( this . os . size (  )  ,    this . helloBytes . length )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "asserEqualsString ( this . os )  ;", "assertSame ( this . os . toByteArrayUnsafe (  )  ,    this . os . toByteArrayUnsafe (  )  )  ;", "assertArrayEquals ( this . os . toByteArray (  )  ,    this . helloBytes )  ;", "}", "METHOD_END"], "methodName": ["toByteArrayUnsafe"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  \"  \\  \"  0  \"  )  ;", "this . os . write ( this . helloBytes )  ;", "In   in    =    this . os . getIn (  )  ;", "DigestUtils . appendMd 5 DigestAsHex ( in ,    builder )  ;", "builder . append (  \"  \\  \"  \"  )  ;", "String   actual    =    builder . toString (  )  ;", "assertEquals (  \"  \\  \"  0 b 1  0 a 8 db 1  6  4 e 0  7  5  4  1  0  5 b 7 a 9  9 be 7  2 e 3 fe 5  \\  \"  \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["updateMessageDigest"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  \"  \\  \"  0  \"  )  ;", "for    ( int   i    =     0  ;    i    <     3  0  ;    i +  +  )     {", "this . os . write ( this . helloBytes )  ;", "}", "In   in    =    this . os . getIn (  )  ;", "DigestUtils . appendMd 5 DigestAsHex ( in ,    builder )  ;", "builder . append (  \"  \\  \"  \"  )  ;", "String   actual    =    builder . toString (  )  ;", "assertEquals (  \"  \\  \"  0  6  2  2  5 ca 1 e 4  5  3  3  3  5  4 c 5  1  6 e 7  4  5  1  2  0  6  5  3  3  1 d \\  \"  \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["updateMessageDigestManyBuffers"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "asserEqualsString ( this . os )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . os . write ( this . helloBytes )  ;", "assertByteArrayEqualsString ( this . os )  ;", "baos    =    new    (  )  ;", "this . os . writeTo ( baos )  ;", "assertArrayEquals ( baos . toByteArray (  )  ,    this . helloBytes )  ;", "}", "METHOD_END"], "methodName": ["writeTo"], "fileName": "org.springframework.util.FastByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   input   byte   array   specified \"  )  ;", "Assert . notNull ( out ,     \" No   output   File   specified \"  )  ;", ". copy ( new   ByteArrayInputStream ( in )  ,    Files . newOutputStream ( out . toPath (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.util.FileCopyUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   input   byte   array   specified \"  )  ;", "Assert . notNull ( out ,     \" No   OutputStream   specified \"  )  ;", "try    {", "out . write ( in )  ;", "}    finally    {", "try    {", "out . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.util.FileCopyUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   input   File   specified \"  )  ;", "Assert . notNull ( out ,     \" No   output   File   specified \"  )  ;", "return    . copy ( Files . newInputStream ( in . toPath (  )  )  ,    Files . newOutputStream ( out . toPath (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.util.FileCopyUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   InputStream   specified \"  )  ;", "Assert . notNull ( out ,     \" No   OutputStream   specified \"  )  ;", "try    {", "return   Stream . copy ( in ,    out )  ;", "}    finally    {", "try    {", "in . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "try    {", "out . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.util.FileCopyUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   Reader   specified \"  )  ;", "Assert . notNull ( out ,     \" No   Writer   specified \"  )  ;", "try    {", "int   byteCount    =     0  ;", "char [  ]    buffer    =    new   char [  . BUFFER _ SIZE ]  ;", "int   bytesRead    =     -  1  ;", "while    (  ( bytesRead    =    in . read ( buffer )  )     !  =     (  -  1  )  )     {", "out . write ( buffer ,     0  ,    bytesRead )  ;", "byteCount    +  =    bytesRead ;", "}", "out . flush (  )  ;", "return   byteCount ;", "}    finally    {", "try    {", "in . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "try    {", "out . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.util.FileCopyUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   input   String   specified \"  )  ;", "Assert . notNull ( out ,     \" No   Writer   specified \"  )  ;", "try    {", "out . write ( in )  ;", "}    finally    {", "try    {", "out . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.util.FileCopyUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   input   File   specified \"  )  ;", "return    . copyToByteArray ( Files . newInputStream ( in . toPath (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["copyToByteArray"], "fileName": "org.springframework.util.FileCopyUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( in    =  =    null )     {", "return   new   byte [  0  ]  ;", "}", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  . BUFFER _ SIZE )  ;", ". copy ( in ,    out )  ;", "return   out . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["copyToByteArray"], "fileName": "org.springframework.util.FileCopyUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( in    =  =    null )     {", "return    \"  \"  ;", "}", "StringWriter   out    =    new   StringWriter (  )  ;", ". copy ( in ,    out )  ;", "return   out . toString (  )  ;", "}", "METHOD_END"], "methodName": ["copyToString"], "fileName": "org.springframework.util.FileCopyUtils"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    content    =     \" content \"  . getBytes (  )  ;", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream ( content . length )  ;", ". copy ( content ,    out )  ;", "assertTrue ( Arrays . equals ( content ,    out . toByteArray (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["copyFromByteArray"], "fileName": "org.springframework.util.FileCopyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    content    =     \" content \"  . getBytes (  )  ;", "ByteArrayInputStream   in    =    new   ByteArrayInputStream ( content )  ;", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream ( content . length )  ;", "int   count    =     . copy ( in ,    out )  ;", "assertEquals ( content . length ,    count )  ;", "assertTrue ( Arrays . equals ( content ,    out . toByteArray (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["copyFromInputStream"], "fileName": "org.springframework.util.FileCopyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \" content \"  ;", "StringReader   in    =    new   StringReader ( content )  ;", "StringWriter   out    =    new   StringWriter (  )  ;", "int   count    =     . copy ( in ,    out )  ;", "assertEquals ( content . length (  )  ,    count )  ;", "assertEquals ( content ,    out . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["copyFromReader"], "fileName": "org.springframework.util.FileCopyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \" content \"  ;", "StringWriter   out    =    new   StringWriter (  )  ;", ". copy ( content ,    out )  ;", "assertEquals ( content ,    out . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["copyFromString"], "fileName": "org.springframework.util.FileCopyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    content    =     \" content \"  . getBytes (  )  ;", "ByteArrayInputStream   in    =    new   ByteArrayInputStream ( content )  ;", "byte [  ]    result    =     . copyToByteArray ( in )  ;", "assertTrue ( Arrays . equals ( content ,    result )  )  ;", "}", "METHOD_END"], "methodName": ["copyToByteArray"], "fileName": "org.springframework.util.FileCopyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \" content \"  ;", "StringReader   in    =    new   StringReader ( content )  ;", "String   result    =     . copyToString ( in )  ;", "assertEquals ( content ,    result )  ;", "}", "METHOD_END"], "methodName": ["copyToString"], "fileName": "org.springframework.util.FileCopyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( src ,     \" Source   File   must   not   be   null \"  )  ;", "Assert . notNull ( dest ,     \" Destination   File   must   not   be   null \"  )  ;", ". copyRecursively ( src . toPath (  )  ,    dest . toPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["copyRecursively"], "fileName": "org.springframework.util.FileSystemUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( src ,     \" Source   Path   must   not   be   null \"  )  ;", "Assert . notNull ( dest ,     \" Destination   Path   must   not   be   null \"  )  ;", "BasicAttributes   srcAttr    =    s . readAttributes ( src ,    BasicAttributes . class )  ;", "if    ( srcAttr . isDirectory (  )  )     {", "s . walkTree ( src ,    new   SimpleVisitor < Path >  (  )     {", "@ Override", "public   VisitResult   preVisitDirectory ( Path   dir ,    BasicAttributes   attrs )    throws   IOException    {", "s . createDirectories ( dest . resolve ( src . relativize ( dir )  )  )  ;", "return   VisitResult . CONTINUE ;", "}", "@ Override", "public   VisitResult   visit ( Path   file ,    BasicAttributes   attrs )    throws   IOException    {", "s . copy ( file ,    dest . resolve ( src . relativize ( file )  )  ,    StandardCopyOption . REPLACE _ EXISTING )  ;", "return   VisitResult . CONTINUE ;", "}", "}  )  ;", "} else", "if    ( srcAttr . isRegular (  )  )     {", "s . copy ( src ,    dest )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Source      must   denote   a   directory   or   file \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyRecursively"], "fileName": "org.springframework.util.FileSystemUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( root    =  =    null )     {", "return   false ;", "}", "try    {", "return    . deleteRecursively ( root . toPath (  )  )  ;", "}    catch    ( IOException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["deleteRecursively"], "fileName": "org.springframework.util.FileSystemUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( root    =  =    null )     {", "return   false ;", "}", "if    (  !  ( s . exists ( root )  )  )     {", "return   false ;", "}", "s . walkTree ( root ,    new   SimpleVisitor < Path >  (  )     {", "@ Override", "public   VisitResult   visit ( Path   file ,    BasicAttributes   attrs )    throws   IOException    {", "s . delete ( file )  ;", "return   VisitResult . CONTINUE ;", "}", "@ Override", "public   VisitResult   postVisitDirectory ( Path   dir ,    IOException   exc )    throws   IOException    {", "s . delete ( dir )  ;", "return   VisitResult . CONTINUE ;", "}", "}  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["deleteRecursively"], "fileName": "org.springframework.util.FileSystemUtils"}, {"methodBody": ["METHOD_START", "{", "File   src    =    new   File (  \"  .  / tmp / src \"  )  ;", "File   child    =    new   File ( src ,     \" child \"  )  ;", "File   grandchild    =    new   File ( child ,     \" grandchild \"  )  ;", "grandchild . mkdirs (  )  ;", "File   bar    =    new   File ( child ,     \" bar . txt \"  )  ;", "bar . createNewFile (  )  ;", "assertTrue ( src . exists (  )  )  ;", "assertTrue ( child . exists (  )  )  ;", "assertTrue ( grandchild . exists (  )  )  ;", "assertTrue ( bar . exists (  )  )  ;", "File   dest    =    new   File (  \"  .  / dest \"  )  ;", ". copyRecursively ( src ,    dest )  ;", "assertTrue ( dest . exists (  )  )  ;", "assertTrue ( new   File ( dest ,    child . getName (  )  )  . exists (  )  )  ;", ". deleteRecursively ( src )  ;", "assertFalse ( src . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["copyRecursively"], "fileName": "org.springframework.util.FileSystemUtilsTests"}, {"methodBody": ["METHOD_START", "{", "File   root    =    new   File (  \"  .  / tmp / root \"  )  ;", "File   child    =    new   File ( root ,     \" child \"  )  ;", "File   grandchild    =    new   File ( child ,     \" grandchild \"  )  ;", "grandchild . mkdirs (  )  ;", "File   bar    =    new   File ( child ,     \" bar . txt \"  )  ;", "bar . createNewFile (  )  ;", "assertTrue ( root . exists (  )  )  ;", "assertTrue ( child . exists (  )  )  ;", "assertTrue ( grandchild . exists (  )  )  ;", "assertTrue ( bar . exists (  )  )  ;", ". deleteRecursively ( root )  ;", "assertFalse ( root . exists (  )  )  ;", "assertFalse ( child . exists (  )  )  ;", "assertFalse ( grandchild . exists (  )  )  ;", "assertFalse ( bar . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["deleteRecursively"], "fileName": "org.springframework.util.FileSystemUtilsTests"}, {"methodBody": ["METHOD_START", "{", "File   tmp    =    new   File (  \"  .  / tmp \"  )  ;", "if    ( tmp . exists (  )  )     {", ". deleteRecursively ( tmp )  ;", "}", "File   dest    =    new   File (  \"  .  / dest \"  )  ;", "if    ( dest . exists (  )  )     {", ". deleteRecursively ( dest )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.util.FileSystemUtilsTests"}, {"methodBody": ["METHOD_START", "{", "FixedBackOff   backOff    =    new   FixedBackOff (  )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "assertEquals ( FixedBackOff . DEFAULT _ INTERVAL ,    execution . nextBackOff (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["defaultInstance"], "fileName": "org.springframework.util.FixedBackOffTests"}, {"methodBody": ["METHOD_START", "{", "FixedBackOff   backOff    =    new   FixedBackOff (  1  0  0 L ,     1  )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  1  0  0 L ,    execution . nextBackOff (  )  )  ;", "backOff . setInterval (  2  0  0 L )  ;", "backOff . setMaxAttempts (  2  )  ;", "assertEquals (  2  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals ( BackOffExecution . STOP ,    execution . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["liveUpdate"], "fileName": "org.springframework.util.FixedBackOffTests"}, {"methodBody": ["METHOD_START", "{", "FixedBackOff   backOff    =    new   FixedBackOff (  2  0  0 L ,     2  )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  2  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  2  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals ( BackOffExecution . STOP ,    execution . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["maxAttemptsReached"], "fileName": "org.springframework.util.FixedBackOffTests"}, {"methodBody": ["METHOD_START", "{", "FixedBackOff   backOff    =    new   FixedBackOff (  1  0  0 L ,     0 L )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals ( BackOffExecution . STOP ,    execution . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["noAttemptAtAll"], "fileName": "org.springframework.util.FixedBackOffTests"}, {"methodBody": ["METHOD_START", "{", "FixedBackOff   backOff    =    new   FixedBackOff (  1  0  0 L ,     1  )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "BackOffExecution   execution 2     =    backOff . start (  )  ;", "assertEquals (  1  0  0 L ,    execution . nextBackOff (  )  )  ;", "assertEquals (  1  0  0 L ,    execution 2  . nextBackOff (  )  )  ;", "assertEquals ( BackOffExecution . STOP ,    execution . nextBackOff (  )  )  ;", "assertEquals ( BackOffExecution . STOP ,    execution 2  . nextBackOff (  )  )  ;", "}", "METHOD_END"], "methodName": ["startReturnDifferentInstances"], "fileName": "org.springframework.util.FixedBackOffTests"}, {"methodBody": ["METHOD_START", "{", "FixedBackOff   backOff    =    new   FixedBackOff (  2  0  0 L ,     1  0  )  ;", "BackOffExecution   execution    =    backOff . start (  )  ;", "assertEquals (  \" FixedBackOff { interval =  2  0  0  ,    currentAttempts =  0  ,    maxAttempts =  1  0  }  \"  ,    execution . toString (  )  )  ;", "execution . nextBackOff (  )  ;", "assertEquals (  \" FixedBackOff { interval =  2  0  0  ,    currentAttempts =  1  ,    maxAttempts =  1  0  }  \"  ,    execution . toString (  )  )  ;", "execution . nextBackOff (  )  ;", "assertEquals (  \" FixedBackOff { interval =  2  0  0  ,    currentAttempts =  2  ,    maxAttempts =  1  0  }  \"  ,    execution . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStringContent"], "fileName": "org.springframework.util.FixedBackOffTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( instance ,     \" Instance   to   match   must   not   be   null \"  )  ;", "boolean   includesSet    =     !  ( this . includes . isEmpty (  )  )  ;", "boolean   excludesSet    =     !  ( this . excludes . isEmpty (  )  )  ;", "if    (  (  ! includesSet )     &  &     (  ! excludesSet )  )     {", "return   this . matchIfEmpty ;", "}", "boolean   matchIncludes    =    match ( instance ,    this . includes )  ;", "boolean   matchExcludes    =    match ( instance ,    this . excludes )  ;", "if    (  ! includesSet )     {", "return    ! matchExcludes ;", "}", "if    (  ! excludesSet )     {", "return   matchIncludes ;", "}", "return   matchIncludes    &  &     (  ! matchExcludes )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.util.InstanceFilter"}, {"methodBody": ["METHOD_START", "{", "return   instance . equals ( candidate )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.util.InstanceFilter"}, {"methodBody": ["METHOD_START", "{", "for    ( T   candidate    :    candidates )     {", "if    ( match ( i ,    candidate )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.util.InstanceFilter"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  (  (  (  \" filter    '  \"     +    filter )     +     \"  '    should   not   match    \"  )     +    candidate )  ,    filter . match ( candidate )  )  ;", "}", "METHOD_END"], "methodName": ["doNotMatch"], "fileName": "org.springframework.util.InstanceFilterTests"}, {"methodBody": ["METHOD_START", "{", "InstanceFilter < String >    filter    =    new   InstanceFilter <  >  ( null ,    null ,    true )  ;", "match ( filter ,     \" foo \"  )  ;", "match ( filter ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["emptyFilterApplyMatchIfEmpty"], "fileName": "org.springframework.util.InstanceFilterTests"}, {"methodBody": ["METHOD_START", "{", "InstanceFilter < String >    filter    =    new   InstanceFilter <  >  ( null ,    Arrays . asList (  \" First \"  ,     \" Second \"  )  ,    true )  ;", "doNotMatch ( filter ,     \" Second \"  )  ;", "match ( filter ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["excludesFilter"], "fileName": "org.springframework.util.InstanceFilterTests"}, {"methodBody": ["METHOD_START", "{", "InstanceFilter < String >    filter    =    new   InstanceFilter <  >  ( Arrays . asList (  \" foo \"  ,     \" Bar \"  )  ,    Arrays . asList (  \" First \"  ,     \" Second \"  )  ,    true )  ;", "doNotMatch ( filter ,     \" Second \"  )  ;", "match ( filter ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["includesAndExcludesFilters"], "fileName": "org.springframework.util.InstanceFilterTests"}, {"methodBody": ["METHOD_START", "{", "InstanceFilter < String >    filter    =    new   InstanceFilter <  >  ( Arrays . asList (  \" First \"  )  ,    Arrays . asList (  \" First \"  )  ,    true )  ;", "doNotMatch ( filter ,     \" First \"  )  ;", "}", "METHOD_END"], "methodName": ["includesAndExcludesFiltersConflict"], "fileName": "org.springframework.util.InstanceFilterTests"}, {"methodBody": ["METHOD_START", "{", "InstanceFilter < String >    filter    =    new   InstanceFilter <  >  ( Arrays . asList (  \" First \"  ,     \" Second \"  )  ,    null ,    true )  ;", "match ( filter ,     \" Second \"  )  ;", "doNotMatch ( filter ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["includesFilter"], "fileName": "org.springframework.util.InstanceFilterTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  (  (  \" filter    '  \"     +    filter )     +     \"  '    should   match    \"  )     +    candidate )  ,    filter . match ( candidate )  )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.springframework.util.InstanceFilterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . mimeType ;", "}", "METHOD_END"], "methodName": ["getMimeType"], "fileName": "org.springframework.util.InvalidMimeTypeException"}, {"methodBody": ["METHOD_START", "{", "return   key . toLowerCase ( getLocale (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertKey"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMap"}, {"methodBody": ["METHOD_START", "{", "return   this . locale ;", "}", "METHOD_END"], "methodName": ["getLocale"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMap"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["removeEldestEntry"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMap"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" value 1  \"  ,    map . computeIfAbsent (  \" key \"  ,     (    key )     -  >     \" value 1  \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    map . computeIfAbsent (  \" KEY \"  ,     (    key )     -  >     \" value 2  \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    map . computeIfAbsent (  \" Key \"  ,     (    key )     -  >     \" value 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["computeIfAbsentWithComputedValue"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMapTests"}, {"methodBody": ["METHOD_START", "{", "map . put (  \" key \"  ,     \" value 1  \"  )  ;", "map . put (  \" KEY \"  ,     \" value 2  \"  )  ;", "map . put (  \" Key \"  ,     \" value 3  \"  )  ;", "assertEquals (  \" value 3  \"  ,    map . computeIfAbt (  \" key \"  ,     (    key )     -  >     \" value 1  \"  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . computeIfAbt (  \" KEY \"  ,     (    key )     -  >     \" value 2  \"  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . computeIfAbt (  \" Key \"  ,     (    key )     -  >     \" value 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["computeIfAbsentWithExistingValue"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMapTests"}, {"methodBody": ["METHOD_START", "{", "map . put (  \" key \"  ,     \" value 1  \"  )  ;", "map . put (  \" KEY \"  ,     \" value 2  \"  )  ;", "map . put (  \" Key \"  ,     \" value 3  \"  )  ;", "assertEquals (  \" value 3  \"  ,    map . getOrDefault (  \" key \"  ,     \" N \"  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . getOrDefault (  \" KEY \"  ,     \" N \"  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . getOrDefault (  \" Key \"  ,     \" N \"  )  )  ;", "assertEquals (  \" N \"  ,    map . getOrDefault (  \" keeeey \"  ,     \" N \"  )  )  ;", "assertEquals (  \" N \"  ,    map . getOrDefault ( new   Object (  )  ,     \" N \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getOrDefault"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMapTests"}, {"methodBody": ["METHOD_START", "{", "map . put (  \" key \"  ,    null )  ;", "map . put (  \" KEY \"  ,    null )  ;", "map . put (  \" Key \"  ,    null )  ;", "assertNull ( map . getOrDefault (  \" key \"  ,     \" N \"  )  )  ;", "assertNull ( map . getOrDefault (  \" KEY \"  ,     \" N \"  )  )  ;", "assertNull ( map . getOrDefault (  \" Key \"  ,     \" N \"  )  )  ;", "assertEquals (  \" N \"  ,    map . getOrDefault (  \" keeeey \"  ,     \" N \"  )  )  ;", "assertEquals (  \" N \"  ,    map . getOrDefault ( new   Object (  )  ,     \" N \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getOrDefaultWithNullValue"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMapTests"}, {"methodBody": ["METHOD_START", "{", "map . put (  \" key \"  ,     \" value 1  \"  )  ;", "< String >    copy    =    map . clone (  )  ;", "assertEquals ( map . getLocale (  )  ,    copy . getLocale (  )  )  ;", "assertEquals (  \" value 1  \"  ,    map . get (  \" key \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    map . get (  \" KEY \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    map . get (  \" Key \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    copy . get (  \" key \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    copy . get (  \" KEY \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    copy . get (  \" Key \"  )  )  ;", "copy . put (  \" Key \"  ,     \" value 2  \"  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals (  1  ,    copy . size (  )  )  ;", "assertEquals (  \" value 1  \"  ,    map . get (  \" key \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    map . get (  \" KEY \"  )  )  ;", "assertEquals (  \" value 1  \"  ,    map . get (  \" Key \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    copy . get (  \" key \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    copy . get (  \" KEY \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    copy . get (  \" Key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mapClone"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMapTests"}, {"methodBody": ["METHOD_START", "{", "map . put (  \" key \"  ,     \" value 1  \"  )  ;", "map . put (  \" key \"  ,     \" value 2  \"  )  ;", "map . put (  \" key \"  ,     \" value 3  \"  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . get (  \" key \"  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . get (  \" KEY \"  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . get (  \" Key \"  )  )  ;", "assertTrue ( map . containsKey (  \" key \"  )  )  ;", "assertTrue ( map . containsKey (  \" KEY \"  )  )  ;", "assertTrue ( map . containsKey (  \" Key \"  )  )  ;", "assertTrue ( map . keySet (  )  . contains (  \" key \"  )  )  ;", "assertTrue ( map . keySet (  )  . contains (  \" KEY \"  )  )  ;", "assertTrue ( map . keySet (  )  . contains (  \" Key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["putAndGet"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMapTests"}, {"methodBody": ["METHOD_START", "{", "map . put (  \" key \"  ,     \" value 1  \"  )  ;", "map . put (  \" KEY \"  ,     \" value 2  \"  )  ;", "map . put (  \" Key \"  ,     \" value 3  \"  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . get (  \" key \"  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . get (  \" KEY \"  )  )  ;", "assertEquals (  \" value 3  \"  ,    map . get (  \" Key \"  )  )  ;", "assertTrue ( map . containsKey (  \" key \"  )  )  ;", "assertTrue ( map . containsKey (  \" KEY \"  )  )  ;", "assertTrue ( map . containsKey (  \" Key \"  )  )  ;", "assertTrue ( map . keySet (  )  . contains (  \" key \"  )  )  ;", "assertTrue ( map . keySet (  )  . contains (  \" KEY \"  )  )  ;", "assertTrue ( map . keySet (  )  . contains (  \" Key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["putWithOverlappingKeys"], "fileName": "org.springframework.util.LinkedCaseInsensitiveMapTests"}, {"methodBody": ["METHOD_START", "{", "LinkedMultiValueMap < K ,    V >    copy    =    new   LinkedMultiValueMap <  >  ( this . targetMap . size (  )  )  ;", "this . targetMap . forEach (  (    key ,    value )     -  >    copy . put ( key ,    new   LinkedList <  >  ( value )  )  )  ;", "return   copy ;", "}", "METHOD_END"], "methodName": ["deepCopy"], "fileName": "org.springframework.util.LinkedMultiValueMap"}, {"methodBody": ["METHOD_START", "{", "map . add (  \" key \"  ,     \" value 1  \"  )  ;", "map . add (  \" key \"  ,     \" value 2  \"  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "List < String >    expected    =    new   ArrayList <  >  (  2  )  ;", "expected . add (  \" value 1  \"  )  ;", "expected . add (  \" value 2  \"  )  ;", "assertEquals ( expected ,    map . get (  \" key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.springframework.util.LinkedMultiValueMapTests"}, {"methodBody": ["METHOD_START", "{", "map . add (  \" key \"  ,     \" value 1  \"  )  ;", "map . addAll (  \" key \"  ,    Arrays . asList (  \" value 2  \"  ,     \" value 3  \"  )  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "List < String >    expected    =    new   ArrayList <  >  (  2  )  ;", "expected . add (  \" value 1  \"  )  ;", "expected . add (  \" value 2  \"  )  ;", "expected . add (  \" value 3  \"  )  ;", "assertEquals ( expected ,    map . get (  \" key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.springframework.util.LinkedMultiValueMapTests"}, {"methodBody": ["METHOD_START", "{", "map . set (  \" key 1  \"  ,     \" value 1  \"  )  ;", "assertEquals ( map ,    map )  ;", "MultiValueMap < String ,    String >    o 1     =    new    <  >  (  )  ;", "o 1  . set (  \" key 1  \"  ,     \" value 1  \"  )  ;", "assertEquals ( map ,    o 1  )  ;", "assertEquals ( o 1  ,    map )  ;", "Map < String ,    List < String >  >    o 2     =    new   HashMap <  >  (  )  ;", "o 2  . put (  \" key 1  \"  ,    Collections . singletonList (  \" value 1  \"  )  )  ;", "assertEquals ( map ,    o 2  )  ;", "assertEquals ( o 2  ,    map )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.springframework.util.LinkedMultiValueMapTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    values    =    new   ArrayList <  >  (  2  )  ;", "values . add (  \" value 1  \"  )  ;", "values . add (  \" value 2  \"  )  ;", "map . put (  \" key \"  ,    values )  ;", "assertEquals (  \" value 1  \"  ,    map . getFirst (  \" key \"  )  )  ;", "assertNull ( map . getFirst (  \" other \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getFirst"], "fileName": "org.springframework.util.LinkedMultiValueMapTests"}, {"methodBody": ["METHOD_START", "{", "map . set (  \" key \"  ,     \" value 1  \"  )  ;", "map . set (  \" key \"  ,     \" value 2  \"  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals ( Collections . singletonList (  \" value 2  \"  )  ,    map . get (  \" key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.util.LinkedMultiValueMapTests"}, {"methodBody": ["METHOD_START", "{", "String   targetMethod    =    getTargetMethod (  )  ;", "Object [  ]    arguments    =    getArguments (  )  ;", "int   argCount    =    arguments . length ;", "Class <  ?  >    targetClass    =    getTargetClass (  )  ;", "Assert . state (  ( targetClass    !  =    null )  ,     \" No   target   class   set \"  )  ;", "Method [  ]    candidates    =    ReflectionUtils . getAllDeclaredMethods ( targetClass )  ;", "int   minTypeDiffWeight    =    Integer . MAX _ VALUE ;", "Method   matchingMethod    =    null ;", "for    ( Method   candidate    :    candidates )     {", "if    ( candidate . getName (  )  . equals ( targetMethod )  )     {", "Class <  ?  >  [  ]    paramTypes    =    candidate . getParameterTypes (  )  ;", "if    (  ( paramTypes . length )     =  =    argCount )     {", "int   typeDiffWeight    =     . getTypeDifferenceWeight ( paramTypes ,    arguments )  ;", "if    ( typeDiffWeight    <    minTypeDiffWeight )     {", "minTypeDiffWeight    =    typeDiffWeight ;", "matchingMethod    =    candidate ;", "}", "}", "}", "}", "return   matchingMethod ;", "}", "METHOD_END"], "methodName": ["findMatchingMethod"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "return    ( this . arguments )     !  =    null    ?    this . arguments    :    new   Object [  0  ]  ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . methodObject )     =  =    null )     {", "throw   new   IllegalStateException (  \" prepare (  )    must   be   called   prior   to   invoke (  )    on    \"  )  ;", "}", "return   this . methodObject ;", "}", "METHOD_END"], "methodName": ["getPreparedMethod"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "return   this . targetClass ;", "}", "METHOD_END"], "methodName": ["getTargetClass"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "return   this . targetMethod ;", "}", "METHOD_END"], "methodName": ["getTargetMethod"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "return   this . targetObject ;", "}", "METHOD_END"], "methodName": ["getTargetObject"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( paTypes . length )  ;    i +  +  )     {", "if    (  !  ( ClassUtils . isAssignableValue ( paTypes [ i ]  ,    args [ i ]  )  )  )     {", "return   Integer . MAX _ VALUE ;", "}", "if    (  ( args [ i ]  )     !  =    null )     {", "Class <  ?  >    paType    =    paTypes [ i ]  ;", "Class <  ?  >    superClass    =    args [ i ]  . getClass (  )  . getSuperclass (  )  ;", "while    ( superClass    !  =    null )     {", "if    ( paType . equals ( superClass )  )     {", "result    =    result    +     2  ;", "superClass    =    null ;", "} else", "if    ( ClassUtils . isAssignable ( paType ,    superClass )  )     {", "result    =    result    +     2  ;", "superClass    =    superClass . getSuperclass (  )  ;", "} else    {", "superClass    =    null ;", "}", "}", "if    ( paType . isInterface (  )  )     {", "result    =    result    +     1  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getTypeDifferenceWeight"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "Object   targetObject    =    getTargetObject (  )  ;", "prepared    =    getPrepared (  )  ;", "if    (  ( targetObject    =  =    null )     &  &     (  !  ( Modifier . isStatic ( prepared . getModifiers (  )  )  )  )  )     {", "throw   new   IllegalArgumentException (  \" Target   method   must   not   be   non - static   without   a   target \"  )  ;", "}", "ReflectionUtils . makeAccessible ( prepared )  ;", "return   prepared . invoke ( targetObject ,    getArguments (  )  )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "return    ( this . methodObject )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isPrepared"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . staticMethod )     !  =    null )     {", "int   lastDotIndex    =    this . staticMethod . lastIndexOf (  '  .  '  )  ;", "if    (  ( lastDotIndex    =  =     (  -  1  )  )     |  |     ( lastDotIndex    =  =     ( this . staticMethod . length (  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" staticMethod   must   be   a   fully   qualified   class   plus   method   name :     \"     +     \" e . g .     ' example . MyExampleClass . myExampleMethod '  \"  )  )  ;", "}", "String   className    =    this . staticMethod . substring (  0  ,    lastDotIndex )  ;", "String   methodName    =    this . staticMethod . substring (  ( lastDotIndex    +     1  )  )  ;", "this . targetClass    =    resolveClassName ( className )  ;", "this . targetMethod    =    methodName ;", "}", "Class <  ?  >    targetClass    =    getTargetClass (  )  ;", "String   targetMethod    =    getTargetMethod (  )  ;", "Assert . notNull ( targetClass ,     \" Either    ' targetClass '    or    ' targetObject '    is   required \"  )  ;", "Assert . notNull ( targetMethod ,     \" Property    ' targetMethod '    is   required \"  )  ;", "Object [  ]    arguments    =    getArguments (  )  ;", "Class <  ?  >  [  ]    argTypes    =    new   Class <  ?  >  [ arguments . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( arguments . length )  ;     +  + i )     {", "argTypes [ i ]     =     (  ( arguments [ i ]  )     !  =    null )     ?    arguments [ i ]  . getClass (  )     :    Object . class ;", "}", "try    {", "this . methodObject    =    targetClass . getMethod ( targetMethod ,    argTypes )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "this . methodObject    =    findMatchingMethod (  )  ;", "if    (  ( this . methodObject )     =  =    null )     {", "throw   ex ;", "}", "}", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . forName ( className ,    ClassUtils . getDefaultClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveClassName"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "this . arguments    =    arguments ;", "}", "METHOD_END"], "methodName": ["setArguments"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "this . staticMethod    =    staticMethod ;", "}", "METHOD_END"], "methodName": ["setStaticMethod"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "this . targetClass    =    targetClass ;", "}", "METHOD_END"], "methodName": ["setTargetClass"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "this . targetMethod    =    targetMethod ;", "}", "METHOD_END"], "methodName": ["setTargetMethod"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "this . targetObject    =    targetObject ;", "if    ( targetObject    !  =    null )     {", "this . targetClass    =    targetObject . getClass (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setTargetObject"], "fileName": "org.springframework.util.MethodInvoker"}, {"methodBody": ["METHOD_START", "{", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetObject ( new    . Greeter (  )  )  ;", "methodInvoker . setTargetMethod (  \" greet \"  )  ;", "methodInvoker . setArguments ( new    . Customer (  )  )  ;", "methodInvoker . prepare (  )  ;", "String   greeting    =     (  ( String )     ( methodInvoker . invoke (  )  )  )  ;", "assertEquals (  \" customer :    good   day \"  ,    greeting )  ;", "}", "METHOD_END"], "methodName": ["customerWithMethodInvoker"], "fileName": "org.springframework.util.MethodInvokerTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvokerTests . TestClass 1    tc 1     =    new   MethodInvokerTests . TestClass 1  (  )  ;", "MethodInvoker   mi    =    new   MethodInvoker (  )  ;", "mi . setTargetObject ( tc 1  )  ;", "mi . setTargetMethod (  \" method 1  \"  )  ;", "mi . prepare (  )  ;", "Integer   i    =     (  ( Integer )     ( mi . invoke (  )  )  )  ;", "assertEquals (  1  ,    i . intValue (  )  )  ;", "tc 1     =    new   MethodInvokerTests . TestClass 1  (  )  ;", "mi    =    new   MethodInvoker (  )  ;", "mi . setTargetObject ( tc 1  )  ;", "mi . setTargetMethod (  \" method 1  \"  )  ;", "mi . setArguments (  (  ( Object [  ]  )     ( null )  )  )  ;", "mi . prepare (  )  ;", "i    =     (  ( Integer )     ( mi . invoke (  )  )  )  ;", "assertEquals (  1  ,    i . intValue (  )  )  ;", "mi    =    new   MethodInvoker (  )  ;", "mi . setTargetClass ( MethodInvokerTests . TestClass 1  . class )  ;", "mi . setTargetMethod (  \" supertypes \"  )  ;", "mi . setArguments ( new   ArrayList <  >  (  )  ,    new   ArrayList <  >  (  )  ,     \" hello \"  )  ;", "mi . prepare (  )  ;", "assertEquals (  \" hello \"  ,    mi . invoke (  )  )  ;", "mi    =    new   MethodInvoker (  )  ;", "mi . setTargetClass ( MethodInvokerTests . TestClass 1  . class )  ;", "mi . setTargetMethod (  \" supertypes 2  \"  )  ;", "mi . setArguments ( new   ArrayList <  >  (  )  ,    new   ArrayList <  >  (  )  ,     \" hello \"  ,     \" bogus \"  )  ;", "mi . prepare (  )  ;", "assertEquals (  \" hello \"  ,    mi . invoke (  )  )  ;", "mi    =    new   MethodInvoker (  )  ;", "mi . setTargetClass ( MethodInvokerTests . TestClass 1  . class )  ;", "mi . setTargetMethod (  \" supertypes 2  \"  )  ;", "mi . setArguments ( new   ArrayList <  >  (  )  ,    new   ArrayList <  >  (  )  ,     \" hello \"  ,    Boolean . TRUE )  ;", "exception . expect ( NoSuchMethodException . class )  ;", "mi . prepare (  )  ;", "}", "METHOD_END"], "methodName": ["plainMethodInvoker"], "fileName": "org.springframework.util.MethodInvokerTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetObject ( new    . Greeter (  )  )  ;", "methodInvoker . setTargetMethod (  \" greet \"  )  ;", "methodInvoker . setArguments ( new    . Purchaser (  )  )  ;", "methodInvoker . prepare (  )  ;", "String   greeting    =     (  ( String )     ( methodInvoker . invoke (  )  )  )  ;", "assertEquals (  \" purchaser :    hello \"  ,    greeting )  ;", "}", "METHOD_END"], "methodName": ["purchaserWithMethodInvoker"], "fileName": "org.springframework.util.MethodInvokerTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetObject ( new    . Greeter (  )  )  ;", "methodInvoker . setTargetMethod (  \" greet \"  )  ;", "methodInvoker . setArguments ( new    . Regular (  \" Kotter \"  )  )  ;", "methodInvoker . prepare (  )  ;", "String   greeting    =     (  ( String )     ( methodInvoker . invoke (  )  )  )  ;", "assertEquals (  \" regular :    welcome   back   Kotter \"  ,    greeting )  ;", "}", "METHOD_END"], "methodName": ["regularWithMethodInvoker"], "fileName": "org.springframework.util.MethodInvokerTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetObject ( new    . Greeter (  )  )  ;", "methodInvoker . setTargetMethod (  \" greet \"  )  ;", "methodInvoker . setArguments ( new    . Salesman (  )  )  ;", "methodInvoker . prepare (  )  ;", "String   greeting    =     (  ( String )     ( methodInvoker . invoke (  )  )  )  ;", "assertEquals (  \" greetable :    how   are   sales ?  \"  ,    greeting )  ;", "}", "METHOD_END"], "methodName": ["salesmanWithMethodInvoker"], "fileName": "org.springframework.util.MethodInvokerTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetObject ( new    . Greeter (  )  )  ;", "methodInvoker . setTargetMethod (  \" greet \"  )  ;", "methodInvoker . setArguments ( new    . Shopper (  )  )  ;", "methodInvoker . prepare (  )  ;", "String   greeting    =     (  ( String )     ( methodInvoker . invoke (  )  )  )  ;", "assertEquals (  \" purchaser :    may   I   help   you ?  \"  ,    greeting )  ;", "}", "METHOD_END"], "methodName": ["shopperWithMethodInvoker"], "fileName": "org.springframework.util.MethodInvokerTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetObject ( new    . Greeter (  )  )  ;", "methodInvoker . setTargetMethod (  \" greet \"  )  ;", "methodInvoker . setArguments (  \" no   match \"  )  ;", "exception . expect ( NoSuchMethodException . class )  ;", "methodInvoker . prepare (  )  ;", "}", "METHOD_END"], "methodName": ["stringWithMethodInvoker"], "fileName": "org.springframework.util.MethodInvokerTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetObject ( new    . Greeter (  )  )  ;", "methodInvoker . setTargetMethod (  \" greet \"  )  ;", "methodInvoker . setArguments ( new    . VIP (  \" Fonzie \"  )  )  ;", "methodInvoker . prepare (  )  ;", "String   greeting    =     (  ( String )     ( methodInvoker . invoke (  )  )  )  ;", "assertEquals (  \" regular :    whassup   dude ?  \"  ,    greeting )  ;", "}", "METHOD_END"], "methodName": ["vipWithMethodInvoker"], "fileName": "org.springframework.util.MethodInvokerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   LinkedHashMap <  >  ( parameters )  ;", "map . put (  . PARAM _ CHARSET ,    charset . name (  )  )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["addCharsetParameter"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "builder . append ( this . type )  ;", "builder . append (  '  /  '  )  ;", "builder . append ( this . subtype )  ;", "appendTo ( this . paters ,    builder )  ;", "}", "METHOD_END"], "methodName": ["appendTo"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "map . forEach (  (    key ,    val )     -  >     {", "builder . append (  '  ;  '  )  ;", "builder . append ( key )  ;", "builder . append (  '  =  '  )  ;", "builder . append ( val )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["appendTo"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "Assert . hasLength ( attribute ,     \"  ' attribute '    must   not   be   empty \"  )  ;", "Assert . hasLength ( value ,     \"  ' value '    must   not   be   empty \"  )  ;", "checkToken ( attribute )  ;", "if    (  . PARAM _ CHARSET . equals ( attribute )  )     {", "value    =    unquote ( value )  ;", "Charset . forName ( value )  ;", "} else", "if    (  !  ( isQuotedString ( value )  )  )     {", "checkToken ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["checkParameters"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( token . length (  )  )  ;    i +  +  )     {", "char   ch    =    token . charAt ( i )  ;", "if    (  !  (  . TOKEN . get ( ch )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Invalid   token   character    '  \"     +    ch )     +     \"  \\  '    in   token    \\  \"  \"  )     +    token )     +     \"  \\  \"  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkToken"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "String   charset    =    getParameter ( MimeType . PARAM _ CHARSET )  ;", "return   charset    !  =    null    ?    Charset . forName ( unquote ( charset )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "return   this . parameters . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getParameter"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "return   this . parameters ;", "}", "METHOD_END"], "methodName": ["getParameters"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "return   this . subtype ;", "}", "METHOD_END"], "methodName": ["getSubtype"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "if    ( other    =  =    null )     {", "return   false ;", "}", "if    ( isWildcardType (  )  )     {", "return   true ;", "} else", "if    ( getType (  )  . equals ( other . getType (  )  )  )     {", "if    ( getSubtype (  )  . equals ( other . getSubtype (  )  )  )     {", "return   true ;", "}", "if    ( isWildcardSubtype (  )  )     {", "int   thisPlusIdx    =    getSubtype (  )  . lastIndexOf (  '  +  '  )  ;", "if    ( thisPlusIdx    =  =     (  -  1  )  )     {", "return   true ;", "} else    {", "int   otherPlusIdx    =    other . getSubtype (  )  . lastIndexOf (  '  +  '  )  ;", "if    ( otherPlusIdx    !  =     (  -  1  )  )     {", "String   thisSubtypeNoSuffix    =    getSubtype (  )  . substring (  0  ,    thisPlusIdx )  ;", "String   thisSubtypeSuffix    =    getSubtype (  )  . substring (  ( thisPlusIdx    +     1  )  )  ;", "String   otherSubtypeSuffix    =    other . getSubtype (  )  . substring (  ( otherPlusIdx    +     1  )  )  ;", "if    (  ( thisSubtypeSuffix . equals ( otherSubtypeSuffix )  )     &  &     (  . WILDCARD _ TYPE . equals ( thisSubtypeNoSuffix )  )  )     {", "return   true ;", "}", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["includes"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "if    ( other    =  =    null )     {", "return   false ;", "}", "if    (  ( isWildcardType (  )  )     |  |     ( other . isWildcardType (  )  )  )     {", "return   true ;", "} else", "if    ( getType (  )  . equals ( other . getType (  )  )  )     {", "if    ( getSubtype (  )  . equals ( other . getSubtype (  )  )  )     {", "return   true ;", "}", "if    (  ( isWildcardSubtype (  )  )     |  |     ( other . isWildcardSubtype (  )  )  )     {", "int   thisPlusIdx    =    getSubtype (  )  . lastIndexOf (  '  +  '  )  ;", "int   otherPlusIdx    =    other . getSubtype (  )  . lastIndexOf (  '  +  '  )  ;", "if    (  ( thisPlusIdx    =  =     (  -  1  )  )     &  &     ( otherPlusIdx    =  =     (  -  1  )  )  )     {", "return   true ;", "} else", "if    (  ( thisPlusIdx    !  =     (  -  1  )  )     &  &     ( otherPlusIdx    !  =     (  -  1  )  )  )     {", "String   thisSubtypeNoSuffix    =    getSubtype (  )  . substring (  0  ,    thisPlusIdx )  ;", "String   otherSubtypeNoSuffix    =    other . getSubtype (  )  . substring (  0  ,    otherPlusIdx )  ;", "String   thisSubtypeSuffix    =    getSubtype (  )  . substring (  ( thisPlusIdx    +     1  )  )  ;", "String   otherSubtypeSuffix    =    other . getSubtype (  )  . substring (  ( otherPlusIdx    +     1  )  )  ;", "if    (  ( thisSubtypeSuffix . equals ( otherSubtypeSuffix )  )     &  &     (  (  . WILDCARD _ TYPE . equals ( thisSubtypeNoSuffix )  )     |  |     (  . WILDCARD _ TYPE . equals ( otherSubtypeNoSuffix )  )  )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isCompatibleWith"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( isWildcardType (  )  )  )     &  &     (  !  ( isWildcardSubtype (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isConcrete"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( s . length (  )  )     <     2  )     {", "return   false ;", "} else    {", "return    (  ( s . startsWith (  \"  \\  \"  \"  )  )     &  &     ( s . endsWith (  \"  \\  \"  \"  )  )  )     |  |     (  ( s . startsWith (  \"  '  \"  )  )     &  &     ( s . endsWith (  \"  '  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isQuotedString"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "return    ( MimeType . WILDCARD _ TYPE . equals ( getSubtype (  )  )  )     |  |     ( getSubtype (  )  . startsWith (  \"  *  +  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isWildcardSubtype"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "return   MimeType . WILDCARD _ TYPE . equals ( getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isWildcardType"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . parameters . size (  )  )     !  =     ( other . parameters . size (  )  )  )     {", "return   false ;", "}", "for    ( Map . Entry < String ,    String >    entry    :    this . parameters . entrySet (  )  )     {", "String   key    =    entry . getKey (  )  ;", "if    (  !  ( other . parameters . containsKey ( key )  )  )     {", "return   false ;", "}", "if    (  . PARAM _ CHARSET . equals ( key )  )     {", "if    (  !  ( ObjectUtils . nullSafeEquals ( getCharset (  )  ,    other . getCharset (  )  )  )  )     {", "return   false ;", "}", "} else", "if    (  !  ( ObjectUtils . nullSafeEquals ( entry . getValue (  )  ,    other . parameters . get ( key )  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["parametersAreEqual"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "return   isQuotedString ( s )     ?    s . substring (  1  ,     (  ( s . length (  )  )     -     1  )  )     :    s ;", "}", "METHOD_END"], "methodName": ["unquote"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "return   MimeTypeUtils . parseMimeType ( value )  ;", "}", "METHOD_END"], "methodName": ["valueOf"], "fileName": "org.springframework.util.MimeType"}, {"methodBody": ["METHOD_START", "{", "MimeType   audioBasic    =    new   MimeType (  \" audio \"  ,     \" basic \"  )  ;", "MimeType   audio    =    new   MimeType (  \" audio \"  )  ;", "MimeType   audioWave    =    new   MimeType (  \" audio \"  ,     \" wave \"  )  ;", "MimeType   audioBasicLevel    =    new   MimeType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" level \"  ,     \"  1  \"  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    audioBasic . compareTo ( audioBasic )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    audio . compareTo ( audio )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    audioBasicLevel . compareTo ( audioBasicLevel )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( audioBasicLevel . compareTo ( audio )  )     >     0  )  )  ;", "List < MimeType >    expected    =    new   ArrayList <  >  (  )  ;", "expected . add ( audio )  ;", "expected . add ( audioBasic )  ;", "expected . add ( audioBasicLevel )  ;", "expected . add ( audioWave )  ;", "List < MimeType >    result    =    new   ArrayList <  >  ( expected )  ;", "Random   rnd    =    new   Random (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "Collections . shuffle ( result ,    rnd )  ;", "Collections . sort ( result )  ;", "for    ( int   j    =     0  ;    j    <     ( result . size (  )  )  ;    j +  +  )     {", "assertSame (  (  (  (  \" Invalid   media   type   at    \"     +    j )     +     \"  ,    run    \"  )     +    i )  ,    expected . get ( j )  ,    result . get ( j )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   m 1     =    new   MimeType (  \" audio \"  ,     \" basic \"  )  ;", "MimeType   m 2     =    new   MimeType (  \" Audio \"  ,     \" Basic \"  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    m 1  . compareTo ( m 2  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    m 2  . compareTo ( m 1  )  )  ;", "m 1     =    new   MimeType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  ;", "m 2     =    new   MimeType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" Foo \"  ,     \" bar \"  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    m 1  . compareTo ( m 2  )  )  ;", "assertEquals (  \" Invalid   comparison   result \"  ,     0  ,    m 2  . compareTo ( m 1  )  )  ;", "m 1     =    new   MimeType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  ;", "m 2     =    new   MimeType (  \" audio \"  ,     \" basic \"  ,    Collections . singletonMap (  \" foo \"  ,     \" Bar \"  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( m 1  . compareTo ( m 2  )  )     !  =     0  )  )  ;", "assertTrue (  \" Invalid   comparison   result \"  ,     (  ( m 2  . compareTo ( m 1  )  )     !  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["compareToCaseSensitivity"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   m 1     =    new   MimeType (  \" text \"  ,     \" plain \"  ,    Collections . singletonMap (  \" charset \"  ,     \" UTF -  8  \"  )  )  ;", "MimeType   m 2     =    new   MimeType (  \" text \"  ,     \" plain \"  ,    Collections . singletonMap (  \" charset \"  ,     \" utf -  8  \"  )  )  ;", "assertEquals ( m 1  ,    m 2  )  ;", "assertEquals ( m 2  ,    m 1  )  ;", "assertEquals (  0  ,    m 1  . compareTo ( m 2  )  )  ;", "assertEquals (  0  ,    m 2  . compareTo ( m 1  )  )  ;", "}", "METHOD_END"], "methodName": ["equalsIsCaseInsensitiveForCharsets"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   textPlain    =    MimeTypeUtils . TEXT _ PLAIN ;", "assertTrue (  \" Equal   types   is   not   inclusive \"  ,    textPlain . includes ( textPlain )  )  ;", "MimeType   allText    =    new   MimeType (  \" text \"  )  ;", "assertTrue (  \" All   subtypes   is   not   inclusive \"  ,    allText . includes ( textPlain )  )  ;", "assertFalse (  \" All   subtypes   is   inclusive \"  ,    textPlain . includes ( allText )  )  ;", "assertTrue (  \" All   types   is   not   inclusive \"  ,    MimeTypeUtils . ALL . includes ( textPlain )  )  ;", "assertFalse (  \" All   types   is   inclusive \"  ,    textPlain . includes ( MimeTypeUtils . ALL )  )  ;", "assertTrue (  \" All   types   is   not   inclusive \"  ,    MimeTypeUtils . ALL . includes ( textPlain )  )  ;", "assertFalse (  \" All   types   is   inclusive \"  ,    textPlain . includes ( MimeTypeUtils . ALL )  )  ;", "MimeType   applicationSoapXml    =    new   MimeType (  \" application \"  ,     \" soap + xml \"  )  ;", "MimeType   applicationWildcardXml    =    new   MimeType (  \" application \"  ,     \"  *  + xml \"  )  ;", "MimeType   suffixXml    =    new   MimeType (  \" application \"  ,     \" x . y + z + xml \"  )  ;", "assertTrue ( applicationSoapXml . includes ( applicationSoapXml )  )  ;", "assertTrue ( applicationWildcardXml . includes ( applicationWildcardXml )  )  ;", "assertTrue ( applicationWildcardXml . includes ( suffixXml )  )  ;", "assertTrue ( applicationWildcardXml . includes ( applicationSoapXml )  )  ;", "assertFalse ( applicationSoapXml . includes ( applicationWildcardXml )  )  ;", "assertFalse ( suffixXml . includes ( applicationWildcardXml )  )  ;", "assertFalse ( applicationWildcardXml . includes ( MimeTypeUtils . APPLICATION _ JSON )  )  ;", "}", "METHOD_END"], "methodName": ["includes"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   textPlain    =    MimeTypeUtils . TEXT _ PLAIN ;", "assertTrue (  \" Equal   types   is   not   compatible \"  ,    textPlain . isCompatibleWith ( textPlain )  )  ;", "MimeType   allText    =    new   MimeType (  \" text \"  )  ;", "assertTrue (  \" All   subtypes   is   not   compatible \"  ,    allText . isCompatibleWith ( textPlain )  )  ;", "assertTrue (  \" All   subtypes   is   not   compatible \"  ,    textPlain . isCompatibleWith ( allText )  )  ;", "assertTrue (  \" All   types   is   not   compatible \"  ,    MimeTypeUtils . ALL . isCompatibleWith ( textPlain )  )  ;", "assertTrue (  \" All   types   is   not   compatible \"  ,    textPlain . isCompatibleWith ( MimeTypeUtils . ALL )  )  ;", "assertTrue (  \" All   types   is   not   compatible \"  ,    MimeTypeUtils . ALL . isCompatibleWith ( textPlain )  )  ;", "assertTrue (  \" All   types   is   compatible \"  ,    textPlain . isCompatibleWith ( MimeTypeUtils . ALL )  )  ;", "MimeType   applicationSoapXml    =    new   MimeType (  \" application \"  ,     \" soap + xml \"  )  ;", "MimeType   applicationWildcardXml    =    new   MimeType (  \" application \"  ,     \"  *  + xml \"  )  ;", "MimeType   suffixXml    =    new   MimeType (  \" application \"  ,     \" x . y + z + xml \"  )  ;", "assertTrue ( applicationSoapXml . isCompatibleWith ( applicationSoapXml )  )  ;", "assertTrue ( applicationWildcardXml . isCompatibleWith ( applicationWildcardXml )  )  ;", "assertTrue ( applicationWildcardXml . isCompatibleWith ( suffixXml )  )  ;", "assertTrue ( applicationWildcardXml . isCompatibleWith ( applicationSoapXml )  )  ;", "assertTrue ( applicationSoapXml . isCompatibleWith ( applicationWildcardXml )  )  ;", "assertTrue ( suffixXml . isCompatibleWith ( applicationWildcardXml )  )  ;", "assertFalse ( applicationWildcardXml . isCompatibleWith ( MimeTypeUtils . APPLICATION _ JSON )  )  ;", "}", "METHOD_END"], "methodName": ["isCompatible"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" text / html ;    charset = iso -  8  8  5  9  -  1  \"  ;", "mimeType    =     . valueOf ( s )  ;", "assertEquals (  \" Invalid   type \"  ,     \" text \"  ,    mimeType . getType (  )  )  ;", "assertEquals (  \" Invalid   subtype \"  ,     \" html \"  ,    mimeType . getSubtype (  )  )  ;", "assertEquals (  \" Invalid   charset \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  ,    mimeType . getCharset (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseCharset"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" audio /  *  \"  ;", "mimeType    =    Utils . parse ( s )  ;", "assertEquals (  \" Invalid   type \"  ,     \" audio \"  ,    mimeType . getType (  )  )  ;", "assertEquals (  \" Invalid   subtype \"  ,     \"  *  \"  ,    mimeType . getSubtype (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeType"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" audio /  *  ;  = value \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeEmptyParameterAttribute"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" audio /  *  ; attr =  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeEmptyParameterValue"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" text / html ;    charset = foo - bar \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeIllegalCharset"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" audio /  *  ; attr <  = value \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeIllegalParameterAttribute"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" audio /  *  ; attr = v > alue \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeIllegalParameterValue"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" audio /  *  ; attr =  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeIllegalQuotedParameterValue"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" audio / basic )  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeIllegalSubtype"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" audio (  / basic \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeIllegalType"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \"                 ; a = b \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeMissingTypeAndSubtype"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" audio \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeNoSubtype"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \" audio /  \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeNoSubtypeSlash"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   mimeType    =    MimeTypeUtils . parseMimeType (  \" audio /  *  ; attr =  \\  \" v > alue \\  \"  \"  )  ;", "assertEquals (  \"  \\  \" v > alue \\  \"  \"  ,    mimeType . getParameter (  \" attr \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeQuotedParameterValue"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   mimeType    =    MimeTypeUtils . parseMimeType (  \" audio /  *  ; attr =  ' v > alue '  \"  )  ;", "assertEquals (  \"  ' v > alue '  \"  ,    mimeType . getParameter (  \" attr \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeSingleQuotedParameterValue"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeTypeUtils . parseMimeType (  \"  *  / json \"  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeTypeRange"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   mimeType    =    MimeTypeUtils . parseMimeType (  \" multipart / x - mixed - replace ; boundary    =     -  - myboundary \"  )  ;", "assertEquals (  \"  -  - myboundary \"  ,    mimeType . getParameter (  \" boundary \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeWithSpacesAroundEquals"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   mimeType    =    MimeTypeUtils . parseMimeType (  \" text / plain ;    foo    =     \\  \"    bar    \\  \"     \"  )  ;", "assertEquals (  \"  \\  \"    bar    \\  \"  \"  ,    mimeType . getParameter (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypeWithSpacesAroundEqualsAndQuotedValue"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" text / plain ,    text / html ,    text / x - dvi ,    text / x - c \"  ;", "List <  >    mimeTypes    =    Utils . parses ( s )  ;", "assertNotNull (  \" No   mime   types   returned \"  ,    mimeTypes )  ;", "assertEquals (  \" Invalid   amount   of   mime   types \"  ,     4  ,    mimeTypes . size (  )  )  ;", "mimeTypes    =    Utils . parses ( null )  ;", "assertNotNull (  \" No   mime   types   returned \"  ,    mimeTypes )  ;", "assertEquals (  \" Invalid   amount   of   mime   types \"  ,     0  ,    mimeTypes . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseMimeTypes"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" application / xml ; charset =  \\  \" utf -  8  \\  \"  \"  ;", "mimeType    =     . valueOf ( s )  ;", "assertEquals (  \" Invalid   type \"  ,     \" application \"  ,    mimeType . getType (  )  )  ;", "assertEquals (  \" Invalid   subtype \"  ,     \" xml \"  ,    mimeType . getSubtype (  )  )  ;", "assertEquals (  \" Invalid   charset \"  ,    StandardCharsets . UTF _  8  ,    mimeType . getCharset (  )  )  ;", "}", "METHOD_END"], "methodName": ["parseQuotedCharset"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" application / xop + xml ; charset = utf -  8  ; type =  \\  \" application / soap + xml ; action =  \\  \\  \\  \" http :  /  / x . y . z \\  \\  \\  \"  \\  \"  \"  ;", "mimeType    =     . valueOf ( s )  ;", "assertEquals (  \" Invalid   type \"  ,     \" application \"  ,    mimeType . getType (  )  )  ;", "assertEquals (  \" Invalid   subtype \"  ,     \" xop + xml \"  ,    mimeType . getSubtype (  )  )  ;", "assertEquals (  \" Invalid   charset \"  ,    StandardCharsets . UTF _  8  ,    mimeType . getCharset (  )  )  ;", "assertEquals (  \"  \\  \" application / soap + xml ; action =  \\  \\  \\  \" http :  /  / x . y . z \\  \\  \\  \"  \\  \"  \"  ,    mimeType . getParameter (  \" type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseQuotedSeparator"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "new   MimeType (  \" text \"  ,     \"  /  \"  )  ;", "}", "METHOD_END"], "methodName": ["slashInSubtype"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   mimeType    =    new   MimeType (  \" text \"  ,     \" plain \"  )  ;", "String   result    =    mimeType . toString (  )  ;", "assertEquals (  \" Invalid   toString (  )    returned \"  ,     \" text / plain \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testToString"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType . valueOf (  \" text / html ;    charset = foo - bar \"  )  ;", "}", "METHOD_END"], "methodName": ["valueOfIllegalCharset"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType . valueOf (  \" audio / basic )  \"  )  ;", "}", "METHOD_END"], "methodName": ["valueOfIllegalSubtype"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType . valueOf (  \" audio (  / basic \"  )  ;", "}", "METHOD_END"], "methodName": ["valueOfIllegalType"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType . valueOf (  \" audio \"  )  ;", "}", "METHOD_END"], "methodName": ["valueOfNoSubtype"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "MimeType . valueOf (  \" audio /  \"  )  ;", "}", "METHOD_END"], "methodName": ["valueOfNoSubtypeSlash"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "ConversionService   conversionService    =    new   DefaultConversionService (  )  ;", "assertTrue ( conversionService . canConvert ( String . class ,     . class )  )  ;", "mimeType    =     . valueOf (  \" application / xml \"  )  ;", "assertEquals ( mimeType ,    conversionService . convert (  \" application / xml \"  ,     . class )  )  ;", "}", "METHOD_END"], "methodName": ["withConversionService"], "fileName": "org.springframework.util.MimeTypeTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    boundary    =    new   byte [  ( MimeTypeUtils . RND . nextInt (  1  1  )  )     +     3  0  ]  ;", "for    ( int   i    =     0  ;    i    <     ( boundary . length )  ;    i +  +  )     {", "boundary [ i ]     =    MimeTypeUtils . BOUNDARY _ CHARS [ MimeTypeUtils . RND . nextInt ( MimeTypeUtils . BOUNDARY _ CHARS . length )  ]  ;", "}", "return   boundary ;", "}", "METHOD_END"], "methodName": ["generateMultipartBoundary"], "fileName": "org.springframework.util.MimeTypeUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   String ( MimeTypeUtils . generateMultipartBoundary (  )  ,    StandardCharsets . US _ ASCII )  ;", "}", "METHOD_END"], "methodName": ["generateMultipartBoundaryString"], "fileName": "org.springframework.util.MimeTypeUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( mimeType )  )  )     {", "throw   new   InvalidException ( mimeType ,     \"  ' mimeType '    must   not   be   empty \"  )  ;", "}", "int   index    =    mimeType . indexOf (  '  ;  '  )  ;", "String   fullType    =     ( index    >  =     0     ?    mimeType . substring (  0  ,    index )     :    mimeType )  . trim (  )  ;", "if    ( fullType . isEmpty (  )  )     {", "throw   new   InvalidException ( mimeType ,     \"  ' mimeType '    must   not   be   empty \"  )  ;", "}", "if    (  . WILDCARD _ TYPE . equals ( fullType )  )     {", "fullType    =     \"  *  /  *  \"  ;", "}", "int   subIndex    =    fullType . indexOf (  '  /  '  )  ;", "if    ( subIndex    =  =     (  -  1  )  )     {", "throw   new   InvalidException ( mimeType ,     \" does   not   contain    '  /  '  \"  )  ;", "}", "if    ( subIndex    =  =     (  ( fullType . length (  )  )     -     1  )  )     {", "throw   new   InvalidException ( mimeType ,     \" does   not   contain   subtype   after    '  /  '  \"  )  ;", "}", "String   type    =    fullType . substring (  0  ,    subIndex )  ;", "String   subtype    =    fullType . substring (  ( subIndex    +     1  )  ,    fullType . length (  )  )  ;", "if    (  (  . WILDCARD _ TYPE . equals ( type )  )     &  &     (  !  (  . WILDCARD _ TYPE . equals ( subtype )  )  )  )     {", "throw   new   InvalidException ( mimeType ,     \" wildcard   type   is   legal   only   in    '  *  /  *  '     ( all   mime   types )  \"  )  ;", "}", "Map < String ,    String >    parameters    =    null ;", "do    {", "int   nextIndex    =    index    +     1  ;", "boolean   quoted    =    false ;", "while    ( nextIndex    <     ( mimeType . length (  )  )  )     {", "char   ch    =    mimeType . charAt ( nextIndex )  ;", "if    ( ch    =  =     '  ;  '  )     {", "if    (  ! quoted )     {", "break ;", "}", "} else", "if    ( ch    =  =     '  \"  '  )     {", "quoted    =     ! quoted ;", "}", "nextIndex +  +  ;", "}", "String   parameter    =    mimeType . substring (  ( index    +     1  )  ,    nextIndex )  . trim (  )  ;", "if    (  ( parameter . length (  )  )     >     0  )     {", "if    ( parameters    =  =    null )     {", "parameters    =    new   LinkedHashMap <  >  (  4  )  ;", "}", "int   eqIndex    =    parameter . indexOf (  '  =  '  )  ;", "if    ( eqIndex    >  =     0  )     {", "String   attribute    =    parameter . substring (  0  ,    eqIndex )  . trim (  )  ;", "String   value    =    parameter . substring (  ( eqIndex    +     1  )  ,    parameter . length (  )  )  . trim (  )  ;", "parameters . put ( attribute ,    value )  ;", "}", "}", "index    =    nextIndex ;", "}    while    ( index    <     ( mimeType . length (  )  )     )  ;", "try    {", "return   new    ( type ,    subtype ,    parameters )  ;", "}    catch    ( UnsupportedCharsetException   ex )     {", "throw   new   InvalidException ( mimeType ,     (  (  \" unsupported   charset    '  \"     +     ( ex . getCharsetName (  )  )  )     +     \"  '  \"  )  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   InvalidException ( mimeType ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseMimeType"], "fileName": "org.springframework.util.MimeTypeUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( mimeTypes )  )  )     {", "return   Collections . emptyList (  )  ;", "}", "String [  ]    tokens    =    StringUtils . tokenizeToStringArray ( mimeTypes ,     \"  ,  \"  )  ;", "List < MimeType >    result    =    new   ArrayList <  >  ( tokens . length )  ;", "for    ( String   token    :    tokens )     {", "result . add (  . parseMimeType ( token )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseMimeTypes"], "fileName": "org.springframework.util.MimeTypeUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mimeTypes ,     \"  ' mimeTypes '    must   not   be   null \"  )  ;", "if    (  ( mimeTypes . size (  )  )     >     1  )     {", "mimeTypes . sort (  . SPECIFICITY _ COMPARATOR )  ;", "}", "}", "METHOD_END"], "methodName": ["sortBySpecificity"], "fileName": "org.springframework.util.MimeTypeUtils"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( Iterator <  ?    extends    >    iterator    =    mimeTypes . iterator (  )  ;    iterator . hasNext (  )  ;  )     {", "mimeType    =    iterator . next (  )  ;", "mimeType . appendTo ( builder )  ;", "if    ( iterator . hasNext (  )  )     {", "builder . append (  \"  ,     \"  )  ;", "}", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.util.MimeTypeUtils"}, {"methodBody": ["METHOD_START", "{", "BigInteger   bigInt    =    null ;", "if    ( number   instanceof   BigInteger )     {", "bigInt    =     (  ( BigInteger )     ( number )  )  ;", "} else", "if    ( number   instanceof   BigDecimal )     {", "bigInt    =     (  ( BigDecimal )     ( number )  )  . toBigInteger (  )  ;", "}", "if    (  ( bigInt    !  =    null )     &  &     (  (  ( bigInt . compareTo (  . LONG _ MIN )  )     <     0  )     |  |     (  ( bigInt . compareTo (  . LONG _ MAX )  )     >     0  )  )  )     {", ". raiseOverflowException ( number ,    targetClass )  ;", "}", "return   number . longValue (  )  ;", "}", "METHOD_END"], "methodName": ["checkedLongValue"], "fileName": "org.springframework.util.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( number ,     \" Number   must   not   be   null \"  )  ;", "Assert . notNull ( targetClass ,     \" Target   class   must   not   be   null \"  )  ;", "if    ( targetClass . isInstance ( number )  )     {", "return    (  ( T )     ( number )  )  ;", "} else", "if    (  ( Byte . class )     =  =    targetClass )     {", "long   value    =     . checkedLongValue ( number ,    targetClass )  ;", "if    (  ( value    <     ( Byte . MIN _ VALUE )  )     |  |     ( value    >     ( Byte . MAX _ VALUE )  )  )     {", ". raiseOverflowException ( number ,    targetClass )  ;", "}", "return    (  ( T )     ( Byte . valueOf ( number . byteValue (  )  )  )  )  ;", "} else", "if    (  ( Short . class )     =  =    targetClass )     {", "long   value    =     . checkedLongValue ( number ,    targetClass )  ;", "if    (  ( value    <     ( Short . MIN _ VALUE )  )     |  |     ( value    >     ( Short . MAX _ VALUE )  )  )     {", ". raiseOverflowException ( number ,    targetClass )  ;", "}", "return    (  ( T )     ( Short . valueOf ( number . shortValue (  )  )  )  )  ;", "} else", "if    (  ( Integer . class )     =  =    targetClass )     {", "long   value    =     . checkedLongValue ( number ,    targetClass )  ;", "if    (  ( value    <     ( Integer . MIN _ VALUE )  )     |  |     ( value    >     ( Integer . MAX _ VALUE )  )  )     {", ". raiseOverflowException ( number ,    targetClass )  ;", "}", "return    (  ( T )     ( Integer . valueOf ( number . intValue (  )  )  )  )  ;", "} else", "if    (  ( Long . class )     =  =    targetClass )     {", "long   value    =     . checkedLongValue ( number ,    targetClass )  ;", "return    (  ( T )     ( Long . valueOf ( value )  )  )  ;", "} else", "if    (  ( class )     =  =    targetClass )     {", "if    ( number   instanceof   BigDecimal )     {", "return    (  ( T )     (  (  ( BigDecimal )     ( number )  )  . toBigInteger (  )  )  )  ;", "} else    {", "return    (  ( T )     ( valueOf ( number . longValue (  )  )  )  )  ;", "}", "} else", "if    (  ( Float . class )     =  =    targetClass )     {", "return    (  ( T )     ( Float . valueOf ( number . floatValue (  )  )  )  )  ;", "} else", "if    (  ( Double . class )     =  =    targetClass )     {", "return    (  ( T )     ( Double . valueOf ( number . doubleValue (  )  )  )  )  ;", "} else", "if    (  ( class )     =  =    targetClass )     {", "return    (  ( T )     ( new   BigDecimal ( number . toString (  )  )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  \" Could   not   convert   number    [  \"     +    number )     +     \"  ]    of   type    [  \"  )     +     ( number . getClass (  )  . getName (  )  )  )     +     \"  ]    to   unsupported   target   class    [  \"  )     +     ( targetClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["convertNumberToTargetClass"], "fileName": "org.springframework.util.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "int   radix    =     1  0  ;", "int   index    =     0  ;", "boolean   negative    =    false ;", "if    ( value . startsWith (  \"  -  \"  )  )     {", "negative    =    true ;", "index +  +  ;", "}", "if    (  ( value . startsWith (  \"  0 x \"  ,    index )  )     |  |     ( value . startsWith (  \"  0 X \"  ,    index )  )  )     {", "index    +  =     2  ;", "radix    =     1  6  ;", "} else", "if    ( value . startsWith (  \"  #  \"  ,    index )  )     {", "index +  +  ;", "radix    =     1  6  ;", "} else", "if    (  ( value . startsWith (  \"  0  \"  ,    index )  )     &  &     (  ( value . length (  )  )     >     (  1     +    index )  )  )     {", "index +  +  ;", "radix    =     8  ;", "}", "BigInteger   result    =    new   BigInteger ( value . subst ( index )  ,    radix )  ;", "return   negative    ?    result . negate (  )     :    result ;", "}", "METHOD_END"], "methodName": ["decodeBigInteger"], "fileName": "org.springframework.util.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "int   index    =     ( value . startsWith (  \"  -  \"  )  )     ?     1     :     0  ;", "return    (  ( value . startsWith (  \"  0 x \"  ,    index )  )     |  |     ( value . startsWith (  \"  0 X \"  ,    index )  )  )     |  |     ( value . startsWith (  \"  #  \"  ,    index )  )  ;", "}", "METHOD_END"], "methodName": ["isHexNumber"], "fileName": "org.springframework.util.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( text ,     \" Text   must   not   be   null \"  )  ;", "Assert . notNull ( targetClass ,     \" Target   class   must   not   be   null \"  )  ;", "String   trimmed    =    StringUtils . trimAllWhitespace ( text )  ;", "if    (  ( Byte . class )     =  =    targetClass )     {", "return    (  ( T )     (  . isHexNumber ( trimmed )     ?    Byte . decode ( trimmed )     :    Byte . valueOf ( trimmed )  )  )  ;", "} else", "if    (  ( Short . class )     =  =    targetClass )     {", "return    (  ( T )     (  . isHexNumber ( trimmed )     ?    Short . decode ( trimmed )     :    Short . valueOf ( trimmed )  )  )  ;", "} else", "if    (  ( Integer . class )     =  =    targetClass )     {", "return    (  ( T )     (  . isHexNumber ( trimmed )     ?    Integer . decode ( trimmed )     :    Integer . valueOf ( trimmed )  )  )  ;", "} else", "if    (  ( Long . class )     =  =    targetClass )     {", "return    (  ( T )     (  . isHexNumber ( trimmed )     ?    Long . decode ( trimmed )     :    Long . valueOf ( trimmed )  )  )  ;", "} else", "if    (  ( class )     =  =    targetClass )     {", "return    (  ( T )     (  . isHexNumber ( trimmed )     ?     . decodeBigInteger ( trimmed )     :    new   BigInteger ( trimmed )  )  )  ;", "} else", "if    (  ( Float . class )     =  =    targetClass )     {", "return    (  ( T )     ( Float . valueOf ( trimmed )  )  )  ;", "} else", "if    (  ( Double . class )     =  =    targetClass )     {", "return    (  ( T )     ( Double . valueOf ( trimmed )  )  )  ;", "} else", "if    (  (  ( class )     =  =    targetClass )     |  |     (  ( Number . class )     =  =    targetClass )  )     {", "return    (  ( T )     ( new   BigDecimal ( trimmed )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Cannot   convert   String    [  \"     +    text )     +     \"  ]    to   target   class    [  \"  )     +     ( targetClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseNumber"], "fileName": "org.springframework.util.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( numberFormat    !  =    null )     {", "Assert . notNull ( text ,     \" Text   must   not   be   null \"  )  ;", "Assert . notNull ( targetClass ,     \" Target   class   must   not   be   null \"  )  ;", "DecimalFormat   decimalFormat    =    null ;", "boolean   resetBigDecimal    =    false ;", "if    ( numberFormat   instanceof   DecimalFormat )     {", "decimalFormat    =     (  ( DecimalFormat )     ( numberFormat )  )  ;", "if    (  (  ( BigDecimal . class )     =  =    targetClass )     &  &     (  !  ( decimalFormat . isParseBigDecimal (  )  )  )  )     {", "decimalFormat . setParseBigDecimal ( true )  ;", "resetBigDecimal    =    true ;", "}", "}", "try    {", "Number   number    =    numberFormat . parse ( StringUtils . trimAllWhitespace ( text )  )  ;", "return    . convertNumberToTargetClass ( number ,    targetClass )  ;", "}    catch    ( ParseException   ex )     {", "throw   new   IllegalArgumentException (  (  \" Could   not   parse   number :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}    finally    {", "if    ( resetBigDecimal )     {", "decimalFormat . setParseBigDecimal ( false )  ;", "}", "}", "} else    {", "return    . parseNumber ( text ,    targetClass )  ;", "}", "}", "METHOD_END"], "methodName": ["parseNumber"], "fileName": "org.springframework.util.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  \" Could   not   convert   number    [  \"     +    number )     +     \"  ]    of   type    [  \"  )     +     ( number . getClass (  )  . getName (  )  )  )     +     \"  ]    to   target   class    [  \"  )     +     ( targetClass . getName (  )  )  )     +     \"  ]  :    overflow \"  )  )  ;", "}", "METHOD_END"], "methodName": ["raiseOverflowException"], "fileName": "org.springframework.util.NumberUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Byte   did   not   parse \"  ,    Byte . MAX _ VALUE ,    NumberUtils . parseNumber ( aByte ,    Byte . class )  . byteValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertByteEquals"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Integer   did   not   parse \"  ,    Integer . MAX _ VALUE ,    NumberUtils . parseNumber ( anInteger ,    Integer . class )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertIntegerEquals"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Long   did   not   parse \"  ,    Long . MAX _ VALUE ,    NumberUtils . parseNumber ( aLong ,    Long . class )  . longValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertLongEquals"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Byte   did   not   parse \"  ,    Byte . MIN _ VALUE ,    NumberUtils . parseNumber ( aByte ,    Byte . class )  . byteValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNegativeByteEquals"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Integer   did   not   parse \"  ,    Integer . MIN _ VALUE ,    NumberUtils . parseNumber ( anInteger ,    Integer . class )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNegativeIntegerEquals"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Long   did   not   parse \"  ,    Long . MIN _ VALUE ,    NumberUtils . parseNumber ( aLong ,    Long . class )  . longValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNegativeLongEquals"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Short   did   not   parse \"  ,    Short . MIN _ VALUE ,    NumberUtils . parseNumber ( aShort ,    Short . class )  . shortValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNegativeShortEquals"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Short   did   not   parse \"  ,    Short . MAX _ VALUE ,    NumberUtils . parseNumber ( aShort ,    Short . class )  . shortValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertShortEquals"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   msg    =     (  (  \" Expected   exception   due   to   overflow :    from =  \"     +    number )     +     \"  ,    toClass =  \"  )     +    targetClass ;", "try    {", ". convertNumberToTargetClass ( number ,    targetClass )  ;", "fail ( msg )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "assertTrue (  (  ( msg    +     \"  ,    with    \\  \" overflow \\  \"    in   message   but   got   message =  \"  )     +     ( expected . getMessage (  )  )  )  ,    expected . getMessage (  )  . endsWith (  \" overflow \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertToNumberOverflow"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   number    =     \"  9  8  7  4  5  9  8  3  7  5  8  3  7  5  0  3  8  7  3  5  5  3  4  6  \"  ;", "BigDecimal   decimal    =    new   BigDecimal ( number )  ;", "assertEquals ( new   BigInteger ( number )  ,     . convertNumberToTargetClass ( decimal ,    BigInteger . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertBigDecimalToBigInteger"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Double   decimal    =    Double . valueOf (  3  .  1  4  )  ;", "assertEquals ( new   BigInteger (  \"  3  \"  )  ,     . convertNumberToTargetClass ( decimal ,    BigInteger . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertDoubleToBigInteger"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "BigDecimal   decimal    =    new   BigDecimal (  \"  9  8  7  4  5  9  8  3  7  5  8  3  7  5  0  3  8  7  3  5  5  3  4  6  .  1  4  \"  )  ;", "assertEquals ( new   BigInteger (  \"  9  8  7  4  5  9  8  3  7  5  8  3  7  5  0  3  8  7  3  5  5  3  4  6  \"  )  ,     . convertNumberToTargetClass ( decimal ,    BigInteger . class )  )  ;", "}", "METHOD_END"], "methodName": ["convertNonExactBigDecimalToBigInteger"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Integer . valueOf ( Integer . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  (  -  1  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  0  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  1  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf ( Integer . MAX _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  (  ( Integer . MAX _ VALUE )     +     1  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf ( Integer . MIN _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  (  ( Integer . MIN _ VALUE )     -     1  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  (  -  1  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  0  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  1  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf ( Integer . MAX _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  (  ( Integer . MAX _ VALUE )     +     1  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf ( Integer . MIN _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  (  ( Integer . MIN _ VALUE )     -     1  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  (  -  1  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  0  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  1  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf ( Integer . MAX _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  (  ( Integer . MAX _ VALUE )     +     1  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf ( Integer . MIN _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  (  ( Integer . MIN _ VALUE )     -     1  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  -  1  )  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  0  )  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  1  )  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Short . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf ( Short . MAX _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Short . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  ( Short . MAX _ VALUE )     +     1  )  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Short . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf ( Short . MIN _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Short . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  ( Short . MIN _ VALUE )     -     1  )  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  -  1  )  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  0  )  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Integer . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  1  )  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Byte . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf ( Byte . MAX _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Byte . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  ( Byte . MAX _ VALUE )     +     1  )  )  )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Byte . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf ( Byte . MIN _ VALUE )  ,    Integer . class )  )  ;", "assertEquals ( Integer . valueOf ( Byte . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  ( Byte . MIN _ VALUE )     -     1  )  )  )  ,    Integer . class )  )  ;", "assertToNumberOverflow ( Long . valueOf (  (  ( Long . MAX _ VALUE )     +     1  )  )  ,    Integer . class )  ;", "assertToNumberOverflow ( Long . valueOf (  (  ( Long . MIN _ VALUE )     -     1  )  )  ,    Integer . class )  ;", "assertToNumberOverflow ( BigInteger . valueOf ( Integer . MAX _ VALUE )  . add ( BigInteger . ONE )  ,    Integer . class )  ;", "assertToNumberOverflow ( BigInteger . valueOf ( Integer . MIN _ VALUE )  . subtract ( BigInteger . ONE )  ,    Integer . class )  ;", "assertToNumberOverflow ( new   BigDecimal (  \"  1  8  4  4  6  7  4  4  0  7  3  7  0  9  5  5  1  6  1  1  \"  )  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["convertToInteger"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Long . valueOf ( Long . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  (  -  1  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  0  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  1  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf ( Long . MAX _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  (  ( Long . MAX _ VALUE )     +     1  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf ( Long . MIN _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( BigInteger . valueOf (  (  ( Long . MIN _ VALUE )     -     1  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  (  -  1  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  0  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  1  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf ( Long . MAX _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  (  ( Long . MAX _ VALUE )     +     1  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf ( Long . MIN _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Long . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Long . valueOf (  (  ( Long . MIN _ VALUE )     -     1  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  (  -  1  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  0  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  1  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf ( Integer . MAX _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  (  ( Integer . MAX _ VALUE )     +     1  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf ( Integer . MIN _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Integer . valueOf (  (  ( Integer . MIN _ VALUE )     -     1  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  -  1  )  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  0  )  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  1  )  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Short . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf ( Short . MAX _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Short . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  ( Short . MAX _ VALUE )     +     1  )  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Short . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf ( Short . MIN _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Short . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Short . valueOf (  (  ( short )     (  ( Short . MIN _ VALUE )     -     1  )  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . valueOf (  (  -  1  )  )  )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  -  1  )  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . valueOf (  0  )  )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  0  )  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Integer . valueOf (  1  )  )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  1  )  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Byte . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf ( Byte . MAX _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Byte . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  ( Byte . MAX _ VALUE )     +     1  )  )  )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Byte . MIN _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf ( Byte . MIN _ VALUE )  ,    Long . class )  )  ;", "assertEquals ( Long . valueOf ( Byte . MAX _ VALUE )  ,    NumberUtils . convertNumberToTargetClass ( Byte . valueOf (  (  ( byte )     (  ( Byte . MIN _ VALUE )     -     1  )  )  )  ,    Long . class )  )  ;", "assertToNumberOverflow ( BigInteger . valueOf ( Long . MAX _ VALUE )  . add ( BigInteger . ONE )  ,    Long . class )  ;", "assertToNumberOverflow ( BigInteger . valueOf ( Long . MIN _ VALUE )  . subtract ( BigInteger . ONE )  ,    Long . class )  ;", "assertToNumberOverflow ( new   BigDecimal (  \"  1  8  4  4  6  7  4  4  0  7  3  7  0  9  5  5  1  6  1  1  \"  )  ,    Long . class )  ;", "}", "METHOD_END"], "methodName": ["convertToLong"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   bigDecimalAsString    =     \"  0  .  1  0  \"  ;", "Number   bigDecimal    =     . parseNumber ( bigDecimalAsString ,    BigDecimal . class )  ;", "assertEquals ( new   BigDecimal ( bigDecimalAsString )  ,    bigDecimal )  ;", "}", "METHOD_END"], "methodName": ["parseBigDecimalNumber1"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   bigDecimalAsString    =     \"  0  .  0  0  1  \"  ;", "Number   bigDecimal    =     . parseNumber ( bigDecimalAsString ,    BigDecimal . class )  ;", "assertEquals ( new   BigDecimal ( bigDecimalAsString )  ,    bigDecimal )  ;", "}", "METHOD_END"], "methodName": ["parseBigDecimalNumber2"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   bigDecimalAsString    =     \"  3  .  1  4  1  5  9  2  6  5  3  5  8  9  7  9  3  2  3  8  4  6  \"  ;", "Number   bigDecimal    =     . parseNumber ( bigDecimalAsString ,    BigDecimal . class )  ;", "assertEquals ( new   BigDecimal ( bigDecimalAsString )  ,    bigDecimal )  ;", "}", "METHOD_END"], "methodName": ["parseBigDecimalNumber3"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   bigDecimalAsString    =     \"  0  .  1  0  \"  ;", "NumberFormat   numberFormat    =    NumberFormat . getInstance ( Locale . ENGLISH )  ;", "Number   bigDecimal    =     . parseNumber ( bigDecimalAsString ,    BigDecimal . class ,    numberFormat )  ;", "assertEquals ( new   BigDecimal ( bigDecimalAsString )  ,    bigDecimal )  ;", "}", "METHOD_END"], "methodName": ["parseLocalizedBigDecimalNumber1"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   bigDecimalAsString    =     \"  0  .  0  0  1  \"  ;", "NumberFormat   numberFormat    =    NumberFormat . getInstance ( Locale . ENGLISH )  ;", "Number   bigDecimal    =     . parseNumber ( bigDecimalAsString ,    BigDecimal . class ,    numberFormat )  ;", "assertEquals ( new   BigDecimal ( bigDecimalAsString )  ,    bigDecimal )  ;", "}", "METHOD_END"], "methodName": ["parseLocalizedBigDecimalNumber2"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   bigDecimalAsString    =     \"  3  .  1  4  1  5  9  2  6  5  3  5  8  9  7  9  3  2  3  8  4  6  \"  ;", "NumberFormat   numberFormat    =    NumberFormat . getInstance ( Locale . ENGLISH )  ;", "Number   bigDecimal    =     . parseNumber ( bigDecimalAsString ,    BigDecimal . class ,    numberFormat )  ;", "assertEquals ( new   BigDecimal ( bigDecimalAsString )  ,    bigDecimal )  ;", "}", "METHOD_END"], "methodName": ["parseLocalizedBigDecimalNumber3"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   aLong    =     \"  \"     +     ( Long . MIN _ VALUE )  ;", "String   aDouble    =     \"  \"     +     ( Double . MIN _ VALUE )  ;", "try    {", ". parseNumber ( aLong ,    Byte . class )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "try    {", ". parseNumber ( aLong ,    Short . class )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "try    {", ". parseNumber ( aLong ,    Integer . class )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "assertEquals ( Long . valueOf ( Long . MIN _ VALUE )  ,     . parseNumber ( aLong ,    Long . class )  )  ;", "assertEquals ( Double . valueOf ( Double . MIN _ VALUE )  ,     . parseNumber ( aDouble ,    Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["parseNegativeOverflow"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "NumberFormat   nf    =    NumberFormat . getNumberInstance ( Locale . US )  ;", "String   aLong    =     \"  \"     +     ( Long . MIN _ VALUE )  ;", "String   aDouble    =     \"  \"     +     ( Double . MIN _ VALUE )  ;", "try    {", ". parseNumber ( aLong ,    Byte . class ,    nf )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "try    {", ". parseNumber ( aLong ,    Short . class ,    nf )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "try    {", ". parseNumber ( aLong ,    Integer . class ,    nf )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "assertEquals ( Long . valueOf ( Long . MIN _ VALUE )  ,     . parseNumber ( aLong ,    Long . class ,    nf )  )  ;", "assertEquals ( Double . valueOf ( Double . MIN _ VALUE )  ,     . parseNumber ( aDouble ,    Double . class ,    nf )  )  ;", "}", "METHOD_END"], "methodName": ["parseNegativeOverflowUsingNumberFormat"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   aByte    =     \"  \"     +     ( Byte . MAX _ VALUE )  ;", "String   aShort    =     \"  \"     +     ( Short . MAX _ VALUE )  ;", "String   anInteger    =     \"  \"     +     ( Integer . MAX _ VALUE )  ;", "String   aLong    =     \"  \"     +     ( Long . MAX _ VALUE )  ;", "String   aFloat    =     \"  \"     +     ( Float . MAX _ VALUE )  ;", "String   aDouble    =     \"  \"     +     ( Double . MAX _ VALUE )  ;", "assertEquals (  \" Byte   did   not   parse \"  ,    Byte . valueOf ( Byte . MAX _ VALUE )  ,     . parseNumber ( aByte ,    Byte . class )  )  ;", "assertEquals (  \" Short   did   not   parse \"  ,    Short . valueOf ( Short . MAX _ VALUE )  ,     . parseNumber ( aShort ,    Short . class )  )  ;", "assertEquals (  \" Integer   did   not   parse \"  ,    Integer . valueOf ( Integer . MAX _ VALUE )  ,     . parseNumber ( anInteger ,    Integer . class )  )  ;", "assertEquals (  \" Long   did   not   parse \"  ,    Long . valueOf ( Long . MAX _ VALUE )  ,     . parseNumber ( aLong ,    Long . class )  )  ;", "assertEquals (  \" Float   did   not   parse \"  ,    Float . valueOf ( Float . MAX _ VALUE )  ,     . parseNumber ( aFloat ,    Float . class )  )  ;", "assertEquals (  \" Double   did   not   parse \"  ,    Double . valueOf ( Double . MAX _ VALUE )  ,     . parseNumber ( aDouble ,    Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["parseNumber"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   aByte    =     \"  0 x \"     +     ( Integer . toHexString ( Byte . valueOf ( Byte . MAX _ VALUE )  . intValue (  )  )  )  ;", "String   aShort    =     \"  0 x \"     +     ( Integer . toHexString ( Short . valueOf ( Short . MAX _ VALUE )  . intValue (  )  )  )  ;", "String   anInteger    =     \"  0 x \"     +     ( Integer . toHexString ( Integer . MAX _ VALUE )  )  ;", "String   aLong    =     \"  0 x \"     +     ( Long . toHexString ( Long . MAX _ VALUE )  )  ;", "String   aReallyBigInt    =     \" FEBD 4 E 6  7  7  8  9  8 DFEBFFEE 4  4  \"  ;", "assertByteEquals ( aByte )  ;", "assertShortEquals ( aShort )  ;", "assertIntegerEquals ( anInteger )  ;", "assertLongEquals ( aLong )  ;", "assertEquals (  \" BigInteger   did   not   parse \"  ,    new   BigInteger ( aReallyBigInt ,     1  6  )  ,     . parseNumber (  (  \"  0 x \"     +    aReallyBigInt )  ,    BigInteger . class )  )  ;", "}", "METHOD_END"], "methodName": ["parseNumberAsHex"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   aByte    =     \"  -  0 x 8  0  \"  ;", "String   aShort    =     \"  -  0 x 8  0  0  0  \"  ;", "String   anInteger    =     \"  -  0 x 8  0  0  0  0  0  0  0  \"  ;", "String   aLong    =     \"  -  0 x 8  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  \"  ;", "String   aReallyBigInt    =     \" FEBD 4 E 6  7  7  8  9  8 DFEBFFEE 4  4  \"  ;", "assertNegativeByteEquals ( aByte )  ;", "assertNegativeShortEquals ( aShort )  ;", "assertNegativeIntegerEquals ( anInteger )  ;", "assertNegativeLongEquals ( aLong )  ;", "assertEquals (  \" BigInteger   did   not   parse \"  ,    new   BigInteger ( aReallyBigInt ,     1  6  )  . negate (  )  ,     . parseNumber (  (  \"  -  0 x \"     +    aReallyBigInt )  ,    BigInteger . class )  )  ;", "}", "METHOD_END"], "methodName": ["parseNumberAsNegativeHex"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   aByte    =     (  \"     \"     +     ( Byte . MAX _ VALUE )  )     +     \"     \"  ;", "String   aShort    =     (  \"     \"     +     ( Short . MAX _ VALUE )  )     +     \"     \"  ;", "String   anInteger    =     (  \"     \"     +     ( Integer . MAX _ VALUE )  )     +     \"     \"  ;", "String   aLong    =     (  \"     \"     +     ( Long . MAX _ VALUE )  )     +     \"     \"  ;", "String   aFloat    =     (  \"     \"     +     ( Float . MAX _ VALUE )  )     +     \"     \"  ;", "String   aDouble    =     (  \"     \"     +     ( Double . MAX _ VALUE )  )     +     \"     \"  ;", "assertEquals (  \" Byte   did   not   parse \"  ,    Byte . valueOf ( Byte . MAX _ VALUE )  ,     . parseNumber ( aByte ,    Byte . class )  )  ;", "assertEquals (  \" Short   did   not   parse \"  ,    Short . valueOf ( Short . MAX _ VALUE )  ,     . parseNumber ( aShort ,    Short . class )  )  ;", "assertEquals (  \" Integer   did   not   parse \"  ,    Integer . valueOf ( Integer . MAX _ VALUE )  ,     . parseNumber ( anInteger ,    Integer . class )  )  ;", "assertEquals (  \" Long   did   not   parse \"  ,    Long . valueOf ( Long . MAX _ VALUE )  ,     . parseNumber ( aLong ,    Long . class )  )  ;", "assertEquals (  \" Float   did   not   parse \"  ,    Float . valueOf ( Float . MAX _ VALUE )  ,     . parseNumber ( aFloat ,    Float . class )  )  ;", "assertEquals (  \" Double   did   not   parse \"  ,    Double . valueOf ( Double . MAX _ VALUE )  ,     . parseNumber ( aDouble ,    Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["parseNumberRequiringTrim"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "NumberFormat   nf    =    NumberFormat . getNumberInstance ( Locale . US )  ;", "String   aByte    =     (  \"     \"     +     ( Byte . MAX _ VALUE )  )     +     \"     \"  ;", "String   aShort    =     (  \"     \"     +     ( Short . MAX _ VALUE )  )     +     \"     \"  ;", "String   anInteger    =     (  \"     \"     +     ( Integer . MAX _ VALUE )  )     +     \"     \"  ;", "String   aLong    =     (  \"     \"     +     ( Long . MAX _ VALUE )  )     +     \"     \"  ;", "String   aFloat    =     (  \"     \"     +     ( Float . MAX _ VALUE )  )     +     \"     \"  ;", "String   aDouble    =     (  \"     \"     +     ( Double . MAX _ VALUE )  )     +     \"     \"  ;", "assertEquals (  \" Byte   did   not   parse \"  ,    Byte . valueOf ( Byte . MAX _ VALUE )  ,     . parseNumber ( aByte ,    Byte . class ,    nf )  )  ;", "assertEquals (  \" Short   did   not   parse \"  ,    Short . valueOf ( Short . MAX _ VALUE )  ,     . parseNumber ( aShort ,    Short . class ,    nf )  )  ;", "assertEquals (  \" Integer   did   not   parse \"  ,    Integer . valueOf ( Integer . MAX _ VALUE )  ,     . parseNumber ( anInteger ,    Integer . class ,    nf )  )  ;", "assertEquals (  \" Long   did   not   parse \"  ,    Long . valueOf ( Long . MAX _ VALUE )  ,     . parseNumber ( aLong ,    Long . class ,    nf )  )  ;", "assertEquals (  \" Float   did   not   parse \"  ,    Float . valueOf ( Float . MAX _ VALUE )  ,     . parseNumber ( aFloat ,    Float . class ,    nf )  )  ;", "assertEquals (  \" Double   did   not   parse \"  ,    Double . valueOf ( Double . MAX _ VALUE )  ,     . parseNumber ( aDouble ,    Double . class ,    nf )  )  ;", "}", "METHOD_END"], "methodName": ["parseNumberRequiringTrimUsingNumberFormat"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "NumberFormat   nf    =    NumberFormat . getNumberInstance ( Locale . US )  ;", "String   aByte    =     \"  \"     +     ( Byte . MAX _ VALUE )  ;", "String   aShort    =     \"  \"     +     ( Short . MAX _ VALUE )  ;", "String   anInteger    =     \"  \"     +     ( Integer . MAX _ VALUE )  ;", "String   aLong    =     \"  \"     +     ( Long . MAX _ VALUE )  ;", "String   aFloat    =     \"  \"     +     ( Float . MAX _ VALUE )  ;", "String   aDouble    =     \"  \"     +     ( Double . MAX _ VALUE )  ;", "assertEquals (  \" Byte   did   not   parse \"  ,    Byte . valueOf ( Byte . MAX _ VALUE )  ,     . parseNumber ( aByte ,    Byte . class ,    nf )  )  ;", "assertEquals (  \" Short   did   not   parse \"  ,    Short . valueOf ( Short . MAX _ VALUE )  ,     . parseNumber ( aShort ,    Short . class ,    nf )  )  ;", "assertEquals (  \" Integer   did   not   parse \"  ,    Integer . valueOf ( Integer . MAX _ VALUE )  ,     . parseNumber ( anInteger ,    Integer . class ,    nf )  )  ;", "assertEquals (  \" Long   did   not   parse \"  ,    Long . valueOf ( Long . MAX _ VALUE )  ,     . parseNumber ( aLong ,    Long . class ,    nf )  )  ;", "assertEquals (  \" Float   did   not   parse \"  ,    Float . valueOf ( Float . MAX _ VALUE )  ,     . parseNumber ( aFloat ,    Float . class ,    nf )  )  ;", "assertEquals (  \" Double   did   not   parse \"  ,    Double . valueOf ( Double . MAX _ VALUE )  ,     . parseNumber ( aDouble ,    Double . class ,    nf )  )  ;", "}", "METHOD_END"], "methodName": ["parseNumberUsingNumberFormat"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   aLong    =     \"  \"     +     ( Long . MAX _ VALUE )  ;", "String   aDouble    =     \"  \"     +     ( Double . MAX _ VALUE )  ;", "try    {", ". parseNumber ( aLong ,    Byte . class )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "try    {", ". parseNumber ( aLong ,    Short . class )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "try    {", ". parseNumber ( aLong ,    Integer . class )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "assertEquals ( Long . valueOf ( Long . MAX _ VALUE )  ,     . parseNumber ( aLong ,    Long . class )  )  ;", "assertEquals ( Double . valueOf ( Double . MAX _ VALUE )  ,     . parseNumber ( aDouble ,    Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["parseOverflow"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "NumberFormat   nf    =    NumberFormat . getNumberInstance ( Locale . US )  ;", "String   aLong    =     \"  \"     +     ( Long . MAX _ VALUE )  ;", "String   aDouble    =     \"  \"     +     ( Double . MAX _ VALUE )  ;", "try    {", ". parseNumber ( aLong ,    Byte . class ,    nf )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "try    {", ". parseNumber ( aLong ,    Short . class ,    nf )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "try    {", ". parseNumber ( aLong ,    Integer . class ,    nf )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "assertEquals ( Long . valueOf ( Long . MAX _ VALUE )  ,     . parseNumber ( aLong ,    Long . class ,    nf )  )  ;", "assertEquals ( Double . valueOf ( Double . MAX _ VALUE )  ,     . parseNumber ( aDouble ,    Double . class ,    nf )  )  ;", "}", "METHOD_END"], "methodName": ["parseOverflowUsingNumberFormat"], "fileName": "org.springframework.util.NumberUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    compType    =    Object . class ;", "if    ( array    !  =    null )     {", "compType    =    array . getClass (  )  . getComponentType (  )  ;", "} else", "if    ( obj    !  =    null )     {", "compType    =    obj . getClass (  )  ;", "}", "int   newArrLength    =     ( array    !  =    null )     ?     ( array . length )     +     1     :     1  ;", "@ SuppressWarnings (  \" unchecked \"  )", "A [  ]    newArr    =     (  ( A [  ]  )     ( Array . newInstance ( compType ,    newArrLength )  )  )  ;", "if    ( array    !  =    null )     {", "System . arraycopy ( array ,     0  ,    newArr ,     0  ,    array . length )  ;", "}", "newArr [  (  ( newArr . length )     -     1  )  ]     =    obj ;", "return   newArr ;", "}", "METHOD_END"], "methodName": ["addObjectToArray"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( o 1    instanceof   Object [  ]  )     &  &     ( o 2    instanceof   Object [  ]  )  )     {", "return   Arrays . equals (  (  ( Object [  ]  )     ( o 1  )  )  ,     (  ( Object [  ]  )     ( o 2  )  )  )  ;", "}", "if    (  ( o 1    instanceof   boolean [  ]  )     &  &     ( o 2    instanceof   boolean [  ]  )  )     {", "return   Arrays . equals (  (  ( boolean [  ]  )     ( o 1  )  )  ,     (  ( boolean [  ]  )     ( o 2  )  )  )  ;", "}", "if    (  ( o 1    instanceof   byte [  ]  )     &  &     ( o 2    instanceof   byte [  ]  )  )     {", "return   Arrays . equals (  (  ( byte [  ]  )     ( o 1  )  )  ,     (  ( byte [  ]  )     ( o 2  )  )  )  ;", "}", "if    (  ( o 1    instanceof   char [  ]  )     &  &     ( o 2    instanceof   char [  ]  )  )     {", "return   Arrays . equals (  (  ( char [  ]  )     ( o 1  )  )  ,     (  ( char [  ]  )     ( o 2  )  )  )  ;", "}", "if    (  ( o 1    instanceof   double [  ]  )     &  &     ( o 2    instanceof   double [  ]  )  )     {", "return   Arrays . equals (  (  ( double [  ]  )     ( o 1  )  )  ,     (  ( double [  ]  )     ( o 2  )  )  )  ;", "}", "if    (  ( o 1    instanceof   float [  ]  )     &  &     ( o 2    instanceof   float [  ]  )  )     {", "return   Arrays . equals (  (  ( float [  ]  )     ( o 1  )  )  ,     (  ( float [  ]  )     ( o 2  )  )  )  ;", "}", "if    (  ( o 1    instanceof   int [  ]  )     &  &     ( o 2    instanceof   int [  ]  )  )     {", "return   Arrays . equals (  (  ( int [  ]  )     ( o 1  )  )  ,     (  ( int [  ]  )     ( o 2  )  )  )  ;", "}", "if    (  ( o 1    instanceof   long [  ]  )     &  &     ( o 2    instanceof   long [  ]  )  )     {", "return   Arrays . equals (  (  ( long [  ]  )     ( o 1  )  )  ,     (  ( long [  ]  )     ( o 2  )  )  )  ;", "}", "if    (  ( o 1    instanceof   short [  ]  )     &  &     ( o 2    instanceof   short [  ]  )  )     {", "return   Arrays . equals (  (  ( short [  ]  )     ( o 1  )  )  ,     (  ( short [  ]  )     ( o 2  )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["arrayEquals"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( E   candidate    :    enumValues )     {", "if    ( candidate . toSt (  )  . equalsIgnoreCase ( constant )  )     {", "return   candidate ;", "}", "}", "throw   new   IllegalArgumentException ( St . format (  \" constant    [  % s ]    does   not   exist   in   enum   type    % s \"  ,    constant ,    enumValues . getClass (  )  . getComponentType (  )  . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["caseInsensitiveValueOf"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return   ObjectUtils . containsConstant ( enumValues ,    constant ,    false )  ;", "}", "METHOD_END"], "methodName": ["containsConstant"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Enum <  ?  >    candidate    :    enumValues )     {", "if    ( caseSensitive    ?    candidate . toSt (  )  . equals ( constant )     :    candidate . toSt (  )  . equalsIgnoreCase ( constant )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsConstant"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return   false ;", "}", "for    ( Object   arrayEle    :    array )     {", "if    (  . nullSafeEquals ( arrayEle ,    element )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsElement"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =    null )     {", "return    . EMPTY _ STRING ;", "}", "return    . nullSafeToString ( obj )  ;", "}", "METHOD_END"], "methodName": ["getDisplayString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return   Integer . toHexString ( System . identityHashCode ( obj )  )  ;", "}", "METHOD_END"], "methodName": ["getIdentityHexString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return   Boolean . hashCode ( bool )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return   Double . hashCode ( dbl )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return   Float . hashCode ( flt )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return   Long . hashCode ( lng )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =    null )     {", "return    . EMPTY _ STRING ;", "}", "return    (  ( obj . getClass (  )  . getName (  )  )     +     \"  @  \"  )     +     (  . getIdentityHexString ( obj )  )  ;", "}", "METHOD_END"], "methodName": ["identityToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( obj    !  =    null )     &  &     ( obj . getClass (  )  . isArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return    !  (  ( ex   instanceof   RuntimeException )     |  |     ( ex   instanceof   Error )  )  ;", "}", "METHOD_END"], "methodName": ["isCheckedException"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ObjectUtils . isCheckedException ( ex )  )  )     {", "return   true ;", "}", "if    ( declaredExceptions    !  =    null )     {", "for    ( Class <  ?  >    declaredException    :    declaredExceptions )     {", "if    ( declaredException . isInstance ( ex )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isCompatibleWithThrowsClause"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =    null )     {", "return   true ;", "}", "if    ( obj   instanceof   Optional )     {", "return    !  (  (  ( Optional )     ( obj )  )  . isPresent (  )  )  ;", "}", "if    ( obj   instanceof   CharSequence )     {", "return    (  (  ( CharSequence )     ( obj )  )  . length (  )  )     =  =     0  ;", "}", "if    ( obj . getClass (  )  . isArray (  )  )     {", "return    ( Array . getLength ( obj )  )     =  =     0  ;", "}", "if    ( obj   instanceof   Collion )     {", "return    (  ( Collion )     ( obj )  )  . isEmpty (  )  ;", "}", "if    ( obj   instanceof   Map )     {", "return    (  ( Map )     ( obj )  )  . isEmpty (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( array    =  =    null )     |  |     (  ( array . length )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "return   obj    !  =    null    ?    obj . getClass (  )  . getName (  )     :    ObjectUtils . NULL _ STRING ;", "}", "METHOD_END"], "methodName": ["nullSafeClassName"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( o 1     =  =    o 2  )     {", "return   true ;", "}", "if    (  ( o 1     =  =    null )     |  |     ( o 2     =  =    null )  )     {", "return   false ;", "}", "if    ( o 1  . equals ( o 2  )  )     {", "return   true ;", "}", "if    (  ( o 1  . getClass (  )  . isArray (  )  )     &  &     ( o 2  . getClass (  )  . isArray (  )  )  )     {", "return    . arrayEquals ( o 1  ,    o 2  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["nullSafeEquals"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    0  ;", "}", "int   hash    =     . INITIAL _ HASH ;", "for    ( boolean   element    :    array )     {", "hash    =     (  (  . MULTIPLIER )     *    hash )     +     ( Boolean . hashCode ( element )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    0  ;", "}", "int   hash    =     . INITIAL _ HASH ;", "for    ( byte   element    :    array )     {", "hash    =     (  (  . MULTIPLIER )     *    hash )     +    element ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    0  ;", "}", "int   hash    =     . INITIAL _ HASH ;", "for    ( char   element    :    array )     {", "hash    =     (  (  . MULTIPLIER )     *    hash )     +    element ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    0  ;", "}", "int   hash    =     . INITIAL _ HASH ;", "for    ( double   element    :    array )     {", "hash    =     (  (  . MULTIPLIER )     *    hash )     +     ( Double . hashCode ( element )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    0  ;", "}", "int   hash    =     . INITIAL _ HASH ;", "for    ( float   element    :    array )     {", "hash    =     (  (  . MULTIPLIER )     *    hash )     +     ( Float . hashCode ( element )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    0  ;", "}", "int   hash    =     . INITIAL _ HASH ;", "for    ( int   element    :    array )     {", "hash    =     (  (  . MULTIPLIER )     *    hash )     +    element ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =    null )     {", "return    0  ;", "}", "if    ( obj . getClass (  )  . isArray (  )  )     {", "if    ( obj   instanceof   Object [  ]  )     {", "return    . nullSafeHashCode (  (  ( Object [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   boolean [  ]  )     {", "return    . nullSafeHashCode (  (  ( boolean [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   byte [  ]  )     {", "return    . nullSafeHashCode (  (  ( byte [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   char [  ]  )     {", "return    . nullSafeHashCode (  (  ( char [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   double [  ]  )     {", "return    . nullSafeHashCode (  (  ( double [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   float [  ]  )     {", "return    . nullSafeHashCode (  (  ( float [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   int [  ]  )     {", "return    . nullSafeHashCode (  (  ( int [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   long [  ]  )     {", "return    . nullSafeHashCode (  (  ( long [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   short [  ]  )     {", "return    . nullSafeHashCode (  (  ( short [  ]  )     ( obj )  )  )  ;", "}", "}", "return   obj . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    0  ;", "}", "int   hash    =     . INITIAL _ HASH ;", "for    ( Object   element    :    array )     {", "hash    =     (  (  . MULTIPLIER )     *    hash )     +     (  . nullSafeHashCode ( element )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    0  ;", "}", "int   hash    =     . INITIAL _ HASH ;", "for    ( long   element    :    array )     {", "hash    =     (  (  . MULTIPLIER )     *    hash )     +     ( Long . hashCode ( element )  )  ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    0  ;", "}", "int   hash    =     . INITIAL _ HASH ;", "for    ( short   element    :    array )     {", "hash    =     (  (  . MULTIPLIER )     *    hash )     +    element ;", "}", "return   hash ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCode"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    . NULL _ STRING ;", "}", "int   length    =    array . length ;", "if    ( length    =  =     0  )     {", "return    . EMPTY _ ARRAY ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "sb . append (  . ARRAY _ START )  ;", "} else    {", "sb . append (  . ARRAY _ ELEMENT _ SEPARATOR )  ;", "}", "sb . append ( array [ i ]  )  ;", "}", "sb . append (  . ARRAY _ END )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    . NULL _ STRING ;", "}", "int   length    =    array . length ;", "if    ( length    =  =     0  )     {", "return    . EMPTY _ ARRAY ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "sb . append (  . ARRAY _ START )  ;", "} else    {", "sb . append (  . ARRAY _ ELEMENT _ SEPARATOR )  ;", "}", "sb . append ( array [ i ]  )  ;", "}", "sb . append (  . ARRAY _ END )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    . NULL _ STRING ;", "}", "int   length    =    array . length ;", "if    ( length    =  =     0  )     {", "return    . EMPTY _ ARRAY ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "sb . append (  . ARRAY _ START )  ;", "} else    {", "sb . append (  . ARRAY _ ELEMENT _ SEPARATOR )  ;", "}", "sb . append (  \"  '  \"  )  . append ( array [ i ]  )  . append (  \"  '  \"  )  ;", "}", "sb . append (  . ARRAY _ END )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    . NULL _ STRING ;", "}", "int   length    =    array . length ;", "if    ( length    =  =     0  )     {", "return    . EMPTY _ ARRAY ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "sb . append (  . ARRAY _ START )  ;", "} else    {", "sb . append (  . ARRAY _ ELEMENT _ SEPARATOR )  ;", "}", "sb . append ( array [ i ]  )  ;", "}", "sb . append (  . ARRAY _ END )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    . NULL _ STRING ;", "}", "int   length    =    array . length ;", "if    ( length    =  =     0  )     {", "return    . EMPTY _ ARRAY ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "sb . append (  . ARRAY _ START )  ;", "} else    {", "sb . append (  . ARRAY _ ELEMENT _ SEPARATOR )  ;", "}", "sb . append ( array [ i ]  )  ;", "}", "sb . append (  . ARRAY _ END )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    . NULL _ STRING ;", "}", "int   length    =    array . length ;", "if    ( length    =  =     0  )     {", "return    . EMPTY _ ARRAY ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "sb . append (  . ARRAY _ START )  ;", "} else    {", "sb . append (  . ARRAY _ ELEMENT _ SEPARATOR )  ;", "}", "sb . append ( array [ i ]  )  ;", "}", "sb . append (  . ARRAY _ END )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =    null )     {", "return    . NULL _ STRING ;", "}", "if    ( obj   instanceof   String )     {", "return    (  ( String )     ( obj )  )  ;", "}", "if    ( obj   instanceof   Object [  ]  )     {", "return    . nullSafeToString (  (  ( Object [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   boolean [  ]  )     {", "return    . nullSafeToString (  (  ( boolean [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   byte [  ]  )     {", "return    . nullSafeToString (  (  ( byte [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   char [  ]  )     {", "return    . nullSafeToString (  (  ( char [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   double [  ]  )     {", "return    . nullSafeToString (  (  ( double [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   float [  ]  )     {", "return    . nullSafeToString (  (  ( float [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   int [  ]  )     {", "return    . nullSafeToString (  (  ( int [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   long [  ]  )     {", "return    . nullSafeToString (  (  ( long [  ]  )     ( obj )  )  )  ;", "}", "if    ( obj   instanceof   short [  ]  )     {", "return    . nullSafeToString (  (  ( short [  ]  )     ( obj )  )  )  ;", "}", "String   str    =    obj . toString (  )  ;", "return   str    !  =    null    ?    str    :     . EMPTY _ STRING ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    . NULL _ STRING ;", "}", "int   length    =    array . length ;", "if    ( length    =  =     0  )     {", "return    . EMPTY _ ARRAY ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "sb . append (  . ARRAY _ START )  ;", "} else    {", "sb . append (  . ARRAY _ ELEMENT _ SEPARATOR )  ;", "}", "sb . append ( String . valueOf ( array [ i ]  )  )  ;", "}", "sb . append (  . ARRAY _ END )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    . NULL _ STRING ;", "}", "int   length    =    array . length ;", "if    ( length    =  =     0  )     {", "return    . EMPTY _ ARRAY ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "sb . append (  . ARRAY _ START )  ;", "} else    {", "sb . append (  . ARRAY _ ELEMENT _ SEPARATOR )  ;", "}", "sb . append ( array [ i ]  )  ;", "}", "sb . append (  . ARRAY _ END )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( array    =  =    null )     {", "return    . NULL _ STRING ;", "}", "int   length    =    array . length ;", "if    ( length    =  =     0  )     {", "return    . EMPTY _ ARRAY ;", "}", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "sb . append (  . ARRAY _ START )  ;", "} else    {", "sb . append (  . ARRAY _ ELEMENT _ SEPARATOR )  ;", "}", "sb . append ( array [ i ]  )  ;", "}", "sb . append (  . ARRAY _ END )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToString"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( source   instanceof   Object [  ]  )     {", "return    (  ( Object [  ]  )     ( source )  )  ;", "}", "if    ( source    =  =    null )     {", "return   new   Object [  0  ]  ;", "}", "if    (  !  ( source . getClass (  )  . isArray (  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Source   is   not   an   array :     \"     +    source )  )  ;", "}", "int   length    =    Array . getLength ( source )  ;", "if    ( length    =  =     0  )     {", "return   new   Object [  0  ]  ;", "}", "Class <  ?  >    wrapperType    =    Array . get ( source ,     0  )  . getClass (  )  ;", "Object [  ]    newArray    =     (  ( Object [  ]  )     ( Array . newInstance ( wrapperType ,    length )  )  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "newArray [ i ]     =    Array . get ( source ,    i )  ;", "}", "return   newArray ;", "}", "METHOD_END"], "methodName": ["toObjectArray"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( obj   instanceof   Optional )     {", "Optional <  ?  >    optional    =     (  ( Optional <  ?  >  )     ( obj )  )  ;", "if    (  !  ( optional . isPresent (  )  )  )     {", "return   null ;", "}", "result    =    optional . get (  )  ;", "Assert . isTrue (  (  !  ( result   instanceof   Optional )  )  ,     \" Multi - level   Optional   usage   not   supported \"  )  ;", "return   result ;", "}", "return   obj ;", "}", "METHOD_END"], "methodName": ["unwrapOptional"], "fileName": "org.springframework.util.ObjectUtils"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    newArray    =    ObjectUtils . addObjectToArray ( null ,    null )  ;", "assertEquals (  1  ,    newArray . length )  ;", "assertEquals ( null ,    newArray [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["addNullObjectToNullArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    array    =    new   String [  ]  {     \" foo \"  ,     \" bar \"     }  ;", "String   newElement    =     \" baz \"  ;", "Object [  ]    newArray    =     . addObjectToArray ( array ,    newElement )  ;", "assertEquals (  3  ,    newArray . length )  ;", "assertEquals ( newElement ,    newArray [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["addObjectToArraySunnyDay"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    array    =    new   String [  0  ]  ;", "String   newElement    =     \" foo \"  ;", "String [  ]    newArray    =     . addObjectToArray ( array ,    newElement )  ;", "assertEquals (  1  ,    newArray . length )  ;", "assertEquals ( newElement ,    newArray [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["addObjectToArrayWhenEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   newElement    =     \" foo \"  ;", "String [  ]    newArray    =     . addObjectToArray ( null ,    newElement )  ;", "assertEquals (  1  ,    newArray . length )  ;", "assertEquals ( newElement ,    newArray [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["addObjectToNullArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   existingElement    =     \" foo \"  ;", "String [  ]    array    =    new   String [  ]  {    existingElement    }  ;", "String   newElement    =     \" bar \"  ;", "String [  ]    newArray    =     . addObjectToArray ( array ,    newElement )  ;", "assertEquals (  2  ,    newArray . length )  ;", "assertEquals ( existingElement ,    newArray [  0  ]  )  ;", "assertEquals ( newElement ,    newArray [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["addObjectToSingleNonNullElementArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    array    =    new   String [  ]  {    null    }  ;", "String   newElement    =     \" bar \"  ;", "String [  ]    newArray    =     . addObjectToArray ( array ,    newElement )  ;", "assertEquals (  2  ,    newArray . length )  ;", "assertEquals ( null ,    newArray [  0  ]  )  ;", "assertEquals ( newElement ,    newArray [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["addObjectToSingleNullElementArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   actual    =    ObjectUtils . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "assertTrue (  (  ( array . hashCode (  )  )     !  =    actual )  )  ;", "}", "METHOD_END"], "methodName": ["assertEqualHashCodes"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( ObjectUtils . caseInsensitiveValueOf ( ObjectUtilsTests . Tropes . values (  )  ,     \" foo \"  )  ,    is ( ObjectUtilsTests . Tropes . FOO )  )  ;", "assertThat ( ObjectUtils . caseInsensitiveValueOf ( ObjectUtilsTests . Tropes . values (  )  ,     \" BAR \"  )  ,    is ( ObjectUtilsTests . Tropes . BAR )  )  ;", "exception . expect ( IllegalArgumentException . class )  ;", "exception . expectMessage ( is (  \" constant    [ bogus ]    does   not   exist   in   enum   type    $ Tropes \"  )  )  ;", "ObjectUtils . caseInsensitiveValueOf ( ObjectUtilsTests . Tropes . values (  )  ,     \" bogus \"  )  ;", "}", "METHOD_END"], "methodName": ["caseInsensitiveValueOf"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( ObjectUtils . containsConstant ( ObjectUtilsTests . Tropes . values (  )  ,     \" FOO \"  )  ,    is ( true )  )  ;", "assertThat ( ObjectUtils . containsConstant ( ObjectUtilsTests . Tropes . values (  )  ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( ObjectUtils . containsConstant ( ObjectUtilsTests . Tropes . values (  )  ,     \" BaR \"  )  ,    is ( true )  )  ;", "assertThat ( ObjectUtils . containsConstant ( ObjectUtilsTests . Tropes . values (  )  ,     \" bar \"  )  ,    is ( true )  )  ;", "assertThat ( ObjectUtils . containsConstant ( ObjectUtilsTests . Tropes . values (  )  ,     \" BAZ \"  )  ,    is ( true )  )  ;", "assertThat ( ObjectUtils . containsConstant ( ObjectUtilsTests . Tropes . values (  )  ,     \" baz \"  )  ,    is ( true )  )  ;", "assertThat ( ObjectUtils . containsConstant ( ObjectUtilsTests . Tropes . values (  )  ,     \" BOGUS \"  )  ,    is ( false )  )  ;", "assertThat ( ObjectUtils . containsConstant ( ObjectUtilsTests . Tropes . values (  )  ,     \" FOO \"  ,    true )  ,    is ( true )  )  ;", "assertThat ( ObjectUtils . containsConstant ( ObjectUtilsTests . Tropes . values (  )  ,     \" foo \"  ,    true )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["containsConstant"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =    Boolean . FALSE . hashCode (  )  ;", "assertEquals ( expected ,     . hashCode ( false )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithBooleanFalse"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =    Boolean . TRUE . hashCode (  )  ;", "assertEquals ( expected ,     . hashCode ( true )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithBooleanTrue"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "double   dbl    =     9  8  3  0  .  4  3  ;", "int   expected    =    new   Double ( dbl )  . hashCode (  )  ;", "assertEquals ( expected ,     . hashCode ( dbl )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithDouble"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "float   flt    =     3  4  .  8 F ;", "int   expected    =    new   Float ( flt )  . hashCode (  )  ;", "assertEquals ( expected ,     . hashCode ( flt )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithFloat"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "long   lng    =     8  8  3 L ;", "int   expected    =    new   Long ( lng )  . hashCode (  )  ;", "assertEquals ( expected ,     . hashCode ( lng )  )  ;", "}", "METHOD_END"], "methodName": ["hashCodeWithLong"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   obj    =    new   Object (  )  ;", "String   expected    =     (  ( obj . getClass (  )  . getName (  )  )     +     \"  @  \"  )     +     (  . getIdentityHexString ( obj )  )  ;", "String   actual    =     . identityToString ( obj )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["identityToString"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  \"  ,    ObjectUtils . identityToString ( null )  )  ;", "}", "METHOD_END"], "methodName": ["identityToStringWithNullObject"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveArray ( boolean [  ]  . class )  )  ;", "}", "METHOD_END"], "methodName": ["isArrayOfPrimitivesWithBooleanArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( ClassUtils . isPrimitiveArray ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["isArrayOfPrimitivesWithNonArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( ClassUtils . isPrimitiveArray ( Object [  ]  . class )  )  ;", "}", "METHOD_END"], "methodName": ["isArrayOfPrimitivesWithObjectArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ObjectUtils . isCheckedException ( new   Exception (  )  )  )  ;", "assertTrue ( ObjectUtils . isCheckedException ( new   SQLException (  )  )  )  ;", "assertFalse ( ObjectUtils . isCheckedException ( new   RuntimeException (  )  )  )  ;", "assertFalse ( ObjectUtils . isCheckedException ( new   IllegalArgumentException (  \"  \"  )  )  )  ;", "assertTrue ( ObjectUtils . isCheckedException ( new   Throwable (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isCheckedException"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    empty    =    new   Class <  ?  >  [  0  ]  ;", "Class <  ?  >  [  ]    exception    =    new   Class <  ?  >  [  ]  {    Exception . class    }  ;", "Class <  ?  >  [  ]    sqlAndIO    =    new   Class <  ?  >  [  ]  {    SQLException . class ,    IOException . class    }  ;", "Class <  ?  >  [  ]    throwable    =    new   Class <  ?  >  [  ]  {    Throwable . class    }  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   RuntimeException (  )  )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   RuntimeException (  )  ,    empty )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   RuntimeException (  )  ,    exception )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   RuntimeException (  )  ,    sqlAndIO )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   RuntimeException (  )  ,    throwable )  )  ;", "assertFalse (  . isCompatibleWithThrowsClause ( new   Exception (  )  )  )  ;", "assertFalse (  . isCompatibleWithThrowsClause ( new   Exception (  )  ,    empty )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   Exception (  )  ,    exception )  )  ;", "assertFalse (  . isCompatibleWithThrowsClause ( new   Exception (  )  ,    sqlAndIO )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   Exception (  )  ,    throwable )  )  ;", "assertFalse (  . isCompatibleWithThrowsClause ( new   SQLException (  )  )  )  ;", "assertFalse (  . isCompatibleWithThrowsClause ( new   SQLException (  )  ,    empty )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   SQLException (  )  ,    exception )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   SQLException (  )  ,    sqlAndIO )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   SQLException (  )  ,    throwable )  )  ;", "assertFalse (  . isCompatibleWithThrowsClause ( new   Throwable (  )  )  )  ;", "assertFalse (  . isCompatibleWithThrowsClause ( new   Throwable (  )  ,    empty )  )  ;", "assertFalse (  . isCompatibleWithThrowsClause ( new   Throwable (  )  ,    exception )  )  ;", "assertFalse (  . isCompatibleWithThrowsClause ( new   Throwable (  )  ,    sqlAndIO )  )  ;", "assertTrue (  . isCompatibleWithThrowsClause ( new   Throwable (  )  ,    throwable )  )  ;", "}", "METHOD_END"], "methodName": ["isCompatibleWithThrowsClause"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ObjectUtils . isEmpty ( new   char [  0  ]  )  )  ;", "assertTrue ( ObjectUtils . isEmpty ( new   Object [  0  ]  )  )  ;", "assertTrue ( ObjectUtils . isEmpty ( new   Integer [  0  ]  )  )  ;", "assertFalse ( ObjectUtils . isEmpty ( new   int [  ]  {     4  2     }  )  )  ;", "assertFalse ( ObjectUtils . isEmpty ( new   Integer [  ]  {     4  2     }  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmptyArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ObjectUtils . isEmpty ( new   StringBuilder (  )  )  )  ;", "assertTrue ( ObjectUtils . isEmpty (  \"  \"  )  )  ;", "assertFalse ( ObjectUtils . isEmpty ( new   StringBuilder (  \" foo \"  )  )  )  ;", "assertFalse ( ObjectUtils . isEmpty (  \"           \"  )  )  ;", "assertFalse ( ObjectUtils . isEmpty (  \"  \\ t \"  )  )  ;", "assertFalse ( ObjectUtils . isEmpty (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmptyCharSequence"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ObjectUtils . isEmpty ( Collections . emptyList (  )  )  )  ;", "assertTrue ( ObjectUtils . isEmpty ( Collections . emptySet (  )  )  )  ;", "Set < String >    set    =    new   HashSet <  >  (  )  ;", "set . add (  \" foo \"  )  ;", "assertFalse ( ObjectUtils . isEmpty ( set )  )  ;", "assertFalse ( ObjectUtils . isEmpty ( Arrays . asList (  \" foo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmptyCollection"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ObjectUtils . isEmpty ( Collections . emptyMap (  )  )  )  ;", "HashMap < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     4  2 L )  ;", "assertFalse ( ObjectUtils . isEmpty ( map )  )  ;", "}", "METHOD_END"], "methodName": ["isEmptyMap"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ObjectUtils . isEmpty ( null )  )  ;", "}", "METHOD_END"], "methodName": ["isEmptyNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( ObjectUtils . isEmpty (  4  2 L )  )  ;", "assertFalse ( ObjectUtils . isEmpty ( new   Object (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmptyUnsupportedObjectType"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithBooleanPrimitiveClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithBooleanWrapperClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( byte . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithBytePrimitiveClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( Byte . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithByteWrapperClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( char . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithCharClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( Character . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithCharacterClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( double . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithDoublePrimitiveClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithDoubleWrapperClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( float . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithFloatPrimitiveClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( Float . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithFloatWrapperClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( int . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithIntClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithIntegerClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( long . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithLongPrimitiveClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( Long . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithLongWrapperClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( ClassUtils . isPrimitiveOrWrapper ( Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithNonPrimitiveOrWrapperClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( short . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithShortPrimitiveClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ClassUtils . isPrimitiveOrWrapper ( Short . class )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrWrapperWithShortWrapperClass"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ObjectUtils . nullSafeEquals ( new   String [  ]  {     \" a \"  ,     \" b \"  ,     \" c \"     }  ,    new   String [  ]  {     \" a \"  ,     \" b \"  ,     \" c \"     }  )  )  ;", "assertTrue ( ObjectUtils . nullSafeEquals ( new   int [  ]  {     1  ,     2  ,     3     }  ,    new   int [  ]  {     1  ,     2  ,     3     }  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeEqualsWithArrays"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =     (  3  1     *     7  )     +     ( Boolean . TRUE . hashCode (  )  )  ;", "expected    =     (  3  1     *    expected )     +     ( Boolean . FALSE . hashCode (  )  )  ;", "boolean [  ]    array    =    new   boolean [  ]  {    true ,    false    }  ;", "int   actual    =     . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithBooleanArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( boolean [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithBooleanArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =     (  3  1     *     7  )     +     8  ;", "expected    =     (  3  1     *    expected )     +     1  0  ;", "byte [  ]    array    =    new   byte [  ]  {     8  ,     1  0     }  ;", "int   actual    =     . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithByteArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( byte [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithByteArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =     (  3  1     *     7  )     +     ' a '  ;", "expected    =     (  3  1     *    expected )     +     ' E '  ;", "char [  ]    array    =    new   char [  ]  {     ' a '  ,     ' E '     }  ;", "int   actual    =     . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithCharArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( char [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithCharArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "long   bits    =    Double . doubleToLongBits (  8  4  4  9  .  6  5  )  ;", "int   expected    =     (  3  1     *     7  )     +     (  ( int )     ( bits    ^     ( bits    >  >  >     3  2  )  )  )  ;", "bits    =    Double . doubleToLongBits (  9  9  4  4  .  9  2  3  )  ;", "expected    =     (  3  1     *    expected )     +     (  ( int )     ( bits    ^     ( bits    >  >  >     3  2  )  )  )  ;", "double [  ]    array    =    new   double [  ]  {     8  4  4  9  .  6  5  ,     9  9  4  4  .  9  2  3     }  ;", "int   actual    =     . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithDoubleArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( double [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithDoubleArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =     (  3  1     *     7  )     +     ( Float . floatToIntBits (  9  .  6 F )  )  ;", "expected    =     (  3  1     *    expected )     +     ( Float . floatToIntBits (  7  .  4 F )  )  ;", "float [  ]    array    =    new   float [  ]  {     9  .  6 F ,     7  .  4 F    }  ;", "int   actual    =     . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithFloatArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( float [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithFloatArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =     (  3  1     *     7  )     +     8  8  4  ;", "expected    =     (  3  1     *    expected )     +     3  4  0  ;", "int [  ]    array    =    new   int [  ]  {     8  8  4  ,     3  4  0     }  ;", "int   actual    =     . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithIntArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( int [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithIntArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "long   lng    =     7  9  9  3 L ;", "int   expected    =     (  3  1     *     7  )     +     (  ( int )     ( lng    ^     ( lng    >  >  >     3  2  )  )  )  ;", "lng    =     8  4  3  2  0 L ;", "expected    =     (  3  1     *    expected )     +     (  ( int )     ( lng    ^     ( lng    >  >  >     3  2  )  )  )  ;", "long [  ]    array    =    new   long [  ]  {     7  9  9  3 L ,     8  4  3  2  0 L    }  ;", "int   actual    =     . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithLongArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( long [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithLongArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   str    =     \" Luke \"  ;", "assertEquals ( str . hashCode (  )  ,     . nullSafeHashCode ( str )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObject"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =     (  3  1     *     7  )     +     (  \" Leia \"  . hashCode (  )  )  ;", "expected    =     (  3  1     *    expected )     +     (  \" Han \"  . hashCode (  )  )  ;", "Object [  ]    array    =    new   Object [  ]  {     \" Leia \"  ,     \" Han \"     }  ;", "int   actual    =     . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( Object [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    new   boolean [  ]  {    true ,    false    }  ;", "int   expected    =     . nullSafeHashCode (  (  ( boolean [  ]  )     ( array )  )  )  ;", "assertEqualHashCodes ( expected ,    array )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectBeingBooleanArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    new   byte [  ]  {     6  ,     3  9     }  ;", "int   expected    =     . nullSafeHashCode (  (  ( byte [  ]  )     ( array )  )  )  ;", "assertEqualHashCodes ( expected ,    array )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectBeingByteArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    new   char [  ]  {     ' l '  ,     ' M '     }  ;", "int   expected    =     . nullSafeHashCode (  (  ( char [  ]  )     ( array )  )  )  ;", "assertEqualHashCodes ( expected ,    array )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectBeingCharArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    new   double [  ]  {     6  8  9  3  0  .  9  9  3  ,     9  0  2  2  .  0  0  9     }  ;", "int   expected    =     . nullSafeHashCode (  (  ( double [  ]  )     ( array )  )  )  ;", "assertEqualHashCodes ( expected ,    array )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectBeingDoubleArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    new   float [  ]  {     9  .  9 F ,     9  .  5  4 F    }  ;", "int   expected    =     . nullSafeHashCode (  (  ( float [  ]  )     ( array )  )  )  ;", "assertEqualHashCodes ( expected ,    array )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectBeingFloatArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    new   int [  ]  {     8  9  ,     3  2     }  ;", "int   expected    =     . nullSafeHashCode (  (  ( int [  ]  )     ( array )  )  )  ;", "assertEqualHashCodes ( expected ,    array )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectBeingIntArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    new   long [  ]  {     4  3  8  9  ,     3  2  0     }  ;", "int   expected    =     . nullSafeHashCode (  (  ( long [  ]  )     ( array )  )  )  ;", "assertEqualHashCodes ( expected ,    array )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectBeingLongArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    new   Object [  ]  {     \" Luke \"  ,     \" Anakin \"     }  ;", "int   expected    =     . nullSafeHashCode (  (  ( Object [  ]  )     ( array )  )  )  ;", "assertEqualHashCodes ( expected ,    array )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectBeingObjectArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   array    =    new   short [  ]  {     5  ,     3     }  ;", "int   expected    =     . nullSafeHashCode (  (  ( short [  ]  )     ( array )  )  )  ;", "assertEqualHashCodes ( expected ,    array )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectBeingShortArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( Object )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithObjectEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   expected    =     (  3  1     *     7  )     +     7  0  ;", "expected    =     (  3  1     *    expected )     +     8  ;", "short [  ]    array    =    new   short [  ]  {     7  0  ,     8     }  ;", "int   actual    =     . nullSafeHashCode ( array )  ;", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithShortArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    ObjectUtils . nullSafeHashCode (  (  ( short [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeHashCodeWithShortArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    array    =    new   boolean [  ]  {    true ,    false    }  ;", "assertEquals (  \"  { true ,    false }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithBooleanArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    array    =    new   boolean [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithBooleanArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( boolean [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithBooleanArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    array    =    new   byte [  ]  {     5  ,     8     }  ;", "assertEquals (  \"  {  5  ,     8  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithByteArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    array    =    new   byte [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithByteArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( byte [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithByteArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "char [  ]    array    =    new   char [  ]  {     ' A '  ,     ' B '     }  ;", "assertEquals (  \"  {  ' A '  ,     ' B '  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithCharArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "char [  ]    array    =    new   char [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithCharArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( char [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithCharArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "double [  ]    array    =    new   double [  ]  {     8  5  9  4  .  9  3  ,     8  5  9  4  0  2  3  .  9  5     }  ;", "assertEquals (  \"  {  8  5  9  4  .  9  3  ,     8  5  9  4  0  2  3  .  9  5  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithDoubleArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "double [  ]    array    =    new   double [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithDoubleArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( double [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithDoubleArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "float [  ]    array    =    new   float [  ]  {     8  .  6 F ,     4  3  .  8 F    }  ;", "assertEquals (  \"  {  8  .  6  ,     4  3  .  8  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithFloatArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "float [  ]    array    =    new   float [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithFloatArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( float [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithFloatArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int [  ]    array    =    new   int [  ]  {     9  ,     6  4     }  ;", "assertEquals (  \"  {  9  ,     6  4  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithIntArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int [  ]    array    =    new   int [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithIntArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( int [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithIntArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "long [  ]    array    =    new   long [  ]  {     4  3  4 L ,     2  3  4  2  3 L    }  ;", "assertEquals (  \"  {  4  3  4  ,     2  3  4  2  3  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithLongArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "long [  ]    array    =    new   long [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithLongArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( long [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithLongArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    array    =    new   Object [  ]  {     \" Han \"  ,    Long . valueOf (  4  3  )     }  ;", "assertEquals (  \"  { Han ,     4  3  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithObjectArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    array    =    new   Object [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithObjectArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( Object [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithObjectArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" I   shoh   love   tha   taste   of   mangoes \"  ,    ObjectUtils . nullSafeToString (  \" I   shoh   love   tha   taste   of   mangoes \"  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithPlainOldString"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "short [  ]    array    =    new   short [  ]  {     7  ,     9     }  ;", "assertEquals (  \"  {  7  ,     9  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithShortArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "short [  ]    array    =    new   short [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithShortArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( short [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithShortArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    array    =    new   String [  ]  {     \" Luke \"  ,     \" Anakin \"     }  ;", "assertEquals (  \"  { Luke ,    Anakin }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithStringArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    array    =    new   String [  ]  {        }  ;", "assertEquals (  \"  {  }  \"  ,     . nullSafeToString ( array )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithStringArrayBeingEmpty"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" null \"  ,    ObjectUtils . nullSafeToString (  (  ( String [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nullSafeToStringWithStringArrayEqualToNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int [  ]    a    =    new   int [  ]  {     1  ,     2  ,     3  ,     4  ,     5     }  ;", "Integer [  ]    wrapper    =     (  ( Integer [  ]  )     (  . toObjectArray ( a )  )  )  ;", "assertTrue (  (  ( wrapper . length )     =  =     5  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( wrapper . length )  ;    i +  +  )     {", "assertEquals ( a [ i ]  ,    wrapper [ i ]  . intValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toObjectArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    objects    =    ObjectUtils . toObjectArray ( new   byte [  ]  {        }  )  ;", "assertNotNull ( objects )  ;", "assertEquals (  0  ,    objects . length )  ;", "}", "METHOD_END"], "methodName": ["toObjectArrayWithEmptyPrimitiveArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", ". toObjectArray (  \" Not   an    [  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["toObjectArrayWithNonArrayType"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    source    =    new   String [  ]  {     \" Bingo \"     }  ;", "assertArrayEquals ( source ,     . toObjectArray ( source )  )  ;", "}", "METHOD_END"], "methodName": ["toObjectArrayWithNonPrimitiveArray"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    objects    =    ObjectUtils . toObjectArray ( null )  ;", "assertNotNull ( objects )  ;", "assertEquals (  0  ,    objects . length )  ;", "}", "METHOD_END"], "methodName": ["toObjectArrayWithNull"], "fileName": "org.springframework.util.ObjectUtilsTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pattern    =  =    null )     |  |     ( str    =  =    null )  )     {", "return   false ;", "}", "int   firstIndex    =    pattern . indexOf (  '  *  '  )  ;", "if    ( firstIndex    =  =     (  -  1  )  )     {", "return   pattern . equals ( str )  ;", "}", "if    ( firstIndex    =  =     0  )     {", "if    (  ( pattern . length (  )  )     =  =     1  )     {", "return   true ;", "}", "int   nextIndex    =    pattern . indexOf (  '  *  '  ,     ( firstIndex    +     1  )  )  ;", "if    ( nextIndex    =  =     (  -  1  )  )     {", "return   str . endsWith ( pattern . substring (  1  )  )  ;", "}", "String   part    =    pattern . substring (  1  ,    nextIndex )  ;", "if    (  \"  \"  . equals ( part )  )     {", "return    . simpleMatch ( pattern . substring ( nextIndex )  ,    str )  ;", "}", "int   partIndex    =    str . indexOf ( part )  ;", "while    ( partIndex    !  =     (  -  1  )  )     {", "if    (  . simpleMatch ( pattern . substring ( nextIndex )  ,    str . substring (  ( partIndex    +     ( part . length (  )  )  )  )  )  )     {", "return   true ;", "}", "partIndex    =    str . indexOf ( part ,     ( partIndex    +     1  )  )  ;", "}", "return   false ;", "}", "return    (  (  ( str . length (  )  )     >  =    firstIndex )     &  &     ( pattern . substring (  0  ,    firstIndex )  . equals ( str . substring (  0  ,    firstIndex )  )  )  )     &  &     (  . simpleMatch ( pattern . substring ( firstIndex )  ,    str . substring ( firstIndex )  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleMatch"], "fileName": "org.springframework.util.PatternMatchUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( patterns    !  =    null )     {", "for    ( String   pattern    :    patterns )     {", "if    (  . simpleMatch ( pattern ,    str )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["simpleMatch"], "fileName": "org.springframework.util.PatternMatchUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( shouldMatch ,    PatternMatchUtils . simpleMatch ( pattern ,    str )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "org.springframework.util.PatternMatchUtilsTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  * stuff *  \"  ,     \" getMeTest \"  ,    false )  ;", "doTest (  \"  * stuff *  \"  ,     \" getstuffTest \"  ,    true )  ;", "doTest (  \"  * stuff *  \"  ,     \" stuffTest \"  ,    true )  ;", "doTest (  \"  * stuff *  \"  ,     \" getstuff \"  ,    true )  ;", "doTest (  \"  * stuff *  \"  ,     \" stuff \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testBetween"], "fileName": "org.springframework.util.PatternMatchUtilsTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  * Test \"  ,     \" getMeTest \"  ,    true )  ;", "doTest (  \"  * Test \"  ,     \" setMe \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testEndsWith"], "fileName": "org.springframework.util.PatternMatchUtilsTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  * a \"  ,     \"  *  \"  ,    false )  ;", "doTest (  \"  * a \"  ,     \" a \"  ,    true )  ;", "doTest (  \"  * a \"  ,     \" b \"  ,    false )  ;", "doTest (  \"  * a \"  ,     \" aa \"  ,    true )  ;", "doTest (  \"  * a \"  ,     \" ba \"  ,    true )  ;", "doTest (  \"  * a \"  ,     \" ab \"  ,    false )  ;", "doTest (  \"  *  * a \"  ,     \"  *  \"  ,    false )  ;", "doTest (  \"  *  * a \"  ,     \" a \"  ,    true )  ;", "doTest (  \"  *  * a \"  ,     \" b \"  ,    false )  ;", "doTest (  \"  *  * a \"  ,     \" aa \"  ,    true )  ;", "doTest (  \"  *  * a \"  ,     \" ba \"  ,    true )  ;", "doTest (  \"  *  * a \"  ,     \" ab \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testPatternVariants"], "fileName": "org.springframework.util.PatternMatchUtilsTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  *  1  *  2  *  3  *  \"  ,     \"  0  0  1  1  0  0  2  0  0  1  0  1  0  0  3  0  0  2  0  2  0  1  0  3  0  \"  ,    true )  ;", "doTest (  \"  1  *  2  *  3  *  4  \"  ,     \"  1  0  3  0  0  2  0  4  \"  ,    false )  ;", "doTest (  \"  1  *  2  *  3  *  3  \"  ,     \"  1  0  3  0  0  2  0  3  \"  ,    false )  ;", "doTest (  \"  *  1  *  2  *  3  *  \"  ,     \"  1  2  3  \"  ,    true )  ;", "doTest (  \"  *  1  *  2  *  3  *  \"  ,     \"  1  3  2  \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testRidiculous"], "fileName": "org.springframework.util.PatternMatchUtilsTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" on * Event \"  ,     \" onMyEvent \"  ,    true )  ;", "doTest (  \" on * Event \"  ,     \" onEvent \"  ,    true )  ;", "doTest (  \"  3  *  3  \"  ,     \"  3  \"  ,    false )  ;", "doTest (  \"  3  *  3  \"  ,     \"  3  3  \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testStartsEnds"], "fileName": "org.springframework.util.PatternMatchUtilsTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  1  2  *  4  5  *  7  8  \"  ,     \"  1  2  3  4  5  6  7  8  \"  ,    true )  ;", "doTest (  \"  1  2  *  4  5  *  7  8  \"  ,     \"  1  2  3  4  5  6  7  8  9  \"  ,    false )  ;", "doTest (  \"  1  2  *  4  5  *  7  8  \"  ,     \"  0  1  2  3  4  5  6  7  8  \"  ,    false )  ;", "doTest (  \"  1  2  *  4  5  *  7  8  \"  ,     \"  1  2  4  5  7  8  \"  ,    true )  ;", "doTest (  \"  1  2  *  4  5  *  7  8  \"  ,     \"  1  2  4  5  4  5  7  8  7  8  \"  ,    true )  ;", "doTest (  \"  3  *  3  *  3  \"  ,     \"  3  3  \"  ,    false )  ;", "doTest (  \"  3  *  3  *  3  \"  ,     \"  3  3  3  \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testStartsEndsBetween"], "fileName": "org.springframework.util.PatternMatchUtilsTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" get *  \"  ,     \" getMe \"  ,    true )  ;", "doTest (  \" get *  \"  ,     \" setMe \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testStartsWith"], "fileName": "org.springframework.util.PatternMatchUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( false ,    PatternMatchUtils . simpleMatch (  (  ( String )     ( null )  )  ,     \"  \"  )  )  ;", "assertEquals ( false ,    PatternMatchUtils . simpleMatch (  \"  1  \"  ,    null )  )  ;", "doTest (  \"  *  \"  ,     \"  1  2  3  \"  ,    true )  ;", "doTest (  \"  1  2  3  \"  ,     \"  1  2  3  \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testTrivial"], "fileName": "org.springframework.util.PatternMatchUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultPropertiesPersister   persister    =    new   DefaultPropertiesPersister (  )  ;", "Properties   props    =    new   Properties (  )  ;", "if    ( useReader )     {", "persister . load ( props ,    new   StringReader ( propString )  )  ;", "} else    {", "persister . load ( props ,    new   ByteArrayInputStream ( propString . getBytes (  )  )  )  ;", "}", "assertEquals (  \" message 1  \"  ,    props . getProperty (  \" code 1  \"  )  )  ;", "assertEquals (  \" message 2  \"  ,    props . getProperty (  \" code 2  \"  )  )  ;", "return   props ;", "}", "METHOD_END"], "methodName": ["loadProperties"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "String   propString    =     \" code 1  = message 1  \\ ncode 2  : message 2  \"  ;", "props    =    load ( propString ,    false )  ;", "String   propCopy    =    store ( props ,    null ,    false )  ;", "load ( propCopy ,    false )  ;", "}", "METHOD_END"], "methodName": ["propertiesPersister"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "String   propString    =     \" code 1  = message 1  \\ ncode 2  : message 2  \\ ncode 3  =  \"  ;", "props    =    load ( propString ,    false )  ;", "String   propCopy    =    store ( props ,    null ,    false )  ;", "load ( propCopy ,    false )  ;", "}", "METHOD_END"], "methodName": ["propertiesPersisterWithEmptyValue"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "String   propString    =     \" code 1  = message 1  \\ ncode 2  : message 2  \"  ;", "props    =    load ( propString ,    false )  ;", "String   propCopy    =    store ( props ,     \" myHeader \"  ,    false )  ;", "load ( propCopy ,    false )  ;", "}", "METHOD_END"], "methodName": ["propertiesPersisterWithHeader"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "String   propString    =     \" code 1  = message 1  \\ ncode 2  : message 2  \"  ;", "props    =    load ( propString ,    true )  ;", "String   propCopy    =    store ( props ,    null ,    true )  ;", "load ( propCopy ,    false )  ;", "}", "METHOD_END"], "methodName": ["propertiesPersisterWithReader"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "String   propString    =     \" code 1  = message 1  \\ ncode 2  : message 2  \\ ncode 3  =  \"  ;", "props    =    load ( propString ,    true )  ;", "String   propCopy    =    store ( props ,    null ,    true )  ;", "load ( propCopy ,    false )  ;", "}", "METHOD_END"], "methodName": ["propertiesPersisterWithReaderAndEmptyValue"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "String   propString    =     \" code 1  \\ t =  \\ tmessage 1  \\ n      code 2     \\ t       :     \\ t   message 2  \"  ;", "props    =    load ( propString ,    true )  ;", "String   propCopy    =    store ( props ,     \" myHeader \"  ,    true )  ;", "load ( propCopy ,    false )  ;", "}", "METHOD_END"], "methodName": ["propertiesPersisterWithReaderAndHeader"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "String   propString    =     \"    code 1  \\ t =     \\ tmessage 1  \\ n      code 2     \\ t       :  \\ t   mess \\  \\  \\ n    \\ t      age 2  \"  ;", "props    =    load ( propString ,    true )  ;", "String   propCopy    =    store ( props ,    null ,    true )  ;", "load ( propCopy ,    false )  ;", "}", "METHOD_END"], "methodName": ["propertiesPersisterWithReaderAndWhitespace"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "String   propString    =     \"    code 1  \\ t =     \\ tmessage 1  \\ n      code 2     \\ t       :  \\ t   mess \\  \\  \\ n    \\ t      age 2  \"  ;", "props    =    load ( propString ,    false )  ;", "String   propCopy    =    store ( props ,    null ,    false )  ;", "load ( propCopy ,    false )  ;", "}", "METHOD_END"], "methodName": ["propertiesPersisterWithWhitespace"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "DefaultPropertiesPersister   persister    =    new   DefaultPropertiesPersister (  )  ;", "String   propCopy    =    null ;", "if    ( useWriter )     {", "StringWriter   propWriter    =    new   StringWriter (  )  ;", "persister . store ( props ,    propWriter ,    header )  ;", "propCopy    =    propWriter . toString (  )  ;", "} else    {", "ByteArrayOutputStream   propOut    =    new   ByteArrayOutputStream (  )  ;", "persister . store ( props ,    propOut ,    header )  ;", "propCopy    =    new   String ( propOut . toByteArray (  )  )  ;", "}", "if    ( header    !  =    null )     {", "assertTrue (  (  ( propCopy . indexOf ( header )  )     !  =     (  -  1  )  )  )  ;", "}", "assertTrue (  (  ( propCopy . indexOf (  \"  \\ ncode 1  = message 1  \"  )  )     !  =     (  -  1  )  )  )  ;", "assertTrue (  (  ( propCopy . indexOf (  \"  \\ ncode 2  = message 2  \"  )  )     !  =     (  -  1  )  )  )  ;", "return   propCopy ;", "}", "METHOD_END"], "methodName": ["storeProperties"], "fileName": "org.springframework.util.PropertiesPersisterTests"}, {"methodBody": ["METHOD_START", "{", "int   index    =    startIndex    +     ( this . placeholderPrefix . length (  )  )  ;", "int   withinNested    =     0  ;", "while    ( index    <     ( buf . length (  )  )  )     {", "if    ( StringUtils . substringMatch ( buf ,    index ,    this . placeholderSuffix )  )     {", "if    ( withinNested    >     0  )     {", "withinNested -  -  ;", "index    =    index    +     ( this . placeholderSuffix . length (  )  )  ;", "} else    {", "return   index ;", "}", "} else", "if    ( StringUtils . substringMatch ( buf ,    index ,    this . simplePrefix )  )     {", "withinNested +  +  ;", "index    =    index    +     ( this . simplePrefix . length (  )  )  ;", "} else    {", "index +  +  ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["findPlaceholderEndIndex"], "fileName": "org.springframework.util.PropertyPlaceholderHelper"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder ( value )  ;", "int   startIndex    =    value . indexOf ( this . placeholderPrefix )  ;", "while    ( startIndex    !  =     (  -  1  )  )     {", "int   endIndex    =    findPlaceholderEndIndex ( result ,    startIndex )  ;", "if    ( endIndex    !  =     (  -  1  )  )     {", "String   placeholder    =    result . substring (  ( startIndex    +     ( this . placeholderPrefix . length (  )  )  )  ,    endIndex )  ;", "String   originalPlaceholder    =    placeholder ;", "if    (  !  ( visitedPlaceholders . add ( originalPlaceholder )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Circular   placeholder   reference    '  \"     +    originalPlaceholder )     +     \"  '    in   property   definitions \"  )  )  ;", "}", "placeholder    =    parseStringValue ( placeholder ,    placeholderResolver ,    visitedPlaceholders )  ;", "String   propVal    =    placeholderResolver . resolvePlaceholder ( placeholder )  ;", "if    (  ( propVal    =  =    null )     &  &     (  ( this . valueSeparator )     !  =    null )  )     {", "int   separatorIndex    =    placeholder . indexOf ( this . valueSeparator )  ;", "if    ( separatorIndex    !  =     (  -  1  )  )     {", "String   actualPlaceholder    =    placeholder . substring (  0  ,    separatorIndex )  ;", "String   defaultValue    =    placeholder . substring (  ( separatorIndex    +     ( this . valueSeparator . length (  )  )  )  )  ;", "propVal    =    placeholderResolver . resolvePlaceholder ( actualPlaceholder )  ;", "if    ( propVal    =  =    null )     {", "propVal    =    defaultValue ;", "}", "}", "}", "if    ( propVal    !  =    null )     {", "propVal    =    parseStringValue ( propVal ,    placeholderResolver ,    visitedPlaceholders )  ;", "result . replace ( startIndex ,     ( endIndex    +     ( this . placeholderSuffix . length (  )  )  )  ,    propVal )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Resolved   placeholder    '  \"     +    placeholder )     +     \"  '  \"  )  )  ;", "}", "startIndex    =    result . indexOf ( this . placeholderPrefix ,     ( startIndex    +     ( propVal . length (  )  )  )  )  ;", "} else", "if    ( this . ignoreUnresolvablePlaceholders )     {", "startIndex    =    result . indexOf ( this . placeholderPrefix ,     ( endIndex    +     ( this . placeholderSuffix . length (  )  )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Could   not   resolve   placeholder    '  \"     +    placeholder )     +     \"  '  \"  )     +     \"    in   value    \\  \"  \"  )     +    value )     +     \"  \\  \"  \"  )  )  ;", "}", "visitedPlaceholders . remove ( originalPlaceholder )  ;", "} else    {", "startIndex    =     -  1  ;", "}", "}", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["parseStringValue"], "fileName": "org.springframework.util.PropertyPlaceholderHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( properties ,     \"  ' properties '    must   not   be   null \"  )  ;", "return   replaces ( value ,    properties :  : getProperty )  ;", "}", "METHOD_END"], "methodName": ["replacePlaceholders"], "fileName": "org.springframework.util.PropertyPlaceholderHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( value ,     \"  ' value '    must   not   be   null \"  )  ;", "return   parseStringValue ( value ,    pResolver ,    new   HashSet <  >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["replacePlaceholders"], "fileName": "org.springframework.util.PropertyPlaceholderHelper"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" foo =  $  { b $  { inner }  }  \"  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" bar \"  ,     \" bar \"  )  ;", "props . setProperty (  \" inner \"  ,     \" ar \"  )  ;", "assertEquals (  \" foo = bar \"  ,    this . helper . replaces ( text ,    props )  )  ;", "text    =     \"  $  { top }  \"  ;", "props    =    new   Properties (  )  ;", "props . setProperty (  \" top \"  ,     \"  $  { child }  +  $  { child }  \"  )  ;", "props . setProperty (  \" child \"  ,     \"  $  {  $  { differentiator }  . grandchild }  \"  )  ;", "props . setProperty (  \" differentiator \"  ,     \" first \"  )  ;", "props . setProperty (  \" first . grandchild \"  ,     \" actualValue \"  )  ;", "assertEquals (  \" actualValue + actualValue \"  ,    this . helper . replaces ( text ,    props )  )  ;", "}", "METHOD_END"], "methodName": ["testRecurseInPlaceholder"], "fileName": "org.springframework.util.PropertyPlaceholderHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" foo =  $  { bar }  \"  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" bar \"  ,     \"  $  { baz }  \"  )  ;", "props . setProperty (  \" baz \"  ,     \" bar \"  )  ;", "assertEquals (  \" foo = bar \"  ,    this . helper . replaces ( text ,    props )  )  ;", "}", "METHOD_END"], "methodName": ["testRecurseInProperty"], "fileName": "org.springframework.util.PropertyPlaceholderHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" foo =  $  { foo }  , bar =  $  { bar }  \"  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" foo \"  ,     \" bar \"  )  ;", "helper    =    new    (  \"  $  {  \"  ,     \"  }  \"  ,    null ,    false )  ;", "assertEquals (  \" foo = bar , bar =  $  { bar }  \"  ,    helper . replacePlaceholders ( text ,    props )  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedPlaceholderAsError"], "fileName": "org.springframework.util.PropertyPlaceholderHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" foo =  $  { foo }  , bar =  $  { bar }  \"  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" foo \"  ,     \" bar \"  )  ;", "assertEquals (  \" foo = bar , bar =  $  { bar }  \"  ,    this . helper . replaces ( text ,    props )  )  ;", "}", "METHOD_END"], "methodName": ["testUnresolvedPlaceholderIsIgnored"], "fileName": "org.springframework.util.PropertyPlaceholderHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" foo =  $  { foo }  , bar =  $  { bar }  \"  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" foo \"  ,     \" bar \"  )  ;", "props . setProperty (  \" bar \"  ,     \" baz \"  )  ;", "assertEquals (  \" foo = bar , bar = baz \"  ,    this . helper . replaces ( text ,    props )  )  ;", "}", "METHOD_END"], "methodName": ["testWithMultipleProperties"], "fileName": "org.springframework.util.PropertyPlaceholderHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" foo =  $  { foo }  \"  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" foo \"  ,     \" bar \"  )  ;", "assertEquals (  \" foo = bar \"  ,    this . helper . replaces ( text ,    props )  )  ;", "}", "METHOD_END"], "methodName": ["testWithProperties"], "fileName": "org.springframework.util.PropertyPlaceholderHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   text    =     \" foo =  $  { foo }  \"  ;", "assertEquals (  \" foo = bar \"  ,    this . helper . replacePlaceholders ( text ,    new    . PlaceholderResolver (  )     {", "@ Override", "public   String   resolvePlaceholder ( String   placeholderName )     {", "if    (  \" foo \"  . equals ( placeholderName )  )     {", "return    \" bar \"  ;", "} else    {", "return   null ;", "}", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithResolver"], "fileName": "org.springframework.util.PropertyPlaceholderHelperTests"}, {"methodBody": ["METHOD_START", "{", "Constructor < T >    ctor    =    clazz . getDeclaredConstructor ( parameterTypes )  ;", ". makeAccessible ( ctor )  ;", "return   ctor ;", "}", "METHOD_END"], "methodName": ["accessibleConstructor"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtils . declaredMethodsCache . clear (  )  ;", "ReflectionUtils . declaredFieldsCache . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "Class <  ?  >  [  ]    declaredExceps    =    method . getExcepTypes (  )  ;", "for    ( Class <  ?  >    declaredExcep    :    declaredExceps )     {", "if    ( declaredExcep . isAssignableFrom ( excepType )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["declaresException"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtils . doWithFields ( clazz ,    fc ,    null )  ;", "}", "METHOD_END"], "methodName": ["doWithFields"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetClass    =    clazz ;", "do    {", "Field [  ]    fields    =     . getDeclaredFields ( targetClass )  ;", "for    ( Field   field    :    fields )     {", "if    (  ( ff    !  =    null )     &  &     (  !  ( ff . matches ( field )  )  )  )     {", "continue ;", "}", "try    {", "fc . doWith ( field )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   IllegalStateException (  (  (  (  \" Not   allowed   to   access   field    '  \"     +     ( field . getName (  )  )  )     +     \"  '  :     \"  )     +    ex )  )  ;", "}", "}", "targetClass    =    targetClass . getSuperclass (  )  ;", "}    while    (  ( targetClass    !  =    null )     &  &     ( targetClass    !  =     ( Object . class )  )     )  ;", "}", "METHOD_END"], "methodName": ["doWithFields"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Field   field    :    ReflectionUtils . getDeclaredFields ( clazz )  )     {", "try    {", "fc . doWith ( field )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   IllegalStateException (  (  (  (  \" Not   allowed   to   access   field    '  \"     +     ( field . getName (  )  )  )     +     \"  '  :     \"  )     +    ex )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doWithLocalFields"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    ReflectionUtils . getDeclaredMethods ( clazz )  ;", "for    ( Method   method    :    methods )     {", "try    {", "mc . doWith ( method )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   IllegalStateException (  (  (  (  \" Not   allowed   to   access   method    '  \"     +     ( method . getName (  )  )  )     +     \"  '  :     \"  )     +    ex )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doWithLocalMethods"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtils . doWithMethods ( clazz ,    mc ,    null )  ;", "}", "METHOD_END"], "methodName": ["doWithMethods"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    ReflectionUtils . getDeclaredMethods ( clazz )  ;", "for    ( Method   method    :    methods )     {", "if    (  ( mf    !  =    null )     &  &     (  !  ( mf . matches ( method )  )  )  )     {", "continue ;", "}", "try    {", "mc . doWith ( method )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   IllegalStateException (  (  (  (  \" Not   allowed   to   access   method    '  \"     +     ( method . getName (  )  )  )     +     \"  '  :     \"  )     +    ex )  )  ;", "}", "}", "if    (  ( clazz . getSuperclass (  )  )     !  =    null )     {", "ReflectionUtils . doWithMethods ( clazz . getSuperclass (  )  ,    mc ,    mf )  ;", "} else", "if    ( clazz . isInterface (  )  )     {", "for    ( Class <  ?  >    superIfc    :    clazz . getInterfaces (  )  )     {", "ReflectionUtils . doWithMethods ( superIfc ,    mc ,    mf )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doWithMethods"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "List < Method >    result    =    null ;", "f    ( Class <  ?  >    ifc    :    clazz . getInterfaces (  )  )     {", "f    ( Method   ifcMethod    :    ifc . getMethods (  )  )     {", "if    (  !  ( Modifier . isAbstract ( ifcMethod . getModifiers (  )  )  )  )     {", "if    ( result    =  =    null )     {", "result    =    new   LinkedList <  >  (  )  ;", "}", "result . add ( ifcMethod )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findConcreteMethodsOnInterfaces"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtils . findField ( clazz ,    name ,    null )  ;", "}", "METHOD_END"], "methodName": ["findField"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . isTrue (  (  ( name    !  =    null )     |  |     ( type    !  =    null )  )  ,     \" Either   name   or   type   of   the   field   must   be   specified \"  )  ;", "Class <  ?  >    searchType    =    clazz ;", "while    (  (  ( Object . class )     !  =    searchType )     &  &     ( searchType    !  =    null )  )     {", "Field [  ]    fields    =     . getDeclaredFields ( searchType )  ;", "for    ( Field   field    :    fields )     {", "if    (  (  ( name    =  =    null )     |  |     ( name . equals ( field . getName (  )  )  )  )     &  &     (  ( type    =  =    null )     |  |     ( type . equals ( field . getType (  )  )  )  )  )     {", "return   field ;", "}", "}", "searchType    =    searchType . getSuperclass (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findField"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtils . findMethod ( clazz ,    name ,    new   Class <  ?  >  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Assert . notNull ( name ,     \" Method   name   must   not   be   null \"  )  ;", "Class <  ?  >    searchType    =    clazz ;", "while    ( searchType    !  =    null )     {", "Method [  ]    methods    =     ( searchType . isInterface (  )  )     ?    searchType . getMethods (  )     :     . getDeclaredMethods ( searchType )  ;", "for    ( Method   method    :    methods )     {", "if    (  ( name . equals ( method . getName (  )  )  )     &  &     (  ( paramTypes    =  =    null )     |  |     ( Arrays . equals ( paramTypes ,    method . getParameterTypes (  )  )  )  )  )     {", "return   method ;", "}", "}", "searchType    =    searchType . getSuperclass (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "final   List < Method >    methods    =    new   ArrayList <  >  (  3  2  )  ;", ". doWithMethods ( leafClass ,    methods :  : add )  ;", "return   methods . toArray ( new   Method [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getAllDeclaredMethods"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Field [  ]    result    =     . declaredFieldsCache . get ( clazz )  ;", "if    ( result    =  =    null )     {", "try    {", "result    =    clazz . getDeclaredFields (  )  ;", ". declaredFieldsCache . put ( clazz ,     (  ( result . length )     =  =     0     ?     . NO _ FIELDS    :    result )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  (  (  (  \" Failed   to   introspect   Class    [  \"     +     ( clazz . getName (  )  )  )     +     \"  ]    from   ClassLoader    [  \"  )     +     ( clazz . getClassLoader (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredFields"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "Method [  ]    result    =     . declaredMethodsCache . get ( clazz )  ;", "if    ( result    =  =    null )     {", "try    {", "Method [  ]    declaredMethods    =    clazz . getDeclaredMethods (  )  ;", "List < Method >    defaultMethods    =     . findConcreteMethodsOnInterfaces ( clazz )  ;", "if    ( defaultMethods    !  =    null )     {", "result    =    new   Method [  ( declaredMethods . length )     +     ( defaultMethods . size (  )  )  ]  ;", "System . arraycopy ( declaredMethods ,     0  ,    result ,     0  ,    declaredMethods . length )  ;", "int   index    =    declaredMethods . length ;", "for    ( Method   defaultMethod    :    defaultMethods )     {", "result [ index ]     =    defaultMethod ;", "index +  +  ;", "}", "} else    {", "result    =    declaredMethods ;", "}", ". declaredMethodsCache . put ( clazz ,     (  ( result . length )     =  =     0     ?     . NO _ METHODS    :    result )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  (  (  (  (  \" Failed   to   introspect   Class    [  \"     +     ( clazz . getName (  )  )  )     +     \"  ]    from   ClassLoader    [  \"  )     +     ( clazz . getClassLoader (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDeclaredMethods"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   field . get ( target )  ;", "}    catch    ( IllegalAccessException   ex )     {", ". handleReflectionException ( ex )  ;", "throw   new   IllegalStateException (  (  (  (  \" Unexpected   reflection   exception    -     \"     +     ( ex . getClass (  )  . getName (  )  )  )     +     \"  :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "final   List < Method >    methods    =    new   ArrayList <  >  (  3  2  )  ;", ". doWithMethods ( leafClass ,     (    method )     -  >     {", "boolean   knownSignature    =    false ;", "Method   methodBeingOverriddenWithCovariantReturnType    =    null ;", "for    ( Method   existingMethod    :    methods )     {", "if    (  ( method . getName (  )  . equals ( existingMethod . getName (  )  )  )     &  &     ( Arrays . equals ( method . getParameterTypes (  )  ,    existingMethod . getParameterTypes (  )  )  )  )     {", "if    (  (  ( existingMethod . getReturnType (  )  )     !  =     ( method . getReturnType (  )  )  )     &  &     ( existingMethod . getReturnType (  )  . isAssignableFrom ( method . getReturnType (  )  )  )  )     {", "methodBeingOverriddenWithCovariantReturnType    =    existingMethod ;", "} else    {", "knownSignature    =    true ;", "}", "break ;", "}", "}", "if    ( methodBeingOverriddenWithCovariantReturnType    !  =    null )     {", "methods . remove ( methodBeingOverriddenWithCovariantReturnType )  ;", "}", "if    (  (  ! knownSignature )     &  &     (  !  (  . isCglibRenamedMethod ( method )  )  )  )     {", "methods . add ( method )  ;", "}", "}  )  ;", "return   methods . toArray ( new   Method [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getUniqueDeclaredMethods"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtils . rethrowRuntimeException ( ex . getTargetException (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleInvocationTargetException"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   NoSuchMethodException )     {", "throw   new   IllegalStateException (  (  \" Method   not   found :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "if    ( ex   instanceof   IllegalAccessException )     {", "throw   new   IllegalStateException (  (  \" Could   not   access   method :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "if    ( ex   instanceof   InvocationTargetException )     {", ". handleInvocationTargetException (  (  ( InvocationTargetException )     ( ex )  )  )  ;", "}", "if    ( ex   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( ex )  )  ;", "}", "throw   new   UndeclaredThrowableException ( ex )  ;", "}", "METHOD_END"], "methodName": ["handleReflectionException"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtils . invokeJdbcMethod ( method ,    target ,    new   Object [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["invokeJdbcMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   method . invoke ( target ,    args )  ;", "}    catch    ( IllegalAccessException   ex )     {", ". handleReflectionException ( ex )  ;", "}    catch    ( InvocationTargetException   ex )     {", "if    (  ( ex . getTargetException (  )  )    instanceof   SQLException )     {", "throw    (  ( SQLException )     ( ex . getTargetException (  )  )  )  ;", "}", ". handleInvocationTargetException ( ex )  ;", "}", "throw   new   IllegalStateException (  \" Should   never   get   here \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeJdbcMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ReflectionUtils . invokeMethod ( method ,    target ,    new   Object [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   method . invoke ( target ,    args )  ;", "}    catch    ( Exception   ex )     {", ". handleReflectionException ( ex )  ;", "}", "throw   new   IllegalStateException (  \" Should   never   get   here \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "String   name    =    renamedMethod . getName (  )  ;", "if    ( name . startsWith (  . CGLIB _ RENAMED _ METHOD _ PREFIX )  )     {", "int   i    =     ( name . length (  )  )     -     1  ;", "while    (  ( i    >  =     0  )     &  &     ( Character . isDigit ( name . charAt ( i )  )  )  )     {", "i -  -  ;", "}", "return    (  ( i    >     (  . CGLIB _ RENAMED _ METHOD _ PREFIX . length (  )  )  )     &  &     ( i    <     (  ( name . length (  )  )     -     1  )  )  )     &  &     (  ( name . charAt ( i )  )     =  =     '  $  '  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isCglibRenamedMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( method    =  =    null )     |  |     (  !  ( method . getName (  )  . equals (  \" equals \"  )  )  )  )     {", "return   false ;", "}", "Class <  ?  >  [  ]    paramTypes    =    method . getPaterTypes (  )  ;", "return    (  ( paramTypes . length )     =  =     1  )     &  &     (  ( paramTypes [  0  ]  )     =  =     ( Object . class )  )  ;", "}", "METHOD_END"], "methodName": ["isEqualsMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( method    !  =    null )     &  &     ( method . getName (  )  . equals (  \" hashCode \"  )  )  )     &  &     (  ( method . getParameterCount (  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isHashCodeMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( method    =  =    null )     {", "return   false ;", "}", "try    {", "Object . class . getDeclaredMethod ( method . getName (  )  ,    method . getPaterTypes (  )  )  ;", "return   true ;", "}    catch    ( Exception   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isObjectMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "int   modifiers    =    field . getModifiers (  )  ;", "return    (  ( Modifier . isPublic ( modifiers )  )     &  &     ( Modifier . isStatic ( modifiers )  )  )     &  &     ( Modifier . isFinal ( modifiers )  )  ;", "}", "METHOD_END"], "methodName": ["isPublicStaticFinal"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( method    !  =    null )     &  &     ( method . getName (  )  . equals (  \" toString \"  )  )  )     &  &     (  ( method . getParameterCount (  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isToStringMethod"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( Modifier . isPublic ( ctor . getModifiers (  )  )  )  )     |  |     (  !  ( Modifier . isPublic ( ctor . getDeclaringClass (  )  . getModifiers (  )  )  )  )  )     &  &     (  !  ( ctor . isAccessible (  )  )  )  )     {", "ctor . setAccessible ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["makeAccessible"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  (  !  ( Modifier . isPublic ( field . getModifiers (  )  )  )  )     |  |     (  !  ( Modifier . isPublic ( field . getDeclaringClass (  )  . getModifiers (  )  )  )  )  )     |  |     ( Modifier . isFinal ( field . getModifiers (  )  )  )  )     &  &     (  !  ( field . isAccessible (  )  )  )  )     {", "field . setAccessible ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["makeAccessible"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( Modifier . isPublic ( method . getModifiers (  )  )  )  )     |  |     (  !  ( Modifier . isPublic ( method . getDeclaringClass (  )  . getModifiers (  )  )  )  )  )     &  &     (  !  ( method . isAccessible (  )  )  )  )     {", "method . setAccessible ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["makeAccessible"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   Exception )     {", "throw    (  ( Exception )     ( ex )  )  ;", "}", "if    ( ex   instanceof   Error )     {", "throw    (  ( Error )     ( ex )  )  ;", "}", "throw   new   UndeclaredThrowableException ( ex )  ;", "}", "METHOD_END"], "methodName": ["rethrowException"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( ex )  )  ;", "}", "if    ( ex   instanceof   Error )     {", "throw    (  ( Error )     ( ex )  )  ;", "}", "throw   new   UndeclaredThrowableException ( ex )  ;", "}", "METHOD_END"], "methodName": ["rethrowRuntimeException"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "field . set ( target ,    value )  ;", "}    catch    ( IllegalAccessException   ex )     {", ". handleReflectionException ( ex )  ;", "throw   new   IllegalStateException (  (  (  (  \" Unexpected   reflection   exception    -     \"     +     ( ex . getClass (  )  . getName (  )  )  )     +     \"  :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setField"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( src ,     \" Source   for   field   copy   cannot   be   null \"  )  ;", "Assert . notNull ( dest ,     \" Destination   for   field   copy   cannot   be   null \"  )  ;", "if    (  !  ( src . getClass (  )  . isAssignableFrom ( dest . getClass (  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Destination   class    [  \"     +     ( dest . getClass (  )  . getName (  )  )  )     +     \"  ]    must   be   same   or   subclass   as   source   class    [  \"  )     +     ( src . getClass (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", ". doWithFields ( src . getClass (  )  ,     (    field )     -  >     {", ". makeAccessible ( field )  ;", "Object   srcValue    =    field . get ( src )  ;", "field . set ( dest ,    srcValue )  ;", "}  ,     . COPYABLE _ FIELDS )  ;", "}", "METHOD_END"], "methodName": ["shallowCopyFieldState"], "fileName": "org.springframework.util.ReflectionUtils"}, {"methodBody": ["METHOD_START", "{", "TestObject   src    =    new   TestObject (  )  ;", "String   dest    =    new   String (  )  ;", ". shallowCopyFieldState ( src ,    dest )  ;", "}", "METHOD_END"], "methodName": ["copySrcToDestinationOfIncorrectClass"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   remoteExMethod    =    ReflectionUtilsTests . A . class . getDeclaredMethod (  \" foo \"  ,    Integer . class )  ;", "assertTrue ( ReflectionUtils . declaresException ( remoteExMethod ,    RemoteException . class )  )  ;", "assertTrue ( ReflectionUtils . declaresException ( remoteExMethod ,    ConnectException . class )  )  ;", "assertFalse ( ReflectionUtils . declaresException ( remoteExMethod ,    NoSuchMethodException . class )  )  ;", "assertFalse ( ReflectionUtils . declaresException ( remoteExMethod ,    Exception . class )  )  ;", "Method   illegalExMethod    =    ReflectionUtilsTests . B . class . getDeclaredMethod (  \" bar \"  ,    String . class )  ;", "assertTrue ( ReflectionUtils . declaresException ( illegalExMethod ,    IllegalArgumentException . class )  )  ;", "assertTrue ( ReflectionUtils . declaresException ( illegalExMethod ,    NumberFormatException . class )  )  ;", "assertFalse ( ReflectionUtils . declaresException ( illegalExMethod ,    IllegalStateException . class )  )  ;", "assertFalse ( ReflectionUtils . declaresException ( illegalExMethod ,    Exception . class )  )  ;", "}", "METHOD_END"], "methodName": ["declaresException"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtilsTests . ListSavingMethodCallback   mc    =    new   ReflectionUtilsTests . ListSavingMethodCallback (  )  ;", "ReflectionUtils . doWithMethods ( TestObject . class ,    mc ,    new   ReflectionUtils . MethodFilter (  )     {", "@ Override", "public   boolean   matches ( Method   m )     {", "return   Modifier . isProtected ( m . getModifiers (  )  )  ;", "}", "}  )  ;", "assertFalse ( mc . getMethodNames (  )  . isEmpty (  )  )  ;", "assertTrue (  \" Must   find   protected   method   on   Object \"  ,    mc . getMethodNames (  )  . contains (  \" clone \"  )  )  ;", "assertTrue (  \" Must   find   protected   method   on   Object \"  ,    mc . getMethodNames (  )  . contains (  \" finalize \"  )  )  ;", "assertFalse (  \" Public ,    not   protected \"  ,    mc . getMethodNames (  )  . contains (  \" hashCode \"  )  )  ;", "assertFalse (  \" Public ,    not   protected \"  ,    mc . getMethodNames (  )  . contains (  \" absquatulate \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doWithProtectedMethods"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtilsTests . ListSavingMethodCallback   mc    =    new   ReflectionUtilsTests . ListSavingMethodCallback (  )  ;", "ReflectionUtils . doWithMethods ( ReflectionUtilsTests . TestObjectSubclass . class ,    mc )  ;", "int   absquatulateCount    =     0  ;", "for    ( String   name    :    mc . getMethodNames (  )  )     {", "if    ( name . equals (  \" absquatulate \"  )  )     {", "+  + absquatulateCount ;", "}", "}", "assertEquals (  \" Found    2    absquatulates \"  ,     2  ,    absquatulateCount )  ;", "}", "METHOD_END"], "methodName": ["duplicatesFound"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    ReflectionUtils . findField ( ReflectionUtilsTests . TestObjectSubclassWithPublicField . class ,     \" publicField \"  ,    String . class )  ;", "assertNotNull ( field )  ;", "assertEquals (  \" publicField \"  ,    field . getName (  )  )  ;", "assertEquals ( String . class ,    field . getType (  )  )  ;", "assertTrue (  \" Field   should   be   public .  \"  ,    Modifier . isPublic ( field . getModifiers (  )  )  )  ;", "field    =    ReflectionUtils . findField ( ReflectionUtilsTests . TestObjectSubclassWithNewField . class ,     \" prot \"  ,    String . class )  ;", "assertNotNull ( field )  ;", "assertEquals (  \" prot \"  ,    field . getName (  )  )  ;", "assertEquals ( String . class ,    field . getType (  )  )  ;", "assertTrue (  \" Field   should   be   protected .  \"  ,    Modifier . isProtected ( field . getModifiers (  )  )  )  ;", "field    =    ReflectionUtils . findField ( ReflectionUtilsTests . TestObjectSubclassWithNewField . class ,     \" name \"  ,    String . class )  ;", "assertNotNull ( field )  ;", "assertEquals (  \" name \"  ,    field . getName (  )  )  ;", "assertEquals ( String . class ,    field . getType (  )  )  ;", "assertTrue (  \" Field   should   be   private .  \"  ,    Modifier . isPrivate ( field . getModifiers (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["findField"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( ReflectionUtils . findMethod ( ReflectionUtilsTests . B . class ,     \" bar \"  ,    String . class )  )  ;", "assertNotNull ( ReflectionUtils . findMethod ( ReflectionUtilsTests . B . class ,     \" foo \"  ,    Integer . class )  )  ;", "assertNotNull ( ReflectionUtils . findMethod ( ReflectionUtilsTests . B . class ,     \" getClass \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( ReflectionUtils . findMethod ( ReflectionUtilsTests . B . class ,     \" add \"  ,    int . class ,    int . class ,    int . class )  )  ;", "}", "METHOD_END"], "methodName": ["findMethodWithVarArgs"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "class   Foo    {", "@ Override", "public   String   toString (  )     {", "return   super . toString (  )  ;", "}", "}", "int   toStringMethodCount    =     0  ;", "for    ( Method   method    :     . getAllDeclaredMethods ( Foo . class )  )     {", "if    ( method . getName (  )  . equals (  \" toString \"  )  )     {", "toStringMethodCount +  +  ;", "}", "}", "assertThat ( toStringMethodCount ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllDeclaredMethods"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "class   Foo    {", "@ Override", "public   String   toString (  )     {", "return   super . toString (  )  ;", "}", "}", "int   toStringMethodCount    =     0  ;", "for    ( Method   method    :     . getUniqueDeclaredMethods ( Foo . class )  )     {", "if    ( method . getName (  )  . equals (  \" toString \"  )  )     {", "toStringMethodCount +  +  ;", "}", "}", "assertThat ( toStringMethodCount ,    is (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["getUniqueDeclaredMethods"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( TestGroup . PERFORMANCE )  ;", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "void   m 0  0  (  )     {", "}", "void   m 0  1  (  )     {", "}", "void   m 0  2  (  )     {", "}", "void   m 0  3  (  )     {", "}", "void   m 0  4  (  )     {", "}", "void   m 0  5  (  )     {", "}", "void   m 0  6  (  )     {", "}", "void   m 0  7  (  )     {", "}", "void   m 0  8  (  )     {", "}", "void   m 0  9  (  )     {", "}", "void   m 1  0  (  )     {", "}", "void   m 1  1  (  )     {", "}", "void   m 1  2  (  )     {", "}", "void   m 1  3  (  )     {", "}", "void   m 1  4  (  )     {", "}", "void   m 1  5  (  )     {", "}", "void   m 1  6  (  )     {", "}", "void   m 1  7  (  )     {", "}", "void   m 1  8  (  )     {", "}", "void   m 1  9  (  )     {", "}", "void   m 2  0  (  )     {", "}", "void   m 2  1  (  )     {", "}", "void   m 2  2  (  )     {", "}", "void   m 2  3  (  )     {", "}", "void   m 2  4  (  )     {", "}", "void   m 2  5  (  )     {", "}", "void   m 2  6  (  )     {", "}", "void   m 2  7  (  )     {", "}", "void   m 2  8  (  )     {", "}", "void   m 2  9  (  )     {", "}", "void   m 3  0  (  )     {", "}", "void   m 3  1  (  )     {", "}", "void   m 3  2  (  )     {", "}", "void   m 3  3  (  )     {", "}", "void   m 3  4  (  )     {", "}", "void   m 3  5  (  )     {", "}", "void   m 3  6  (  )     {", "}", "void   m 3  7  (  )     {", "}", "void   m 3  8  (  )     {", "}", "void   m 3  9  (  )     {", "}", "void   m 4  0  (  )     {", "}", "void   m 4  1  (  )     {", "}", "void   m 4  2  (  )     {", "}", "void   m 4  3  (  )     {", "}", "void   m 4  4  (  )     {", "}", "void   m 4  5  (  )     {", "}", "void   m 4  6  (  )     {", "}", "void   m 4  7  (  )     {", "}", "void   m 4  8  (  )     {", "}", "void   m 4  9  (  )     {", "}", "void   m 5  0  (  )     {", "}", "void   m 5  1  (  )     {", "}", "void   m 5  2  (  )     {", "}", "void   m 5  3  (  )     {", "}", "void   m 5  4  (  )     {", "}", "void   m 5  5  (  )     {", "}", "void   m 5  6  (  )     {", "}", "void   m 5  7  (  )     {", "}", "void   m 5  8  (  )     {", "}", "void   m 5  9  (  )     {", "}", "void   m 6  0  (  )     {", "}", "void   m 6  1  (  )     {", "}", "void   m 6  2  (  )     {", "}", "void   m 6  3  (  )     {", "}", "void   m 6  4  (  )     {", "}", "void   m 6  5  (  )     {", "}", "void   m 6  6  (  )     {", "}", "void   m 6  7  (  )     {", "}", "void   m 6  8  (  )     {", "}", "void   m 6  9  (  )     {", "}", "void   m 7  0  (  )     {", "}", "void   m 7  1  (  )     {", "}", "void   m 7  2  (  )     {", "}", "void   m 7  3  (  )     {", "}", "void   m 7  4  (  )     {", "}", "void   m 7  5  (  )     {", "}", "void   m 7  6  (  )     {", "}", "void   m 7  7  (  )     {", "}", "void   m 7  8  (  )     {", "}", "void   m 7  9  (  )     {", "}", "void   m 8  0  (  )     {", "}", "void   m 8  1  (  )     {", "}", "void   m 8  2  (  )     {", "}", "void   m 8  3  (  )     {", "}", "void   m 8  4  (  )     {", "}", "void   m 8  5  (  )     {", "}", "void   m 8  6  (  )     {", "}", "void   m 8  7  (  )     {", "}", "void   m 8  8  (  )     {", "}", "void   m 8  9  (  )     {", "}", "void   m 9  0  (  )     {", "}", "void   m 9  1  (  )     {", "}", "void   m 9  2  (  )     {", "}", "void   m 9  3  (  )     {", "}", "void   m 9  4  (  )     {", "}", "void   m 9  5  (  )     {", "}", "void   m 9  6  (  )     {", "}", "void   m 9  7  (  )     {", "}", "void   m 9  8  (  )     {", "}", "void   m 9  9  (  )     {", "}", "}", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  )  ;", "Method [  ]    methods    =     . getUniqueDeclaredMethods ( C . class )  ;", "sw . stop (  )  ;", "long   totalMs    =    sw . getTotalTimeMillis (  )  ;", "assertThat ( methods . length ,    Matchers . greaterThan (  1  0  0  )  )  ;", "assertThat ( totalMs ,    Matchers . lessThan (  1  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["getUniqueDeclaredMethods_isFastEnough"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "class   Parent    {", "@ SuppressWarnings (  \" unused \"  )", "public   Number   m 1  (  )     {", "return   Integer . valueOf (  4  2  )  ;", "}", "}", "class   Leaf   extends   Parent    {", "@ Override", "public   Integer   m 1  (  )     {", "return   Integer . valueOf (  4  2  )  ;", "}", "}", "int   m 1 MethodCount    =     0  ;", "Method [  ]    methods    =     . getUniqueDeclaredMethods ( Leaf . class )  ;", "for    ( Method   method    :    methods )     {", "if    ( method . getName (  )  . equals (  \" m 1  \"  )  )     {", "m 1 MethodCount +  +  ;", "}", "}", "assertThat ( m 1 MethodCount ,    is (  1  )  )  ;", "assertTrue ( ObjectUtils . containsElement ( methods ,    Leaf . class . getMethod (  \" m 1  \"  )  )  )  ;", "assertFalse ( ObjectUtils . containsElement ( methods ,    Parent . class . getMethod (  \" m 1  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getUniqueDeclaredMethods_withCovariantReturnType"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   rob    =     \" Rob   Harrop \"  ;", "TestObject   bean    =    new   TestObject (  )  ;", "bean . setName ( rob )  ;", "Method   getName    =    TestObject . class . getMethod (  \" getName \"  )  ;", "Method   setName    =    TestObject . class . getMethod (  \" setName \"  ,    String . class )  ;", "Object   name    =     . invokeMethod ( getName ,    bean )  ;", "assertEquals (  \" Incorrect   name   returned \"  ,    rob ,    name )  ;", "String   juergen    =     \" Juergen   Hoeller \"  ;", ". invokeMethod ( setName ,    bean ,    juergen )  ;", "assertEquals (  \" Incorrect   name   set \"  ,    juergen ,    bean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   void   CGLIB $ m 1  $  1  2  3  (  )     {", "}", "public   void   CGLIB $ m 1  $  0  (  )     {", "}", "public   void   CGLIB $  $  0  (  )     {", "}", "public   void   CGLIB $ m 1  $  (  )     {", "}", "public   void   CGLIB $ m 1  (  )     {", "}", "public   void   m 1  (  )     {", "}", "public   void   m 1  $  (  )     {", "}", "public   void   m 1  $  1  (  )     {", "}", "}", "assertTrue (  . isCglibRenamedMethod ( C . class . getMethod (  \" CGLIB $ m 1  $  1  2  3  \"  )  )  )  ;", "assertTrue (  . isCglibRenamedMethod ( C . class . getMethod (  \" CGLIB $ m 1  $  0  \"  )  )  )  ;", "assertFalse (  . isCglibRenamedMethod ( C . class . getMethod (  \" CGLIB $  $  0  \"  )  )  )  ;", "assertFalse (  . isCglibRenamedMethod ( C . class . getMethod (  \" CGLIB $ m 1  $  \"  )  )  )  ;", "assertFalse (  . isCglibRenamedMethod ( C . class . getMethod (  \" CGLIB $ m 1  \"  )  )  )  ;", "assertFalse (  . isCglibRenamedMethod ( C . class . getMethod (  \" m 1  \"  )  )  )  ;", "assertFalse (  . isCglibRenamedMethod ( C . class . getMethod (  \" m 1  $  \"  )  )  )  ;", "assertFalse (  . isCglibRenamedMethod ( C . class . getMethod (  \" m 1  $  1  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isCglibRenamedMethod"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestObject   src    =    new   TestObject (  )  ;", "String   dest    =    null ;", ". shallowCopyFieldState ( src ,    dest )  ;", "}", "METHOD_END"], "methodName": ["rejectsNullDest"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestObject   src    =    null ;", "String   dest    =    new   String (  )  ;", ". shallowCopyFieldState ( src ,    dest )  ;", "}", "METHOD_END"], "methodName": ["rejectsNullSrc"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtilsTests . TestObjectSubclassWithNewField   testBean    =    new   ReflectionUtilsTests . TestObjectSubclassWithNewField (  )  ;", "Field   field    =    ReflectionUtils . findField ( ReflectionUtilsTests . TestObjectSubclassWithNewField . class ,     \" name \"  ,    String . class )  ;", "ReflectionUtils . makeAccessible ( field )  ;", "ReflectionUtils . setField ( field ,    testBean ,     \" FooBar \"  )  ;", "assertNotNull ( testBean . getName (  )  )  ;", "assertEquals (  \" FooBar \"  ,    testBean . getName (  )  )  ;", "ReflectionUtils . setField ( field ,    testBean ,    null )  ;", "assertNull ( testBean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["setField"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "src . setName (  \" freddie \"  )  ;", "src . setAge (  1  5  )  ;", "src . setSpouse ( new   TestObject (  )  )  ;", "assertFalse (  (  ( src . getAge (  )  )     =  =     ( dest . getAge (  )  )  )  )  ;", ". shallowCopyFieldState ( src ,    dest )  ;", "assertEquals ( src . getAge (  )  ,    dest . getAge (  )  )  ;", "assertEquals ( src . getSpouse (  )  ,    dest . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidCopy"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestObject   src    =    new   TestObject (  )  ;", "TestObject   dest    =    new   TestObject (  )  ;", "testValidCopy ( src ,    dest )  ;", "}", "METHOD_END"], "methodName": ["validCopy"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtilsTests . TestObjectSubclassWithNewField   src    =    new   ReflectionUtilsTests . TestObjectSubclassWithNewField (  )  ;", "ReflectionUtilsTests . TestObjectSubclassWithNewField   dest    =    new   ReflectionUtilsTests . TestObjectSubclassWithNewField (  )  ;", "src . magic    =     1  1  ;", "testValidCopy ( src ,    dest )  ;", "assertEquals ( src . magic ,    dest . magic )  ;", "assertEquals ( src . prot ,    dest . prot )  ;", "}", "METHOD_END"], "methodName": ["validCopyOnSubTypeWithNewField"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestObject   src    =    new   TestObject (  )  ;", ". TestObjectSubclassWithNewField   dest    =    new    . TestObjectSubclassWithNewField (  )  ;", "dest . magic    =     1  1  ;", "testValidCopy ( src ,    dest )  ;", "assertEquals (  1  1  ,    dest . magic )  ;", "}", "METHOD_END"], "methodName": ["validCopyToSubType"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtilsTests . TestObjectSubclassWithFinalField   src    =    new   ReflectionUtilsTests . TestObjectSubclassWithFinalField (  )  ;", "ReflectionUtilsTests . TestObjectSubclassWithFinalField   dest    =    new   ReflectionUtilsTests . TestObjectSubclassWithFinalField (  )  ;", "testValidCopy ( src ,    dest )  ;", "}", "METHOD_END"], "methodName": ["validCopyToSubTypeWithFinalField"], "fileName": "org.springframework.util.ReflectionUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . buf . length ;", "}", "METHOD_END"], "methodName": ["capacity"], "fileName": "org.springframework.util.ResizableByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( additionalCapacity    >  =     0  )  ,     \" Additional   capacity   must   be    0    or   higher \"  )  ;", "if    (  (  ( this . count )     +    additionalCapacity )     >     ( this . buf . length )  )     {", "int   newCapacity    =    Math . max (  (  ( this . buf . length )     *     2  )  ,     (  ( this . count )     +    additionalCapacity )  )  ;", "re ( newCapacity )  ;", "}", "}", "METHOD_END"], "methodName": ["grow"], "fileName": "org.springframework.util.ResizableByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( targetCapacity    >  =     ( this . count )  )  ,     \" New   capacity   must   not   be   smaller   than   current   size \"  )  ;", "byte [  ]    redBuffer    =    new   byte [ targetCapacity ]  ;", "System . arraycopy ( this . buf ,     0  ,    redBuffer ,     0  ,    this . count )  ;", "this . buf    =    redBuffer ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "org.springframework.util.ResizableByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "assertArrayEquals ( helloBytes ,    actual . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertByteArrayEqualsString"], "fileName": "org.springframework.util.ResizableByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( ResizableByteArrayOutputStreamTests . INITIAL _ CAPACITY ,    this . baos . capacity (  )  )  ;", "for    ( int   i    =     0  ;    i    <     1  2  9  ;    i +  +  )     {", "this . baos . write (  0  )  ;", "}", "assertEquals (  2  5  6  ,    this . baos . capacity (  )  )  ;", "}", "METHOD_END"], "methodName": ["autoGrow"], "fileName": "org.springframework.util.ResizableByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . baos . write ( helloBytes )  ;", "this . baos . resize (  5  )  ;", "}", "METHOD_END"], "methodName": ["failResize"], "fileName": "org.springframework.util.ResizableByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( ResizableByteArrayOutputStreamTests . INITIAL _ CAPACITY ,    this . baos . capacity (  )  )  ;", "this . baos . write ( helloBytes )  ;", "this . baos . grow (  1  0  0  0  )  ;", "assertEquals (  (  ( this . helloBytes . length )     +     1  0  0  0  )  ,    this . baos . capacity (  )  )  ;", "assertByteArrayEqualsString ( this . baos )  ;", "}", "METHOD_END"], "methodName": ["grow"], "fileName": "org.springframework.util.ResizableByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( ResizableByteArrayOutputStreamTests . INITIAL _ CAPACITY ,    this . baos . capacity (  )  )  ;", "this . baos . write ( helloBytes )  ;", "int   size    =     6  4  ;", "this . baos . resize ( size )  ;", "assertEquals ( size ,    this . baos . capacity (  )  )  ;", "assertByteArrayEqualsString ( this . baos )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "org.springframework.util.ResizableByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . baos    =    new   ResizableByteArrayOutputStream ( ResizableByteArrayOutputStreamTests . INITIAL _ CAPACITY )  ;", "this . helloBytes    =     \" Hello   World \"  . getBytes (  \" UTF -  8  \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.util.ResizableByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "this . baos . write ( helloBytes )  ;", "assertEqualsString ( this . baos )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.util.ResizableByteArrayOutputStreamTests"}, {"methodBody": ["METHOD_START", "{", "String   urlFile    =    jarUrl . getFile (  )  ;", "int   endIndex    =    urlFile . indexOf (  . WAR _ URL _ SEPARATOR )  ;", "if    ( endIndex    !  =     (  -  1  )  )     {", "String   warFile    =    urlFile . substring (  0  ,    endIndex )  ;", "if    (  . URL _ PROTOCOL _ WAR . equals ( jarUrl . getProtocol (  )  )  )     {", "return   new   URL ( warFile )  ;", "}", "int   startIndex    =    warFile . indexOf (  . WAR _ URL _ PREFIX )  ;", "if    ( startIndex    !  =     (  -  1  )  )     {", "return   new   URL ( warFile . substring (  ( startIndex    +     (  . WAR _ URL _ PREFIX . length (  )  )  )  )  )  ;", "}", "}", "return    . extractJarFileURL ( jarUrl )  ;", "}", "METHOD_END"], "methodName": ["extractArchiveURL"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "String   urlFile    =    jarUrl . getFile (  )  ;", "int   separatorIndex    =    urlFile . indexOf (  . JAR _ URL _ SEPARATOR )  ;", "if    ( separatorIndex    !  =     (  -  1  )  )     {", "String   jarFile    =    urlFile . substring (  0  ,    separatorIndex )  ;", "try    {", "return   new   URL ( jarFile )  ;", "}    catch    ( MalformedURLException   ex )     {", "if    (  !  ( jarFile . startsWith (  \"  /  \"  )  )  )     {", "jarFile    =     \"  /  \"     +    jarFile ;", "}", "return   new   URL (  (  (  . FILE _ URL _ PREFIX )     +    jarFile )  )  ;", "}", "} else    {", "return   jarUrl ;", "}", "}", "METHOD_END"], "methodName": ["extractJarFileURL"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourceLocation ,     \" Resource   location   must   not   be   null \"  )  ;", "if    ( resourceLocation . startsWith (  . CLASSPATH _ URL _ PREFIX )  )     {", "String   path    =    resourceLocation . substring (  . CLASSPATH _ URL _ PREFIX . length (  )  )  ;", "String   description    =     (  \" class   path   resource    [  \"     +    path )     +     \"  ]  \"  ;", "ClassLoader   cl    =    ClassUtils . getDefaultClassLoader (  )  ;", "URL   url    =     ( cl    !  =    null )     ?    cl . getResource ( path )     :    ClassLoader . getSystemResource ( path )  ;", "if    ( url    =  =    null )     {", "throw   new   FileNotFoundException (  ( description    +     \"    cannot   be   resolved   to   absolute   file   path   because   it   does   not   exist \"  )  )  ;", "}", "return    . getFile ( url ,    description )  ;", "}", "try    {", "return    . getFile ( new   URL ( resourceLocation )  )  ;", "}    catch    ( MalformedURLException   ex )     {", "return   new   File ( resourceLocation )  ;", "}", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "return   ResourceUtils . getFile ( resourceUri ,     \" URI \"  )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourceUri ,     \" Resource   URI   must   not   be   null \"  )  ;", "if    (  !  (  . URL _ PROTOCOL _ FILE . equals ( resourceUri . getScheme (  )  )  )  )     {", "throw   new   FileNotFoundException (  (  (  ( description    +     \"    cannot   be   resolved   to   absolute   file   path    \"  )     +     \" because   it   does   not   reside   in   the   file   system :     \"  )     +    resourceUri )  )  ;", "}", "return   new   File ( resourceUri . getSchemeSpecificPart (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "return   ResourceUtils . getFile ( resourceUrl ,     \" URL \"  )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourceUrl ,     \" Resource   URL   must   not   be   null \"  )  ;", "if    (  !  (  . URL _ PROTOCOL _ FILE . equals ( resourceUrl . getProtocol (  )  )  )  )     {", "throw   new   FileNotFoundException (  (  (  ( description    +     \"    cannot   be   resolved   to   absolute   file   path    \"  )     +     \" because   it   does   not   reside   in   the   file   system :     \"  )     +    resourceUrl )  )  ;", "}", "try    {", "return   new   File (  . toURI ( resourceUrl )  . getSchemeSpecificPart (  )  )  ;", "}    catch    ( URISyntaxException   ex )     {", "return   new   File ( resourceUrl . getFile (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resourceLocation ,     \" Resource   location   must   not   be   null \"  )  ;", "if    ( resourceLocation . startsWith (  . CLASSPATH _ URL _ PREFIX )  )     {", "String   path    =    resourceLocation . substring (  . CLASSPATH _ URL _ PREFIX . length (  )  )  ;", "ClassLoader   cl    =    ClassUtils . getDefaultClassLoader (  )  ;", "URL   url    =     ( cl    !  =    null )     ?    cl . getResource ( path )     :    ClassLoader . getSystemResource ( path )  ;", "if    ( url    =  =    null )     {", "String   description    =     (  \" class   path   resource    [  \"     +    path )     +     \"  ]  \"  ;", "throw   new   FileNotFoundException (  ( description    +     \"    cannot   be   resolved   to   URL   because   it   does   not   exist \"  )  )  ;", "}", "return   url ;", "}", "try    {", "return   new   URL ( resourceLocation )  ;", "}    catch    ( MalformedURLException   ex )     {", "try    {", "return   new   File ( resourceLocation )  . toURI (  )  . toURL (  )  ;", "}    catch    ( MalformedURLException   ex 2  )     {", "throw   new   FileNotFoundException (  (  (  \" Resource   location    [  \"     +    resourceLocation )     +     \"  ]    is   neither   a   URL   not   a   well - formed   file   path \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getURL"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "String   protocol    =    url . getProtocol (  )  ;", "return    (  (  . URL _ PROTOCOL _ FILE . equals ( protocol )  )     |  |     (  . URL _ PROTOCOL _ VFSFILE . equals ( protocol )  )  )     |  |     (  . URL _ PROTOCOL _ VFS . equals ( protocol )  )  ;", "}", "METHOD_END"], "methodName": ["isFileURL"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( ResourceUtils . URL _ PROTOCOL _ FILE . equals ( url . getProtocol (  )  )  )     &  &     ( url . getPath (  )  . toLowerCase (  )  . endsWith ( ResourceUtils . JAR _ FILE _ EXTENSION )  )  ;", "}", "METHOD_END"], "methodName": ["isJarFileURL"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "String   protocol    =    url . getProtocol (  )  ;", "return    (  (  (  (  . URL _ PROTOCOL _ JAR . equals ( protocol )  )     |  |     (  . URL _ PROTOCOL _ WAR . equals ( protocol )  )  )     |  |     (  . URL _ PROTOCOL _ ZIP . equals ( protocol )  )  )     |  |     (  . URL _ PROTOCOL _ VFSZIP . equals ( protocol )  )  )     |  |     (  . URL _ PROTOCOL _ WSJAR . equals ( protocol )  )  ;", "}", "METHOD_END"], "methodName": ["isJarURL"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( resourceLocation    =  =    null )     {", "return   false ;", "}", "if    ( resourceLocation . startsWith (  . CLASSPATH _ URL _ PREFIX )  )     {", "return   true ;", "}", "try    {", "new   URL ( resourceLocation )  ;", "return   true ;", "}    catch    ( MalformedURLException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isUrl"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   URI ( StringUtils . replace ( location ,     \"     \"  ,     \"  %  2  0  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["toURI"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "return   ResourceUtils . toURI ( url . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["toURI"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "con . setUseCaches ( con . getClass (  )  . getSimpleName (  )  . startsWith (  \" JNLP \"  )  )  ;", "}", "METHOD_END"], "methodName": ["useCachesIfNecessary"], "fileName": "org.springframework.util.ResourceUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL (  \" jar : file : myjar . jar !  / mypath \"  )  )  )  ;", "assertEquals ( new   URL (  \" file :  / myjar . jar \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL ( null ,     \" jar : myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL ( null ,     \" zip : file : myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL ( null ,     \" wsjar : file : myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : mywar . war \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL ( null ,     \" jar : war : file : mywar . war *  / myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL (  \" file : myjar . jar \"  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL (  \" jar : file : myjar . jar !  /  \"  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL ( null ,     \" zip : file : myjar . jar !  /  \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL ( null ,     \" wsjar : file : myjar . jar !  /  \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : mywar . war \"  )  ,    ResourceUtils . extractArchiveURL ( new   URL ( null ,     \" jar : war : file : mywar . war *  / myjar . jar !  /  \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["extractArchiveURL"], "fileName": "org.springframework.util.ResourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractJarFileURL ( new   URL (  \" jar : file : myjar . jar !  / mypath \"  )  )  )  ;", "assertEquals ( new   URL (  \" file :  / myjar . jar \"  )  ,    ResourceUtils . extractJarFileURL ( new   URL ( null ,     \" jar : myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractJarFileURL ( new   URL ( null ,     \" zip : file : myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractJarFileURL ( new   URL ( null ,     \" wsjar : file : myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractJarFileURL ( new   URL (  \" file : myjar . jar \"  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractJarFileURL ( new   URL (  \" jar : file : myjar . jar !  /  \"  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractJarFileURL ( new   URL ( null ,     \" zip : file : myjar . jar !  /  \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertEquals ( new   URL (  \" file : myjar . jar \"  )  ,    ResourceUtils . extractJarFileURL ( new   URL ( null ,     \" wsjar : file : myjar . jar !  /  \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["extractJarFileURL"], "fileName": "org.springframework.util.ResourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ResourceUtils . isJarURL ( new   URL (  \" jar : file : myjar . jar !  / mypath \"  )  )  )  ;", "assertTrue ( ResourceUtils . isJarURL ( new   URL ( null ,     \" zip : file : myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertTrue ( ResourceUtils . isJarURL ( new   URL ( null ,     \" wsjar : file : myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertTrue ( ResourceUtils . isJarURL ( new   URL ( null ,     \" jar : war : file : mywar . war *  / myjar . jar !  / mypath \"  ,    new    . DummyURLStreamHandler (  )  )  )  )  ;", "assertFalse ( ResourceUtils . isJarURL ( new   URL (  \" file : myjar . jar \"  )  )  )  ;", "assertFalse ( ResourceUtils . isJarURL ( new   URL (  \" http : myserver / myjar . jar \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isJarURL"], "fileName": "org.springframework.util.ResourceUtilsTests"}, {"methodBody": ["METHOD_START", "{", "try    {", ". testSerialization ( o )  ;", "return   true ;", "}    catch    ( NotSerializableException   ex )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isSerializable"], "fileName": "org.springframework.util.SerializationTestUtils"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "ObjectOutputStream   oos    =    new   ObjectOutputStream ( baos )  ;", "oos . writeObject ( o )  ;", "oos . flush (  )  ;", "baos . flush (  )  ;", "byte [  ]    bytes    =    baos . toByteArray (  )  ;", "ByteArrayInputStream   is    =    new   ByteArrayInputStream ( bytes )  ;", "ObjectInputStream   ois    =    new   ObjectInputStream ( is )  ;", "Object   o 2     =    ois . readObject (  )  ;", "return   o 2  ;", "}", "METHOD_END"], "methodName": ["serializeAndDeserialize"], "fileName": "org.springframework.util.SerializationTestUtils"}, {"methodBody": ["METHOD_START", "{", "OutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "ObjectOutputStream   oos    =    new   ObjectOutputStream ( baos )  ;", "oos . writeObject ( o )  ;", "}", "METHOD_END"], "methodName": ["testSerialization"], "fileName": "org.springframework.util.SerializationTestUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( bytes    =  =    null )     {", "return   null ;", "}", "try    {", "ObjectInputStream   ois    =    new   ObjectInputStream ( new   ByteArrayInputStream ( bytes )  )  ;", "return   ois . readObject (  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalArgumentException (  \" Failed   to   dese   object \"  ,    ex )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   IllegalStateException (  \" Failed   to   dese   object   type \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["deserialize"], "fileName": "org.springframework.util.SerializationUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( object    =  =    null )     {", "return   null ;", "}", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  1  0  2  4  )  ;", "try    {", "ObjectOutputStream   oos    =    new   ObjectOutputStream ( baos )  ;", "oos . writeObject ( object )  ;", "oos . flush (  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalArgumentException (  (  \" Failed   to   se   object   of   type :     \"     +     ( object . getClass (  )  )  )  ,    ex )  ;", "}", "return   baos . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["serialize"], "fileName": "org.springframework.util.SerializationUtils"}, {"methodBody": ["METHOD_START", "{", "SerializationUtils . deserialize (  \" foo \"  . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["deserializeNonSerializable"], "fileName": "org.springframework.util.SerializationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( SerializationUtils . deserialize ( null )  )  ;", "}", "METHOD_END"], "methodName": ["deserializeNull"], "fileName": "org.springframework.util.SerializationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    SerializationUtilsTests . FOO . toByteArray (  )  ;", "Object   foo    =    SerializationUtils . deserialize ( bytes )  ;", "assertNotNull ( foo )  ;", "}", "METHOD_END"], "methodName": ["deserializeUndefined"], "fileName": "org.springframework.util.SerializationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    SerializationUtils . deserialize ( SerializationUtils . serialize (  \" foo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["serializeCycleSunnyDay"], "fileName": "org.springframework.util.SerializationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "SerializationUtils . serialize ( new   Object (  )  )  ;", "}", "METHOD_END"], "methodName": ["serializeNonSerializable"], "fileName": "org.springframework.util.SerializationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( SerializationUtils . serialize ( null )  )  ;", "}", "METHOD_END"], "methodName": ["serializeNull"], "fileName": "org.springframework.util.SerializationUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . findAvailableTcpPort ( SocketUtils . PORT _ RANGE _ MIN )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPort"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . findAvailableTcpPort ( minPort ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPort"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . SocketType . TCP . findAvailablePort ( minPort ,    maxPort )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPort"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . findAvailableTcpPorts ( numRequested ,    SocketUtils . PORT _ RANGE _ MIN ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPorts"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . SocketType . TCP . findAvailablePorts ( numRequested ,    minPort ,    maxPort )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPorts"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . findAvailableUdpPort ( SocketUtils . PORT _ RANGE _ MIN )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPort"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . findAvailableUdpPort ( minPort ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPort"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . SocketType . UDP . findAvailablePort ( minPort ,    maxPort )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPort"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . findAvailableUdpPorts ( numRequested ,    SocketUtils . PORT _ RANGE _ MIN ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPorts"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "return   SocketUtils . SocketType . UDP . findAvailablePorts ( numRequested ,    minPort ,    maxPort )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPorts"], "fileName": "org.springframework.util.SocketUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" number   of   ports   requested \"  ,    numRequested ,    ports . size (  )  )  ;", "for    ( int   port    :    ports )     {", "assertPortInRange ( port ,    minPort ,    maxPort )  ;", "}", "}", "METHOD_END"], "methodName": ["assertAvailablePorts"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  (  (  \" port    [  \"     +    port )     +     \"  ]     >  =     \"  )     +    minPort )  ,     ( port    >  =    minPort )  )  ;", "assertTrue (  (  (  (  \" port    [  \"     +    port )     +     \"  ]     <  =     \"  )     +    maxPort )  ,     ( port    <  =    maxPort )  )  ;", "}", "METHOD_END"], "methodName": ["assertPortInRange"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "findAvailableTcpPorts (  4  )  ;", "}", "METHOD_END"], "methodName": ["find4AvailableTcpPorts"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "findAvailableTcpPorts (  4  ,     3  0  0  0  0  ,     3  5  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["find4AvailableTcpPortsInRange"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "findAvailableUdpPorts (  4  )  ;", "}", "METHOD_END"], "methodName": ["find4AvailableUdpPorts"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "findAvailableUdpPorts (  4  ,     3  0  0  0  0  ,     3  5  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["find4AvailableUdpPortsInRange"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "findAvailableTcpPorts (  5  0  )  ;", "}", "METHOD_END"], "methodName": ["find50AvailableTcpPorts"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "findAvailableTcpPorts (  5  0  ,     4  0  0  0  0  ,     4  5  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["find50AvailableTcpPortsInRange"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "findAvailableUdpPorts (  5  0  )  ;", "}", "METHOD_END"], "methodName": ["find50AvailableUdpPorts"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "findAvailableUdpPorts (  5  0  ,     4  0  0  0  0  ,     4  5  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["find50AvailableUdpPortsInRange"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   port    =    SocketUtils . findAvailableTcpPort (  )  ;", "assertPortInRange ( port ,    SocketUtils . PORT _ RANGE _ MIN ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPort"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   minPort    =     2  0  0  0  0  ;", "int   maxPort    =    minPort    +     1  0  0  0  ;", "int   port    =     . findAvailableTcpPort ( minPort ,    maxPort )  ;", "assertPortInRange ( port ,    minPort ,    maxPort )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPortInRange"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   port    =    SocketUtils . findAvailableTcpPort (  )  ;", "ServerSocket   socket    =    ServerSocketFactory . getDefault (  )  . createServerSocket ( port ,     1  ,    InetAddress . getByName (  \" localhost \"  )  )  ;", "try    {", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage ( startsWith (  \" Could   not   find   an   available   TCP   port \"  )  )  ;", "exception . expectMessage ( endsWith (  \" after    1    attempts \"  )  )  ;", "SocketUtils . findAvailableTcpPort ( port ,    port )  ;", "}    finally    {", "socket . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["findAvailableTcpPortWhenPortOnLoopbackInterfaceIsNotAvailable"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   port    =    SocketUtils . findAvailableTcpPort (  5  0  0  0  0  )  ;", "assertPortInRange ( port ,     5  0  0  0  0  ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPortWithMin"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   minMaxPort    =    SocketUtils . findAvailableTcpPort (  )  ;", "int   port    =    SocketUtils . findAvailableTcpPort ( minMaxPort ,    minMaxPort )  ;", "assertEquals ( minMaxPort ,    port )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPortWithMinPortEqualToMaxPort"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", ". findAvailableTcpPort (  (  -  5  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPortWithNegativeMinPort"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", ". findAvailableTcpPort (  0  )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPortWithZeroMinPort"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "SortedSet < Integer >    ports    =    SocketUtils . findAvailableTcpPorts ( numRequested )  ;", "assertAvailablePorts ( ports ,    numRequested ,    SocketUtils . PORT _ RANGE _ MIN ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPorts"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "SortedSet < Integer >    ports    =    SocketUtils . findAvailableTcpPorts ( numRequested ,    minPort ,    maxPort )  ;", "assertAvailablePorts ( ports ,    numRequested ,    minPort ,    maxPort )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPorts"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "findAvailableTcpPorts (  5  0  ,     4  5  0  0  0  ,     4  5  0  1  0  )  ;", "}", "METHOD_END"], "methodName": ["findAvailableTcpPortsWithRequestedNumberGreaterThanSizeOfRange"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   port    =    SocketUtils . findAvailableUdpPort (  )  ;", "assertPortInRange ( port ,    SocketUtils . PORT _ RANGE _ MIN ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPort"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   minPort    =     2  0  0  0  0  ;", "int   maxPort    =    minPort    +     1  0  0  0  ;", "int   port    =     . findAvailableUdpPort ( minPort ,    maxPort )  ;", "assertPortInRange ( port ,    minPort ,    maxPort )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPortInRange"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   port    =    SocketUtils . findAvailableUdpPort (  )  ;", "DatagramSocket   socket    =    new   DatagramSocket ( port ,    InetAddress . getByName (  \" localhost \"  )  )  ;", "try    {", "exception . expect ( IllegalStateException . class )  ;", "exception . expectMessage ( startsWith (  \" Could   not   find   an   available   UDP   port \"  )  )  ;", "exception . expectMessage ( endsWith (  \" after    1    attempts \"  )  )  ;", "SocketUtils . findAvailableUdpPort ( port ,    port )  ;", "}    finally    {", "socket . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["findAvailableUdpPortWhenPortOnLoopbackInterfaceIsNotAvailable"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   port    =    SocketUtils . findAvailableUdpPort (  5  0  0  0  0  )  ;", "assertPortInRange ( port ,     5  0  0  0  0  ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPortWithMin"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", ". findAvailableUdpPort (  (  -  5  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPortWithNegativeMinPort"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", ". findAvailableUdpPort (  0  )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPortWithZeroMinPort"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "SortedSet < Integer >    ports    =    SocketUtils . findAvailableUdpPorts ( numRequested )  ;", "assertAvailablePorts ( ports ,    numRequested ,    SocketUtils . PORT _ RANGE _ MIN ,    SocketUtils . PORT _ RANGE _ MAX )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPorts"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "SortedSet < Integer >    ports    =    SocketUtils . findAvailableUdpPorts ( numRequested ,    minPort ,    maxPort )  ;", "assertAvailablePorts ( ports ,    numRequested ,    minPort ,    maxPort )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPorts"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalArgumentException . class )  ;", "findAvailableUdpPorts (  5  0  ,     4  5  0  0  0  ,     4  5  0  1  0  )  ;", "}", "METHOD_END"], "methodName": ["findAvailableUdpPortsWithRequestedNumberGreaterThanSizeOfRange"], "fileName": "org.springframework.util.SocketUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . currentTaskName ;", "}", "METHOD_END"], "methodName": ["currentTaskName"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . lastTaskInfo )     =  =    null )     {", "throw   new   IllegalStateException (  \" No   tasks   run :    can ' t   get   last   task   fo \"  )  ;", "}", "return   this . lastTaskInfo ;", "}", "METHOD_END"], "methodName": ["getLastTaskInfo"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . lastTaskInfo )     =  =    null )     {", "throw   new   IllegalStateException (  \" No   tasks   run :    can ' t   get   last   task   n \"  )  ;", "}", "return   this . lastTaskInfo . getTaskN (  )  ;", "}", "METHOD_END"], "methodName": ["getLastTaskName"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . lastTaskInfo )     =  =    null )     {", "throw   new   IllegalStateException (  \" No   tasks   run :    can ' t   get   last   task   terval \"  )  ;", "}", "return   this . lastTaskInfo . getTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["getLastTaskTimeMillis"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "return   this . taskCount ;", "}", "METHOD_END"], "methodName": ["getTaskCount"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . keepTaskList )  )     {", "throw   new   UnsupportedOperationException (  \" Task   info   is   not   being   kept !  \"  )  ;", "}", "return   this . taskList . toArray ( new    . TaskInfo [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getTaskInfo"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "return   this . totalTimeMillis ;", "}", "METHOD_END"], "methodName": ["getTotalTimeMillis"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "return    ( this . totalTimeMillis )     /     1  0  0  0  .  0  ;", "}", "METHOD_END"], "methodName": ["getTotalTimeSeconds"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "return    ( this . currentTaskName )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isRunning"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( shortSummary (  )  )  ;", "sb . append (  '  \\ n '  )  ;", "if    (  !  ( this . keepTaskList )  )     {", "sb . append (  \" No   task   info   kept \"  )  ;", "} else    {", "sb . append (  \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  \\ n \"  )  ;", "sb . append (  \" ms                %                Task   name \\ n \"  )  ;", "sb . append (  \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  \\ n \"  )  ;", "NumberFormat   nf    =    NumberFormat . getNumberInstance (  )  ;", "nf . setMinimumIntegerDigits (  5  )  ;", "nf . setGroupingUsed ( false )  ;", "NumberFormat   pf    =    NumberFormat . getPercentInstance (  )  ;", "pf . setMinimumIntegerDigits (  3  )  ;", "pf . setGroupingUsed ( false )  ;", "for    (  . TaskInfo   task    :    getTaskInfo (  )  )     {", "sb . append ( nf . format ( task . getTimeMillis (  )  )  )  . append (  \"        \"  )  ;", "sb . append ( pf . format (  (  ( task . getTimeSeconds (  )  )     /     ( getTotalTimeSeconds (  )  )  )  )  )  . append (  \"        \"  )  ;", "sb . append ( task . getTaskName (  )  )  . append (  \"  \\ n \"  )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["prettyPrint"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "this . keepTaskList    =    keepTaskList ;", "}", "METHOD_END"], "methodName": ["setKeepTaskList"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "return    (  (  \" StopWatch    '  \"     +     ( getId (  )  )  )     +     \"  '  :    running   time    ( millis )     =     \"  )     +     ( getTotalTimeMillis (  )  )  ;", "}", "METHOD_END"], "methodName": ["shortSummary"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "start (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . currentTaskName )     !  =    null )     {", "throw   new   IllegalStateException (  \" Can ' t   start    :    it ' s   already   running \"  )  ;", "}", "this . currentTaskName    =    taskName ;", "this . startTimeMillis    =    System . currentTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . currentTaskName )     =  =    null )     {", "throw   new   IllegalStateException (  \" Can ' t   stop    :    it ' s   not   running \"  )  ;", "}", "long   lastTime    =     ( System . currentTimeMillis (  )  )     -     ( this . startTimeMillis )  ;", "this . totalTimeMillis    +  =    lastTime ;", "this . lastTaskInfo    =    new    . TaskInfo ( this . currentTaskName ,    lastTime )  ;", "if    ( this . keepTaskList )     {", "this . taskList . add ( this . lastTaskInfo )  ;", "}", "+  +  ( this . taskCount )  ;", "this . currentTaskName    =    null ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.springframework.util.StopWatch"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalStateException . class )  ;", "sw . getLastTaskTimeMillis (  )  ;", "}", "METHOD_END"], "methodName": ["failureToStartBeforeGettingTimings"], "fileName": "org.springframework.util.StopWatchTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( IllegalStateException . class )  ;", "sw . s (  )  ;", "}", "METHOD_END"], "methodName": ["failureToStartBeforeStop"], "fileName": "org.springframework.util.StopWatchTests"}, {"methodBody": ["METHOD_START", "{", "sw . start (  \"  \"  )  ;", "sw . s (  )  ;", "sw . start (  \"  \"  )  ;", "assertTrue ( sw . isRunning (  )  )  ;", "exception . expect ( IllegalStateException . class )  ;", "sw . start (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["rejectsStartTwice"], "fileName": "org.springframework.util.StopWatchTests"}, {"methodBody": ["METHOD_START", "{", "String   id    =     \" myId \"  ;", "sw    =    new    ( id )  ;", "long   int 1     =     1  6  6 L ;", "long   int 2     =     4  5 L ;", "String   name 1     =     \" Task    1  \"  ;", "String   name 2     =     \" Task    2  \"  ;", "assertFalse ( sw . isRunning (  )  )  ;", "sw . start ( name 1  )  ;", "Thread . sleep ( int 1  )  ;", "assertTrue ( sw . isRunning (  )  )  ;", "assertEquals ( name 1  ,    sw . currentTaskName (  )  )  ;", "sw . stop (  )  ;", "sw . start ( name 2  )  ;", "Thread . sleep ( int 2  )  ;", "sw . stop (  )  ;", "assertTrue (  (  ( sw . getTaskCount (  )  )     =  =     2  )  )  ;", "String   pp    =    sw . prettyPrint (  )  ;", "assertTrue ( pp . contains ( name 1  )  )  ;", "assertTrue ( pp . contains ( name 2  )  )  ;", ". TaskInfo [  ]    tasks    =    sw . getTaskInfo (  )  ;", "assertTrue (  (  ( tasks . length )     =  =     2  )  )  ;", "assertTrue ( tasks [  0  ]  . getTaskName (  )  . equals ( name 1  )  )  ;", "assertTrue ( tasks [  1  ]  . getTaskName (  )  . equals ( name 2  )  )  ;", "String   toString    =    sw . toString (  )  ;", "assertTrue ( toString . contains ( id )  )  ;", "assertTrue ( toString . contains ( name 1  )  )  ;", "assertTrue ( toString . contains ( name 2  )  )  ;", "assertEquals ( id ,    sw . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["validUsage"], "fileName": "org.springframework.util.StopWatchTests"}, {"methodBody": ["METHOD_START", "{", "sw . setKeepTaskList ( false )  ;", "long   int 1     =     1  6  6 L ;", "long   int 2     =     4  5 L ;", "St   name 1     =     \" Task    1  \"  ;", "St   name 2     =     \" Task    2  \"  ;", "assertFalse ( sw . isRunning (  )  )  ;", "sw . start ( name 1  )  ;", "Thread . sleep ( int 1  )  ;", "assertTrue ( sw . isRunning (  )  )  ;", "sw . stop (  )  ;", "sw . start ( name 2  )  ;", "Thread . sleep ( int 2  )  ;", "sw . stop (  )  ;", "assertTrue (  (  ( sw . getTaskCount (  )  )     =  =     2  )  )  ;", "St   pp    =    sw . prettyPrint (  )  ;", "assertTrue ( pp . contains (  \" kept \"  )  )  ;", "St   toSt    =    sw . toSt (  )  ;", "assertFalse ( toSt . contains ( name 1  )  )  ;", "assertFalse ( toSt . contains ( name 2  )  )  ;", "exception . expect ( UnsupportedOperationException . class )  ;", "sw . getTaskInfo (  )  ;", "}", "METHOD_END"], "methodName": ["validUsageNotKeepingTaskList"], "fileName": "org.springframework.util.StopWatchTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   input   byte   array   specified \"  )  ;", "Assert . notNull ( out ,     \" No   Output   specified \"  )  ;", "out . write ( in )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   InputStream   specified \"  )  ;", "Assert . notNull ( out ,     \" No   OutputStream   specified \"  )  ;", "int   byteCount    =     0  ;", "byte [  ]    buffer    =    new   byte [  . BUFFER _ SIZE ]  ;", "int   bytesRead    =     -  1  ;", "while    (  ( bytesRead    =    in . read ( buffer )  )     !  =     (  -  1  )  )     {", "out . write ( buffer ,     0  ,    bytesRead )  ;", "byteCount    +  =    bytesRead ;", "}", "out . flush (  )  ;", "return   byteCount ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   input   String   specified \"  )  ;", "Assert . notNull ( charset ,     \" No   charset   specified \"  )  ;", "Assert . notNull ( out ,     \" No   Output   specified \"  )  ;", "Writer   writer    =    new   OutputWriter ( out ,    charset )  ;", "writer . write ( in )  ;", "writer . flush (  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   InputStream   specified \"  )  ;", "Assert . notNull ( out ,     \" No   OutputStream   specified \"  )  ;", "long   skipped    =    in . skip ( start )  ;", "if    ( skipped    <    start )     {", "throw   new   IOException (  (  (  (  (  \" Skipped   only    \"     +    skipped )     +     \"    bytes   out   of    \"  )     +    start )     +     \"    required \"  )  )  ;", "}", "long   bytesToCopy    =     ( end    -    start )     +     1  ;", "byte [  ]    buffer    =    new   byte [  . BUFFER _ SIZE ]  ;", "while    ( bytesToCopy    >     0  )     {", "int   bytesRead    =    in . read ( buffer )  ;", "if    ( bytesRead    =  =     (  -  1  )  )     {", "break ;", "} else", "if    ( bytesRead    <  =    bytesToCopy )     {", "out . write ( buffer ,     0  ,    bytesRead )  ;", "bytesToCopy    -  =    bytesRead ;", "} else    {", "out . write ( buffer ,     0  ,     (  ( int )     ( bytesToCopy )  )  )  ;", "bytesToCopy    =     0  ;", "}", "}", "return    (  ( end    -    start )     +     1  )     -    bytesToCopy ;", "}", "METHOD_END"], "methodName": ["copyRange"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( in    =  =    null )     {", "return   new   byte [  0  ]  ;", "}", "ByteArrayOutputStream   out    =    new   ByteArrayOutputStream (  . BUFFER _ SIZE )  ;", ". copy ( in ,    out )  ;", "return   out . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["copyToByteArray"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( in    =  =    null )     {", "return    \"  \"  ;", "}", "StringBuilder   out    =    new   StringBuilder (  )  ;", "InputStreamReader   reader    =    new   InputStreamReader ( in ,    charset )  ;", "char [  ]    buffer    =    new   char [  . BUFFER _ SIZE ]  ;", "int   bytesRead    =     -  1  ;", "while    (  ( bytesRead    =    reader . read ( buffer )  )     !  =     (  -  1  )  )     {", "out . append ( buffer ,     0  ,    bytesRead )  ;", "}", "return   out . toString (  )  ;", "}", "METHOD_END"], "methodName": ["copyToString"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   InputStream   specified \"  )  ;", "byte [  ]    buffer    =    new   byte [  . BUFFER _ SIZE ]  ;", "int   bytesRead    =     -  1  ;", "int   byteCount    =     0  ;", "while    (  ( bytesRead    =    in . read ( buffer )  )     !  =     (  -  1  )  )     {", "byteCount    +  =    bytesRead ;", "}", "return   byteCount ;", "}", "METHOD_END"], "methodName": ["drain"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   ByteArrayInputStream ( StreamUtils . EMPTY _ CONTENT )  ;", "}", "METHOD_END"], "methodName": ["emptyInput"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( in ,     \" No   InputStream   specified \"  )  ;", "return   new    . NonClosingInputStream ( in )  ;", "}", "METHOD_END"], "methodName": ["nonClosing"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( out ,     \" No   OutputStream   specified \"  )  ;", "return   new    . NonClosingOutputStream ( out )  ;", "}", "METHOD_END"], "methodName": ["nonClosing"], "fileName": "org.springframework.util.StreamUtils"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   out    =    spy ( new   ByteArrayOutputStream (  )  )  ;", ". copy ( bytes ,    out )  ;", "assertThat ( out . toByteArray (  )  ,    equalTo ( bytes )  )  ;", "verify ( out ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["copyBytes"], "fileName": "org.springframework.util.StreamUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   out    =    spy ( new   ByteArrayOutputStream (  )  )  ;", ". copyRange ( new   ByteArrayInputStream ( bytes )  ,    out ,     0  ,     1  0  0  )  ;", "byte [  ]    range    =    Arrays . copyOfRange ( bytes ,     0  ,     1  0  1  )  ;", "assertThat ( out . toByteArray (  )  ,    equalTo ( range )  )  ;", "verify ( out ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["copyRange"], "fileName": "org.springframework.util.StreamUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   out    =    spy ( new   ByteArrayOutputStream (  )  )  ;", ". copy ( new   ByteArrayInputStream ( bytes )  ,    out )  ;", "assertThat ( out . toByteArray (  )  ,    equalTo ( bytes )  )  ;", "verify ( out ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["copyStream"], "fileName": "org.springframework.util.StreamUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    Charset . defaultCharset (  )  ;", "ByteArrayOutputStream   out    =    spy ( new   ByteArrayOutputStream (  )  )  ;", ". copy ( string ,    charset ,    out )  ;", "assertThat ( out . toByteArray (  )  ,    equalTo ( string . getBytes ( charset )  )  )  ;", "verify ( out ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["copyString"], "fileName": "org.springframework.util.StreamUtilsTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   inputStream    =    spy ( new   ByteArrayInputStream ( bytes )  )  ;", "byte [  ]    actual    =     . copyToByteArray ( inputStream )  ;", "assertThat ( actual ,    equalTo ( bytes )  )  ;", "verify ( inputStream ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["copyToByteArray"], "fileName": "org.springframework.util.StreamUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    Charset . defaultCharset (  )  ;", "InputStream   inputStream    =    spy ( new   ByteArrayInputStream ( string . getBytes ( charset )  )  )  ;", "String   actual    =     . copyToString ( inputStream ,    charset )  ;", "assertThat ( actual ,    equalTo ( string )  )  ;", "verify ( inputStream ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["copyToString"], "fileName": "org.springframework.util.StreamUtilsTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   source    =    mock ( InputStream . class )  ;", "InputStream   nonClosing    =     . nonClosing ( source )  ;", "nonClosing . read (  )  ;", "nonClosing . read ( bytes )  ;", "nonClosing . read ( bytes ,     1  ,     2  )  ;", "nonClosing . close (  )  ;", "InOrder   ordered    =    inOrder ( source )  ;", "ordered . verify ( source )  . read (  )  ;", "ordered . verify ( source )  . read ( bytes ,     0  ,    bytes . length )  ;", "ordered . verify ( source )  . read ( bytes ,     1  ,     2  )  ;", "ordered . verify ( source ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["nonClosingInputStream"], "fileName": "org.springframework.util.StreamUtilsTests"}, {"methodBody": ["METHOD_START", "{", "OutputStream   source    =    mock ( OutputStream . class )  ;", "OutputStream   nonClosing    =     . nonClosing ( source )  ;", "nonClosing . write (  1  )  ;", "nonClosing . write ( bytes )  ;", "nonClosing . write ( bytes ,     1  ,     2  )  ;", "nonClosing . close (  )  ;", "InOrder   ordered    =    inOrder ( source )  ;", "ordered . verify ( source )  . write (  1  )  ;", "ordered . verify ( source )  . write ( bytes ,     0  ,    bytes . length )  ;", "ordered . verify ( source )  . write ( bytes ,     1  ,     2  )  ;", "ordered . verify ( source ,    never (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["nonClosingOutputStream"], "fileName": "org.springframework.util.StreamUtilsTests"}, {"methodBody": ["METHOD_START", "{", "new   Random (  )  . nextBytes ( bytes )  ;", "while    (  ( string . length (  )  )     <     (  (  . BUFFER _ SIZE )     +     1  0  )  )     {", "string    +  =    UUID . randomUUID (  )  . toString (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.util.StreamUtilsTests"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( array )  )     {", "return   new    [  ]  {    str    }  ;", "}", "[  ]    newArr    =    new    [  ( array . length )     +     1  ]  ;", "System . arraycopy ( array ,     0  ,    newArr ,     0  ,    array . length )  ;", "newArr [ array . length ]     =    str ;", "return   newArr ;", "}", "METHOD_END"], "methodName": ["addStringToArray"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "int   separatorIndex    =    path . lastIndexOf ( StringUtils . FOLDER _ SEPARATOR )  ;", "if    ( separatorIndex    !  =     (  -  1  )  )     {", "String   newPath    =    path . substring (  0  ,    separatorIndex )  ;", "if    (  !  ( relativePath . startsWith ( StringUtils . FOLDER _ SEPARATOR )  )  )     {", "newPath    +  =    StringUtils . FOLDER _ SEPARATOR ;", "}", "return   newPath    +    relativePath ;", "} else    {", "return   relativePath ;", "}", "}", "METHOD_END"], "methodName": ["applyRelativePath"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . arrayToDelimitedString ( arr ,     \"  ,  \"  )  ;", "}", "METHOD_END"], "methodName": ["arrayToCommaDelimitedString"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( arr )  )     {", "return    \"  \"  ;", "}", "if    (  ( arr . length )     =  =     1  )     {", "return   ObjectUtils . nullSafeTo ( arr [  0  ]  )  ;", "}", "Builder   sb    =    new   Builder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( arr . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "sb . append ( delim )  ;", "}", "sb . append ( arr [ i ]  )  ;", "}", "return   sb . to (  )  ;", "}", "METHOD_END"], "methodName": ["arrayToDelimitedString"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . changeFirstCharacterCase ( str ,    true )  ;", "}", "METHOD_END"], "methodName": ["capitalize"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( str )  )  )     {", "return   str ;", "}", "char   baseChar    =    str . charAt (  0  )  ;", "char   updatedChar ;", "if    ( capitalize )     {", "updatedChar    =    Character . toUpperCase ( baseChar )  ;", "} else    {", "updatedChar    =    Character . toLowerCase ( baseChar )  ;", "}", "if    ( baseChar    =  =    updatedChar )     {", "return   str ;", "}", "char [  ]    chars    =    str . toCharArray (  )  ;", "chars [  0  ]     =    updatedChar ;", "return   new   String ( chars ,     0  ,    chars . length )  ;", "}", "METHOD_END"], "methodName": ["changeFirstCharacterCase"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( path )  )  )     {", "return   path ;", "}", "String   pathToUse    =    StringUtils . replace ( path ,    StringUtils . WINDOWS _ FOLDER _ SEPARATOR ,    StringUtils . FOLDER _ SEPARATOR )  ;", "int   prefixIndex    =    pathToUse . indexOf (  '  :  '  )  ;", "String   prefix    =     \"  \"  ;", "if    ( prefixIndex    !  =     (  -  1  )  )     {", "prefix    =    pathToUse . substring (  0  ,     ( prefixIndex    +     1  )  )  ;", "if    ( prefix . contains (  \"  /  \"  )  )     {", "prefix    =     \"  \"  ;", "} else    {", "pathToUse    =    pathToUse . substring (  ( prefixIndex    +     1  )  )  ;", "}", "}", "if    ( pathToUse . startsWith ( StringUtils . FOLDER _ SEPARATOR )  )     {", "prefix    =    prefix    +     ( StringUtils . FOLDER _ SEPARATOR )  ;", "pathToUse    =    pathToUse . substring (  1  )  ;", "}", "String [  ]    pathArray    =    StringUtils . delimitedListToStringArray ( pathToUse ,    StringUtils . FOLDER _ SEPARATOR )  ;", "List < String >    pathElements    =    new   LinkedList <  >  (  )  ;", "int   tops    =     0  ;", "for    ( int   i    =     ( pathArray . length )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "String   element    =    pathArray [ i ]  ;", "if    ( StringUtils . CURRENT _ PATH . equals ( element )  )     {", "} else", "if    ( StringUtils . TOP _ PATH . equals ( element )  )     {", "tops +  +  ;", "} else    {", "if    ( tops    >     0  )     {", "tops -  -  ;", "} else    {", "pathElements . add (  0  ,    element )  ;", "}", "}", "}", "for    ( int   i    =     0  ;    i    <    tops ;    i +  +  )     {", "pathElements . add (  0  ,    StringUtils . TOP _ PATH )  ;", "}", "return   prefix    +     ( StringUtils . collectionToDelimitedString ( pathElements ,    StringUtils . FOLDER _ SEPARATOR )  )  ;", "}", "METHOD_END"], "methodName": ["cleanPath"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . collectionToDelimitedString ( coll ,     \"  ,  \"  )  ;", "}", "METHOD_END"], "methodName": ["collectionToCommaDelimitedString"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . collectionToDelimitedString ( coll ,    delim ,     \"  \"  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["collectionToDelimitedString"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( coll )  )     {", "return    \"  \"  ;", "}", "Builder   sb    =    new   Builder (  )  ;", "Iterator <  ?  >    it    =    coll . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "sb . append ( prefix )  . append ( it . next (  )  )  . append ( suffix )  ;", "if    ( it . hasNext (  )  )     {", "sb . append ( delim )  ;", "}", "}", "return   sb . to (  )  ;", "}", "METHOD_END"], "methodName": ["collectionToDelimitedString"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "Set < String >    set    =    new   LinkedHashSet <  >  (  )  ;", "String [  ]    tokens    =     . commaDelimitedListToStringArray ( str )  ;", "for    ( String   token    :    tokens )     {", "set . add ( token )  ;", "}", "return   set ;", "}", "METHOD_END"], "methodName": ["commaDelimitedListToSet"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . delimitedListToStringArray ( str ,     \"  ,  \"  )  ;", "}", "METHOD_END"], "methodName": ["commaDelimitedListToStringArray"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( array 1  )  )     {", "return   array 2  ;", "}", "if    ( ObjectUtils . isEmpty ( array 2  )  )     {", "return   array 1  ;", "}", "[  ]    newArr    =    new    [  ( array 1  . length )     +     ( array 2  . length )  ]  ;", "System . arraycopy ( array 1  ,     0  ,    newArr ,     0  ,    array 1  . length )  ;", "System . arraycopy ( array 2  ,     0  ,    newArr ,    array 1  . length ,    array 2  . length )  ;", "return   newArr ;", "}", "METHOD_END"], "methodName": ["concatenateStringArrays"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "int   strLen    =    str . length (  )  ;", "for    ( int   i    =     0  ;    i    <    strLen ;    i +  +  )     {", "if    (  !  ( Character . isWhitespace ( str . charAt ( i )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsText"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( str )  )  )     {", "return   false ;", "}", "int   strLen    =    str . length (  )  ;", "for    ( int   i    =     0  ;    i    <    strLen ;    i +  +  )     {", "if    ( Character . isWhitespace ( str . charAt ( i )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsWhitespace"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . containsWhitespace (  (  ( CharSequence )     ( str )  )  )  ;", "}", "METHOD_END"], "methodName": ["containsWhitespace"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( StringUtils . hasLength ( str )  )  )     |  |     (  !  ( StringUtils . hasLength ( sub )  )  )  )     {", "return    0  ;", "}", "int   count    =     0  ;", "int   pos    =     0  ;", "int   idx ;", "while    (  ( idx    =    str . indexOf ( sub ,    pos )  )     !  =     (  -  1  )  )     {", "+  + count ;", "pos    =    idx    +     ( sub . length (  )  )  ;", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["countOccurrencesOf"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . replace ( inString ,    pattern ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( StringUtils . hasLength ( inString )  )  )     |  |     (  !  ( StringUtils . hasLength ( charsToDelete )  )  )  )     {", "return   inString ;", "}", "StringBuilder   sb    =    new   StringBuilder ( inString . length (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( inString . length (  )  )  ;    i +  +  )     {", "char   c    =    inString . charAt ( i )  ;", "if    (  ( charsToDelete . indexOf ( c )  )     =  =     (  -  1  )  )     {", "sb . append ( c )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["deleteAny"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . delimitedListToStringArray ( str ,    delimiter ,    null )  ;", "}", "METHOD_END"], "methodName": ["delimitedListToStringArray"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( str    =  =    null )     {", "return   new   String [  0  ]  ;", "}", "if    ( delimiter    =  =    null )     {", "return   new   String [  ]  {    str    }  ;", "}", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "if    (  \"  \"  . equals ( delimiter )  )     {", "for    ( int   i    =     0  ;    i    <     ( str . length (  )  )  ;    i +  +  )     {", "result . add (  . deleteAny ( str . substring ( i ,     ( i    +     1  )  )  ,    charsToDelete )  )  ;", "}", "} else    {", "int   pos    =     0  ;", "int   delPos ;", "while    (  ( delPos    =    str . indexOf ( delimiter ,    pos )  )     !  =     (  -  1  )  )     {", "result . add (  . deleteAny ( str . substring ( pos ,    delPos )  ,    charsToDelete )  )  ;", "pos    =    delPos    +     ( delimiter . length (  )  )  ;", "}", "if    (  (  ( str . length (  )  )     >     0  )     &  &     ( pos    <  =     ( str . length (  )  )  )  )     {", "result . add (  . deleteAny ( str . substring ( pos )  ,    charsToDelete )  )  ;", "}", "}", "return    . toStringArray ( result )  ;", "}", "METHOD_END"], "methodName": ["delimitedListToStringArray"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( str    !  =    null )     &  &     ( suffix    !  =    null )  )     &  &     (  ( str . length (  )  )     >  =     ( suffix . length (  )  )  )  )     &  &     ( str . regionMatches ( true ,     (  ( str . length (  )  )     -     ( suffix . length (  )  )  )  ,    suffix ,     0  ,    suffix . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["endsWithIgnoreCase"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( path    =  =    null )     {", "return   null ;", "}", "int   separatorIndex    =    path . lastIndexOf (  . FOLDER _ SEPARATOR )  ;", "return   separatorIndex    !  =     (  -  1  )     ?    path . substring (  ( separatorIndex    +     1  )  )     :    path ;", "}", "METHOD_END"], "methodName": ["getFilename"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( path    =  =    null )     {", "return   null ;", "}", "int   extIndex    =    path . lastIndexOf (  . EXTENSION _ SEPARATOR )  ;", "if    ( extIndex    =  =     (  -  1  )  )     {", "return   null ;", "}", "int   folderIndex    =    path . lastIndexOf (  . FOLDER _ SEPARATOR )  ;", "if    ( folderIndex    >    extIndex )     {", "return   null ;", "}", "return   path . substring (  ( extIndex    +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getFilenameExtension"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( str    !  =    null )     &  &     (  ( str . length (  )  )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["hasLength"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( str    !  =    null )     &  &     (  !  ( str . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasLength"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( str    !  =    null )     &  &     (  ( str . length (  )  )     >     0  )  )     &  &     ( StringUtils . containsText ( str )  )  ;", "}", "METHOD_END"], "methodName": ["hasText"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( str    !  =    null )     &  &     (  !  ( str . isEmpty (  )  )  )  )     &  &     ( StringUtils . containsText ( str )  )  ;", "}", "METHOD_END"], "methodName": ["hasText"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( str    =  =    null )     |  |     (  \"  \"  . equals ( str )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( array 1  )  )     {", "return   array 2  ;", "}", "if    ( ObjectUtils . isEmpty ( array 2  )  )     {", "return   array 1  ;", "}", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "result . addAll ( Arrays . asList ( array 1  )  )  ;", "for    ( String   str    :    array 2  )     {", "if    (  !  ( result . contains ( str )  )  )     {", "result . add ( str )  ;", "}", "}", "return    . toStringArray ( result )  ;", "}", "METHOD_END"], "methodName": ["mergeStringArrays"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "String [  ]    tokens    =    StringUtils . tokenizeLocaleSource ( localeValue )  ;", "if    (  ( tokens . length )     =  =     1  )     {", "return   Locale . forLanguageTag ( localeValue )  ;", "}", "return   StringUtils . parseLocaleTokens ( localeValue ,    tokens )  ;", "}", "METHOD_END"], "methodName": ["parseLocale"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . parseLocaleTokens ( localeString ,    StringUtils . tokenizeLocaleSource ( localeString )  )  ;", "}", "METHOD_END"], "methodName": ["parseLocaleString"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "String   language    =     (  ( tokens . length )     >     0  )     ?    tokens [  0  ]     :     \"  \"  ;", "String   country    =     (  ( tokens . length )     >     1  )     ?    tokens [  1  ]     :     \"  \"  ;", ". validateLocalePart ( language )  ;", ". validateLocalePart ( country )  ;", "String   variant    =     \"  \"  ;", "if    (  ( tokens . length )     >     2  )     {", "int   endIndexOfCountryCode    =     ( localeString . indexOf ( country ,    language . length (  )  )  )     +     ( country . length (  )  )  ;", "variant    =     . trimLeadingWhitespace ( localeString . substring ( endIndexOfCountryCode )  )  ;", "if    ( variant . startsWith (  \"  _  \"  )  )     {", "variant    =     . trimLeadingCharacter ( variant ,     '  _  '  )  ;", "}", "}", "return    ( language . length (  )  )     >     0     ?    new   Locale ( language ,    country ,    variant )     :    null ;", "}", "METHOD_END"], "methodName": ["parseLocaleTokens"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "TimeZone   timeZone    =    TimeZone . getTimeZone ( timeZoneString )  ;", "if    (  (  \" GMT \"  . equals ( timeZone . getID (  )  )  )     &  &     (  !  ( timeZoneString . startsWith (  \" GMT \"  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   time   zone   specification    '  \"     +    timeZoneString )     +     \"  '  \"  )  )  ;", "}", "return   timeZone ;", "}", "METHOD_END"], "methodName": ["parseTimeZoneString"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . cleanPath ( path 1  )  . equals ( StringUtils . cleanPath ( path 2  )  )  ;", "}", "METHOD_END"], "methodName": ["pathEquals"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   str    !  =    null    ?     (  \"  '  \"     +    str )     +     \"  '  \"     :    null ;", "}", "METHOD_END"], "methodName": ["quote"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   obj   instanceof   String    ?    StringUtils . quote (  (  ( String )     ( obj )  )  )     :    obj ;", "}", "METHOD_END"], "methodName": ["quoteIfString"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( array )  )     {", "return   array ;", "}", "Set < String >    set    =    new   LinkedHashSet <  >  (  )  ;", "for    ( String   element    :    array )     {", "set . add ( element )  ;", "}", "return    . toStringArray ( set )  ;", "}", "METHOD_END"], "methodName": ["removeDuplicateStrings"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( StringUtils . hasLength ( inString )  )  )     |  |     (  !  ( StringUtils . hasLength ( oldPattern )  )  )  )     |  |     ( newPattern    =  =    null )  )     {", "return   inString ;", "}", "int   index    =    inString . indexOf ( oldPattern )  ;", "if    ( index    =  =     (  -  1  )  )     {", "return   inString ;", "}", "int   capacity    =    inString . length (  )  ;", "if    (  ( newPattern . length (  )  )     >     ( oldPattern . length (  )  )  )     {", "capacity    +  =     1  6  ;", "}", "StringBuilder   sb    =    new   StringBuilder ( capacity )  ;", "int   pos    =     0  ;", "int   patLen    =    oldPattern . length (  )  ;", "while    ( index    >  =     0  )     {", "sb . append ( inString . substring ( pos ,    index )  )  ;", "sb . append ( newPattern )  ;", "pos    =    index    +    patLen ;", "index    =    inString . indexOf ( oldPattern ,    pos )  ;", "}", "sb . append ( inString . substring ( pos )  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( array )  )     {", "return   new    [  0  ]  ;", "}", "Arrays . sort ( array )  ;", "return   array ;", "}", "METHOD_END"], "methodName": ["sortStringArray"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( StringUtils . hasLength ( toSplit )  )  )     |  |     (  !  ( StringUtils . hasLength ( delimiter )  )  )  )     {", "return   null ;", "}", "int   offset    =    toSplit . indexOf ( delimiter )  ;", "if    ( offset    <     0  )     {", "return   null ;", "}", "String   beforeDelimiter    =    toSplit . substring (  0  ,    offset )  ;", "String   afterDelimiter    =    toSplit . substring (  ( offset    +     ( delimiter . length (  )  )  )  )  ;", "return   new   String [  ]  {    beforeDelimiter ,    afterDelimiter    }  ;", "}", "METHOD_END"], "methodName": ["split"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . splitArrayElementsIntoProperties ( array ,    delimiter ,    null )  ;", "}", "METHOD_END"], "methodName": ["splitArrayElementsIntoProperties"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( array )  )     {", "return   null ;", "}", "Properties   result    =    new   Properties (  )  ;", "for    ( String   element    :    array )     {", "if    ( charsToDelete    !  =    null )     {", "element    =     . deleteAny ( element ,    charsToDelete )  ;", "}", "String [  ]    splittedElement    =     . split ( element ,    delimiter )  ;", "if    ( splittedElement    =  =    null )     {", "continue ;", "}", "result . setProperty ( splittedElement [  0  ]  . trim (  )  ,    splittedElement [  1  ]  . trim (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["splitArrayElementsIntoProperties"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( str    !  =    null )     &  &     ( prefix    !  =    null )  )     &  &     (  ( str . length (  )  )     >  =     ( prefix . length (  )  )  )  )     &  &     ( str . regionMatches ( true ,     0  ,    prefix ,     0  ,    prefix . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["startsWithIgnoreCase"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "int   extIndex    =    path . lastIndexOf ( StringUtils . EXTENSION _ SEPARATOR )  ;", "if    ( extIndex    =  =     (  -  1  )  )     {", "return   path ;", "}", "int   folderIndex    =    path . lastIndexOf ( StringUtils . FOLDER _ SEPARATOR )  ;", "if    ( folderIndex    >    extIndex )     {", "return   path ;", "}", "return   path . substring (  0  ,    extIndex )  ;", "}", "METHOD_END"], "methodName": ["stripFilenameExtension"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( index    +     ( substring . length (  )  )  )     >     ( str . length (  )  )  )     {", "return   false ;", "}", "for    ( int   i    =     0  ;    i    <     ( substring . length (  )  )  ;    i +  +  )     {", "if    (  ( str . charAt (  ( index    +    i )  )  )     !  =     ( substring . charAt ( i )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["substringMatch"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( locale . getLanguage (  )  )     +     ( StringUtils . hasText ( locale . getCountry (  )  )     ?     \"  -  \"     +     ( locale . getCountry (  )  )     :     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["toLanguageTag"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   collection . toArray ( new   String [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["toStringArray"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . toStringArray ( Collections . list ( enumeration )  )  ;", "}", "METHOD_END"], "methodName": ["toStringArray"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . tokenizeToStringArray ( localeSource ,     \"  _     \"  ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["tokenizeLocaleSource"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . tokenizeToStringArray ( str ,    delimiters ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["tokenizeToStringArray"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( str    =  =    null )     {", "return   new   String [  0  ]  ;", "}", "StringTokenizer   st    =    new   StringTokenizer ( str ,    delimiters )  ;", "List < String >    tokens    =    new   ArrayList <  >  (  )  ;", "while    ( st . hasMoreTokens (  )  )     {", "String   token    =    st . nextToken (  )  ;", "if    ( trimTokens )     {", "token    =    token . trim (  )  ;", "}", "if    (  (  ! ignoreEmptyTokens )     |  |     (  ( token . length (  )  )     >     0  )  )     {", "tokens . add ( token )  ;", "}", "}", "return    . toStringArray ( tokens )  ;", "}", "METHOD_END"], "methodName": ["tokenizeToStringArray"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( str )  )  )     {", "return   str ;", "}", "int   len    =    str . length (  )  ;", "StringBuilder   sb    =    new   StringBuilder ( str . length (  )  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "char   c    =    str . charAt ( i )  ;", "if    (  !  ( Character . isWhitespace ( c )  )  )     {", "sb . append ( c )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["trimAllWhitespace"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( array )  )     {", "return   new    [  0  ]  ;", "}", "[  ]    result    =    new    [ array . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "element    =    array [ i ]  ;", "result [ i ]     =     ( element    !  =    null )     ?    element . trim (  )     :    null ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["trimArrayElements"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( str )  )  )     {", "return   str ;", "}", "StringBuilder   sb    =    new   StringBuilder ( str )  ;", "while    (  (  ( sb . length (  )  )     >     0  )     &  &     (  ( sb . charAt (  0  )  )     =  =    leadingCharacter )  )     {", "sb . deleteCharAt (  0  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["trimLeadingCharacter"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( str )  )  )     {", "return   str ;", "}", "StringBuilder   sb    =    new   StringBuilder ( str )  ;", "while    (  (  ( sb . length (  )  )     >     0  )     &  &     ( Character . isWhitespace ( sb . charAt (  0  )  )  )  )     {", "sb . deleteCharAt (  0  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["trimLeadingWhitespace"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( str )  )  )     {", "return   str ;", "}", "StringBuilder   sb    =    new   StringBuilder ( str )  ;", "while    (  (  ( sb . length (  )  )     >     0  )     &  &     (  ( sb . charAt (  (  ( sb . length (  )  )     -     1  )  )  )     =  =    trailingCharacter )  )     {", "sb . deleteCharAt (  (  ( sb . length (  )  )     -     1  )  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["trimTrailingCharacter"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( str )  )  )     {", "return   str ;", "}", "StringBuilder   sb    =    new   StringBuilder ( str )  ;", "while    (  (  ( sb . length (  )  )     >     0  )     &  &     ( Character . isWhitespace ( sb . charAt (  (  ( sb . length (  )  )     -     1  )  )  )  )  )     {", "sb . deleteCharAt (  (  ( sb . length (  )  )     -     1  )  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["trimTrailingWhitespace"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( str )  )  )     {", "return   str ;", "}", "StringBuilder   sb    =    new   StringBuilder ( str )  ;", "while    (  (  ( sb . length (  )  )     >     0  )     &  &     ( Character . isWhitespace ( sb . charAt (  0  )  )  )  )     {", "sb . deleteCharAt (  0  )  ;", "}", "while    (  (  ( sb . length (  )  )     >     0  )     &  &     ( Character . isWhitespace ( sb . charAt (  (  ( sb . length (  )  )     -     1  )  )  )  )  )     {", "sb . deleteCharAt (  (  ( sb . length (  )  )     -     1  )  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["trimWhitespace"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . changeFirstCharacterCase ( str ,    false )  ;", "}", "METHOD_END"], "methodName": ["uncapitalize"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . unqualify ( qualifiedName ,     '  .  '  )  ;", "}", "METHOD_END"], "methodName": ["unqualify"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "return   qualifiedName . substring (  (  ( qualifiedName . lastIndexOf ( separator )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["unqualify"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "int   length    =    source . length (  )  ;", "if    ( length    =  =     0  )     {", "return   source ;", "}", "Assert . notNull ( charset ,     \" Charset   must   not   be   null \"  )  ;", "ByteArrayOutputStream   bos    =    new   ByteArrayOutputStream ( length )  ;", "boolean   changed    =    false ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "int   ch    =    source . charAt ( i )  ;", "if    ( ch    =  =     '  %  '  )     {", "if    (  ( i    +     2  )     <    length )     {", "char   hex 1     =    source . charAt (  ( i    +     1  )  )  ;", "char   hex 2     =    source . charAt (  ( i    +     2  )  )  ;", "int   u    =    Character . digit ( hex 1  ,     1  6  )  ;", "int   l    =    Character . digit ( hex 2  ,     1  6  )  ;", "if    (  ( u    =  =     (  -  1  )  )     |  |     ( l    =  =     (  -  1  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   encoded   sequence    \\  \"  \"     +     ( source . substring ( i )  )  )     +     \"  \\  \"  \"  )  )  ;", "}", "bos . write (  (  ( char )     (  ( u    <  <     4  )     +    l )  )  )  ;", "i    +  =     2  ;", "changed    =    true ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   encoded   sequence    \\  \"  \"     +     ( source . substring ( i )  )  )     +     \"  \\  \"  \"  )  )  ;", "}", "} else    {", "bos . write ( ch )  ;", "}", "}", "return   changed    ?    new    ( bos . toByteArray (  )  ,    charset )     :    source ;", "}", "METHOD_END"], "methodName": ["uriDecode"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( localePart . length (  )  )  ;    i +  +  )     {", "char   ch    =    localePart . charAt ( i )  ;", "if    (  (  (  ( ch    !  =     '     '  )     &  &     ( ch    !  =     '  _  '  )  )     &  &     ( ch    !  =     '  #  '  )  )     &  &     (  !  ( Character . isLetterOrDigit ( ch )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Locale   part    \\  \"  \"     +    localePart )     +     \"  \\  \"    contains   invalid   characters \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateLocalePart"], "fileName": "org.springframework.util.StringUtils"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( components . length )  ;    i +  +  )     {", "if    ( i    !  =     0  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "sb . append ( components [ i ]  )  ;", "}", "String [  ]    sa    =     . commaDelimitedListToStringArray ( sb . toString (  )  )  ;", "assertTrue (  \" String   array   isn ' t   null   with   legal   match \"  ,     ( sa    !  =    null )  )  ;", "assertEquals (  \" String   array   length   is   correct   with   legal   match \"  ,    components . length ,    sa . length )  ;", "assertTrue (  \" Output   equals   input \"  ,    Arrays . equals ( sa ,    components )  )  ;", "}", "METHOD_END"], "methodName": ["doTestCommaDelimitedListToStringArrayLegalMatch"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    reverse    =    StringUtils . commaDelimitedListToStringArray ( StringUtils . arrayToCommaDelimitedString ( sa )  )  ;", "assertEquals (  \" Reverse   transformation   is   equal \"  ,    Arrays . asList ( sa )  ,    Arrays . asList ( reverse )  )  ;", "}", "METHOD_END"], "methodName": ["doTestStringArrayReverseTransformationMatches"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   capitalized    =     \" i   am   not   capitalized \"  ;", "assertEquals (  \" I   am   not   capitalized \"  ,     . capitalize ( capitalized )  )  ;", "}", "METHOD_END"], "methodName": ["testCapitalize"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" mypath / myfile \"  ,    StringUtils . cleanPath (  \" mypath / myfile \"  )  )  ;", "assertEquals (  \" mypath / myfile \"  ,    StringUtils . cleanPath (  \" mypath \\  \\ myfile \"  )  )  ;", "assertEquals (  \" mypath / myfile \"  ,    StringUtils . cleanPath (  \" mypath /  .  .  / mypath / myfile \"  )  )  ;", "assertEquals (  \" mypath / myfile \"  ,    StringUtils . cleanPath (  \" mypath / myfile /  .  .  /  .  .  / mypath / myfile \"  )  )  ;", "assertEquals (  \"  .  .  / mypath / myfile \"  ,    StringUtils . cleanPath (  \"  .  .  / mypath / myfile \"  )  )  ;", "assertEquals (  \"  .  .  / mypath / myfile \"  ,    StringUtils . cleanPath (  \"  .  .  / mypath /  .  .  / mypath / myfile \"  )  )  ;", "assertEquals (  \"  .  .  / mypath / myfile \"  ,    StringUtils . cleanPath (  \" mypath /  .  .  /  .  .  / mypath / myfile \"  )  )  ;", "assertEquals (  \"  /  .  .  / mypath / myfile \"  ,    StringUtils . cleanPath (  \"  /  .  .  / mypath / myfile \"  )  )  ;", "assertEquals (  \"  / mypath / myfile \"  ,    StringUtils . cleanPath (  \"  / a /  : b /  .  .  /  .  .  / mypath / myfile \"  )  )  ;", "assertEquals (  \" file :  /  /  / c :  / path / to / the %  2  0 file . txt \"  ,    StringUtils . cleanPath (  \" file :  /  /  / c :  / some /  .  .  / path / to / the %  2  0 file . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCleanPath"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . commaDelimitedListToStringArray (  \" a ,  , b \"  )  ;", "assertEquals (  \" a ,  , b   produces   array   length    3  \"  ,     3  ,    sa . length )  ;", "assertTrue (  \" components   are   correct \"  ,     (  (  ( sa [  0  ]  . equals (  \" a \"  )  )     &  &     ( sa [  1  ]  . equals (  \"  \"  )  )  )     &  &     ( sa [  2  ]  . equals (  \" b \"  )  )  )  )  ;", "sa    =    new   String [  ]  {     \"  \"  ,     \"  \"  ,     \" a \"  ,     \"  \"     }  ;", "doTestCommaDelimitedListToStringArrayLegalMatch ( sa )  ;", "}", "METHOD_END"], "methodName": ["testCommaDelimitedListToStringArrayEmptyStrings"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    new   String [  ]  {     \" foo \"  ,     \" bar \"  ,     \" big \"     }  ;", "doTestCommaDelimitedListToStringArrayLegalMatch ( sa )  ;", "doTestStringArrayReverseTransformationMatches ( sa )  ;", "sa    =    new   String [  ]  {     \" a \"  ,     \" b \"  ,     \" c \"     }  ;", "doTestCommaDelimitedListToStringArrayLegalMatch ( sa )  ;", "doTestStringArrayReverseTransformationMatches ( sa )  ;", "sa    =    new   String [  ]  {     \" AA \"  ,     \" AA \"  ,     \" AA \"  ,     \" AA \"  ,     \" AA \"     }  ;", "doTestCommaDelimitedListToStringArrayLegalMatch ( sa )  ;", "doTestStringArrayReverseTransformationMatches ( sa )  ;", "}", "METHOD_END"], "methodName": ["testCommaDelimitedListToStringArrayMatchWords"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" woeirqupoiewuropqiewuorpqiwueopriquwopeiurqopwieur \"  ;", "String [  ]    sa    =     . commaDelimitedListToStringArray ( s )  ;", "assertTrue (  \" Found   one   String   with   no   delimiters \"  ,     (  ( sa . length )     =  =     1  )  )  ;", "assertTrue (  \" Single   array   entry   matches   input   String   with   no   delimiters \"  ,    sa [  0  ]  . equals ( s )  )  ;", "}", "METHOD_END"], "methodName": ["testCommaDelimitedListToStringArraySingleString"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . commaDelimitedListToStringArray (  \"  \"  )  ;", "assertTrue (  \" String   array   isn ' t   null   with   null   input \"  ,     ( sa    !  =    null )  )  ;", "assertTrue (  \" String   array   length    =  =     0    with   null   input \"  ,     (  ( sa . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testCommaDelimitedListToStringArrayWithEmptyStringProducesEmptyArray"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . commaDelimitedListToStringArray ( null )  ;", "assertTrue (  \" String   array   isn ' t   null   with   null   input \"  ,     ( sa    !  =    null )  )  ;", "assertTrue (  \" String   array   length    =  =     0    with   null   input \"  ,     (  ( sa . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testCommaDelimitedListToStringArrayWithNullProducesEmptyArray"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    new   String [  ]  {     \" xcvwert 4  4  5  6  3  4  6  &  *  .  \"  ,     \"  /  /  /  \"  ,     \"  .  !  \"  ,     \"  .  \"  ,     \"  ;  \"     }  ;", "doTestCommaDelimitedListToStringArrayLegalMatch ( sa )  ;", "}", "METHOD_END"], "methodName": ["testCommaDelimitedListToStringArrayWithOtherPunctuation"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    input 1     =    new   String [  ]  {     \" myString 2  \"     }  ;", "String [  ]    input 2     =    new   String [  ]  {     \" myString 1  \"  ,     \" myString 2  \"     }  ;", "String [  ]    result    =     . concatenateStringArrays ( input 1  ,    input 2  )  ;", "assertEquals (  3  ,    result . length )  ;", "assertEquals (  \" myString 2  \"  ,    result [  0  ]  )  ;", "assertEquals (  \" myString 1  \"  ,    result [  1  ]  )  ;", "assertEquals (  \" myString 2  \"  ,    result [  2  ]  )  ;", "assertArrayEquals ( input 1  ,     . concatenateStringArrays ( input 1  ,    null )  )  ;", "assertArrayEquals ( input 2  ,     . concatenateStringArrays ( null ,    input 2  )  )  ;", "assertNull (  . concatenateStringArrays ( null ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testConcatenateStringArrays"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( StringUtils . containsWhitespace ( null )  )  ;", "assertFalse ( StringUtils . containsWhitespace (  \"  \"  )  )  ;", "assertFalse ( StringUtils . containsWhitespace (  \" a \"  )  )  ;", "assertFalse ( StringUtils . containsWhitespace (  \" abc \"  )  )  ;", "assertTrue ( StringUtils . containsWhitespace (  \"     \"  )  )  ;", "assertTrue ( StringUtils . containsWhitespace (  \"    a \"  )  )  ;", "assertTrue ( StringUtils . containsWhitespace (  \" abc    \"  )  )  ;", "assertTrue ( StringUtils . containsWhitespace (  \" a   b \"  )  )  ;", "assertTrue ( StringUtils . containsWhitespace (  \" a      b \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testContainsWhitespace"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" nullx 2     =     0  \"  ,     (  ( StringUtils . countOccurrencesOf ( null ,    null )  )     =  =     0  )  )  ;", "assertTrue (  \" null   string    =     0  \"  ,     (  ( StringUtils . countOccurrencesOf (  \" s \"  ,    null )  )     =  =     0  )  )  ;", "assertTrue (  \" null   substring    =     0  \"  ,     (  ( StringUtils . countOccurrencesOf ( null ,     \" s \"  )  )     =  =     0  )  )  ;", "String   s    =     \" erowoiueoiur \"  ;", "assertTrue (  \" not   found    =     0  \"  ,     (  ( StringUtils . countOccurrencesOf ( s ,     \" WERWER \"  )  )     =  =     0  )  )  ;", "assertTrue (  \" not   found   char    =     0  \"  ,     (  ( StringUtils . countOccurrencesOf ( s ,     \" x \"  )  )     =  =     0  )  )  ;", "assertTrue (  \" not   found   ws    =     0  \"  ,     (  ( StringUtils . countOccurrencesOf ( s ,     \"     \"  )  )     =  =     0  )  )  ;", "assertTrue (  \" not   found   empty   string    =     0  \"  ,     (  ( StringUtils . countOccurrencesOf ( s ,     \"  \"  )  )     =  =     0  )  )  ;", "assertTrue (  \" found   char =  2  \"  ,     (  ( StringUtils . countOccurrencesOf ( s ,     \" e \"  )  )     =  =     2  )  )  ;", "assertTrue (  \" found   substring =  2  \"  ,     (  ( StringUtils . countOccurrencesOf ( s ,     \" oi \"  )  )     =  =     2  )  )  ;", "assertTrue (  \" found   substring =  2  \"  ,     (  ( StringUtils . countOccurrencesOf ( s ,     \" oiu \"  )  )     =  =     2  )  )  ;", "assertTrue (  \" found   substring =  3  \"  ,     (  ( StringUtils . countOccurrencesOf ( s ,     \" oiur \"  )  )     =  =     1  )  )  ;", "assertTrue (  \" test   last \"  ,     (  ( StringUtils . countOccurrencesOf ( s ,     \" r \"  )  )     =  =     2  )  )  ;", "}", "METHOD_END"], "methodName": ["testCountOccurrencesOf"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   inString    =     \" The   quick   brown   fox   jumped   over   the   lazy   dog \"  ;", "String   noThe    =     . delete ( inString ,     \" the \"  )  ;", "assertTrue (  (  (  \" Result   has   no   the    [  \"     +    noThe )     +     \"  ]  \"  )  ,    noThe . equals (  \" The   quick   brown   fox   jumped   over      lazy   dog \"  )  )  ;", "String   nohe    =     . delete ( inString ,     \" he \"  )  ;", "assertTrue (  (  (  \" Result   has   no   he    [  \"     +    nohe )     +     \"  ]  \"  )  ,    nohe . equals (  \" T   quick   brown   fox   jumped   over   t   lazy   dog \"  )  )  ;", "String   nosp    =     . delete ( inString ,     \"     \"  )  ;", "assertTrue (  \" Result   has   no   spaces \"  ,    nosp . equals (  \" Thequickbrownfoxjumpedoverthelazydog \"  )  )  ;", "String   killEnd    =     . delete ( inString ,     \" dog \"  )  ;", "assertTrue (  \" Result   has   no   dog \"  ,    killEnd . equals (  \" The   quick   brown   fox   jumped   over   the   lazy    \"  )  )  ;", "String   mismatch    =     . delete ( inString ,     \" dxxcxcxog \"  )  ;", "assertTrue (  \" Result   is   unchanged \"  ,    mismatch . equals ( inString )  )  ;", "String   nochange    =     . delete ( inString ,     \"  \"  )  ;", "assertTrue (  \" Result   is   unchanged \"  ,    nochange . equals ( inString )  )  ;", "}", "METHOD_END"], "methodName": ["testDelete"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   inString    =     \" Able   was   I   ere   I   saw   Elba \"  ;", "String   res    =     . deleteAny ( inString ,     \" I \"  )  ;", "assertTrue (  (  (  \" Result   has   no   Is    [  \"     +    res )     +     \"  ]  \"  )  ,    res . equals (  \" Able   was      ere      saw   Elba \"  )  )  ;", "res    =     . deleteAny ( inString ,     \" AeEba !  \"  )  ;", "assertTrue (  (  (  \" Result   has   no   Is    [  \"     +    res )     +     \"  ]  \"  )  ,    res . equals (  \" l   ws   I   r   I   sw   l \"  )  )  ;", "String   mismatch    =     . deleteAny ( inString ,     \"  #  @  $  #  $  ^  \"  )  ;", "assertTrue (  \" Result   is   unchanged \"  ,    mismatch . equals ( inString )  )  ;", "String   whitespace    =     \" This   is \\ n \\ n \\ n             \\ t         a   messagy   string   with   whitespace \\ n \"  ;", "assertTrue (  \" Has   CR \"  ,    whitespace . contains (  \"  \\ n \"  )  )  ;", "assertTrue (  \" Has   tab \"  ,    whitespace . contains (  \"  \\ t \"  )  )  ;", "assertTrue (  \" Has      sp \"  ,    whitespace . contains (  \"     \"  )  )  ;", "String   cleaned    =     . deleteAny ( whitespace ,     \"  \\ n \\ t    \"  )  ;", "assertTrue (  \" Has   no   CR \"  ,     (  !  ( cleaned . contains (  \"  \\ n \"  )  )  )  )  ;", "assertTrue (  \" Has   no   tab \"  ,     (  !  ( cleaned . contains (  \"  \\ t \"  )  )  )  )  ;", "assertTrue (  \" Has   no   sp \"  ,     (  !  ( cleaned . contains (  \"     \"  )  )  )  )  ;", "assertTrue (  \" Still   has   chars \"  ,     (  ( cleaned . length (  )  )     >     1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testDeleteAny"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . delimitedListToStringArray (  \" a , b \"  ,     \"  ,  \"  )  ;", "assertEquals (  2  ,    sa . length )  ;", "assertEquals (  \" a \"  ,    sa [  0  ]  )  ;", "assertEquals (  \" b \"  ,    sa [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testDelimitedListToStringArrayWithComma"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . delimitedListToStringArray (  \" a , b \"  ,     \"  \"  )  ;", "assertEquals (  3  ,    sa . length )  ;", "assertEquals (  \" a \"  ,    sa [  0  ]  )  ;", "assertEquals (  \"  ,  \"  ,    sa [  1  ]  )  ;", "assertEquals (  \" b \"  ,    sa [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["testDelimitedListToStringArrayWithEmptyString"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . delimitedListToStringArray (  \" a , b \"  ,    null )  ;", "assertEquals (  1  ,    sa . length )  ;", "assertEquals (  \" a , b \"  ,    sa [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testDelimitedListToStringArrayWithNullDelimiter"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . delimitedListToStringArray (  \" a ; b \"  ,     \"  ;  \"  )  ;", "assertEquals (  2  ,    sa . length )  ;", "assertEquals (  \" a \"  ,    sa [  0  ]  )  ;", "assertEquals (  \" b \"  ,    sa [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testDelimitedListToStringArrayWithSemicolon"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   suffix    =     \" fOo \"  ;", "assertTrue (  . endsWithIgnoreCase (  \" foo \"  ,    suffix )  )  ;", "assertTrue (  . endsWithIgnoreCase (  \" Foo \"  ,    suffix )  )  ;", "assertTrue (  . endsWithIgnoreCase (  \" barfoo \"  ,    suffix )  )  ;", "assertTrue (  . endsWithIgnoreCase (  \" barbarfoo \"  ,    suffix )  )  ;", "assertTrue (  . endsWithIgnoreCase (  \" barFoo \"  ,    suffix )  )  ;", "assertTrue (  . endsWithIgnoreCase (  \" barBarFoo \"  ,    suffix )  )  ;", "assertTrue (  . endsWithIgnoreCase (  \" barfoO \"  ,    suffix )  )  ;", "assertTrue (  . endsWithIgnoreCase (  \" barFOO \"  ,    suffix )  )  ;", "assertTrue (  . endsWithIgnoreCase (  \" barfOo \"  ,    suffix )  )  ;", "assertFalse (  . endsWithIgnoreCase ( null ,    suffix )  )  ;", "assertFalse (  . endsWithIgnoreCase (  \" barfOo \"  ,    null )  )  ;", "assertFalse (  . endsWithIgnoreCase (  \" b \"  ,    suffix )  )  ;", "assertFalse (  . endsWithIgnoreCase (  \" foobar \"  ,    suffix )  )  ;", "assertFalse (  . endsWithIgnoreCase (  \" barfoobar \"  ,    suffix )  )  ;", "}", "METHOD_END"], "methodName": ["testEndsWithIgnoreCase"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    StringUtils . getFilename ( null )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . getFilename (  \"  \"  )  )  ;", "assertEquals (  \" myfile \"  ,    StringUtils . getFilename (  \" myfile \"  )  )  ;", "assertEquals (  \" myfile \"  ,    StringUtils . getFilename (  \" mypath / myfile \"  )  )  ;", "assertEquals (  \" myfile .  \"  ,    StringUtils . getFilename (  \" myfile .  \"  )  )  ;", "assertEquals (  \" myfile .  \"  ,    StringUtils . getFilename (  \" mypath / myfile .  \"  )  )  ;", "assertEquals (  \" myfile . txt \"  ,    StringUtils . getFilename (  \" myfile . txt \"  )  )  ;", "assertEquals (  \" myfile . txt \"  ,    StringUtils . getFilename (  \" mypath / myfile . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetFilename"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    StringUtils . getFilenameExtension ( null )  )  ;", "assertEquals ( null ,    StringUtils . getFilenameExtension (  \"  \"  )  )  ;", "assertEquals ( null ,    StringUtils . getFilenameExtension (  \" myfile \"  )  )  ;", "assertEquals ( null ,    StringUtils . getFilenameExtension (  \" myPath / myfile \"  )  )  ;", "assertEquals ( null ,    StringUtils . getFilenameExtension (  \"  / home / user /  . m 2  / settings / myfile \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . getFilenameExtension (  \" myfile .  \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . getFilenameExtension (  \" myPath / myfile .  \"  )  )  ;", "assertEquals (  \" txt \"  ,    StringUtils . getFilenameExtension (  \" myfile . txt \"  )  )  ;", "assertEquals (  \" txt \"  ,    StringUtils . getFilenameExtension (  \" mypath / myfile . txt \"  )  )  ;", "assertEquals (  \" txt \"  ,    StringUtils . getFilenameExtension (  \"  / home / user /  . m 2  / settings / myfile . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetFilenameExtension"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   blank    =     \"                                \"  ;", "assertEquals ( false ,     . hasText ( blank )  )  ;", "}", "METHOD_END"], "methodName": ["testHasTextBlank"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( false ,    StringUtils . hasText ( null )  )  ;", "assertEquals ( false ,    StringUtils . hasText (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHasTextNullEmpty"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( true ,    StringUtils . hasText (  \" t \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHasTextValid"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    input 1     =    new   String [  ]  {     \" myString 2  \"     }  ;", "String [  ]    input 2     =    new   String [  ]  {     \" myString 1  \"  ,     \" myString 2  \"     }  ;", "String [  ]    result    =     . mergeStringArrays ( input 1  ,    input 2  )  ;", "assertEquals (  2  ,    result . length )  ;", "assertEquals (  \" myString 2  \"  ,    result [  0  ]  )  ;", "assertEquals (  \" myString 1  \"  ,    result [  1  ]  )  ;", "assertArrayEquals ( input 1  ,     . mergeStringArrays ( input 1  ,    null )  )  ;", "assertArrayEquals ( input 2  ,     . mergeStringArrays ( null ,    input 2  )  )  ;", "assertNull (  . mergeStringArrays ( null ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testMergeStringArrays"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" sr _  # LATN \"  ,    StringUtils . parseLocaleString (  \" sr _  # LATN \"  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseJava7Variant"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Locale   expectedLocale    =    Locale . UK ;", "Locale   locale    =     . parseLocaleString ( expectedLocale . toString (  )  )  ;", "assertNotNull (  \" When   given   a   bona - fide   Locale   string ,    must   not   return   null .  \"  ,    locale )  ;", "assertEquals ( expectedLocale ,    locale )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleStringSunnyDay"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Locale   locale    =    StringUtils . parseLocaleString (  \"  \"  )  ;", "assertNull (  \" When   given   an   empty   Locale   string ,    must   return   null .  \"  ,    locale )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleStringWithEmptyLocaleStringYieldsNullLocale"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Locale   locale    =    StringUtils . parseLocaleString (  \"  _ banjo _ on _ my _ knee \"  )  ;", "assertNotNull (  \" When   given   a   malformed   Locale   string ,    must   not   return   null .  \"  ,    locale )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleStringWithMalformedLocaleString"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "try    {", ". parseLocaleString (  \"  %  0 D %  0 AContent - length :  3  0  %  0 D %  0 A %  0 D %  0 A %  3 Cscript %  3 Ealert %  2  8  1  2  3  %  2  9  %  3 C / script %  3 E \"  )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testParseLocaleWithInvalidCharacters"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   variant    =     \" proper - northern \"  ;", "String   localeString    =     \" en _ GB _  \"     +    variant ;", "Locale   locale    =     . parseLocaleString ( localeString )  ;", "assertEquals (  \" Multi - valued   variant   portion   of   the   Locale   not   extracted   correctly .  \"  ,    variant ,    locale . getVariant (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleWithMultiSpecialCharactersInVariant"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   variant    =     \" proper _ northern \"  ;", "String   localeString    =     \" en _ GB _  \"     +    variant ;", "Locale   locale    =     . parseLocaleString ( localeString )  ;", "assertEquals (  \" Multi - valued   variant   portion   of   the   Locale   not   extracted   correctly .  \"  ,    variant ,    locale . getVariant (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleWithMultiValuedVariant"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   variant    =     \" proper   northern \"  ;", "String   localeString    =     \" en _ GB _  \"     +    variant ;", "Locale   locale    =     . parseLocaleString ( localeString )  ;", "assertEquals (  \" Multi - valued   variant   portion   of   the   Locale   not   extracted   correctly .  \"  ,    variant ,    locale . getVariant (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleWithMultiValuedVariantUsingMixtureOfUnderscoresAndSpacesAsSeparators"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   variant    =     \" proper   northern \"  ;", "String   localeString    =     \" en   GB    \"     +    variant ;", "Locale   locale    =     . parseLocaleString ( localeString )  ;", "assertEquals (  \" Multi - valued   variant   portion   of   the   Locale   not   extracted   correctly .  \"  ,    variant ,    locale . getVariant (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleWithMultiValuedVariantUsingSpacesAsSeparators"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   variant    =     \" proper   northern \"  ;", "String   localeString    =     \" en   GB                                     \"     +    variant ;", "Locale   locale    =     . parseLocaleString ( localeString )  ;", "assertEquals (  \" Multi - valued   variant   portion   of   the   Locale   not   extracted   correctly .  \"  ,    variant ,    locale . getVariant (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleWithMultiValuedVariantUsingSpacesAsSeparatorsWithLotsOfLeadingWhitespace"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   variant    =     \" proper _ northern \"  ;", "String   localeString    =     \" en _ GB _  _  _  _  _  \"     +    variant ;", "Locale   locale    =     . parseLocaleString ( localeString )  ;", "assertEquals (  \" Multi - valued   variant   portion   of   the   Locale   not   extracted   correctly .  \"  ,    variant ,    locale . getVariant (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleWithMultiValuedVariantUsingUnderscoresAsSeparatorsWithLotsOfLeadingWhitespace"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" tr _ TR \"  ,    StringUtils . parseLocaleString (  \" tr _ tr \"  )  . toString (  )  )  ;", "assertEquals (  \" bg _ BG _ vnt \"  ,    StringUtils . parseLocaleString (  \" bg _ bg _ vnt \"  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleWithSameLowercaseTokenForLanguageAndCountry"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   variant    =     \" GBtest \"  ;", "String   localeString    =     \" en _ GB _  \"     +    variant ;", "Locale   locale    =     . parseLocaleString ( localeString )  ;", "assertEquals (  \" Variant   containing   country   code   not   extracted   correctly \"  ,    variant ,    locale . getVariant (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParseLocaleWithVariantContainingCountryCode"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Must   be   true   for   the   same   strings \"  ,    StringUtils . pathEquals (  \"  / dummy 1  / dummy 2  / dummy 3  \"  ,     \"  / dummy 1  / dummy 2  / dummy 3  \"  )  )  ;", "assertTrue (  \" Must   be   true   for   the   same   win   strings \"  ,    StringUtils . pathEquals (  \" C :  \\  \\ dummy 1  \\  \\ dummy 2  \\  \\ dummy 3  \"  ,     \" C :  \\  \\ dummy 1  \\  \\ dummy 2  \\  \\ dummy 3  \"  )  )  ;", "assertTrue (  \" Must   be   true   for   one   top   path   on    1  \"  ,    StringUtils . pathEquals (  \"  / dummy 1  / bin /  .  .  / dummy 2  / dummy 3  \"  ,     \"  / dummy 1  / dummy 2  / dummy 3  \"  )  )  ;", "assertTrue (  \" Must   be   true   for   one   win   top   path   on    2  \"  ,    StringUtils . pathEquals (  \" C :  \\  \\ dummy 1  \\  \\ dummy 2  \\  \\ dummy 3  \"  ,     \" C :  \\  \\ dummy 1  \\  \\ bin \\  \\  .  .  \\  \\ dummy 2  \\  \\ dummy 3  \"  )  )  ;", "assertTrue (  \" Must   be   true   for   two   top   paths   on    1  \"  ,    StringUtils . pathEquals (  \"  / dummy 1  / bin /  .  .  / dummy 2  / bin /  .  .  / dummy 3  \"  ,     \"  / dummy 1  / dummy 2  / dummy 3  \"  )  )  ;", "assertTrue (  \" Must   be   true   for   two   win   top   paths   on    2  \"  ,    StringUtils . pathEquals (  \" C :  \\  \\ dummy 1  \\  \\ dummy 2  \\  \\ dummy 3  \"  ,     \" C :  \\  \\ dummy 1  \\  \\ bin \\  \\  .  .  \\  \\ dummy 2  \\  \\ bin \\  \\  .  .  \\  \\ dummy 3  \"  )  )  ;", "assertTrue (  \" Must   be   true   for   double   top   paths   on    1  \"  ,    StringUtils . pathEquals (  \"  / dummy 1  / bin / tmp /  .  .  /  .  .  / dummy 2  / dummy 3  \"  ,     \"  / dummy 1  / dummy 2  / dummy 3  \"  )  )  ;", "assertTrue (  \" Must   be   true   for   double   top   paths   on    2    with   similarity \"  ,    StringUtils . pathEquals (  \"  / dummy 1  / dummy 2  / dummy 3  \"  ,     \"  / dummy 1  / dum / dum /  .  .  /  .  .  / dummy 2  / dummy 3  \"  )  )  ;", "assertTrue (  \" Must   be   true   for   current   paths \"  ,    StringUtils . pathEquals (  \"  .  / dummy 1  / dummy 2  / dummy 3  \"  ,     \" dummy 1  / dum /  .  / dum /  .  .  /  .  .  / dummy 2  / dummy 3  \"  )  )  ;", "assertFalse (  \" Must   be   false   for   relative / absolute   paths \"  ,    StringUtils . pathEquals (  \"  .  / dummy 1  / dummy 2  / dummy 3  \"  ,     \"  / dummy 1  / dum /  .  / dum /  .  .  /  .  .  / dummy 2  / dummy 3  \"  )  )  ;", "assertFalse (  \" Must   be   false   for   different   strings \"  ,    StringUtils . pathEquals (  \"  / dummy 1  / dummy 2  / dummy 3  \"  ,     \"  / dummy 1  / dummy 4  / dummy 3  \"  )  )  ;", "assertFalse (  \" Must   be   false   for   one   false   path   on    1  \"  ,    StringUtils . pathEquals (  \"  / dummy 1  / bin / tmp /  .  .  / dummy 2  / dummy 3  \"  ,     \"  / dummy 1  / dummy 2  / dummy 3  \"  )  )  ;", "assertFalse (  \" Must   be   false   for   one   false   win   top   path   on    2  \"  ,    StringUtils . pathEquals (  \" C :  \\  \\ dummy 1  \\  \\ dummy 2  \\  \\ dummy 3  \"  ,     \" C :  \\  \\ dummy 1  \\  \\ bin \\  \\ tmp \\  \\  .  .  \\  \\ dummy 2  \\  \\ dummy 3  \"  )  )  ;", "assertFalse (  \" Must   be   false   for   top   path   on    1     +    difference \"  ,    StringUtils . pathEquals (  \"  / dummy 1  / bin /  .  .  / dummy 2  / dummy 3  \"  ,     \"  / dummy 1  / dummy 2  / dummy 4  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPathEquals"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  ' myString '  \"  ,    StringUtils . quote (  \" myString \"  )  )  ;", "assertEquals (  \"  '  '  \"  ,    StringUtils . quote (  \"  \"  )  )  ;", "assertNull ( StringUtils . quote ( null )  )  ;", "}", "METHOD_END"], "methodName": ["testQuote"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  ' myString '  \"  ,    StringUtils . quoteIfString (  \" myString \"  )  )  ;", "assertEquals (  \"  '  '  \"  ,    StringUtils . quoteIfString (  \"  \"  )  )  ;", "assertEquals ( Integer . valueOf (  5  )  ,    StringUtils . quoteIfString (  5  )  )  ;", "assertNull ( StringUtils . quoteIfString ( null )  )  ;", "}", "METHOD_END"], "methodName": ["testQuoteIfString"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    input    =    new   String [  ]  {     \" myString 2  \"  ,     \" myString 1  \"  ,     \" myString 2  \"     }  ;", "input    =     . removeDuplicateStrings ( input )  ;", "assertEquals (  \" myString 2  \"  ,    input [  0  ]  )  ;", "assertEquals (  \" myString 1  \"  ,    input [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveDuplicateStrings"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   inString    =     \" a 6 AazAaa 7  7 abaa \"  ;", "String   oldPattern    =     \" aa \"  ;", "String   newPattern    =     \" foo \"  ;", "String   s    =     . replace ( inString ,    oldPattern ,    newPattern )  ;", "assertTrue (  \" Replace    1    worked \"  ,    s . equals (  \" a 6 AazAfoo 7  7 abfoo \"  )  )  ;", "s    =     . replace ( inString ,     \" qwoeiruqopwieurpoqwieur \"  ,    newPattern )  ;", "assertSame (  \" Replace   non - matched   is   returned   as - is \"  ,    inString ,    s )  ;", "s    =     . replace ( inString ,    oldPattern ,    null )  ;", "assertSame (  \" Replace   non - matched   is   returned   as - is \"  ,    inString ,    s )  ;", "s    =     . replace ( inString ,    null ,    newPattern )  ;", "assertSame (  \" Replace   non - matched   is   returned   as - is \"  ,    inString ,    s )  ;", "}", "METHOD_END"], "methodName": ["testReplace"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    input    =    new   String [  ]  {     \" myString 2  \"     }  ;", "input    =     . addStringToArray ( input ,     \" myString 1  \"  )  ;", "assertEquals (  \" myString 2  \"  ,    input [  0  ]  )  ;", "assertEquals (  \" myString 1  \"  ,    input [  1  ]  )  ;", ". sortStringArray ( input )  ;", "assertEquals (  \" myString 1  \"  ,    input [  0  ]  )  ;", "assertEquals (  \" myString 2  \"  ,    input [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testSortStringArray"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    input    =    new   String [  ]  {     \" key 1  = value 1     \"  ,     \" key 2     =  \\  \" value 2  \\  \"  \"     }  ;", "Properties   result    =     . splitArrayElementsIntoProperties ( input ,     \"  =  \"  )  ;", "assertEquals (  \" value 1  \"  ,    result . getProperty (  \" key 1  \"  )  )  ;", "assertEquals (  \"  \\  \" value 2  \\  \"  \"  ,    result . getProperty (  \" key 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSplitArrayElementsIntoProperties"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    input    =    new   String [  ]  {     \" key 1  = value 1     \"  ,     \" key 2     =  \\  \" value 2  \\  \"  \"     }  ;", "Properties   result    =     . splitArrayElementsIntoProperties ( input ,     \"  =  \"  ,     \"  \\  \"  \"  )  ;", "assertEquals (  \" value 1  \"  ,    result . getProperty (  \" key 1  \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    result . getProperty (  \" key 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSplitArrayElementsIntoPropertiesAndDeletedChars"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =     \" fOo \"  ;", "assertTrue (  . startsWithIgnoreCase (  \" foo \"  ,    prefix )  )  ;", "assertTrue (  . startsWithIgnoreCase (  \" Foo \"  ,    prefix )  )  ;", "assertTrue (  . startsWithIgnoreCase (  \" foobar \"  ,    prefix )  )  ;", "assertTrue (  . startsWithIgnoreCase (  \" foobarbar \"  ,    prefix )  )  ;", "assertTrue (  . startsWithIgnoreCase (  \" Foobar \"  ,    prefix )  )  ;", "assertTrue (  . startsWithIgnoreCase (  \" FoobarBar \"  ,    prefix )  )  ;", "assertTrue (  . startsWithIgnoreCase (  \" foObar \"  ,    prefix )  )  ;", "assertTrue (  . startsWithIgnoreCase (  \" FOObar \"  ,    prefix )  )  ;", "assertTrue (  . startsWithIgnoreCase (  \" fOobar \"  ,    prefix )  )  ;", "assertFalse (  . startsWithIgnoreCase ( null ,    prefix )  )  ;", "assertFalse (  . startsWithIgnoreCase (  \" fOobar \"  ,    null )  )  ;", "assertFalse (  . startsWithIgnoreCase (  \" b \"  ,    prefix )  )  ;", "assertFalse (  . startsWithIgnoreCase (  \" barfoo \"  ,    prefix )  )  ;", "assertFalse (  . startsWithIgnoreCase (  \" barfoobar \"  ,    prefix )  )  ;", "}", "METHOD_END"], "methodName": ["testStartsWithIgnoreCase"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  \"  ,    StringUtils . stripFilenameExtension (  \"  \"  )  )  ;", "assertEquals (  \" myfile \"  ,    StringUtils . stripFilenameExtension (  \" myfile \"  )  )  ;", "assertEquals (  \" myfile \"  ,    StringUtils . stripFilenameExtension (  \" myfile .  \"  )  )  ;", "assertEquals (  \" myfile \"  ,    StringUtils . stripFilenameExtension (  \" myfile . txt \"  )  )  ;", "assertEquals (  \" mypath / myfile \"  ,    StringUtils . stripFilenameExtension (  \" mypath / myfile \"  )  )  ;", "assertEquals (  \" mypath / myfile \"  ,    StringUtils . stripFilenameExtension (  \" mypath / myfile .  \"  )  )  ;", "assertEquals (  \" mypath / myfile \"  ,    StringUtils . stripFilenameExtension (  \" mypath / myfile . txt \"  )  )  ;", "assertEquals (  \"  / home / user /  . m 2  / settings / myfile \"  ,    StringUtils . stripFilenameExtension (  \"  / home / user /  . m 2  / settings / myfile \"  )  )  ;", "assertEquals (  \"  / home / user /  . m 2  / settings / myfile \"  ,    StringUtils . stripFilenameExtension (  \"  / home / user /  . m 2  / settings / myfile .  \"  )  )  ;", "assertEquals (  \"  / home / user /  . m 2  / settings / myfile \"  ,    StringUtils . stripFilenameExtension (  \"  / home / user /  . m 2  / settings / myfile . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testStripFilenameExtension"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( StringUtils . substringMatch (  \" foo \"  ,     0  ,     \" foo \"  )  )  ;", "assertTrue ( StringUtils . substringMatch (  \" foo \"  ,     1  ,     \" oo \"  )  )  ;", "assertTrue ( StringUtils . substringMatch (  \" foo \"  ,     2  ,     \" o \"  )  )  ;", "assertFalse ( StringUtils . substringMatch (  \" foo \"  ,     0  ,     \" fOo \"  )  )  ;", "assertFalse ( StringUtils . substringMatch (  \" foo \"  ,     1  ,     \" fOo \"  )  )  ;", "assertFalse ( StringUtils . substringMatch (  \" foo \"  ,     2  ,     \" fOo \"  )  )  ;", "assertFalse ( StringUtils . substringMatch (  \" foo \"  ,     3  ,     \" fOo \"  )  )  ;", "assertFalse ( StringUtils . substringMatch (  \" foo \"  ,     1  ,     \" Oo \"  )  )  ;", "assertFalse ( StringUtils . substringMatch (  \" foo \"  ,     2  ,     \" Oo \"  )  )  ;", "assertFalse ( StringUtils . substringMatch (  \" foo \"  ,     3  ,     \" Oo \"  )  )  ;", "assertFalse ( StringUtils . substringMatch (  \" foo \"  ,     2  ,     \" O \"  )  )  ;", "assertFalse ( StringUtils . substringMatch (  \" foo \"  ,     3  ,     \" O \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSubstringMatch"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . tokenizeToStringArray (  \" a , b    ,     , c \"  ,     \"  ,  \"  )  ;", "assertEquals (  3  ,    sa . length )  ;", "assertTrue (  \" components   are   correct \"  ,     (  (  ( sa [  0  ]  . equals (  \" a \"  )  )     &  &     ( sa [  1  ]  . equals (  \" b \"  )  )  )     &  &     ( sa [  2  ]  . equals (  \" c \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTokenizeToStringArray"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . tokenizeToStringArray (  \" a , b    ,     , c \"  ,     \"  ,  \"  ,    true ,    false )  ;", "assertEquals (  4  ,    sa . length )  ;", "assertTrue (  \" components   are   correct \"  ,     (  (  (  ( sa [  0  ]  . equals (  \" a \"  )  )     &  &     ( sa [  1  ]  . equals (  \" b \"  )  )  )     &  &     ( sa [  2  ]  . equals (  \"  \"  )  )  )     &  &     ( sa [  3  ]  . equals (  \" c \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTokenizeToStringArrayWithNotIgnoreEmptyTokens"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sa    =    StringUtils . tokenizeToStringArray (  \" a , b    , c \"  ,     \"  ,  \"  ,    false ,    true )  ;", "assertEquals (  3  ,    sa . length )  ;", "assertTrue (  \" components   are   correct \"  ,     (  (  ( sa [  0  ]  . equals (  \" a \"  )  )     &  &     ( sa [  1  ]  . equals (  \" b    \"  )  )  )     &  &     ( sa [  2  ]  . equals (  \" c \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTokenizeToStringArrayWithNotTrimTokens"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  \"  ,    StringUtils . trimAllWhitespace (  \"  \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimAllWhitespace (  \"     \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimAllWhitespace (  \"  \\ t \"  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimAllWhitespace (  \"    a \"  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimAllWhitespace (  \" a    \"  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimAllWhitespace (  \"    a    \"  )  )  ;", "assertEquals (  \" ab \"  ,    StringUtils . trimAllWhitespace (  \"    a   b    \"  )  )  ;", "assertEquals (  \" abc \"  ,    StringUtils . trimAllWhitespace (  \"    a   b      c    \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testTrimAllWhitespace"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    StringUtils . trimLeadingCharacter ( null ,     '     '  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimLeadingCharacter (  \"  \"  ,     '     '  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimLeadingCharacter (  \"     \"  ,     '     '  )  )  ;", "assertEquals (  \"  \\ t \"  ,    StringUtils . trimLeadingCharacter (  \"  \\ t \"  ,     '     '  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimLeadingCharacter (  \"    a \"  ,     '     '  )  )  ;", "assertEquals (  \" a    \"  ,    StringUtils . trimLeadingCharacter (  \" a    \"  ,     '     '  )  )  ;", "assertEquals (  \" a    \"  ,    StringUtils . trimLeadingCharacter (  \"    a    \"  ,     '     '  )  )  ;", "assertEquals (  \" a   b    \"  ,    StringUtils . trimLeadingCharacter (  \"    a   b    \"  ,     '     '  )  )  ;", "assertEquals (  \" a   b      c    \"  ,    StringUtils . trimLeadingCharacter (  \"    a   b      c    \"  ,     '     '  )  )  ;", "}", "METHOD_END"], "methodName": ["testTrimLeadingCharacter"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    StringUtils . trimLeadingWhitespace ( null )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimLeadingWhitespace (  \"  \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimLeadingWhitespace (  \"     \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimLeadingWhitespace (  \"  \\ t \"  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimLeadingWhitespace (  \"    a \"  )  )  ;", "assertEquals (  \" a    \"  ,    StringUtils . trimLeadingWhitespace (  \" a    \"  )  )  ;", "assertEquals (  \" a    \"  ,    StringUtils . trimLeadingWhitespace (  \"    a    \"  )  )  ;", "assertEquals (  \" a   b    \"  ,    StringUtils . trimLeadingWhitespace (  \"    a   b    \"  )  )  ;", "assertEquals (  \" a   b      c    \"  ,    StringUtils . trimLeadingWhitespace (  \"    a   b      c    \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testTrimLeadingWhitespace"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    StringUtils . trimTrailingCharacter ( null ,     '     '  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimTrailingCharacter (  \"  \"  ,     '     '  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimTrailingCharacter (  \"     \"  ,     '     '  )  )  ;", "assertEquals (  \"  \\ t \"  ,    StringUtils . trimTrailingCharacter (  \"  \\ t \"  ,     '     '  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimTrailingCharacter (  \" a    \"  ,     '     '  )  )  ;", "assertEquals (  \"    a \"  ,    StringUtils . trimTrailingCharacter (  \"    a \"  ,     '     '  )  )  ;", "assertEquals (  \"    a \"  ,    StringUtils . trimTrailingCharacter (  \"    a    \"  ,     '     '  )  )  ;", "assertEquals (  \"    a   b \"  ,    StringUtils . trimTrailingCharacter (  \"    a   b    \"  ,     '     '  )  )  ;", "assertEquals (  \"    a   b      c \"  ,    StringUtils . trimTrailingCharacter (  \"    a   b      c    \"  ,     '     '  )  )  ;", "}", "METHOD_END"], "methodName": ["testTrimTrailingCharacter"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    StringUtils . trimTrailingWhitespace ( null )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimTrailingWhitespace (  \"  \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimTrailingWhitespace (  \"     \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimTrailingWhitespace (  \"  \\ t \"  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimTrailingWhitespace (  \" a    \"  )  )  ;", "assertEquals (  \"    a \"  ,    StringUtils . trimTrailingWhitespace (  \"    a \"  )  )  ;", "assertEquals (  \"    a \"  ,    StringUtils . trimTrailingWhitespace (  \"    a    \"  )  )  ;", "assertEquals (  \"    a   b \"  ,    StringUtils . trimTrailingWhitespace (  \"    a   b    \"  )  )  ;", "assertEquals (  \"    a   b      c \"  ,    StringUtils . trimTrailingWhitespace (  \"    a   b      c    \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testTrimTrailingWhitespace"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( null ,    StringUtils . trimWhitespace ( null )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimWhitespace (  \"  \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimWhitespace (  \"     \"  )  )  ;", "assertEquals (  \"  \"  ,    StringUtils . trimWhitespace (  \"  \\ t \"  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimWhitespace (  \"    a \"  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimWhitespace (  \" a    \"  )  )  ;", "assertEquals (  \" a \"  ,    StringUtils . trimWhitespace (  \"    a    \"  )  )  ;", "assertEquals (  \" a   b \"  ,    StringUtils . trimWhitespace (  \"    a   b    \"  )  )  ;", "assertEquals (  \" a   b      c \"  ,    StringUtils . trimWhitespace (  \"    a   b      c    \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testTrimWhitespace"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   capitalized    =     \" I   am   capitalized \"  ;", "assertEquals (  \" i   am   capitalized \"  ,     . uncapitalize ( capitalized )  )  ;", "}", "METHOD_END"], "methodName": ["testUncapitalize"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   qualified    =     \" i . am . not . unqualified \"  ;", "assertEquals (  \" unqualified \"  ,     . unqualify ( qualified )  )  ;", "}", "METHOD_END"], "methodName": ["testUnqualify"], "fileName": "org.springframework.util.StringUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   SystemPropertyUtils . resolvePlaceholders ( text ,    false )  ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholders"], "fileName": "org.springframework.util.SystemPropertyUtils"}, {"methodBody": ["METHOD_START", "{", "PropertyPlaceholderHelper   helper    =     ( ignoreUnresolvablePlaceholders )     ?    SystemPropertyUtils . nonStrictHelper    :    SystemPropertyUtils . strictHelper ;", "return   helper . replacePlaceholders ( text ,    new   SystemPropertyUtils . SystemPropertyPlaceholderResolver ( text )  )  ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholders"], "fileName": "org.springframework.util.SystemPropertyUtils"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" test . prop \"  ,     \" foo =  $  { bar }  \"  )  ;", "System . setProperty (  \" bar \"  ,     \" baz \"  )  ;", "try    {", "String   resolved    =     . resolvePlaceholders (  \"  $  { test . prop }  \"  )  ;", "assertEquals (  \" foo = baz \"  ,    resolved )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" test . prop \"  )  ;", "System . getProperties (  )  . remove (  \" bar \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRecursiveFromSystemProperty"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    env    =    System . getenv (  )  ;", "if    ( env . containsKey (  \" PATH \"  )  )     {", "String   text    =     \"  $  { PATH }  \"  ;", "assertEquals ( env . get (  \" PATH \"  )  ,     . resolvePlaceholders ( text )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testReplaceFromEnv"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" test . prop \"  ,     \" bar \"  )  ;", "try    {", "String   resolved    =     . resolvePlaceholders (  \"  $  { test . prop }  \"  )  ;", "assertEquals (  \" bar \"  ,    resolved )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" test . prop \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testReplaceFromSystemProperty"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" test . prop \"  ,     \" bar \"  )  ;", "try    {", "String   resolved    =     . resolvePlaceholders (  \"  $  { test . prop : foo }  \"  )  ;", "assertEquals (  \" bar \"  ,    resolved )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" test . prop \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testReplaceFromSystemPropertyWithDefault"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" test . prop \"  ,     \" bar \"  )  ;", "try    {", "String   resolved    =     . resolvePlaceholders (  \"  $  { test . prop : Y #  { foo . bar } X }  \"  )  ;", "assertEquals (  \" bar \"  ,    resolved )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" test . prop \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testReplaceFromSystemPropertyWithExpressionContainingDefault"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" test . prop \"  ,     \" bar \"  )  ;", "try    {", "String   resolved    =     . resolvePlaceholders (  \"  $  { test . prop :  #  { foo . bar }  }  \"  )  ;", "assertEquals (  \" bar \"  ,    resolved )  ;", "}    finally    {", "System . getProperties (  )  . remove (  \" test . prop \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testReplaceFromSystemPropertyWithExpressionDefault"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   resolved    =    SystemPropertyUtils . resolvePlaceholders (  \"  $  { test . prop : foo }  \"  )  ;", "assertEquals (  \" foo \"  ,    resolved )  ;", "}", "METHOD_END"], "methodName": ["testReplaceWithDefault"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   resolved    =    SystemPropertyUtils . resolvePlaceholders (  \"  $  { test . prop :  }  \"  )  ;", "assertEquals (  \"  \"  ,    resolved )  ;", "}", "METHOD_END"], "methodName": ["testReplaceWithEmptyDefault"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   resolved    =    SystemPropertyUtils . resolvePlaceholders (  \"  $  { test . prop : Y #  { foo . bar } X }  \"  )  ;", "assertEquals (  \" Y #  { foo . bar } X \"  ,    resolved )  ;", "}", "METHOD_END"], "methodName": ["testReplaceWithExpressionContainingDefault"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   resolved    =    SystemPropertyUtils . resolvePlaceholders (  \"  $  { test . prop :  #  { foo . bar }  }  \"  )  ;", "assertEquals (  \"  #  { foo . bar }  \"  ,    resolved )  ;", "}", "METHOD_END"], "methodName": ["testReplaceWithExpressionDefault"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   resolved    =    SystemPropertyUtils . resolvePlaceholders (  \"  $  { test . prop }  \"  )  ;", "assertEquals (  \"  \"  ,    resolved )  ;", "}", "METHOD_END"], "methodName": ["testReplaceWithNoDefault"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   resolved    =    SystemPropertyUtils . resolvePlaceholders (  \"  $  { test . prop }  \"  ,    true )  ;", "assertEquals (  \"  $  { test . prop }  \"  ,    resolved )  ;", "}", "METHOD_END"], "methodName": ["testReplaceWithNoDefaultIgnored"], "fileName": "org.springframework.util.SystemPropertyUtilsTests"}, {"methodBody": ["METHOD_START", "{", "if    ( lhsType . equals ( rhsType )  )     {", "return   true ;", "}", "Type [  ]    lhsTypeArguments    =    lhsType . getActualTypeArguments (  )  ;", "Type [  ]    rhsTypeArguments    =    rhsType . getActualTypeArguments (  )  ;", "if    (  ( lhsTypeArguments . length )     !  =     ( rhsTypeArguments . length )  )     {", "return   false ;", "}", "for    ( int   size    =    lhsTypeArguments . length ,    i    =     0  ;    i    <    size ;     +  + i )     {", "Type   lhsArg    =    lhsTypeArguments [ i ]  ;", "Type   rhsArg    =    rhsTypeArguments [ i ]  ;", "if    (  (  !  ( lhsArg . equals ( rhsArg )  )  )     &  &     (  !  (  ( lhsArg   instanceof   WildcardType )     &  &     (  . isAssignable (  (  ( WildcardType )     ( lhsArg )  )  ,    rhsArg )  )  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isAssignable"], "fileName": "org.springframework.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lhsType ,     \" Left - hand   side   type   must   not   be   null \"  )  ;", "Assert . notNull ( rhsType ,     \" Right - hand   side   type   must   not   be   null \"  )  ;", "if    (  ( lhsType . equals ( rhsType )  )     |  |     (  ( Object . class )     =  =    lhsType )  )     {", "return   true ;", "}", "if    ( lhsType   instanceof   Class )     {", "Class <  ?  >    lhsClass    =     (  ( Class <  ?  >  )     ( lhsType )  )  ;", "if    ( rhsType   instanceof   Class )     {", "return   ClassUtils . isAssignable ( lhsClass ,     (  ( Class <  ?  >  )     ( rhsType )  )  )  ;", "}", "if    ( rhsType   instanceof   ParameterizedType )     {", "Type   rhsRaw    =     (  ( ParameterizedType )     ( rhsType )  )  . getRawType (  )  ;", "if    ( rhsRaw   instanceof   Class )     {", "return   ClassUtils . isAssignable ( lhsClass ,     (  ( Class <  ?  >  )     ( rhsRaw )  )  )  ;", "}", "} else", "if    (  ( lhsClass . isArray (  )  )     &  &     ( rhsType   instanceof   GenericArrayType )  )     {", "Type   rhsComponent    =     (  ( GenericArrayType )     ( rhsType )  )  . getGenericComponentType (  )  ;", "return    . isAssignable ( lhsClass . getComponentType (  )  ,    rhsComponent )  ;", "}", "}", "if    ( lhsType   instanceof   ParameterizedType )     {", "if    ( rhsType   instanceof   Class )     {", "Type   lhsRaw    =     (  ( ParameterizedType )     ( lhsType )  )  . getRawType (  )  ;", "if    ( lhsRaw   instanceof   Class )     {", "return   ClassUtils . isAssignable (  (  ( Class <  ?  >  )     ( lhsRaw )  )  ,     (  ( Class <  ?  >  )     ( rhsType )  )  )  ;", "}", "} else", "if    ( rhsType   instanceof   ParameterizedType )     {", "return    . isAssignable (  (  ( ParameterizedType )     ( lhsType )  )  ,     (  ( ParameterizedType )     ( rhsType )  )  )  ;", "}", "}", "if    ( lhsType   instanceof   GenericArrayType )     {", "Type   lhsComponent    =     (  ( GenericArrayType )     ( lhsType )  )  . getGenericComponentType (  )  ;", "if    ( rhsType   instanceof   Class )     {", "Class <  ?  >    rhsClass    =     (  ( Class <  ?  >  )     ( rhsType )  )  ;", "if    ( rhsClass . isArray (  )  )     {", "return    . isAssignable ( lhsComponent ,    rhsClass . getComponentType (  )  )  ;", "}", "} else", "if    ( rhsType   instanceof   GenericArrayType )     {", "Type   rhsComponent    =     (  ( GenericArrayType )     ( rhsType )  )  . getGenericComponentType (  )  ;", "return    . isAssignable ( lhsComponent ,    rhsComponent )  ;", "}", "}", "if    ( lhsType   instanceof   WildcardType )     {", "return    . isAssignable (  (  ( WildcardType )     ( lhsType )  )  ,    rhsType )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAssignable"], "fileName": "org.springframework.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "Type [  ]    lUpperBounds    =    lhsType . getUpperBounds (  )  ;", "if    (  ( lUpperBounds . length )     =  =     0  )     {", "lUpperBounds    =    new   Type [  ]  {    Object . class    }  ;", "}", "Type [  ]    lLowerBounds    =    lhsType . getLowerBounds (  )  ;", "if    (  ( lLowerBounds . length )     =  =     0  )     {", "lLowerBounds    =    new   Type [  ]  {    null    }  ;", "}", "if    ( rhsType   instanceof   WildcardType )     {", "WildcardType   rhsWcType    =     (  ( WildcardType )     ( rhsType )  )  ;", "Type [  ]    rUpperBounds    =    rhsWcType . getUpperBounds (  )  ;", "if    (  ( rUpperBounds . length )     =  =     0  )     {", "rUpperBounds    =    new   Type [  ]  {    Object . class    }  ;", "}", "Type [  ]    rLowerBounds    =    rhsWcType . getLowerBounds (  )  ;", "if    (  ( rLowerBounds . length )     =  =     0  )     {", "rLowerBounds    =    new   Type [  ]  {    null    }  ;", "}", "for    ( Type   lBound    :    lUpperBounds )     {", "for    ( Type   rBound    :    rUpperBounds )     {", "if    (  !  (  . isAssignableBound ( lBound ,    rBound )  )  )     {", "return   false ;", "}", "}", "for    ( Type   rBound    :    rLowerBounds )     {", "if    (  !  (  . isAssignableBound ( lBound ,    rBound )  )  )     {", "return   false ;", "}", "}", "}", "for    ( Type   lBound    :    lLowerBounds )     {", "for    ( Type   rBound    :    rUpperBounds )     {", "if    (  !  (  . isAssignableBound ( rBound ,    lBound )  )  )     {", "return   false ;", "}", "}", "for    ( Type   rBound    :    rLowerBounds )     {", "if    (  !  (  . isAssignableBound ( rBound ,    lBound )  )  )     {", "return   false ;", "}", "}", "}", "} else    {", "for    ( Type   lBound    :    lUpperBounds )     {", "if    (  !  (  . isAssignableBound ( lBound ,    rhsType )  )  )     {", "return   false ;", "}", "}", "for    ( Type   lBound    :    lLowerBounds )     {", "if    (  !  (  . isAssignableBound ( rhsType ,    lBound )  )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isAssignable"], "fileName": "org.springframework.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( rhsType    =  =    null )     {", "return   true ;", "}", "if    ( lhsType    =  =    null )     {", "return   false ;", "}", "return    . isAssignable ( lhsType ,    rhsType )  ;", "}", "METHOD_END"], "methodName": ["isAssignableBound"], "fileName": "org.springframework.util.TypeUtils"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TypeUtils . isAssignable ( Object . class ,    Object . class )  )  ;", "assertTrue ( TypeUtils . isAssignable ( Object . class ,    String . class )  )  ;", "assertFalse ( TypeUtils . isAssignable ( String . class ,    Object . class )  )  ;", "assertTrue ( TypeUtils . isAssignable ( List . class ,    List . class )  )  ;", "assertTrue ( TypeUtils . isAssignable ( List . class ,    LinkedList . class )  )  ;", "assertFalse ( TypeUtils . isAssignable ( List . class ,    Collection . class )  )  ;", "assertFalse ( TypeUtils . isAssignable ( List . class ,    HashSet . class )  )  ;", "}", "METHOD_END"], "methodName": ["withClasses"], "fileName": "org.springframework.util.TypeUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Type   arrayType    =    getClass (  )  . getField (  \" array \"  )  . getGenericType (  )  ;", "Type   openArrayType    =    getClass (  )  . getField (  \" openArray \"  )  . getGenericType (  )  ;", "assertTrue (  . isAssignable ( Object . class ,    arrayType )  )  ;", "assertTrue (  . isAssignable ( Object . class ,    openArrayType )  )  ;", "assertTrue (  . isAssignable ( List [  ]  . class ,    arrayType )  )  ;", "assertTrue (  . isAssignable ( List [  ]  . class ,    openArrayType )  )  ;", "assertTrue (  . isAssignable ( arrayType ,    List [  ]  . class )  )  ;", "assertTrue (  . isAssignable ( openArrayType ,    List [  ]  . class )  )  ;", "assertTrue (  . isAssignable ( arrayType ,    arrayType )  )  ;", "assertTrue (  . isAssignable ( openArrayType ,    openArrayType )  )  ;", "assertTrue (  . isAssignable ( openArrayType ,    arrayType )  )  ;", "}", "METHOD_END"], "methodName": ["withGenericArrayTypes"], "fileName": "org.springframework.util.TypeUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Type   objectsType    =    getClass (  )  . getField (  \" objects \"  )  . getGenericType (  )  ;", "Type   openObjectsType    =    getClass (  )  . getField (  \" openObjects \"  )  . getGenericType (  )  ;", "Type   stringsType    =    getClass (  )  . getField (  \" strings \"  )  . getGenericType (  )  ;", "assertTrue (  . isAssignable ( Object . class ,    objectsType )  )  ;", "assertTrue (  . isAssignable ( Object . class ,    openObjectsType )  )  ;", "assertTrue (  . isAssignable ( Object . class ,    stringsType )  )  ;", "assertTrue (  . isAssignable ( List . class ,    objectsType )  )  ;", "assertTrue (  . isAssignable ( List . class ,    openObjectsType )  )  ;", "assertTrue (  . isAssignable ( List . class ,    stringsType )  )  ;", "assertTrue (  . isAssignable ( objectsType ,    List . class )  )  ;", "assertTrue (  . isAssignable ( openObjectsType ,    List . class )  )  ;", "assertTrue (  . isAssignable ( stringsType ,    List . class )  )  ;", "assertTrue (  . isAssignable ( objectsType ,    objectsType )  )  ;", "assertTrue (  . isAssignable ( openObjectsType ,    openObjectsType )  )  ;", "assertTrue (  . isAssignable ( stringsType ,    stringsType )  )  ;", "assertTrue (  . isAssignable ( openObjectsType ,    objectsType )  )  ;", "assertTrue (  . isAssignable ( openObjectsType ,    stringsType )  )  ;", "assertFalse (  . isAssignable ( stringsType ,    objectsType )  )  ;", "assertFalse (  . isAssignable ( objectsType ,    stringsType )  )  ;", "}", "METHOD_END"], "methodName": ["withParameterizedTypes"], "fileName": "org.springframework.util.TypeUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ParameterizedType   openObjectsType    =     (  ( ParameterizedType )     ( getClass (  )  . getField (  \" openObjects \"  )  . getGenericType (  )  )  )  ;", "ParameterizedType   openNumbersType    =     (  ( ParameterizedType )     ( getClass (  )  . getField (  \" openNumbers \"  )  . getGenericType (  )  )  )  ;", "Type   storableObjectListType    =    getClass (  )  . getField (  \" storableObjectList \"  )  . getGenericType (  )  ;", "Type   objectType    =    getClass (  )  . getField (  \" object \"  )  . getGenericType (  )  ;", "Type   numberType    =    getClass (  )  . getField (  \" number \"  )  . getGenericType (  )  ;", "Type   stringType    =    getClass (  )  . getField (  \" string \"  )  . getGenericType (  )  ;", "Type   openWildcard    =    openObjectsType . getActualTypeArguments (  )  [  0  ]  ;", "Type   openNumbersWildcard    =    openNumbersType . getActualTypeArguments (  )  [  0  ]  ;", "assertTrue (  . isAssignable ( openWildcard ,    objectType )  )  ;", "assertTrue (  . isAssignable ( openNumbersWildcard ,    numberType )  )  ;", "assertFalse (  . isAssignable ( openNumbersWildcard ,    stringType )  )  ;", "assertFalse (  . isAssignable ( storableObjectListType ,    openObjectsType )  )  ;", "}", "METHOD_END"], "methodName": ["withWildcardTypes"], "fileName": "org.springframework.util.TypeUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   data ;", "while    (  ( data    =    read (  )  )     !  =     (  -  1  )  )     {", "m . update (  (  ( byte )     ( data )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateMessageDigest"], "fileName": "org.springframework.util.UpdateMessageDigestInputStream"}, {"methodBody": ["METHOD_START", "{", "int   data ;", "int   bytesRead    =     0  ;", "while    (  ( bytesRead    <    len )     &  &     (  ( data    =    read (  )  )     !  =     (  -  1  )  )  )     {", "m . update (  (  ( byte )     ( data )  )  )  ;", "bytesRead +  +  ;", "}", "}", "METHOD_END"], "methodName": ["updateMessageDigest"], "fileName": "org.springframework.util.UpdateMessageDigestInputStream"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( multiplier    >  =     1  )  ,     (  )     -  >     (  (  \" Invalid   multiplier    '  \"     +    multiplier )     +     \"  '  .    Should   be   greater   than    \"  )     +     \" or   equal   to    1  .    A   multiplier   of    1    is   equivalent   to   a   fixed   interval .  \"  )  ;", "}", "METHOD_END"], "methodName": ["checkMultiplier"], "fileName": "org.springframework.util.backoff.ExponentialBackOff"}, {"methodBody": ["METHOD_START", "{", "return   initialInterval ;", "}", "METHOD_END"], "methodName": ["getInitialInterval"], "fileName": "org.springframework.util.backoff.ExponentialBackOff"}, {"methodBody": ["METHOD_START", "{", "return   maxElapsedTime ;", "}", "METHOD_END"], "methodName": ["getMaxElapsedTime"], "fileName": "org.springframework.util.backoff.ExponentialBackOff"}, {"methodBody": ["METHOD_START", "{", "return   maxInterval ;", "}", "METHOD_END"], "methodName": ["getMaxInterval"], "fileName": "org.springframework.util.backoff.ExponentialBackOff"}, {"methodBody": ["METHOD_START", "{", "return   multiplier ;", "}", "METHOD_END"], "methodName": ["getMultiplier"], "fileName": "org.springframework.util.backoff.ExponentialBackOff"}, {"methodBody": ["METHOD_START", "{", "this . initialInterval    =    initialInterval ;", "}", "METHOD_END"], "methodName": ["setInitialInterval"], "fileName": "org.springframework.util.backoff.ExponentialBackOff"}, {"methodBody": ["METHOD_START", "{", "this . maxElapsedTime    =    maxElapsedTime ;", "}", "METHOD_END"], "methodName": ["setMaxElapsedTime"], "fileName": "org.springframework.util.backoff.ExponentialBackOff"}, {"methodBody": ["METHOD_START", "{", "this . maxInterval    =    maxInterval ;", "}", "METHOD_END"], "methodName": ["setMaxInterval"], "fileName": "org.springframework.util.backoff.ExponentialBackOff"}, {"methodBody": ["METHOD_START", "{", "checkMultiplier ( multiplier )  ;", "this . multiplier    =    multiplier ;", "}", "METHOD_END"], "methodName": ["setMultiplier"], "fileName": "org.springframework.util.backoff.ExponentialBackOff"}, {"methodBody": ["METHOD_START", "{", "return   interval ;", "}", "METHOD_END"], "methodName": ["getInterval"], "fileName": "org.springframework.util.backoff.FixedBackOff"}, {"methodBody": ["METHOD_START", "{", "return   maxAttempts ;", "}", "METHOD_END"], "methodName": ["getMaxAttempts"], "fileName": "org.springframework.util.backoff.FixedBackOff"}, {"methodBody": ["METHOD_START", "{", "this . interval    =    interval ;", "}", "METHOD_END"], "methodName": ["setInterval"], "fileName": "org.springframework.util.backoff.FixedBackOff"}, {"methodBody": ["METHOD_START", "{", "this . maxAttempts    =    maxAttempts ;", "}", "METHOD_END"], "methodName": ["setMaxAttempts"], "fileName": "org.springframework.util.backoff.FixedBackOff"}, {"methodBody": ["METHOD_START", "{", "Comparator < Boolean >    c    =    BooleanComparator . TRUE _ HIGH ;", "assertThat ( c . compare ( true ,    false )  ,    is (  1  )  )  ;", "assertThat ( c . compare ( Boolean . TRUE ,    Boolean . TRUE )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareFromTrueHigh"], "fileName": "org.springframework.util.comparator.BooleanComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < Boolean >    c    =    BooleanComparator . TRUE _ LOW ;", "assertThat ( c . compare ( true ,    false )  ,    is (  (  -  1  )  )  )  ;", "assertThat ( c . compare ( Boolean . TRUE ,    Boolean . TRUE )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareFromTrueLow"], "fileName": "org.springframework.util.comparator.BooleanComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < Boolean >    c    =    new   BooleanComparator ( false )  ;", "assertThat ( c . compare ( true ,    false )  ,    is (  1  )  )  ;", "assertThat ( c . compare ( Boolean . TRUE ,    Boolean . TRUE )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareWithTrueHigh"], "fileName": "org.springframework.util.comparator.BooleanComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < Boolean >    c    =    new   BooleanComparator ( true )  ;", "assertThat ( c . compare ( true ,    false )  ,    is (  (  -  1  )  )  )  ;", "assertThat ( c . compare ( Boolean . TRUE ,    Boolean . TRUE )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareWithTrueLow"], "fileName": "org.springframework.util.comparator.BooleanComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator   c    =    new   ComparableComparator (  )  ;", "Object   o 1     =    new   Object (  )  ;", "Object   o 2     =    new   Object (  )  ;", "thrown . expect ( ClassCastException . class )  ;", "c . compare ( o 1  ,    o 2  )  ;", "}", "METHOD_END"], "methodName": ["shouldNeedComparable"], "fileName": "org.springframework.util.comparator.ComparableComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < String >    c    =    new   ComparableComparator <  >  (  )  ;", "String   s 1     =     \" abc \"  ;", "String   s 2     =     \" cde \"  ;", "assertTrue (  (  ( c . compare ( s 1  ,    s 2  )  )     <     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testComparableComparator"], "fileName": "org.springframework.util.comparator.ComparableComparatorTests"}, {"methodBody": ["METHOD_START", "{", "return   ComparableComparator . INSTANCE ;", "}", "METHOD_END"], "methodName": ["comparable"], "fileName": "org.springframework.util.comparator.Comparators"}, {"methodBody": ["METHOD_START", "{", "return   NullSafeComparator . NULLS _ HIGH ;", "}", "METHOD_END"], "methodName": ["nullsHigh"], "fileName": "org.springframework.util.comparator.Comparators"}, {"methodBody": ["METHOD_START", "{", "return   new   NullSafeComparator <  >  ( comparator ,    false )  ;", "}", "METHOD_END"], "methodName": ["nullsHigh"], "fileName": "org.springframework.util.comparator.Comparators"}, {"methodBody": ["METHOD_START", "{", "return   NullSafeComparator . NULLS _ LOW ;", "}", "METHOD_END"], "methodName": ["nullsLow"], "fileName": "org.springframework.util.comparator.Comparators"}, {"methodBody": ["METHOD_START", "{", "return   new   NullSafeComparator <  >  ( comparator ,    false )  ;", "}", "METHOD_END"], "methodName": ["nullsLow"], "fileName": "org.springframework.util.comparator.Comparators"}, {"methodBody": ["METHOD_START", "{", "if      instanceof   InvertibleComparator )     {", "thiss . add (  (  ( InvertibleComparator )     )  )  )  ;", "} else    {", "thiss . add ( new   InvertibleComparator )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addComparator"], "fileName": "org.springframework.util.comparator.CompoundComparator"}, {"methodBody": ["METHOD_START", "{", "this . comparators . add ( new   InvertibleComparator ( comparator ,    ascending )  )  ;", "}", "METHOD_END"], "methodName": ["addComparator"], "fileName": "org.springframework.util.comparator.CompoundComparator"}, {"methodBody": ["METHOD_START", "{", "return   this . comparators . size (  )  ;", "}", "METHOD_END"], "methodName": ["getComparatorCount"], "fileName": "org.springframework.util.comparator.CompoundComparator"}, {"methodBody": ["METHOD_START", "{", "for    ( InvertibleComparator   comparator    :    this . comparators )     {", "comparator . invertOrder (  )  ;", "}", "}", "METHOD_END"], "methodName": ["invertOrder"], "fileName": "org.springframework.util.comparator.CompoundComparator"}, {"methodBody": ["METHOD_START", "{", "this . comparators . get ( index )  . invertOrder (  )  ;", "}", "METHOD_END"], "methodName": ["invertOrder"], "fileName": "org.springframework.util.comparator.CompoundComparator"}, {"methodBody": ["METHOD_START", "{", "this . comparators . get ( index )  . setAscending ( true )  ;", "}", "METHOD_END"], "methodName": ["setAscendingOrder"], "fileName": "org.springframework.util.comparator.CompoundComparator"}, {"methodBody": ["METHOD_START", "{", "if      instanceof   InvertibleComparator )     {", "thiss . set ( index ,     (  ( InvertibleComparator )     )  )  )  ;", "} else    {", "thiss . set ( index ,    new   InvertibleComparator )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setComparator"], "fileName": "org.springframework.util.comparator.CompoundComparator"}, {"methodBody": ["METHOD_START", "{", "this . comparators . set ( index ,    new   InvertibleComparator <  >  ( comparator ,    ascending )  )  ;", "}", "METHOD_END"], "methodName": ["setComparator"], "fileName": "org.springframework.util.comparator.CompoundComparator"}, {"methodBody": ["METHOD_START", "{", "this . comparators . get ( index )  . setAscending ( false )  ;", "}", "METHOD_END"], "methodName": ["setDescendingOrder"], "fileName": "org.springframework.util.comparator.CompoundComparator"}, {"methodBody": ["METHOD_START", "{", "Comparator < String >    c    =    new   CompoundComparator <  >  (  )  ;", "thrown . expect ( IllegalStateException . class )  ;", "c . compare (  \" foo \"  ,     \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["shouldNeedAtLeastOneComparator"], "fileName": "org.springframework.util.comparator.CompoundComparatorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( object    !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( this . instanceOrder . length )  ;    i +  +  )     {", "if    ( this . instanceOrder [ i ]  . is ( object )  )     {", "return   i ;", "}", "}", "}", "return   this . instanceOrder . length ;", "}", "METHOD_END"], "methodName": ["getOrder"], "fileName": "org.springframework.util.comparator.InstanceComparator"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    comparator    =    new   InstanceComparator <  >  ( InstanceComparatorTests . C 1  . class ,    InstanceComparatorTests . C 2  . class )  ;", "assertThat ( comparator . compare ( c 1  ,    c 1  )  ,    is (  0  )  )  ;", "assertThat ( comparator . compare ( c 1  ,    c 2  )  ,    is (  (  -  1  )  )  )  ;", "assertThat ( comparator . compare ( c 2  ,    c 1  )  ,    is (  1  )  )  ;", "assertThat ( comparator . compare ( c 2  ,    c 3  )  ,    is (  (  -  1  )  )  )  ;", "assertThat ( comparator . compare ( c 2  ,    c 4  )  ,    is (  (  -  1  )  )  )  ;", "assertThat ( comparator . compare ( c 3  ,    c 4  )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareClasses"], "fileName": "org.springframework.util.comparator.InstanceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    comparator    =    new   InstanceComparator <  >  ( InstanceComparatorTests . I 1  . class ,    InstanceComparatorTests . I 2  . class )  ;", "assertThat ( comparator . compare ( c 1  ,    c 1  )  ,    is (  0  )  )  ;", "assertThat ( comparator . compare ( c 1  ,    c 2  )  ,    is (  0  )  )  ;", "assertThat ( comparator . compare ( c 2  ,    c 1  )  ,    is (  0  )  )  ;", "assertThat ( comparator . compare ( c 1  ,    c 3  )  ,    is (  (  -  1  )  )  )  ;", "assertThat ( comparator . compare ( c 3  ,    c 1  )  ,    is (  1  )  )  ;", "assertThat ( comparator . compare ( c 3  ,    c 4  )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareInterfaces"], "fileName": "org.springframework.util.comparator.InstanceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    comparator    =    new   InstanceComparator <  >  ( InstanceComparatorTests . I 1  . class ,    InstanceComparatorTests . C 3  . class )  ;", "assertThat ( comparator . compare ( c 1  ,    c 1  )  ,    is (  0  )  )  ;", "assertThat ( comparator . compare ( c 3  ,    c 4  )  ,    is (  (  -  1  )  )  )  ;", "assertThat ( comparator . compare ( c 3  ,    null )  ,    is (  (  -  1  )  )  )  ;", "assertThat ( comparator . compare ( c 4  ,    null )  ,    is (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareMix"], "fileName": "org.springframework.util.comparator.InstanceComparatorTests"}, {"methodBody": ["METHOD_START", "{", "this . ascending    =     !  ( this . ascending )  ;", "}", "METHOD_END"], "methodName": ["invertOrder"], "fileName": "org.springframework.util.comparator.InvertibleComparator"}, {"methodBody": ["METHOD_START", "{", "return   this . ascending ;", "}", "METHOD_END"], "methodName": ["isAscending"], "fileName": "org.springframework.util.comparator.InvertibleComparator"}, {"methodBody": ["METHOD_START", "{", "this . ascending    =    ascending ;", "}", "METHOD_END"], "methodName": ["setAscending"], "fileName": "org.springframework.util.comparator.InvertibleComparator"}, {"methodBody": ["METHOD_START", "{", "InvertibleComparator < Integer >    invertibleComparator    =    new   InvertibleComparator <  >  ( comparator ,    true )  ;", "assertThat ( invertibleComparator . compare (  1  ,     2  )  ,    is (  (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareAscending"], "fileName": "org.springframework.util.comparator.InvertibleComparatorTests"}, {"methodBody": ["METHOD_START", "{", "InvertibleComparator < Integer >    invertibleComparator    =    new   InvertibleComparator <  >  ( comparator ,    false )  ;", "assertThat ( invertibleComparator . compare (  1  ,     2  )  ,    is (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareDescending"], "fileName": "org.springframework.util.comparator.InvertibleComparatorTests"}, {"methodBody": ["METHOD_START", "{", "InvertibleComparator < Integer >    invertibleComparator    =    new   InvertibleComparator <  >  ( comparator )  ;", "assertThat ( invertibleComparator . isAscending (  )  ,    is ( true )  )  ;", "assertThat ( invertibleComparator . compare (  1  ,     2  )  ,    is (  (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDefaultToAscending"], "fileName": "org.springframework.util.comparator.InvertibleComparatorTests"}, {"methodBody": ["METHOD_START", "{", "InvertibleComparator < Integer >    invertibleComparator    =    new   InvertibleComparator <  >  ( comparator )  ;", "assertThat ( invertibleComparator . isAscending (  )  ,    is ( true )  )  ;", "assertThat ( invertibleComparator . compare (  1  ,     2  )  ,    is (  (  -  1  )  )  )  ;", "invertibleComparator . invertOrder (  )  ;", "assertThat ( invertibleComparator . isAscending (  )  ,    is ( false )  )  ;", "assertThat ( invertibleComparator . compare (  1  ,     2  )  ,    is (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldInvert"], "fileName": "org.springframework.util.comparator.InvertibleComparatorTests"}, {"methodBody": ["METHOD_START", "{", "new   InvertibleComparator <  >  ( null )  ;", "}", "METHOD_END"], "methodName": ["shouldNeedComparator"], "fileName": "org.springframework.util.comparator.InvertibleComparatorTests"}, {"methodBody": ["METHOD_START", "{", "new   InvertibleComparator <  >  ( null ,    true )  ;", "}", "METHOD_END"], "methodName": ["shouldNeedComparatorWithAscending"], "fileName": "org.springframework.util.comparator.InvertibleComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < String >    c    =    NullSafeComparator . NULLS _ HIGH ;", "assertTrue (  (  ( c . compare ( null ,     \" boo \"  )  )     >     0  )  )  ;", "assertTrue (  (  ( c . compare ( null ,    null )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareWithNullsHigh"], "fileName": "org.springframework.util.comparator.NullSafeComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < String >    c    =    NullSafeComparator . NULLS _ LOW ;", "assertTrue (  (  ( c . compare ( null ,     \" boo \"  )  )     <     0  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldCompareWithNullsLow"], "fileName": "org.springframework.util.comparator.NullSafeComparatorTests"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . mutex )     {", "switch    ( this . state )     {", "case   SUCCESS    :", "return    (  ( T )     ( this . result )  )  ;", "case   FAILURE    :", "Assert . state (  (  ( this . result )    instanceof   ExecutionException )  ,     \" Failure   without   exception \"  )  ;", "throw    (  ( ExecutionException )     ( this . result )  )  ;", "case   NEW    :", "try    {", "T   adapted    =    adapt ( adapteeResult )  ;", "this . result    =    adapted ;", "this . state    =     . State . SUCCESS ;", "return   adapted ;", "}    catch    ( ExecutionException   ex )     {", "this . result    =    ex ;", "this . state    =     . State . FAILURE ;", "throw   ex ;", "}    catch    ( Throwable   ex )     {", "ExecutionException   execEx    =    new   ExecutionException ( ex )  ;", "this . result    =    execEx ;", "this . state    =     . State . FAILURE ;", "throw   execEx ;", "}", "default    :", "throw   new   IllegalStateException (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["adaptInternal"], "fileName": "org.springframework.util.concurrent.FutureAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . adaptee ;", "}", "METHOD_END"], "methodName": ["getAdaptee"], "fileName": "org.springframework.util.concurrent.FutureAdapter"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . cancel ( true )  )  . willReturn ( true )  ;", "boolean   result    =    a . cancel ( true )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.springframework.util.concurrent.FutureAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . get (  )  )  . willReturn (  4  2  )  ;", "String   result    =    a . get (  )  ;", "assertEquals (  \"  4  2  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.util.concurrent.FutureAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . get (  1  ,    TimeUnit . SECONDS )  )  . willReturn (  4  2  )  ;", "String   result    =    a . get (  1  ,    TimeUnit . SECONDS )  ;", "assertEquals (  \"  4  2  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["getTimeOut"], "fileName": "org.springframework.util.concurrent.FutureAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . isCancelled (  )  )  . willReturn ( true )  ;", "boolean   result    =    a . isCancelled (  )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["isCancelled"], "fileName": "org.springframework.util.concurrent.FutureAdapterTests"}, {"methodBody": ["METHOD_START", "{", "given ( adaptee . isDone (  )  )  . willReturn ( true )  ;", "boolean   result    =    a . isDone (  )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["isDone"], "fileName": "org.springframework.util.concurrent.FutureAdapterTests"}, {"methodBody": ["METHOD_START", "{", "adaptee    =    mock ( Future . class )  ;", "adapter    =    new    < String ,    Integer >  ( adaptee )     {", "@ Override", "protected   String   adapt ( Integer   adapteeResult )    throws   ExecutionException    {", "return   adapteeResult . toString (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.util.concurrent.FutureAdapterTests"}, {"methodBody": ["METHOD_START", "{", "CompletableFuture < T >    completable    =    new   DelegatingCompletableFuture <  >  ( this )  ;", "addCallback ( completable :  : complete ,    completable :  : completeExceptionally )  ;", "return   completable ;", "}", "METHOD_END"], "methodName": ["completable"], "fileName": "org.springframework.util.concurrent.ListenableFuture"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( callback ,     \"  ' callback '    must   not   be   null \"  )  ;", "synchronized ( this . mutex )     {", "switch    ( this . state )     {", "case   NEW    :", "this . successCallbacks . add ( callback )  ;", "this . fails . add ( callback )  ;", "break ;", "case   SUCCESS    :", "notifySuccess ( callback )  ;", "break ;", "case   FAILURE    :", "notifyFailure ( callback )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["addCallback"], "fileName": "org.springframework.util.concurrent.ListenableFutureCallbackRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( callback ,     \"  ' callback '    must   not   be   null \"  )  ;", "synchronized ( this . mutex )     {", "switch    ( this . state )     {", "case   NEW    :", "this . fails . add ( callback )  ;", "break ;", "case   FAILURE    :", "notifyFailure ( callback )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["addFailureCallback"], "fileName": "org.springframework.util.concurrent.ListenableFutureCallbackRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( callback ,     \"  ' callback '    must   not   be   null \"  )  ;", "synchronized ( this . mutex )     {", "switch    ( this . state )     {", "case   NEW    :", "this . successs . add ( callback )  ;", "break ;", "case   SUCCESS    :", "notifySuccess ( callback )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["addSuccessCallback"], "fileName": "org.springframework.util.concurrent.ListenableFutureCallbackRegistry"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . mutex )     {", "this . state    =     . State . FAILURE ;", "this . result    =    ex ;", "FailureCallback   callback ;", "while    (  ( callback    =    this . failureCallbacks . poll (  )  )     !  =    null )     {", "notifyFailure ( callback )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["failure"], "fileName": "org.springframework.util.concurrent.ListenableFutureCallbackRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . result )    instanceof   Throwable )  ,     \" No   Throwable   result   for   failure   state \"  )  ;", "try    {", "c . onFailure (  (  ( Throwable )     ( this . result )  )  )  ;", "}    catch    ( Throwable   ex )     {", "}", "}", "METHOD_END"], "methodName": ["notifyFailure"], "fileName": "org.springframework.util.concurrent.ListenableFutureCallbackRegistry"}, {"methodBody": ["METHOD_START", "{", "try    {", "c . onSuccess (  (  ( T )     ( this . result )  )  )  ;", "}    catch    ( Throwable   ex )     {", "}", "}", "METHOD_END"], "methodName": ["notifySuccess"], "fileName": "org.springframework.util.concurrent.ListenableFutureCallbackRegistry"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . mutex )     {", "this . state    =     . State . SUCCESS ;", "this . result    =    result ;", "SuccessCallback <  ?    super   T >    callback ;", "while    (  ( callback    =    this . successCallbacks . poll (  )  )     !  =    null )     {", "notifySuccess ( callback )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["success"], "fileName": "org.springframework.util.concurrent.ListenableFutureCallbackRegistry"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =     \" Hello   World \"  ;", "Callable < String >    callable    =     (  )     -  >     {", "throw   new   IOException ( s )  ;", "}  ;", "< String >    task    =    new    <  >  ( callable )  ;", "task . addCallback ( new   ListenableFutureCallback < String >  (  )     {", "@ Override", "public   void   onSuccess ( String   result )     {", "fail (  \" onSuccess   not   expected \"  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "assertEquals ( s ,    ex . getMessage (  )  )  ;", "}", "}  )  ;", "task . run (  )  ;", "try    {", "task . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertSame ( s ,    ex . getCause (  )  . getMessage (  )  )  ;", "}", "try    {", "task . completable (  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertSame ( s ,    ex . getCause (  )  . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["failure"], "fileName": "org.springframework.util.concurrent.ListenableFutureTaskTests"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =     \" Hello   World \"  ;", "IOException   ex    =    new   IOException ( s )  ;", "Callable < String >    callable    =     (  )     -  >     {", "throw   ex ;", "}  ;", "SuccessCallback < String >    successCallback    =    mock ( SuccessCallback . class )  ;", "FailureCallback   failureCallback    =    mock ( FailureCallback . class )  ;", "< String >    task    =    new    <  >  ( callable )  ;", "task . addCallback ( successCallback ,    failureCallback )  ;", "task . run (  )  ;", "verify ( failureCallback )  . onFailure ( ex )  ;", "verifyZeroInteractions ( successCallback )  ;", "try    {", "task . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex 2  )     {", "assertSame ( s ,    ex 2  . getCause (  )  . getMessage (  )  )  ;", "}", "try    {", "task . completable (  )  . get (  )  ;", "fail (  \" Should   have   thrown   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex 2  )     {", "assertSame ( s ,    ex 2  . getCause (  )  . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["failureWithLambdas"], "fileName": "org.springframework.util.concurrent.ListenableFutureTaskTests"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =     \" Hello   World \"  ;", "Callable < String >    callable    =     (  )     -  >    s ;", "< String >    task    =    new    <  >  ( callable )  ;", "task . addCallback ( new   ListenableFutureCallback < String >  (  )     {", "@ Override", "public   void   onSuccess ( String   result )     {", "assertEquals ( s ,    result )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}  )  ;", "task . run (  )  ;", "assertSame ( s ,    task . get (  )  )  ;", "assertSame ( s ,    task . completable (  )  . get (  )  )  ;", "task . completable (  )  . thenAccept (  (    v )     -  >    assertSame ( s ,    v )  )  ;", "}", "METHOD_END"], "methodName": ["success"], "fileName": "org.springframework.util.concurrent.ListenableFutureTaskTests"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =     \" Hello   World \"  ;", "Callable < String >    callable    =     (  )     -  >    s ;", "SuccessCallback < String >    successCallback    =    mock ( SuccessCallback . class )  ;", "FailureCallback   failureCallback    =    mock ( FailureCallback . class )  ;", "< String >    task    =    new    <  >  ( callable )  ;", "task . addCallback ( successCallback ,    failureCallback )  ;", "task . run (  )  ;", "verify ( successCallback )  . onSuccess ( s )  ;", "verifyZeroInteractions ( failureCallback )  ;", "assertSame ( s ,    task . get (  )  )  ;", "assertSame ( s ,    task . completable (  )  . get (  )  )  ;", "task . completable (  )  . thenAccept (  (    v )     -  >    assertSame ( s ,    v )  )  ;", "}", "METHOD_END"], "methodName": ["successWithLambdas"], "fileName": "org.springframework.util.concurrent.ListenableFutureTaskTests"}, {"methodBody": ["METHOD_START", "{", "return   this . settableTask . setResultValue ( value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.springframework.util.concurrent.SettableListenableFuture"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( exception ,     \" Exception   must   not   be   null \"  )  ;", "return   this . sTask . setExceptionResult ( exception )  ;", "}", "METHOD_END"], "methodName": ["setException"], "fileName": "org.springframework.util.concurrent.SettableListenableFuture"}, {"methodBody": ["METHOD_START", "{", "ListenableFutureCallback   callback    =    mock ( ListenableFutureCallback . class )  ;", "s . addCallback ( callback )  ;", "s . cancel ( true )  ;", "verify ( callback )  . onFailure ( any ( CancellationException . class )  )  ;", "verifyNoMoreInteractions ( callback )  ;", "s . set (  \" hello \"  )  ;", "verifyNoMoreInteractions ( callback )  ;", "assertTrue ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancelDoesNotNotifyCallbacksOnSet"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFutureCallback   callback    =    mock ( ListenableFutureCallback . class )  ;", "s . addCallback ( callback )  ;", "s . cancel ( true )  ;", "verify ( callback )  . onFailure ( any ( CancellationException . class )  )  ;", "verifyNoMoreInteractions ( callback )  ;", "s . setException ( new   RuntimeException (  )  )  ;", "verifyNoMoreInteractions ( callback )  ;", "assertTrue ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancelDoesNotNotifyCallbacksOnSetException"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( settableListenableFuture . cancel ( true )  )  ;", "assertFalse ( settableListenableFuture . setException ( new   RuntimeException (  )  )  )  ;", "assertTrue ( settableListenableFuture . isCancelled (  )  )  ;", "assertTrue ( settableListenableFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancelPreventsExceptionFromBeingSet"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( settableListenableFuture . cancel ( true )  )  ;", "assertFalse ( settableListenableFuture . set (  \" hello \"  )  )  ;", "assertTrue ( settableListenableFuture . isCancelled (  )  )  ;", "assertTrue ( settableListenableFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancelPreventsValueFromBeingSet"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "settableListenableFuture . cancel ( true )  ;", "assertTrue ( settableListenableFuture . isCancelled (  )  )  ;", "assertTrue ( settableListenableFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancelSetsFutureToDone"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "settableListenableFuture . cancel ( true )  ;", "try    {", "settableListenableFuture . get (  )  ;", "fail (  \" Expected   CancellationException \"  )  ;", "}    catch    ( CancellationException   ex )     {", "}", "assertTrue ( settableListenableFuture . isCancelled (  )  )  ;", "assertTrue ( settableListenableFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancelStateThrowsExceptionWhenCallingGet"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "new   Thread ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "Thread . sleep (  2  0 L )  ;", "s . cancel ( true )  ;", "}    catch    ( InterruptedException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "}", "}  )  . start (  )  ;", "try    {", "s . get (  5  0  0 L ,    TimeUnit . MILLISECONDS )  ;", "fail (  \" Expected   CancellationException \"  )  ;", "}    catch    ( CancellationException   ex )     {", "}", "assertTrue ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancelStateThrowsExceptionWhenCallingGetWithTimeout"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "SettableListenableFutureTests . InterruptibleSettableListenableFuture   interruptibleFuture    =    new   SettableListenableFutureTests . InterruptibleSettableListenableFuture (  )  ;", "assertTrue ( interruptibleFuture . cancel ( false )  )  ;", "assertFalse ( interruptibleFuture . calledInterruptTask (  )  )  ;", "assertTrue ( interruptibleFuture . isCancelled (  )  )  ;", "assertTrue ( interruptibleFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancelWithMayInterruptIfRunningFalseDoesNotCallOverriddenMethod"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "SettableListenableFutureTests . InterruptibleSettableListenableFuture   interruptibleFuture    =    new   SettableListenableFutureTests . InterruptibleSettableListenableFuture (  )  ;", "assertTrue ( interruptibleFuture . cancel ( true )  )  ;", "assertTrue ( interruptibleFuture . calledInterruptTask (  )  )  ;", "assertTrue ( interruptibleFuture . isCancelled (  )  )  ;", "assertTrue ( interruptibleFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["cancelWithMayInterruptIfRunningTrueCallsOverriddenMethod"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "final   String   string    =     \" hello \"  ;", "new   Thread ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "Thread . sleep (  2  0 L )  ;", "s . set ( string )  ;", "}    catch    ( InterruptedException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "}", "}  )  . start (  )  ;", "String   value    =    s . get (  )  ;", "assertThat ( value ,    equalTo ( string )  )  ;", "assertFalse ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["getWaitsForCompletion"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "s . get (  1 L ,    TimeUnit . MILLISECONDS )  ;", "fail (  \" Expected   TimeoutException \"  )  ;", "}    catch    ( TimeoutException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["getWithTimeoutThrowsTimeoutException"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "final   String   string    =     \" hello \"  ;", "new   Thread ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "Thread . sleep (  2  0 L )  ;", "s . set ( string )  ;", "}    catch    ( InterruptedException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "}", "}  )  . start (  )  ;", "String   value    =    s . get (  5  0  0 L ,    TimeUnit . MILLISECONDS )  ;", "assertThat ( value ,    equalTo ( string )  )  ;", "assertFalse ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["getWithTimeoutWaitsForCompletion"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "settableListenableFuture . set ( null )  ;", "assertNull ( settableListenableFuture . get (  )  )  ;", "assertFalse ( settableListenableFuture . isCancelled (  )  )  ;", "assertTrue ( settableListenableFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["nullIsAcceptedAsValueToSet"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "String   string    =     \" hello \"  ;", "assertTrue ( s . set ( string )  )  ;", "assertThat ( s . get (  )  ,    equalTo ( string )  )  ;", "assertFalse ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["returnsSetValue"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "String   string    =     \" hello \"  ;", "assertTrue ( s . set ( string )  )  ;", "Future < String >    completable    =    s . completable (  )  ;", "assertThat ( completable . get (  )  ,    equalTo ( string )  )  ;", "assertFalse ( completable . isCancelled (  )  )  ;", "assertTrue ( completable . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["returnsSetValueFromCompletable"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( settableListenableFuture . setException ( new   RuntimeException (  )  )  )  ;", "assertFalse ( settableListenableFuture . cancel ( true )  )  ;", "assertFalse ( settableListenableFuture . isCancelled (  )  )  ;", "assertTrue ( settableListenableFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["setExceptionPreventsCancel"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   exception    =    new   RuntimeException (  )  ;", "final   Throwable [  ]    callbackHolder    =    new   Throwable [  1  ]  ;", "s . addCallback ( new   ListenableFutureCallback < String >  (  )     {", "@ Override", "public   void   onSuccess ( String   result )     {", "fail (  \" Expected   onFailure (  )    to   be   called \"  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "callbackHolder [  0  ]     =    ex ;", "}", "}  )  ;", "s . setException ( exception )  ;", "assertThat ( callbackHolder [  0  ]  ,    equalTo ( exception )  )  ;", "assertFalse ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["setExceptionTriggersCallback"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   exception    =    new   RuntimeException (  )  ;", "final   Throwable [  ]    callbackHolder    =    new   Throwable [  1  ]  ;", "s . addCallback ( new   ListenableFutureCallback < String >  (  )     {", "@ Override", "public   void   onSuccess ( String   result )     {", "fail (  \" Expected   onFailure (  )    to   be   called \"  )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "callbackHolder [  0  ]     =    ex ;", "}", "}  )  ;", "s . setException ( exception )  ;", "assertFalse ( s . setException ( new   IllegalArgumentException (  )  )  )  ;", "assertThat ( callbackHolder [  0  ]  ,    equalTo ( exception )  )  ;", "assertFalse ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["setExceptionTriggersCallbackOnlyOnce"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( settableListenableFuture . set (  \" hello \"  )  )  ;", "assertFalse ( settableListenableFuture . cancel ( true )  )  ;", "assertFalse ( settableListenableFuture . isCancelled (  )  )  ;", "assertTrue ( settableListenableFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPreventsCancel"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "String   string    =     \" hello \"  ;", "final   String [  ]    callbackHolder    =    new   String [  1  ]  ;", "s . addCallback ( new   ListenableFutureCallback < String >  (  )     {", "@ Override", "public   void   onSuccess ( String   result )     {", "callbackHolder [  0  ]     =    result ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail (  \" Expected   onSuccess (  )    to   be   called \"  )  ;", "}", "}  )  ;", "s . set ( string )  ;", "assertThat ( callbackHolder [  0  ]  ,    equalTo ( string )  )  ;", "assertFalse ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValueTriggersCallback"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "String   string    =     \" hello \"  ;", "final   String [  ]    callbackHolder    =    new   String [  1  ]  ;", "s . addCallback ( new   ListenableFutureCallback < String >  (  )     {", "@ Override", "public   void   onSuccess ( String   result )     {", "callbackHolder [  0  ]     =    result ;", "}", "@ Override", "public   void   onFailure ( Throwable   ex )     {", "fail (  \" Expected   onSuccess (  )    to   be   called \"  )  ;", "}", "}  )  ;", "s . set ( string )  ;", "assertFalse ( s . set (  \" good   bye \"  )  )  ;", "assertThat ( callbackHolder [  0  ]  ,    equalTo ( string )  )  ;", "assertFalse ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValueTriggersCallbackOnlyOnce"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "settableListenableFuture . set (  \" hello \"  )  ;", "assertFalse ( settableListenableFuture . isCancelled (  )  )  ;", "assertTrue ( settableListenableFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValueUpdatesDoneStatus"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   exception    =    new   OutOfMemoryError (  )  ;", "assertTrue ( s . setException ( exception )  )  ;", "try    {", "s . get (  )  ;", "fail (  \" Expected   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertThat ( ex . getCause (  )  ,    equalTo ( exception )  )  ;", "}", "assertFalse ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["throwsSetErrorWrappedInExecutionException"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   exception    =    new   OutOfMemoryError (  )  ;", "assertTrue ( s . setException ( exception )  )  ;", "Future < String >    completable    =    s . completable (  )  ;", "try    {", "completable . get (  )  ;", "fail (  \" Expected   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertThat ( ex . getCause (  )  ,    equalTo ( exception )  )  ;", "}", "assertFalse ( completable . isCancelled (  )  )  ;", "assertTrue ( completable . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["throwsSetErrorWrappedInExecutionExceptionFromCompletable"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   exception    =    new   RuntimeException (  )  ;", "assertTrue ( s . setException ( exception )  )  ;", "try    {", "s . get (  )  ;", "fail (  \" Expected   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertThat ( ex . getCause (  )  ,    equalTo ( exception )  )  ;", "}", "assertFalse ( s . isCancelled (  )  )  ;", "assertTrue ( s . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["throwsSetExceptionWrappedInExecutionException"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   exception    =    new   RuntimeException (  )  ;", "assertTrue ( s . setException ( exception )  )  ;", "Future < String >    completable    =    s . completable (  )  ;", "try    {", "completable . get (  )  ;", "fail (  \" Expected   ExecutionException \"  )  ;", "}    catch    ( ExecutionException   ex )     {", "assertThat ( ex . getCause (  )  ,    equalTo ( exception )  )  ;", "}", "assertFalse ( completable . isCancelled (  )  )  ;", "assertTrue ( completable . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["throwsSetExceptionWrappedInExecutionExceptionFromCompletable"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( settableListenableFuture . isCancelled (  )  )  ;", "assertFalse ( settableListenableFuture . isDone (  )  )  ;", "}", "METHOD_END"], "methodName": ["validateInitialValues"], "fileName": "org.springframework.util.concurrent.SettableListenableFutureTests"}, {"methodBody": ["METHOD_START", "{", "return   this . namespaceMappings . get (  (  ( this . namespaceMappings . size (  )  )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["currentNamespaceMapping"], "fileName": "org.springframework.util.xml.AbstractStaxHandler"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =    qName . getPrefix (  )  ;", "String   localPart    =    qName . getLocalPart (  )  ;", "return    (  ( XMLConstants . XMLNS _ ATTRIBUTE . equals ( localPart )  )     &  &     ( prefix . isEmpty (  )  )  )     |  |     (  ( XMLConstants . XMLNS _ ATTRIBUTE . equals ( prefix )  )     &  &     (  !  ( localPart . isEmpty (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isNamespaceDeclaration"], "fileName": "org.springframework.util.xml.AbstractStaxHandler"}, {"methodBody": ["METHOD_START", "{", "this . namespaceMappings . add ( new   HashMap <  >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["newNamespaceMapping"], "fileName": "org.springframework.util.xml.AbstractStaxHandler"}, {"methodBody": ["METHOD_START", "{", "this . namespaceMappings . clear (  )  ;", "}", "METHOD_END"], "methodName": ["removeAllNamespaceMappings"], "fileName": "org.springframework.util.xml.AbstractStaxHandler"}, {"methodBody": ["METHOD_START", "{", "this . namespaceMappings . remove (  (  ( this . namespaceMappings . size (  )  )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["removeNamespaceMapping"], "fileName": "org.springframework.util.xml.AbstractStaxHandler"}, {"methodBody": ["METHOD_START", "{", "int   idx    =    qualifiedName . indexOf (  '  :  '  )  ;", "if    ( idx    =  =     (  -  1  )  )     {", "return   new   QName ( namespaceUri ,    qualifiedName )  ;", "} else    {", "St   prefix    =    qualifiedName . subst (  0  ,    idx )  ;", "St   localPart    =    qualifiedName . subst (  ( idx    +     1  )  )  ;", "return   new   QName ( namespaceUri ,    localPart ,    prefix )  ;", "}", "}", "METHOD_END"], "methodName": ["toQName"], "fileName": "org.springframework.util.xml.AbstractStaxHandler"}, {"methodBody": ["METHOD_START", "{", "xmlReader    =    XMLReaderFactory . createXMLReader (  )  ;", "}", "METHOD_END"], "methodName": ["createXMLReader"], "fileName": "org.springframework.util.xml.AbstractStaxHandlerTestCase"}, {"methodBody": ["METHOD_START", "{", "Assume . assumeTrue ( AbstractStaxHandlerTestCase . wwwSpringframeworkOrgIsAccessible (  )  )  ;", "StringWriter   stringWriter    =    new   StringWriter (  )  ;", "AbstractStaxHandler   handler    =    createStaxHandler ( new   StreamResult ( stringWriter )  )  ;", "xmlReader . setContentHandler ( handler )  ;", "xmlReader . setProperty (  \" http :  /  / xml . org / sax / properties / lexical - handler \"  ,    handler )  ;", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    true )  ;", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    true )  ;", "xmlReader . parse ( new   InputSource ( new   StringReader ( AbstractStaxHandlerTestCase . COMPLEX _ XML )  )  )  ;", "assertThat ( stringWriter . toString (  )  ,    isSimilarTo ( AbstractStaxHandlerTestCase . COMPLEX _ XML )  . withNodeFilter ( AbstractStaxHandlerTestCase . nodeFilter )  )  ;", "}", "METHOD_END"], "methodName": ["namespacePrefixes"], "fileName": "org.springframework.util.xml.AbstractStaxHandlerTestCase"}, {"methodBody": ["METHOD_START", "{", "DocumentBuilderFactory   documentBuilderFactory    =    DocumentBuilderFactory . newInstance (  )  ;", "documentBuilderFactory . setNamespaceAware ( true )  ;", "DocumentBuilder   documentBuilder    =    documentBuilderFactory . newDocumentBuilder (  )  ;", "Document   expected    =    documentBuilder . parse ( new   InputSource ( new   StringReader (  . SIMPLE _ XML )  )  )  ;", "Document   result    =    documentBuilder . newDocument (  )  ;", "AbstractStaxHandler   handler    =    createStaxHandler ( new   DOMResult ( result )  )  ;", "xmlReader . setContentHandler ( handler )  ;", "xmlReader . setProperty (  \" http :  /  / xml . org / sax / properties / lexical - handler \"  ,    handler )  ;", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    true )  ;", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    true )  ;", "xmlReader . parse ( new   InputSource ( new   StringReader (  . SIMPLE _ XML )  )  )  ;", "assertThat ( expected ,    isSimilarTo ( result )  . withNodeFilter (  . nodeFilter )  )  ;", "}", "METHOD_END"], "methodName": ["namespacePrefixesDom"], "fileName": "org.springframework.util.xml.AbstractStaxHandlerTestCase"}, {"methodBody": ["METHOD_START", "{", "Assume . assumeTrue ( AbstractStaxHandlerTestCase . wwwSpringframeworkOrgIsAccessible (  )  )  ;", "StringWriter   stringWriter    =    new   StringWriter (  )  ;", "AbstractStaxHandler   handler    =    createStaxHandler ( new   StreamResult ( stringWriter )  )  ;", "xmlReader . setContentHandler ( handler )  ;", "xmlReader . setProperty (  \" http :  /  / xml . org / sax / properties / lexical - handler \"  ,    handler )  ;", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    true )  ;", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    false )  ;", "xmlReader . parse ( new   InputSource ( new   StringReader ( AbstractStaxHandlerTestCase . COMPLEX _ XML )  )  )  ;", "assertThat ( stringWriter . toString (  )  ,    isSimilarTo ( AbstractStaxHandlerTestCase . COMPLEX _ XML )  . withNodeFilter ( AbstractStaxHandlerTestCase . nodeFilter )  )  ;", "}", "METHOD_END"], "methodName": ["noNamespacePrefixes"], "fileName": "org.springframework.util.xml.AbstractStaxHandlerTestCase"}, {"methodBody": ["METHOD_START", "{", "DocumentBuilderFactory   documentBuilderFactory    =    DocumentBuilderFactory . newInstance (  )  ;", "documentBuilderFactory . setNamespaceAware ( true )  ;", "DocumentBuilder   documentBuilder    =    documentBuilderFactory . newDocumentBuilder (  )  ;", "Document   expected    =    documentBuilder . parse ( new   InputSource ( new   StringReader (  . SIMPLE _ XML )  )  )  ;", "Document   result    =    documentBuilder . newDocument (  )  ;", "AbstractStaxHandler   handler    =    createStaxHandler ( new   DOMResult ( result )  )  ;", "xmlReader . setContentHandler ( handler )  ;", "xmlReader . setProperty (  \" http :  /  / xml . org / sax / properties / lexical - handler \"  ,    handler )  ;", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    true )  ;", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    false )  ;", "xmlReader . parse ( new   InputSource ( new   StringReader (  . SIMPLE _ XML )  )  )  ;", "assertThat ( result ,    isSimilarTo ( expected )  . withNodeFilter (  . nodeFilter )  )  ;", "}", "METHOD_END"], "methodName": ["noNamespacePrefixesDom"], "fileName": "org.springframework.util.xml.AbstractStaxHandlerTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   Socket (  \" wwworg \"  ,     8  0  )  . close (  )  ;", "}    catch    ( Exception   e )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["wwwSpringframeworkOrgIsAccessible"], "fileName": "org.springframework.util.xml.AbstractStaxHandlerTestCase"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( getContentHandler (  )  )     !  =    null )     &  &     ( this . namespaces . containsKey ( prefix )  )  )     {", "getContentHandler (  )  . endPrefixMapping ( prefix )  ;", "this . namespaces . remove ( prefix )  ;", "}", "}", "METHOD_END"], "methodName": ["endPrefixMapping"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReader"}, {"methodBody": ["METHOD_START", "{", "return   this . namespacePrefixesFeature ;", "}", "METHOD_END"], "methodName": ["hasNamespacePrefixesFeature"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReader"}, {"methodBody": ["METHOD_START", "{", "return   this . namespacesFeature ;", "}", "METHOD_END"], "methodName": ["hasNamespacesFeature"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReader"}, {"methodBody": ["METHOD_START", "{", "try    {", "parseInternal (  )  ;", "}    catch    ( XMLStreamException   ex )     {", "Locator   locator    =    null ;", "if    (  ( ex . getLocation (  )  )     !  =    null )     {", "locator    =    new    . StaxLocator ( ex . getLocation (  )  )  ;", "}", "SAXParseException   saxException    =    new   SAXParseException ( ex . getMessage (  )  ,    locator ,    ex )  ;", "if    (  ( getErrorHandler (  )  )     !  =    null )     {", "getErrorHandler (  )  . fatalError ( saxException )  ;", "} else    {", "throw   saxException ;", "}", "}", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReader"}, {"methodBody": ["METHOD_START", "{", "this . isStandalone    =    standalone ;", "}", "METHOD_END"], "methodName": ["setStandalone"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( getContentHandler (  )  )     !  =    null )     &  &     ( StringUtils . hasLength ( namespace )  )  )     {", "if    ( prefix    =  =    null )     {", "prefix    =     \"  \"  ;", "}", "if    (  !  ( namespace . equals ( this . namespaces . get ( prefix )  )  )  )     {", "getContentHandler (  )  . startPrefixMapping ( prefix ,    namespace )  ;", "this . namespaces . put ( prefix ,    namespace )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["startPrefixMapping"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReader"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =    qName . getPrefix (  )  ;", "if    (  !  ( StringUtils . hasLength ( prefix )  )  )     {", "return   qName . getLocalPart (  )  ;", "} else    {", "return    ( prefix    +     \"  :  \"  )     +     ( qName . getLocalPart (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toQualifiedName"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReader"}, {"methodBody": ["METHOD_START", "{", "standardReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    true )  ;", "standardReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    false )  ;", "standardReader . parse ( new   InputSource ( createTestInputStream (  )  )  )  ;", "staxXmlReader    =    createStaxXmlReader ( createTestInputStream (  )  )  ;", "ContentHandler   contentHandler    =    mockContentHandler (  )  ;", "staxXmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    true )  ;", "staxXmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    false )  ;", "staxXmlReader . setContentHandler ( contentHandler )  ;", "staxXmlReader . parse ( new   InputSource (  )  )  ;", "verifyIdenticalInvocations ( standardContentHandler ,    contentHandler )  ;", "}", "METHOD_END"], "methodName": ["contentHandlerNamespacesNoPrefixes"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "standardReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    true )  ;", "standardReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    true )  ;", "standardReader . parse ( new   InputSource ( createTestInputStream (  )  )  )  ;", "staxXmlReader    =    createStaxXmlReader ( createTestInputStream (  )  )  ;", "ContentHandler   contentHandler    =    mockContentHandler (  )  ;", "staxXmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    true )  ;", "staxXmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    true )  ;", "staxXmlReader . setContentHandler ( contentHandler )  ;", "staxXmlReader . parse ( new   InputSource (  )  )  ;", "verifyIdenticalInvocations ( standardContentHandler ,    contentHandler )  ;", "}", "METHOD_END"], "methodName": ["contentHandlerNamespacesPrefixes"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "standardReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    false )  ;", "standardReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    true )  ;", "standardReader . parse ( new   InputSource ( createTestInputStream (  )  )  )  ;", "staxXmlReader    =    createStaxXmlReader ( createTestInputStream (  )  )  ;", "ContentHandler   contentHandler    =    mockContentHandler (  )  ;", "staxXmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespaces \"  ,    false )  ;", "staxXmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    true )  ;", "staxXmlReader . setContentHandler ( contentHandler )  ;", "staxXmlReader . parse ( new   InputSource (  )  )  ;", "verifyIdenticalInvocations ( standardContentHandler ,    contentHandler )  ;", "}", "METHOD_END"], "methodName": ["contentHandlerNoNamespacesPrefixes"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "return   getClass (  )  . getResourceAsStream (  \" testContentHandler . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["createTestInputStream"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "Resource   testLexicalHandlerXml    =    new   ClassPathResource (  \" testLexicalHandler . xml \"  ,    getClass (  )  )  ;", "LexicalHandler   expectedLexicalHandler    =    mockLexicalHandler (  )  ;", "standardReader . setContentHandler ( null )  ;", "standardReader . setProperty (  \" http :  /  / xml . org / sax / properties / lexical - handler \"  ,    expectedLexicalHandler )  ;", "standardReader . parse ( new   InputSource ( testLexicalHandlerXml . getInputStream (  )  )  )  ;", ". inputFactory . setProperty (  \" isCoalescing \"  ,    Boolean . FALSE )  ;", ". inputFactory . setProperty (  \" http :  /  / com / xml / stream / properties / report - cdata - event \"  ,    Boolean . TRUE )  ;", ". inputFactory . setProperty (  \" isReplacingEntityReferences \"  ,    Boolean . FALSE )  ;", ". inputFactory . setProperty (  \" isSupportingExternalEntities \"  ,    Boolean . FALSE )  ;", "LexicalHandler   actualLexicalHandler    =    mockLexicalHandler (  )  ;", "willAnswer (  (    invocation )     -  >    invocation . getArguments (  )  [  0  ]     =     \" element \"  )  . given ( actualLexicalHandler )  . startDTD ( anyString (  )  ,    anyString (  )  ,    anyString (  )  )  ;", "AbstractStaxXMLReader   staxXmlReader    =    createStaxXmlReader ( testLexicalHandlerXml . getInputStream (  )  )  ;", "staxXmlReader . setProperty (  \" http :  /  / xml . org / sax / properties / lexical - handler \"  ,    actualLexicalHandler )  ;", "staxXmlReader . parse ( new   InputSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["lexicalHandler"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "ContentHandler   contentHandler    =    mock ( ContentHandler . class )  ;", "willAnswer ( new    . CopyCharsAnswer (  )  )  . given ( contentHandler )  . characters ( any ( char [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "willAnswer ( new    . CopyCharsAnswer (  )  )  . given ( contentHandler )  . ignorableWhitespace ( any ( char [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "willAnswer ( new   Answer < Object >  (  )     {", "@ Override", "public   Object   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "invocation . getArguments (  )  [  3  ]     =    new   AttributesImpl (  (  ( Attributes )     ( invocation . getArguments (  )  [  3  ]  )  )  )  ;", "return   null ;", "}", "}  )  . given ( contentHandler )  . startElement ( anyString (  )  ,    anyString (  )  ,    anyString (  )  ,    any ( Attributes . class )  )  ;", "return   contentHandler ;", "}", "METHOD_END"], "methodName": ["mockContentHandler"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "LexicalHandler   lexicalHandler    =    mock ( LexicalHandler . class )  ;", "willAnswer ( new    . CopyCharsAnswer (  )  )  . given ( lexicalHandler )  . comment ( any ( char [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "return   lexicalHandler ;", "}", "METHOD_END"], "methodName": ["mockLexicalHandler"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "AbstractStaxXMLReaderTestCase . inputFactory    =    XMLInputFactory . newInstance (  )  ;", "standardReader    =    XMLReaderFactory . createXMLReader (  )  ;", "standardContentHandler    =    mockContentHandler (  )  ;", "standardReader . setContentHandler ( standardContentHandler )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "MockitoUtils . verifySameInvocations ( expected ,    actual ,    new   AbstractStaxXMLReaderTestCase . SkipLocatorArgumentsAdapter (  )  ,    new   AbstractStaxXMLReaderTestCase . CharArrayToStringAdapter (  )  ,    new   AbstractStaxXMLReaderTestCase . PartialAttributesAdapter (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyIdenticalInvocations"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "String   xml    =     \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" UTF -  8  \\  \"  ?  >  < test >  < node 1  >     <  / node 1  >  < node 2  >    Some   text    <  / node 2  >  <  / test >  \"  ;", "Transformer   transformer    =    TransformerFactory . newInstance (  )  . newTransformer (  )  ;", "staxXmlReader    =    createStaxXmlReader ( new   ByteArrayInputStream ( xml . getBytes (  \" UTF -  8  \"  )  )  )  ;", "SAXSource   source    =    new   SAXSource ( staxXmlReader ,    new   InputSource (  )  )  ;", "DOMResult   result    =    new   DOMResult (  )  ;", "transformer . transform ( source ,    result )  ;", "Node   node 1     =    result . getNode (  )  . getFirstChild (  )  . getFirstChild (  )  ;", "assertEquals (  \"     \"  ,    node 1  . getTextContent (  )  )  ;", "assertEquals (  \"    Some   text    \"  ,    node 1  . getNextSibling (  )  . getTextContent (  )  )  ;", "}", "METHOD_END"], "methodName": ["whitespace"], "fileName": "org.springframework.util.xml.AbstractStaxXMLReaderTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( isClosed (  )  )     {", "throw   new   XMLStreamException (  \"    has   been   closed \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkIfClosed"], "fileName": "org.springframework.util.xml.AbstractXMLEventReader"}, {"methodBody": ["METHOD_START", "{", "return   this . closed ;", "}", "METHOD_END"], "methodName": ["isClosed"], "fileName": "org.springframework.util.xml.AbstractXMLEventReader"}, {"methodBody": ["METHOD_START", "{", "return   this . lexicalHandler ;", "}", "METHOD_END"], "methodName": ["getLexicalHandler"], "fileName": "org.springframework.util.xml.AbstractXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( elements . isEmpty (  )  )  )     {", "return   elements . get (  (  ( elements . size (  )  )     -     1  )  )  ;", "} else    {", "return   node ;", "}", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.springframework.util.xml.DomContentHandler"}, {"methodBody": ["METHOD_START", "{", "xmlReader . setFeature (  \" http :  /  / xml . org / sax / features / namespace - prefixes \"  ,    true )  ;", "handler    =    new   DomContentHandler ( result )  ;", "expected    =    documentBuilder . parse ( new   InputSource ( new   StringReader (  . XML _  1  )  )  )  ;", "xmlReader . setContentHandler ( handler )  ;", "xmlReader . parse ( new   InputSource ( new   StringReader (  . XML _  1  )  )  )  ;", "assertThat (  \" Invalid   result \"  ,    result ,    isSimilarTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["contentHandlerDocumentNamespacePrefixes"], "fileName": "org.springframework.util.xml.DomContentHandlerTests"}, {"methodBody": ["METHOD_START", "{", "handler    =    new   DomContentHandler ( result )  ;", "expected    =    documentBuilder . parse ( new   InputSource ( new   StringReader (  . XML _  1  )  )  )  ;", "xmlReader . setContentHandler ( handler )  ;", "xmlReader . parse ( new   InputSource ( new   StringReader (  . XML _  1  )  )  )  ;", "assertThat (  \" Invalid   result \"  ,    result ,    isSimilarTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["contentHandlerDocumentNoNamespacePrefixes"], "fileName": "org.springframework.util.xml.DomContentHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Element   rootElement    =    result . createElementNS (  \" namespace \"  ,     \" root \"  )  ;", "result . appendChild ( rootElement )  ;", "handler    =    new   DomContentHandler ( rootElement )  ;", "expected    =    documentBuilder . parse ( new   InputSource ( new   StringReader (  . XML _  2  _ EXPECTED )  )  )  ;", "xmlReader . setContentHandler ( handler )  ;", "xmlReader . parse ( new   InputSource ( new   StringReader (  . XML _  2  _ SNIPPET )  )  )  ;", "assertThat (  \" Invalid   result \"  ,    result ,    isSimilarTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["contentHandlerElement"], "fileName": "org.springframework.util.xml.DomContentHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DocumentBuilderFactory   documentBuilderFactory    =    DocumentBuilderFactory . newInstance (  )  ;", "documentBuilderFactory . setNamespaceAware ( true )  ;", "documentBuilder    =    documentBuilderFactory . newDocumentBuilder (  )  ;", "result    =    documentBuilder . newDocument (  )  ;", "xmlReader    =    XMLReaderFactory . createXMLReader (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.util.xml.DomContentHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DomContentHandler ( node )  ;", "}", "METHOD_END"], "methodName": ["createContentHandler"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( ele ,     \" Element   must   not   be   null \"  )  ;", "Assert . notNull ( childEleName ,     \" Element   name   must   not   be   null \"  )  ;", "NodeList   nl    =    ele . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  ( node   instanceof   Element )     &  &     (  . nodeNameMatch ( node ,    childEleName )  )  )     {", "return    (  ( Element )     ( node )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getChildElementByTagName"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "Element   child    =    DomUtils . getChildElementByTagName ( ele ,    childEleName )  ;", "return   child    !  =    null    ?    DomUtils . getTextValue ( child )     :    null ;", "}", "METHOD_END"], "methodName": ["getChildElementValueByTagName"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( ele ,     \" Element   must   not   be   null \"  )  ;", "NodeList   nl    =    ele . getChildNodes (  )  ;", "List < Element >    childEles    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    ( node   instanceof   Element )     {", "childEles . add (  (  ( Element )     ( node )  )  )  ;", "}", "}", "return   childEles ;", "}", "METHOD_END"], "methodName": ["getChildElements"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "return   DomUtils . getChildElementsByTagName ( ele ,    new   String [  ]  {    childEleName    }  )  ;", "}", "METHOD_END"], "methodName": ["getChildElementsByTagName"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( ele ,     \" Element   must   not   be   null \"  )  ;", "Assert . notNull ( childEleNames ,     \" Element   names   collection   must   not   be   null \"  )  ;", "List < String >    childEleNameList    =    Arrays . asList ( childEleNames )  ;", "NodeList   nl    =    ele . getChildNodes (  )  ;", "List < Element >    childEles    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  ( node   instanceof   Element )     &  &     (  . nodeNameMatch ( node ,    childEleNameList )  )  )     {", "childEles . add (  (  ( Element )     ( node )  )  )  ;", "}", "}", "return   childEles ;", "}", "METHOD_END"], "methodName": ["getChildElementsByTagName"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( valueEle ,     \" Element   must   not   be   null \"  )  ;", "StBuilder   sb    =    new   StBuilder (  )  ;", "NodeList   nl    =    valueEle . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   item    =    nl . item ( i )  ;", "if    (  (  ( item   instanceof   CharacterData )     &  &     (  !  ( item   instanceof   Comment )  )  )     |  |     ( item   instanceof   EntityReference )  )     {", "sb . append ( item . getNodeValue (  )  )  ;", "}", "}", "return   sb . toSt (  )  ;", "}", "METHOD_END"], "methodName": ["getTextValue"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( node ,     \" Node   must   not   be   null \"  )  ;", "Assert . notNull ( desiredName ,     \" Desired   name   must   not   be   null \"  )  ;", "return    . nodeNameMatch ( node ,    desiredName )  ;", "}", "METHOD_END"], "methodName": ["nodeNameEquals"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( desiredName . equals ( node . getNodeName (  )  )  )     |  |     ( desiredName . equals ( node . getLocalName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nodeNameMatch"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( desiredNames . contains ( node . getNodeName (  )  )  )     |  |     ( desiredNames . contains ( node . getLocalName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nodeNameMatch"], "fileName": "org.springframework.util.xml.DomUtils"}, {"methodBody": ["METHOD_START", "{", "XMLEventReader   reader    =    this . inputFactory . createXMLEventReader ( new   StringReader ( xml )  )  ;", "List < XMLEvent >    events    =    new   ArrayList <  >  (  )  ;", "while    ( reader . hasNext (  )  )     {", "events . add ( reader . nextEvent (  )  )  ;", "}", "return   events ;", "}", "METHOD_END"], "methodName": ["readEvents"], "fileName": "org.springframework.util.xml.ListBasedXMLEventReaderTests"}, {"methodBody": ["METHOD_START", "{", "String   xml    =     \"  < foo >  < bar > baz <  / bar >  <  / foo >  \"  ;", "List < XMLEvent >    events    =    readEvents ( xml )  ;", "reader    =    new    ( events )  ;", "StringWriter   resultWriter    =    new   StringWriter (  )  ;", "XMLEventWriter   writer    =    this . outputFactory . createXMLEventWriter ( resultWriter )  ;", "writer . add ( reader )  ;", "Assert . assertThat ( resultWriter . toString (  )  ,    isSimilarTo ( xml )  )  ;", "}", "METHOD_END"], "methodName": ["standard"], "fileName": "org.springframework.util.xml.ListBasedXMLEventReaderTests"}, {"methodBody": ["METHOD_START", "{", "bindNamespaceUri ( XMLConstants . DEFAULT _ NS _ PREFIX ,    namespaceUri )  ;", "}", "METHOD_END"], "methodName": ["bindDefaultNamespaceUri"], "fileName": "org.springframework.util.xml.SimpleNamespaceContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( prefix ,     \" No   prefix   given \"  )  ;", "Assert . notNull ( namespaceUri ,     \" No   namespaceUri   given \"  )  ;", "if    ( XMLConstants . DEFAULT _ NS _ PREFIX . equals ( prefix )  )     {", "this . defaultUri    =    namespaceUri ;", "} else    {", "this . prefixToUri . put ( prefix ,    namespaceUri )  ;", "Set < String >    prefixes    =    this . namespaceUriToPrefixes . computeIfAbsent ( namespaceUri ,     (    k )     -  >    new   LinkedHashSet <  >  (  )  )  ;", "prefixes . add ( prefix )  ;", "}", "}", "METHOD_END"], "methodName": ["bindNamespaceUri"], "fileName": "org.springframework.util.xml.SimpleNamespaceContext"}, {"methodBody": ["METHOD_START", "{", "this . prefixToNamespaceUri . clear (  )  ;", "this . namespaceUriToPrefixes . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.util.xml.SimpleNamespaceContext"}, {"methodBody": ["METHOD_START", "{", "return   this . prefixToNamespaceUri . keySet (  )  . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["getBoundPrefixes"], "fileName": "org.springframework.util.xml.SimpleNamespaceContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( namespaceUri ,     \" No   namespaceUri   given \"  )  ;", "if    ( this . defaultUri . equals ( namespaceUri )  )     {", "return   Collections . singleton ( XMLConstants . DEFAULT _ NS _ PREFIX )  ;", "} else", "if    ( XMLConstants . XML _ NS _ URI . equals ( namespaceUri )  )     {", "return   Collections . singleton ( XMLConstants . XML _ NS _ PREFIX )  ;", "} else", "if    ( XMLConstants . XMLNS _ ATTRIBUTE _ NS _ URI . equals ( namespaceUri )  )     {", "return   Collections . singleton ( XMLConstants . XMLNS _ ATTRIBUTE )  ;", "} else    {", "Set < String >    prefixes    =    this . namespaceUriToPrefixes . get ( namespaceUri )  ;", "return   prefixes    !  =    null    ?    Collections . unmodifiableSet ( prefixes )     :    Collections . emptySet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPrefixesSet"], "fileName": "org.springframework.util.xml.SimpleNamespaceContext"}, {"methodBody": ["METHOD_START", "{", "if    ( XMLConstants . DEFAULT _ NS _ PREFIX . equals ( prefix )  )     {", "this . defaultUri    =     \"  \"  ;", "} else", "if    ( prefix    !  =    null )     {", "String   namespaceUri    =    this . prefixToUri . remove ( prefix )  ;", "if    ( namespaceUri    !  =    null )     {", "Set < String >    prefixes    =    this . namespaceUriToPrefixes . get ( namespaceUri )  ;", "if    ( prefixes    !  =    null )     {", "prefixes . remove ( prefix )  ;", "if    ( prefixes . isEmpty (  )  )     {", "this . namespaceUriToPrefixes . remove ( namespaceUri )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["removeBinding"], "fileName": "org.springframework.util.xml.SimpleNamespaceContext"}, {"methodBody": ["METHOD_START", "{", "bindings . forEach ( this :  : bindNamespaceUri )  ;", "}", "METHOD_END"], "methodName": ["setBindings"], "fileName": "org.springframework.util.xml.SimpleNamespaceContext"}, {"methodBody": ["METHOD_START", "{", "context . bindNamespaceUri ( prefix ,    namespaceUri )  ;", "assertThat (  \" The   Namespace   URI   was   bound   to   the   prefix \"  ,    context . getNamespaceURI ( prefix )  ,    is ( namespaceUri )  )  ;", "assertThat (  \" The   prefix   was   bound   to   the   namespace   URI \"  ,    getItemSet ( context . getPrefixes ( namespaceUri )  )  ,    hasItem ( prefix )  )  ;", "}", "METHOD_END"], "methodName": ["bindNamespaceUri"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . bindNamespaceUri (  \" prefix \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["bindNamespaceUri_withNullNamespaceUri"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . bindNamespaceUri ( null ,    namespaceUri )  ;", "}", "METHOD_END"], "methodName": ["bindNamespaceUri_withNullPrefix"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . bindNamespaceUri (  \" prefix 1  \"  ,    namespaceUri )  ;", "context . bindNamespaceUri (  \" prefix 2  \"  ,    namespaceUri )  ;", "context . bindNamespaceUri (  \" prefix 3  \"  ,    additionalNamespaceUri )  ;", "context . clear (  )  ;", "assertThat (  \" All   bound   prefixes   were   removed \"  ,    context . getBoundPrefixes (  )  . hasNext (  )  ,    is ( false )  )  ;", "assertThat (  \" All   bound   namespace   URIs   were   removed \"  ,    context . getPrefixes ( namespaceUri )  . hasNext (  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . bindNamespaceUri (  \" prefix 1  \"  ,    namespaceUri )  ;", "context . bindNamespaceUri (  \" prefix 2  \"  ,    namespaceUri )  ;", "context . bindNamespaceUri (  \" prefix 3  \"  ,    additionalNamespaceUri )  ;", "assertThat (  \" Returns   all   bound   prefixes \"  ,    getItemSet ( context . getBoundPrefixes (  )  )  ,    is ( makeSet (  \" prefix 1  \"  ,     \" prefix 2  \"  ,     \" prefix 3  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getBoundPrefixes"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    itemSet    =    new   HashSet <  >  (  )  ;", "while    ( iterator . hasNext (  )  )     {", "itemSet . add ( iterator . next (  )  )  ;", "}", "return   itemSet ;", "}", "METHOD_END"], "methodName": ["getItemSet"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . bindNamespaceUri ( XMLConstants . XMLNS _ ATTRIBUTE ,    additionalNamespaceUri )  ;", "assertThat (  \" Always   returns    \\  \" http :  /  / www . w 3  . org /  2  0  0  0  / xmlns /  \\  \"    for    \\  \" xmlns \\  \"  \"  ,    context . getNamespaceURI ( XMLConstants . XMLNS _ ATTRIBUTE )  ,    is ( XMLConstants . XMLNS _ ATTRIBUTE _ NS _ URI )  )  ;", "context . bindNamespaceUri ( XMLConstants . XML _ NS _ PREFIX ,    additionalNamespaceUri )  ;", "assertThat (  \" Always   returns    \\  \" http :  /  / www . w 3  . org / XML /  1  9  9  8  / namespace \\  \"    for    \\  \" xml \\  \"  \"  ,    context . getNamespaceURI ( XMLConstants . XML _ NS _ PREFIX )  ,    is ( XMLConstants . XML _ NS _ URI )  )  ;", "assertThat (  \" Returns    \\  \"  \\  \"    for   an   unbound   prefix \"  ,    context . getNamespaceURI ( unboundPrefix )  ,    is ( XMLConstants . NULL _ NS _ URI )  )  ;", "context . bindNamespaceUri ( prefix ,    namespaceUri )  ;", "assertThat (  \" Returns   the   bound   namespace   URI   for   a   bound   prefix \"  ,    context . getNamespaceURI ( prefix )  ,    is ( namespaceUri )  )  ;", "assertThat (  \" By   default   returns   URI    \\  \"  \\  \"    for   the   default   namespace   prefix \"  ,    context . getNamespaceURI ( XMLConstants . DEFAULT _ NS _ PREFIX )  ,    is ( XMLConstants . NULL _ NS _ URI )  )  ;", "context . bindDefaultNamespaceUri ( defaultNamespaceUri )  ;", "assertThat (  \" Returns   the   set   URI   for   the   default   namespace   prefix \"  ,    context . getNamespaceURI ( XMLConstants . DEFAULT _ NS _ PREFIX )  ,    is ( defaultNamespaceUri )  )  ;", "}", "METHOD_END"], "methodName": ["getNamespaceURI"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . getNamespaceURI ( null )  ;", "}", "METHOD_END"], "methodName": ["getNamespaceURI_withNull"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "assertThat (  \" Always   returns    \\  \" xmlns \\  \"    for    \\  \" http :  /  / www . w 3  . org /  2  0  0  0  / xmlns /  \\  \"  \"  ,    context . getPrefix ( XMLConstants . XMLNS _ ATTRIBUTE _ NS _ URI )  ,    is ( XMLConstants . XMLNS _ ATTRIBUTE )  )  ;", "assertThat (  \" Always   returns    \\  \" xml \\  \"    for    \\  \" http :  /  / www . w 3  . org / XML /  1  9  9  8  / namespace \\  \"  \"  ,    context . getPrefix ( XMLConstants . XML _ NS _ URI )  ,    is ( XMLConstants . XML _ NS _ PREFIX )  )  ;", "assertThat (  \" Returns   null   for   an   unbound   namespace   URI \"  ,    context . getPrefix ( unboundUri )  ,    is ( nullValue (  )  )  )  ;", "context . bindUri (  \" prefix 1  \"  ,    namespaceUri )  ;", "context . bindUri (  \" prefix 2  \"  ,    namespaceUri )  ;", "assertThat (  \" Returns   a   prefix   for   a   bound   namespace   URI \"  ,    context . getPrefix ( namespaceUri )  ,    anyOf ( is (  \" prefix 1  \"  )  ,    is (  \" prefix 2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPrefix"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . getPrefix ( null )  ;", "}", "METHOD_END"], "methodName": ["getPrefix_withNull"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "assertThat (  \" Returns   only    \\  \" xmlns \\  \"    for    \\  \" http :  /  / www . w 3  . org /  2  0  0  0  / xmlns /  \\  \"  \"  ,    getItemSet ( context . getPrefixes ( XMLConstants . XMLNS _ ATTRIBUTE _ NS _ URI )  )  ,    is ( makeSet ( XMLConstants . XMLNS _ ATTRIBUTE )  )  )  ;", "assertThat (  \" Returns   only    \\  \" xml \\  \"    for    \\  \" http :  /  / www . w 3  . org / XML /  1  9  9  8  / namespace \\  \"  \"  ,    getItemSet ( context . getPrefixes ( XMLConstants . XML _ NS _ URI )  )  ,    is ( makeSet ( XMLConstants . XML _ NS _ PREFIX )  )  )  ;", "assertThat (  \" Returns   empty   iterator   for   unbound   prefix \"  ,    context . getPrefixes (  \" unbound      URI \"  )  . hasNext (  )  ,    is ( false )  )  ;", "context . bindUri (  \" prefix 1  \"  ,    namespaceUri )  ;", "context . bindUri (  \" prefix 2  \"  ,    namespaceUri )  ;", "assertThat (  \" Returns   all   prefixes    ( and   only   those )    bound   to   the   namespace   URI \"  ,    getItemSet ( context . getPrefixes ( namespaceUri )  )  ,    is ( makeSet (  \" prefix 1  \"  ,     \" prefix 2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getPrefixes"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . bindNamespaceUri ( prefix ,    namespaceUri )  ;", "Iterator < String >    iterator    =    context . getPrefixes ( namespaceUri )  ;", "iterator . remove (  )  ;", "}", "METHOD_END"], "methodName": ["getPrefixes_IteratorIsNotModifiable"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . getPrefixes ( null )  ;", "}", "METHOD_END"], "methodName": ["getPrefixes_withNull"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    itemSet    =    new   HashSet <  >  (  )  ;", "for    ( String   item    :    items )     {", "itemSet . add ( item )  ;", "}", "return   itemSet ;", "}", "METHOD_END"], "methodName": ["makeSet"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "context . removeBinding ( unboundPrefix )  ;", "context . bindUri ( prefix ,    namespaceUri )  ;", "context . removeBinding ( prefix )  ;", "assertThat (  \" Returns   default   namespace   URI   for   removed   prefix \"  ,    context . getURI ( prefix )  ,    is ( XMLConstants . NULL _ NS _ URI )  )  ;", "assertThat (  \"  # getPrefix   returns   null   when   all   prefixes   for   a   namespace   URI   were   removed \"  ,    context . getPrefix ( namespaceUri )  ,    is ( nullValue (  )  )  )  ;", "assertThat (  \"  # getPrefixes   returns   an   empty   iterator   when   all   prefixes   for   a   namespace   URI   were   removed \"  ,    context . getPrefixes ( namespaceUri )  . hasNext (  )  ,    is ( false )  )  ;", "context . bindUri (  \" prefix 1  \"  ,    additionalUri )  ;", "context . bindUri (  \" prefix 2  \"  ,    additionalUri )  ;", "context . removeBinding (  \" prefix 1  \"  )  ;", "assertThat (  \" Prefix   was   unbound \"  ,    context . getURI (  \" prefix 1  \"  )  ,    is ( XMLConstants . NULL _ NS _ URI )  )  ;", "assertThat (  \"  # getPrefix   returns   a   bound   prefix   after   removal   of   another   prefix   for   the   same   namespace   URI \"  ,    context . getPrefix ( additionalUri )  ,    is (  \" prefix 2  \"  )  )  ;", "assertThat (  \" Prefix   was   removed   from   namespace   URI \"  ,    getItemSet ( context . getPrefixes ( additionalUri )  )  ,    is ( makeSet (  \" prefix 2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["removeBinding"], "fileName": "org.springframework.util.xml.SimpleNamespaceContextTests"}, {"methodBody": ["METHOD_START", "{", "List < Attribute >    result    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     ( attributes . getLength (  )  )  ;    i +  +  )     {", "QName   attrName    =    toQName ( attributes . getURI ( i )  ,    attributes . getQName ( i )  )  ;", "if    (  !  ( isNamespaceDeclaration ( attrName )  )  )     {", "result . add ( this . eFactory . createAttribute ( attrName ,    attributes . getValue ( i )  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.springframework.util.xml.StaxEventHandler"}, {"methodBody": ["METHOD_START", "{", "List < Namespace >    result    =    new   ArrayList <  >  (  )  ;", "namespaceMapping . forEach (  (    prefix ,    namespaceUri )     -  >    result . add ( this . eFactory . createNamespace ( prefix ,    namespaceUri )  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getNamespaces"], "fileName": "org.springframework.util.xml.StaxEventHandler"}, {"methodBody": ["METHOD_START", "{", "AttributesImpl   attributes    =    new   AttributesImpl (  )  ;", "for    ( Iterator   i    =    e . getAttributes (  )  ;    i . hasNext (  )  ;  )     {", "Attribute   attribute    =     (  ( Attribute )     ( i . next (  )  )  )  ;", "QName   qName    =    attribute . getName (  )  ;", "String   namespace    =    qName . getNamespaceURI (  )  ;", "if    (  ( namespace    =  =    null )     |  |     (  !  ( hasNamespacesFeature (  )  )  )  )     {", "namespace    =     \"  \"  ;", "}", "String   type    =    attribute . getDTDType (  )  ;", "if    ( type    =  =    null )     {", "type    =     \" CDATA \"  ;", "}", "attributes . addAttribute ( namespace ,    qName . getLocalPart (  )  ,    toQualifiedName ( qName )  ,    type ,    attribute . getValue (  )  )  ;", "}", "if    ( hasNamespacePrefixesFeature (  )  )     {", "for    ( Iterator   i    =    e . getNamespaces (  )  ;    i . hasNext (  )  ;  )     {", "Namespace   namespace    =     (  ( Namespace )     ( i . next (  )  )  )  ;", "String   prefix    =    namespace . getPrefix (  )  ;", "String   namespaceUri    =    namespace . getNamespaceURI (  )  ;", "String   qName ;", "if    ( StringUtils . hasLength ( prefix )  )     {", "qName    =     \" xmlns :  \"     +    prefix ;", "} else    {", "qName    =     \" xmlns \"  ;", "}", "attributes . addAttribute (  \"  \"  ,     \"  \"  ,    qName ,     \" CDATA \"  ,    namespaceUri )  ;", "}", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "char [  ]    data    =    characters . getData (  )  . toCharArray (  )  ;", "if    (  (  ( getContHandler (  )  )     !  =    null )     &  &     ( characters . isIgnorableWhiteSpace (  )  )  )     {", "getContHandler (  )  . ignorableWhitespace ( data ,     0  ,    data . length )  ;", "return ;", "}", "if    (  ( characters . isCData (  )  )     &  &     (  ( getLexicalHandler (  )  )     !  =    null )  )     {", "getLexicalHandler (  )  . startCDATA (  )  ;", "}", "if    (  ( getContHandler (  )  )     !  =    null )     {", "getContHandler (  )  . characters ( data ,     0  ,    data . length )  ;", "}", "if    (  ( characters . isCData (  )  )     &  &     (  ( getLexicalHandler (  )  )     !  =    null )  )     {", "getLexicalHandler (  )  . endCDATA (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleCharacters"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "char [  ]    ch    =    comm . getText (  )  . toCharArray (  )  ;", "getLexicalHandler (  )  . comm ( ch ,     0  ,    ch . length )  ;", "}", "}", "METHOD_END"], "methodName": ["handleComment"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "Location   location    =    dtd . getLocation (  )  ;", "getLexicalHandler (  )  . startDTD ( null ,    location . getPublicId (  )  ,    location . getSystemId (  )  )  ;", "}", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "getLexicalHandler (  )  . endDTD (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleDtd"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "getContentHandler (  )  . endDocument (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleEndDocument"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "QName   qName    =    endElement . getName (  )  ;", "if    ( hasNamespacesFeature (  )  )     {", "getContentHandler (  )  . endElement ( qName . getNamespaceURI (  )  ,    qName . getLocalPart (  )  ,    toQualifiedName ( qName )  )  ;", "for    ( Iterator   i    =    endElement . getNamespaces (  )  ;    i . hasNext (  )  ;  )     {", "Namespace   namespace    =     (  ( Namespace )     ( i . next (  )  )  )  ;", "endPrefixMapping ( namespace . getPrefix (  )  )  ;", "}", "} else    {", "getContentHandler (  )  . endElement (  \"  \"  ,     \"  \"  ,    toQualifiedName ( qName )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleEndElement"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getDTDHandler (  )  )     !  =    null )     {", "getDTDHandler (  )  . unparsedEntityDecl ( entityDeclaration . getN (  )  ,    entityDeclaration . getPublicId (  )  ,    entityDeclaration . getSystemId (  )  ,    entityDeclaration . getNotationN (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleEntityDeclaration"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "getLexicalHandler (  )  . startEntity ( reference . getN (  )  )  ;", "}", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "getLexicalHandler (  )  . endEntity ( reference . getN (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleEntityReference"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getDTDHandler (  )  )     !  =    null )     {", "getDTDHandler (  )  . notationDecl ( declaration . getN (  )  ,    declaration . getPublicId (  )  ,    declaration . getSystemId (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleNotationDeclaration"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "getContentHandler (  )  . processingInstruction ( pi . getTarget (  )  ,    pi . getData (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleProcessingInstruction"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    ( event . isStartDocument (  )  )     {", "StartDocument   startDocument    =     (  ( StartDocument )     ( event )  )  ;", "String   xmlVersion    =    startDocument . getVersion (  )  ;", "if    ( StringUtils . hasLength ( xmlVersion )  )     {", "this . xmlVersion    =    xmlVersion ;", "}", "if    ( startDocument . encodingSet (  )  )     {", "this . encoding    =    startDocument . getCharacterEncodingScheme (  )  ;", "}", "}", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "final   Location   location    =    event . getLocation (  )  ;", "getContentHandler (  )  . setDocumentLocator ( new   Locator 2  (  )     {", "@ Override", "public   int   getColumnNumber (  )     {", "return   location    !  =    null    ?    location . getColumnNumber (  )     :     -  1  ;", "}", "@ Override", "public   int   getLineNumber (  )     {", "return   location    !  =    null    ?    location . getLineNumber (  )     :     -  1  ;", "}", "@ Override", "@ Nullable", "public   String   getPublicId (  )     {", "return   location    !  =    null    ?    location . getPublicId (  )     :    null ;", "}", "@ Override", "@ Nullable", "public   String   getSystemId (  )     {", "return   location    !  =    null    ?    location . getSystemId (  )     :    null ;", "}", "@ Override", "public   String   getXMLVersion (  )     {", "return   xmlVersion ;", "}", "@ Override", "@ Nullable", "public   String   getEncoding (  )     {", "return   encoding ;", "}", "}  )  ;", "getContentHandler (  )  . startDocument (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleStartDocument"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "QName   qName    =    startElement . getName (  )  ;", "if    ( hasNamespacesFeature (  )  )     {", "for    ( Iterator   i    =    startElement . getNamespaces (  )  ;    i . hasNext (  )  ;  )     {", "Namespace   namespace    =     (  ( Namespace )     ( i . next (  )  )  )  ;", "startPrefixMapping ( namespace . getPrefix (  )  ,    namespace . getNamespaceURI (  )  )  ;", "}", "for    ( Iterator   i    =    startElement . getAttributes (  )  ;    i . hasNext (  )  ;  )     {", "Attribute   attribute    =     (  ( Attribute )     ( i . next (  )  )  )  ;", "QName   attributeName    =    attribute . getName (  )  ;", "startPrefixMapping ( attributeName . getPrefix (  )  ,    attributeName . getNamespaceURI (  )  )  ;", "}", "getContentHandler (  )  . startElement ( qName . getNamespaceURI (  )  ,    qName . getLocalPart (  )  ,    toQualifiedName ( qName )  ,    getAttributes ( startElement )  )  ;", "} else    {", "getContentHandler (  )  . startElement (  \"  \"  ,     \"  \"  ,    toQualifiedName ( qName )  ,    getAttributes ( startElement )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleStartElement"], "fileName": "org.springframework.util.xml.StaxEventXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "XMLEventReader   eventReader    =    inputFactory . createXMLEventReader ( new   StringReader (  . CONTENT )  )  ;", "eventReader . nextTag (  )  ;", "StaxEventXMLReader   xmlReader    =    new   StaxEventXMLReader ( eventReader )  ;", "ContentHandler   contentHandler    =    mock ( ContentHandler . class )  ;", "xmlReader . setContentHandler ( contentHandler )  ;", "xmlReader . parse ( new   InputSource (  )  )  ;", "verify ( contentHandler )  . startDocument (  )  ;", "verify ( contentHandler )  . startElement ( eq (  \" http :  /  / springframework . org / spring - ws \"  )  ,    eq (  \" child \"  )  ,    eq (  \" child \"  )  ,    any ( Attributes . class )  )  ;", "verify ( contentHandler )  . endElement (  \" http :  /  / springframework . org / spring - ws \"  ,     \" child \"  ,     \" child \"  )  ;", "verify ( contentHandler )  . endDocument (  )  ;", "}", "METHOD_END"], "methodName": ["partial"], "fileName": "org.springframework.util.xml.StaxEventXMLReaderTests"}, {"methodBody": ["METHOD_START", "{", "return   this . eventWriter ;", "}", "METHOD_END"], "methodName": ["getXMLEventWriter"], "fileName": "org.springframework.util.xml.StaxResult"}, {"methodBody": ["METHOD_START", "{", "return   this . streamWriter ;", "}", "METHOD_END"], "methodName": ["getXMLStreamWriter"], "fileName": "org.springframework.util.xml.StaxResult"}, {"methodBody": ["METHOD_START", "{", "StringWriter   stringWriter    =    new   StringWriter (  )  ;", "XMLEventWriter   eventWriter    =    inputFactory . createXMLEventWriter ( stringWriter )  ;", "Reader   reader    =    new   StringReader (  . XML )  ;", "Source   source    =    new   StreamSource ( reader )  ;", "StaxResult   result    =    new   StaxResult ( eventWriter )  ;", "Assert . assertEquals (  \" Invalid   eventWriter   returned \"  ,    eventWriter ,    result . getXMLEventWriter (  )  )  ;", "Assert . assertNull (  \" StreamWriter   returned \"  ,    result . getXMLStreamWriter (  )  )  ;", "transformer . transform ( source ,    result )  ;", "Assert . assertThat (  \" Invalid   result \"  ,    stringWriter . toString (  )  ,    isSimilarTo (  . XML )  )  ;", "}", "METHOD_END"], "methodName": ["eventWriterSource"], "fileName": "org.springframework.util.xml.StaxResultTests"}, {"methodBody": ["METHOD_START", "{", "TransformerFactory   transformerFactory    =    TransformerFactory . newInstance (  )  ;", "transformer    =    transformerFactory . newTransformer (  )  ;", "inputFactory    =    XMLOutputFactory . newInstance (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.util.xml.StaxResultTests"}, {"methodBody": ["METHOD_START", "{", "StringWriter   stringWriter    =    new   StringWriter (  )  ;", "XMLStreamWriter   streamWriter    =    inputFactory . createXMLStreamWriter ( stringWriter )  ;", "Reader   reader    =    new   StringReader (  . XML )  ;", "Source   source    =    new   StreamSource ( reader )  ;", "StaxResult   result    =    new   StaxResult ( streamWriter )  ;", "Assert . assertEquals (  \" Invalid   streamWriter   returned \"  ,    streamWriter ,    result . getXMLStreamWriter (  )  )  ;", "Assert . assertNull (  \" EventWriter   returned \"  ,    result . getXMLEventWriter (  )  )  ;", "transformer . transform ( source ,    result )  ;", "Assert . assertThat (  \" Invalid   result \"  ,    stringWriter . toString (  )  ,    isSimilarTo (  . XML )  )  ;", "}", "METHOD_END"], "methodName": ["streamWriterSource"], "fileName": "org.springframework.util.xml.StaxResultTests"}, {"methodBody": ["METHOD_START", "{", "return   this . eventReader ;", "}", "METHOD_END"], "methodName": ["getXMLEventReader"], "fileName": "org.springframework.util.xml.StaxSource"}, {"methodBody": ["METHOD_START", "{", "return   this . streamReader ;", "}", "METHOD_END"], "methodName": ["getXMLStreamReader"], "fileName": "org.springframework.util.xml.StaxSource"}, {"methodBody": ["METHOD_START", "{", "XMLEventReader   eventReader    =    inputFactory . createXMLEventReader ( new   StringReader ( StaxSourceTests . XML )  )  ;", "StaxSource   source    =    new   StaxSource ( eventReader )  ;", "Assert . assertEquals (  \" Invalid   eventReader   returned \"  ,    eventReader ,    source . getXMLEventReader (  )  )  ;", "Assert . assertNull (  \" StreamReader   returned \"  ,    source . getXMLStreamReader (  )  )  ;", "Document   expected    =    documentBuilder . parse ( new   InputSource ( new   StringReader ( StaxSourceTests . XML )  )  )  ;", "Document   result    =    documentBuilder . newDocument (  )  ;", "transformer . transform ( source ,    new   DOMResult ( result )  )  ;", "Assert . assertThat (  \" Invalid   result \"  ,    result ,    isSimilarTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["eventReaderSourceToDOMResult"], "fileName": "org.springframework.util.xml.StaxSourceTests"}, {"methodBody": ["METHOD_START", "{", "XMLEventReader   eventReader    =    inputFactory . createXMLEventReader ( new   StringReader ( StaxSourceTests . XML )  )  ;", "StaxSource   source    =    new   StaxSource ( eventReader )  ;", "Assert . assertEquals (  \" Invalid   eventReader   returned \"  ,    eventReader ,    source . getXMLEventReader (  )  )  ;", "Assert . assertNull (  \" StreamReader   returned \"  ,    source . getXMLStreamReader (  )  )  ;", "StringWriter   writer    =    new   StringWriter (  )  ;", "transformer . transform ( source ,    new   StreamResult ( writer )  )  ;", "Assert . assertThat (  \" Invalid   result \"  ,    writer . toString (  )  ,    isSimilarTo ( StaxSourceTests . XML )  )  ;", "}", "METHOD_END"], "methodName": ["eventReaderSourceToStreamResult"], "fileName": "org.springframework.util.xml.StaxSourceTests"}, {"methodBody": ["METHOD_START", "{", "TransformerFactory   transformerFactory    =    TransformerFactory . newInstance (  )  ;", "transformer    =    transformerFactory . newTransformer (  )  ;", "inputFactory    =    XMLInputFactory . newInstance (  )  ;", "DocumentBuilderFactory   documentBuilderFactory    =    DocumentBuilderFactory . newInstance (  )  ;", "documentBuilderFactory . setNspaceAware ( true )  ;", "documentBuilder    =    documentBuilderFactory . newDocumentBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.util.xml.StaxSourceTests"}, {"methodBody": ["METHOD_START", "{", "XMLStreamReader   streamReader    =    inputFactory . createXMLStreamReader ( new   StringReader ( StaxSourceTests . XML )  )  ;", "StaxSource   source    =    new   StaxSource ( streamReader )  ;", "Assert . assertEquals (  \" Invalid   streamReader   returned \"  ,    streamReader ,    source . getXMLStreamReader (  )  )  ;", "Assert . assertNull (  \" EventReader   returned \"  ,    source . getXMLEventReader (  )  )  ;", "Document   expected    =    documentBuilder . parse ( new   InputSource ( new   StringReader ( StaxSourceTests . XML )  )  )  ;", "Document   result    =    documentBuilder . newDocument (  )  ;", "transformer . transform ( source ,    new   DOMResult ( result )  )  ;", "Assert . assertThat (  \" Invalid   result \"  ,    result ,    isSimilarTo ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["streamReaderSourceToDOMResult"], "fileName": "org.springframework.util.xml.StaxSourceTests"}, {"methodBody": ["METHOD_START", "{", "XMLStreamReader   streamReader    =    inputFactory . createXMLStreamReader ( new   StringReader ( StaxSourceTests . XML )  )  ;", "StaxSource   source    =    new   StaxSource ( streamReader )  ;", "Assert . assertEquals (  \" Invalid   streamReader   returned \"  ,    streamReader ,    source . getXMLStreamReader (  )  )  ;", "Assert . assertNull (  \" EventReader   returned \"  ,    source . getXMLEventReader (  )  )  ;", "StringWriter   writer    =    new   StringWriter (  )  ;", "transformer . transform ( source ,    new   StreamResult ( writer )  )  ;", "Assert . assertThat (  \" Invalid   result \"  ,    writer . toString (  )  ,    isSimilarTo ( StaxSourceTests . XML )  )  ;", "}", "METHOD_END"], "methodName": ["streamReaderSourceToStreamResult"], "fileName": "org.springframework.util.xml.StaxSourceTests"}, {"methodBody": ["METHOD_START", "{", "AttributesImpl   attributes    =    new   AttributesImpl (  )  ;", "for    ( int   i    =     0  ;    i    <     ( this . r . getAttributeCount (  )  )  ;    i +  +  )     {", "String   namespace    =    this . r . getAttributeNamespace ( i )  ;", "if    (  ( namespace    =  =    null )     |  |     (  !  ( hasNamespacesFeature (  )  )  )  )     {", "namespace    =     \"  \"  ;", "}", "String   type    =    this . r . getAttributeType ( i )  ;", "if    ( type    =  =    null )     {", "type    =     \" CDATA \"  ;", "}", "attributes . addAttribute ( namespace ,    this . r . getAttributeLocalName ( i )  ,    toQualifiedName ( this . r . getAttributeName ( i )  )  ,    type ,    this . r . getAttributeValue ( i )  )  ;", "}", "if    ( hasNamespacePrefixesFeature (  )  )     {", "for    ( int   i    =     0  ;    i    <     ( this . r . getNamespaceCount (  )  )  ;    i +  +  )     {", "String   prefix    =    this . r . getNamespacePrefix ( i )  ;", "String   namespaceUri    =    this . r . getNamespaceURI ( i )  ;", "String   qName ;", "if    ( StringUtils . hasLength ( prefix )  )     {", "qName    =     \" xmlns :  \"     +    prefix ;", "} else    {", "qName    =     \" xmlns \"  ;", "}", "attributes . addAttribute (  \"  \"  ,     \"  \"  ,    qName ,     \" CDATA \"  ,    namespaceUri )  ;", "}", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( XMLStreamConstants . CDATA )     =  =     ( this . reader . getEventType (  )  )  )     &  &     (  ( getLexicalHandler (  )  )     !  =    null )  )     {", "getLexicalHandler (  )  . startCDATA (  )  ;", "}", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "getContentHandler (  )  . characters ( this . reader . getTextCharacters (  )  ,    this . reader . getTextStart (  )  ,    this . reader . getTextLength (  )  )  ;", "}", "if    (  (  ( XMLStreamConstants . CDATA )     =  =     ( this . reader . getEventType (  )  )  )     &  &     (  ( getLexicalHandler (  )  )     !  =    null )  )     {", "getLexicalHandler (  )  . endCDATA (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleCharacters"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "getLexicalHandler (  )  . comment ( this . r . getTextCharacters (  )  ,    this . r . getTextStart (  )  ,    this . r . getTextLength (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleComment"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "Location   location    =    this . r . getLocation (  )  ;", "getLexicalHandler (  )  . startDTD ( null ,    location . getPublicId (  )  ,    location . getSystemId (  )  )  ;", "}", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "getLexicalHandler (  )  . endDTD (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleDtd"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "getContentHandler (  )  . endDocument (  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleEndDocument"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "QName   qName    =    this . r . getName (  )  ;", "if    ( hasNamespacesFeature (  )  )     {", "getContentHandler (  )  . endElement ( qName . getNamespaceURI (  )  ,    qName . getLocalPart (  )  ,    toQualifiedName ( qName )  )  ;", "for    ( int   i    =     0  ;    i    <     ( this . r . getNamespaceCount (  )  )  ;    i +  +  )     {", "String   prefix    =    this . r . getNamespacePrefix ( i )  ;", "if    ( prefix    =  =    null )     {", "prefix    =     \"  \"  ;", "}", "endPrefixMapping ( prefix )  ;", "}", "} else    {", "getContentHandler (  )  . endElement (  \"  \"  ,     \"  \"  ,    toQualifiedName ( qName )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleEndElement"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "getLexicalHandler (  )  . startEntity ( this . r . getLocalName (  )  )  ;", "}", "if    (  ( getLexicalHandler (  )  )     !  =    null )     {", "getLexicalHandler (  )  . endEntity ( this . r . getLocalName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleEntityReference"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "getContentHandler (  )  . processingInstruction ( this . r . getPITarget (  )  ,    this . r . getPIData (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleProcessingInstruction"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( XMLStreamConstants . START _ DOCUMENT )     =  =     ( this . reader . getEventType (  )  )  )     {", "String   xmlVersion    =    this . reader . getVersion (  )  ;", "if    ( StringUtils . hasLength ( xmlVersion )  )     {", "this . xmlVersion    =    xmlVersion ;", "}", "this . encoding    =    this . reader . getCharacterEncodingScheme (  )  ;", "}", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "final   Location   location    =    this . reader . getLocation (  )  ;", "getContentHandler (  )  . setDocumentLocator ( new   Locator 2  (  )     {", "@ Override", "public   int   getColumnNumber (  )     {", "return   location    !  =    null    ?    location . getColumnNumber (  )     :     -  1  ;", "}", "@ Override", "public   int   getLineNumber (  )     {", "return   location    !  =    null    ?    location . getLineNumber (  )     :     -  1  ;", "}", "@ Override", "@ Nullable", "public   String   getPublicId (  )     {", "return   location    !  =    null    ?    location . getPublicId (  )     :    null ;", "}", "@ Override", "@ Nullable", "public   String   getSystemId (  )     {", "return   location    !  =    null    ?    location . getSystemId (  )     :    null ;", "}", "@ Override", "public   String   getXMLVersion (  )     {", "return   xmlVersion ;", "}", "@ Override", "@ Nullable", "public   String   getEncoding (  )     {", "return   encoding ;", "}", "}  )  ;", "getContentHandler (  )  . startDocument (  )  ;", "if    ( this . reader . standaloneSet (  )  )     {", "setStandalone ( this . reader . isStandalone (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleStartDocument"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getContentHandler (  )  )     !  =    null )     {", "QName   qName    =    this . r . getName (  )  ;", "if    ( hasNamespacesFeature (  )  )     {", "for    ( int   i    =     0  ;    i    <     ( this . r . getNamespaceCount (  )  )  ;    i +  +  )     {", "startPrefixMapping ( this . r . getNamespacePrefix ( i )  ,    this . r . getNamespaceURI ( i )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( this . r . getAttributeCount (  )  )  ;    i +  +  )     {", "String   prefix    =    this . r . getAttributePrefix ( i )  ;", "String   namespace    =    this . r . getAttributeNamespace ( i )  ;", "if    ( StringUtils . hasLength ( namespace )  )     {", "startPrefixMapping ( prefix ,    namespace )  ;", "}", "}", "getContentHandler (  )  . startElement ( qName . getNamespaceURI (  )  ,    qName . getLocalPart (  )  ,    toQualifiedName ( qName )  ,    getAttributes (  )  )  ;", "} else    {", "getContentHandler (  )  . startElement (  \"  \"  ,     \"  \"  ,    toQualifiedName ( qName )  ,    getAttributes (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleStartElement"], "fileName": "org.springframework.util.xml.StaxStreamXMLReader"}, {"methodBody": ["METHOD_START", "{", "XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "XMLStreamReader   streamReader    =    inputFactory . createXMLStreamReader ( new   StringReader (  . CONTENT )  )  ;", "streamReader . nextTag (  )  ;", "assertEquals (  \" Invalid   element \"  ,    new   QName (  \" http :  /  / springframework . org / spring - ws \"  ,     \" root \"  )  ,    streamReader . getName (  )  )  ;", "streamReader . nextTag (  )  ;", "assertEquals (  \" Invalid   element \"  ,    new   QName (  \" http :  /  / springframework . org / spring - ws \"  ,     \" child \"  )  ,    streamReader . getName (  )  )  ;", "StaxStreamXMLReader   xmlReader    =    new   StaxStreamXMLReader ( streamReader )  ;", "ContentHandler   contentHandler    =    mock ( ContentHandler . class )  ;", "xmlReader . setContentHandler ( contentHandler )  ;", "xmlReader . parse ( new   InputSource (  )  )  ;", "verify ( contentHandler )  . setDocumentLocator ( any ( Locator . class )  )  ;", "verify ( contentHandler )  . startDocument (  )  ;", "verify ( contentHandler )  . startElement ( eq (  \" http :  /  / springframework . org / spring - ws \"  )  ,    eq (  \" child \"  )  ,    eq (  \" child \"  )  ,    any ( Attributes . class )  )  ;", "verify ( contentHandler )  . endElement (  \" http :  /  / springframework . org / spring - ws \"  ,     \" child \"  ,     \" child \"  )  ;", "verify ( contentHandler )  . endDocument (  )  ;", "}", "METHOD_END"], "methodName": ["partial"], "fileName": "org.springframework.util.xml.StaxStreamXMLReaderTests"}, {"methodBody": ["METHOD_START", "{", "return   new   StaxEventHandler ( eventWriter )  ;", "}", "METHOD_END"], "methodName": ["createContentHandler"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StaxStreamHandler ( streamWriter )  ;", "}", "METHOD_END"], "methodName": ["createContentHandler"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StaxResult ( eventWriter )  ;", "}", "METHOD_END"], "methodName": ["createCustomStaxResult"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StaxResult ( streamWriter )  ;", "}", "METHOD_END"], "methodName": ["createCustomStaxResult"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StaxSource ( eventReader )  ;", "}", "METHOD_END"], "methodName": ["createCustomStaxSource"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StaxSource ( streamReader )  ;", "}", "METHOD_END"], "methodName": ["createCustomStaxSource"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "inputFactory . setProperty ( XMLInputFactory . SUPPORT _ DTD ,    false )  ;", "inputFactory . setProperty ( XMLInputFactory . IS _ SUPPORTING _ EXTERNAL _ ENTITIES ,    false )  ;", "inputFactory . setXMLResolver (  . NO _ OP _ XML _ RESOLVER )  ;", "return   inputFactory ;", "}", "METHOD_END"], "methodName": ["createDefensiveInputFactory"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   XMLEventStreamReader ( eventReader )  ;", "}", "METHOD_END"], "methodName": ["createEventStreamReader"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   XMLEventStreamWriter ( eventWriter ,    XMLEventFactory . newFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["createEventStreamWriter"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   XMLEventStreamWriter ( eventWriter ,    eventFactory )  ;", "}", "METHOD_END"], "methodName": ["createEventStreamWriter"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StAXResult ( eventWriter )  ;", "}", "METHOD_END"], "methodName": ["createStaxResult"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StAXResult ( streamWriter )  ;", "}", "METHOD_END"], "methodName": ["createStaxResult"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StAXSource ( eventReader )  ;", "}", "METHOD_END"], "methodName": ["createStaxSource"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StAXSource ( streamReader )  ;", "}", "METHOD_END"], "methodName": ["createStaxSource"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   ListBasedXMLEventReader ( events )  ;", "}", "METHOD_END"], "methodName": ["createXMLEventReader"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StaxEventXMLReader ( eventReader )  ;", "}", "METHOD_END"], "methodName": ["createXMLReader"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   StaxStreamXMLReader ( streamReader )  ;", "}", "METHOD_END"], "methodName": ["createXMLReader"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( source   instanceof   StAXSource )     {", "return    (  ( StAXSource )     ( source )  )  . getXMLEventReader (  )  ;", "} else", "if    ( source   instanceof   Source )     {", "return    (  ( Source )     ( source )  )  . getXMLEventReader (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Source    '  \"     +    source )     +     \"  '    is   neither   Source   nor   StAXSource \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getXMLEventReader"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( result   instanceof   StAXResult )     {", "return    (  ( StAXResult )     ( result )  )  . getXMLEventWriter (  )  ;", "} else", "if    ( result   instanceof   Result )     {", "return    (  ( Result )     ( result )  )  . getXMLEventWriter (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Result    '  \"     +    result )     +     \"  '    is   neither   Result   nor   StAXResult \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getXMLEventWriter"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( source   instanceof   StAXSource )     {", "return    (  ( StAXSource )     ( source )  )  . getXMLStreamReader (  )  ;", "} else", "if    ( source   instanceof   Source )     {", "return    (  ( Source )     ( source )  )  . getXMLStreamReader (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Source    '  \"     +    source )     +     \"  '    is   neither   Source   nor   StAXSource \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getXMLStreamReader"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( result   instanceof   StAXResult )     {", "return    (  ( StAXResult )     ( result )  )  . getXMLStreamWriter (  )  ;", "} else", "if    ( result   instanceof   Result )     {", "return    (  ( Result )     ( result )  )  . getXMLStreamWriter (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Result    '  \"     +    result )     +     \"  '    is   neither   Result   nor   StAXResult \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getXMLStreamWriter"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( result   instanceof   StAXResult )     |  |     ( result   instanceof   StaxResult )  ;", "}", "METHOD_END"], "methodName": ["isStaxResult"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( source   instanceof   StAXSource )     |  |     ( source   instanceof   StaxSource )  ;", "}", "METHOD_END"], "methodName": ["isStaxSource"], "fileName": "org.springframework.util.xml.StaxUtils"}, {"methodBody": ["METHOD_START", "{", "XMLOutputFactory   outputFactory    =    XMLOutputFactory . newInstance (  )  ;", "XMLStreamWriter   streamWriter    =    outputFactory . createXMLStreamWriter ( new   StringWriter (  )  )  ;", "Result   result    =     . createCustomStaxResult ( streamWriter )  ;", "assertTrue (  \" Not   a   StAX   Result \"  ,     . isStaxResult ( result )  )  ;", "}", "METHOD_END"], "methodName": ["isStaxResult"], "fileName": "org.springframework.util.xml.StaxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" A   StAX   Result \"  ,    StaxUtils . isStaxResult ( new   DOMResult (  )  )  )  ;", "assertFalse (  \" A   StAX   Result \"  ,    StaxUtils . isStaxResult ( new   SAXResult (  )  )  )  ;", "assertFalse (  \" A   StAX   Result \"  ,    StaxUtils . isStaxResult ( new   StreamResult (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isStaxResultInvalid"], "fileName": "org.springframework.util.xml.StaxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "XMLOutputFactory   outputFactory    =    XMLOutputFactory . newInstance (  )  ;", "XMLStreamWriter   streamWriter    =    outputFactory . createXMLStreamWriter ( new   StringWriter (  )  )  ;", "StAXResult   result    =    new   StAXResult ( streamWriter )  ;", "assertTrue (  \" Not   a   StAX   Result \"  ,     . isStaxResult ( result )  )  ;", "}", "METHOD_END"], "methodName": ["isStaxResultJaxp14"], "fileName": "org.springframework.util.xml.StaxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "String   expected    =     \"  < element /  >  \"  ;", "XMLStreamReader   streamReader    =    inputFactory . createXMLStreamReader ( new   StringReader ( expected )  )  ;", "Source   source    =     . createCustomStaxSource ( streamReader )  ;", "assertTrue (  \" Not   a   StAX   Source \"  ,     . isStaxSource ( source )  )  ;", "}", "METHOD_END"], "methodName": ["isStaxSource"], "fileName": "org.springframework.util.xml.StaxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse (  \" A   StAX   Source \"  ,    StaxUtils . isStaxSource ( new   DOMSource (  )  )  )  ;", "assertFalse (  \" A   StAX   Source \"  ,    StaxUtils . isStaxSource ( new   SAXSource (  )  )  )  ;", "assertFalse (  \" A   StAX   Source \"  ,    StaxUtils . isStaxSource ( new   StreamSource (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isStaxSourceInvalid"], "fileName": "org.springframework.util.xml.StaxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "String   expected    =     \"  < element /  >  \"  ;", "XMLStreamReader   streamReader    =    inputFactory . createXMLStreamReader ( new   StringReader ( expected )  )  ;", "StAXSource   source    =    new   StAXSource ( streamReader )  ;", "assertTrue (  \" Not   a   StAX   Source \"  ,     . isStaxSource ( source )  )  ;", "}", "METHOD_END"], "methodName": ["isStaxSourceJaxp14"], "fileName": "org.springframework.util.xml.StaxUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( transformer ,     \" Transformer   must   not   be   null \"  )  ;", "transformer . setOutputProperty ( OutputKeys . INDENT ,     \" no \"  )  ;", "}", "METHOD_END"], "methodName": ["disableIndenting"], "fileName": "org.springframework.util.xml.TransformerUtils"}, {"methodBody": ["METHOD_START", "{", "TransformerUtils . enableIndenting ( transformer ,    TransformerUtils . DEFAULT _ INDENT _ AMOUNT )  ;", "}", "METHOD_END"], "methodName": ["enableIndenting"], "fileName": "org.springframework.util.xml.TransformerUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( transformer ,     \" Transformer   must   not   be   null \"  )  ;", "if    ( indentAmount    <     0  )     {", "throw   new   IllegalArgumentException (  (  \" Invalid   indent   amount    ( must   not   be   less   than   zero )  :     \"     +    indentAmount )  )  ;", "}", "transformer . setOutputProperty ( OutputKeys . INDENT ,     \" yes \"  )  ;", "try    {", "transformer . setOutputProperty (  \"  { http :  /  / xml . apache . org / xslt } indent - amount \"  ,    String . valueOf ( indentAmount )  )  ;", "}    catch    ( IllegalArgumentException   ignored )     {", "}", "}", "METHOD_END"], "methodName": ["enableIndenting"], "fileName": "org.springframework.util.xml.TransformerUtils"}, {"methodBody": ["METHOD_START", "{", "Transformer   transformer    =    new   TransformerUtilsTests . StubTransformer (  )  ;", "TransformerUtils . disableIndenting ( transformer )  ;", "String   indent    =    transformer . getOutputProperty ( OutputKeys . INDENT )  ;", "assertNotNull ( indent )  ;", "assertEquals (  \" no \"  ,    indent )  ;", "}", "METHOD_END"], "methodName": ["disableIndentingSunnyDay"], "fileName": "org.springframework.util.xml.TransformerUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TransformerUtils . disableIndenting ( null )  ;", "}", "METHOD_END"], "methodName": ["disableIndentingWithNullTransformer"], "fileName": "org.springframework.util.xml.TransformerUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Transformer   transformer    =    new   TransformerUtilsTests . StubTransformer (  )  ;", "TransformerUtils . enableIndenting ( transformer )  ;", "String   indent    =    transformer . getOutputProperty ( OutputKeys . INDENT )  ;", "assertNotNull ( indent )  ;", "assertEquals (  \" yes \"  ,    indent )  ;", "String   indentAmount    =    transformer . getOutputProperty (  \"  { http :  /  / xml . apache . org / xslt } indent - amount \"  )  ;", "assertNotNull ( indentAmount )  ;", "assertEquals ( String . valueOf ( TransformerUtils . DEFAULT _ INDENT _ AMOUNT )  ,    indentAmount )  ;", "}", "METHOD_END"], "methodName": ["enableIndentingSunnyDay"], "fileName": "org.springframework.util.xml.TransformerUtilsTests"}, {"methodBody": ["METHOD_START", "{", "final   String   indentAmountProperty    =     \"  1  0  \"  ;", "Transformer   transformer    =    new    . StubTransformer (  )  ;", "TransformerUtils . enableIndenting ( transformer ,    Integer . valueOf ( indentAmountProperty )  )  ;", "String   indent    =    transformer . getOutputProperty ( OutputKeys . INDENT )  ;", "assertNotNull ( indent )  ;", "assertEquals (  \" yes \"  ,    indent )  ;", "String   indentAmount    =    transformer . getOutputProperty (  \"  { http :  /  / xml . apache . org / xslt } indent - amount \"  )  ;", "assertNotNull ( indentAmount )  ;", "assertEquals ( indentAmountProperty ,    indentAmount )  ;", "}", "METHOD_END"], "methodName": ["enableIndentingSunnyDayWithCustomKosherIndentAmount"], "fileName": "org.springframework.util.xml.TransformerUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TransformerUtils . enableIndenting ( new   TransformerUtilsTests . StubTransformer (  )  ,     (  -  2  1  9  3  8  )  )  ;", "}", "METHOD_END"], "methodName": ["enableIndentingWithNegativeIndentAmount"], "fileName": "org.springframework.util.xml.TransformerUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TransformerUtils . enableIndenting ( null )  ;", "}", "METHOD_END"], "methodName": ["enableIndentingWithNullTransformer"], "fileName": "org.springframework.util.xml.TransformerUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TransformerUtils . enableIndenting ( new   TransformerUtilsTests . StubTransformer (  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["enableIndentingWithZeroIndentAmount"], "fileName": "org.springframework.util.xml.TransformerUtilsTests"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "while    ( iterator . hasNext (  )  )     {", "iterator . next (  )  ;", "count +  +  ;", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["countIterator"], "fileName": "org.springframework.util.xml.XMLEventStreamReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . event . isStartElement (  )  )  )     {", "throw   new   IllegalStateException (  )  ;", "}", "int   count    =     0  ;", "Iterator   attributes    =    this . event . asStartElement (  )  . getAttributes (  )  ;", "while    ( attributes . hasNext (  )  )     {", "Attribute   attribute    =     (  ( Attribute )     ( attributes . next (  )  )  )  ;", "if    ( count    =  =    index )     {", "return   attribute ;", "} else    {", "count +  +  ;", "}", "}", "throw   new   IllegalArgumentException (  )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.springframework.util.xml.XMLEventStreamReader"}, {"methodBody": ["METHOD_START", "{", "Iterator   namespaces ;", "if    ( this . e . isStartElement (  )  )     {", "namespaces    =    this . e . asStartElement (  )  . getNamespaces (  )  ;", "} else", "if    ( this . e . isEndElement (  )  )     {", "namespaces    =    this . e . asEndElement (  )  . getNamespaces (  )  ;", "} else    {", "throw   new   IllegalStateException (  )  ;", "}", "int   count    =     0  ;", "while    ( namespaces . hasNext (  )  )     {", "Namespace   namespace    =     (  ( Namespace )     ( namespaces . next (  )  )  )  ;", "if    ( count    =  =    index )     {", "return   namespace ;", "} else    {", "count +  +  ;", "}", "}", "throw   new   IllegalArgumentException (  )  ;", "}", "METHOD_END"], "methodName": ["getNamespace"], "fileName": "org.springframework.util.xml.XMLEventStreamReader"}, {"methodBody": ["METHOD_START", "{", "XMLInputFactory   inputFactory    =    XMLInputFactory . newInstance (  )  ;", "XMLEventReader   eventReader    =    inputFactory . createXMLEventReader ( new   StringReader (  . XML )  )  ;", "streamReader    =    new   XMLEventStreamReader ( eventReader )  ;", "}", "METHOD_END"], "methodName": ["createStreamReader"], "fileName": "org.springframework.util.xml.XMLEventStreamReaderTests"}, {"methodBody": ["METHOD_START", "{", "while    ( streamReader . hasNext (  )  )     {", "streamReader . next (  )  ;", "}", "}", "METHOD_END"], "methodName": ["readAll"], "fileName": "org.springframework.util.xml.XMLEventStreamReaderTests"}, {"methodBody": ["METHOD_START", "{", "Transformer   transformer    =    TransformerFactory . newInstance (  )  . newTransformer (  )  ;", "StAXSource   source    =    new   StAXSource ( streamReader )  ;", "StringWriter   writer    =    new   StringWriter (  )  ;", "transformer . transform ( source ,    new   StreamResult ( writer )  )  ;", "Predicate < Node >    nodeFilter    =     (    n )     -  >     (  ( n . getNodeType (  )  )     !  =    Node . DOCUMENT _ TYPE _ NODE )     &  &     (  ( n . getNodeType (  )  )     !  =    Node . PROCESSING _ INSTRUCTION _ NODE )  ;", "Assert . assertThat ( writer . toString (  )  ,    isSimilarTo (  . XML )  . withNodeFilter ( nodeFilter )  )  ;", "}", "METHOD_END"], "methodName": ["readCorrect"], "fileName": "org.springframework.util.xml.XMLEventStreamReaderTests"}, {"methodBody": ["METHOD_START", "{", "if    ( this . emptyElement )     {", "this . emptyElement    =    false ;", "wEndElement (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeEmptyElementIfNecessary"], "fileName": "org.springframework.util.xml.XMLEventStreamWriter"}, {"methodBody": ["METHOD_START", "{", "int   last    =     ( this . endElements . size (  )  )     -     1  ;", "EndElement   oldEndElement    =    this . endElements . get ( last )  ;", "Iterator   oldNamespaces    =    oldEndElement . getNamespaces (  )  ;", "List < Namespace >    newNamespaces    =    new   ArrayList <  >  (  )  ;", "while    ( oldNamespaces . hasNext (  )  )     {", "Namespace   oldNamespace    =     (  ( Namespace )     ( oldNamespaces . next (  )  )  )  ;", "newNamespaces . add ( oldNamespace )  ;", "}", "newNamespaces . add ( namespace )  ;", "EndElement   newEndElement    =    this . eventFactory . createEndElement ( oldEndElement . getName (  )  ,    newNamespaces . iterator (  )  )  ;", "this . event . add ( namespace )  ;", "this . endElements . set ( last ,    newEndElement )  ;", "}", "METHOD_END"], "methodName": ["doWriteNamespace"], "fileName": "org.springframework.util.xml.XMLEventStreamWriter"}, {"methodBody": ["METHOD_START", "{", "this . eventWriter . add ( startElement )  ;", "this . endElements . add ( this . eventFactory . createEndElement ( startElement . getName (  )  ,    startElement . getNamespaces (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doWriteStartElement"], "fileName": "org.springframework.util.xml.XMLEventStreamWriter"}, {"methodBody": ["METHOD_START", "{", "stringWriter    =    new   StringWriter (  )  ;", "XMLOutputFactory   outputFactory    =    XMLOutputFactory . newInstance (  )  ;", "XMLEventWriter   eventWriter    =    outputFactory . createXMLEventWriter ( stringWriter )  ;", "streamWriter    =    new    ( eventWriter ,    XMLEventFactory . newInstance (  )  )  ;", "}", "METHOD_END"], "methodName": ["createStreamReader"], "fileName": "org.springframework.util.xml.XMLEventStreamWriterTests"}, {"methodBody": ["METHOD_START", "{", "streamWriter . writeStartDocument (  )  ;", "streamWriter . writeProcessingInstruction (  \" pi \"  ,     \" content \"  )  ;", "streamWriter . writeStartElement (  \" namespace \"  ,     \" root \"  )  ;", "streamWriter . writeDefaultNamespace (  \" namespace \"  )  ;", "streamWriter . writeStartElement (  \" prefix \"  ,     \" child \"  ,     \" namespace 2  \"  )  ;", "streamWriter . writeNamespace (  \" prefix \"  ,     \" namespace 2  \"  )  ;", "streamWriter . writeComment (  \" comment \"  )  ;", "streamWriter . writeCharacters (  \" content \"  )  ;", "streamWriter . writeEndElement (  )  ;", "streamWriter . writeEndElement (  )  ;", "streamWriter . writeEndDocument (  )  ;", "Predicate < Node >    nodeFilter    =     (    n )     -  >     (  ( n . getNodeType (  )  )     !  =    Node . DOCUMENT _ TYPE _ NODE )     &  &     (  ( n . getNodeType (  )  )     !  =    Node . PROCESSING _ INSTRUCTION _ NODE )  ;", "Assert . assertThat ( stringWriter . toString (  )  ,    isSimilarTo (  . XML )  . withNodeFilter ( nodeFilter )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.springframework.util.xml.XMLEventStreamWriterTests"}, {"methodBody": ["METHOD_START", "{", "int   index    =    line . indexOf ( token )  ;", "if    ( index    >     (  -  1  )  )     {", "this . inComment    =    inCommentIfPresent ;", "}", "return   index    =  =     (  -  1  )     ?    index    :    index    +     ( token . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["commentToken"], "fileName": "org.springframework.util.xml.XmlValidationModeDetector"}, {"methodBody": ["METHOD_START", "{", "int   index    =     ( this . inComment )     ?    endComment ( line )     :    startComment ( line )  ;", "return   index    =  =     (  -  1  )     ?    null    :    line . subst ( index )  ;", "}", "METHOD_END"], "methodName": ["consume"], "fileName": "org.springframework.util.xml.XmlValidationModeDetector"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( line . contains ( XmlValidationModeDetector . START _ COMMENT )  )  )     &  &     (  !  ( line . contains ( XmlValidationModeDetector . END _ COMMENT )  )  )  )     {", "return   line ;", "}", "String   currLine    =    line ;", "while    (  ( currLine    =    consume ( currLine )  )     !  =    null )     {", "if    (  (  !  ( this . inComment )  )     &  &     (  !  ( currLine . trim (  )  . startsWith ( XmlValidationModeDetector . START _ COMMENT )  )  )  )     {", "return   currLine ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["consumeCommentTokens"], "fileName": "org.springframework.util.xml.XmlValidationModeDetector"}, {"methodBody": ["METHOD_START", "{", "BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( inputStream )  )  ;", "try    {", "boolean   isDtdValidated    =    false ;", "String   content ;", "while    (  ( content    =    reader . readLine (  )  )     !  =    null )     {", "content    =    consumeCommentTokens ( content )  ;", "if    (  ( this . inComment )     |  |     (  !  ( StringUtils . hasText ( content )  )  )  )     {", "continue ;", "}", "if    ( hasDoctype ( content )  )     {", "isDtdValidated    =    true ;", "break ;", "}", "if    ( hasOpeningTag ( content )  )     {", "break ;", "}", "}", "return   isDtdValidated    ?     . VALIDATION _ DTD    :     . VALIDATION _ XSD ;", "}    catch    ( CharConversionException   ex )     {", "return    . VALIDATION _ AUTO ;", "}    finally    {", "reader . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["detectValidationMode"], "fileName": "org.springframework.util.xml.XmlValidationModeDetector"}, {"methodBody": ["METHOD_START", "{", "return   commentToken ( line ,    XmlValidationModeDetector . END _ COMMENT ,    false )  ;", "}", "METHOD_END"], "methodName": ["endComment"], "fileName": "org.springframework.util.xml.XmlValidationModeDetector"}, {"methodBody": ["METHOD_START", "{", "return   content . contains ( XmlValidationModeDetector . DOCTYPE )  ;", "}", "METHOD_END"], "methodName": ["hasDoctype"], "fileName": "org.springframework.util.xml.XmlValidationModeDetector"}, {"methodBody": ["METHOD_START", "{", "if    ( this . inComment )     {", "return   false ;", "}", "int   openTagIndex    =    content . indexOf (  '  <  '  )  ;", "return    (  ( openTagIndex    >     (  -  1  )  )     &  &     (  ( content . length (  )  )     >     ( openTagIndex    +     1  )  )  )     &  &     ( Character . isLetter ( content . charAt (  ( openTagIndex    +     1  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasOpeningTag"], "fileName": "org.springframework.util.xml.XmlValidationModeDetector"}, {"methodBody": ["METHOD_START", "{", "return   commentToken ( line ,    XmlValidationModeDetector . START _ COMMENT ,    true )  ;", "}", "METHOD_END"], "methodName": ["startComment"], "fileName": "org.springframework.util.xml.XmlValidationModeDetector"}]