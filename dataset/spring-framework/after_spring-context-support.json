[{"methodBody": ["METHOD_START", "{", "return   new   CaffeineCache ( name ,    createNativeCaffeineCache ( name )  ,    isAllowNullValues (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCaffeineCache"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . cacheLoader )     !  =    null )     {", "return   this . cacheBuilder . build ( this . cacheLoader )  ;", "} else    {", "return   this . cacheBuilder . build (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createNativeCaffeineCache"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ObjectUtils . nullSafeEquals ( this . cacheBuilder ,    cacheBuilder )  )  )     {", "this . cacheBuilder    =    cacheBuilder ;", "refreshKnownCaches (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doSetCaffeine"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "return   this . allowNullValues ;", "}", "METHOD_END"], "methodName": ["isAllowNullValues"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    Cache >    entry    :    this . cacheMap . entrySet (  )  )     {", "entry . setValue ( create ( entry . getKey (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["refreshKnownCaches"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . allowNullValues )     !  =    allowNullValues )     {", "this . allowNullValues    =    allowNullValues ;", "refreshKnowns (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAllowNullValues"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ObjectUtils . nullSafeEquals ( this . cacheLoader ,    cacheLoader )  )  )     {", "this . cacheLoader    =    cacheLoader ;", "refreshKnownCaches (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setCacheLoader"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "if    ( cacheNames    !  =    null )     {", "for    ( String   name    :    cacheNames )     {", "this . cacheMap . put ( name ,    create ( name )  )  ;", "}", "this . dynamic    =    false ;", "} else    {", "this . dynamic    =    true ;", "}", "}", "METHOD_END"], "methodName": ["setCacheNames"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "doSetCaffeine ( Caffeine . from ( cacheSpecification )  )  ;", "}", "METHOD_END"], "methodName": ["setCacheSpecification"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( caffeine ,     \" Caffeine   must   not   be   null \"  )  ;", "doSetCaffeine ( caffeine )  ;", "}", "METHOD_END"], "methodName": ["setCaffeine"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "doSetCaffeine ( Caffeine . from ( caffeineSpec )  )  ;", "}", "METHOD_END"], "methodName": ["setCaffeineSpec"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManager"}, {"methodBody": ["METHOD_START", "{", "CaffeineCacheManager   cm    =    new   CaffeineCacheManager (  \" c 1  \"  )  ;", "cm . setCacheLoader ( new   com . github . benmanes . caffeine . cache . CacheLoader < Object ,    Object >  (  )     {", "@ Override", "public   Object   load ( Object   key )    throws   Exception    {", "if    (  \" ping \"  . equals ( key )  )     {", "return    \" pong \"  ;", "}", "throw   new   IllegalArgumentException (  \" I   only   know   ping \"  )  ;", "}", "}  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "Cache . ValueWrapper   value    =    cache 1  . get (  \" ping \"  )  ;", "assertNotNull ( value )  ;", "assertEquals (  \" pong \"  ,    value . get (  )  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" I   only   know   ping \"  )  ;", "assertNull ( cache 1  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheLoaderUseLoadingCache"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "CaffeineCacheManager   cm    =    new   CaffeineCacheManager (  \" c 1  \"  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "CacheLoader < Object ,    Object >    loader    =    mockCacheLoader (  )  ;", "cm . setCacheLoader ( loader )  ;", "Cache   cache 1 x    =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1 x    !  =    cache 1  )  )  ;", "cm . setCacheLoader ( loader )  ;", "Cache   cache 1 xx    =    cm . getCache (  \" c 1  \"  )  ;", "assertSame ( cache 1 x ,    cache 1 xx )  ;", "}", "METHOD_END"], "methodName": ["changeCacheLoaderRecreateCache"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "CaffeineCacheManager   cm    =    new   CaffeineCacheManager (  \" c 1  \"  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "cm . setCacheSpecification (  \" maximumSize =  1  0  \"  )  ;", "Cache   cache 1 x    =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1 x    !  =    cache 1  )  )  ;", "}", "METHOD_END"], "methodName": ["changeCacheSpecificationRecreateCache"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "CaffeineCacheManager   cm    =    new   CaffeineCacheManager (  \" c 1  \"  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "Caffeine < Object ,    Object >    caffeine    =    Caffeine . newBuilder (  )  . maximumSize (  1  0  )  ;", "cm . setCaffeine ( caffeine )  ;", "Cache   cache 1 x    =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1 x    !  =    cache 1  )  )  ;", "cm . setCaffeine ( caffeine )  ;", "Cache   cache 1 xx    =    cm . getCache (  \" c 1  \"  )  ;", "assertSame ( cache 1 x ,    cache 1 xx )  ;", "}", "METHOD_END"], "methodName": ["changeCaffeineRecreateCache"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "CaffeineCacheManager   cm    =    new   CaffeineCacheManager (  \" c 1  \"  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "cm . setCaffeineSpec ( CaffeineSpec . parse (  \" maximumSize =  1  0  \"  )  )  ;", "Cache   cache 1 x    =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1 x    !  =    cache 1  )  )  ;", "}", "METHOD_END"], "methodName": ["changeCaffeineSpecRecreateCache"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   mock ( CacheLoader . class )  ;", "}", "METHOD_END"], "methodName": ["mockCacheLoader"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "CaffeineCacheManager   cm    =    new   CaffeineCacheManager (  \" c 1  \"  )  ;", "assertNull ( cm . getCache (  \" someCache \"  )  )  ;", "cm . setCacheNames ( null )  ;", "assertNotNull ( cm . getCache (  \" someCache \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setCacheNameNullRestoreDynamicMode"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "CacheManager   cm    =    new   CaffeineCacheManager (  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1    instanceof   CaffeineCache )  )  ;", "Cache   cache 1 again    =    cm . getCache (  \" c 1  \"  )  ;", "assertSame ( cache 1 again ,    cache 1  )  ;", "Cache   cache 2     =    cm . getCache (  \" c 2  \"  )  ;", "assertTrue (  ( cache 2    instanceof   CaffeineCache )  )  ;", "Cache   cache 2 again    =    cm . getCache (  \" c 2  \"  )  ;", "assertSame ( cache 2 again ,    cache 2  )  ;", "Cache   cache 3     =    cm . getCache (  \" c 3  \"  )  ;", "assertTrue (  ( cache 3    instanceof   CaffeineCache )  )  ;", "Cache   cache 3 again    =    cm . getCache (  \" c 3  \"  )  ;", "assertSame ( cache 3 again ,    cache 3  )  ;", "cache 1  . put (  \" key 1  \"  ,     \" value 1  \"  )  ;", "assertEquals (  \" value 1  \"  ,    cache 1  . get (  \" key 1  \"  )  . get (  )  )  ;", "cache 1  . put (  \" key 2  \"  ,     2  )  ;", "assertEquals (  2  ,    cache 1  . get (  \" key 2  \"  )  . get (  )  )  ;", "cache 1  . put (  \" key 3  \"  ,    null )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  . get (  )  )  ;", "cache 1  . evict (  \" key 3  \"  )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDynamicMode"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "CaffeineCacheManager   cm    =    new   CaffeineCacheManager (  \" c 1  \"  ,     \" c 2  \"  )  ;", "Cache   cache 1     =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1    instanceof   CaffeineCache )  )  ;", "Cache   cache 1 again    =    cm . getCache (  \" c 1  \"  )  ;", "assertSame ( cache 1 again ,    cache 1  )  ;", "Cache   cache 2     =    cm . getCache (  \" c 2  \"  )  ;", "assertTrue (  ( cache 2    instanceof   CaffeineCache )  )  ;", "Cache   cache 2 again    =    cm . getCache (  \" c 2  \"  )  ;", "assertSame ( cache 2 again ,    cache 2  )  ;", "Cache   cache 3     =    cm . getCache (  \" c 3  \"  )  ;", "assertNull ( cache 3  )  ;", "cache 1  . put (  \" key 1  \"  ,     \" value 1  \"  )  ;", "assertEquals (  \" value 1  \"  ,    cache 1  . get (  \" key 1  \"  )  . get (  )  )  ;", "cache 1  . put (  \" key 2  \"  ,     2  )  ;", "assertEquals (  2  ,    cache 1  . get (  \" key 2  \"  )  . get (  )  )  ;", "cache 1  . put (  \" key 3  \"  ,    null )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  . get (  )  )  ;", "cache 1  . evict (  \" key 3  \"  )  ;", "assertNull ( cache 1  . get (  \" key 3  \"  )  )  ;", "cm . setAllowNullValues ( false )  ;", "Cache   cache 1 x    =    cm . getCache (  \" c 1  \"  )  ;", "assertTrue (  ( cache 1 x   instanceof   CaffeineCache )  )  ;", "assertTrue (  ( cache 1 x    !  =    cache 1  )  )  ;", "Cache   cache 2 x    =    cm . getCache (  \" c 2  \"  )  ;", "assertTrue (  ( cache 2 x   instanceof   CaffeineCache )  )  ;", "assertTrue (  ( cache 2 x    !  =    cache 2  )  )  ;", "Cache   cache 3 x    =    cm . getCache (  \" c 3  \"  )  ;", "assertNull ( cache 3 x )  ;", "cache 1 x . put (  \" key 1  \"  ,     \" value 1  \"  )  ;", "assertEquals (  \" value 1  \"  ,    cache 1 x . get (  \" key 1  \"  )  . get (  )  )  ;", "cache 1 x . put (  \" key 2  \"  ,     2  )  ;", "assertEquals (  2  ,    cache 1 x . get (  \" key 2  \"  )  . get (  )  )  ;", "cm . setAllowNullValues ( true )  ;", "Cache   cache 1 y    =    cm . getCache (  \" c 1  \"  )  ;", "cache 1 y . put (  \" key 3  \"  ,    null )  ;", "assertNull ( cache 1 y . get (  \" key 3  \"  )  . get (  )  )  ;", "cache 1 y . evict (  \" key 3  \"  )  ;", "assertNull ( cache 1 y . get (  \" key 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticMode"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "nativeCache    =    Caffeine . newBuilder (  )  . build (  )  ;", "cache    =    new    ( CACHE _ NAME ,    nativeCache )  ;", "Cache < Object ,    Object >    nativeCacheNoNull    =    Caffeine . newBuilder (  )  . build (  )  ;", "cacheNoNull    =    new    ( CACHE _ NAME _ NO _ NULL ,    nativeCacheNoNull ,    false )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheTests"}, {"methodBody": ["METHOD_START", "{", "CaffeineCache   cache    =    getCache (  )  ;", "Object   key    =    new   Object (  )  ;", "Object   value    =    null ;", "assertNull ( cache . get ( key )  )  ;", "assertNull ( cache . putIfAbsent ( key ,    value )  )  ;", "assertEquals ( value ,    cache . get ( key )  . get (  )  )  ;", "Cache . ValueWrapper   wrapper    =    cache . putIfAbsent ( key ,     \" anotherValue \"  )  ;", "assertNotNull ( wrapper )  ;", "assertEquals ( null ,    wrapper . get (  )  )  ;", "assertEquals ( value ,    cache . get ( key )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPutIfAbsentNullValue"], "fileName": "org.springframework.cache.caffeine.CaffeineCacheTests"}, {"methodBody": ["METHOD_START", "{", "T   value ;", "try    {", "value    =    valueLoaderll (  )  ;", "} tch    ( Throwable   ex )     {", "throw   new   ValueRetrievalException ( key ,    valueLoader ,    ex )  ;", "}", "put ( key ,    value )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["loadValue"], "fileName": "org.springframework.cache.ehcache.EhCacheCache"}, {"methodBody": ["METHOD_START", "{", "return   this . cache . get ( key )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.springframework.cache.ehcache.EhCacheCache"}, {"methodBody": ["METHOD_START", "{", "return   element    !  =    null    ?    new   SimpleValueWrapper ( element . getObjectValue (  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["toValueWrapper"], "fileName": "org.springframework.cache.ehcache.EhCacheCache"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheManager ;", "}", "METHOD_END"], "methodName": ["getCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheCacheManager"}, {"methodBody": ["METHOD_START", "{", "this . cacheManager    =    cacheManager ;", "}", "METHOD_END"], "methodName": ["setCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheCacheManager"}, {"methodBody": ["METHOD_START", "{", "nativeCacheManager    =    new   net . sf . ehcache . CacheManager ( new   Configuration (  )  . name (  \" EhCacheCacheManagerTests \"  )  . defaultCache ( new   CacheConfiguration (  \" default \"  ,     1  0  0  )  )  )  ;", "addNativeCache ( AbstractTransactionSupportingCacheManagerTests . CACHE _ NAME )  ;", "cacheManager    =    new   EhCacheCacheManager ( nativeCacheManager )  ;", "cacheManager . setTransactionAware ( false )  ;", "cacheManager . afterPropertiesSet (  )  ;", "transactionalCacheManager    =    new   EhCacheCacheManager ( nativeCacheManager )  ;", "transactionalCacheManager . setTransactionAware ( true )  ;", "transactionalCacheManager . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.ehcache.EhCacheCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "nativeCacheManager . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.springframework.cache.ehcache.EhCacheCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "cacheManager    =    new   net . sf . ehcache . CacheManager ( new   Configuration (  )  . name (  \" EhCacheCacheTests \"  )  . defaultCache ( new   CacheConfiguration (  \" default \"  ,     1  0  0  )  )  )  ;", "nativeCache    =    new   Cache ( new   CacheConfiguration ( CACHE _ NAME ,     1  0  0  )  )  ;", "cacheManager . addCache ( nativeCache )  ;", "cache    =    new   EhCacheCache ( nativeCache )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.ehcache.EhCacheCacheTests"}, {"methodBody": ["METHOD_START", "{", "cacheManager . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.springframework.cache.ehcache.EhCacheCacheTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "String   key    =     \" brancusi \"  ;", "String   value    =     \" constantin \"  ;", "Element   brancusi    =    new   Element ( key ,    value )  ;", "brancusi . setTimeToLive (  3  )  ;", "nativ . put ( brancusi )  ;", "assertEquals ( value ,    cache . get ( key )  . get (  )  )  ;", "Thread . sleep (  (  5     *     1  0  0  0  )  )  ;", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["testExpiredElements"], "fileName": "org.springframework.cache.ehcache.EhCacheCacheTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Cache ( this )  ;", "}", "METHOD_END"], "methodName": ["createCache"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . cacheEntryFactory )     !  =    null )     {", "if    (  ( this . cacheEntryFactory )    instanceof   UpdatingCacheEntryFactory )     {", "return   new   net . sfconstructs . blocking . UpdatingSelfPopulatingCache ( cache ,     (  ( UpdatingCacheEntryFactory )     ( this . cacheEntryFactory )  )  )  ;", "} else    {", "return   new   net . sfconstructs . blocking . SelfPopulatingCache ( cache ,    this . cacheEntryFactory )  ;", "}", "}", "if    ( this . blocking )     {", "return   new   net . sfconstructs . blocking . BlockingCache ( cache )  ;", "}", "return   cache ;", "}", "METHOD_END"], "methodName": ["decorateCache"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . blocking    =    blocking ;", "}", "METHOD_END"], "methodName": ["setBlocking"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . bootstrapCacheLoader    =    bootstrapCacheLoader ;", "}", "METHOD_END"], "methodName": ["setBootstrapCacheLoader"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cacheEntryFactory    =    cacheEntryFactory ;", "}", "METHOD_END"], "methodName": ["setCacheEntryFactory"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cacheEventListeners    =    cacheEventListeners ;", "}", "METHOD_END"], "methodName": ["setCacheEventListeners"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cacheManager    =    cacheManager ;", "}", "METHOD_END"], "methodName": ["setCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "setName ( cacheName )  ;", "}", "METHOD_END"], "methodName": ["setCacheName"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . disabled    =    disabled ;", "}", "METHOD_END"], "methodName": ["setDisabled"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "setDiskSpoolBufferSizeMB ( diskSpoolBufferSize )  ;", "}", "METHOD_END"], "methodName": ["setDiskSpoolBufferSize"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "setTimeToIdleSeconds ( timeToIdle )  ;", "}", "METHOD_END"], "methodName": ["setTimeToIdle"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "setTimeToLiveSeconds ( timeToLive )  ;", "}", "METHOD_END"], "methodName": ["setTimeToLive"], "fileName": "org.springframework.cache.ehcache.EhCacheFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . acceptExisting    =    acceptExisting ;", "}", "METHOD_END"], "methodName": ["setAcceptExisting"], "fileName": "org.springframework.cache.ehcache.EhCacheManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cacheManagerName    =    cacheManagerName ;", "}", "METHOD_END"], "methodName": ["setCacheManagerName"], "fileName": "org.springframework.cache.ehcache.EhCacheManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . configLocation    =    configLocation ;", "}", "METHOD_END"], "methodName": ["setConfigLocation"], "fileName": "org.springframework.cache.ehcache.EhCacheManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . shared    =    shared ;", "}", "METHOD_END"], "methodName": ["setShared"], "fileName": "org.springframework.cache.ehcache.EhCacheManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   new   net . sf . ehcache . CacheManager ( ConfigurationFactory . parseConfiguration (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheManagerUtils"}, {"methodBody": ["METHOD_START", "{", "Configuration   configuration    =    ConfigurationFactory . parseConfiguration (  )  ;", "configuration . setName ( name )  ;", "return   new   net . sf . ehcache .  ( configuration )  ;", "}", "METHOD_END"], "methodName": ["buildCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheManagerUtils"}, {"methodBody": ["METHOD_START", "{", "Configuration   configuration    =    EhCacheManagerUtils . parseConfiguration ( configLocation )  ;", "configuration . setName ( name )  ;", "return   new   net . sf . ehcache . CacheManager ( configuration )  ;", "}", "METHOD_END"], "methodName": ["buildCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheManagerUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   net . sf . ehcache . CacheManager ( EhCacheManagerUtils . parseConfiguration ( configLocation )  )  ;", "}", "METHOD_END"], "methodName": ["buildCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheManagerUtils"}, {"methodBody": ["METHOD_START", "{", "InputStream   is    =    null ;", "try    {", "is    =    configLocation . getInputStream (  )  ;", "return   ConfigurationFactory . parseConfiguration ( is )  ;", "}    catch    ( IOException   ex )     {", "throw   new   CacheException (  \" Failed   to   parse      configuration   resource \"  ,    ex )  ;", "}    finally    {", "if    ( is    !  =    null )     {", "try    {", "is . close (  )  ;", "}    catch    ( IOException   ex )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseConfiguration"], "fileName": "org.springframework.cache.ehcache.EhCacheManagerUtils"}, {"methodBody": ["METHOD_START", "{", "Cache   cache ;", "ManagerFactoryBean   cacheManagerFb    =    null ;", "boolean   cacheManagerFbInitialized    =    false ;", "try    {", "FactoryBean   cacheFb    =    new   FactoryBean (  )  ;", "Class <  ?    extends   Ehcache >    objectType    =    cacheFb . getObjectType (  )  ;", "assertTrue ( Ehcache . class . isAssignableFrom ( objectType )  )  ;", "assertTrue (  \" Singleton   property \"  ,    cacheFb . isSingleton (  )  )  ;", "if    ( useCacheManagerFb )     {", "cacheManagerFb    =    new   ManagerFactoryBean (  )  ;", "cacheManagerFb . setConfigLocation ( new   ClassPathResource (  \" testEhcache . xml \"  ,    getClass (  )  )  )  ;", "cacheManagerFb . setCacheManagerName (  \" cache \"  )  ;", "cacheManagerFb . afterPropertiesSet (  )  ;", "cacheManagerFbInitialized    =    true ;", "cacheFb . setCacheManager ( cacheManagerFb . getObject (  )  )  ;", "}", "cacheFb . setCacheName (  \" myCache 1  \"  )  ;", "cacheFb . afterPropertiesSet (  )  ;", "cache    =     (  ( Cache )     ( cacheFb . getObject (  )  )  )  ;", "Class <  ?    extends   Ehcache >    objectType 2     =    cacheFb . getObjectType (  )  ;", "assertSame ( objectType ,    objectType 2  )  ;", "CacheConfiguration   config    =    cache . getCacheConfiguration (  )  ;", "assertEquals (  \" myCache 1  \"  ,    cache . getName (  )  )  ;", "if    ( useCacheManagerFb )     {", "assertEquals (  \" myCache 1  . maxElements \"  ,     3  0  0  ,    config . getMaxEntriesLocalHeap (  )  )  ;", "} else    {", "assertEquals (  \" myCache 1  . maxElements \"  ,     1  0  0  0  0  ,    config . getMaxEntriesLocalHeap (  )  )  ;", "}", "cacheFb    =    new   FactoryBean (  )  ;", "if    ( useCacheManagerFb )     {", "cacheFb . setCacheManager ( cacheManagerFb . getObject (  )  )  ;", "}", "cacheFb . setCacheName (  \" undefinedCache \"  )  ;", "cacheFb . afterPropertiesSet (  )  ;", "cache    =     (  ( Cache )     ( cacheFb . getObject (  )  )  )  ;", "config    =    cache . getCacheConfiguration (  )  ;", "assertEquals (  \" undefinedCache \"  ,    cache . getName (  )  )  ;", "assertTrue (  \" default   maxElements   is   correct \"  ,     (  ( config . getMaxEntriesLocalHeap (  )  )     =  =     1  0  0  0  0  )  )  ;", "assertFalse (  \" default   eternal   is   correct \"  ,    config . isEternal (  )  )  ;", "assertTrue (  \" default   timeToLive   is   correct \"  ,     (  ( config . getTimeToLiveSeconds (  )  )     =  =     1  2  0  )  )  ;", "assertTrue (  \" default   timeToIdle   is   correct \"  ,     (  ( config . getTimeToIdleSeconds (  )  )     =  =     1  2  0  )  )  ;", "assertTrue (  \" default   diskExpiryThreadIntervalSeconds   is   correct \"  ,     (  ( config . getDiskExpiryThreadIntervalSeconds (  )  )     =  =     1  2  0  )  )  ;", "cacheFb    =    new   FactoryBean (  )  ;", "if    ( useCacheManagerFb )     {", "cacheFb . setCacheManager ( cacheManagerFb . getObject (  )  )  ;", "}", "cacheFb . setBeanName (  \" undefinedCache 2  \"  )  ;", "cacheFb . setMaxEntriesLocalHeap (  5  )  ;", "cacheFb . setTimeToLive (  8  )  ;", "cacheFb . setTimeToIdle (  7  )  ;", "cacheFb . setDiskExpiryThreadIntervalSeconds (  1  0  )  ;", "cacheFb . afterPropertiesSet (  )  ;", "cache    =     (  ( Cache )     ( cacheFb . getObject (  )  )  )  ;", "config    =    cache . getCacheConfiguration (  )  ;", "assertEquals (  \" undefinedCache 2  \"  ,    cache . getName (  )  )  ;", "assertTrue (  \" overridden   maxElements   is   correct \"  ,     (  ( config . getMaxEntriesLocalHeap (  )  )     =  =     5  )  )  ;", "assertTrue (  \" default   timeToLive   is   correct \"  ,     (  ( config . getTimeToLiveSeconds (  )  )     =  =     8  )  )  ;", "assertTrue (  \" default   timeToIdle   is   correct \"  ,     (  ( config . getTimeToIdleSeconds (  )  )     =  =     7  )  )  ;", "assertTrue (  \" overridden   diskExpiryThreadIntervalSeconds   is   correct \"  ,     (  ( config . getDiskExpiryThreadIntervalSeconds (  )  )     =  =     1  0  )  )  ;", "}    finally    {", "if    ( cacheManagerFbInitialized )     {", "cacheManagerFb . destroy (  )  ;", "} else    {", "CacheManager . getInstance (  )  . shutdown (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doTestEhCacheFactoryBean"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "EhCacheManagerFactoryBean   cacheManagerFb    =    new   EhCacheManagerFactoryBean (  )  ;", "cacheManagerFb . setCacheManagerName (  \" myCacheManager \"  )  ;", "assertEquals ( CacheManager . class ,    cacheManagerFb . getObjectType (  )  )  ;", "assertTrue (  \" Singleton   property \"  ,    cacheManagerFb . isSingleton (  )  )  ;", "cacheManagerFb . afterPropertiesSet (  )  ;", "try    {", "CacheManager   cm    =    cacheManagerFb . getObject (  )  ;", "assertTrue (  \" Loaded   CacheManager   with   no   caches \"  ,     (  ( cm . getCacheNames (  )  . length )     =  =     0  )  )  ;", "Cache   myCache 1     =    cm . getCache (  \" myCache 1  \"  )  ;", "assertTrue (  \" No   myCache 1    defined \"  ,     ( myCache 1     =  =    null )  )  ;", "EhCacheManagerFactoryBean   cacheManagerFb 2     =    new   EhCacheManagerFactoryBean (  )  ;", "cacheManagerFb 2  . setCacheManagerName (  \" myCacheManager \"  )  ;", "cacheManagerFb 2  . setAcceptExisting ( true )  ;", "cacheManagerFb 2  . afterPropertiesSet (  )  ;", "CacheManager   cm 2     =    cacheManagerFb 2  . getObject (  )  ;", "assertSame ( cm ,    cm 2  )  ;", "cacheManagerFb 2  . destroy (  )  ;", "}    finally    {", "cacheManagerFb . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAcceptExistingCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "EhCacheManagerFactoryBean   cacheManagerFb    =    new   EhCacheManagerFactoryBean (  )  ;", "cacheManagerFb . setCacheManagerName (  \" myCacheManager \"  )  ;", "assertEquals ( CacheManager . class ,    cacheManagerFb . getObjectType (  )  )  ;", "assertTrue (  \" Singleton   property \"  ,    cacheManagerFb . isSingleton (  )  )  ;", "cacheManagerFb . afterPropertiesSet (  )  ;", "try    {", "CacheManager   cm    =    cacheManagerFb . getObject (  )  ;", "assertTrue (  \" Loaded   CacheManager   with   no   caches \"  ,     (  ( cm . getCacheNames (  )  . length )     =  =     0  )  )  ;", "Cache   myCache 1     =    cm . getCache (  \" myCache 1  \"  )  ;", "assertTrue (  \" No   myCache 1    defined \"  ,     ( myCache 1     =  =    null )  )  ;", "}    finally    {", "cacheManagerFb . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBlankCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "EhCacheManagerFactoryBean   cacheManagerFb    =    new   EhCacheManagerFactoryBean (  )  ;", "cacheManagerFb . setCacheManagerName (  \" myCacheManager \"  )  ;", "assertEquals ( CacheManager . class ,    cacheManagerFb . getObjectType (  )  )  ;", "assertTrue (  \" Singleton   property \"  ,    cacheManagerFb . isSingleton (  )  )  ;", "cacheManagerFb . afterPropertiesSet (  )  ;", "try    {", "CacheManager   cm    =    cacheManagerFb . getObject (  )  ;", "assertTrue (  \" Loaded   CacheManager   with   no   caches \"  ,     (  ( cm . getCacheNames (  )  . length )     =  =     0  )  )  ;", "Cache   myCache 1     =    cm . getCache (  \" myCache 1  \"  )  ;", "assertTrue (  \" No   myCache 1    defined \"  ,     ( myCache 1     =  =    null )  )  ;", "EhCacheManagerFactoryBean   cacheManagerFb 2     =    new   EhCacheManagerFactoryBean (  )  ;", "cacheManagerFb 2  . setCacheManagerName (  \" myCacheManager \"  )  ;", "cacheManagerFb 2  . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   CacheException   because   of   naming   conflict \"  )  ;", "}    catch    ( CacheException   ex )     {", "}    finally    {", "cacheManagerFb . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCacheManagerConflict"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "EhCacheManagerFactoryBean   cacheManagerFb    =    new   EhCacheManagerFactoryBean (  )  ;", "cacheManagerFb . setConfigLocation ( new   ClassPathResource (  \" testEhcache . xml \"  ,    getClass (  )  )  )  ;", "cacheManagerFb . setCacheManagerName (  \" myCacheManager \"  )  ;", "cacheManagerFb . afterPropertiesSet (  )  ;", "try    {", "CacheManager   cm    =    cacheManagerFb . getObject (  )  ;", "assertTrue (  \" Correct   number   of   caches   loaded \"  ,     (  ( cm . getCacheNames (  )  . length )     =  =     1  )  )  ;", "Cache   myCache 1     =    cm . getCache (  \" myCache 1  \"  )  ;", "assertFalse (  \" myCache 1    is   not   eternal \"  ,    myCache 1  . getCacheConfiguration (  )  . isEternal (  )  )  ;", "assertTrue (  \" myCache 1  . maxElements    =  =     3  0  0  \"  ,     (  ( myCache 1  . getCacheConfiguration (  )  . getMaxEntriesLocalHeap (  )  )     =  =     3  0  0  )  )  ;", "}    finally    {", "cacheManagerFb . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCacheManagerFromConfigFile"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "EhCacheManagerFactoryBean   cacheManagerFb    =    new   EhCacheManagerFactoryBean (  )  ;", "cacheManagerFb . afterPropertiesSet (  )  ;", "try    {", "CacheManager   cm    =    cacheManagerFb . getObject (  )  ;", "EhCacheFactoryBean   cacheFb    =    new   EhCacheFactoryBean (  )  ;", "cacheFb . setCacheManager ( cm )  ;", "cacheFb . setCacheName (  \" myCache 1  \"  )  ;", "cacheFb . setBlocking ( true )  ;", "assertEquals ( cacheFb . getObjectType (  )  ,    BlockingCache . class )  ;", "cacheFb . afterPropertiesSet (  )  ;", "Ehcache   myCache 1     =    cm . getEhcache (  \" myCache 1  \"  )  ;", "assertTrue (  ( myCache 1    instanceof   BlockingCache )  )  ;", "}    finally    {", "cacheManagerFb . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testEhCacheFactoryBeanWithBlockingCache"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestEhCacheFactoryBean ( false )  ;", "}", "METHOD_END"], "methodName": ["testEhCacheFactoryBeanWithDefaultCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "doTestEhCacheFactoryBean ( true )  ;", "}", "METHOD_END"], "methodName": ["testEhCacheFactoryBeanWithExplicitCacheManager"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "EhCacheManagerFactoryBean   cacheManagerFb    =    new   EhCacheManagerFactoryBean (  )  ;", "cacheManagerFb . afterPropertiesSet (  )  ;", "try    {", "CacheManager   cm    =    cacheManagerFb . getObject (  )  ;", "EhCacheFactoryBean   cacheFb    =    new   EhCacheFactoryBean (  )  ;", "cacheFb . setCacheManager ( cm )  ;", "cacheFb . setCacheName (  \" myCache 1  \"  )  ;", "cacheFb . setCacheEntryFactory (  (    key )     -  >    key )  ;", "assertEquals ( cacheFb . getObjectType (  )  ,    SelfPopulatingCache . class )  ;", "cacheFb . afterPropertiesSet (  )  ;", "Ehcache   myCache 1     =    cm . getEhcache (  \" myCache 1  \"  )  ;", "assertTrue (  ( myCache 1    instanceof   SelfPopulatingCache )  )  ;", "assertEquals (  \" myKey 1  \"  ,    myCache 1  . get (  \" myKey 1  \"  )  . getObjectValue (  )  )  ;", "}    finally    {", "cacheManagerFb . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testEhCacheFactoryBeanWithSelfPopulatingCache"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "EhCacheManagerFactoryBean   cacheManagerFb    =    new   EhCacheManagerFactoryBean (  )  ;", "cacheManagerFb . afterPropertiesSet (  )  ;", "try    {", "CacheManager   cm    =    cacheManagerFb . getObject (  )  ;", "EhCacheFactoryBean   cacheFb    =    new   EhCacheFactoryBean (  )  ;", "cacheFb . setCacheManager ( cm )  ;", "cacheFb . setCacheName (  \" myCache 1  \"  )  ;", "cacheFb . setCacheEntryFactory ( new   UpdatingCacheEntryFactory (  )     {", "@ Override", "public   Object   createEntry ( Object   key )     {", "return   key ;", "}", "@ Override", "public   void   updateEntryValue ( Object   key ,    Object   value )     {", "}", "}  )  ;", "assertEquals ( cacheFb . getObjectType (  )  ,    UpdatingSelfPopulatingCache . class )  ;", "cacheFb . afterPropertiesSet (  )  ;", "Ehcache   myCache 1     =    cm . getEhcache (  \" myCache 1  \"  )  ;", "assertTrue (  ( myCache 1    instanceof   UpdatingSelfPopulatingCache )  )  ;", "assertEquals (  \" myKey 1  \"  ,    myCache 1  . get (  \" myKey 1  \"  )  . getObjectValue (  )  )  ;", "}    finally    {", "cacheManagerFb . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testEhCacheFactoryBeanWithUpdatingSelfPopulatingCache"], "fileName": "org.springframework.cache.ehcache.EhCacheSupportTests"}, {"methodBody": ["METHOD_START", "{", "SimpleCacheManager   result    =    new   SimpleCacheManager (  )  ;", "List < Cache >    caches    =    new   ArrayList <  >  (  )  ;", "for    ( String   cacheName    :    cacheNames )     {", "caches . add ( new   ConcurrentMapCache ( cacheName )  )  ;", "}", "result . setCaches ( caches )  ;", "result . afterPropertiesSet (  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createSimpleCacheManager"], "fileName": "org.springframework.cache.jcache.AbstractJCacheTests"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheManager ;", "}", "METHOD_END"], "methodName": ["getCacheManager"], "fileName": "org.springframework.cache.jcache.JCacheCacheManager"}, {"methodBody": ["METHOD_START", "{", "return   this . allowNullValues ;", "}", "METHOD_END"], "methodName": ["isAllowNullValues"], "fileName": "org.springframework.cache.jcache.JCacheCacheManager"}, {"methodBody": ["METHOD_START", "{", "this . allowNullValues    =    allowNullValues ;", "}", "METHOD_END"], "methodName": ["setAllowNullValues"], "fileName": "org.springframework.cache.jcache.JCacheCacheManager"}, {"methodBody": ["METHOD_START", "{", "this . cacheManager    =    cacheManager ;", "}", "METHOD_END"], "methodName": ["setCacheManager"], "fileName": "org.springframework.cache.jcache.JCacheCacheManager"}, {"methodBody": ["METHOD_START", "{", "cacheManagerMock    =    new   JCacheCacheManagerTests . CacheManagerMock (  )  ;", "cacheManagerMock . addCache ( AbstractTransactionSupportingCacheManagerTests . CACHE _ NAME )  ;", "cacheManager    =    new   JCacheCacheManager ( cacheManagerMock . getCacheManager (  )  )  ;", "cacheManager . setTransactionAware ( false )  ;", "cacheManager . afterPropertiesSet (  )  ;", "transactionalCacheManager    =    new   JCacheCacheManager ( cacheManagerMock . getCacheManager (  )  )  ;", "transactionalCacheManager . setTransactionAware ( true )  ;", "transactionalCacheManager . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["setupOnce"], "fileName": "org.springframework.cache.jcache.JCacheCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   Caching . getCachingProvider (  \" JCacheCachingProvider \"  )  ;", "}", "METHOD_END"], "methodName": ["getCachingProvider"], "fileName": "org.springframework.cache.jcache.JCacheEhCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( jCacheManager )     !  =    null )     {", "jCacheManager . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.springframework.cache.jcache.JCacheEhCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "return   Caching . getCachingProvider (  \" JCacheCachingProvider \"  )  ;", "}", "METHOD_END"], "methodName": ["getCachingProvider"], "fileName": "org.springframework.cache.jcache.JCacheEhCacheApiTests"}, {"methodBody": ["METHOD_START", "{", "thisanager    =    getCachingProvider (  )  . getCacheManager (  )  ;", "thisanager . createCache ( CACHE _ NAME ,    new   MutableConfiguration (  )  )  ;", "thisanager . createCache ( CACHE _ NAME _ NO _ NULL ,    new   MutableConfiguration (  )  )  ;", "this . nativeCache    =    thisanager . getCache ( CACHE _ NAME )  ;", "this =    new   JCacheCache ( this . nativeCache )  ;", "Cache < Object ,    Object >    nativeCacheNoNull    =    thisanager . getCache ( CACHE _ NAME _ NO _ NULL )  ;", "thisoNull    =    new   JCacheCache ( nativeCacheNoNull ,    false )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.jcache.JCacheEhCacheApiTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . cacheManager )     !  =    null )     {", "this . cacheManager . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.springframework.cache.jcache.JCacheEhCacheApiTests"}, {"methodBody": ["METHOD_START", "{", "this . cacheManagerProperties    =    cacheManagerProperties ;", "}", "METHOD_END"], "methodName": ["setCacheManagerProperties"], "fileName": "org.springframework.cache.jcache.JCacheManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cacheManagerUri    =    cacheManagerUri ;", "}", "METHOD_END"], "methodName": ["setCacheManagerUri"], "fileName": "org.springframework.cache.jcache.JCacheManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Object   first    =    service ( keyItem )  ;", "Object   second    =    service ( keyItem )  ;", "assertSame ( first ,    second )  ;", "}", "METHOD_END"], "methodName": ["cache"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Object   first    =    serviceAlwaysInvoke ( keyItem )  ;", "Object   second    =    serviceAlwaysInvoke ( keyItem )  ;", "assertNotSame ( first ,    second )  ;", "}", "METHOD_END"], "methodName": ["cacheAlwaysInvoke"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . EXCEPTION _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "assertNull ( cache . get ( key )  )  ;", "try    {", "service . cacheWithCheckedException ( keyItem ,    true )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( IOException   e )     {", "}", "Cache . ValueWrapper   result    =    cache . get ( key )  ;", "assertNotNull ( result )  ;", "assertEquals ( IOException . class ,    result . get (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheCheckedException"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . EXCEPTION _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "assertNull ( cache . get ( key )  )  ;", "try    {", "service . cacheWithException ( keyItem ,    true )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "}", "Cache . ValueWrapper   result    =    cache . get ( key )  ;", "assertNotNull ( result )  ;", "assertEquals ( UnsupportedOperationException . class ,    result . get (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheException"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "final   String   keyItem    =    name . getMethodName (  )  ;", "UnsupportedOperationException   first    =    null ;", "long   ref    =    service . exceptionInvocations (  )  ;", "try    {", "service . cacheWithException ( keyItem ,    true )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "first    =    e ;", "}", "assertEquals (  \" First   call   should   not   have   been   cached \"  ,     ( ref    +     1  )  ,    service . exceptionInvocations (  )  )  ;", "UnsupportedOperationException   second    =    methodInCallStack ( keyItem )  ;", "assertEquals (  \" Second   call   should   have   been   cached \"  ,     ( ref    +     1  )  ,    service . exceptionInvocations (  )  )  ;", "assertEquals ( first . getCause (  )  ,    second . getCause (  )  )  ;", "assertEquals ( first . getMessage (  )  ,    second . getMessage (  )  )  ;", "assertFalse (  \" Original   stack   must   not   contain   any   reference   to   methodInCallStack \"  ,    contain ( first ,     . class . getName (  )  ,     \" methodInCallStack \"  )  )  ;", "assertTrue (  \" Cached   stack   should   have   been   rewritten   with   a   reference   to      methodInCallStack \"  ,    contain ( second ,     . class . getName (  )  ,     \" methodInCallStack \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheExceptionRewriteCallStack"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . EXCEPTION _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "assertNull ( cache . get ( key )  )  ;", "try    {", "service . cacheWithException ( keyItem ,    false )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( NullPointerException   e )     {", "}", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["cacheExceptionVetoed"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    getCache ( AbstractJCacheAnnotationTests . DEFAULT _ CACHE )  ;", "String   keyItem    =    name . getMethodName (  )  ;", "assertNull ( cache . get ( keyItem )  )  ;", "Object   first    =    service . cacheNull ( keyItem )  ;", "Object   second    =    service . cacheNull ( keyItem )  ;", "assertSame ( first ,    second )  ;", "Cache . ValueWrapper   wrapper    =    cache . get ( keyItem )  ;", "assertNotNull ( wrapper )  ;", "assertSame ( first ,    wrapper . get (  )  )  ;", "assertNull (  \" Cached   value   should   be   null \"  ,    wrapper . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheNull"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "service . cacheWithCustomCacheResolver ( keyItem )  ;", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["cacheWithCustomCacheResolver"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "service . cacheWithCustomKeyGenerator ( keyItem ,     \" ignored \"  )  ;", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["cacheWithCustomKeyGenerator"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Object   first    =    serviceWithPartialKey ( keyItem ,    true )  ;", "Object   second    =    serviceWithPartialKey ( keyItem ,    false )  ;", "assertSame ( first ,    second )  ;", "}", "METHOD_END"], "methodName": ["cacheWithPartialKey"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "for    ( StackTraceElement   element    :    t . getStackTrace (  )  )     {", "if    (  ( className . equals ( element . getClassName (  )  )  )     &  &     ( methodName . equals ( element . getMethodName (  )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["contain"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "return   SimpleKeyGenerator . generateKey ( params )  ;", "}", "METHOD_END"], "methodName": ["createKey"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "assertNull ( cache . get ( key )  )  ;", "service . earlyPut ( keyItem ,    value )  ;", "Cache . ValueWrapper   result    =    cache . get ( key )  ;", "assertNotNull ( result )  ;", "assertEquals ( value ,    result . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["earlyPut"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "assertNull ( cache . get ( key )  )  ;", "try    {", "service . earlyPutWithException ( keyItem ,    value ,    true )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "}", "Cache . ValueWrapper   result    =    cache . get ( key )  ;", "assertNotNull ( result )  ;", "assertEquals ( value ,    result . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["earlyPutWithException"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "assertNull ( cache . get ( key )  )  ;", "try    {", "service . earlyPutWithException ( keyItem ,    value ,    false )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( NullPointerException   e )     {", "}", "Cache . ValueWrapper   result    =    cache . get ( key )  ;", "assertNotNull ( result )  ;", "assertEquals ( value ,    result . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["earlyPutWithExceptionVetoPut"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "cache . put ( key ,    value )  ;", "service . earlyRemove ( keyItem )  ;", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["earlyRemove"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    getCache ( AbstractJCacheAnnotationTests . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( name . getMethodName (  )  )  ;", "cache . put ( key ,    new   Object (  )  )  ;", "service . earlyRemoveAll (  )  ;", "assertTrue ( isEmpty ( cache )  )  ;", "}", "METHOD_END"], "methodName": ["earlyRemoveAll"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    getCache ( AbstractJCacheAnnotationTests . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( name . getMethodName (  )  )  ;", "cache . put ( key ,    new   Object (  )  )  ;", "try    {", "service . earlyRemoveAllWithException ( true )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "}", "assertTrue ( isEmpty ( cache )  )  ;", "}", "METHOD_END"], "methodName": ["earlyRemoveAllWithException"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    getCache ( AbstractJCacheAnnotationTests . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( name . getMethodName (  )  )  ;", "cache . put ( key ,    new   Object (  )  )  ;", "try    {", "service . earlyRemoveAllWithException ( false )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( NullPointerException   e )     {", "}", "assertTrue ( isEmpty ( cache )  )  ;", "}", "METHOD_END"], "methodName": ["earlyRemoveAllWithExceptionVetoRemove"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "cache . put ( key ,    value )  ;", "try    {", "service . earlyRemoveWithException ( keyItem ,    true )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "}", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["earlyRemoveWithException"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "cache . put ( key ,    value )  ;", "try    {", "service . earlyRemoveWithException ( keyItem ,    false )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( NullPointerException   e )     {", "}", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["earlyRemoveWithExceptionVetoRemove"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    cacheManager . getCache ( name )  ;", "assertNotNull (  (  (  \" required   cache    \"     +    name )     +     \"    does   not   exist \"  )  ,    cache )  ;", "return   cache ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentHashMap <  ?  ,     ?  >    nativeCache    =     (  ( ConcurrentHashMap <  ?  ,     ?  >  )     ( cache . getNativeCache (  )  )  )  ;", "return   nativeCache . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "serviceWithException ( keyItem ,    true )  ;", "throw   new   IllegalStateException (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "return   e ;", "}", "}", "METHOD_END"], "methodName": ["methodInCallStack"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "assertNull ( cache . get ( key )  )  ;", "service . put ( keyItem ,    value )  ;", "Cache . ValueWrapper   result    =    cache . get ( key )  ;", "assertNotNull ( result )  ;", "assertEquals ( value ,    result . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "assertNull ( cache . get ( key )  )  ;", "try    {", "service . putWithException ( keyItem ,    value ,    true )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "}", "Cache . ValueWrapper   result    =    cache . get ( key )  ;", "assertNotNull ( result )  ;", "assertEquals ( value ,    result . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["putWithException"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "assertNull ( cache . get ( key )  )  ;", "try    {", "service . putWithException ( keyItem ,    value ,    false )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( NullPointerException   e )     {", "}", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["putWithExceptionVetoPut"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "cache . put ( key ,    value )  ;", "service . remove ( keyItem )  ;", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    getCache ( AbstractJCacheAnnotationTests . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( name . getMethodName (  )  )  ;", "cache . put ( key ,    new   Object (  )  )  ;", "service . removeAll (  )  ;", "assertTrue ( isEmpty ( cache )  )  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    getCache ( AbstractJCacheAnnotationTests . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( name . getMethodName (  )  )  ;", "cache . put ( key ,    new   Object (  )  )  ;", "try    {", "service . removeAllWithException ( true )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "}", "assertTrue ( isEmpty ( cache )  )  ;", "}", "METHOD_END"], "methodName": ["removeAllWithException"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "Cache   cache    =    getCache ( AbstractJCacheAnnotationTests . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( name . getMethodName (  )  )  ;", "cache . put ( key ,    new   Object (  )  )  ;", "try    {", "service . removeAllWithException ( false )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( NullPointerException   e )     {", "}", "assertNotNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["removeAllWithExceptionVetoRemove"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "cache . put ( key ,    value )  ;", "try    {", "service . removeWithException ( keyItem ,    true )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "}", "assertNull ( cache . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["removeWithException"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "String   keyItem    =    name . getMethodName (  )  ;", "Cache   cache    =    getCache (  . DEFAULT _ CACHE )  ;", "Object   key    =    createKey ( keyItem )  ;", "Object   value    =    new   Object (  )  ;", "cache . put ( key ,    value )  ;", "try    {", "service . removeWithException ( keyItem ,    false )  ;", "fail (  \" Should   have   thrown   an   exception \"  )  ;", "}    catch    ( NullPointerException   e )     {", "}", "Cache . ValueWrapper   wrapper    =    cache . get ( key )  ;", "assertNotNull ( wrapper )  ;", "assertEquals ( value ,    wrapper . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["removeWithExceptionVetoRemove"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "ctx    =    getApplicationContext (  )  ;", "service    =    ctx . getBean ( ableService . class )  ;", "cacheManager    =    ctx . getBean (  \" cacheManager \"  ,    CacheManager . class )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultJCacheOperationSource   source    =    new   DefaultJCacheOperationSource (  )  ;", "if    (  ( this . cacheManager )     !  =    null )     {", "source . setCacheManager ( this . cacheManager )  ;", "}", "if    (  ( this . keyGenerator )     !  =    null )     {", "source . setKeyGenerator ( this . keyGenerator )  ;", "}", "if    (  ( this . cacheResolver )     !  =    null )     {", "source . setCacheResolver ( this . cacheResolver )  ;", "}", "if    (  ( this . exceptionCacheResolver )     !  =    null )     {", "source . setExceptionCacheResolver ( this . exceptionCacheResolver )  ;", "}", "return   source ;", "}", "METHOD_END"], "methodName": ["cacheOperationSource"], "fileName": "org.springframework.cache.jcache.config.AbstractJCacheConfiguration"}, {"methodBody": ["METHOD_START", "{", "try    {", "csWithCheckedException (  \" id \"  ,    true )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( RuntimeException   e )     {", "assertNotNull (  \" missing   original   exception \"  ,    e . getCause (  )  )  ;", "assertEquals ( IOException . class ,    e . getCause (  )  . getClass (  )  )  ;", "}    catch    ( Exception   e )     {", "fail (  (  \" Wrong   exception   type    \"     +    e )  )  ;", "}", "}", "METHOD_END"], "methodName": ["customInterceptorAppliesWithCheckedException"], "fileName": "org.springframework.cache.jcache.config.JCacheCustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    cs . cacheWithException (  \" id \"  ,    true )  ;", "assertEquals (  5  5 L ,    o )  ;", "}", "METHOD_END"], "methodName": ["customInterceptorAppliesWithRuntimeException"], "fileName": "org.springframework.cache.jcache.config.JCacheCustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    JCacheInterceptor >    interceptors    =    ctx . getBeansOfType ( JCacheInterceptor . class )  ;", "assertEquals (  \" Only   one   interceptor   should   be   defined \"  ,     1  ,    interceptors . size (  )  )  ;", "JCacheInterceptor   interceptor    =    interceptors . values (  )  . iterator (  )  . next (  )  ;", "assertEquals (  \" Custom   interceptor   not   defined \"  ,     . TestCacheInterceptor . class ,    interceptor . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["onlyOneInterceptorIsAvailable"], "fileName": "org.springframework.cache.jcache.config.JCacheCustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ctx    =    new   AnnotationConfigApplicationContext ( JCacheCustomInterceptorTests . EnableCachingConfig . class )  ;", "cs    =    ctx . getBean (  \" service \"  ,    JCacheableService . class )  ;", "exceptionCache    =    ctx . getBean (  \" exceptionCache \"  ,    Cache . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.jcache.config.JCacheCustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( tx )     !  =    null )     {", "txlose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.cache.jcache.config.JCacheCustomInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JCacheJavaConfigTests . FullCachingConfigSupport . class )  ;", "DefaultJCacheOperationSource   cos    =    context . getBean ( DefaultJCacheOperationSource . class )  ;", "assertSame ( context . getBean (  \" cacheResolver \"  )  ,    cos . getCacheResolver (  )  )  ;", "assertSame ( context . getBean (  \" keyGenerator \"  )  ,    cos . getKeyGenerator (  )  )  ;", "assertSame ( context . getBean (  \" exceptionCacheResolver \"  )  ,    cos . getExceptionCacheResolver (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["bothSetOnlyResolverIsUsed"], "fileName": "org.springframework.cache.jcache.config.JCacheJavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JCacheJavaConfigTests . EmptyConfigSupportConfig . class )  ;", "DefaultJCacheOperationSource   cos    =    context . getBean ( DefaultJCacheOperationSource . class )  ;", "assertNotNull ( cos . getCacheResolver (  )  )  ;", "assertEquals ( SimpleCacheResolver . class ,    cos . getCacheResolver (  )  . getClass (  )  )  ;", "assertSame ( context . getBean ( CacheManager . class )  ,     (  ( SimpleCacheResolver )     ( cos . getCacheResolver (  )  )  )  . getCacheManager (  )  )  ;", "assertNull ( cos . getExceptionCacheResolver (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["emptyConfigSupport"], "fileName": "org.springframework.cache.jcache.config.JCacheJavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JCacheJavaConfigTests . NoExceptionCacheResolverConfig . class )  ;", "try    {", "DefaultJCacheOperationSource   cos    =    context . getBean ( DefaultJCacheOperationSource . class )  ;", "assertSame ( context . getBean (  \" cacheResolver \"  )  ,    cos . getCacheResolver (  )  )  ;", "JCacheableService <  ?  >    service    =    context . getBean ( JCacheableService . class )  ;", "service . cache (  \" id \"  )  ;", "thrown . expect ( IllegalStateException . class )  ;", "service . cacheWithException (  \" test \"  ,    false )  ;", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["exceptionCacheResolverLazilyRequired"], "fileName": "org.springframework.cache.jcache.config.JCacheJavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JCacheJavaConfigTests . FullCachingConfig . class )  ;", "DefaultJCacheOperationSource   cos    =    context . getBean ( DefaultJCacheOperationSource . class )  ;", "assertSame ( context . getBean ( KeyGenerator . class )  ,    cos . getKeyGenerator (  )  )  ;", "assertSame ( context . getBean (  \" cacheResolver \"  ,    CacheResolver . class )  ,    cos . getCacheResolver (  )  )  ;", "assertSame ( context . getBean (  \" exceptionCacheResolver \"  ,    CacheResolver . class )  ,    cos . getExceptionCacheResolver (  )  )  ;", "JCacheInterceptor   interceptor    =    context . getBean ( JCacheInterceptor . class )  ;", "assertSame ( context . getBean (  \" errorHandler \"  ,    CacheErrorHandler . class )  ,    interceptor . getErrorHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["fullCachingConfig"], "fileName": "org.springframework.cache.jcache.config.JCacheJavaConfigTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    new   GenericXmlApplicationContext (  \"  / org / springframework / cache / jcache / config / jCacheNamespaceDriven - resolver . xml \"  )  ;", "DefaultJCacheOperationSource   ci    =    context . getBean ( DefaultJCacheOperationSource . class )  ;", "assertSame ( context . getBean (  \" cacheResolver \"  )  ,    ci . getCacheResolver (  )  )  ;", "context . close (  )  ;", "}", "METHOD_END"], "methodName": ["cacheResolver"], "fileName": "org.springframework.cache.jcache.config.JCacheNamespaceDrivenTests"}, {"methodBody": ["METHOD_START", "{", "JCacheInterceptor   ci    =    ctx . getBean ( JCacheInterceptor . class )  ;", "assertSame ( ctx . getBean (  \" errorHandler \"  ,    CacheErrorHandler . class )  ,    ci . getErrorHandler (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheErrorHandler"], "fileName": "org.springframework.cache.jcache.config.JCacheNamespaceDrivenTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactoryJCacheOperationSourceAdvisor   advisor    =    new   BeanFactoryJCacheOperationSourceAdvisor (  )  ;", "advisor . setCacheOperationSource ( cacheOperationSource (  )  )  ;", "advisor . setAdvice ( cacheInterceptor (  )  )  ;", "if    (  ( this . enableCaching )     !  =    null )     {", "advisor . setOrder ( this . enableCaching .  < Integer > getNumber (  \" order \"  )  )  ;", "}", "return   advisor ;", "}", "METHOD_END"], "methodName": ["cacheAdvisor"], "fileName": "org.springframework.cache.jcache.config.ProxyJCacheConfiguration"}, {"methodBody": ["METHOD_START", "{", "JCacheInterceptor   interceptor    =    new   JCacheInterceptor (  )  ;", "interceptor . setCacheOperationSource ( cacheOperationSource (  )  )  ;", "if    (  ( this . errorHandler )     !  =    null )     {", "interceptor . setErrorHandler ( this . errorHandler )  ;", "}", "return   interceptor ;", "}", "METHOD_END"], "methodName": ["cacheInterceptor"], "fileName": "org.springframework.cache.jcache.config.ProxyJCacheConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty (  )  )     {", "return   null ;", "} else", "if    (  (  . size (  )  )     =  =     1  )     {", "return    . iterator (  )  . next (  )  ;", "} else    {", "throw   new   IllegalStateException (  (  (  \" Unsupported   resolution   result    \"     +     )     +     \"  :    JSR -  1  0  7    only   supports   a   single    \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["extractFrom"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractCacheInterceptor"}, {"methodBody": ["METHOD_START", "{", "Collection <  ?    extends   Cache >    caches    =    context . getOperation (  )  . getCacheResolver (  )  . resolveCaches ( context )  ;", "Cache   cache    =     . extractFrom ( caches )  ;", "if    ( cache    =  =    null )     {", "throw   new   IllegalStateException (  (  \" Cache   could   not   have   been   resolved   for    \"     +     ( context . getOperation (  )  )  )  )  ;", "}", "return   cache ;", "}", "METHOD_END"], "methodName": ["resolveCache"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractCacheInterceptor"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  (  \" wrong   parameter   type   for    \"     +    actual )  ,    targetType ,    actual . getRawType (  )  )  ;", "assertEquals (  (  \" wrong   parameter   value   for    \"     +    actual )  ,    value ,    actual . getValue (  )  )  ;", "assertEquals (  (  \" wrong   parameter   position   for    \"     +    actual )  ,    position ,    actual . getParameterPosition (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCacheInvocationParameter"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractCacheOperationTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( targetType ,    methodName ,    parameterTypes )  ;", "Assert . notNull ( method ,     (  (  \" requested   method    '  \"     +    methodName )     +     \"  ' does   not   exist \"  )  )  ;", "A   cacheAnnotation    =    method . getAnnotation ( annotationType )  ;", "return   new   DefaultCacheMethodDetails ( method ,    cacheAnnotation ,     . getCacheName ( cacheAnnotation )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractCacheOperationTests"}, {"methodBody": ["METHOD_START", "{", "Object   cacheName    =    AnnotationUtils . getValue ( annotation ,     \" cacheName \"  )  ;", "return   cacheName    !  =    null    ?    cacheName . toString (  )     :     \" test \"  ;", "}", "METHOD_END"], "methodName": ["getCacheName"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractCacheOperationTests"}, {"methodBody": ["METHOD_START", "{", "O   operation    =    createSimpleOperation (  )  ;", "assertEquals (  \" Wrong   cache   name \"  ,     \" simpleCache \"  ,    operation . getCacheName (  )  )  ;", "assertEquals (  (  \" Unexpected   number   of   annotation   on    \"     +     ( operation . getMethod (  )  )  )  ,     1  ,    operation . getAnnotations (  )  . size (  )  )  ;", "assertEquals (  \" Wrong   method   annotation \"  ,    operation . getCacheAnnotation (  )  ,    operation . getAnnotations (  )  . iterator (  )  . next (  )  )  ;", "assertNotNull (  \" cache   resolver   should   be   set \"  ,    operation . getCacheResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["simple"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractCacheOperationTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["allowPublicMethodsOnly"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractFallbackJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( allowPublicMethodsOnly (  )  )     &  &     (  !  ( Modifier . isPublic ( method . getModifiers (  )  )  )  )  )     {", "return   null ;", "}", "Method   specificMethod    =    AopUtils . getMostSpecificMethod ( method ,    targetClass )  ;", "<  ?  >    operation    =    findCacheOperation ( specificMethod ,    targetClass )  ;", "if    ( operation    !  =    null )     {", "return   operation ;", "}", "if    ( specificMethod    !  =    method )     {", "operation    =    findCacheOperation ( method ,    targetClass )  ;", "if    ( operation    !  =    null )     {", "return   operation ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["computeCacheOperation"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractFallbackJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "return   this . keyGenerator ;", "}", "METHOD_END"], "methodName": ["getKeyGenerator"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractJCacheKeyOperation"}, {"methodBody": ["METHOD_START", "{", "List < CacheInvocationParameter >    result    =    new   ArrayList <  >  (  )  ;", "for    ( Operation . CacheParameterDetail   keyParameterDetail    :    this . keyParameterDetails )     {", "int   parameterPosition    =    keyParameterDetail . getParameterPosition (  )  ;", "if    ( parameterPosition    >  =     ( values . length )  )     {", "throw   new   IllegalStateException (  (  (  (  (  \" Values   mismatch ,    key   parameter   at   position    \"     +    parameterPosition )     +     \"    cannot   be   matched   against    \"  )     +     ( values . length )  )     +     \"    value ( s )  \"  )  )  ;", "}", "result . add ( keyParameterDetail . toCacheInvocationParameter ( values [ parameterPosition ]  )  )  ;", "}", "return   result . toArray ( new   CacheInvocationParameter [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getKeyParameters"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractJCacheKeyOperation"}, {"methodBody": ["METHOD_START", "{", "List < AbstractJCacheOperation . CacheParameterDetail >    all    =    new   ArrayList <  >  (  )  ;", "List < AbstractJCacheOperation . CacheParameterDetail >    annotated    =    new   ArrayList <  >  (  )  ;", "for    ( AbstractJCacheOperation . CacheParameterDetail   allParameter    :    allParameters )     {", "if    (  !  ( allParameter . isValue (  )  )  )     {", "all . add ( allParameter )  ;", "}", "if    ( allParameter . isKey (  )  )     {", "annotated . add ( allParameter )  ;", "}", "}", "return   annotated . isEmpty (  )     ?    all    :    annotated ;", "}", "METHOD_END"], "methodName": ["initializeKeyParameterDetails"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractJCacheKeyOperation"}, {"methodBody": ["METHOD_START", "{", "return   new   ExceptionTypeFilter ( Arrays . asList ( includes )  ,    Arrays . asList ( excludes )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["createExceptionTypeFilter"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractJCacheOperation"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "result . append ( getClass (  )  . getSimpleName (  )  )  ;", "result . append (  \"  [  \"  )  ;", "result . append ( this . methodDetails )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getOperationDescription"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractJCacheOperation"}, {"methodBody": ["METHOD_START", "{", "List < AbstractJCacheOperation . CacheParameterDetail >    result    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     ( method . getParameterCount (  )  )  ;    i +  +  )     {", "AbstractJCacheOperation . CacheParameterDetail   detail    =    new   AbstractJCacheOperation . CacheParameterDetail ( method ,    i )  ;", "result . add ( detail )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["initializeAllParameterDetails"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractJCacheOperation"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheKeyInvocationContext ( context . getOperation (  )  ,    context . getTarget (  )  ,    context . getArgs (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCacheKeyInvocationContext"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractKeyCacheInterceptor"}, {"methodBody": ["METHOD_START", "{", "KeyGenerator   keyGenerator    =    context . getOperation (  )  . getKeyGenerator (  )  ;", "Object   key    =    keyGenerator . generate ( context . getTarget (  )  ,    context . getMethod (  )  ,    context . getArgs (  )  )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Computed      key    \"     +    key )     +     \"    for   operation    \"  )     +     ( context . getOperation (  )  )  )  )  ;", "}", "return   key ;", "}", "METHOD_END"], "methodName": ["generateKey"], "fileName": "org.springframework.cache.jcache.interceptor.AbstractKeyCacheInterceptor"}, {"methodBody": ["METHOD_START", "{", "long   count    =    exceptionCounter . getAndIncrement (  )  ;", "if    ( matchFilter )     {", "throw   new   IOException (  (  (  \" Expected   exception    (  \"     +    count )     +     \"  )  \"  )  )  ;", "} else    {", "throw   new   NullPoException (  (  (  \" Expected   exception    (  \"     +    count )     +     \"  )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["throwCheckedException"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotatedJCacheableService"}, {"methodBody": ["METHOD_START", "{", "long   count    =    exceptionCounter . getAndIncrement (  )  ;", "if    ( matchFilter )     {", "throw   new   UnsupportedOperationException (  (  (  \" Expected   exception    (  \"     +    count )     +     \"  )  \"  )  )  ;", "} else    {", "throw   new   NullPoException (  (  (  \" Expected   exception    (  \"     +    count )     +     \"  )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["throwException"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotatedJCacheableService"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Wrong   cache   resolver   implementation \"  ,    KeyGeneratorAdapter . class ,    actual . getClass (  )  )  ;", "KeyGeneratorAdapter   adapter    =     (  ( KeyGeneratorAdapter )     ( actual )  )  ;", "assertEquals (  \" Wrong   target   CacheKeyGenerator   implementation \"  ,    expectedTargetType ,    adapter . getTarget (  )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCacheKeyGenerator"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( defaultCacheResolver ,    operation . getCacheResolver (  )  )  ;", "assertEquals ( KeyGeneratorAdapter . class ,    operation . getKeyGenerator (  )  . getClass (  )  )  ;", "assertEquals ( defaultKeyGenerator ,     (  ( KeyGeneratorAdapter )     ( operation . getKeyGenerator (  )  )  )  . getTarget (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDefaults"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "if    ( expectedTargetType    =  =    null )     {", "assertNull ( actual )  ;", "} else    {", "assertEquals (  \" Wrong   cache   resolver   implemen \"  ,    CacheResolverAdapter . class ,    actual . getClass (  )  )  ;", "CacheResolverAdapter   adapter    =     (  ( CacheResolverAdapter )     ( actual )  )  ;", "assertEquals (  \" Wrong   target   JCache   implemen \"  ,    expectedTargetType ,    adapter . getTarget (  )  . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertJCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CacheResultOperation   op    =    getDefaultCacheOperation ( CacheResultOperation . class ,    String . class )  ;", "assertDefaults ( op )  ;", "assertNull (  \" Exception   caching   not   enabled   so   resolver   should   not   be   set \"  ,    op . getExceptionCacheResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["cache"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CacheResultOperation   op    =    getDefaultCacheOperation ( CacheResultOperation . class ,    String . class ,    boolean . class )  ;", "assertDefaults ( op )  ;", "assertEquals ( defaultExceptionCacheResolver ,    op . getExceptionCacheResolver (  )  )  ;", "assertEquals (  \" exception \"  ,    op . getExceptionCacheName (  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheWithException"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CacheResultOperation   operation    =    getCacheOperation ( CacheResultOperation . class ,    AnnotationCacheOperationSourceTests . CustomService . class ,    name . getMethodName (  )  ,    Long . class )  ;", "assertJCacheResolver ( operation . getCacheResolver (  )  ,    TestableCacheResolver . class )  ;", "assertJCacheResolver ( operation . getExceptionCacheResolver (  )  ,    null )  ;", "assertEquals ( KeyGeneratorAdapter . class ,    operation . getKeyGenerator (  )  . getClass (  )  )  ;", "assertEquals ( defaultKeyGenerator ,     (  ( KeyGeneratorAdapter )     ( operation . getKeyGenerator (  )  )  )  . getTarget (  )  )  ;", "}", "METHOD_END"], "methodName": ["customCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CacheResultOperation   operation    =    getCacheOperation ( CacheResultOperation . class ,    AnnotationCacheOperationSourceTests . CustomService . class ,    name . getMethodName (  )  ,    Long . class )  ;", "assertEquals ( defaultCacheResolver ,    operation . getCacheResolver (  )  )  ;", "assertNull ( operation . getExceptionCacheResolver (  )  )  ;", "assertCacheKeyGenerator ( operation . getKeyGenerator (  )  ,    TestableCacheKeyGenerator . class )  ;", "}", "METHOD_END"], "methodName": ["customKeyGenerator"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CacheResultOperation   operation    =    getCacheOperation ( CacheResultOperation . class ,    AnnotationCacheOperationSourceTests . CustomServiceWithDefaults . class ,    name . getMethodName (  )  ,    Long . class )  ;", "assertJCacheResolver ( operation . getCacheResolver (  )  ,    TestableCacheResolver . class )  ;", "assertJCacheResolver ( operation . getExceptionCacheResolver (  )  ,    null )  ;", "assertCacheKeyGenerator ( operation . getKeyGenerator (  )  ,    TestableCacheKeyGenerator . class )  ;", "}", "METHOD_END"], "methodName": ["customKeyGeneratorAndCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CacheResultOperation   operation    =    getCacheOperation ( CacheResultOperation . class ,    AnnotationCacheOperationSourceTests . CustomServiceWithDefaults . class ,    name . getMethodName (  )  ,    Long . class )  ;", "assertJCacheResolver ( operation . getCacheResolver (  )  ,    TestableCacheResolver . class )  ;", "assertJCacheResolver ( operation . getExceptionCacheResolver (  )  ,    TestableCacheResolver . class )  ;", "assertCacheKeyGenerator ( operation . getKeyGenerator (  )  ,    TestableCacheKeyGenerator . class )  ;", "}", "METHOD_END"], "methodName": ["customKeyGeneratorAndCacheResolverWithExceptionName"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "TestableCacheKeyGenerator   bean    =    new   TestableCacheKeyGenerator (  )  ;", "beanFactory . registerSingleton (  \" fooBar \"  ,    bean )  ;", "CacheResultOperation   operation    =    getCacheOperation ( CacheResultOperation . class ,     . CustomService . class ,    name . getMethodName (  )  ,    Long . class )  ;", "assertEquals ( defaultCacheResolver ,    operation . getCacheResolver (  )  )  ;", "assertNull ( operation . getExceptionCacheResolver (  )  )  ;", "KeyGeneratorAdapter   adapter    =     (  ( KeyGeneratorAdapter )     ( operation . getKeyGenerator (  )  )  )  ;", "assertSame ( bean ,    adapter . getTarget (  )  )  ;", "}", "METHOD_END"], "methodName": ["customKeyGeneratorSpringBean"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( Object . class ,     \" toString \"  )  ;", "assertEquals (  \" toString (  )  \"  ,    source . determineName ( method ,    null ,     \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultCacheNameNoDefaults"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( Object . class ,     \" toString \"  )  ;", "assertEquals (  \" foo \"  ,    s . determineCacheName ( method ,    null ,     \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultCacheNameWithCandidate"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( Object . class ,     \" toString \"  )  ;", "CacheDefaults   mock    =    mock ( CacheDefaults . class )  ;", "given ( mocName (  )  )  . willReturn (  \"  \"  )  ;", "assertEquals (  \" toString (  )  \"  ,    source . determineCacheName ( method ,    mock ,     \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultCacheNameWithDefaults"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( Comparator . class ,     \" compare \"  ,    Object . class ,    Object . class )  ;", "assertEquals (  \" compare ( Object , Object )  \"  ,    source . determineName ( method ,    null ,     \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultCacheNameWithParameters"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "JCacheOperation <  ?  >    result    =    getCacheOperation ( targetType ,    methodName ,    parameterTypes )  ;", "assertNotNull ( result )  ;", "assertEquals ( operationType ,    result . getClass (  )  )  ;", "return   operationType . cast ( result )  ;", "}", "METHOD_END"], "methodName": ["getCacheOperation"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( targetType ,    methodName ,    parameterTypes )  ;", "Assert . notNull ( method ,     (  (  \" requested   method    '  \"     +    methodName )     +     \"  ' does   not   exist \"  )  )  ;", "return   source . get ( method ,    targetType )  ;", "}", "METHOD_END"], "methodName": ["getCacheOperation"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "return   getCacheOperation ( operationType ,    AnnotatedJCacheableService . class ,    name . getMethodName (  )  ,    parameterTypes )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCacheOperation"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalStateException . class )  ;", "getCacheOperation (  . InvalidCases . class ,    name . getMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["multiAnnotations"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( getCacheOperation ( AnnotatedJCacheableService . class ,    name . getMethodName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["noAnnotation"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CachePutOperation   op    =    getDefaultCacheOperation ( CachePutOperation . class ,    String . class ,    Object . class )  ;", "assertDefaults ( op )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CacheRemoveOperation   op    =    getDefaultCacheOperation ( CacheRemoveOperation . class ,    String . class )  ;", "assertDefaults ( op )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "CacheRemoveAllOperation   op    =    getDefaultCacheOperation ( CacheRemoveAllOperation . class )  ;", "assertEquals ( defaultCacheResolver ,    op . getCacheResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "source . setCacheResolver ( defaultCacheResolver )  ;", "source . setExcepResolver ( defaultExcepResolver )  ;", "source . setKeyGenerator ( defaultKeyGenerator )  ;", "source . setBeanFactory ( beanFactory )  ;", "source . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationCacheOperationSourceTests"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "for    ( Object   instance    :    instances )     {", "if    ( instance    !  =    null )     {", "result    +  =     1  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["countNonNull"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "String   cacheName    =    determineCacheName ( method ,    defaults ,    ann . cacheName (  )  )  ;", "CacheResolverFactory   cacheResolverFactory    =    determineCacheResolverFactory ( defaults ,    ann . cacheResolverFactory (  )  )  ;", "KeyGenerator   keyGenerator    =    determineKeyGenerator ( defaults ,    ann . cacheKeyGenerator (  )  )  ;", "CacheMethodDetails < CachePut >    methodDetails    =    createMethodDetails ( method ,    ann ,    cacheName )  ;", "CacheResolver   cacheResolver    =    getCacheResolver ( cacheResolverFactory ,    methodDetails )  ;", "return   new   CachePut ( methodDetails ,    cacheResolver ,    keyGenerator )  ;", "}", "METHOD_END"], "methodName": ["createCachePutOperation"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "String   cacheName    =    determineCacheName ( method ,    defaults ,    ann . cacheName (  )  )  ;", "CacheResolverFactory   cacheResolverFactory    =    determineCacheResolverFactory ( defaults ,    ann . cacheResolverFactory (  )  )  ;", "CacheMethodDetails < CacheRemoveAll >    methodDetails    =    createMethodDetails ( method ,    ann ,    cacheName )  ;", "CacheResolver   cacheResolver    =    getCacheResolver ( cacheResolverFactory ,    methodDetails )  ;", "return   new   CacheRemoveAll ( methodDetails ,    cacheResolver )  ;", "}", "METHOD_END"], "methodName": ["createCacheRemoveAllOperation"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "String   cacheName    =    determineCacheName ( method ,    defaults ,    ann . cacheName (  )  )  ;", "CacheResolverFactory   cacheResolverFactory    =    determineCacheResolverFactory ( defaults ,    ann . cacheResolverFactory (  )  )  ;", "KeyGenerator   keyGenerator    =    determineKeyGenerator ( defaults ,    ann . cacheKeyGenerator (  )  )  ;", "CacheMethodDetails < CacheRemove >    methodDetails    =    createMethodDetails ( method ,    ann ,    cacheName )  ;", "CacheResolver   cacheResolver    =    getCacheResolver ( cacheResolverFactory ,    methodDetails )  ;", "return   new   CacheRemov ( methodDetails ,    cacheResolver ,    keyGenerator )  ;", "}", "METHOD_END"], "methodName": ["createCacheRemoveOperation"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "String   cacheName    =    determineCacheName ( method ,    defaults ,    ann . cacheName (  )  )  ;", "CacheResolverFactory   cacheResolverFactory    =    determineCacheResolverFactory ( defaults ,    ann . cacheResolverFactory (  )  )  ;", "KeyGenerator   keyGenerator    =    determineKeyGenerator ( defaults ,    ann . cacheKeyGenerator (  )  )  ;", "CacheMethodDetails < CacheResult >    methodDetails    =    createMethodDetails ( method ,    ann ,    cacheName )  ;", "CacheResolver   cacheResolver    =    getCacheResolver ( cacheResolverFactory ,    methodDetails )  ;", "CacheResolver   exceptionCacheResolver    =    null ;", "final   String   exceptionCacheName    =    ann . exceptionCacheName (  )  ;", "if    ( StringUtils . hasText ( exceptionCacheName )  )     {", "exceptionCacheResolver    =    getExceptionCacheResolver ( cacheResolverFactory ,    methodDetails )  ;", "}", "return   new   CacheResult ( methodDetails ,    cacheResolver ,    keyGenerator ,    exceptionCacheResolver )  ;", "}", "METHOD_END"], "methodName": ["createCacheResultOperation"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheMethodDetails ( method ,    annotation ,    cacheName )  ;", "}", "METHOD_END"], "methodName": ["createMethodDetails"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( candidate )  )     {", "return   candidate ;", "}", "if    (  ( defaults    !  =    null )     &  &     ( StringUtils . hasText ( defaultsName (  )  )  )  )     {", "return   defaultsName (  )  ;", "}", "return   generateDefaultCacheName ( method )  ;", "}", "METHOD_END"], "methodName": ["determineCacheName"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( CacheResolverFactory . class )     !  =    candidate )     {", "return   getBean ( candidate )  ;", "} else", "if    (  ( defaults    !  =    null )     &  &     (  ( CacheResolverFactory . class )     !  =     ( defaultsResolverFactory (  )  )  )  )     {", "return   getBean ( defaultsResolverFactory (  )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["determineCacheResolverFactory"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( CacheKeyGenerator . class )     !  =    candidate )     {", "return   new   KeyGeneratorAdapter ( this ,    getBean ( candidate )  )  ;", "} else", "if    (  ( defaults    !  =    null )     &  &     (  ( CacheKeyGenerator . class )     !  =     ( defaultsKeyGenerator (  )  )  )  )     {", "return   new   KeyGeneratorAdapter ( this ,    getBean ( defaultsKeyGenerator (  )  )  )  ;", "} else    {", "return   getDefaultKeyGenerator (  )  ;", "}", "}", "METHOD_END"], "methodName": ["determineKeyGenerator"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "List < String >    parameters    =    new   ArrayList <  >  ( parameterTypes . length )  ;", "for    ( Class <  ?  >    parameterType    :    parameterTypes )     {", "parameters . add ( parameterType . getName (  )  )  ;", "}", "StringBuilder   sb    =    new   StringBuilder ( method . getDeclaringClass (  )  . getName (  )  )  ;", "sb . append (  \"  .  \"  )  . append ( method . getName (  )  )  ;", "sb . append (  \"  (  \"  )  . append ( StringUtils . collectionToCommaDelimitedString ( parameters )  )  . append (  \"  )  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateDefaultCacheName"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "CacheDefaults   annotation    =    method . getDeclaringClass (  )  . getAnnotation ( CacheDefaults . class )  ;", "if    ( annotation    !  =    null )     {", "return   annotation ;", "}", "return   targetType . getAnnotation ( CacheDefaults . class )  ;", "}", "METHOD_END"], "methodName": ["getCacheDefaults"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "if    ( factory    !  =    null )     {", "Resolver   cacheResolver    =    factory . getResolver ( details )  ;", "return   new   ResolverAdapter ( cacheResolver )  ;", "} else    {", "return   getDefaultResolver (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "if    ( factory    !  =    null )     {", "CacheResolver   Resolver    =    factory . getExceptionCacheResolver ( details )  ;", "return   new   CacheResolverAdapter ( Resolver )  ;", "} else    {", "return   getDefaultExceptionCacheResolver (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getExceptionCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.AnnotationJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "this . cacheOperationSource    =    cacheOperationSource ;", "}", "METHOD_END"], "methodName": ["setCacheOperationSource"], "fileName": "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor"}, {"methodBody": ["METHOD_START", "{", "this . pointcut . setClassFilter ( classFilter )  ;", "}", "METHOD_END"], "methodName": ["setClassFilter"], "fileName": "org.springframework.cache.jcache.interceptor.BeanFactoryJCacheOperationSourceAdvisor"}, {"methodBody": ["METHOD_START", "{", "Object   key    =    generateKey ( context )  ;", "cache    =    resolve ( context )  ;", "doPut ( cache ,    key ,    value )  ;", "}", "METHOD_END"], "methodName": ["cacheValue"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutInterceptor"}, {"methodBody": ["METHOD_START", "{", "int   parameterPosition    =    this . valueParameterDetail . getParameterPosition (  )  ;", "if    ( parameterPosition    >  =     ( values . length )  )     {", "throw   new   IllegalStateException (  (  (  (  (  \" Values   mismatch ,    value   parameter   at   position    \"     +    parameterPosition )     +     \"    cannot   be   matched   against    \"  )     +     ( values . length )  )     +     \"    value ( s )  \"  )  )  ;", "}", "return   this . valueParameterDetail . toInvocationParameter ( values [ parameterPosition ]  )  ;", "}", "METHOD_END"], "methodName": ["getValueParameter"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutOperation"}, {"methodBody": ["METHOD_START", "{", "AbstractJCacheOperation . CacheParameterDetail   result    =    null ;", "for    ( AbstractJCacheOperation . CacheParameterDetail   parameter    :    allParameters )     {", "if    ( parameter . isValue (  )  )     {", "if    ( result    =  =    null )     {", "result    =    parameter ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" More   than   one    @ CacheValue   found   on    \"     +    method )     +     \"  \"  )  )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["initializeValueParameterDetail"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutOperation"}, {"methodBody": ["METHOD_START", "{", "return    !  ( getCacheAnnotation (  )  . afterInvocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEarlyPut"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutOperation"}, {"methodBody": ["METHOD_START", "{", "return   new   CachePutOperation ( methodDetails ,    defaultCacheResolver ,    defaultKeyGenerator )  ;", "}", "METHOD_END"], "methodName": ["createDefaultOperation"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutOperationTests"}, {"methodBody": ["METHOD_START", "{", "CacheMethodDetails < CachePut >    methodDetails    =    create ( CachePut . class ,    SampleObject . class ,     \" fullPutConfig \"  ,    Long . class ,    SampleObject . class )  ;", "operation    =    createDefaultOperation ( methodDetails )  ;", "assertTrue ( operation . isEarlyPut (  )  )  ;", "assertNotNull ( operation . getExceptionTypeFilter (  )  )  ;", "assertTrue ( operation . getExceptionTypeFilter (  )  . match ( IOException . class )  )  ;", "assertFalse ( operation . getExceptionTypeFilter (  )  . match ( NullPointerException . class )  )  ;", "}", "METHOD_END"], "methodName": ["fullPutConfig"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutOperationTests"}, {"methodBody": ["METHOD_START", "{", "CachePutOperation   operation    =    createSimpleOperation (  )  ;", "thrown . expect ( IllegalStateException . class )  ;", "operation . getValueParameter (  2 L )  ;", "}", "METHOD_END"], "methodName": ["invokeWithWrongParameters"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutOperationTests"}, {"methodBody": ["METHOD_START", "{", "CacheMethodDetails < CachePut >    methodDetails    =    create ( CachePut . class ,    SampleObject . class ,     \" multiCacheValues \"  ,    Long . class ,    SampleObject . class ,    SampleObject . class )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "createDefaul ( methodDetails )  ;", "}", "METHOD_END"], "methodName": ["multiCacheValues"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutOperationTests"}, {"methodBody": ["METHOD_START", "{", "CacheMethodDetails < CachePut >    methodDetails    =    create ( CachePut . class ,    SampleObject . class ,     \" noCacheValue \"  ,    Long . class )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "createDefaul ( methodDetails )  ;", "}", "METHOD_END"], "methodName": ["noCacheValue"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutOperationTests"}, {"methodBody": ["METHOD_START", "{", "CachePutOperation   operation    =    createSimpleOperation (  )  ;", "CacheInvocationParameter [  ]    allParameters    =    operation . getAllParameters (  2 L ,    sampleInstance )  ;", "assertEquals (  2  ,    allParameters . length )  ;", "assertCacheInvocationParameter ( allParameters [  0  ]  ,    Long . class ,     2 L ,     0  )  ;", "assertCacheInvocationParameter ( allParameters [  1  ]  ,    SampleObject . class ,    sampleInstance ,     1  )  ;", "CacheInvocationParameter   valueParameter    =    operation . getValueParameter (  2 L ,    sampleInstance )  ;", "assertNotNull ( valueParameter )  ;", "assertCacheInvocationParameter ( valueParameter ,    SampleObject . class ,    sampleInstance ,     1  )  ;", "}", "METHOD_END"], "methodName": ["simplePut"], "fileName": "org.springframework.cache.jcache.interceptor.CachePutOperationTests"}, {"methodBody": ["METHOD_START", "{", "Cache    =    resolveCache ( context )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Invalidating   entire    '  \"     +     ( getName (  )  )  )     +     \"  '    for   operation    \"  )     +     ( context . getOperation (  )  )  )  )  ;", "}", "doClear (  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "org.springframework.cache.jcache.interceptor.CacheRemoveAllInterceptor"}, {"methodBody": ["METHOD_START", "{", "return    !  ( getCacheAnnotation (  )  . afterInvocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEarlyRemove"], "fileName": "org.springframework.cache.jcache.interceptor.CacheRemoveAllOperation"}, {"methodBody": ["METHOD_START", "{", "CacheRemoveAllOperation   operation    =    createSimpleOperation (  )  ;", "CacheInvocationParameter [  ]    allParameters    =    operation . getAllParameters (  )  ;", "assertEquals (  0  ,    allParameters . length )  ;", "}", "METHOD_END"], "methodName": ["simpleRemoveAll"], "fileName": "org.springframework.cache.jcache.interceptor.CacheRemoveAllOperationTests"}, {"methodBody": ["METHOD_START", "{", "Object   key    =    generateKey ( context )  ;", "Cache    =    resolveCache ( context )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  (  \" Invalidating   key    [  \"     +    key )     +     \"  ]    on    '  \"  )     +     ( getName (  )  )  )     +     \"  '    for   operation    \"  )     +     ( context . getOperation (  )  )  )  )  ;", "}", "doEvict (    key )  ;", "}", "METHOD_END"], "methodName": ["removeValue"], "fileName": "org.springframework.cache.jcache.interceptor.CacheRemoveEntryInterceptor"}, {"methodBody": ["METHOD_START", "{", "return    !  ( getCacheAnnotation (  )  . afterInvocation (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEarlyRemove"], "fileName": "org.springframework.cache.jcache.interceptor.CacheRemoveOperation"}, {"methodBody": ["METHOD_START", "{", "CacheRemoveOperation   operation    =    createSimpleOperation (  )  ;", "CacheInvocationParameter [  ]    allParameters    =    operation . getAllParameters (  2 L )  ;", "assertEquals (  1  ,    allParameters . length )  ;", "assertCacheInvocationParameter ( allParameters [  0  ]  ,    Long . class ,     2 L ,     0  )  ;", "}", "METHOD_END"], "methodName": ["simpleRemove"], "fileName": "org.springframework.cache.jcache.interceptor.CacheRemoveOperationTests"}, {"methodBody": ["METHOD_START", "{", "return   target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResolverAdapter"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    CacheResolverAdapterTests . Sample . class . getMethod (  \" get \"  ,    String . class )  ;", "CacheResult   cacheAnnotation    =    method . getAnnotation ( CacheResult . class )  ;", "CacheMethodDetails < CacheResult >    methodDetails    =    new   DefaultCacheMethodDetails ( method ,    cacheAnnotation ,     \" test \"  )  ;", "CacheResultOperation   operation    =    new   CacheResultOperation ( methodDetails ,    defaultCacheResolver ,    defaultKeyGenerator ,    defaultExceptionCacheResolver )  ;", "return   new   DefaultCacheInvocationContext ( operation ,    new   CacheResolverAdapterTests . Sample (  )  ,    new   Object [  ]  {     \" id \"     }  )  ;", "}", "METHOD_END"], "methodName": ["createDummyContext"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "CacheResolver   cacheResolver    =    mock ( CacheResolver . class )  ;", "Cache   cache ;", "if    ( cacheName    =  =    null )     {", "cache    =    null ;", "} else    {", "cache    =    mock ( Cache . class )  ;", "given ( cache . getName (  )  )  . willReturn ( cacheName )  ;", "}", "given ( cacheResolver . resolveCache ( context )  )  . willReturn ( cache )  ;", "return   cacheResolver ;", "}", "METHOD_END"], "methodName": ["getCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "DefaultCacheInvocationContext <  ?  >    dummyContext    =    createDummyContext (  )  ;", "adapter    =    new    ( getCacheResolver ( dummyContext ,     \" testCache \"  )  )  ;", "Collection <  ?    extends   Cache >    caches    =    adapter . resolveCaches ( dummyContext )  ;", "assertNotNull ( caches )  ;", "assertEquals (  1  ,    caches . size (  )  )  ;", "assertEquals (  \" testCache \"  ,    caches . iterator (  )  . next (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveSimpleCache"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "DefaultCacheInvocationContext <  ?  >    dummyContext    =    createDummyContext (  )  ;", "adapter    =    new    ( getCacheResolver ( dummyContext ,    null )  )  ;", "thrown . expect ( IllegalStateException . class )  ;", "adapter . resolveCaches ( dummyContext )  ;", "}", "METHOD_END"], "methodName": ["resolveUnknownCache"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResolverAdapterTests"}, {"methodBody": ["METHOD_START", "{", "if    ( exceptionCache    =  =    null )     {", "return ;", "}", "if    ( filter . match ( ex . getClass (  )  )  )     {", "doPut ( exceptionCache ,    cacheKey ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["cacheException"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultInterceptor"}, {"methodBody": ["METHOD_START", "{", "if    ( exceptionCache    =  =    null )     {", "return ;", "}", "Cache . ValueWrapper   result    =    doGet ( exceptionCache ,    cacheKey )  ;", "if    ( result    !  =    null )     {", "throw    . rewriteCallStack (  (  ( Throwable )     ( result . get (  )  )  )  ,    getClass (  )  . getName (  )  ,     \" invoke \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkForCachedException"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultInterceptor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( T )     ( SerializationUtils . deserialize ( SerializationUtils . serialize ( exion )  )  )  )  ;", "}    catch    ( Exion   ex )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["cloneException"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultInterceptor"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( callStack . length )  ;    i +  +  )     {", "StackTraceElement   element    =    callStack [ i ]  ;", "if    (  ( className . equals ( element . getClassName (  )  )  )     &  &     ( methodName . equals ( element . getMethodName (  )  )  )  )     {", "return   i ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["findCommonAncestorIndex"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultInterceptor"}, {"methodBody": ["METHOD_START", "{", "CacheResolver   exceptionCacheResolver    =    context . getOperation (  )  . getExceptionCacheResolver (  )  ;", "if    ( exceptionCacheResolver    !  =    null )     {", "return   AbstractCacheIextractFrom ( context . getOperation (  )  . getExceptionCacheResolver (  )  . resolveCaches ( context )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveExceptionCache"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultInterceptor"}, {"methodBody": ["METHOD_START", "{", "Throwable   clone    =    CacheResultInterceptor . cloneException ( exception )  ;", "if    ( clone    =  =    null )     {", "return   new   CacheOperationInvoker . ThrowableWrapper ( exception )  ;", "}", "StackTraceElement [  ]    callStack    =    new   Exception (  )  . getStackTrace (  )  ;", "StackTraceElement [  ]    cachedCallStack    =    exception . getStackTrace (  )  ;", "int   index    =    CacheResultInterceptor . findCommonAncestorIndex ( callStack ,    className ,    methodName )  ;", "int   cachedIndex    =    CacheResultInterceptor . findCommonAncestorIndex ( cachedCallStack ,    className ,    methodName )  ;", "if    (  ( index    =  =     (  -  1  )  )     |  |     ( cachedIndex    =  =     (  -  1  )  )  )     {", "return   new   CacheOperationInvoker . ThrowableWrapper ( exception )  ;", "}", "StackTraceElement [  ]    result    =    new   StackTraceElement [  ( cachedIndex    +     ( callStack . length )  )     -    index ]  ;", "System . arraycopy ( cachedCallStack ,     0  ,    result ,     0  ,    cachedIndex )  ;", "System . arraycopy ( callStack ,    index ,    result ,    cachedIndex ,     (  ( callStack . length )     -    index )  )  ;", "clone . setStackTrace ( result )  ;", "return   new   CacheOperationInvoker . ThrowableWrapper ( clone )  ;", "}", "METHOD_END"], "methodName": ["rewriteCallStack"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultInterceptor"}, {"methodBody": ["METHOD_START", "{", "return   this . exceptionCacheName ;", "}", "METHOD_END"], "methodName": ["getExceptionCacheName"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . exceptionCacheResolver ;", "}", "METHOD_END"], "methodName": ["getExceptionCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperation"}, {"methodBody": ["METHOD_START", "{", "return   getCacheAnnotation (  )  . skipGet (  )  ;", "}", "METHOD_END"], "methodName": ["isAlwaysInvoked"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperation"}, {"methodBody": ["METHOD_START", "{", "CacheMethodDetails < CacheResult >    methodDetails    =    create ( CacheResult . class ,    SampleObject . class ,     \" annotatedGet \"  ,    Long . class ,    String . class )  ;", "operation    =    createDefaultOperation ( methodDetails )  ;", "CacheInvocationParameter [  ]    parameters    =    operation . getAllParameters (  2 L ,     \" foo \"  )  ;", "Set < Annotation >    firstParameterAnnotations    =    parameters [  0  ]  . getAnnotations (  )  ;", "assertEquals (  1  ,    firstParameterAnnotations . size (  )  )  ;", "assertEquals ( CacheKey . class ,    firstParameterAnnotations . iterator (  )  . next (  )  . annotationType (  )  )  ;", "Set < Annotation >    secondParameterAnnotations    =    parameters [  1  ]  . getAnnotations (  )  ;", "assertEquals (  1  ,    secondParameterAnnotations . size (  )  )  ;", "assertEquals ( Value . class ,    secondParameterAnnotations . iterator (  )  . next (  )  . annotationType (  )  )  ;", "}", "METHOD_END"], "methodName": ["annotatedGet"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   CacheResultOperation ( methodDetails ,    defaultCacheResolver ,    defaultKeyGenerator ,    defaultCacheResolver )  ;", "}", "METHOD_END"], "methodName": ["createDefaultOperation"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperationTests"}, {"methodBody": ["METHOD_START", "{", "CacheMethodDetails < CacheResult >    methodDetails    =    create ( CacheResult . class ,    SampleObject . class ,     \" fullGetConfig \"  ,    Long . class )  ;", "operation    =    createDefaultOperation ( methodDetails )  ;", "assertTrue ( operation . isAlwaysInvoked (  )  )  ;", "assertNotNull ( operation . getExceptionTypeFilter (  )  )  ;", "assertTrue ( operation . getExceptionTypeFilter (  )  . match ( IOException . class )  )  ;", "assertFalse ( operation . getExceptionTypeFilter (  )  . match ( NullPointerException . class )  )  ;", "}", "METHOD_END"], "methodName": ["fullGetConfig"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperationTests"}, {"methodBody": ["METHOD_START", "{", "CacheMethodDetails < CacheResult >    methodDetails    =    create ( CacheResult . class ,    SampleObject . class ,     \" anotherSimpleGet \"  ,    String . class ,    Long . class )  ;", "operation    =    createDefaultOperation ( methodDetails )  ;", "thrown . expect ( IllegalStateException . class )  ;", "operation . getAllParameters (  \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["invokeWithWrongParameters"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperationTests"}, {"methodBody": ["METHOD_START", "{", "CacheMethodDetails < CacheResult >    methodDetails    =    create ( CacheResult . class ,    SampleObject . class ,     \" multiKeysGet \"  ,    Long . class ,    Boolean . class ,    String . class )  ;", "operation    =    createDefaultOperation ( methodDetails )  ;", "CacheInvocationParameter [  ]    keyParameters    =    operation . getKeyParameters (  3 L ,    Boolean . TRUE ,     \" Foo \"  )  ;", "assertEquals (  2  ,    keyParameters . length )  ;", "assertCacheInvocationParameter ( keyParameters [  0  ]  ,    Long . class ,     3 L ,     0  )  ;", "assertCacheInvocationParameter ( keyParameters [  1  ]  ,    String . class ,     \" Foo \"  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["multiParameterKey"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperationTests"}, {"methodBody": ["METHOD_START", "{", "CacheResultOperation   operation    =    createSimpleOperation (  )  ;", "assertNotNull ( operation . getKeyGenerator (  )  )  ;", "assertNotNull ( operation . getExceptionCacheResolver (  )  )  ;", "assertNull ( operation . getExceptionCacheName (  )  )  ;", "assertEquals ( defaultExceptionCacheResolver ,    operation . getExceptionCacheResolver (  )  )  ;", "CacheInvocationParameter [  ]    allParameters    =    operation . getAllParameters (  2 L )  ;", "assertEquals (  1  ,    allParameters . length )  ;", "assertCacheInvocationParameter ( allParameters [  0  ]  ,    Long . class ,     2 L ,     0  )  ;", "CacheInvocationParameter [  ]    keyParameters    =    operation . getKeyParameters (  2 L )  ;", "assertEquals (  1  ,    keyParameters . length )  ;", "assertCacheInvocationParameter ( keyParameters [  0  ]  ,    Long . class ,     2 L ,     0  )  ;", "}", "METHOD_END"], "methodName": ["simpleGet"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperationTests"}, {"methodBody": ["METHOD_START", "{", "CacheMethodDetails < CacheResult >    methodDetails    =    create ( CacheResult . class ,    SampleObject . class ,     \" anotherSimpleGet \"  ,    String . class ,    Long . class )  ;", "operation    =    createDefaultOperation ( methodDetails )  ;", "thrown . expect ( IllegalStateException . class )  ;", "operation . getKeyParameters (  \" bar \"  )  ;", "}", "METHOD_END"], "methodName": ["tooManyKeyValues"], "fileName": "org.springframework.cache.jcache.interceptor.CacheResultOperationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheManager ;", "}", "METHOD_END"], "methodName": ["getCacheManager"], "fileName": "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheResolver ;", "}", "METHOD_END"], "methodName": ["getCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . cacheManager )     =  =    null )     {", "try    {", "this . cacheManager    =    this . beanFactory . getBean ( CacheManager . class )  ;", "}    catch    ( NoUniqueBeanDefinitionException   ex )     {", "throw   new   IllegalStateException (  (  \" No   unique   bean   of   type   CacheManager   found .     \"     +     \" Mark   one   as   primary   or   declare   a   specific   CacheManager   to   use .  \"  )  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "throw   new   IllegalStateException (  (  \" No   bean   of   type   CacheManager   found .    Register   a   CacheManager    \"     +     \" bean   or   remove   the    @ EnableCaching   annotation   from   your   configuration .  \"  )  )  ;", "}", "}", "return   this . cacheManager ;", "}", "METHOD_END"], "methodName": ["getDefaultCacheManager"], "fileName": "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "return   this . exceptionCacheResolver ;", "}", "METHOD_END"], "methodName": ["getExceptionCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "return   this . keyGenerator ;", "}", "METHOD_END"], "methodName": ["getKeyGenerator"], "fileName": "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "this . cacheManager    =    cacheManager ;", "}", "METHOD_END"], "methodName": ["setCacheManager"], "fileName": "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "this . cacheResolver    =    cacheResolver ;", "}", "METHOD_END"], "methodName": ["setCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "this . exceptionCacheResolver    =    exceptionCacheResolver ;", "}", "METHOD_END"], "methodName": ["setExceptionCacheResolver"], "fileName": "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "this . keyGenerator    =    keyGenerator ;", "}", "METHOD_END"], "methodName": ["setKeyGenerator"], "fileName": "org.springframework.cache.jcache.interceptor.DefaultJCacheOperationSource"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( getCacheOperationSource (  )  )     !  =    null )  ,     (  \" The    ' cacheOperationSource '    property   is   required :     \"     +     \" If   there   are   no   cacheable   methods ,    then   don ' t   use   a   cache   aspect .  \"  )  )  ;", "this . cacheResultI    =    new   CacheResultI ( getErrorHandler (  )  )  ;", "this . cachePutI    =    new   CachePutI ( getErrorHandler (  )  )  ;", "this . cacheRemoveEntryI    =    new   CacheRemoveEntryI ( getErrorHandler (  )  )  ;", "this . cacheRemoveAllI    =    new   CacheRemoveAllI ( getErrorHandler (  )  )  ;", "this . initialized    =    true ;", "}", "METHOD_END"], "methodName": ["afterPropertiesSet"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheInvocationContext (  (  ( JCacheOperation < Annotation >  )     ( operation )  )  ,    target ,    args )  ;", "}", "METHOD_END"], "methodName": ["createCacheOperationInvocationContext"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "CacheOperationInvoker   adapter    =    new   JCacheAspectSupport . CacheOperationInvokerAdapter ( invoker )  ;", "BasicOperation   operation    =    context . getOperation (  )  ;", "if    ( operation   instanceof   CacheResultOperation )     {", "return   this . cacheResultInterceptor . invoke (  (  ( CacheOperationInvocationContext < CacheResultOperation >  )     ( context )  )  ,    adapter )  ;", "} else", "if    ( operation   instanceof   CachePutOperation )     {", "return   this . cachePutInterceptor . invoke (  (  ( CacheOperationInvocationContext < CachePutOperation >  )     ( context )  )  ,    adapter )  ;", "} else", "if    ( operation   instanceof   CacheRemoveOperation )     {", "return   this . cacheRemoveEntryInterceptor . invoke (  (  ( CacheOperationInvocationContext < CacheRemoveOperation >  )     ( context )  )  ,    adapter )  ;", "} else", "if    ( operation   instanceof   CacheRemoveAllOperation )     {", "return   this . cacheRemoveAllInterceptor . invoke (  (  ( CacheOperationInvocationContext < CacheRemoveAllOperation >  )     ( context )  )  ,    adapter )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Cannot   handle    \"     +    operation )  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( this . initialized )     {", "Class <  ?  >    targetClass    =    AopProxyUtils . ultimateTargetClass ( target )  ;", "Operation <  ?  >    operation    =    getCacheOperationSource (  )  . getCacheOperation ( method ,    targetClass )  ;", "if    ( operation    !  =    null )     {", "CacheOperationInvocationContext <  ?  >    context    =    createCacheOperationInvocationContext ( target ,    args ,    operation )  ;", "return   execute ( context ,    invoker )  ;", "}", "}", "return   invoker . invoke (  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheOperationSource ;", "}", "METHOD_END"], "methodName": ["getCacheOperationSource"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "return   invoker . invoke (  )  ;", "}", "METHOD_END"], "methodName": ["invokeOperation"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cacheOperationSource ,     \" JCacheOperationSource   must   not   be   null \"  )  ;", "this . cacheOperationSource    =    cacheOperationSource ;", "}", "METHOD_END"], "methodName": ["setCacheOperationSource"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheAspectSupport"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   evict \"  )  ;", "willThrow ( exception )  . given ( this . cache )  . clear (  )  ;", "this . simpleService . clear (  )  ;", "verify ( this . e )  . handleCacheClearError ( exception ,    this . cache )  ;", "}", "METHOD_END"], "methodName": ["clearFail"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   evict \"  )  ;", "Object   key    =    SimpleKeyGenerator . generateKey (  0 L )  ;", "willThrow ( exception )  . given ( this . cache )  . evict ( key )  ;", "this . simpleService . evict (  0 L )  ;", "verify ( this . e )  . handleCacheEvictError ( exception ,    this . cache ,    key )  ;", "}", "METHOD_END"], "methodName": ["evictFail"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   get \"  )  ;", "Object   key    =    SimpleKeyGenerator . generateKey (  0 L )  ;", "willThrow ( exception )  . given ( this . cache )  . get ( key )  ;", "this . simpleService . get (  0 L )  ;", "verify ( this . e )  . handleCacheGetError ( exception ,    this . cache ,    key )  ;", "}", "METHOD_END"], "methodName": ["getFail"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exceptionOnPut    =    new   UnsupportedOperationException (  \" Test   exception   on   put \"  )  ;", "Object   key    =    SimpleKeyGenerator . generateKey (  0 L )  ;", "given ( this . cache . get ( key )  )  . willReturn ( null )  ;", "willThrow ( exceptionOnPut )  . given ( this . errorCache )  . put ( key ,     . SimpleService . TEST _ EXCEPTION )  ;", "try    {", "this . simpleService . getFail (  0 L )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertEquals (  \" Test   exception \"  ,    ex . getMessage (  )  )  ;", "}", "verify ( this . errorHandler )  . handleCachePutError ( exceptionOnPut ,    this . errorCache ,    key ,     . SimpleService . TEST _ EXCEPTION )  ;", "}", "METHOD_END"], "methodName": ["getFailPutExceptionFail"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   put \"  )  ;", "Object   key    =    SimpleKeyGenerator . generateKey (  0 L )  ;", "given ( this . cache . get ( key )  )  . willReturn ( null )  ;", "willThrow ( exception )  . given ( this . cache )  . put ( key ,     0 L )  ;", "this . simpleService . get (  0 L )  ;", "verify ( this . e )  . handleCachePutError ( exception ,    this . cache ,    key ,     0 L )  ;", "}", "METHOD_END"], "methodName": ["getPutNewElementFail"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   exception    =    new   UnsupportedOperationException (  \" Test   exception   on   put \"  )  ;", "Object   key    =    SimpleKeyGenerator . generateKey (  0 L )  ;", "willThrow ( exception )  . given ( this . cache )  . put ( key ,     2  3  4 L )  ;", "this . simpleService . put (  0 L ,     2  3  4 L )  ;", "verify ( this . e )  . handleCachePutError ( exception ,    this . cache ,    key ,     2  3  4 L )  ;", "}", "METHOD_END"], "methodName": ["putFail"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JCacheErrorHandlerTests . Config . class )  ;", "this . cache    =    context . getBean (  \" mockCache \"  ,    Cache . class )  ;", "this . errorCache    =    context . getBean (  \" mockErrorCache \"  ,    Cache . class )  ;", "this . errorHandler    =    context . getBean ( CacheErrorHandler . class )  ;", "this . simpleService    =    context . getBean ( JCacheErrorHandlerTests . SimpleService . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheErrorHandlerTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalStateException . class )  ;", "createOperationSource ( null ,    null ,    null ,    defaultKeyGenerator )  ;", "}", "METHOD_END"], "methodName": ["cacheManagerMandatoryIfCacheResolverNotSet"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "createOperationSource ( null ,    defaultCacheResolver ,    defaultExceptionCacheResolver ,    defaultKeyGenerator )  ;", "}", "METHOD_END"], "methodName": ["cacheManagerOptionalIfCacheResolversSet"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "JCacheInterceptor   interceptor    =    createInterceptor ( createOperationSource ( cacheManager ,    defaultCacheResolver ,    defaultExceptionCacheResolver ,    defaultKeyGenerator )  )  ;", "AnnotatedJCacheableService   service    =    new   AnnotatedJCacheableService ( cacheManager . getCache (  \" default \"  )  )  ;", "Method   method    =    ReflectionUtils . findMethod ( AnnotatedJCacheableService . class ,     \" cache \"  ,    String . class )  ;", "CacheOperationInvoker   invoker    =    new    . DummyInvoker (  0 L )  ;", "Object   execute    =    interceptor . execute ( invoker ,    service ,    method ,    new   Object [  ]  {     \" myId \"     }  )  ;", "assertNotNull (  \" result   cannot   be   null .  \"  ,    execute )  ;", "assertEquals (  \" Wrong   result   type \"  ,    Long . class ,    execute . getClass (  )  )  ;", "assertEquals (  \" Wrong   result \"  ,     0 L ,    execute )  ;", "}", "METHOD_END"], "methodName": ["cacheResultReturnsProperType"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "JCacheInterceptor   interceptor    =    new   JCacheInterceptor (  )  ;", "interceptor . setCacheOperationSource ( source )  ;", "interceptor . afterPropertiesSet (  )  ;", "return   interceptor ;", "}", "METHOD_END"], "methodName": ["createInterceptor"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultJCacheOperationSource   source    =    new   DefaultJCacheOperationSource (  )  ;", "source . setCacheManager ( cacheManager )  ;", "source . setCacheResolver ( cacheResolver )  ;", "source . setExceptionCacheResolver ( exceptionCacheResolver )  ;", "source . setKeyGenerator ( keyGenerator )  ;", "source . setBeanFactory ( new   StaticListableBeanFactory (  )  )  ;", "source . afterPropertiesSet (  )  ;", "source . afterSingletonsInstantiated (  )  ;", "return   source ;", "}", "METHOD_END"], "methodName": ["createOperationSource"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "JCacheInterceptor   interceptor    =    createInterceptor ( createOperationSource ( cacheManager ,    new   NamedCacheResolver ( cacheManager )  ,    defaultExceptionCacheResolver ,    defaultKeyGenerator )  )  ;", "AnnotatedJCacheableService   service    =    new   AnnotatedJCacheableService ( cacheManager . getCache (  \" default \"  )  )  ;", "Method   m    =    ReflectionUtils . findMethod ( AnnotatedJCacheableService . class ,     \" cache \"  ,    String . class )  ;", "try    {", "interceptor . execute ( dummyInvoker ,    service ,    m ,    new   Object [  ]  {     \" myId \"     }  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" Cache   could   not   have   been   resolved   for \"  )  )  ;", "}    catch    ( Throwable   ex )     {", "fail (  (  \" Unexpected :     \"     +    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["noCacheCouldBeResolved"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "JCacheInterceptor   interceptor    =    createInterceptor ( createOperationSource ( cacheManager ,    new   NamedCacheResolver ( cacheManager ,     \" default \"  ,     \" simpleCache \"  )  ,    defaultExceptionCacheResolver ,    defaultKeyGenerator )  )  ;", "AnnotatedJCacheableService   service    =    new   AnnotatedJCacheableService ( cacheManager . getCache (  \" default \"  )  )  ;", "Method   m    =    ReflectionUtils . findMethod ( AnnotatedJCacheableService . class ,     \" cache \"  ,    String . class )  ;", "try    {", "interceptor . execute ( dummyInvoker ,    service ,    m ,    new   Object [  ]  {     \" myId \"     }  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" JSR -  1  0  7    only   supports   a   single   cache \"  )  )  ;", "}    catch    ( Throwable   ex )     {", "fail (  (  \" Unexpected :     \"     +    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["severalCachesNotSupported"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . keyGenerator . expect (  1 L )  ;", "Object   first    =    this . simpleService . getFiltered (  1 L ,     \" foo \"  ,     \" bar \"  )  ;", "Object   second    =    this . simpleService . getFiltered (  1 L ,     \" foo \"  ,     \" bar \"  )  ;", "assertSame ( first ,    second )  ;", "Object   key    =    new   SimpleKey (  1 L )  ;", "assertEquals ( first ,    cache . get ( key )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFiltered"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "this . keyGenerator . expect (  1 L ,     \" foo \"  ,     \" bar \"  )  ;", "Object   first    =    this . simpleService . get (  1 L ,     \" foo \"  ,     \" bar \"  )  ;", "Object   second    =    this . simpleService . get (  1 L ,     \" foo \"  ,     \" bar \"  )  ;", "assertSame ( first ,    second )  ;", "Object   key    =    new   SimpleKey (  1 L ,     \" foo \"  ,     \" bar \"  )  ;", "assertEquals ( first ,    cache . get ( key )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFlattenVararg"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "this . keyGenerator . expect (  1 L )  ;", "Object   first    =    this . simpleService . get (  1 L )  ;", "Object   second    =    this . simpleService . get (  1 L )  ;", "assertSame ( first ,    second )  ;", "Object   key    =    new   SimpleKey (  1 L )  ;", "assertEquals ( first ,    cache . get ( key )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSimple"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   context    =    new   AnnotationConfigApplicationContext ( JCacheKeyGeneratorTests . Config . class )  ;", "this . keyGenerator    =    context . getBean ( JCacheKeyGeneratorTests . TestKeyGenerator . class )  ;", "this . simpleService    =    context . getBean ( JCacheKeyGeneratorTests . SimpleService . class )  ;", "this . cache    =    context . getBean ( CacheManager . class )  . getCache (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.cache.jcache.interceptor.JCacheKeyGeneratorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractJCacheKeyOperation < Annotation >    keyCacheOperation    =     (  ( AbstractJCacheKeyOperation < Annotation >  )     ( operation )  )  ;", "return   new   DefaultCacheKeyInvocationContext ( keyCacheOperation ,    target ,    params )  ;", "}", "METHOD_END"], "methodName": ["createCacheKeyInvocationContext"], "fileName": "org.springframework.cache.jcache.interceptor.KeyGeneratorAdapter"}, {"methodBody": ["METHOD_START", "{", "List < Object >    parameters    =    new   ArrayList <  >  (  )  ;", "for    ( CacheInvocationParameter   param    :    context . getKeyParameters (  )  )     {", "Object   value    =    param . getValue (  )  ;", "if    (  (  ( param . getParameterPosition (  )  )     =  =     (  ( context . getAllParameters (  )  . length )     -     1  )  )     &  &     ( context . getMethod (  )  . isVarArgs (  )  )  )     {", "parameters . addAll (  (  ( List < Object >  )     ( CollectionUtils . arrayToList ( value )  )  )  )  ;", "} else    {", "parameters . add ( value )  ;", "}", "}", "return   k . generate ( context . getTarget (  )  ,    context . getMethod (  )  ,    parameters . toArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["doGenerate"], "fileName": "org.springframework.cache.jcache.interceptor.KeyGeneratorAdapter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . keyGenerator )     !  =    null    ?    this . keyGenerator    :    this . cacheKeyGenerator ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.springframework.cache.jcache.interceptor.KeyGeneratorAdapter"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["annotatedGet"], "fileName": "org.springframework.cache.jcache.interceptor.SampleObject"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["anotherSimpleGet"], "fileName": "org.springframework.cache.jcache.interceptor.SampleObject"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["fullGetConfig"], "fileName": "org.springframework.cache.jcache.interceptor.SampleObject"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["multiKeysGet"], "fileName": "org.springframework.cache.jcache.interceptor.SampleObject"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["simpleGet"], "fileName": "org.springframework.cache.jcache.interceptor.SampleObject"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionAware ;", "}", "METHOD_END"], "methodName": ["isTransactionAware"], "fileName": "org.springframework.cache.transaction.AbstractTransactionSupportingCacheManager"}, {"methodBody": ["METHOD_START", "{", "this . transactionAware    =    transactionAware ;", "}", "METHOD_END"], "methodName": ["setTransactionAware"], "fileName": "org.springframework.cache.transaction.AbstractTransactionSupportingCacheManager"}, {"methodBody": ["METHOD_START", "{", "assertThat ( getCacheManager ( false )  . getCache ( AbstractTransactionSupportingCacheManagerTests . CACHE _ NAME )  ,    is ( AbstractTransactionSupportingCacheManagerTests . instanceOf ( getCacheType (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getOnExistingCache"], "fileName": "org.springframework.cache.transaction.AbstractTransactionSupportingCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "T   cacheManager    =    getCacheManager ( false )  ;", "String   cacheName    =    name . getMethodName (  )  ;", "addNativeCache ( cacheName )  ;", "assertFalse ( cacheManager . getCacheNames (  )  . contains ( cacheName )  )  ;", "try    {", "assertThat ( cacheManager . getCache ( cacheName )  ,    is (  . instanceOf ( getCacheType (  )  )  )  )  ;", "assertTrue ( cacheManager . getCacheNames (  )  . contains ( cacheName )  )  ;", "}    finally    {", "removeNativeCache ( cacheName )  ;", "}", "}", "METHOD_END"], "methodName": ["getOnNewCache"], "fileName": "org.springframework.cache.transaction.AbstractTransactionSupportingCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "T   cacheManager    =    getCacheManager ( false )  ;", "String   cacheName    =    name . getMethodName (  )  ;", "assertFalse ( cacheManager . getCacheNames (  )  . contains ( cacheName )  )  ;", "assertThat ( cacheManager . getCache ( cacheName )  ,     . nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getOnUnknownCache"], "fileName": "org.springframework.cache.transaction.AbstractTransactionSupportingCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( getCacheManager ( true )  . getCache ( AbstractTransactionSupportingCacheManagerTests . CACHE _ NAME )  ,    is ( AbstractTransactionSupportingCacheManagerTests . instanceOf ( TransactionAwareCacheDecorator . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionalOnExistingCache"], "fileName": "org.springframework.cache.transaction.AbstractTransactionSupportingCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "String   cacheName    =    name . getMethodName (  )  ;", "T   cacheManager    =    getCacheManager ( true )  ;", "assertFalse ( cacheManager . getCacheNames (  )  . contains ( cacheName )  )  ;", "addNativeCache ( cacheName )  ;", "try    {", "assertThat ( cacheManager . getCache ( cacheName )  ,    is (  . instanceOf ( TransactionAwareCacheDecorator . class )  )  )  ;", "assertTrue ( cacheManager . getCacheNames (  )  . contains ( cacheName )  )  ;", "}    finally    {", "removeNativeCache ( cacheName )  ;", "}", "}", "METHOD_END"], "methodName": ["getTransactionalOnNewCache"], "fileName": "org.springframework.cache.transaction.AbstractTransactionSupportingCacheManagerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . targetCache ;", "}", "METHOD_END"], "methodName": ["getTargetCache"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecorator"}, {"methodBody": ["METHOD_START", "{", "Cache   target    =    new   ConcurrentMapCache (  \" testCache \"  )  ;", "Cache   cache    =    new    ( target )  ;", "Object   key    =    new   Object (  )  ;", "cache . put ( key ,     \"  1  2  3  \"  )  ;", "cache . clear (  )  ;", "assertNull ( target . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["clearNonTransactional"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "Cache   target    =    new   ConcurrentMapCache (  \" testCache \"  )  ;", "Cache   cache    =    new    ( target )  ;", "Object   key    =    new   Object (  )  ;", "cache . put ( key ,     \"  1  2  3  \"  )  ;", "TransactionStatus   status    =    this . txManager . getTransaction ( new   DefaultTransactionAttribute ( TransactionDefinition . PROPAGATION _ REQUIRED )  )  ;", "cache . clear (  )  ;", "assertEquals (  \"  1  2  3  \"  ,    target . get ( key ,    String . class )  )  ;", "this . txManager . commit ( status )  ;", "assertNull ( target . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["clearTransactional"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalArgumentException . class )  ;", "new    ( null )  ;", "}", "METHOD_END"], "methodName": ["createWithNullTarget"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "Cache   target    =    new   ConcurrentMapCache (  \" testCache \"  )  ;", "Cache   cache    =    new    ( target )  ;", "Object   key    =    new   Object (  )  ;", "cache . put ( key ,     \"  1  2  3  \"  )  ;", "cache . evict ( key )  ;", "assertNull ( target . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["evictNonTransactional"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "Cache   target    =    new   ConcurrentMapCache (  \" testCache \"  )  ;", "Cache   cache    =    new    ( target )  ;", "Object   key    =    new   Object (  )  ;", "cache . put ( key ,     \"  1  2  3  \"  )  ;", "TransactionStatus   status    =    this . txManager . getTransaction ( new   DefaultTransactionAttribute ( TransactionDefinition . PROPAGATION _ REQUIRED )  )  ;", "cache . evict ( key )  ;", "assertEquals (  \"  1  2  3  \"  ,    target . get ( key ,    String . class )  )  ;", "this . txManager . commit ( status )  ;", "assertNull ( target . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["evictTransactional"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "Cache   target    =    new   ConcurrentMapCache (  \" testCache \"  )  ;", "cache    =    new    ( target )  ;", "assertSame ( target ,    cache . getTargetCache (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTargetCache"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "Cache   target    =    new   ConcurrentMapCache (  \" testCache \"  )  ;", "Cache   cache    =    new    ( target )  ;", "Object   key    =    new   Object (  )  ;", "assertNull ( cache . putIfAbsent ( key ,     \"  1  2  3  \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    target . get ( key ,    String . class )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    cache . putIfAbsent ( key ,     \"  4  5  6  \"  )  . get (  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    target . get ( key ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["putIfAbsent"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "Cache   target    =    new   ConcurrentMapCache (  \" testCache \"  )  ;", "Cache   cache    =    new    ( target )  ;", "Object   key    =    new   Object (  )  ;", "cache . put ( key ,     \"  1  2  3  \"  )  ;", "assertEquals (  \"  1  2  3  \"  ,    target . get ( key ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["putNonTransactional"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "Cache   target    =    new   ConcurrentMapCache (  \" testCache \"  )  ;", "Cache   cache    =    new    ( target )  ;", "TransactionStatus   status    =    this . txManager . getTransaction ( new   DefaultTransactionAttribute ( TransactionDefinition . PROPAGATION _ REQUIRED )  )  ;", "Object   key    =    new   Object (  )  ;", "cache . put ( key ,     \"  1  2  3  \"  )  ;", "assertNull ( target . get ( key )  )  ;", "this . txManager . commit ( status )  ;", "assertEquals (  \"  1  2  3  \"  ,    target . get ( key ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["putTransactional"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "Cache   target    =    new   ConcurrentMapCache (  \" testCache \"  )  ;", "Cache   cache    =    new    ( target )  ;", "assertEquals ( target . getName (  )  ,    cache . getName (  )  )  ;", "assertEquals ( target . getNativeCache (  )  ,    cache . getNativeCache (  )  )  ;", "Object   key    =    new   Object (  )  ;", "target . put ( key ,     \"  1  2  3  \"  )  ;", "assertEquals (  \"  1  2  3  \"  ,    cache . get ( key )  . get (  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    cache . get ( key ,    String . class )  )  ;", "cache . clear (  )  ;", "assertNull ( target . get ( key )  )  ;", "}", "METHOD_END"], "methodName": ["regularOperationsOnTarget"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheDecoratorTests"}, {"methodBody": ["METHOD_START", "{", "this . targetCacheManager    =    targetCacheManager ;", "}", "METHOD_END"], "methodName": ["setTargetCacheManager"], "fileName": "org.springframework.cache.transaction.TransactionAwareCacheManagerProxy"}, {"methodBody": ["METHOD_START", "{", "return   this . failedMessages ;", "}", "METHOD_END"], "methodName": ["getFailedMessages"], "fileName": "org.springframework.mail.MailSendException"}, {"methodBody": ["METHOD_START", "{", "return    ( this . messageExceptions )     !  =    null    ?    this . messageExceptions    :    new   Exception [  0  ]  ;", "}", "METHOD_END"], "methodName": ["getMessageExceptions"], "fileName": "org.springframework.mail.MailSendException"}, {"methodBody": ["METHOD_START", "{", "String [  ]    copy    =    new   String [ state . length ]  ;", "System . arraycopy ( state ,     0  ,    copy ,     0  ,    state . length )  ;", "return   copy ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "if    ( state    =  =    null )     {", "return   null ;", "}", "return    . copy ( state )  ;", "}", "METHOD_END"], "methodName": ["copyOrNull"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( target ,     \"  ' target '    MailMessage   must   not   be   null \"  )  ;", "if    (  ( getFrom (  )  )     !  =    null )     {", "target . setFrom ( getFrom (  )  )  ;", "}", "if    (  ( getReplyTo (  )  )     !  =    null )     {", "target . setReplyTo ( getReplyTo (  )  )  ;", "}", "if    (  ( getTo (  )  )     !  =    null )     {", "target . setTo (  . copy ( getTo (  )  )  )  ;", "}", "if    (  ( getCc (  )  )     !  =    null )     {", "target . setCc (  . copy ( getCc (  )  )  )  ;", "}", "if    (  ( getBcc (  )  )     !  =    null )     {", "target . setBcc (  . copy ( getBcc (  )  )  )  ;", "}", "if    (  ( getSentDate (  )  )     !  =    null )     {", "target . setSentDate ( getSentDate (  )  )  ;", "}", "if    (  ( getSubject (  )  )     !  =    null )     {", "target . setSubject ( getSubject (  )  )  ;", "}", "if    (  ( getText (  )  )     !  =    null )     {", "target . setText ( getText (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . bcc ;", "}", "METHOD_END"], "methodName": ["getBcc"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . cc ;", "}", "METHOD_END"], "methodName": ["getCc"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . from ;", "}", "METHOD_END"], "methodName": ["getFrom"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . replyTo ;", "}", "METHOD_END"], "methodName": ["getReplyTo"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . sentDate ;", "}", "METHOD_END"], "methodName": ["getSentDate"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . subject ;", "}", "METHOD_END"], "methodName": ["getSubject"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . text ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . to ;", "}", "METHOD_END"], "methodName": ["getTo"], "fileName": "org.springframework.mail.SimpleMailMessage"}, {"methodBody": ["METHOD_START", "{", "new   SimpleMailMessage ( null )  ;", "}", "METHOD_END"], "methodName": ["testCopyCtorChokesOnNullOriginalMessage"], "fileName": "org.springframework.mail.SimpleMailMessageTests"}, {"methodBody": ["METHOD_START", "{", "new   SimpleMailMessage (  )  . copyTo ( null )  ;", "}", "METHOD_END"], "methodName": ["testCopyToChokesOnNullTargetMessage"], "fileName": "org.springframework.mail.SimpleMailMessageTests"}, {"methodBody": ["METHOD_START", "{", "SimpleMailMessage   original    =    new   SimpleMailMessage (  )  ;", "original . setTo ( new   String [  ]  {     \" fiona @ mail . org \"  ,     \" apple @ mail . org \"     }  )  ;", "original . setCc ( new   String [  ]  {     \" he @ mail . org \"  ,     \" she @ mail . org \"     }  )  ;", "original . setBcc ( new   String [  ]  {     \" us @ mail . org \"  ,     \" them @ mail . org \"     }  )  ;", "SimpleMailMessage   copy    =    new   SimpleMailMessage ( original )  ;", "original . getTo (  )  [  0  ]     =     \" mmm @ mmm . org \"  ;", "original . getCc (  )  [  0  ]     =     \" mmm @ mmm . org \"  ;", "original . getBcc (  )  [  0  ]     =     \" mmm @ mmm . org \"  ;", "assertEquals (  \" fiona @ mail . org \"  ,    copy . getTo (  )  [  0  ]  )  ;", "assertEquals (  \" he @ mail . org \"  ,    copy . getCc (  )  [  0  ]  )  ;", "assertEquals (  \" us @ mail . org \"  ,    copy . getBcc (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testDeepCopyOfStringArrayTypedFieldsOnCopyCtor"], "fileName": "org.springframework.mail.SimpleMailMessageTests"}, {"methodBody": ["METHOD_START", "{", "SimpleMailMessage   message 1  ;", "SimpleMailMessage   message 2  ;", "message 1     =    new   SimpleMailMessage (  )  ;", "message 2     =    message 1  ;", "assertTrue ( message 1  . equals ( message 2  )  )  ;", "message 1     =    new   SimpleMailMessage (  )  ;", "message 2     =    null ;", "assertTrue (  (  !  ( message 1  . equals ( message 2  )  )  )  )  ;", "assertTrue (  (  !  ( message 1  . equals ( new   Object (  )  )  )  )  )  ;", "message 1     =    new   SimpleMailMessage (  )  ;", "message 2     =    new   SimpleMailMessage (  )  ;", "assertTrue ( message 1  . equals ( message 2  )  )  ;", "message 1     =    new   SimpleMailMessage (  )  ;", "message 1  . setFrom (  \" from @ somewhere \"  )  ;", "message 1  . setReplyTo (  \" replyTo @ somewhere \"  )  ;", "message 1  . setTo (  \" to @ somewhere \"  )  ;", "message 1  . setCc (  \" cc @ somewhere \"  )  ;", "message 1  . setBcc (  \" bcc @ somewhere \"  )  ;", "message 1  . setSentDate ( new   Date (  )  )  ;", "message 1  . setSubject (  \" subject \"  )  ;", "message 1  . setText (  \" text \"  )  ;", "message 2     =    new   SimpleMailMessage ( message 1  )  ;", "assertTrue ( message 1  . equals ( message 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testEqualsObject"], "fileName": "org.springframework.mail.SimpleMailMessageTests"}, {"methodBody": ["METHOD_START", "{", "SimpleMailMessage   message 1     =    new   SimpleMailMessage (  )  ;", "message 1  . setFrom (  \" from @ somewhere \"  )  ;", "message 1  . setReplyTo (  \" replyTo @ somewhere \"  )  ;", "message 1  . setTo (  \" to @ somewhere \"  )  ;", "message 1  . setCc (  \" cc @ somewhere \"  )  ;", "message 1  . setBcc (  \" bcc @ somewhere \"  )  ;", "message 1  . setSentDate ( new   Date (  )  )  ;", "message 1  . setSubject (  \" subject \"  )  ;", "message 1  . setText (  \" text \"  )  ;", "SimpleMailMessage   message 2     =    new   SimpleMailMessage ( message 1  )  ;", "assertEquals ( message 1  ,    message 2  )  ;", "assertEquals ( message 1  . hashCode (  )  ,    message 2  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHashCode"], "fileName": "org.springframework.mail.SimpleMailMessageTests"}, {"methodBody": ["METHOD_START", "{", "SimpleMailMessage   message    =    new   SimpleMailMessage (  )  ;", "message . setFrom (  \" me @ mail . org \"  )  ;", "message . setTo (  \" you @ mail . org \"  )  ;", "SimpleMailMessage   messageCopy    =    new   SimpleMailMessage ( message )  ;", "assertEquals (  \" me @ mail . org \"  ,    messageCopy . getFrom (  )  )  ;", "assertEquals (  \" you @ mail . org \"  ,    messageCopy . getTo (  )  [  0  ]  )  ;", "message . setReplyTo (  \" reply @ mail . org \"  )  ;", "message . setCc ( new   String [  ]  {     \" he @ mail . org \"  ,     \" she @ mail . org \"     }  )  ;", "message . setBcc ( new   String [  ]  {     \" us @ mail . org \"  ,     \" them @ mail . org \"     }  )  ;", "Date   sentDate    =    new   Date (  )  ;", "message . setSentDate ( sentDate )  ;", "message . setSubject (  \" my   subject \"  )  ;", "message . setText (  \" my   text \"  )  ;", "assertEquals (  \" me @ mail . org \"  ,    message . getFrom (  )  )  ;", "assertEquals (  \" reply @ mail . org \"  ,    message . getReplyTo (  )  )  ;", "assertEquals (  \" you @ mail . org \"  ,    message . getTo (  )  [  0  ]  )  ;", "List < String >    ccs    =    Arrays . asList ( message . getCc (  )  )  ;", "assertTrue ( ccs . contains (  \" he @ mail . org \"  )  )  ;", "assertTrue ( ccs . contains (  \" she @ mail . org \"  )  )  ;", "List < String >    bccs    =    Arrays . asList ( message . getBcc (  )  )  ;", "assertTrue ( bccs . contains (  \" us @ mail . org \"  )  )  ;", "assertTrue ( bccs . contains (  \" them @ mail . org \"  )  )  ;", "assertEquals ( sentDate ,    message . getSentDate (  )  )  ;", "assertEquals (  \" my   subject \"  ,    message . getSubject (  )  )  ;", "assertEquals (  \" my   text \"  ,    message . getText (  )  )  ;", "messageCopy    =    new   SimpleMailMessage ( message )  ;", "assertEquals (  \" me @ mail . org \"  ,    messageCopy . getFrom (  )  )  ;", "assertEquals (  \" reply @ mail . org \"  ,    messageCopy . getReplyTo (  )  )  ;", "assertEquals (  \" you @ mail . org \"  ,    messageCopy . getTo (  )  [  0  ]  )  ;", "ccs    =    Arrays . asList ( messageCopy . getCc (  )  )  ;", "assertTrue ( ccs . contains (  \" he @ mail . org \"  )  )  ;", "assertTrue ( ccs . contains (  \" she @ mail . org \"  )  )  ;", "bccs    =    Arrays . asList ( message . getBcc (  )  )  ;", "assertTrue ( bccs . contains (  \" us @ mail . org \"  )  )  ;", "assertTrue ( bccs . contains (  \" them @ mail . org \"  )  )  ;", "assertEquals ( sentDate ,    messageCopy . getSentDate (  )  )  ;", "assertEquals (  \" my   subject \"  ,    messageCopy . getSubject (  )  )  ;", "assertEquals (  \" my   text \"  ,    messageCopy . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleMessageCopyCtor"], "fileName": "org.springframework.mail.SimpleMailMessageTests"}, {"methodBody": ["METHOD_START", "{", "MimetypesFileTypeMap   fileTypeMap    =    null ;", "if    ( mappingLocation    !  =    null )     {", "InputStream   is    =    mappingLocation . getInputStream (  )  ;", "try    {", "fileTypeMap    =    new   MimetypesFileTypeMap ( is )  ;", "}    finally    {", "is . close (  )  ;", "}", "} else    {", "fileTypeMap    =    new   MimetypesFileTypeMap (  )  ;", "}", "if    ( mappings    !  =    null )     {", "for    ( String   mapping    :    mappings )     {", "fileTypeMap . addMimeTypes ( mapping )  ;", "}", "}", "return   fileTypeMap ;", "}", "METHOD_END"], "methodName": ["createFileTypeMap"], "fileName": "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . fileTypeMap )     =  =    null )     {", "try    {", "this . fileTypeMap    =    creat ( this . mappingLocation ,    this . mappings )  ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  (  \" Could   not   load   specified   MIME   type   mapping   file :     \"     +     ( this . mappingLocation )  )  ,    ex )  ;", "}", "}", "return   this . fileTypeMap ;", "}", "METHOD_END"], "methodName": ["getFileTypeMap"], "fileName": "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap"}, {"methodBody": ["METHOD_START", "{", "this . mappingLocation    =    mappingLocation ;", "}", "METHOD_END"], "methodName": ["setMappingLocation"], "fileName": "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap"}, {"methodBody": ["METHOD_START", "{", "this . mappings    =    mappings ;", "}", "METHOD_END"], "methodName": ["setMappings"], "fileName": "org.springframework.mail.javamail.ConfigurableMimeFileTypeMap"}, {"methodBody": ["METHOD_START", "{", "ConfigurableMimeFileTypeMap   ftm    =    new   ConfigurableMimeFileTypeMap (  )  ;", "ftm . afterPropertiesSet (  )  ;", "assertEquals (  \" Invalid   content   type   for   HTM \"  ,     \" text / html \"  ,    ftm . getContentType (  \" foobar . HTM \"  )  )  ;", "assertEquals (  \" Invalid   content   type   for   html \"  ,     \" text / html \"  ,    ftm . getContentType (  \" foobar . html \"  )  )  ;", "assertEquals (  \" Invalid   content   type   for   c +  +  \"  ,     \" text / plain \"  ,    ftm . getContentType (  \" foobar . c +  +  \"  )  )  ;", "assertEquals (  \" Invalid   content   type   for   svf \"  ,     \" image / vnd . svf \"  ,    ftm . getContentType (  \" foobar . svf \"  )  )  ;", "assertEquals (  \" Invalid   content   type   for   dsf \"  ,     \" image / x - mgx - dsf \"  ,    ftm . getContentType (  \" foobar . dsf \"  )  )  ;", "assertEquals (  \" Invalid   default   content   type \"  ,     \" application / octet - stream \"  ,    ftm . getContentType (  \" foobar . foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["againstDefaultConfiguration"], "fileName": "org.springframework.mail.javamail.ConfigurableMimeFileTypeMapTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableMimeFileTypeMap   ftm    =    new   ConfigurableMimeFileTypeMap (  )  ;", "assertEquals (  \" Invalid   content   type   for   HTM \"  ,     \" text / html \"  ,    ftm . getContentType ( new   File (  \"  / tmp / foobar . HTM \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["againstDefaultConfigurationWithFilePath"], "fileName": "org.springframework.mail.javamail.ConfigurableMimeFileTypeMapTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableMimeFileTypeMap   ftm    =    new   ConfigurableMimeFileTypeMap (  )  ;", "ftm . setMappings ( new   String [  ]  {     \" foo / bar   HTM   foo \"  ,     \" foo / cpp   c +  +  \"     }  )  ;", "ftm . afterPropertiesSet (  )  ;", "assertEquals (  \" Invalid   content   type   for   HTM    -    override   didn ' t   work \"  ,     \" foo / bar \"  ,    ftm . getContentType (  \" foobar . HTM \"  )  )  ;", "assertEquals (  \" Invalid   content   type   for   c +  +     -    override   didn ' t   work \"  ,     \" foo / cpp \"  ,    ftm . getContentType (  \" foobar . c +  +  \"  )  )  ;", "assertEquals (  \" Invalid   content   type   for   foo    -    new   mapping   didn ' t   work \"  ,     \" foo / bar \"  ,    ftm . getContentType (  \" bar . foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withAdditionalMappings"], "fileName": "org.springframework.mail.javamail.ConfigurableMimeFileTypeMapTests"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    new   ClassPathResource (  \" test . mime . types \"  ,    getClass (  )  )  ;", "ftm    =    new    (  )  ;", "ftm . setMappingLocation ( resource )  ;", "ftm . afterPropertiesSet (  )  ;", "assertEquals (  \" Invalid   content   type   for   foo \"  ,     \" text / foo \"  ,    ftm . getContentType (  \" foobar . foo \"  )  )  ;", "assertEquals (  \" Invalid   content   type   for   bar \"  ,     \" text / bar \"  ,    ftm . getContentType (  \" foobar . bar \"  )  )  ;", "assertEquals (  \" Invalid   content   type   for   fimg \"  ,     \" image / foo \"  ,    ftm . getContentType (  \" foobar . fimg \"  )  )  ;", "assertEquals (  \" Invalid   content   type   for   bimg \"  ,     \" image / bar \"  ,    ftm . getContentType (  \" foobar . bimg \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withCustomMappingLocation"], "fileName": "org.springframework.mail.javamail.ConfigurableMimeFileTypeMapTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText (  \"     \"  )  ;", "assertEquals (  \" All   whitespace   was   not   recognized \"  ,     . EMPTY ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["allWhitespace"], "fileName": "org.springframework.mail.javamail.InternetAddressEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText (  (  (  \"     \"     +     ( InternetAddressEditorTests . SIMPLE )  )     +     \"     \"  )  )  ;", "assertEquals (  \" Whitespace   was   not   stripped \"  ,    InternetAddressEditorTests . SIMPLE ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["excessWhitespace"], "fileName": "org.springframework.mail.javamail.InternetAddressEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText ( InternetAddressEditorTests . EMPTY )  ;", "assertEquals (  \" Setting   empty   string   did   not   result   in   empty   value   string \"  ,    InternetAddressEditorTests . EMPTY ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setEmpty"], "fileName": "org.springframework.mail.javamail.InternetAddressEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText ( null )  ;", "assertEquals (  \" Setting   null   did   not   result   in   empty   value   string \"  ,     . EMPTY ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setNull"], "fileName": "org.springframework.mail.javamail.InternetAddressEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText ( InternetAddressEditorTests . BAD )  ;", "}", "METHOD_END"], "methodName": ["simpleBadAddress"], "fileName": "org.springframework.mail.javamail.InternetAddressEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText ( InternetAddressEditorTests . SIMPLE )  ;", "assertEquals (  \" Simple   email   address   failed \"  ,    InternetAddressEditorTests . SIMPLE ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleGoodAddess"], "fileName": "org.springframework.mail.javamail.InternetAddressEditorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Uninitialized   editor   did   not   return   empty   value   string \"  ,    InternetAddressEditorTests . EMPTY ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["uninitialized"], "fileName": "org.springframework.mail.javamail.InternetAddressEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   username    =    getUsername (  )  ;", "String   password    =    getPassword (  )  ;", "if    (  \"  \"  . equals ( username )  )     {", "username    =    null ;", "if    (  \"  \"  . equals ( password )  )     {", "password    =    null ;", "}", "}", "Transport   transport    =    getTransport ( getSession (  )  )  ;", "transport . connect ( getHost (  )  ,    getPort (  )  ,    username ,    password )  ;", "return   transport ;", "}", "METHOD_END"], "methodName": ["connectTransport"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "Map < Object ,    Exception >    failedMessages    =    new   LinkedHashMap <  >  (  )  ;", "Transport   transport    =    null ;", "try    {", "for    ( int   i    =     0  ;    i    <     ( mimeMessages . length )  ;    i +  +  )     {", "if    (  ( transport    =  =    null )     |  |     (  !  ( transport . isConnected (  )  )  )  )     {", "if    ( transport    !  =    null )     {", "try    {", "transport . close (  )  ;", "}    catch    ( Exception   ex )     {", "}", "transport    =    null ;", "}", "try    {", "transport    =    connectTransport (  )  ;", "}    catch    ( AuthenticationFailedException   ex )     {", "throw   new   MailAuthenticationException ( ex )  ;", "}    catch    ( Exception   ex )     {", "for    ( int   j    =    i ;    j    <     ( mimeMessages . length )  ;    j +  +  )     {", "Object   original    =     ( originalMessages    !  =    null )     ?    originalMessages [ j ]     :    mimeMessages [ j ]  ;", "failedMessages . put ( original ,    ex )  ;", "}", "throw   new   MailSendException (  \" Mail   server   connection   failed \"  ,    ex ,    failedMessages )  ;", "}", "}", "MimeMessage   mimeMessage    =    mimeMessages [ i ]  ;", "try    {", "if    (  ( mimeMessage . getSentDate (  )  )     =  =    null )     {", "mimeMessage . setSentDate ( new   Date (  )  )  ;", "}", "String   messageId    =    mimeMessage . getMessageID (  )  ;", "mimeMessage . saveChanges (  )  ;", "if    ( messageId    !  =    null )     {", "mimeMessage . setHeader (  . HEADER _ MESSAGE _ ID ,    messageId )  ;", "}", "transport . sendMessage ( mimeMessage ,    mimeMessage . getAllRecipients (  )  )  ;", "}    catch    ( Exception   ex )     {", "Object   original    =     ( originalMessages    !  =    null )     ?    originalMessages [ i ]     :    mimeMessage ;", "failedMessages . put ( original ,    ex )  ;", "}", "}", "}    finally    {", "try    {", "if    ( transport    !  =    null )     {", "transport . close (  )  ;", "}", "}    catch    ( Exception   ex )     {", "if    (  !  ( failedMessages . isEmpty (  )  )  )     {", "throw   new   MailSendException (  \" Failed   to   close   server   connection   after   message   failures \"  ,    ex ,    failedMessages )  ;", "} else    {", "throw   new   MailSendException (  \" Failed   to   close   server   connection   after   message   sending \"  ,    ex )  ;", "}", "}", "}", "if    (  !  ( failedMessages . isEmpty (  )  )  )     {", "throw   new   MailSendException ( failedMessages )  ;", "}", "}", "METHOD_END"], "methodName": ["doSend"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultEncoding ;", "}", "METHOD_END"], "methodName": ["getDefaultEncoding"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultFileTypeMap ;", "}", "METHOD_END"], "methodName": ["getDefaultFileTypeMap"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . javaMailProperties ;", "}", "METHOD_END"], "methodName": ["getJavaMailProperties"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . port ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . protocol ;", "}", "METHOD_END"], "methodName": ["getProtocol"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . session )     =  =    null )     {", "this . session    =    Session . getInstance ( this . jProperties )  ;", "}", "return   this . session ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "String   protocol    =    getProtocol (  )  ;", "if    ( protocol    =  =    null )     {", "protocol    =    session . getProperty (  \" mail . transport . protocol \"  )  ;", "if    ( protocol    =  =    null )     {", "protocol    =     . DEFAULT _ PROTOCOL ;", "}", "}", "return   session . getTransport ( protocol )  ;", "}", "METHOD_END"], "methodName": ["getTransport"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . username ;", "}", "METHOD_END"], "methodName": ["getUsername"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "this . defaultEncoding    =    defaultEncoding ;", "}", "METHOD_END"], "methodName": ["setDefaultEncoding"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "this . defaultFileTypeMap    =    defaultFileTypeMap ;", "}", "METHOD_END"], "methodName": ["setDefaultFileTypeMap"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "this . host    =    host ;", "}", "METHOD_END"], "methodName": ["setHost"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "this . javaMailProperties    =    javaMailProperties ;", "synchronized ( this )     {", "this . session    =    null ;", "}", "}", "METHOD_END"], "methodName": ["setJavaMailProperties"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "this . password    =    password ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "this . port    =    port ;", "}", "METHOD_END"], "methodName": ["setPort"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "this . protocol    =    protocol ;", "}", "METHOD_END"], "methodName": ["setProtocol"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( session ,     \" Session   must   not   be   null \"  )  ;", "this . session    =    session ;", "}", "METHOD_END"], "methodName": ["setSession"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "this . username    =    username ;", "}", "METHOD_END"], "methodName": ["setUsername"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "Transport   transport    =    null ;", "try    {", "transport    =    connectTransport (  )  ;", "}    finally    {", "if    ( transport    !  =    null )     {", "transport . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testConnection"], "fileName": "org.springframework.mail.javamail.JavaMailSenderImpl"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "MimeMessage   mimeMessage 1     =    sender . createMimeMessage (  )  ;", "mimeMessage 1  . setRecipient ( TO ,    new   InternetAddress (  \" he @ mail . org \"  )  )  ;", "mimeMessage 1  . setSubject (  \" fail \"  )  ;", "MimeMessage   mimeMessage 2     =    sender . createMimeMessage (  )  ;", "mimeMessage 2  . setRecipient ( TO ,    new   InternetAddress (  \" she @ mail . org \"  )  )  ;", "try    {", "sender . send ( mimeMessage 1  ,    mimeMessage 2  )  ;", "}    catch    ( MailSendException   ex )     {", "ex . printStackTrace (  )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( mimeMessage 2  ,    sender . transport . getSentMessage (  0  )  )  ;", "assertEquals (  1  ,    ex . getFailedMessages (  )  . size (  )  )  ;", "assertEquals ( mimeMessage 1  ,    ex . getFailedMessages (  )  . keySet (  )  . iterator (  )  . next (  )  )  ;", "Object   subEx    =    ex . getFailedMessages (  )  . values (  )  . iterator (  )  . next (  )  ;", "assertTrue (  ( subEx   instanceof   MessagingException )  )  ;", "assertEquals (  \" failed \"  ,     (  ( MessagingException )     ( subEx )  )  . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fFailedMimeMessage"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \"  \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "SimpleMailMessage   simpleMessage 1     =    new   SimpleMailMessage (  )  ;", "try    {", "sender . send ( simpleMessage 1  )  ;", "fail (  \" Should   have   thrown   MailSendException \"  )  ;", "}    catch    ( MailSendException   ex )     {", "ex . printStackTrace (  )  ;", "assertTrue (  (  ( ex . getFailedMessages (  )  )     !  =    null )  )  ;", "assertEquals (  0  ,    ex . getFailedMessages (  )  . size (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["failedMailServerClose"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost ( null )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "SimpleMailMessage   simpleMessage 1     =    new   SimpleMailMessage (  )  ;", "try    {", "sender . send ( simpleMessage 1  )  ;", "fail (  \" Should   have   thrown   MailSendException \"  )  ;", "}    catch    ( MailSendException   ex )     {", "ex . printStackTrace (  )  ;", "assertTrue (  (  ( ex . getFailedMessages (  )  )     !  =    null )  )  ;", "assertEquals (  1  ,    ex . getFailedMessages (  )  . size (  )  )  ;", "assertSame ( simpleMessage 1  ,    ex . getFailedMessages (  )  . keySet (  )  . iterator (  )  . next (  )  )  ;", "assertSame ( ex . getCause (  )  ,    ex . getFailedMessages (  )  . values (  )  . iterator (  )  . next (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["failedMailServerConnect"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "SimpleMailMessage   simpleMessage 1     =    new   SimpleMailMessage (  )  ;", "simpleMessage 1  . setTo (  \" he @ mail . org \"  )  ;", "simpleMessage 1  . setSubject (  \" fail \"  )  ;", "SimpleMailMessage   simpleMessage 2     =    new   SimpleMailMessage (  )  ;", "simpleMessage 2  . setTo (  \" she @ mail . org \"  )  ;", "try    {", "sender . send ( simpleMessage 1  ,    simpleMessage 2  )  ;", "}    catch    ( MailSendException   ex )     {", "ex . printStackTrace (  )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( new   InternetAddress (  \" she @ mail . org \"  )  ,    sender . transport . getSentMessage (  0  )  . getAllRecipients (  )  [  0  ]  )  ;", "assertEquals (  1  ,    ex . getFailedMessages (  )  . size (  )  )  ;", "assertEquals ( simpleMessage 1  ,    ex . getFailedMessages (  )  . keySet (  )  . iterator (  )  . next (  )  )  ;", "Object   subEx    =    ex . getFailedMessages (  )  . values (  )  . iterator (  )  . next (  )  ;", "assertTrue (  ( subEx   instanceof   MessagingException )  )  ;", "assertEquals (  \" failed \"  ,     (  ( MessagingException )     ( subEx )  )  . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["failedSimpleMessage"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" bogusKey \"  ,     \" bogusValue \"  )  ;", ". MockJavaMailSender   sender    =    new    . MockJavaMailSender (  )     {", "@ Override", "protected   Transport   getTransport ( Session   sess )    throws   NoSuchProviderException    {", "assertEquals (  \" bogusValue \"  ,    sess . getProperty (  \" bogusKey \"  )  )  ;", "return   super . getTransport ( sess )  ;", "}", "}  ;", "sender . setJavaMailProperties ( props )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "MimeMessage   mimeMessage    =    sender . createMimeMessage (  )  ;", "mimeMessage . setRecipient ( TO ,    new   InternetAddress (  \" you @ mail . org \"  )  )  ;", "sender . send ( mimeMessage )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( mimeMessage ,    sender . transport . getSentMessage (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["javaMailProperties"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "final   Session   session    =    Session . getInstance ( new   Properties (  )  )  ;", ". MockJavaMailSender   sender    =    new    . MockJavaMailSender (  )     {", "@ Override", "protected   Transport   getTransport ( Session   sess )    throws   NoSuchProviderException    {", "assertEquals ( session ,    sess )  ;", "return   super . getTransport ( sess )  ;", "}", "}  ;", "sender . setSession ( session )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "MimeMessage   mimeMessage    =    sender . createMimeMessage (  )  ;", "mimeMessage . setSubject (  \" custom \"  )  ;", "mimeMessage . setRecipient ( TO ,    new   InternetAddress (  \" you @ mail . org \"  )  )  ;", "mimeMessage . setSentDate ( new   GregorianCalendar (  2  0  0  5  ,     3  ,     1  )  . getTime (  )  )  ;", "sender . send ( mimeMessage )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( mimeMessage ,    sender . transport . getSentMessage (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["javaMailSenderWithCustomSession"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "MimeMessageHelper   message    =    new   MimeMessageHelper ( sender . createMimeMessage (  )  )  ;", "assertNull ( message . getEncoding (  )  )  ;", "assertTrue (  (  ( message . getFileTypeMap (  )  )    instanceof   ConfigurableMimeFileTypeMap )  )  ;", "message . setTo (  \" you @ mail . org \"  )  ;", "sender . send ( message . getMimeMessage (  )  )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( message . getMimeMessage (  )  ,    sender . transport . getSentMessage (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["javaMailSenderWithMimeMessageHelper"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "sender . setDefaultEncoding (  \" UTF -  8  \"  )  ;", "FileTypeMap   fileTypeMap    =    new   ConfigurableMimeFileTypeMap (  )  ;", "sender . setDefaultFileTypeMap ( fileTypeMap )  ;", "MimeMessageHelper   message    =    new   MimeMessageHelper ( sender . createMimeMessage (  )  )  ;", "assertEquals (  \" UTF -  8  \"  ,    message . getEncoding (  )  )  ;", "assertEquals ( fileTypeMap ,    message . getFileTypeMap (  )  )  ;", "message . setTo (  \" you @ mail . org \"  )  ;", "sender . send ( message . getMimeMessage (  )  )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( message . getMimeMessage (  )  ,    sender . transport . getSentMessage (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["javaMailSenderWithMimeMessageHelperAndDefaultEncoding"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "MimeMessageHelper   message    =    new   MimeMessageHelper ( sender . createMimeMessage (  )  ,     \" UTF -  8  \"  )  ;", "assertEquals (  \" UTF -  8  \"  ,    message . getEncoding (  )  )  ;", "FileTypeMap   fileTypeMap    =    new   ConfigurableMimeFileTypeMap (  )  ;", "message . setFileTypeMap ( fileTypeMap )  ;", "assertEquals ( fileTypeMap ,    message . getFileTypeMap (  )  )  ;", "message . setTo (  \" you @ mail . org \"  )  ;", "sender . send ( message . getMimeMessage (  )  )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( message . getMimeMessage (  )  ,    sender . transport . getSentMessage (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["javaMailSenderWithMimeMessageHelperAndSpecificEncoding"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "final   List < Message >    messages    =    new   ArrayList <  >  (  )  ;", "MimeMessagePreparator   preparator    =    new   MimeMessagePreparator (  )     {", "@ Override", "public   void   prepare ( MimeMessage   mimeMessage )    throws   MessagingException    {", "mimeMessage . setRecipient ( TO ,    new   InternetAddress (  \" you @ mail . org \"  )  )  ;", "messages . add ( mimeMessage )  ;", "}", "}  ;", "sender . send ( preparator )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( messages . get (  0  )  ,    sender . transport . getSentMessage (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["javaMailSenderWithMimeMessagePreparator"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "final   List < Message >    messages    =    new   ArrayList <  >  (  )  ;", "MimeMessagePreparator   preparator 1     =    new   MimeMessagePreparator (  )     {", "@ Override", "public   void   prepare ( MimeMessage   mimeMessage )    throws   MessagingException    {", "mimeMessage . setRecipient ( TO ,    new   InternetAddress (  \" he @ mail . org \"  )  )  ;", "messages . add ( mimeMessage )  ;", "}", "}  ;", "MimeMessagePreparator   preparator 2     =    new   MimeMessagePreparator (  )     {", "@ Override", "public   void   prepare ( MimeMessage   mimeMessage )    throws   MessagingException    {", "mimeMessage . setRecipient ( TO ,    new   InternetAddress (  \" she @ mail . org \"  )  )  ;", "messages . add ( mimeMessage )  ;", "}", "}  ;", "sender . send ( preparator 1  ,    preparator 2  )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  2  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( messages . get (  0  )  ,    sender . transport . getSentMessage (  0  )  )  ;", "assertEquals ( messages . get (  1  )  ,    sender . transport . getSentMessage (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["javaMailSenderWithMimeMessagePreparators"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "MimeMessage   mimeMessage 1     =    sender . createMimeMessage (  )  ;", "mimeMessage 1  . setRecipient ( TO ,    new   InternetAddress (  \" he @ mail . org \"  )  )  ;", "MimeMessage   mimeMessage 2     =    sender . createMimeMessage (  )  ;", "mimeMessage 2  . setRecipient ( TO ,    new   InternetAddress (  \" she @ mail . org \"  )  )  ;", "sender . send ( mimeMessage 1  ,    mimeMessage 2  )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  2  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( mimeMessage 1  ,    sender . transport . getSentMessage (  0  )  )  ;", "assertEquals ( mimeMessage 2  ,    sender . transport . getSentMessage (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["javaMailSenderWithMimeMessages"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "MimeMessagePreparator   preparator    =    new   MimeMessagePreparator (  )     {", "@ Override", "public   void   prepare ( MimeMessage   mimeMessage )    throws   MessagingException    {", "mimeMessage . setFrom ( new   InternetAddress (  \"  \"  )  )  ;", "}", "}  ;", "try    {", "sender . send ( preparator )  ;", "}    catch    ( MailParseException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   AddressException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["javaMailSenderWithParseExceptionOnMimeMessagePreparator"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "SimpleMailMessage   simpleMessage    =    new   SimpleMailMessage (  )  ;", "simpleMessage . setFrom (  \"  \"  )  ;", "try    {", "sender . send ( simpleMessage )  ;", "}    catch    ( MailParseException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   AddressException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["javaMailSenderWithParseExceptionOnSimpleMessage"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setPort (  3  0  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "SimpleMailMessage   simpleMessage    =    new   SimpleMailMessage (  )  ;", "simpleMessage . setFrom (  \" me @ mail . org \"  )  ;", "simpleMessage . setReplyTo (  \" reply @ mail . org \"  )  ;", "simpleMessage . setTo (  \" you @ mail . org \"  )  ;", "simpleMessage . setCc ( new   String [  ]  {     \" he @ mail . org \"  ,     \" she @ mail . org \"     }  )  ;", "simpleMessage . setBcc ( new   String [  ]  {     \" us @ mail . org \"  ,     \" them @ mail . org \"     }  )  ;", "Date   sentDate    =    new   GregorianCalendar (  2  0  0  4  ,     1  ,     1  )  . getTime (  )  ;", "simpleMessage . setSentDate ( sentDate )  ;", "simpleMessage . setSubject (  \" my   subject \"  )  ;", "simpleMessage . setText (  \" my   text \"  )  ;", "sender . send ( simpleMessage )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  3  0  ,    sender . transport . getConnectedPort (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "MimeMessage   sentMessage    =    sender . transport . getSentMessage (  0  )  ;", "List < Address >    froms    =    Arrays . asList ( sentMessage . getFrom (  )  )  ;", "assertEquals (  1  ,    froms . size (  )  )  ;", "assertEquals (  \" me @ mail . org \"  ,     (  ( InternetAddress )     ( froms . get (  0  )  )  )  . getAddress (  )  )  ;", "List < Address >    replyTos    =    Arrays . asList ( sentMessage . getReplyTo (  )  )  ;", "assertEquals (  \" reply @ mail . org \"  ,     (  ( InternetAddress )     ( replyTos . get (  0  )  )  )  . getAddress (  )  )  ;", "List < Address >    tos    =    Arrays . asList ( sentMessage . getRecipients ( TO )  )  ;", "assertEquals (  1  ,    tos . size (  )  )  ;", "assertEquals (  \" you @ mail . org \"  ,     (  ( InternetAddress )     ( tos . get (  0  )  )  )  . getAddress (  )  )  ;", "List < Address >    ccs    =    Arrays . asList ( sentMessage . getRecipients ( CC )  )  ;", "assertEquals (  2  ,    ccs . size (  )  )  ;", "assertEquals (  \" he @ mail . org \"  ,     (  ( InternetAddress )     ( ccs . get (  0  )  )  )  . getAddress (  )  )  ;", "assertEquals (  \" she @ mail . org \"  ,     (  ( InternetAddress )     ( ccs . get (  1  )  )  )  . getAddress (  )  )  ;", "List < Address >    bccs    =    Arrays . asList ( sentMessage . getRecipients ( BCC )  )  ;", "assertEquals (  2  ,    bccs . size (  )  )  ;", "assertEquals (  \" us @ mail . org \"  ,     (  ( InternetAddress )     ( bccs . get (  0  )  )  )  . getAddress (  )  )  ;", "assertEquals (  \" them @ mail . org \"  ,     (  ( InternetAddress )     ( bccs . get (  1  )  )  )  . getAddress (  )  )  ;", "assertEquals ( sentDate . getTime (  )  ,    sentMessage . getSentDate (  )  . getTime (  )  )  ;", "assertEquals (  \" my   subject \"  ,    sentMessage . getSubject (  )  )  ;", "assertEquals (  \" my   text \"  ,    sentMessage . getContent (  )  )  ;", "}", "METHOD_END"], "methodName": ["javaMailSenderWithSimpleMessage"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . testConnection (  )  ;", "}", "METHOD_END"], "methodName": ["testConnection"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost ( null )  ;", "thrown . expect ( MessagingException . class )  ;", "sender . testConnection (  )  ;", "}", "METHOD_END"], "methodName": ["testConnectionWithFailure"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "MimeMessage   mimeMessage    =    sender . createMimeMessage (  )  ;", "mimeMessage . setRecipient ( TO ,    new   InternetAddress (  \" you @ mail . org \"  )  )  ;", "sender . send ( mimeMessage )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  1  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( mimeMessage ,    sender . transport . getSentMessage (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testJavaMailSenderWithMimeMessage"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "JavaMailSenderTests . MockJavaMailSender   sender    =    new   JavaMailSenderTests . MockJavaMailSender (  )  ;", "sender . setHost (  \" host \"  )  ;", "sender . setUsername (  \" username \"  )  ;", "sender . setPassword (  \" password \"  )  ;", "SimpleMailMessage   simpleMessage 1     =    new   SimpleMailMessage (  )  ;", "simpleMessage 1  . setTo (  \" he @ mail . org \"  )  ;", "SimpleMailMessage   simpleMessage 2     =    new   SimpleMailMessage (  )  ;", "simpleMessage 2  . setTo (  \" she @ mail . org \"  )  ;", "sender . send ( simpleMessage 1  ,    simpleMessage 2  )  ;", "assertEquals (  \" host \"  ,    sender . transport . getConnectedHost (  )  )  ;", "assertEquals (  \" username \"  ,    sender . transport . getConnectedUsername (  )  )  ;", "assertEquals (  \" password \"  ,    sender . transport . getConnectedPassword (  )  )  ;", "assertTrue ( sender . transport . isCloseCalled (  )  )  ;", "assertEquals (  2  ,    sender . transport . getSentMessages (  )  . size (  )  )  ;", "MimeMessage   sentMessage 1     =    sender . transport . getSentMessage (  0  )  ;", "List < Address >    tos 1     =    Arrays . asList ( sentMessage 1  . getRecipients ( TO )  )  ;", "assertEquals (  1  ,    tos 1  . size (  )  )  ;", "assertEquals (  \" he @ mail . org \"  ,     (  ( InternetAddress )     ( tos 1  . get (  0  )  )  )  . getAddress (  )  )  ;", "MimeMessage   sentMessage 2     =    sender . transport . getSentMessage (  1  )  ;", "List < Address >    tos 2     =    Arrays . asList ( sentMessage 2  . getRecipients ( TO )  )  ;", "assertEquals (  1  ,    tos 2  . size (  )  )  ;", "assertEquals (  \" she @ mail . org \"  ,     (  ( InternetAddress )     ( tos 2  . get (  0  )  )  )  . getAddress (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJavaMailSenderWithSimpleMessages"], "fileName": "org.springframework.mail.javamail.JavaMailSenderTests"}, {"methodBody": ["METHOD_START", "{", "return   this . helper . getMimeMessage (  )  ;", "}", "METHOD_END"], "methodName": ["getMimeMessage"], "fileName": "org.springframework.mail.javamail.MimeMailMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . helper ;", "}", "METHOD_END"], "methodName": ["getMimeMessageHelper"], "fileName": "org.springframework.mail.javamail.MimeMailMessage"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( file ,     \" File   must   not   be   null \"  )  ;", "FileDataSource   dataSource    =    new   FileDataSource ( file )  ;", "dataSource . setFileTypeMap ( getFileTypeMap (  )  )  ;", "addAttachment ( attachmentFilen ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["addAttachment"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( attachmentFilename ,     \" Attachment   filename   must   not   be   null \"  )  ;", "Assert . notNull ( dataSource ,     \" DataSource   must   not   be   null \"  )  ;", "try    {", "MimeBodyPart   mimeBodyPart    =    new   MimeBodyPart (  )  ;", "mimeBodyPart . setDisposition ( ATTACHMENT )  ;", "mimeBodyPart . setFileName ( MimeUtility . encodeText ( attachmentFilename )  )  ;", "mimeBodyPart . setDataHandler ( new   DataHandler ( dataSource )  )  ;", "getRootMimeMultipart (  )  . addBodyPart ( mimeBodyPart )  ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   ingException (  \" Failed   to   encode   attachment   filename \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["addAttachment"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "String   contentType    =    getFileTypeMap (  )  . getContentType ( attachmentFilename )  ;", "addAttachment ( attachmentFilename ,    inputStreamSource ,    contentType )  ;", "}", "METHOD_END"], "methodName": ["addAttachment"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( inputStreamSource ,     \" InputStreamSource   must   not   be   null \"  )  ;", "if    (  ( inputStreamSource   instanceof   Resource )     &  &     (  (  ( Resource )     ( inputStreamSource )  )  . isOpen (  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Passed - in   Resource   contains   an   open   stream :    invalid   argument .     \"     +     \" JavaM   requires   an   InputStreamSource   that   creates   a   fresh   stream   for   every   call .  \"  )  )  ;", "}", "DataSource   dataSource    =    createDataSource ( inputStreamSource ,    contentType ,    attachmentFilename )  ;", "addAttachment ( attachmentFilename ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["addAttachment"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( bcc ,     \" Bcc   address   must   not   be   null \"  )  ;", "addBcc ( parseAddress ( bcc )  )  ;", "}", "METHOD_END"], "methodName": ["addBcc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( bcc ,     \" Bcc   address   must   not   be   null \"  )  ;", "addBcc (  (  ( getEncoding (  )  )     !  =    null    ?    new   InternetAddress ( bcc ,    personal ,    getEncoding (  )  )     :    new   InternetAddress ( bcc ,    personal )  )  )  ;", "}", "METHOD_END"], "methodName": ["addBcc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( bcc ,     \" Bcc   address   must   not   be   null \"  )  ;", "validateAddress ( bcc )  ;", "this . m . addRecipient ( BCC ,    bcc )  ;", "}", "METHOD_END"], "methodName": ["addBcc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cc ,     \" Cc   address   must   not   be   null \"  )  ;", "addCc ( parseAddress ( cc )  )  ;", "}", "METHOD_END"], "methodName": ["addCc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cc ,     \" Cc   address   must   not   be   null \"  )  ;", "addCc (  (  ( getEncoding (  )  )     !  =    null    ?    new   InternetAddress ( cc ,    personal ,    getEncoding (  )  )     :    new   InternetAddress ( cc ,    personal )  )  )  ;", "}", "METHOD_END"], "methodName": ["addCc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cc ,     \" Cc   address   must   not   be   null \"  )  ;", "validateAddress ( cc )  ;", "this . m . addRecipient ( CC ,    cc )  ;", "}", "METHOD_END"], "methodName": ["addCc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( file ,     \" File   must   not   be   null \"  )  ;", "FileDataSource   dataSource    =    new   FileDataSource ( file )  ;", "dataSource . setFileTypeMap ( getFileTypeMap (  )  )  ;", "addInline ( contentId ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["addInline"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( contentId ,     \" Content   ID   must   not   be   null \"  )  ;", "Assert . notNull ( dataSource ,     \" DataSource   must   not   be   null \"  )  ;", "MimeBodyPart   mimeBodyPart    =    new   MimeBodyPart (  )  ;", "mimeBodyPart . setDisposition ( INLINE )  ;", "mimeBodyPart . setHeader (  . HEADER _ CONTENT _ ID ,     (  (  \"  <  \"     +    contentId )     +     \"  >  \"  )  )  ;", "mimeBodyPart . setDataHandler ( new   DataHandler ( dataSource )  )  ;", "getMimeMultipart (  )  . addBodyPart ( mimeBodyPart )  ;", "}", "METHOD_END"], "methodName": ["addInline"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( inputStreamSource ,     \" InputStreamSource   must   not   be   null \"  )  ;", "if    (  ( inputStreamSource   instanceof   Resource )     &  &     (  (  ( Resource )     ( inputStreamSource )  )  . isOpen (  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Passed - in   Resource   contains   an   open   stream :    invalid   argument .     \"     +     \" JavaM   requires   an   InputStreamSource   that   creates   a   fresh   stream   for   every   call .  \"  )  )  ;", "}", "DataSource   dataSource    =    createDataSource ( inputStreamSource ,    contentType ,     \" inline \"  )  ;", "addInline ( contentId ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["addInline"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resource ,     \" Resource   must   not   be   null \"  )  ;", "St   contentType    =    getFileTypeMap (  )  . getContentType ( resource . getFilename (  )  )  ;", "addInline ( contentId ,    resource ,    contentType )  ;", "}", "METHOD_END"], "methodName": ["addInline"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( to ,     \" To   address   must   not   be   null \"  )  ;", "addTo ( parseAddress ( to )  )  ;", "}", "METHOD_END"], "methodName": ["addTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( to ,     \" To   address   must   not   be   null \"  )  ;", "addTo (  (  ( getEncoding (  )  )     !  =    null    ?    new   InternetAddress ( to ,    personal ,    getEncoding (  )  )     :    new   InternetAddress ( to ,    personal )  )  )  ;", "}", "METHOD_END"], "methodName": ["addTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( to ,     \" To   address   must   not   be   null \"  )  ;", "validateAddress ( to )  ;", "this . m . addRecipient ( TO ,    to )  ;", "}", "METHOD_END"], "methodName": ["addTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "return   new   DataSource (  )     {", "@ Override", "public   InputStream   getInputStream (  )    throws   IOException    {", "return   inputStreamSource . getInputStream (  )  ;", "}", "@ Override", "public   OutputStream   getOutputStream (  )     {", "throw   new   UnsupportedOperationException (  \" Read - only   x . activation . DataSource \"  )  ;", "}", "@ Override", "public   String   getContentType (  )     {", "return   contentType ;", "}", "@ Override", "public   String   getName (  )     {", "return   name ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createDataSource"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "switch    ( multipartMode )     {", "case    . MULTIPART _ MODE _ NO    :", "setMimeMultiparts ( null ,    null )  ;", "break ;", "case    . MULTIPART _ MODE _ MIXED    :", "MimeMultipart   mixedMultipart    =    new   MimeMultipart (  . MULTIPART _ SUBTYPE _ MIXED )  ;", "mimeMessage . setContent ( mixedMultipart )  ;", "setMimeMultiparts ( mixedMultipart ,    mixedMultipart )  ;", "break ;", "case    . MULTIPART _ MODE _ RELATED    :", "MimeMultipart   relatedMultipart    =    new   MimeMultipart (  . MULTIPART _ SUBTYPE _ RELATED )  ;", "mimeMessage . setContent ( relatedMultipart )  ;", "setMimeMultiparts ( relatedMultipart ,    relatedMultipart )  ;", "break ;", "case    . MULTIPART _ MODE _ MIXED _ RELATED    :", "MimeMultipart   rootMixedMultipart    =    new   MimeMultipart (  . MULTIPART _ SUBTYPE _ MIXED )  ;", "mimeMessage . setContent ( rootMixedMultipart )  ;", "MimeMultipart   nestedRelatedMultipart    =    new   MimeMultipart (  . MULTIPART _ SUBTYPE _ RELATED )  ;", "MimeBodyPart   relatedBodyPart    =    new   MimeBodyPart (  )  ;", "relatedBodyPart . setContent ( nestedRelatedMultipart )  ;", "rootMixedMultipart . addBodyPart ( relatedBodyPart )  ;", "setMimeMultiparts ( rootMixedMultipart ,    nestedRelatedMultipart )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  \" Only   multipart   modes   MIXED _ RELATED ,    RELATED   and   NO   supported \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["createMimeMultiparts"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( mimeMessage   instanceof   SmartMimeMessage )     {", "return    (  ( SmartMimeMessage )     ( mimeMessage )  )  . getDefaultEncoding (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultEncoding"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( mimeMessage   instanceof   SmartMimeMessage )     {", "FileTypeMap   fileTypeMap    =     (  ( SmartMimeMessage )     ( mimeMessage )  )  . getDefaultFileTypeMap (  )  ;", "if    ( fileTypeMap    !  =    null )     {", "return   fileTypeMap ;", "}", "}", "ConfigurableMimeFileTypeMap   fileTypeMap    =    new   ConfigurableMimeFileTypeMap (  )  ;", "fileTypeMap . afterPropertiesSet (  )  ;", "return   fileTypeMap ;", "}", "METHOD_END"], "methodName": ["getDefaultFileTypeMap"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . encoding ;", "}", "METHOD_END"], "methodName": ["getEncoding"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . fileTypeMap ;", "}", "METHOD_END"], "methodName": ["getFileTypeMap"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "MimeMultipart   mimeMultipart    =    getMimeMultipart (  )  ;", "MimeBodyPart   bodyPart    =    null ;", "for    ( int   i    =     0  ;    i    <     ( mimeMultipart . getCount (  )  )  ;    i +  +  )     {", "BodyPart   bp    =    mimeMultipart . getBodyPart ( i )  ;", "if    (  ( bp . getFileName (  )  )     =  =    null )     {", "bodyPart    =     (  ( MimeBodyPart )     ( bp )  )  ;", "}", "}", "if    ( bodyPart    =  =    null )     {", "MimeBodyPart   mimeBodyPart    =    new   MimeBodyPart (  )  ;", "mimeMultipart . addBodyPart ( mimeBodyPart )  ;", "bodyPart    =    mimeBodyPart ;", "}", "return   bodyPart ;", "}", "METHOD_END"], "methodName": ["getMainPart"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . mimeMessage ;", "}", "METHOD_END"], "methodName": ["getMimeMessage"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . mimeMultipart )     =  =    null )     {", "throw   new   IllegalStateException (  (  \" Not   in   multipart   mode    -     \"     +     (  \" create   an   appropriate      via   a   constructor   that   takes   a    ' multipart '    flag    \"     +     \" if   you   need   to   set   alternative   texts   or   add   inline   elements   or   attachments .  \"  )  )  )  ;", "}", "return   this . mimeMultipart ;", "}", "METHOD_END"], "methodName": ["getMimeMultipart"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . rootMimeMultipart )     =  =    null )     {", "throw   new   IllegalStateException (  (  \" Not   in   multipart   mode    -     \"     +     (  \" create   an   appropriate      via   a   constructor   that   takes   a    ' multipart '    flag    \"     +     \" if   you   need   to   set   alternative   texts   or   add   inline   elements   or   attachments .  \"  )  )  )  ;", "}", "return   this . rootMimeMultipart ;", "}", "METHOD_END"], "methodName": ["getRootMimeMultipart"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "return    ( this . rootMimeMultipart )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isMultipart"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . validateAddresses ;", "}", "METHOD_END"], "methodName": ["isValidateAddresses"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "InternetAddress [  ]    parsed    =    InternetAddress . parse ( address )  ;", "if    (  ( parsed . length )     !  =     1  )     {", "throw   new   AddressException (  \" Illegal   address \"  ,    address )  ;", "}", "InternetAddress   raw    =    parsed [  0  ]  ;", "try    {", "return    ( getEncoding (  )  )     !  =    null    ?    new   InternetAddress ( raw . getAddress (  )  ,    raw . getPersonal (  )  ,    getEncoding (  )  )     :    raw ;", "}    catch    ( UnsupportedEncodingException   ex )     {", "throw   new   ingException (  \" Failed   to   parse   embedded   personal   name   to   correct   encoding \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAddress"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( bcc ,     \" Bcc   address   must   not   be   null \"  )  ;", "setBcc ( parseAddress ( bcc )  )  ;", "}", "METHOD_END"], "methodName": ["setBcc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( bcc ,     \" Bcc   address   array   must   not   be   null \"  )  ;", "InternetAddress [  ]    addresses    =    new   InternetAddress [ bcc . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( bcc . length )  ;    i +  +  )     {", "addresses [ i ]     =    parseAddress ( bcc [ i ]  )  ;", "}", "setBcc ( addresses )  ;", "}", "METHOD_END"], "methodName": ["setBcc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( bcc ,     \" Bcc   address   must   not   be   null \"  )  ;", "validateAddress ( bcc )  ;", "this . m . setRecipient ( BCC ,    bcc )  ;", "}", "METHOD_END"], "methodName": ["setBcc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( bcc ,     \" Bcc   address   array   must   not   be   null \"  )  ;", "validateAddresses ( bcc )  ;", "this . m . setRecipients ( BCC ,    bcc )  ;", "}", "METHOD_END"], "methodName": ["setBcc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cc ,     \" Cc   address   must   not   be   null \"  )  ;", "setCc ( parseAddress ( cc )  )  ;", "}", "METHOD_END"], "methodName": ["setCc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cc ,     \" Cc   address   array   must   not   be   null \"  )  ;", "InternetAddress [  ]    addresses    =    new   InternetAddress [ cc . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( cc . length )  ;    i +  +  )     {", "addresses [ i ]     =    parseAddress ( cc [ i ]  )  ;", "}", "setCc ( addresses )  ;", "}", "METHOD_END"], "methodName": ["setCc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cc ,     \" Cc   address   must   not   be   null \"  )  ;", "validateAddress ( cc )  ;", "this . m . setRecipient ( CC ,    cc )  ;", "}", "METHOD_END"], "methodName": ["setCc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( cc ,     \" Cc   address   array   must   not   be   null \"  )  ;", "validateAddresses ( cc )  ;", "this . m . setRecipients ( CC ,    cc )  ;", "}", "METHOD_END"], "methodName": ["setCc"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "this . fileTypeMap    =     ( fileTypeMap    !  =    null )     ?    fileTypeMap    :    getDefaultFileTypeMap ( getMimeMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["setFileTypeMap"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( from ,     \" From   address   must   not   be   null \"  )  ;", "setFrom ( parseAddress ( from )  )  ;", "}", "METHOD_END"], "methodName": ["setFrom"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( from ,     \" From   address   must   not   be   null \"  )  ;", "setFrom (  (  ( getEncoding (  )  )     !  =    null    ?    new   InternetAddress ( from ,    personal ,    getEncoding (  )  )     :    new   InternetAddress ( from ,    personal )  )  )  ;", "}", "METHOD_END"], "methodName": ["setFrom"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( from ,     \" From   address   must   not   be   null \"  )  ;", "validateAddress ( from )  ;", "this . m . setFrom ( from )  ;", "}", "METHOD_END"], "methodName": ["setFrom"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getEncoding (  )  )     !  =    null )     {", "mimePart . setContent ( text ,     (  (  (  . CONTENT _ TYPE _ HTML )     +     (  . CONTENT _ TYPE _ CHARSET _ SUFFIX )  )     +     ( getEncoding (  )  )  )  )  ;", "} else    {", "mimePart . setContent ( text ,     . CONTENT _ TYPE _ HTML )  ;", "}", "}", "METHOD_END"], "methodName": ["setHtmlTextToMimePart"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "this . rootMimeMultipart    =    root ;", "this . mimeMultipart    =    main ;", "}", "METHOD_END"], "methodName": ["setMimeMultiparts"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getEncoding (  )  )     !  =    null )     {", "mimePart . setText ( text ,    getEncoding (  )  )  ;", "} else    {", "mimePart . setText ( text )  ;", "}", "}", "METHOD_END"], "methodName": ["setPlainTextToMimePart"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "this . mimeMessage . setHeader ( MimeMessageHelper . HEADER _ PRIORITY ,    Integer . toString ( priority )  )  ;", "}", "METHOD_END"], "methodName": ["setPriority"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( replyTo ,     \" Reply - to   address   must   not   be   null \"  )  ;", "setReplyTo ( parseAddress ( replyTo )  )  ;", "}", "METHOD_END"], "methodName": ["setReplyTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( replyTo ,     \" Reply - to   address   must   not   be   null \"  )  ;", "InternetAddress   replyToAddress    =     (  ( getEncoding (  )  )     !  =    null )     ?    new   InternetAddress ( replyTo ,    personal ,    getEncoding (  )  )     :    new   InternetAddress ( replyTo ,    personal )  ;", "setReplyTo ( replyToAddress )  ;", "}", "METHOD_END"], "methodName": ["setReplyTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( replyTo ,     \" Reply - to   address   must   not   be   null \"  )  ;", "validateAddress ( replyTo )  ;", "this . m . setReplyTo ( new   InternetAddress [  ]  {    replyTo    }  )  ;", "}", "METHOD_END"], "methodName": ["setReplyTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( sentDate ,     \" Sent   date   must   not   be   null \"  )  ;", "this . m . setSentDate ( sentDate )  ;", "}", "METHOD_END"], "methodName": ["setSentDate"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( subject ,     \" Subject   must   not   be   null \"  )  ;", "if    (  ( getEncoding (  )  )     !  =    null )     {", "this . m . setSubject ( subject ,    getEncoding (  )  )  ;", "} else    {", "this . m . setSubject ( subject )  ;", "}", "}", "METHOD_END"], "methodName": ["setSubject"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "setText ( text ,    false )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( text ,     \" Text   must   not   be   null \"  )  ;", "MimePart   partToUse ;", "if    ( isMultipart (  )  )     {", "partToUse    =    getMainPart (  )  ;", "} else    {", "partToUse    =    this . m ;", "}", "if    ( html )     {", "setHtmlTextToMimePart ( partToUse ,    text )  ;", "} else    {", "setPlainTextToMimePart ( partToUse ,    text )  ;", "}", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( plainText ,     \" Plain   text   must   not   be   null \"  )  ;", "Assert . notNull ( htmlText ,     \" HTML   text   must   not   be   null \"  )  ;", "MimeMultipart   messageBody    =    new   MimeMultipart (  . MULTIPART _ SUBTYPE _ ALTERNATIVE )  ;", "getMainPart (  )  . setContent ( messageBody ,     . CONTENT _ TYPE _ ALTERNATIVE )  ;", "MimeBodyPart   plainTextPart    =    new   MimeBodyPart (  )  ;", "setPlainTextToMimePart ( plainTextPart ,    plainText )  ;", "messageBody . addBodyPart ( plainTextPart )  ;", "MimeBodyPart   htmlTextPart    =    new   MimeBodyPart (  )  ;", "setHtmlTextToMimePart ( htmlTextPart ,    htmlText )  ;", "messageBody . addBodyPart ( htmlTextPart )  ;", "}", "METHOD_END"], "methodName": ["setText"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( to ,     \" To   address   must   not   be   null \"  )  ;", "setTo ( parseAddress ( to )  )  ;", "}", "METHOD_END"], "methodName": ["setTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( to ,     \" To   address   array   must   not   be   null \"  )  ;", "InternetAddress [  ]    addresses    =    new   InternetAddress [ to . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( to . length )  ;    i +  +  )     {", "addresses [ i ]     =    parseAddress ( to [ i ]  )  ;", "}", "setTo ( addresses )  ;", "}", "METHOD_END"], "methodName": ["setTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( to ,     \" To   address   must   not   be   null \"  )  ;", "validateAddress ( to )  ;", "this . m . setRecipient ( TO ,    to )  ;", "}", "METHOD_END"], "methodName": ["setTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( to ,     \" To   address   array   must   not   be   null \"  )  ;", "validateAddresses ( to )  ;", "this . m . setRecipients ( TO ,    to )  ;", "}", "METHOD_END"], "methodName": ["setTo"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "this . validateAddresses    =    validateAddresses ;", "}", "METHOD_END"], "methodName": ["setValidateAddresses"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( isValidateAddresses (  )  )     {", "address . validate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateAddress"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "for    ( InternetAddress   address    :    addresses )     {", "validateAddress ( address )  ;", "}", "}", "METHOD_END"], "methodName": ["validateAddresses"], "fileName": "org.springframework.mail.javamail.MimeMessageHelper"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultEncoding ;", "}", "METHOD_END"], "methodName": ["getDefaultEncoding"], "fileName": "org.springframework.mail.javamail.SmartMimeMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultFileTypeMap ;", "}", "METHOD_END"], "methodName": ["getDefaultFileTypeMap"], "fileName": "org.springframework.mail.javamail.SmartMimeMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.scheduling.commonj.DelegatingWork"}, {"methodBody": ["METHOD_START", "{", "return   this . delay ;", "}", "METHOD_END"], "methodName": ["getDelay"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "return   this . period ;", "}", "METHOD_END"], "methodName": ["getPeriod"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "return   this . timerListener ;", "}", "METHOD_END"], "methodName": ["getTimerListener"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "return   this . fixedRate ;", "}", "METHOD_END"], "methodName": ["isFixedRate"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "return    ( this . period )     <     0  ;", "}", "METHOD_END"], "methodName": ["isOneTimeTask"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "this . delay    =    delay ;", "}", "METHOD_END"], "methodName": ["setDelay"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "this . fixedRate    =    fixedRate ;", "}", "METHOD_END"], "methodName": ["setFixedRate"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "this . period    =    period ;", "}", "METHOD_END"], "methodName": ["setPeriod"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "this . timerListener    =    new   DelegatingTimerListener ( timerTask )  ;", "}", "METHOD_END"], "methodName": ["setRunnable"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "this . timerListener    =    timerListener ;", "}", "METHOD_END"], "methodName": ["setTimerListener"], "fileName": "org.springframework.scheduling.commonj.ScheduledTimerListener"}, {"methodBody": ["METHOD_START", "{", "return   this . timerManager ;", "}", "METHOD_END"], "methodName": ["getTimerManager"], "fileName": "org.springframework.scheduling.commonj.TimerManagerAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( this . timerManager ,     \" No   TimerManager   set \"  )  ;", "return   this . timerManager ;", "}", "METHOD_END"], "methodName": ["obtainTimerManager"], "fileName": "org.springframework.scheduling.commonj.TimerManagerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . shared    =    shared ;", "}", "METHOD_END"], "methodName": ["setShared"], "fileName": "org.springframework.scheduling.commonj.TimerManagerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . timerManager    =    timerManager ;", "}", "METHOD_END"], "methodName": ["setTimerManager"], "fileName": "org.springframework.scheduling.commonj.TimerManagerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . timerManagerName    =    timerManagerName ;", "}", "METHOD_END"], "methodName": ["setTimerManagerName"], "fileName": "org.springframework.scheduling.commonj.TimerManagerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . scheduledTimerListeners    =    scheduledTimerListeners ;", "}", "METHOD_END"], "methodName": ["setScheduledTimerListeners"], "fileName": "org.springframework.scheduling.commonj.TimerManagerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   TaskUtils . decorateTaskWithErrorHandler ( delegate ,    this . errorHandler ,    isRepeatingTask )  ;", "}", "METHOD_END"], "methodName": ["errorHandlingTask"], "fileName": "org.springframework.scheduling.commonj.TimerManagerTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.scheduling.commonj.TimerManagerTaskScheduler"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . workManager )     !  =    null )  ,     \" No   WorkManager   specified \"  )  ;", "return   this . workManager ;", "}", "METHOD_END"], "methodName": ["obtainWorkManager"], "fileName": "org.springframework.scheduling.commonj.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . taskDecorator    =    taskDecorator ;", "}", "METHOD_END"], "methodName": ["setTaskDecorator"], "fileName": "org.springframework.scheduling.commonj.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . workListener    =    workListener ;", "}", "METHOD_END"], "methodName": ["setWorkListener"], "fileName": "org.springframework.scheduling.commonj.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . workManager    =    workManager ;", "}", "METHOD_END"], "methodName": ["setWorkManager"], "fileName": "org.springframework.scheduling.commonj.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "this . workManagerName    =    workManagerName ;", "}", "METHOD_END"], "methodName": ["setWorkManagerName"], "fileName": "org.springframework.scheduling.commonj.WorkManagerTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "if    ( jobObject   instanceof   Job )     {", "return    (  ( Job )     ( jobObject )  )  ;", "} else", "if    ( jobObject   instanceof   Runnable )     {", "return   new   DelegatingJob (  (  ( Runnable )     ( jobObject )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  \" Unable   to   execute   job   class    [  \"     +     ( jobObject . getClass (  )  . getName (  )  )  )     +     \"  ]  :    only    [ orJob ]    and    [ Runnable ]    supported .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["adaptJob"], "fileName": "org.springframework.scheduling.quartz.AdaptableJobFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    jobClass    =    bundle . getJobDetail (  )  . getJobClass (  )  ;", "return   ReflectionUtils . accessibleConstru ( jobClass )  . newInstance (  )  ;", "}", "METHOD_END"], "methodName": ["createJobInstance"], "fileName": "org.springframework.scheduling.quartz.AdaptableJobFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . jobDataMap ;", "}", "METHOD_END"], "methodName": ["getJobDataMap"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . calendarName    =    calendarName ;", "}", "METHOD_END"], "methodName": ["setCalendarName"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . cronExpression    =    cronExpression ;", "}", "METHOD_END"], "methodName": ["setCronExpression"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . group    =    group ;", "}", "METHOD_END"], "methodName": ["setGroup"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . jobDataMap . putAll ( jobDataAsMap )  ;", "}", "METHOD_END"], "methodName": ["setJobDataAsMap"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . jobDataMap    =    jobDataMap ;", "}", "METHOD_END"], "methodName": ["setJobDataMap"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . jobDetail    =    jobDetail ;", "}", "METHOD_END"], "methodName": ["setJobDetail"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . misfireInstruction    =    misfireInstruction ;", "}", "METHOD_END"], "methodName": ["setMisfireInstruction"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . misfireInstruction    =    CronTriggerFactoryBean . constants . asNumber ( constantName )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["setMisfireInstructionName"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . priority    =    priority ;", "}", "METHOD_END"], "methodName": ["setPriority"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( startDelay    >  =     0  )  ,     \" Start   delay   cannot   be   negative \"  )  ;", "this . startDelay    =    startDelay ;", "}", "METHOD_END"], "methodName": ["setStartDelay"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . startTime    =    startTime ;", "}", "METHOD_END"], "methodName": ["setStartTime"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . timeZone    =    timeZone ;", "}", "METHOD_END"], "methodName": ["setTimeZone"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "CronTriggerFactoryBean   factory    =    new   CronTriggerFactoryBean (  )  ;", "factory . setName (  \" myTrigger \"  )  ;", "factory . setCronExpression (  \"  0     1  5     1  0     ?     *     *  \"  )  ;", "factory . afterPropertiesSet (  )  ;", "CronTrigger   trigger    =    factory . getObject (  )  ;", "assertEquals (  \"  0     1  5     1  0     ?     *     *  \"  ,    trigger . getCronExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["createWithoutJobDetail"], "fileName": "org.springframework.scheduling.quartz.CronTriggerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.scheduling.quartz.DelegatingJob"}, {"methodBody": ["METHOD_START", "{", "return   this . jobDataMap ;", "}", "METHOD_END"], "methodName": ["getJobDataMap"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . applicationContextJobDataKey    =    applicationContextJobDataKey ;", "}", "METHOD_END"], "methodName": ["setApplicationContextJobDataKey"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . durability    =    durability ;", "}", "METHOD_END"], "methodName": ["setDurability"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . group    =    group ;", "}", "METHOD_END"], "methodName": ["setGroup"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . jobClass    =    jobClass ;", "}", "METHOD_END"], "methodName": ["setJobClass"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "getJobDataMap (  )  . putAll ( jobDataAsMap )  ;", "}", "METHOD_END"], "methodName": ["setJobDataAsMap"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . jobDataMap    =    jobDataMap ;", "}", "METHOD_END"], "methodName": ["setJobDataMap"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . requestsRecovery    =    requestsRecovery ;", "}", "METHOD_END"], "methodName": ["setRequestsRecovery"], "fileName": "org.springframework.scheduling.quartz.JobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . concurrent    =    concurrent ;", "}", "METHOD_END"], "methodName": ["setConcurrent"], "fileName": "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . group    =    group ;", "}", "METHOD_END"], "methodName": ["setGroup"], "fileName": "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanName    =    targetBeanName ;", "}", "METHOD_END"], "methodName": ["setTargetBeanName"], "fileName": "org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" quartzSchedulerLifecycleTests . xml \"  ,    this . getClass (  )  )  ;", "assertNotNull ( context . getBean (  \" lazyInitSchedulerWithCustomShutdownOrder \"  )  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" lazyScheduler \"  )  ;", "context . close (  )  ;", "sw . stop (  )  ;", "assertTrue (  (  \" Quartz   Scheduler   with   lazy - init   is   hanging   on   destruction :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     5  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["destroyLazyInitSchedulerWithCustomShutdownOrderDoesNotHang"], "fileName": "org.springframework.scheduling.quartz.QuartzSchedulerLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "AbstractApplicationContext   context    =    new   ClassPathXmlApplicationContext (  \" quartzSchedulerLifecycleTests . xml \"  ,    this . getClass (  )  )  ;", "assertNotNull ( context . getBean (  \" lazyInitSchedulerWithDefaultShutdownOrder \"  )  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" lazyScheduler \"  )  ;", "context . close (  )  ;", "sw . stop (  )  ;", "assertTrue (  (  \" Quartz   Scheduler   with   lazy - init   is   hanging   on   destruction :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     5  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["destroyLazyInitSchedulerWithDefaultShutdownOrderDoesNotHang"], "fileName": "org.springframework.scheduling.quartz.QuartzSchedulerLifecycleTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathXmlApplicationContext ( path ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["context"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "JobDetailImpl   jobDetail    =    new   JobDetailImpl (  )  ;", "jobDetail . setJobClass (  (  ( Class )     (  . DummyRunnable . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["jobDetailWithRunnableInsteadOfJob"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    context (  \" multipleSchedulers . xml \"  )  ;", "try    {", "Scheduler   er 1     =     (  ( Scheduler )     ( ctx . getBean (  \" er 1  \"  )  )  )  ;", "Scheduler   er 2     =     (  ( Scheduler )     ( ctx . getBean (  \" er 2  \"  )  )  )  ;", "assertNotSame ( er 1  ,    er 2  )  ;", "assertEquals (  \" quartz 1  \"  ,    er 1  . getSchedulerName (  )  )  ;", "assertEquals (  \" quartz 2  \"  ,    er 2  . getSchedulerName (  )  )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["multipleSchedulers"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ClassPathXmlApplicationContext   ctx    =    context (  \" erAccessorBean . xml \"  )  ;", "Thread . sleep (  3  0  0  0  )  ;", "try    {", "QuartzTestBean   exportService    =     (  ( QuartzTestBean )     ( ctx . getBean (  \" exportService \"  )  )  )  ;", "QuartzTestBean   importService    =     (  ( QuartzTestBean )     ( ctx . getBean (  \" importService \"  )  )  )  ;", "assertEquals (  \" doImport   called   exportService \"  ,     0  ,    exportService . getImportCount (  )  )  ;", "assertEquals (  \" doExport   not   called   on   exportService \"  ,     2  ,    exportService . getExportCount (  )  )  ;", "assertEquals (  \" doImport   not   called   on   importService \"  ,     2  ,    importService . getImportCount (  )  )  ;", "assertEquals (  \" doExport   called   on   importService \"  ,     0  ,    importService . getExportCount (  )  )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["schedulerAccessorBean"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "context . registerBeanDefinition (  \" er \"  ,    new   RootBeanDefinition ( SchedulerFactoryBean . class )  )  ;", "Scheduler   bean    =    context . getBean (  \" er \"  ,    Scheduler . class )  ;", "assertFalse ( bean . isStarted (  )  )  ;", "context . refresh (  )  ;", "assertTrue ( bean . isStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["schedulerAutoStartsOnContextRefreshedEventByDefault"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   context    =    new   StaticApplicationContext (  )  ;", "BeanDefinition   beanDefinition    =    BeanDefinitionBuilder . genericBeanDefinition ( SchedulerFactoryBean . class )  . addPropertyValue (  \" autoStartup \"  ,    false )  . getBeanDefinition (  )  ;", "context . registerBeanDefinition (  \" er \"  ,    beanDefinition )  ;", "Scheduler   bean    =    context . getBean (  \" er \"  ,    Scheduler . class )  ;", "assertFalse ( bean . isStarted (  )  )  ;", "context . refresh (  )  ;", "assertFalse ( bean . isStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["schedulerAutoStartupFalse"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  \" tb \"  ,     9  9  )  ;", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "final   Scheduler   er    =    mock ( Scheduler . class )  ;", "SchedulerContext   erContext    =    new   SchedulerContext (  )  ;", "given ( er . getContext (  )  )  . willReturn ( erContext )  ;", "SchedulerFactoryBean   erFactoryBean    =    new   SchedulerFactoryBean (  )     {", "@ Override", "protected   Scheduler   createScheduler ( SchedulerFactory   erFactory ,    String   erName )     {", "return   er ;", "}", "}  ;", "erFactoryBean . setJobFactory ( null )  ;", "Map < String ,    Object >    erContextMap    =    new   HashMap <  >  (  )  ;", "erContextMap . put (  \" testBean \"  ,    tb )  ;", "erFactoryBean . setSchedulerContextAsMap ( erContextMap )  ;", "erFactoryBean . setApplicationContext ( ac )  ;", "erFactoryBean . setApplicationContextSchedulerContextKey (  \" appCtx \"  )  ;", "try    {", "erFactoryBean . afterPropertiesSet (  )  ;", "erFactoryBean . start (  )  ;", "Scheduler   returnedScheduler    =    erFactoryBean . getObject (  )  ;", "assertEquals ( tb ,    returnedScheduler . getContext (  )  . get (  \" testBean \"  )  )  ;", "assertEquals ( ac ,    returnedScheduler . getContext (  )  . get (  \" appCtx \"  )  )  ;", "}    finally    {", "erFactoryBean . destroy (  )  ;", "}", "verify ( er )  . start (  )  ;", "verify ( er )  . shutdown ( false )  ;", "}", "METHOD_END"], "methodName": ["schedulerFactoryBeanWithApplicationContext"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   ctx    =    context (  \" schedulerRepositoryExposure . xml \"  )  ;", "assertSame ( SchedulerRepository . getInstance (  )  . lookup (  \" myScheduler \"  )  ,    ctx . getBean (  \" scheduler \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["schedulerRepositoryExposure"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "QuartzSupportTests . DummyJob . param    =     0  ;", "QuartzSupportTests . DummyJob . count    =     0  ;", "ClassPathXmlApplicationContext   ctx    =    context (  \" databasePersistence . xml \"  )  ;", "JdbcTemplate   jdbcTemplate    =    new   JdbcTemplate ( ctx . getBean ( DataSource . class )  )  ;", "assertFalse (  \" No   triggers   were   persisted \"  ,    jdbcTemplate . queryForList (  \" SELECT    *    FROM   qrtz _ triggers \"  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["schedulerWithHsqlDataSource"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", ". DummyJob . param    =     0  ;", ". DummyJob . count    =     0  ;", "JobDetailImpl   jobDetail    =    new   JobDetailImpl (  )  ;", "jobDetail . setDurability ( true )  ;", "jobDetail . setJobClass (  . DummyJobBean . class )  ;", "jobDetail . setName (  \" myJob \"  )  ;", "jobDetail . getJobDataMap (  )  . put (  \" param \"  ,     \"  1  0  \"  )  ;", "SimpleTriggerFactoryBean   trigger    =    new   SimpleTriggerFactoryBean (  )  ;", "trigger . setName (  \" myTrigger \"  )  ;", "trigger . setJobDetail ( jobDetail )  ;", "trigger . setStartDelay (  1  )  ;", "trigger . setRepeatInterval (  5  0  0  )  ;", "trigger . setRepeatCount (  1  )  ;", "trigger . afterPropertiesSet (  )  ;", "SchedulerFactoryBean   bean    =    new   SchedulerFactoryBean (  )  ;", "bean . setTriggers ( trigger . getObject (  )  )  ;", "bean . setJobDetails ( jobDetail )  ;", "bean . afterPropertiesSet (  )  ;", "bean . start (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertEquals (  1  0  ,     . DummyJobBean . param )  ;", "assertTrue (  (  (  . DummyJobBean . count )     >     0  )  )  ;", "bean . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["schedulerWithQuartzJobBean"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", ". DummyJob . param    =     0  ;", ". DummyJob . count    =     0  ;", "JobDetailImpl   jobDetail    =    new   JobDetailImpl (  )  ;", "jobDetail . setDurability ( true )  ;", "jobDetail . setJobClass (  . DummyJob . class )  ;", "jobDetail . setName (  \" myJob \"  )  ;", "jobDetail . getJobDataMap (  )  . put (  \" param \"  ,     \"  1  0  \"  )  ;", "jobDetail . getJobDataMap (  )  . put (  \" ignoredParam \"  ,     \"  1  0  \"  )  ;", "SimpleTriggerFactoryBean   trigger    =    new   SimpleTriggerFactoryBean (  )  ;", "trigger . setName (  \" myTrigger \"  )  ;", "trigger . setJobDetail ( jobDetail )  ;", "trigger . setStartDelay (  1  )  ;", "trigger . setRepeatInterval (  5  0  0  )  ;", "trigger . setRepeatCount (  1  )  ;", "trigger . afterPropertiesSet (  )  ;", "SchedulerFactoryBean   bean    =    new   SchedulerFactoryBean (  )  ;", "bean . setJobFactory ( new   SpringBeanJobFactory (  )  )  ;", "bean . setTriggers ( trigger . getObject (  )  )  ;", "bean . setJobDetails ( jobDetail )  ;", "bean . afterPropertiesSet (  )  ;", "bean . start (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertEquals (  1  0  ,     . DummyJob . param )  ;", "assertTrue (  \" DummyJob   should   have   been   executed   at   least   once .  \"  ,     (  (  . DummyJob . count )     >     0  )  )  ;", "bean . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["schedulerWithSpringBeanJobFactory"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", ". DummyJob . param    =     0  ;", ". DummyJob . count    =     0  ;", "SchedulerFactoryBean   bean    =    new   SchedulerFactoryBean (  )  ;", "bean . setJobFactory ( new   SpringBeanJobFactory (  )  )  ;", "bean . setJobSchedulingDataLocation (  \" org / springframework / scheduling / quartz / job - scheduling - data . xml \"  )  ;", "bean . afterPropertiesSet (  )  ;", "bean . start (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertEquals (  1  0  ,     . DummyJob . param )  ;", "assertTrue (  \" DummyJob   should   have   been   executed   at   least   once .  \"  ,     (  (  . DummyJob . count )     >     0  )  )  ;", "bean . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["schedulerWithSpringBeanJobFactoryAndJobSchedulingData"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", ". DummyJob . param    =     0  ;", ". DummyJob . count    =     0  ;", "JobDetailImpl   jobDetail    =    new   JobDetailImpl (  )  ;", "jobDetail . setDurability ( true )  ;", "jobDetail . setJobClass (  . DummyJob . class )  ;", "jobDetail . setName (  \" myJob \"  )  ;", "jobDetail . getJobDataMap (  )  . put (  \" para \"  ,     \"  1  0  \"  )  ;", "jobDetail . getJobDataMap (  )  . put (  \" ignoredParam \"  ,     \"  1  0  \"  )  ;", "SimpleTriggerFactoryBean   trigger    =    new   SimpleTriggerFactoryBean (  )  ;", "trigger . setName (  \" myTrigger \"  )  ;", "trigger . setJobDetail ( jobDetail )  ;", "trigger . setStartDelay (  1  )  ;", "trigger . setRepeatInterval (  5  0  0  )  ;", "trigger . setRepeatCount (  1  )  ;", "trigger . afterPropertiesSet (  )  ;", "SchedulerFactoryBean   bean    =    new   SchedulerFactoryBean (  )  ;", "SpringBeanJobFactory   jobFactory    =    new   SpringBeanJobFactory (  )  ;", "jobFactory . setIgnoredUnknownProperties (  \" ignoredParam \"  )  ;", "bean . setJobFactory ( jobFactory )  ;", "bean . setTriggers ( trigger . getObject (  )  )  ;", "bean . setJobDetails ( jobDetail )  ;", "bean . afterPropertiesSet (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertEquals (  0  ,     . DummyJob . param )  ;", "assertTrue (  (  (  . DummyJob . count )     =  =     0  )  )  ;", "bean . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["schedulerWithSpringBeanJobFactoryAndParamMismatchNotIgnored"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", ". DummyJobBean . param    =     0  ;", ". DummyJobBean . count    =     0  ;", "JobDetailImpl   jobDetail    =    new   JobDetailImpl (  )  ;", "jobDetail . setDurability ( true )  ;", "jobDetail . setJobClass (  . DummyJobBean . class )  ;", "jobDetail . setName (  \" myJob \"  )  ;", "jobDetail . getJobDataMap (  )  . put (  \" param \"  ,     \"  1  0  \"  )  ;", "SimpleTriggerFactoryBean   trigger    =    new   SimpleTriggerFactoryBean (  )  ;", "trigger . setName (  \" myTrigger \"  )  ;", "trigger . setJobDetail ( jobDetail )  ;", "trigger . setStartDelay (  1  )  ;", "trigger . setRepeatInterval (  5  0  0  )  ;", "trigger . setRepeatCount (  1  )  ;", "trigger . afterPropertiesSet (  )  ;", "SchedulerFactoryBean   bean    =    new   SchedulerFactoryBean (  )  ;", "bean . setJobFactory ( new   SpringBeanJobFactory (  )  )  ;", "bean . setTriggers ( trigger . getObject (  )  )  ;", "bean . setJobDetails ( jobDetail )  ;", "bean . afterPropertiesSet (  )  ;", "bean . start (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertEquals (  1  0  ,     . DummyJobBean . param )  ;", "assertTrue (  (  (  . DummyJobBean . count )     >     0  )  )  ;", "bean . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["schedulerWithSpringBeanJobFactoryAndQuartzJobBean"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", ". CountingTaskExecutor   taskExecutor    =    new    . CountingTaskExecutor (  )  ;", ". DummyJob . count    =     0  ;", "JobDetailImpl   jobDetail    =    new   JobDetailImpl (  )  ;", "jobDetail . setDurability ( true )  ;", "jobDetail . setJobClass (  . DummyJob . class )  ;", "jobDetail . setName (  \" myJob \"  )  ;", "SimpleTriggerFactoryBean   trigger    =    new   SimpleTriggerFactoryBean (  )  ;", "trigger . setName (  \" myTrigger \"  )  ;", "trigger . setJobDetail ( jobDetail )  ;", "trigger . setStartDelay (  1  )  ;", "trigger . setRepeatInterval (  5  0  0  )  ;", "trigger . setRepeatCount (  1  )  ;", "trigger . afterPropertiesSet (  )  ;", "SchedulerFactoryBean   bean    =    new   SchedulerFactoryBean (  )  ;", "bean . setTaskExecutor ( taskExecutor )  ;", "bean . setTriggers ( trigger . getObject (  )  )  ;", "bean . setJobDetails ( jobDetail )  ;", "bean . afterPropertiesSet (  )  ;", "bean . start (  )  ;", "Thread . sleep (  5  0  0  )  ;", "assertTrue (  \" DummyJob   should   have   been   executed   at   least   once .  \"  ,     (  (  . DummyJob . count )     >     0  )  )  ;", "assertEquals (  . DummyJob . count ,    taskExecutor . count )  ;", "bean . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["schedulerWithTaskExecutor"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "ClassPathXmlApplicationContext   ctx    =    context (  \" multipleAnonymousMethodInvokingJobDetailFB . xml \"  )  ;", "Thread . sleep (  3  0  0  0  )  ;", "try    {", "TestBean   exportService    =     (  ( TestBean )     ( ctx . getBean (  \" exportService \"  )  )  )  ;", "TestBean   importService    =     (  ( TestBean )     ( ctx . getBean (  \" importService \"  )  )  )  ;", "assertEquals (  \" doImport   called   exportService \"  ,     0  ,    exportService . getImportCount (  )  )  ;", "assertEquals (  \" doExport   not   called   on   exportService \"  ,     2  ,    exportService . getExportCount (  )  )  ;", "assertEquals (  \" doImport   not   called   on   importService \"  ,     2  ,    importService . getImportCount (  )  )  ;", "assertEquals (  \" doExport   called   on   importService \"  ,     0  ,    importService . getExportCount (  )  )  ;", "}    finally    {", "ctx . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["twoAnonymousMethodInvokingJobDetailFactoryBeans"], "fileName": "org.springframework.scheduling.quartz.QuartzSupportTests"}, {"methodBody": ["METHOD_START", "{", "+  +  ( exportCount )  ;", "}", "METHOD_END"], "methodName": ["doExport"], "fileName": "org.springframework.scheduling.quartz.QuartzTestBean"}, {"methodBody": ["METHOD_START", "{", "+  +  ( importCount )  ;", "}", "METHOD_END"], "methodName": ["doImport"], "fileName": "org.springframework.scheduling.quartz.QuartzTestBean"}, {"methodBody": ["METHOD_START", "{", "return   exportCount ;", "}", "METHOD_END"], "methodName": ["getExportCount"], "fileName": "org.springframework.scheduling.quartz.QuartzTestBean"}, {"methodBody": ["METHOD_START", "{", "return   importCount ;", "}", "METHOD_END"], "methodName": ["getImportCount"], "fileName": "org.springframework.scheduling.quartz.QuartzTestBean"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Class <  ?    extends   T >  )     ( loadClass ( name )  )  )  ;", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.springframework.scheduling.quartz.ResourceLoaderClassLoadHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . overwriteExistingJobs )     |  |     (  ( getScheduler (  )  . getJobDetail ( jobDetail . getKey (  )  )  )     =  =    null )  )     {", "getScheduler (  )  . addJob ( jobDetail ,    true )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["addJobToScheduler"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "boolean   triggerExists    =     ( getScheduler (  )  . getTrigger ( trigger . getKey (  )  )  )     !  =    null ;", "if    ( triggerExists    &  &     (  !  ( this . overwriteExistingJobs )  )  )     {", "return   false ;", "}", "JobDetail   jobDetail    =     (  ( JobDetail )     ( trigger . getJobDataMap (  )  . remove (  \" jobDetail \"  )  )  )  ;", "if    ( triggerExists )     {", "if    (  (  (  ( jobDetail    !  =    null )     &  &     (  ( this . jobDetails )     !  =    null )  )     &  &     (  !  ( this . jobDetails . contains ( jobDetail )  )  )  )     &  &     ( addJobToScheduler ( jobDetail )  )  )     {", "this . jobDetails . add ( jobDetail )  ;", "}", "getScheduler (  )  . rescheduleJob ( trigger . getKey (  )  ,    trigger )  ;", "} else    {", "try    {", "if    (  (  (  ( jobDetail    !  =    null )     &  &     (  ( this . jobDetails )     !  =    null )  )     &  &     (  !  ( this . jobDetails . contains ( jobDetail )  )  )  )     &  &     (  ( this . overwriteExistingJobs )     |  |     (  ( getScheduler (  )  . getJobDetail ( jobDetail . getKey (  )  )  )     =  =    null )  )  )     {", "getScheduler (  )  . scheduleJob ( jobDetail ,    trigger )  ;", "this . jobDetails . add ( jobDetail )  ;", "} else    {", "getScheduler (  )  . scheduleJob ( trigger )  ;", "}", "}    catch    ( ObjectAlreadyExistsException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Unexpectedly   found   existing   trigger ,    assumably   due   to   cluster   race   condition :     \"     +     ( ex . getMessage (  )  )  )     +     \"     -    can   safely   be   ignored \"  )  )  ;", "}", "if    ( this . overwriteExistingJobs )     {", "getScheduler (  )  . rescheduleJob ( trigger . getKey (  )  ,    trigger )  ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["addTriggerToScheduler"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "TransactionStatus   transactionStatus    =    null ;", "if    (  ( this . transactionManager )     !  =    null )     {", "transactionStatus    =    this . transactionManager . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "}", "try    {", "if    (  ( this . jobSDataLocations )     !  =    null )     {", "ClassLoadHelper   clh    =    new   ResourceLoaderClassLoadHelper ( this . resourceLoader )  ;", "clh . initialize (  )  ;", "XMLSDataProcessor   dataProcessor    =    new   XMLSDataProcessor ( clh )  ;", "for    ( String   location    :    this . jobSDataLocations )     {", "dataProcessor . processFileAndScheduleJobs ( location ,    getScheduler (  )  )  ;", "}", "}", "if    (  ( this . jobDetails )     !  =    null )     {", "for    ( JobDetail   jobDetail    :    this . jobDetails )     {", "addJobToScheduler ( jobDetail )  ;", "}", "} else    {", "this . jobDetails    =    new   LinkedList (  )  ;", "}", "if    (  ( this . calendars )     !  =    null )     {", "for    ( String   calendarName    :    this . calendars . keySet (  )  )     {", "Calendar   calendar    =    this . calendars . get ( calendarName )  ;", "getScheduler (  )  . addCalendar ( calendarName ,    calendar ,    true ,    true )  ;", "}", "}", "if    (  ( this . triggers )     !  =    null )     {", "for    ( Trigger   trigger    :    this . triggers )     {", "addTriggerToScheduler ( trigger )  ;", "}", "}", "}    catch    ( Throwable   ex )     {", "if    ( transactionStatus    !  =    null )     {", "try    {", "this . transactionManager . rollback ( transactionStatus )  ;", "}    catch    ( TransactionException   tex )     {", "logger . error (  \" Job   registration   exception   overridden   by   rollback   exception \"  ,    ex )  ;", "throw   tex ;", "}", "}", "if    ( ex   instanceof   SchedulerException )     {", "throw    (  ( SchedulerException )     ( ex )  )  ;", "}", "if    ( ex   instanceof   Exception )     {", "throw   new   SchedulerException (  (  \" Registration   of   jobs   and   triggers   failed :     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "throw   new   SchedulerException (  (  \" Registration   of   jobs   and   triggers   failed :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "if    ( transactionStatus    !  =    null )     {", "this . transactionManager . commit ( transactionStatus )  ;", "}", "}", "METHOD_END"], "methodName": ["registerJobsAndTriggers"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "ListenerManager   listenerManager    =    getScheduler (  )  . getListenerManager (  )  ;", "if    (  ( this . schedulerListeners )     !  =    null )     {", "for    ( SchedulerListener   listener    :    this . schedulerListeners )     {", "listenerManager . addSchedulerListener ( listener )  ;", "}", "}", "if    (  ( this . globalJobListeners )     !  =    null )     {", "for    ( JobListener   listener    :    this . globalJobListeners )     {", "listenerManager . addJobListener ( listener )  ;", "}", "}", "if    (  ( this . globalTriggerListeners )     !  =    null )     {", "for    ( TriggerListener   listener    :    this . globalTriggerListeners )     {", "listenerManager . addTriggerListener ( listener )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerListeners"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . calendars    =    calendars ;", "}", "METHOD_END"], "methodName": ["setCalendars"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . globalJobListeners    =    globalJobListeners ;", "}", "METHOD_END"], "methodName": ["setGlobalJobListeners"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . globalTriggerListeners    =    globalTriggerListeners ;", "}", "METHOD_END"], "methodName": ["setGlobalTriggerListeners"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . jobDetails    =    new   ArrayList ( Arrays . asList ( jobDetails )  )  ;", "}", "METHOD_END"], "methodName": ["setJobDetails"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . jobSchedulingDataLocations    =    new   String [  ]  {    jobSchedulingDataLocation    }  ;", "}", "METHOD_END"], "methodName": ["setJobSchedulingDataLocation"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . jobSchedulingDataLocations    =    jobSchedulingDataLocations ;", "}", "METHOD_END"], "methodName": ["setJobSchedulingDataLocations"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . overwriteExistingJobs    =    overwriteExistingJobs ;", "}", "METHOD_END"], "methodName": ["setOverwriteExistingJobs"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . schedulerListeners    =    schedulerListeners ;", "}", "METHOD_END"], "methodName": ["setSchedulerListeners"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . transactionManager    =    transactionManager ;", "}", "METHOD_END"], "methodName": ["setTransactionManager"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "this . triggers    =    Arrays . asList ( triggers )  ;", "}", "METHOD_END"], "methodName": ["setTriggers"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )     !  =    null )     {", "return   this . beanFactory . getBean (  . class )  ;", "} else    {", "throw   new   IllegalStateException (  \" No      specified ,    and   cannot   find   a   default      without   a   BeanFactory \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["findDefaultScheduler"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessorBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )    instanceof   ListableBeanFactory )     {", "ListableBeanFactory   lbf    =     (  ( ListableBeanFactory )     ( this . beanFactory )  )  ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType (  . class )  ;", "for    ( String   beanName    :    beanNames )     {", "schedulerBean    =     (  (  )     ( lbf . getBean ( beanName )  )  )  ;", "if    ( schedulerName . equals ( schedulerBean . getName (  )  )  )     {", "return   schedulerBean ;", "}", "}", "}", "schedulerInRepo    =    Repository . getInstance (  )  . lookup ( schedulerName )  ;", "if    ( schedulerInRepo    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No      named    '  \"     +    schedulerName )     +     \"  '    found \"  )  )  ;", "}", "return   schedulerInRepo ;", "}", "METHOD_END"], "methodName": ["findScheduler"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessorBean"}, {"methodBody": ["METHOD_START", "{", "this . scheduler    =    scheduler ;", "}", "METHOD_END"], "methodName": ["setScheduler"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessorBean"}, {"methodBody": ["METHOD_START", "{", "this . schedulerName    =    schedulerName ;", "}", "METHOD_END"], "methodName": ["setSchedulerName"], "fileName": "org.springframework.scheduling.quartz.SchedulerAccessorBean"}, {"methodBody": ["METHOD_START", "{", "Thread   currentThread    =    Thread . currentThread (  )  ;", "ClassLoader   threadContextClassLoader    =    currentThread . getContextClassLoader (  )  ;", "boolean   overrideClassLoader    =     (  ( this . resourceLoader )     !  =    null )     &  &     (  ( this . resourceLoader . getClassLoader (  )  )     !  =    threadContextClassLoader )  ;", "if    ( overrideClassLoader )     {", "currentThread . setContextClassLoader ( this . resourceLoader . getClassLoader (  )  )  ;", "}", "try    {", "SchedulerRepository   repository    =    SchedulerRepository . getInstance (  )  ;", "synchronized ( repository )     {", "Scheduler   existingScheduler    =     ( schedulerName    !  =    null )     ?    repository . lookup ( schedulerName )     :    null ;", "Scheduler   newScheduler    =    s . getScheduler (  )  ;", "if    ( newScheduler    =  =    existingScheduler )     {", "throw   new   IllegalStateException (  (  (  (  \" Active   Scheduler   of   name    '  \"     +    schedulerName )     +     \"  '    already   registered    \"  )     +     \" in   Quartz   SchedulerRepository .    Cannot   create   a   new   Spring - managed   Scheduler   of   the   same   name !  \"  )  )  ;", "}", "if    (  !  ( this . exposeSchedulerInRepository )  )     {", "SchedulerRepository . getInstance (  )  . remove ( newScheduler . getSchedulerName (  )  )  ;", "}", "return   newScheduler ;", "}", "}    finally    {", "if    ( overrideClassLoader )     {", "currentThread . setContextClassLoader ( threadContextClassLoader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createScheduler"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   SchedulerFactoryBean . configTimeDataSourceHolder . get (  )  ;", "}", "METHOD_END"], "methodName": ["getConfigTimeDataSource"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   SchedulerFactoryBean . configTimeNonTransactionalDataSourceHolder . get (  )  ;", "}", "METHOD_END"], "methodName": ["getConfigTimeNonTransactionalDataSource"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   SchedulerFactoryBean . configTimeResourceLoaderHolder . get (  )  ;", "}", "METHOD_END"], "methodName": ["getConfigTimeResourceLoader"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   SchedulerFactoryBean . configTimeTaskExecutorHolder . get (  )  ;", "}", "METHOD_END"], "methodName": ["getConfigTimeTaskExecutor"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Properties   mergedProps    =    new   Properties (  )  ;", "if    (  ( this . resourceLoader )     !  =    null )     {", "mergedProps . setProperty ( PROP _ SCHED _ CLASS _ LOAD _ HELPER _ CLASS ,    ResourceLoaderClassLoadHelper . class . getName (  )  )  ;", "}", "if    (  ( this . taskExecutor )     !  =    null )     {", "mergedProps . setProperty ( PROP _ THREAD _ POOL _ CLASS ,    LocalTaskExecutorThreadPool . class . getName (  )  )  ;", "} else    {", "mergedProps . setProperty ( PROP _ THREAD _ POOL _ CLASS ,    SimpleThreadPool . class . getName (  )  )  ;", "mergedProps . setProperty (  . PROP _ THREAD _ COUNT ,    Integer . toString (  . DEFAULT _ THREAD _ COUNT )  )  ;", "}", "if    (  ( this . configLocation )     !  =    null )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" Loading   Quartz   config   from    [  \"     +     ( this . configLocation )  )     +     \"  ]  \"  )  )  ;", "}", "PropertiesLoaderUtils . fillProperties ( mergedProps ,    this . configLocation )  ;", "}", "CollectionUtils . mergePropertiesIntoMap ( this . quartzProperties ,    mergedProps )  ;", "if    (  ( this . dataSource )     !  =    null )     {", "mergedProps . put ( PROP _ JOB _ STORE _ CLASS ,    LocalDataSourceJobStore . class . getName (  )  )  ;", "}", "if    (  ( this . schedulerName )     !  =    null )     {", "mergedProps . put ( PROP _ SCHED _ INSTANCE _ NAME ,    this . schedulerName )  ;", "}", "schedulerFactory . initialize ( mergedProps )  ;", "}", "METHOD_END"], "methodName": ["initSchedulerFactory"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . schedulerContextMap )     !  =    null )     {", "getScheduler (  )  . getContext (  )  . putAll ( this . schedulerContextMap )  ;", "}", "if    (  ( this . applicationContextSchedulerContextKey )     !  =    null )     {", "if    (  ( this . applicationContext )     =  =    null )     {", "throw   new   IllegalStateException (  (  \"    needs   to   be   set   up   in   an   ApplicationContext    \"     +     \" to   be   able   to   handle   an    ' applicationContextSchedulerContextKey '  \"  )  )  ;", "}", "getScheduler (  )  . getContext (  )  . put ( this . applicationContextSchedulerContextKey ,    this . applicationContext )  ;", "}", "}", "METHOD_END"], "methodName": ["populateSchedulerContext"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "SchedulerFactory   schedulerFactory    =    this . schedulerFactory ;", "if    ( schedulerFactory    =  =    null )     {", "schedulerFactory    =    BeanUtils . instantiateClass ( this . schedulerFactoryClass )  ;", "if    ( schedulerFactory   instanceof   StdSchedulerFactory )     {", "initSchedulerFactory (  (  ( StdSchedulerFactory )     ( schedulerFactory )  )  )  ;", "} else", "if    (  (  (  (  ( this . configLocation )     !  =    null )     |  |     (  ( this . quartzProperties )     !  =    null )  )     |  |     (  ( this . taskExecutor )     !  =    null )  )     |  |     (  ( this . dataSource )     !  =    null )  )     {", "throw   new   IllegalArgumentException (  (  \" StdSchedulerFactory   required   for   applying   Quartz   properties :     \"     +    schedulerFactory )  )  ;", "}", "}", "return   schedulerFactory ;", "}", "METHOD_END"], "methodName": ["prepareSchedulerFactory"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . applicationContextSchedulerContextKey    =    applicationContextSchedulerContextKey ;", "}", "METHOD_END"], "methodName": ["setApplicationContextSchedulerContextKey"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . configLocation    =    configLocation ;", "}", "METHOD_END"], "methodName": ["setConfigLocation"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . dataSource    =    dataSource ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . exposeSchedulerInRepository    =    exposeSchedulerInRepository ;", "}", "METHOD_END"], "methodName": ["setExposeSchedulerInRepository"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . jobFactory    =    jobFactory ;", "this . jobFactorySet    =    true ;", "}", "METHOD_END"], "methodName": ["setJobFactory"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . nonTransactionalDataSource    =    nonTransactionalDataSource ;", "}", "METHOD_END"], "methodName": ["setNonTransactionalDataSource"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . phase    =    phase ;", "}", "METHOD_END"], "methodName": ["setPhase"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . quartzProperties    =    quartzProperties ;", "}", "METHOD_END"], "methodName": ["setQuartzProperties"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . schedulerContextMap    =    schedulerContextAsMap ;", "}", "METHOD_END"], "methodName": ["setSchedulerContextAsMap"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . schedulerFactory    =    schedulerFactory ;", "}", "METHOD_END"], "methodName": ["setSchedulerFactory"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . schedulerFactoryClass    =    schedulerFactoryClass ;", "}", "METHOD_END"], "methodName": ["setSchedulerFactoryClass"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . schedulerName    =    schedulerName ;", "}", "METHOD_END"], "methodName": ["setSchedulerName"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . startupDelay    =    startupDelay ;", "}", "METHOD_END"], "methodName": ["setStartupDelay"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . taskExecutor    =    taskExecutor ;", "}", "METHOD_END"], "methodName": ["setTaskExecutor"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . waitForJobsToCompleteOnShutdown    =    waitForJobsToCompleteOnShutdown ;", "}", "METHOD_END"], "methodName": ["setWaitForJobsToCompleteOnShutdown"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( startupDelay    <  =     0  )     {", "logger . info (  \" Starting   Quartz   Scheduler   now \"  )  ;", "scheduler . start (  )  ;", "} else    {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  (  \" Will   start   Quartz   Scheduler    [  \"     +     ( scheduler . getSchedulerName (  )  )  )     +     \"  ]    in    \"  )     +    startupDelay )     +     \"    seconds \"  )  )  ;", "}", "Thread   schedulerThread    =    new   Thread (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "Thread . sleep ( TimeUnit . SECONDS . toMillis ( startupDelay )  )  ;", "}    catch    ( InterruptedException   ex )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  \" Starting   Quartz   Scheduler   now ,    after   delay   of    \"     +    startupDelay )     +     \"    seconds \"  )  )  ;", "}", "try    {", "scheduler . start (  )  ;", "}    catch    ( SchedulerException   ex )     {", "throw   new   SchedulingException (  \" Could   not   start   Quartz   Scheduler   after   delay \"  ,    ex )  ;", "}", "}", "}  ;", "schedulerThread . setName (  (  (  \" Quartz   Scheduler    [  \"     +     ( scheduler . getSchedulerName (  )  )  )     +     \"  ]  \"  )  )  ;", "schedulerThread . setDaemon ( true )  ;", "schedulerThread . start (  )  ;", "}", "}", "METHOD_END"], "methodName": ["startScheduler"], "fileName": "org.springframework.scheduling.quartz.SchedulerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . waitForJobsToCompleteOnShutdown    =    waitForJobsToCompleteOnShutdown ;", "}", "METHOD_END"], "methodName": ["setWaitForJobsToCompleteOnShutdown"], "fileName": "org.springframework.scheduling.quartz.SimpleThreadPoolTaskExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . jobDataMap ;", "}", "METHOD_END"], "methodName": ["getJobDataMap"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . group    =    group ;", "}", "METHOD_END"], "methodName": ["setGroup"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . jobDataMap . putAll ( jobDataAsMap )  ;", "}", "METHOD_END"], "methodName": ["setJobDataAsMap"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . jobDataMap    =    jobDataMap ;", "}", "METHOD_END"], "methodName": ["setJobDataMap"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . jobDetail    =    jobDetail ;", "}", "METHOD_END"], "methodName": ["setJobDetail"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . misfireInstruction    =    misfireInstruction ;", "}", "METHOD_END"], "methodName": ["setMisfireInstruction"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . misfireInstruction    =    SimpleTriggerFactoryBean . constants . asNumber ( constantName )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["setMisfireInstructionName"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . priority    =    priority ;", "}", "METHOD_END"], "methodName": ["setPriority"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . repeatCount    =    repeatCount ;", "}", "METHOD_END"], "methodName": ["setRepeatCount"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . repeatInterval    =    repeatInterval ;", "}", "METHOD_END"], "methodName": ["setRepeatInterval"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( startDelay    >  =     0  )  ,     \" Start   delay   cannot   be   negative \"  )  ;", "this . startDelay    =    startDelay ;", "}", "METHOD_END"], "methodName": ["setStartDelay"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . startTime    =    startTime ;", "}", "METHOD_END"], "methodName": ["setStartTime"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"}, {"methodBody": ["METHOD_START", "{", "SimpleTriggerFactoryBean   factory    =    new   SimpleTriggerFactoryBean (  )  ;", "factory . setName (  \" myTrigger \"  )  ;", "factory . setRepeatCount (  5  )  ;", "factory . setRepeatInterval (  1  0  0  0 L )  ;", "factory . afterPropertiesSet (  )  ;", "SimpleTrigger   trigger    =    factory . getObject (  )  ;", "assertEquals (  5  ,    trigger . getRepeatCount (  )  )  ;", "assertEquals (  1  0  0  0 L ,    trigger . getRepeatInterval (  )  )  ;", "}", "METHOD_END"], "methodName": ["createWithoutJobDetail"], "fileName": "org.springframework.scheduling.quartz.SimpleTriggerFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return    !  ( jobObject   instanceof   QuartzJobBean )  ;", "}", "METHOD_END"], "methodName": ["isEligibleForPropertyPopulation"], "fileName": "org.springframework.scheduling.quartz.SpringBeanJobFactory"}, {"methodBody": ["METHOD_START", "{", "this . ignoredUnknownProperties    =    ignoredUnknownProperties ;", "}", "METHOD_END"], "methodName": ["setIgnoredUnknownProperties"], "fileName": "org.springframework.scheduling.quartz.SpringBeanJobFactory"}, {"methodBody": ["METHOD_START", "{", "Configuration   config    =    newConfiguration (  )  ;", "Properties   props    =    new   Properties (  )  ;", "if    (  ( this . configLocation )     !  =    null )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Loading   FreeMarker   configuration   from    \"     +     ( this . configLocation )  )  )  ;", "}", "PropertiesLoaderUtils . fillProperties ( props ,    this . configLocation )  ;", "}", "if    (  ( this . freemarkerSettings )     !  =    null )     {", "props . putAll ( this . freemarkerSettings )  ;", "}", "if    (  !  ( props . isEmpty (  )  )  )     {", "config . setSettings ( props )  ;", "}", "if    (  !  ( CollectionUtils . isEmpty ( this . freemarkerVariables )  )  )     {", "config . setAllSharedVariables ( new   freemarker . template . SimpleHash ( this . freemarkerVariables ,    config . getObjectWrapper (  )  )  )  ;", "}", "if    (  ( this . defaultEncoding )     !  =    null )     {", "config . setDefaultEncoding ( this . defaultEncoding )  ;", "}", "List < TemplateLoader >    templateLoaders    =    new   LinkedList ( this . templateLoaders )  ;", "if    (  ( this . preTemplateLoaders )     !  =    null )     {", "templateLoaders . addAll ( this . preTemplateLoaders )  ;", "}", "if    (  ( this . templateLoaderPaths )     !  =    null )     {", "for    ( String   path    :    this . templateLoaderPaths )     {", "templateLoaders . add ( getTemplateLoaderForPath ( path )  )  ;", "}", "}", "postProcessTemplateLoaders ( templateLoaders )  ;", "if    (  ( this . postTemplateLoaders )     !  =    null )     {", "templateLoaders . addAll ( this . postTemplateLoaders )  ;", "}", "TemplateLoader   loader    =    getAggregateTemplateLoader ( templateLoaders )  ;", "if    ( loader    !  =    null )     {", "config . setTemplateLoader ( loader )  ;", "}", "postProcessConfiguration ( config )  ;", "return   config ;", "}", "METHOD_END"], "methodName": ["createConfiguration"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "switch    ( templateLoaders . size (  )  )     {", "case    0     :", "logger . info (  \" No   FreeMarker   TemplateLoaders   specified \"  )  ;", "return   null ;", "case    1     :", "return   templateLoaders . get (  0  )  ;", "default    :", "TemplateLoader [  ]    loaders    =    templateLoaders . toArray ( new   TemplateLoader [  0  ]  )  ;", "return   new   cache . MultiTemplateLoader ( loaders )  ;", "}", "}", "METHOD_END"], "methodName": ["getAggregateTemplateLoader"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceLoader ;", "}", "METHOD_END"], "methodName": ["getResourceLoader"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( isPreferFileSystemAccess (  )  )     {", "try    {", "Resource   path    =    getResourceLoader (  )  . getResource ( templateLoaderPath )  ;", "File   file    =    path . getFile (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Template   loader   path    [  \"     +    path )     +     \"  ]    resolved   to   file   path    [  \"  )     +     ( file . getAbsolutePath (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return   new   FileTemplateLoader ( file )  ;", "}    catch    ( Exception   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Cannot   resolve   template   loader   path    [  \"     +    templateLoaderPath )     +     \"  ]    to    [ File ]  :    using   STemplateLoader   as   fallback \"  )  ,    ex )  ;", "}", "return   new   STemplateLoader ( getResourceLoader (  )  ,    templateLoaderPath )  ;", "}", "} else    {", "logger . debug (  \" File   system   access   not   preferred :    using   STemplateLoader \"  )  ;", "return   new   STemplateLoader ( getResourceLoader (  )  ,    templateLoaderPath )  ;", "}", "}", "METHOD_END"], "methodName": ["getTemplateLoaderForPath"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . preferFileSystemAccess ;", "}", "METHOD_END"], "methodName": ["isPreferFileSystemAccess"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   Configuration ( Configuration . DEFAULT _ INCOMPATIBLE _ IMPROVEMENTS )  ;", "}", "METHOD_END"], "methodName": ["newConfiguration"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "configLocation    =    resource ;", "}", "METHOD_END"], "methodName": ["setConfigLocation"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "this . defaultEncoding    =    defaultEncoding ;", "}", "METHOD_END"], "methodName": ["setDefaultEncoding"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "this . freemarkerSettings    =    settings ;", "}", "METHOD_END"], "methodName": ["setFreemarkerSettings"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "this . freemarkerVariables    =    variables ;", "}", "METHOD_END"], "methodName": ["setFreemarkerVariables"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "this . postTemplateLoaders    =    Arrays . asList ( postTemplateLoaders )  ;", "}", "METHOD_END"], "methodName": ["setPostTemplateLoaders"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "this . preTemplateLoaders    =    Arrays . asList ( preTemplateLoaders )  ;", "}", "METHOD_END"], "methodName": ["setPreTemplateLoaders"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "this . preferFileSystemAccess    =    preferFileSystemAccess ;", "}", "METHOD_END"], "methodName": ["setPreferFileSystemAccess"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "this . resourceLoader    =    resourceLoader ;", "}", "METHOD_END"], "methodName": ["setResourceLoader"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "this . templateLoaderPaths    =    new   String [  ]  {    templateLoaderPath    }  ;", "}", "METHOD_END"], "methodName": ["setTemplateLoaderPath"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "this . templateLoaderPaths    =    templateLoaderPaths ;", "}", "METHOD_END"], "methodName": ["setTemplateLoaderPaths"], "fileName": "org.springframework.ui.freemarker.FreeMarkerConfigurationFactory"}, {"methodBody": ["METHOD_START", "{", "StringWriter   result    =    new   StringWriter (  )  ;", "t . process ( model ,    result )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["processTemplateIntoString"], "fileName": "org.springframework.ui.freemarker.FreeMarkerTemplateUtils"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  )  ;", "ac . registerBeanDefinition (  \" capp \"  ,    new   RootBeanDefinition ( CommonAnnotationBeanPostProcessor . class )  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    new   RootBeanDefinition (  . NotNullConstrainedBean . class )  )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getRootCause (  )  . getMessage (  )  . contains (  \" testBean \"  )  )  ;", "assertTrue ( ex . getRootCause (  )  . getMessage (  )  . contains (  \" invalid \"  )  )  ;", "}", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testNotNullConstraint"], "fileName": "org.springframework.validation.beanvalidation2.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "RootBeanDefinition   bvpp    =    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  ;", "bvpp . getPropertyValues (  )  . add (  \" afterInitialization \"  ,    true )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    bvpp )  ;", "ac . registerBeanDefinition (  \" capp \"  ,    new   RootBeanDefinition ( CommonAnnotationBeanPostProcessor . class )  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    new   RootBeanDefinition (  . AfterInitConstraintBean . class )  )  ;", "ac . refresh (  )  ;", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testNotNullConstraintAfterInitialization"], "fileName": "org.springframework.validation.beanvalidation2.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  )  ;", "ac . registerBeanDefinition (  \" capp \"  ,    new   RootBeanDefinition ( CommonAnnotationBeanPostProcessor . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . NotNullConstrainedBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" testBean \"  ,    new   TestBean (  )  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    bd )  ;", "ac . refresh (  )  ;", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testNotNullConstraintSatisfied"], "fileName": "org.springframework.validation.beanvalidation2.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . NotNullConstrainedBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" testBean \"  ,    new   TestBean (  )  )  ;", "bd . getPropertyValues (  )  . add (  \" stringValue \"  ,     \" s \"  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    bd )  ;", "try    {", "ac . refresh (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getRootCause (  )  . getMessage (  )  . contains (  \" stringValue \"  )  )  ;", "assertTrue ( ex . getRootCause (  )  . getMessage (  )  . contains (  \" invalid \"  )  )  ;", "}", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSizeConstraint"], "fileName": "org.springframework.validation.beanvalidation2.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   ac    =    new   GenericApplicationContext (  )  ;", "ac . registerBeanDefinition (  \" bvpp \"  ,    new   RootBeanDefinition ( BeanValidationPostProcessor . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . NotNullConstrainedBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" testBean \"  ,    new   TestBean (  )  )  ;", "bd . getPropertyValues (  )  . add (  \" stringValue \"  ,     \" ss \"  )  ;", "ac . registerBeanDefinition (  \" bean \"  ,    bd )  ;", "ac . refresh (  )  ;", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSizeConstraintSatisfied"], "fileName": "org.springframework.validation.beanvalidation2.BeanValidationPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( proxy . myValidMethod (  \" value \"  ,     5  )  )  ;", "try    {", "assertNotNull ( proxy . myValidMethod (  \" value \"  ,     1  5  )  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "try    {", "assertNotNull ( proxy . myValidMethod ( null ,     5  )  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "try    {", "assertNotNull ( proxy . myValidMethod (  \" value \"  ,     0  )  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "proxy . myValidAsyncMethod (  \" value \"  ,     5  )  ;", "try    {", "proxy . myValidAsyncMethod (  \" value \"  ,     1  5  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "try    {", "proxy . myValidAsyncMethod ( null ,     5  )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "assertEquals (  \" myValue \"  ,    proxy . myGenericMethod (  \" myValue \"  )  )  ;", "try    {", "proxy . myGenericMethod ( null )  ;", "fail (  \" Should   have   thrown   ValidationException \"  )  ;", "}    catch    ( javax   ex )     {", "}", "}", "METHOD_END"], "methodName": ["doTestProxyValidation"], "fileName": "org.springframework.validation.beanvalidation2.MethodValidationTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationConfigApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( MethodValidationTests . LazyMethodValidationConfig . class ,    CustomValidatorBean . class ,    MethodValidationTests . MyValidBean . class )  ;", "ctx . getBean ( MethodValidationTests . MyValidInterface . class )  . myValidMethod (  \" value \"  ,     5  )  ;", "}", "METHOD_END"], "methodName": ["testLazyValidatorForMethodValidation"], "fileName": "org.springframework.validation.beanvalidation2.MethodValidationTests"}, {"methodBody": ["METHOD_START", "{", "MethodValidationTests . MyValidBean   bean    =    new   MethodValidationTests . MyValidBean (  )  ;", "ProxyFactory   proxyFactory    =    new   ProxyFactory ( bean )  ;", "proxyFactory . addAdvice ( new   MethodValidationInterceptor (  )  )  ;", "proxyFactory . addAdvisor ( new   AsyncAnnotationAdvisor (  )  )  ;", "doTestProxyValidation (  (  ( MethodValidationTests . MyValidInterface )     ( proxyFactory . getProxy (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMethodValidationInterceptor"], "fileName": "org.springframework.validation.beanvalidation2.MethodValidationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   ac    =    new   StaticApplicationContext (  )  ;", "ac . registerSingleton (  \" mvpp \"  ,    MethodValidationPostProcessor . class )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" beforeExistingAdvisors \"  ,    false )  ;", "ac . registerSingleton (  \" aapp \"  ,    AsyncAnnotationBeanPostProcessor . class ,    pvs )  ;", "ac . registerSingleton (  \" bean \"  ,     . MyValidBean . class )  ;", "ac . refresh (  )  ;", "doTestProxyValidation ( ac . getBean (  \" bean \"  ,     . MyValidInterface . class )  )  ;", "ac . close (  )  ;", "}", "METHOD_END"], "methodName": ["testMethodValidationPostProcessor"], "fileName": "org.springframework.validation.beanvalidation2.MethodValidationTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . Child   child 1     =    new   SpringValidatorAdapterTests . Child (  )  ;", "child 1  . setName (  \" Child 1  \"  )  ;", "child 1  . setAge ( null )  ;", "child 1  . setParent ( parent )  ;", "SpringValidatorAdapterTests . Child   child 2     =    new   SpringValidatorAdapterTests . Child (  )  ;", "child 2  . setName ( null )  ;", "child 2  . setAge (  1  7  )  ;", "child 2  . setParent ( parent )  ;", "return   Arrays . asList ( child 1  ,    child 2  )  ;", "}", "METHOD_END"], "methodName": ["createChildren"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "messageSource . addMessage (  \" Size \"  ,    Locale . ENGLISH ,     \" Size   of    {  0  }    is   must   be   between    {  2  }    and    {  1  }  \"  )  ;", "messageSource . addMessage (  \" S \"  ,    Locale . ENGLISH ,     \"  {  2  }    must   be   s   value   with    {  1  }  \"  )  ;", "messageSource . addMessage (  \" password \"  ,    Locale . ENGLISH ,     \" Password \"  )  ;", "messageSource . addMessage (  \" confirmPassword \"  ,    Locale . ENGLISH ,     \" Password ( Confirm )  \"  )  ;", "}", "METHOD_END"], "methodName": ["setupSpringValidatorAdapter"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "messageSource . setAlwaysUseMessageFormat ( true )  ;", ". TestBean   testBean    =    new    . TestBean (  )  ;", "testBean . setEmail (  \" test @ example . com \"  )  ;", "testBean . setConfirmEmail (  \" TEST @ EXAMPLE . IO \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( testBean ,     \" testBean \"  )  ;", "validatorAdapter . validate ( testBean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" email \"  )  ,    is (  1  )  )  ;", "assertThat ( errors . getFieldValue (  \" email \"  )  ,    is (  \" test @ example . com \"  )  )  ;", "assertThat ( errors . getFieldErrorCount (  \" confirmEmail \"  )  ,    is (  1  )  )  ;", "assertThat ( messageSource . getMessage ( errors . getFieldError (  \" email \"  )  ,    Locale . ENGLISH )  ,    is (  \" email   must   be   same   value   with   confirmEmail \"  )  )  ;", "assertThat ( messageSource . getMessage ( errors . getFieldError (  \" confirmEmail \"  )  ,    Locale . ENGLISH )  ,    is (  \" Email   required \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyMessageSourceResolvableToStringArgumentValueWithAlwaysUseMessageFormat"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . TestBean   testBean    =    new   SpringValidatorAdapterTests . TestBean (  )  ;", "testBean . setPassword (  \" password \"  )  ;", "testBean . setConfirmPassword (  \" PASSWORD \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( testBean ,     \" testBean \"  )  ;", "validatorAdapter . validate ( testBean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" password \"  )  ,    is (  1  )  )  ;", "assertThat ( errors . getFieldValue (  \" password \"  )  ,    is (  \" password \"  )  )  ;", "assertThat ( messageSource . getMessage ( errors . getFieldError (  \" password \"  )  ,    Locale . ENGLISH )  ,    is (  \" Password   must   be   same   value   with   Password ( Confirm )  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyMessageSourceResolvableToStringArgumentValueWithResolvedLogicalFieldName"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . TestBean   testBean    =    new   SpringValidatorAdapterTests . TestBean (  )  ;", "testBean . setEmail (  \" test @ example . com \"  )  ;", "testBean . setConfirmEmail (  \" TEST @ EXAMPLE . IO \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( testBean ,     \" testBean \"  )  ;", "validatorAdapter . validate ( testBean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" email \"  )  ,    is (  1  )  )  ;", "assertThat ( errors . getFieldValue (  \" email \"  )  ,    is (  \" test @ example . com \"  )  )  ;", "assertThat ( errors . getFieldErrorCount (  \" confirmEmail \"  )  ,    is (  1  )  )  ;", "assertThat ( messageSource . getMessage ( errors . getFieldError (  \" email \"  )  ,    Locale . ENGLISH )  ,    is (  \" email   must   be   same   value   with   confirmEmail \"  )  )  ;", "assertThat ( messageSource . getMessage ( errors . getFieldError (  \" confirmEmail \"  )  ,    Locale . ENGLISH )  ,    is (  \" Email   required \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyMessageSourceResolvableToStringArgumentValueWithUnresolvedLogicalFieldName"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . BeanWithListElementConstraint   bean    =    new   SpringValidatorAdapterTests . BeanWithListElementConstraint (  )  ;", "bean . setProperty ( Arrays . asList (  \" no \"  ,     \" element \"  ,     \" can \"  ,     \" be \"  ,    null )  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( bean ,     \" bean \"  )  ;", "validatorAdapter . validate ( bean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" property [  4  ]  \"  )  ,    is (  1  )  )  ;", "assertNull ( errors . getFieldValue (  \" property [  4  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testListElementConstraint"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    property    =    new   HashMap <  >  (  )  ;", "property . put ( null ,    null )  ;", ". BeanWithMapEntryConstraint   bean    =    new    . BeanWithMapEntryConstraint (  )  ;", "bean . setProperty ( property )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( bean ,     \" bean \"  )  ;", "validatorAdapter . validate ( bean ,    errors )  ;", "assertTrue ( errors . hasFieldErrors (  \" property [  ]  \"  )  )  ;", "assertNull ( errors . getFieldValue (  \" property [  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapEntryConstraint"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    property    =    new   HashMap <  >  (  )  ;", "property . put (  \" no   value   can   be \"  ,    null )  ;", ". BeanWithMapEntryConstraint   bean    =    new    . BeanWithMapEntryConstraint (  )  ;", "bean . setProperty ( property )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( bean ,     \" bean \"  )  ;", "validatorAdapter . validate ( bean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" property [ no   value   can   be ]  \"  )  ,    is (  1  )  )  ;", "assertNull ( errors . getFieldValue (  \" property [ no   value   can   be ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapValueConstraint"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . TestBean   testBean    =    new   SpringValidatorAdapterTests . TestBean (  )  ;", "testBean . setPassword (  \" pass \"  )  ;", "testBean . setConfirmPassword (  \" pass \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( testBean ,     \" testBean \"  )  ;", "validatorAdapter . validate ( testBean ,    errors )  ;", "assertThat ( errors . getFieldErrorCount (  \" password \"  )  ,    is (  1  )  )  ;", "assertThat ( errors . getFieldValue (  \" password \"  )  ,    is (  \" pass \"  )  )  ;", "assertThat ( messageSource . getMessage ( errors . getFieldError (  \" password \"  )  ,    Locale . ENGLISH )  ,    is (  \" Size   of   Password   is   must   be   between    8    and    1  2  8  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoStringArgumentValue"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Validator   nativeValidator    =    validatorAdapter . unwrap ( Validator . class )  ;", "assertSame ( this . nativeValidator ,    nativeValidator )  ;", "}", "METHOD_END"], "methodName": ["testUnwrap"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . Parent   parent    =    new   SpringValidatorAdapterTests . Parent (  )  ;", "parent . setName (  \" Parent   whit   list \"  )  ;", "parent . getChildList (  )  . addAll ( createChildren ( parent )  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( parent ,     \" parent \"  )  ;", "validatorAdapter . validate ( parent ,    errors )  ;", "assertTrue (  (  ( errors . getErrorCount (  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithList"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "SpringValidatorAdapterTests . Parent   parent    =    new   SpringValidatorAdapterTests . Parent (  )  ;", "parent . setName (  \" Parent   whith   set \"  )  ;", "parent . getChildSet (  )  . addAll ( createChildren ( parent )  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( parent ,     \" parent \"  )  ;", "validatorAdapter . validate ( parent ,    errors )  ;", "assertTrue (  (  ( errors . getErrorCount (  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithSet"], "fileName": "org.springframework.validation.beanvalidation2.SpringValidatorAdapterTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". MainBean   mainBean    =    new    . MainBean (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( mainBean ,     \" mainBean \"  )  ;", "validator . validate ( mainBean ,    errors )  ;", "Object   rejected    =    errors . getFieldValue (  \" inner . value \"  )  ;", "assertNull ( rejected )  ;", "}", "METHOD_END"], "methodName": ["testInnerBeanValidation"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ListContainer   listContainer    =    new    . ListContainer (  )  ;", "listContainer . addString (  \" A \"  )  ;", "listContainer . addString (  \" X \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( listContainer ,     \" listContainer \"  )  ;", "errors . initConversion ( new   DefaultConversionService (  )  )  ;", "validator . validate ( listContainer ,    errors )  ;", "FieldError   fieldError    =    errors . getFieldError (  \" list [  1  ]  \"  )  ;", "assertEquals (  \" X \"  ,    errors . getFieldValue (  \" list [  1  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testListValidation"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "Set < ConstraintViolation <  . ValidPerson >  >    result    =    validator . validate ( person )  ;", "assertEquals (  2  ,    result . size (  )  )  ;", "for    ( ConstraintViolation <  . ValidPerson >    cv    :    result )     {", "String   path    =    cv . getPropertyPath (  )  . toString (  )  ;", "if    (  (  \" name \"  . equals ( path )  )     |  |     (  \" address . street \"  . equals ( path )  )  )     {", "assertTrue (  (  ( cv . getConstraintDescriptor (  )  . getAnnotation (  )  )    instanceof   NotNull )  )  ;", "} else    {", "fail (  (  (  \" Invalid   constraint   violation   with   path    '  \"     +    path )     +     \"  '  \"  )  )  ;", "}", "}", "Validator   nativeValidator    =    validator . unwrap ( Validator . class )  ;", "assertTrue ( nativeValidator . getClass (  )  . getName (  )  . startsWith (  \" hibernate \"  )  )  ;", "assertTrue (  (  ( validator . unwrap ( ValidatorFactory . class )  )    instanceof   HibernateValidatorFactory )  )  ;", "assertTrue (  (  ( validator . unwrap ( HibernateValidatorFactory . class )  )    instanceof   HibernateValidatorFactory )  )  ;", "validator . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleValidation"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . setName (  \" Juergen \"  )  ;", "person . getAddress (  )  . setStreet (  \" Juergen ' s   Street \"  )  ;", "Set < ConstraintViolation <  . ValidPerson >  >    result    =    validator . validate ( person )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "Iterator < ConstraintViolation <  . ValidPerson >  >    iterator    =    result . iterator (  )  ;", "ConstraintViolation <  ?  >    cv    =    iterator . next (  )  ;", "assertEquals (  \"  \"  ,    cv . getPropertyPath (  )  . toString (  )  )  ;", "assertTrue (  (  ( cv . getConstraintDescriptor (  )  . getAnnotation (  )  )    instanceof    . NameAddressValid )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleValidationWithClassLevel"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . setProviderClass ( HibernateValidator . class )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "Set < ConstraintViolation <  . ValidPerson >  >    result    =    validator . validate ( person )  ;", "assertEquals (  2  ,    result . size (  )  )  ;", "for    ( ConstraintViolation <  . ValidPerson >    cv    :    result )     {", "String   path    =    cv . getPropertyPath (  )  . toString (  )  ;", "if    (  (  \" name \"  . equals ( path )  )     |  |     (  \" address . street \"  . equals ( path )  )  )     {", "assertTrue (  (  ( cv . getConstraintDescriptor (  )  . getAnnotation (  )  )    instanceof   NotNull )  )  ;", "} else    {", "fail (  (  (  \" Invalid   constraint   violation   with   path    '  \"     +    path )     +     \"  '  \"  )  )  ;", "}", "}", "Validator   nativeValidator    =    validator . unwrap ( Validator . class )  ;", "assertTrue ( nativeValidator . getClass (  )  . getName (  )  . startsWith (  \" hibernate \"  )  )  ;", "assertTrue (  (  ( validator . unwrap ( ValidatorFactory . class )  )    instanceof   HibernateValidatorFactory )  )  ;", "assertTrue (  (  ( validator . unwrap ( HibernateValidatorFactory . class )  )    instanceof   HibernateValidatorFactory )  )  ;", "validator . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleValidationWithCustomProvider"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  2  ,    result . getErrorCount (  )  )  ;", "FieldError   fieldError    =    result . getFieldError (  \" name \"  )  ;", "assertEquals (  \" name \"  ,    fieldError . getField (  )  )  ;", "List < String >    errorCodes    =    Arrays . asList ( fieldError . getCodes (  )  )  ;", "assertEquals (  4  ,    errorCodes . size (  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . person . name \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . name \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . String \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull \"  )  )  ;", "fieldError    =    result . getFieldError (  \" address . street \"  )  ;", "assertEquals (  \" address . street \"  ,    fieldError . getField (  )  )  ;", "errorCodes    =    Arrays . asList ( fieldError . getCodes (  )  )  ;", "assertEquals (  5  ,    errorCodes . size (  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . person . address . street \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . address . street \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . street \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull . String \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NotNull \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidation"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . setName (  \" Phil \"  )  ;", "person . getAddress (  )  . setStreet (  \" Phil ' s   Street \"  )  ;", "BeanPropertyBindingResult   errors    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    errors )  ;", "assertEquals (  1  ,    errors . getErrorCount (  )  )  ;", "assertThat (  \" Field / Value   type   mismatch \"  ,    errors . getFieldError (  \" address \"  )  . getRejectedValue (  )  ,    instanceOf (  . ValidAddress . class )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationFieldType"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   ctx    =    new   AnnotationConfigApplicationContext ( LocalValidatorFactoryBean . class )  ;", "LocalValidatorFactoryBean   validator    =    ctx . getBean ( LocalValidatorFactoryBean . class )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . expectsAutowiredValidator    =    true ;", "person . setName (  \" Juergen \"  )  ;", "person . getAddress (  )  . setStreet (  \" Juergen ' s   Street \"  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  1  ,    result . getErrorCount (  )  )  ;", "ObjectError   globalError    =    result . getGlobalError (  )  ;", "List < String >    errorCodes    =    Arrays . asList ( globalError . getCodes (  )  )  ;", "assertEquals (  2  ,    errorCodes . size (  )  )  ;", "assertTrue ( errorCodes . contains (  \" NameAddressValid . person \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NameAddressValid \"  )  )  ;", "ctx . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationWithAutowiredValidator"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . setName (  \" Juergen \"  )  ;", "person . getAddress (  )  . setStreet (  \" Juergen ' s   Street \"  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  1  ,    result . getErrorCount (  )  )  ;", "ObjectError   globalError    =    result . getGlobalError (  )  ;", "List < String >    errorCodes    =    Arrays . asList ( globalError . getCodes (  )  )  ;", "assertEquals (  2  ,    errorCodes . size (  )  )  ;", "assertTrue ( errorCodes . contains (  \" NameAddressValid . person \"  )  )  ;", "assertTrue ( errorCodes . contains (  \" NameAddressValid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationWithClassLevel"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . getAddressList (  )  . add ( new    . ValidAddress (  )  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  3  ,    result . getErrorCount (  )  )  ;", "FieldError   fieldError    =    result . getFieldError (  \" name \"  )  ;", "assertEquals (  \" name \"  ,    fieldError . getField (  )  )  ;", "fieldError    =    result . getFieldError (  \" address . street \"  )  ;", "assertEquals (  \" address . street \"  ,    fieldError . getField (  )  )  ;", "fieldError    =    result . getFieldError (  \" addressList [  0  ]  . street \"  )  ;", "assertEquals (  \" addressList [  0  ]  . street \"  ,    fieldError . getField (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationWithErrorInListElement"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". ValidPerson   person    =    new    . ValidPerson (  )  ;", "person . getAddressSet (  )  . add ( new    . ValidAddress (  )  )  ;", "BeanPropertyBindingResult   result    =    new   BeanPropertyBindingResult ( person ,     \" person \"  )  ;", "validator . validate ( person ,    result )  ;", "assertEquals (  3  ,    result . getErrorCount (  )  )  ;", "FieldError   fieldError    =    result . getFieldError (  \" name \"  )  ;", "assertEquals (  \" name \"  ,    fieldError . getField (  )  )  ;", "fieldError    =    result . getFieldError (  \" address . street \"  )  ;", "assertEquals (  \" address . street \"  ,    fieldError . getField (  )  )  ;", "fieldError    =    result . getFieldError (  \" addressSet [  ]  . street \"  )  ;", "assertEquals (  \" addressSet [  ]  . street \"  ,    fieldError . getField (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringValidationWithErrorInSetElement"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LocalValidatorFactoryBean   validator    =    new   LocalValidatorFactoryBean (  )  ;", "validator . afterPropertiesSet (  )  ;", ". MainBeanWithOptional   mainBean    =    new    . MainBeanWithOptional (  )  ;", "Errors   errors    =    new   BeanPropertyBindingResult ( mainBean ,     \" mainBean \"  )  ;", "validator . validate ( mainBean ,    errors )  ;", "Object   rejected    =    errors . getFieldValue (  \" inner . value \"  )  ;", "assertNull ( rejected )  ;", "}", "METHOD_END"], "methodName": ["testValidationWithOptionalField"], "fileName": "org.springframework.validation.beanvalidation2.ValidatorFactoryTests"}]