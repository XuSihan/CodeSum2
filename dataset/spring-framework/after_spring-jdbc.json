[{"methodBody": ["METHOD_START", "{", "return    (  ( SQLException )     ( getCause (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSQLException"], "fileName": "org.springframework.jdbc.BadSqlGrammarException"}, {"methodBody": ["METHOD_START", "{", "return   this . sql ;", "}", "METHOD_END"], "methodName": ["getSql"], "fileName": "org.springframework.jdbc.BadSqlGrammarException"}, {"methodBody": ["METHOD_START", "{", "return   forename ;", "}", "METHOD_END"], "methodName": ["getForename"], "fileName": "org.springframework.jdbc.Customer"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.jdbc.Customer"}, {"methodBody": ["METHOD_START", "{", "this . forename    =    forename ;", "}", "METHOD_END"], "methodName": ["setForename"], "fileName": "org.springframework.jdbc.Customer"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.springframework.jdbc.Customer"}, {"methodBody": ["METHOD_START", "{", "return   this . actualCount ;", "}", "METHOD_END"], "methodName": ["getActualCount"], "fileName": "org.springframework.jdbc.IncorrectResultSetColumnCountException"}, {"methodBody": ["METHOD_START", "{", "return   this . expectedCount ;", "}", "METHOD_END"], "methodName": ["getExpectedCount"], "fileName": "org.springframework.jdbc.IncorrectResultSetColumnCountException"}, {"methodBody": ["METHOD_START", "{", "return    (  ( SQLException )     ( getCause (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSQLException"], "fileName": "org.springframework.jdbc.InvalidResultSetAccessException"}, {"methodBody": ["METHOD_START", "{", "return   this . sql ;", "}", "METHOD_END"], "methodName": ["getSql"], "fileName": "org.springframework.jdbc.InvalidResultSetAccessException"}, {"methodBody": ["METHOD_START", "{", "return   this . actual ;", "}", "METHOD_END"], "methodName": ["getActualRowsAffected"], "fileName": "org.springframework.jdbc.JdbcUpdateAffectedIncorrectNumberOfRowsException"}, {"methodBody": ["METHOD_START", "{", "return   this . expected ;", "}", "METHOD_END"], "methodName": ["getExpectedRowsAffected"], "fileName": "org.springframework.jdbc.JdbcUpdateAffectedIncorrectNumberOfRowsException"}, {"methodBody": ["METHOD_START", "{", "return    (  ( SQLWarning )     ( getCause (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["SQLWarning"], "fileName": "org.springframework.jdbc.SQLWarningException"}, {"methodBody": ["METHOD_START", "{", "return    (  ( SQLException )     ( getCause (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSQLException"], "fileName": "org.springframework.jdbc.UncategorizedSQLException"}, {"methodBody": ["METHOD_START", "{", "return   this . sql ;", "}", "METHOD_END"], "methodName": ["getSql"], "fileName": "org.springframework.jdbc.UncategorizedSQLException"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . genericBeanDefinition ( CompositeDatabasePopulator . class )  ;", "boolean   ignoreFailedDrops    =    element . getAttribute (  \" ignore - failures \"  )  . equals (  \" DROPS \"  )  ;", "boolean   continueOnError    =    element . getAttribute (  \" ignore - failures \"  )  . equals (  \" ALL \"  )  ;", "ManagedList < BeanMetadataElement >    delegates    =    new   ManagedList (  )  ;", "for    ( Element   scriptElement    :    scripts )     {", "String   executionAttr    =    scriptElement . getAttribute (  \" execution \"  )  ;", "if    (  !  ( StringUtils . hasText ( executionAttr )  )  )     {", "executionAttr    =     \" INIT \"  ;", "}", "if    (  !  ( execution . equals ( executionAttr )  )  )     {", "continue ;", "}", "BeanDefinitionBuilder   delegate    =    BeanDefinitionBuilder . genericBeanDefinition ( ResourceDatabasePopulator . class )  ;", "delegate . addPropertyValue (  \" ignoreFailedDrops \"  ,    ignoreFailedDrops )  ;", "delegate . addPropertyValue (  \" continueOnError \"  ,    continueOnError )  ;", "BeanDefinitionBuilder   resourcesFactory    =    BeanDefinitionBuilder . genericBeanDefinition ( SortedResourcesFactoryBean . class )  ;", "resourcesFactory . addConstructorArgValue ( new   TypedStringValue ( scriptElement . getAttribute (  \" location \"  )  )  )  ;", "delegate . addPropertyValue (  \" scripts \"  ,    resourcesFactory . getBeanDefinition (  )  )  ;", "if    ( StringUtils . hasLength ( scriptElement . getAttribute (  \" encoding \"  )  )  )     {", "delegate . addPropertyValue (  \" sqlScriptEncoding \"  ,    new   TypedStringValue ( scriptElement . getAttribute (  \" encoding \"  )  )  )  ;", "}", "String   separator    =     . getSeparator ( element ,    scriptElement )  ;", "if    ( separator    !  =    null )     {", "delegate . addPropertyValue (  \" separator \"  ,    new   TypedStringValue ( separator )  )  ;", "}", "delegates . add ( delegate . getBeanDefinition (  )  )  ;", "}", "builder . addPropertyValue (  \" populators \"  ,    delegates )  ;", "return   builder . getBeanDefinition (  )  ;", "}", "METHOD_END"], "methodName": ["createDatabasePopulator"], "fileName": "org.springframework.jdbc.config.DatabasePopulatorConfigUtils"}, {"methodBody": ["METHOD_START", "{", "String   scriptSeparator    =    scriptElement . getAttribute (  \" separator \"  )  ;", "if    ( Strin . hasLength ( scriptSeparator )  )     {", "return   scriptSeparator ;", "}", "String   elementSeparator    =    element . getAttribute (  \" separator \"  )  ;", "if    ( Strin . hasLength ( elementSeparator )  )     {", "return   elementSeparator ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSeparator"], "fileName": "org.springframework.jdbc.config.DatabasePopulatorConfigUtils"}, {"methodBody": ["METHOD_START", "{", "List < Element >    scripts    =    DomUtils . getChildElementsByTagName ( element ,     \" script \"  )  ;", "if    (  !  ( scripts . isEmpty (  )  )  )     {", "builder . addPropertyValue (  \" databasePopulator \"  ,     . createDatabasePopulator ( element ,    scripts ,     \" INIT \"  )  )  ;", "builder . addPropertyValue (  \" databaseCleaner \"  ,     . createDatabasePopulator ( element ,    scripts ,     \" DESTROY \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setDatabasePopulator"], "fileName": "org.springframework.jdbc.config.DatabasePopulatorConfigUtils"}, {"methodBody": ["METHOD_START", "{", "String   name    =    element . getAttribute ( EmbeddedDatabaseBeanDefinitionParser . DB _ NAME _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( name )  )  )     {", "name    =    element . getAttribute ( ID _ ATTRIBUTE )  ;", "}", "if    ( StringUtils . hasText ( name )  )     {", "builder . addPropertyValue (  \" databaseName \"  ,    name )  ;", "}", "}", "METHOD_END"], "methodName": ["setDatabaseName"], "fileName": "org.springframework.jdbc.config.EmbeddedDatabaseBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String   type    =    element . getAttribute (  \" type \"  )  ;", "if    ( StringUtils . hasText ( type )  )     {", "builder . addPropertyValue (  \" dType \"  ,    type )  ;", "}", "}", "METHOD_END"], "methodName": ["setDatabaseType"], "fileName": "org.springframework.jdbc.config.EmbeddedDatabaseBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String   generateName    =    element . getAttribute ( EmbeddedDatabaseBeanDefinitionParser . GENERATE _ NAME _ ATTRIBUTE )  ;", "if    ( StringUtils . hasText ( generateName )  )     {", "builder . addPropertyValue (  \" generateUniqueDatabaseName \"  ,    generateName )  ;", "}", "}", "METHOD_END"], "methodName": ["setGenerateUniqueDatabaseNameFlag"], "fileName": "org.springframework.jdbc.config.EmbeddedDatabaseBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( enabled )     !  =    null )     {", "System . setProperty (  \" ENABLED \"  ,    enabled )  ;", "} else    {", "System . clearProperty (  \" ENABLED \"  )  ;", "}", "if    (  ( text )     !  =    null )     {", "text . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["after"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "JdbcTemplate   jt    =    new   JdbcTemplate ( dataSource )  ;", "assertEquals (  1  ,    jt . queryForObject (  \" select   count (  *  )    from   T _ TEST \"  ,    er . class )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCorrectSetup"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "enabled    =    System . setProperty (  \" ENABLED \"  ,     \" true \"  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / jdbc / config / jdbc - initialize - cache - config . xml \"  )  ;", "assertCorrectSetup ( context . getBean (  \" dataSource \"  ,    DataSource . class )  )  ;", ". CacheData   cache    =    context . getBean (  . CacheData . class )  ;", "assertEquals (  1  ,    cache . getCachedData (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCacheInitialization"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / jdbc / config / jdbc - initialize - config . xml \"  )  ;", "assertCorrectSetup ( context . getBean (  \" dataSource \"  ,    DataSource . class )  )  ;", "}", "METHOD_END"], "methodName": ["testCreateEmbeddedDatabase"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" ENABLED \"  ,     \" false \"  )  ;", "context    =    new   ClassPathXmlApplicationContext (  \" org /  / jdbc / config / jdbc - initialize - config . xml \"  )  ;", "assertCorrectSetup ( context . getBean (  \" dataSource \"  ,    DataSource . class )  )  ;", "}", "METHOD_END"], "methodName": ["testDisableCreateEmbeddedDatabase"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / jdbc / config / jdbc - initialize - fail - config . xml \"  )  ;", "assertCorrectSetup ( context . getBean (  \" dataSource \"  ,    DataSource . class )  )  ;", "}", "METHOD_END"], "methodName": ["testIgnoreFailedDrops"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / jdbc / config / jdbc - initialize - expression - config . xml \"  )  ;", "DataSource   dataSource    =    context . getBean (  \" dataSource \"  ,    DataSource . class )  ;", "assertCorrectSetup ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["testScriptNameWithExpressions"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / jdbc / config / jdbc - initialize - pattern - config . xml \"  )  ;", "DataSource   dataSource    =    context . getBean (  \" dataSource \"  ,    DataSource . class )  ;", "assertCorrectSetup ( dataSource )  ;", "JdbcTemplate   t    =    new   JdbcTemplate ( dataSource )  ;", "assertEquals (  \" Dave \"  ,    t . queryForObject (  \" select   name   from   T _ TEST \"  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testScriptNameWithPattern"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "context    =    new   ClassPathXmlApplicationContext (  \" org / springframework / jdbc / config / jdbc - initialize - placeholder - config . xml \"  )  ;", "DataSource   dataSource    =    context . getBean (  \" dataSource \"  ,    DataSource . class )  ;", "assertCorrectSetup ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["testScriptNameWithPlaceholder"], "fileName": "org.springframework.jdbc.config.InitializeDatabaseIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   bean    =    factory . getBeanDefinition ( expected )  ;", "PropertyValue   value    =    bean . getPropertyValues (  )  . getPropertyValue ( propertyName )  ;", "assertThat ( value ,    is ( notNullValue (  )  )  )  ;", "assertThat ( value . getValue (  )  . toString (  )  ,    is ( expected )  )  ;", "}", "METHOD_END"], "methodName": ["assertBeanPropertyValueOf"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertCorrectSetupAndCloseContext ( file ,     1  ,    dataSources )  ;", "}", "METHOD_END"], "methodName": ["assertCorrectSetup"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    context ( file )  ;", "try    {", "for    ( String   dataSourceName    :    dataSources )     {", "DataSource   dataSource    =    context . getBean ( dataSourceName ,    DataSource . class )  ;", "assertNumRowsInTestTable ( new   JdbcTemplate ( dataSource )  ,    count )  ;", "assertTrue (  ( dataSource   instanceof   AbstractDriverBasedDataSource )  )  ;", "AbstractDriverBasedDataSource   adbDataSource    =     (  ( AbstractDriverBasedDataSource )     ( dataSource )  )  ;", "assertThat ( adbDataSource . getUrl (  )  ,    containsString ( dataSourceName )  )  ;", "}", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertCorrectSetupAndCloseContext"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableApplicationContext   context    =    context ( file )  ;", "try    {", "DataSource   dataSource    =    context . getBean ( DataSource . class )  ;", "assertNumRowsInTestTable ( new   JdbcTemplate ( dataSource )  ,     1  )  ;", "assertTrue (  ( dataSource   instanceof   AbstractDriverBasedDataSource )  )  ;", "AbstractDriverBasedDataSource   adbDataSource    =     (  ( AbstractDriverBasedDataSource )     ( dataSource )  )  ;", "assertTrue ( urlPredicate . test ( adbDataSource . getUrl (  )  )  )  ;", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertCorrectSetupForSingleDataSource"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( count ,    template . queryForObject (  \" select   count (  *  )    from   T _ TEST \"  ,    Integer . class )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumRowsInTestTable"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathXmlApplicationContext ( file ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["context"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    context (  \" jdbc - destroy - config . xml \"  )  ;", "try    {", "DataSource   dataSource    =    context . getBean ( DataSource . class )  ;", "JdbcTemplate   template    =    new   JdbcTemplate ( dataSource )  ;", "assertNumRowsInTestTable ( template ,     1  )  ;", "context . getBean ( DataSourceInitializer . class )  . destroy (  )  ;", "expected . expect ( BadSqlGrammarException . class )  ;", "assertNumRowsInTestTable ( template ,     1  )  ;", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createAndDestroy"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    context (  \" jdbc - destroy - nested - config - h 2  . xml \"  )  ;", "try    {", "DataSource   dataSource    =    context . getBean ( DataSource . class )  ;", "JdbcTemplate   template    =    new   JdbcTemplate ( dataSource )  ;", "assertNumRowsInTestTable ( template ,     1  )  ;", "context . getBean ( EmbeddedDatabaseFactoryBean . class )  . destroy (  )  ;", "expected . expect ( BadSqlGrammarException . class )  ;", "assertNumRowsInTestTable ( template ,     1  )  ;", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createAndDestroyNestedWithH2"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ClassPathXmlApplicationContext   context    =    context (  \" jdbc - destroy - nested - config . xml \"  )  ;", "try    {", "DataSource   dataSource    =    context . getBean ( DataSource . class )  ;", "JdbcTemplate   template    =    new   JdbcTemplate ( dataSource )  ;", "assertNumRowsInTestTable ( template ,     1  )  ;", "context . getBean ( EmbeddedDatabaseFactoryBean . class )  . destroy (  )  ;", "expected . expect ( BadSqlGrammarException . class )  ;", "assertNumRowsInTestTable ( template ,     1  )  ;", "}    finally    {", "context . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createAndDestroyNestedWithHsql"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "assertCorrectSetup (  \" jdbc - xml \"  ,     \" dataSource \"  ,     \" h 2 DataSource \"  ,     \" derbyDataSource \"  )  ;", "}", "METHOD_END"], "methodName": ["createEmbeddedDatabase"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "assertCorrectSetup (  \" jdbc - xml \"  ,     \" derbyDataSource \"  )  ;", "}", "METHOD_END"], "methodName": ["createEmbeddedDatabaseAgain"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertCorrectSetupForSingleDataSource (  \" jdbc - config - db - name - default - and - anonymous - datasource . xml \"  ,     (    url )     -  >    url . endsWith ( EmbeddedDatabaseFactory . DEFAULT _ DATABASE _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["createWithAnonymousDataSourceAndDefaultDatabaseName"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertCorrectSetupAndCloseContext (  \" jdbc - initialize - endings - config . xml \"  ,     2  ,     \" dataSource \"  )  ;", "}", "METHOD_END"], "methodName": ["createWithEndings"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertCorrectSetupAndCloseContext (  \" jdbc - initialize - endings - nested - config . xml \"  ,     2  ,     \" dataSource \"  )  ;", "}", "METHOD_END"], "methodName": ["createWithEndingsNested"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertCorrectSetupForSingleDataSource (  \" jdbc - config - db - name - explicit . xml \"  ,     (    url )     -  >    url . endsWith (  \" customDbName \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createWithExplicitDatabaseName"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "Predicate < String >    urlPredicate    =     (    url )     -  >    url . startsWith (  \" jdbc : hsqldb : mem :  \"  )  ;", "urlPredicate . and (  (    url )     -  >     !  ( url . endsWith (  \" dataSource \"  )  )  )  ;", "urlPredicate . and (  (    url )     -  >     !  ( url . endsWith (  \" shouldBeOverriddenByGeneratedName \"  )  )  )  ;", "assertCorrectSetupForSingleDataSource (  \" jdbc -  - db - name - generated . xml \"  ,    urlPredicate )  ;", "}", "METHOD_END"], "methodName": ["createWithGeneratedDatabaseName"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertCorrectSetupForSingleDataSource (  \" jdbc - config - db - name - implicit . xml \"  ,     (    url )     -  >    url . endsWith (  \" dataSource \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createWithImplicitDatabaseName"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertCorrectSetup (  \" jdbc - config - pattern . xml \"  ,     \" dataSource \"  )  ;", "}", "METHOD_END"], "methodName": ["createWithResourcePattern"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertCorrectSetupAndCloseContext (  \" jdbc - config - custom - separator . xml \"  ,     2  ,     \" dataSource \"  )  ;", "}", "METHOD_END"], "methodName": ["embeddedWithCustomSeparator"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertCorrectSetupAndCloseContext (  \" jdbc - initialize - custom - separator . xml \"  ,     2  ,     \" dataSource \"  )  ;", "}", "METHOD_END"], "methodName": ["initializeWithCustomSeparator"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions ( new   ClassPathResource (  \" jdbc - config - multiple - datasources . xml \"  ,    getClass (  )  )  )  ;", "assertBeanPropertyValueOf (  \" databaseName \"  ,     \" firstDataSource \"  ,    factory )  ;", "assertBeanPropertyValueOf (  \" databaseName \"  ,     \" secondDataSource \"  ,    factory )  ;", "}", "METHOD_END"], "methodName": ["multipleDataSourcesHaveDifferentDatabaseNames"], "fileName": "org.springframework.jdbc.config.JdbcNamespaceIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Bubba \"  ,    bean . getName (  )  )  ;", "assertEquals (  2  2 L ,    bean . getAge (  )  )  ;", "assertEquals ( new   Date (  1  2  2  1  2  2  2 L )  ,    bean . getBirth _ date (  )  )  ;", "assertEquals ( new   BigDecimal (  \"  1  2  3  4  .  5  6  \"  )  ,    bean . getBalance (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPerson"], "fileName": "org.springframework.jdbc.core.AbstractRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Bubba \"  ,    bean . getLastName (  )  )  ;", "assertEquals (  2  2 L ,    bean . getAge (  )  )  ;", "assertEquals ( new   Date (  1  2  2  1  2  2  2 L )  . toLocalDate (  )  ,    bean . getBirthDate (  )  )  ;", "assertEquals ( new   BigDecimal (  \"  1  2  3  4  .  5  6  \"  )  ,    bean . getBalance (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPerson"], "fileName": "org.springframework.jdbc.core.AbstractRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Bubba \"  ,    bean . getName (  )  )  ;", "assertEquals (  2  2 L ,    bean . getAge (  )  )  ;", "assertEquals ( new   Date (  1  2  2  1  2  2  2 L )  ,    bean . getBirth _ date (  )  )  ;", "assertEquals ( new   BigDecimal (  \"  1  2  3  4  .  5  6  \"  )  ,    bean . getBalance (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPerson"], "fileName": "org.springframework.jdbc.core.AbstractRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Bubba \"  ,    bean . getLastName (  )  )  ;", "assertEquals (  2  2 L ,    bean . getAge (  )  )  ;", "assertEquals ( new   Timestamp (  1  2  2  1  2  2  2 L )  . toLocalDateTime (  )  ,    bean . getBirthDate (  )  )  ;", "assertEquals ( new   BigDecimal (  \"  1  2  3  4  .  5  6  \"  )  ,    bean . getBalance (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyPerson"], "fileName": "org.springframework.jdbc.core.AbstractRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "if    ( argValue   instanceof   SqlParameterValue )     {", "SqlParameterValue   paramValue    =     (  ( SqlParameterValue )     ( argValue )  )  ;", "CreatorUtils . setParameterValue ( ps ,    parameterPosition ,    paramValue ,    paramValue . getValue (  )  )  ;", "} else    {", "CreatorUtils . setParameterValue ( ps ,    parameterPosition ,    SqlTypeValue . TYPE _ UNKNOWN ,    argValue )  ;", "}", "}", "METHOD_END"], "methodName": ["doSetValue"], "fileName": "org.springframework.jdbc.core.ArgumentPreparedStatementSetter"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . setParameterValue ( ps ,    parameterPosition ,    argType ,    argValue )  ;", "}", "METHOD_END"], "methodName": ["doSetValue"], "fileName": "org.springframework.jdbc.core.ArgumentTypePreparedStatementSetter"}, {"methodBody": ["METHOD_START", "{", "return   jdbcOperations . batchUpdate ( sql ,    new   BatchPreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps ,    int   i )    throws   SQLException    {", "Object [  ]    values    =    batchValues . get ( i )  ;", ". setStatementParameters ( values ,    ps ,    columnTypes )  ;", "}", "@ Override", "public   int   getBatchSize (  )     {", "return   batchValues . size (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["executeBatchUpdate"], "fileName": "org.springframework.jdbc.core.BatchUpdateUtils"}, {"methodBody": ["METHOD_START", "{", "int   colIndex    =     0  ;", "for    ( Object   value    :    values )     {", "colIndex +  +  ;", "if    ( value   instanceof   SqlParameterValue )     {", "SqlParameterValue   paramValue    =     (  ( SqlParameterValue )     ( value )  )  ;", "StatementCreator . setParameterValue ( ps ,    colIndex ,    paramValue ,    paramValue . getValue (  )  )  ;", "} else    {", "int   colType ;", "if    (  ( columnTypes    =  =    null )     |  |     (  ( columnTypes . length )     <    colIndex )  )     {", "colType    =    SqlTypeValue . TYPE _ UNKNOWN ;", "} else    {", "colType    =    columnTypes [  ( colIndex    -     1  )  ]  ;", "}", "StatementCreator . setParameterValue ( ps ,    colIndex ,    colType ,    value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setStatementParameters"], "fileName": "org.springframework.jdbc.core.BatchUpdateUtils"}, {"methodBody": ["METHOD_START", "{", "return   JdbcUtils . getResultSetValue ( rs ,    index ,    pd . getPropertyType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getColumnValue"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   this . conversionService ;", "}", "METHOD_END"], "methodName": ["getConversionService"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   this . mappedClass ;", "}", "METHOD_END"], "methodName": ["getMappedClass"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "ConversionService   cs    =    getConversionService (  )  ;", "if    ( cs    !  =    null )     {", "bw . setConversionService ( cs )  ;", "}", "}", "METHOD_END"], "methodName": ["initBeanWrapper"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "this . mappedClass    =    mappedClass ;", "this . mappedFields    =    new   HashMap <  >  (  )  ;", "this . mappedProperties    =    new   HashSet <  >  (  )  ;", "Descriptor [  ]    pds    =    BeanUtils . getDescriptors ( mappedClass )  ;", "for    ( Descriptor   pd    :    pds )     {", "if    (  ( pd . getWriteMethod (  )  )     !  =    null )     {", "this . mappedFields . put ( lowerCaseName ( pd . getName (  )  )  ,    pd )  ;", "String   underscoredName    =    underscoreName ( pd . getName (  )  )  ;", "if    (  !  ( lowerCaseName ( pd . getName (  )  )  . equals ( underscoredName )  )  )     {", "this . mappedFields . put ( underscoredName ,    pd )  ;", "}", "this . mappedProperties . add ( pd . getName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   this . checkFullyPopulated ;", "}", "METHOD_END"], "methodName": ["isCheckFullyPopulated"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   this . primitivesDefaultedForNullValue ;", "}", "METHOD_END"], "methodName": ["isPrimitivesDefaultedForNullValue"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   name . toLowerCase ( Locale . US )  ;", "}", "METHOD_END"], "methodName": ["lowerCaseName"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   new   BeanPropertyRowMapper <  >  ( mappedClass )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "this . checkFullyPopulated    =    checkFullyPopulated ;", "}", "METHOD_END"], "methodName": ["setCheckFullyPopulated"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "this . conversionService    =    conversionService ;", "}", "METHOD_END"], "methodName": ["setConversionService"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . mappedClass )     =  =    null )     {", "initialize ( mappedClass )  ;", "} else    {", "if    (  ( this . mappedClass )     !  =    mappedClass )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  \" The   mapped   class   can   not   be   reassigned   to   map   to    \"     +    mappedClass )     +     \"    since   it   is   already   providing   mapping   for    \"  )     +     ( this . mappedClass )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setMappedClass"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "this . primitivesDefaultedForNullValue    =    primitivesDefaultedForNullValue ;", "}", "METHOD_END"], "methodName": ["setPrimitivesDefaultedForNullValue"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( name )  )  )     {", "return    \"  \"  ;", "}", "StringBuilder   result    =    new   StringBuilder (  )  ;", "result . append ( lowerCaseName ( name . substring (  0  ,     1  )  )  )  ;", "for    ( int   i    =     1  ;    i    <     ( name . length (  )  )  ;    i +  +  )     {", "String   s    =    name . substring ( i ,     ( i    +     1  )  )  ;", "String   slc    =    lowerCaseName ( s )  ;", "if    (  !  ( s . equals ( slc )  )  )     {", "result . append (  \"  _  \"  )  . append ( slc )  ;", "} else    {", "result . append ( s )  ;", "}", "}", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["underscoreName"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapper"}, {"methodBody": ["METHOD_START", "{", "BeanPropertyRowMapper < Person >    mapper    =    new   BeanPropertyRowMapper <  >  ( Person . class )  ;", "AbstractRowMapperTests . Mock   mock    =    new   AbstractRowMapperTests . Mock ( AbstractRowMapperTests . MockType . TWO )  ;", "thrown . expect ( TypeMismatchException . class )  ;", "mock . getJdbcTemplate (  )  . query (  \" select   name ,    null   as   age ,    birth _ date ,    balance   from   people \"  ,    mapper )  ;", "}", "METHOD_END"], "methodName": ["testMappingNullValue"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "AbstractRowMapperTests . Mock   mock    =    new   AbstractRowMapperTests . Mock (  )  ;", "List < ConcretePerson >    result    =    mock . getJdbcTemplate (  )  . query (  \" select   name ,    age ,    birth _ date ,    balance   from   people \"  ,    new    <  >  ( ConcretePerson . class )  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "verifyPerson ( result . get (  0  )  )  ;", "mock . verifyClosed (  )  ;", "}", "METHOD_END"], "methodName": ["testMappingWithInheritance"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "AbstractRowMapperTests . Mock   mock    =    new   AbstractRowMapperTests . Mock (  )  ;", "List < ConcretePerson >    result    =    mock . getJdbcTemplate (  )  . query (  \" select   name ,    age ,    birth _ date ,    balance   from   people \"  ,    new    <  >  ( ConcretePerson . class ,    true )  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "verifyPerson ( result . get (  0  )  )  ;", "mock . verifyClosed (  )  ;", "}", "METHOD_END"], "methodName": ["testMappingWithNoUnpopulatedFieldsFound"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "AbstractRowMapperTests . Mock   mock    =    new   AbstractRowMapperTests . Mock (  )  ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "mock . getJdbcTemplate (  )  . query (  \" select   name ,    age ,    birth _ date ,    balance   from   people \"  ,    new    <  >  ( ExtendedPerson . class ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testMappingWithUnpopulatedFieldsNotAccepted"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "AbstractRowMapperTests . Mock   mock    =    new   AbstractRowMapperTests . Mock (  )  ;", "List < ExtendedPerson >    result    =    mock . getJdbcTemplate (  )  . query (  \" select   name ,    age ,    birth _ date ,    balance   from   people \"  ,    new    <  >  ( ExtendedPerson . class )  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "ExtendedPerson   bean    =    result . get (  0  )  ;", "verifyPerson ( bean )  ;", "mock . verifyClosed (  )  ;", "}", "METHOD_END"], "methodName": ["testMappingWithUnpopulatedFieldsNotChecked"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanPropertyRowMapper   mapper    =    new   BeanPropertyRowMapper ( Person . class )  ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "mapper . setMappedClass ( Long . class )  ;", "}", "METHOD_END"], "methodName": ["testOverridingDifferentClassDefinedForMapping"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanPropertyRowMapper < Person >    mapper    =    new   BeanPropertyRowMapper <  >  ( Person . class )  ;", "mapper . setMappedClass ( Person . class )  ;", "}", "METHOD_END"], "methodName": ["testOverridingSameClassDefinedForMapping"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "AbstractRowMapperTests . Mock   mock    =    new   AbstractRowMapperTests . Mock ( AbstractRowMapperTests . MockType . THREE )  ;", "List < DatePerson >    result    =    mock . getJdbcTemplate (  )  . query (  \" select   last _ name   as    \\  \" Last   Name \\  \"  ,    age ,    birth _ date ,    balance   from   people \"  ,    new    <  >  ( DatePerson . class )  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "verifyPerson ( result . get (  0  )  )  ;", "mock . verifyClosed (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithSpaceInColumnNameAndLocalDate"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "AbstractRowMapperTests . Mock   mock    =    new   AbstractRowMapperTests . Mock ( AbstractRowMapperTests . MockType . THREE )  ;", "List < SpacePerson >    result    =    mock . getJdbcTemplate (  )  . query (  \" select   last _ name   as    \\  \" Last   Name \\  \"  ,    age ,    birth _ date ,    balance   from   people \"  ,    new    <  >  ( SpacePerson . class )  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "verifyPerson ( result . get (  0  )  )  ;", "mock . verifyClosed (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithSpaceInColumnNameAndLocalDateTime"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "AbstractRowMapperTests . Mock   mock    =    new   AbstractRowMapperTests . Mock (  )  ;", "List < Person >    result    =    mock . getJdbcTemplate (  )  . query (  \" select   name ,    age ,    birth _ date ,    balance   from   people \"  ,    new    <  >  ( Person . class )  )  ;", "assertEquals (  1  ,    result . size (  )  )  ;", "verifyPerson ( result . get (  0  )  )  ;", "mock . verifyClosed (  )  ;", "}", "METHOD_END"], "methodName": ["testStaticQueryWithRowMapper"], "fileName": "org.springframework.jdbc.core.BeanPropertyRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "this . declaredParameters . add ( param )  ;", "}", "METHOD_END"], "methodName": ["addParameter"], "fileName": "org.springframework.jdbc.core.CallableStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   CallableStatementCreatorFactory . CallableStatementCreatorImpl (  ( params    !  =    null    ?    params    :    new   HashMap <  >  (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newCallableStatementCreator"], "fileName": "org.springframework.jdbc.core.CallableStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   CallableStatementCreatorFactory . CallableStatementCreatorImpl ( inParamMapper )  ;", "}", "METHOD_END"], "methodName": ["newCallableStatementCreator"], "fileName": "org.springframework.jdbc.core.CallableStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "this . resultSetType    =    resultSetType ;", "}", "METHOD_END"], "methodName": ["setResultSetType"], "fileName": "org.springframework.jdbc.core.CallableStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "this . updatableResults    =    updatableResults ;", "}", "METHOD_END"], "methodName": ["setUpdatableResults"], "fileName": "org.springframework.jdbc.core.CallableStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedCaseInsensitiveMap ( columnCount )  ;", "}", "METHOD_END"], "methodName": ["createColumnMap"], "fileName": "org.springframework.jdbc.core.ColumnMapRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   columnName ;", "}", "METHOD_END"], "methodName": ["getColumnKey"], "fileName": "org.springframework.jdbc.core.ColumnMapRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   JdbcUtils . getResultSetValue ( rs ,    index )  ;", "}", "METHOD_END"], "methodName": ["getColumnValue"], "fileName": "org.springframework.jdbc.core.ColumnMapRowMapper"}, {"methodBody": ["METHOD_START", "{", "int   fetchSize    =    getFetchSize (  )  ;", "if    ( fetchSize    !  =     (  -  1  )  )     {", "stmt . setFetchSize ( fetchSize )  ;", "}", "int   maxRows    =    getMaxRows (  )  ;", "if    ( maxRows    !  =     (  -  1  )  )     {", "stmt . setMaxRows ( maxRows )  ;", "}", "DataSourceUtils . applyTimeout ( stmt ,    getDataSource (  )  ,    getQueryTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["applyStatementSettings"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Connection )     ( Proxy . newProxyInstance ( ConnectionProxy . class . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    ConnectionProxy . class    }  ,    new   JdbcTemplate . CloseSuppressingInvocationHandler ( con )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createConnectionProxy"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( isResultsMapCaseInsensitive (  )  )     {", "return   new   util . LinkedCaseInsensitiveMap (  )  ;", "} else    {", "return   new   LinkedHashMap <  >  (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createResultsMap"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    returnedResults    =    new   HashMap <  >  (  )  ;", "int   sqlColIndex    =     1  ;", "for    ( SqlParameter   param    :    parameters )     {", "if    ( param   instanceof   SqlOutParameter )     {", "SqlOutParameter   outParam    =     (  ( SqlOutParameter )     ( param )  )  ;", "Assert . state (  (  ( outParam . getName (  )  )     !  =    null )  ,     \" Anonymous   parameters   not   allowed \"  )  ;", "SqlReturnType   returnType    =    outParam . getSqlReturnType (  )  ;", "if    ( returnType    !  =    null )     {", "Object   out    =    returnType . getTypeValue ( cs ,    sqlColIndex ,    outParam . getSqlType (  )  ,    outParam . getTypeName (  )  )  ;", "returnedResults . put ( outParam . getName (  )  ,    out )  ;", "} else    {", "Object   out    =    cs . getObject ( sqlColIndex )  ;", "if    ( out   instanceof   ResultSet )     {", "if    ( outParam . isResultSetSupported (  )  )     {", "returnedResults . putAll ( processResultSet (  (  ( ResultSet )     ( out )  )  ,    outParam )  )  ;", "} else    {", "String   rsName    =    outParam . getName (  )  ;", "SqlReturnResultSet   rsParam    =    new   SqlReturnResultSet ( rsName ,    getColumnMapRowMapper (  )  )  ;", "returnedResults . putAll ( processResultSet (  (  ( ResultSet )     ( out )  )  ,    rsParam )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Added   default   SqlReturnResultSet   parameter   named    '  \"     +    rsName )     +     \"  '  \"  )  )  ;", "}", "}", "} else    {", "returnedResults . put ( outParam . getName (  )  ,    out )  ;", "}", "}", "}", "if    (  !  ( param . isResultsParameter (  )  )  )     {", "sqlColIndex +  +  ;", "}", "}", "return   returnedResults ;", "}", "METHOD_END"], "methodName": ["extractOutputParameters"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    returnedResults    =    new   HashMap <  >  (  )  ;", "int   rsIndex    =     0  ;", "int   updateIndex    =     0  ;", "boolean   moreResults ;", "if    (  !  ( this . skipResultsProcessing )  )     {", "do    {", "if    ( updateCount    =  =     (  -  1  )  )     {", "if    (  ( resultSetParameters    !  =    null )     &  &     (  ( resultSetParameters . size (  )  )     >    rsIndex )  )     {", "SqlReturnResultSet   declaredRsParam    =     (  ( SqlReturnResultSet )     ( resultSetParameters . get ( rsIndex )  )  )  ;", "returnedResults . putAll ( processResultSet ( cs . getResultSet (  )  ,    declaredRsParam )  )  ;", "rsIndex +  +  ;", "} else    {", "if    (  !  ( this . skipUndeclaredResults )  )     {", "String   rsName    =     (  . RETURN _ RESULT _ SET _ PREFIX )     +     ( rsIndex    +     1  )  ;", "SqlReturnResultSet   undeclaredRsParam    =    new   SqlReturnResultSet ( rsName ,    getColumnMapRowMapper (  )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Added   default   SqlReturnResultSet   parameter   named    '  \"     +    rsName )     +     \"  '  \"  )  )  ;", "}", "returnedResults . putAll ( processResultSet ( cs . getResultSet (  )  ,    undeclaredRsParam )  )  ;", "rsIndex +  +  ;", "}", "}", "} else    {", "if    (  ( updateCountParameters    !  =    null )     &  &     (  ( updateCountParameters . size (  )  )     >    updateIndex )  )     {", "SqlReturnUpdateCount   ucParam    =     (  ( SqlReturnUpdateCount )     ( updateCountParameters . get ( updateIndex )  )  )  ;", "String   declaredUcName    =    ucParam . getName (  )  ;", "returnedResults . put ( declaredUcName ,    updateCount )  ;", "updateIndex +  +  ;", "} else    {", "if    (  !  ( this . skipUndeclaredResults )  )     {", "String   undeclaredName    =     (  . RETURN _ UPDATE _ COUNT _ PREFIX )     +     ( updateIndex    +     1  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Added   default   SqlReturnUpdateCount   parameter   named    '  \"     +    undeclaredName )     +     \"  '  \"  )  )  ;", "}", "returnedResults . put ( undeclaredName ,    updateCount )  ;", "updateIndex +  +  ;", "}", "}", "}", "moreResults    =    cs . getMoreResults (  )  ;", "updateCount    =    cs . getUpdateCount (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" CallableStatement . getUpdateCount (  )    returned    \"     +    updateCount )  )  ;", "}", "}    while    ( moreResults    |  |     ( updateCount    !  =     (  -  1  )  )     )  ;", "}", "return   returnedResults ;", "}", "METHOD_END"], "methodName": ["extractReturnedResults"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnMapRowMapper (  )  ;", "}", "METHOD_END"], "methodName": ["getColumnMapRowMapper"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . fetchSize ;", "}", "METHOD_END"], "methodName": ["getFetchSize"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . maxRows ;", "}", "METHOD_END"], "methodName": ["getMaxRows"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . queryTimeout ;", "}", "METHOD_END"], "methodName": ["getQueryTimeout"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   SingleColumnRowMapper <  >  ( requiredType )  ;", "}", "METHOD_END"], "methodName": ["getSingleColumnRowMapper"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( sqlProvider   instanceof   SqlProvider )     {", "return    (  ( SqlProvider )     ( sqlProvider )  )  . getSql (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getSql"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( warning    !  =    null )     {", "throw   new   SQLWarningException (  \" Warning   not   ignored \"  ,    warning )  ;", "}", "}", "METHOD_END"], "methodName": ["handleWarnings"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( isIgnoreWarnings (  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "SQLWarning   warningToLog    =    stmt . getWarnings (  )  ;", "while    ( warningToLog    !  =    null )     {", "logger . debug (  (  (  (  (  (  (  \" SQLWarning   ignored :    SQL   state    '  \"     +     ( warningToLog . getSQLState (  )  )  )     +     \"  '  ,    error   code    '  \"  )     +     ( warningToLog . getErrorCode (  )  )  )     +     \"  '  ,    message    [  \"  )     +     ( warningToLog . getMessage (  )  )  )     +     \"  ]  \"  )  )  ;", "warningToLog    =    warningToLog . getNextWarning (  )  ;", "}", "}", "} else    {", "handleWarnings ( stmt . getWarnings (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleWarnings"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . ignoreWarnings ;", "}", "METHOD_END"], "methodName": ["isIgnoreWarnings"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . resultsMapCaseInsensitive ;", "}", "METHOD_END"], "methodName": ["isResultsMapCaseInsensitive"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . skipResultsProcessing ;", "}", "METHOD_END"], "methodName": ["isSkipResultsProcessing"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . skipUndeclaredResults ;", "}", "METHOD_END"], "methodName": ["isSkipUndeclaredResults"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   ArgumentPreparedStatementSetter ( args )  ;", "}", "METHOD_END"], "methodName": ["newArgPreparedStatementSetter"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   new   ArgumentTypePreparedStatementSetter ( args ,    argTypes )  ;", "}", "METHOD_END"], "methodName": ["newArgTypePreparedStatementSetter"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( rs    =  =    null )     {", "return   Collections . emptyMap (  )  ;", "}", "Map < String ,    Object >    returnedResults    =    new   HashMap <  >  (  )  ;", "try    {", "if    (  ( param . getRowMapper (  )  )     !  =    null )     {", "RowMapper <  ?  >    rowMapper    =    param . getRowMapper (  )  ;", "Object   result    =    new   RowMapperResultSetExtractor <  >  ( rowMapper )  . extractData ( rs )  ;", "returnedResults . put ( param . getName (  )  ,    result )  ;", "} else", "if    (  ( param . getRowCallbackHandler (  )  )     !  =    null )     {", "RowCallbackHandler   rch    =    param . getRowCallbackHandler (  )  ;", "new    . RowCallbackHandlerResultSetExtractor ( rch )  . extractData ( rs )  ;", "returnedResults . put ( param . getName (  )  ,     \" ResultSet   returned   from   stored   procedure   was   processed \"  )  ;", "} else", "if    (  ( param . getResultSetExtractor (  )  )     !  =    null )     {", "Object   result    =    param . getResultSetExtractor (  )  . extractData ( rs )  ;", "returnedResults . put ( param . getName (  )  ,    result )  ;", "}", "}    finally    {", "JdbcUtils . closeResultSet ( rs )  ;", "}", "return   returnedResults ;", "}", "METHOD_END"], "methodName": ["processResultSet"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( rse ,     \" ResultSetExtractor   must   not   be   null \"  )  ;", "logger . debug (  \" Executing   prepared   SQL   query \"  )  ;", "return   execute ( psc ,    new   PreparedStatementCallback < T >  (  )     {", "@ Override", "@ Nullable", "public   T   doInPreparedStatement ( PreparedStatement   ps )    throws   SQLException    {", "ResultSet   rs    =    null ;", "try    {", "if    ( pss    !  =    null )     {", "pss . setValues ( ps )  ;", "}", "rs    =    ps . executeQuery (  )  ;", "return   rse . extractData ( rs )  ;", "}    finally    {", "Utils . closeResultSet ( rs )  ;", "if    ( pss   instanceof   ParameterDisposer )     {", "(  ( ParameterDisposer )     ( pss )  )  . cleanupParameters (  )  ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["query"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  ( result    !  =    null )  ,     \" No   result \"  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["result"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "this . fetchSize    =    fetchSize ;", "}", "METHOD_END"], "methodName": ["setFetchSize"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "this . ignoreWarnings    =    ignoreWarnings ;", "}", "METHOD_END"], "methodName": ["setIgnoreWarnings"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "this . maxRows    =    maxRows ;", "}", "METHOD_END"], "methodName": ["setMaxRows"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "this . queryTimeout    =    queryTimeout ;", "}", "METHOD_END"], "methodName": ["setQueryTimeout"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "this . resultsMapCaseInsensitive    =    resultsMapCaseInsensitive ;", "}", "METHOD_END"], "methodName": ["setResultsMapCaseInsensitive"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "this . skipResultsProcessing    =    skipResultsProcessing ;", "}", "METHOD_END"], "methodName": ["setSkipResultsProcessing"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "this . skipUndeclaredResults    =    skipUndeclaredResults ;", "}", "METHOD_END"], "methodName": ["setSkipUndeclaredResults"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "DataAccessException   dae    =    getExceptionTranslator (  )  . translate ( task ,    sql ,    ex )  ;", "return   dae    !  =    null    ?    dae    :    new   UncategorizedSQLException ( task ,    sql ,    ex )  ;", "}", "METHOD_END"], "methodName": ["translateException"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  \" Executing   prepared   SQL   update \"  )  ;", "return    . updateCount ( execute ( psc ,     (    ps )     -  >     {", "try    {", "if    ( pss    !  =    null )     {", "pss . setValues ( ps )  ;", "}", "int   rows    =    ps . executeUpdate (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" SQL   update   affected    \"     +    rows )     +     \"    rows \"  )  )  ;", "}", "return   rows ;", "}    finally    {", "if    ( pss   instanceof   ParameterDisposer )     {", "(  ( ParameterDisposer )     ( pss )  )  . cleanupParameters (  )  ;", "}", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  ( result    !  =    null )  ,     \" No   update   count \"  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["updateCount"], "fileName": "org.springframework.jdbc.core.JdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( this . resultSet . getObject (  1  )  )  . willReturn (  1  1  ,     1  2  )  ;", "List < Map < String ,    Object >  >    li    =    this . t . queryForList ( sql ,    new   Object [  ]  {     3     }  )  ;", "assertEquals (  \" All   rows   returned \"  ,     2  ,    li . size (  )  )  ;", "assertEquals (  \" First   row   is   Integer \"  ,     1  1  ,     (  ( Integer )     ( li . get (  0  )  . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "assertEquals (  \" Second   row   is   Integer \"  ,     1  2  ,     (  ( Integer )     ( li . get (  1  )  . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestQueryForListWithArgs"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "this . connection    =    mock ( Connection . class )  ;", "this . dataSource    =    mock ( DataSource . class )  ;", "this . statement    =    mock ( Statement . class )  ;", "this . preparedStatement    =    mock ( PreparedStatement . class )  ;", "this . resultSet    =    mock ( ResultSet . class )  ;", "this . resultSetMetaData    =    mock ( ResultSetMetaData . class )  ;", "this . template    =    new    ( this . dataSource )  ;", "given ( this . dataSource . getConnection (  )  )  . willReturn ( this . connection )  ;", "given ( this . resultSet . getMetaData (  )  )  . willReturn ( this . resultSetMetaData )  ;", "given ( this . resultSetMetaData . getColumnCount (  )  )  . willReturn (  1  )  ;", "given ( this . resultSetMetaData . getColumnLabel (  1  )  )  . willReturn (  \" age \"  )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "given ( this . connection . prepareStatement ( anyString (  )  )  )  . willReturn ( this . preparedStatement )  ;", "given ( this . preparedStatement . executeQuery (  )  )  . willReturn ( this . resultSet )  ;", "given ( this . statement . executeQuery ( anyString (  )  )  )  . willReturn ( this . resultSet )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "int   i    =    this . t . queryForObject ( sql ,    Integer . class )  . intValue (  )  ;", "assertEquals (  \" Return   of   an   int \"  ,     2  2  ,    i )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForInt"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "int   i    =    this . t . queryForObject ( sql ,    int . class )  ;", "assertEquals (  \" Return   of   an   int \"  ,     2  2  ,    i )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForIntPrimitive"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     ?  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "int   i    =    this . t . queryForObject ( sql ,    new   Object [  ]  {     3     }  ,    Integer . class )  . intValue (  )  ;", "assertEquals (  \" Return   of   an   int \"  ,     2  2  ,    i )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForIntWithArgs"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( this . resultSet . getObject (  1  )  )  . willReturn (  1  1  ,     1  2  )  ;", "List < Map < String ,    Object >  >    li    =    this . t . queryForList ( sql )  ;", "assertEquals (  \" All   rows   returned \"  ,     2  ,    li . size (  )  )  ;", "assertEquals (  \" First   row   is   Integer \"  ,     1  1  ,     (  ( Integer )     ( li . get (  0  )  . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "assertEquals (  \" Second   row   is   Integer \"  ,     1  2  ,     (  ( Integer )     ( li . get (  1  )  . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForList"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "doTestQueryForListWithArgs (  \" SELECT   AGE   FROM   PREFIX : CUSTMR   WHERE   ID    <     ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListIsNotConfusedByNamedParameterPrefix"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "doTestQueryForListWithArgs (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithArgs"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( false )  ;", "List < Map < String ,    Object >  >    li    =    this . t . queryForList ( sql ,    new   Object [  ]  {     3     }  )  ;", "assertEquals (  \" All   rows   returned \"  ,     0  ,    li . size (  )  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithArgsAndEmptyResult"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  1  1  )  ;", "List < Integer >    li    =    this . t . queryForList ( sql ,    new   Object [  ]  {     3     }  ,    Integer . class )  ;", "assertEquals (  \" All   rows   returned \"  ,     1  ,    li . size (  )  )  ;", "assertEquals (  \" First   row   is   Integer \"  ,     1  1  ,    li . get (  0  )  . intValue (  )  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithArgsAndIntegerElementAndSingleRowAndColumn"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getObject (  1  )  )  . willReturn (  1  1  )  ;", "List < Map < String ,    Object >  >    li    =    this . t . queryForList ( sql ,    new   Object [  ]  {     3     }  )  ;", "assertEquals (  \" All   rows   returned \"  ,     1  ,    li . size (  )  )  ;", "assertEquals (  \" First   row   is   Integer \"  ,     1  1  ,     (  ( Integer )     ( li . get (  0  )  . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithArgsAndSingleRowAndColumn"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( false )  ;", "List < Map < String ,    Object >  >    li    =    this . t . queryForList ( sql )  ;", "assertEquals (  \" All   rows   returned \"  ,     0  ,    li . size (  )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithEmptyResult"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  1  1  )  ;", "List < Integer >    li    =    this . t . queryForList ( sql ,    Integer . class )  ;", "assertEquals (  \" All   rows   returned \"  ,     1  ,    li . size (  )  )  ;", "assertEquals (  \" Element   is   Integer \"  ,     1  1  ,    li . get (  0  )  . intValue (  )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithIntegerElement"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getObject (  1  )  )  . willReturn (  1  1  )  ;", "List < Map < String ,    Object >  >    li    =    this . t . queryForList ( sql )  ;", "assertEquals (  \" All   rows   returned \"  ,     1  ,    li . size (  )  )  ;", "assertEquals (  \" First   row   is   Integer \"  ,     1  1  ,     (  ( Integer )     ( li . get (  0  )  . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithSingleRowAndColumn"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getLong (  1  )  )  . willReturn (  8  7 L )  ;", "long   l    =    this . t . queryForObject ( sql ,    Long . class )  . longValue (  )  ;", "assertEquals (  \" Return   of   a   long \"  ,     8  7  ,    l )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForLong"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getLong (  1  )  )  . willReturn (  8  7 L )  ;", "long   l    =    this . t . queryForObject ( sql ,    long . class )  ;", "assertEquals (  \" Return   of   a   long \"  ,     8  7  ,    l )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForLongPrimitive"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     ?  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getLong (  1  )  )  . willReturn (  8  7 L )  ;", "long   l    =    this . t . queryForObject ( sql ,    new   Object [  ]  {     3     }  ,    Long . class )  . longValue (  )  ;", "assertEquals (  \" Return   of   a   long \"  ,     8  7  ,    l )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForLongWithArgs"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getObject (  1  )  )  . willReturn (  1  1  )  ;", "Map < String ,    Object >    map    =    this . t . queryForMap ( sql ,    new   Object [  ]  {     3     }  )  ;", "assertEquals (  \" Row   is   Integer \"  ,     1  1  ,     (  ( Integer )     ( map . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForMapWithArgsAndSingleRowAndColumn"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getObject (  1  )  )  . willReturn (  1  1  )  ;", "Map < String ,    Object >    map    =    this . t . queryForMap ( sql )  ;", "assertEquals (  \" Wow   is   Integer \"  ,     1  1  ,     (  ( Integer )     ( map . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForMapWithSingleRowAndColumn"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" select   pass   from   t _ account   where   first _ name =  ' Alef '  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( this . resultSet . getString (  1  )  )  . willReturn (  \" pass \"  )  ;", "this . thrown . expect ( IncorrectResultSizeDataAccessException . class )  ;", "try    {", "this . t . queryForObject ( sql ,    String . class )  ;", "}    finally    {", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testQueryForObjectThrowsIncorrectResultSizeForMoreThanOneRow"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     ?  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "Object   o    =    this . t . queryForObject ( sql ,    new   Object [  ]  {     3     }  ,    Integer . class )  ;", "assertTrue (  \" Correct   result   type \"  ,     ( o   instanceof   Integer )  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithArgsAndInteger"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     ?  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "Object   o    =    this . t . queryForObject ( sql ,    new   Object [  ]  {     3     }  ,    new   RowMapper < Integer >  (  )     {", "@ Override", "public   Integer   mapRow ( ResultSet   rs ,    int   rowNum )    throws   SQLException    {", "return   rs . getInt (  1  )  ;", "}", "}  )  ;", "assertTrue (  \" Correct   result   type \"  ,     ( o   instanceof   Integer )  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithArgsAndRowMapper"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getBigDecimal (  1  )  )  . willReturn ( new   BigDecimal (  \"  2  2  .  5  \"  )  )  ;", "assertEquals ( new   BigDecimal (  \"  2  2  .  5  \"  )  ,    this . t . queryForObject ( sql ,    BigDecimal . class )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithBigDecimal"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getObject (  1  ,    BigInteger . class )  )  . willReturn ( new   BigInteger (  \"  2  2  \"  )  )  ;", "assertEquals ( new   BigInteger (  \"  2  2  \"  )  ,    this . t . queryForObject ( sql ,    BigInteger . class )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithBigInteger"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "assertEquals ( Integer . valueOf (  2  2  )  ,    this . t . queryForObject ( sql ,    Integer . class )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithInteger"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  0  )  ;", "given ( this . resultSet . wasNull (  )  )  . willReturn ( true )  ;", "assertNull ( this . t . queryForObject ( sql ,    Integer . class )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithIntegerAndNull"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "Object   o    =    this . t . queryForObject ( sql ,    new   RowMapper < Integer >  (  )     {", "@ Override", "public   Integer   mapRow ( ResultSet   rs ,    int   rowNum )    throws   SQLException    {", "return   rs . getInt (  1  )  ;", "}", "}  )  ;", "assertTrue (  \" Correct   result   type \"  ,     ( o   instanceof   Integer )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithRowMapper"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( this . resultSet . getString (  1  )  )  . willReturn (  \" myvalue \"  )  ;", "assertEquals (  \" myvalue \"  ,    this . t . queryForObject ( sql ,    String . class )  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithString"], "fileName": "org.springframework.jdbc.core.JdbcTemplateQueryTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sqlException    =    new   SQLException (  \" foo \"  ,     \"  0  7 xxx \"  )  ;", "this . dataSource    =    mock ( DataSource . class )  ;", "given ( this . dataSource . getConnection (  )  )  . willThrow ( sqlException )  ;", "this . template    =    new    (  )  ;", "this . template . setDataSource ( this . dataSource )  ;", "this . template . setLazyInit ( false )  ;", "if    ( beanProperty )     {", "this . template . setExceptionTranslator ( new   SQLErrorCodeSQLExceptionTranslator ( this . dataSource )  )  ;", "} else    {", "this . template . afterPropertiesSet (  )  ;", "}", "RowCountCallbackHandler   rcch    =    new   RowCountCallbackHandler (  )  ;", "this . thrown . expect ( CannotGetJdbcConnectionException . class )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "this . template . query (  \" SELECT   ID ,    FORENAME   FROM   CUSTMR   WHERE   ID    <     3  \"  ,    rcch )  ;", "}", "METHOD_END"], "methodName": ["doTestCouldntGetConnectionInOperationWithExceptionTranslatorInitialized"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   FORENAME   FROM   CUSTMR \"  ;", "String [  ]    results    =    new   String [  ]  {     \" rod \"  ,     \" gary \"  ,     \"    portia \"     }  ;", "class   StringHandler   implements   RowCallbackHandler    {", "private   List < String >    list    =    new   LinkedList <  >  (  )  ;", "@ Override", "public   void   processRow ( ResultSet   rs )    throws   SQLException    {", "this . list . add ( rs . getString (  1  )  )  ;", "}", "public   String [  ]    getStrings (  )     {", "return   StringUtils . toStringArray ( this . list )  ;", "}", "}", "given ( this . resultSet . next (  )  )  . willReturn ( true ,    true ,    true ,    false )  ;", "given ( this . resultSet . getString (  1  )  )  . willReturn ( results [  0  ]  ,    results [  1  ]  ,    results [  2  ]  )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . preparedStatement )  ;", "StringHandler   sh    =    new   StringHandler (  )  ;", "template    =    new    (  )  ;", "template . setDataSource ( this . dataSource )  ;", "if    ( fetchSize    !  =    null )     {", "template . setFetchSize ( fetchSize . intValue (  )  )  ;", "}", "if    ( maxRows    !  =    null )     {", "template . setMaxRows ( maxRows . intValue (  )  )  ;", "}", "if    ( queryTimeout    !  =    null )     {", "template . setQueryTimeout ( queryTimeout . intValue (  )  )  ;", "}", "jdbcTemplateCallback . doIn ( template ,    sql ,    sh )  ;", "String [  ]    forenames    =    sh . getStrings (  )  ;", "assertTrue (  \" same   length \"  ,     (  ( forenames . length )     =  =     ( results . length )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( forenames . length )  ;    i +  +  )     {", "assertTrue (  (  (  \" Row    \"     +    i )     +     \"    matches \"  )  ,    forenames [ i ]  . equals ( results [ i ]  )  )  ;", "}", "if    ( fetchSize    !  =    null )     {", "verify ( this . preparedStatement )  . setFetchSize ( fetchSize . intValue (  )  )  ;", "}", "if    ( maxRows    !  =    null )     {", "verify ( this . preparedStatement )  . setMaxRows ( maxRows . intValue (  )  )  ;", "}", "if    ( queryTimeout    !  =    null )     {", "verify ( this . preparedStatement )  . setQueryTimeout ( queryTimeout . intValue (  )  )  ;", "}", "if    ( argument    !  =    null )     {", "verify ( this . preparedStatement )  . setObject (  1  ,    argument )  ;", "}", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestStrings"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "DatabaseMetaData   databaseMetaData    =    mock ( DatabaseMetaData . class )  ;", "given ( databaseMetaData . getDatabaseProductN (  )  )  . willReturn (  \" MySQL \"  )  ;", "given ( databaseMetaData . supportsBatchUpdates (  )  )  . willReturn ( supportsBatchUpdates )  ;", "given ( this . connection . getMetaData (  )  )  . willReturn ( databaseMetaData )  ;", "}", "METHOD_END"], "methodName": ["mockDatabaseMetaData"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . connection    =    mock ( Connection . class )  ;", "this . dataSource    =    mock ( DataSource . class )  ;", "this . preparedStatement    =    mock ( PreparedStatement . class )  ;", "this . statement    =    mock ( Statement . class )  ;", "this . resultSet    =    mock ( ResultSet . class )  ;", "this . template    =    new    ( this . dataSource )  ;", "this . callableStatement    =    mock ( CallableStatement . class )  ;", "given ( this . dataSource . getConnection (  )  )  . willReturn ( this . connection )  ;", "given ( this . connection . prepareStatement ( anyString (  )  )  )  . willReturn ( this . preparedStatement )  ;", "given ( this . preparedStatement . executeQuery (  )  )  . willReturn ( this . resultSet )  ;", "given ( this . preparedStatement . executeQuery ( anyString (  )  )  )  . willReturn ( this . resultSet )  ;", "given ( this . preparedStatement . getConnection (  )  )  . willReturn ( this . connection )  ;", "given ( this . statement . getConnection (  )  )  . willReturn ( this . connection )  ;", "given ( this . statement . executeQuery ( anyString (  )  )  )  . willReturn ( this . resultSet )  ;", "given ( this . connection . prepareCall ( anyString (  )  )  )  . willReturn ( this . callableStatement )  ;", "given ( this . callableStatement . getResultSet (  )  )  . willReturn ( this . resultSet )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    sql    =    new   String [  ]  {     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     1  \"  ,     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     2  \"     }  ;", "given ( this . statement . executeBatch (  )  )  . willReturn ( new   int [  ]  {     1  ,     1     }  )  ;", "mockDatabaseMetaData ( true )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "template    =    new    ( this . dataSource ,    false )  ;", "int [  ]    actualRowsAffected    =    template . batchUpdate ( sql )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "verify ( this . statement )  . addBatch ( sql [  0  ]  )  ;", "verify ( this . statement )  . addBatch ( sql [  1  ]  )  ;", "verify ( this . statement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdate"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   int [  ]    ids    =    new   int [  ]  {     1  0  0  ,     2  0  0     }  ;", "SQLException   sqlException    =    new   SQLException (  )  ;", "given ( this . preparedStatement . executeBatch (  )  )  . willThrow ( sqlException )  ;", "mockDatabaseMetaData ( true )  ;", "BatchPreparedStatementSetter   setter    =    new   BatchPreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps ,    int   i )    throws   SQLException    {", "ps . setInt (  1  ,    ids [ i ]  )  ;", "}", "@ Override", "public   int   getBatchSize (  )     {", "return   ids . length ;", "}", "}  ;", "this . thrown . expect ( DataAccessException . class )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "try    {", "this . t . batchUpdate ( sql ,    setter )  ;", "}    finally    {", "verify ( this . preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  0  ]  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  1  ]  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBatchUpdateFails"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    sql    =    new   String [  ]  {     \" A \"  ,     \" B \"  ,     \" C \"  ,     \" D \"     }  ;", "given ( this . statement . executeBatch (  )  )  . willThrow ( new   BatchUpdateException ( new   int [  ]  {     1  ,    Statement . EXECUTE _ FAILED ,     1  ,    Statement . EXECUTE _ FAILED    }  )  )  ;", "mockDatabaseMetaData ( true )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "template    =    new    ( this . dataSource ,    false )  ;", "try    {", "template . batchUpdate ( sql )  ;", "}    catch    ( UncategorizedSQLException   ex )     {", "assertThat ( ex . getSql (  )  ,    equalTo (  \" B ;    D \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithBatchFailure"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   List < Integer >    ids    =    Arrays . asList (  1  0  0  ,     2  0  0  ,     3  0  0  )  ;", "final   int [  ]    rowsAffected 1     =    new   int [  ]  {     1  ,     2     }  ;", "final   int [  ]    rowsAffected 2     =    new   int [  ]  {     3     }  ;", "given ( this . preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected 1  ,    rowsAffected 2  )  ;", "mockDatabaseMetaData ( true )  ;", "ParameterizedPreparedStatementSetter < Integer >    setter    =    new   ParameterizedPreparedStatementSetter < Integer >  (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps ,    Integer   argument )    throws   SQLException    {", "ps . setInt (  1  ,    argument . intValue (  )  )  ;", "}", "}  ;", "template    =    new    ( this . dataSource ,    false )  ;", "int [  ]  [  ]    actualRowsAffected    =    template . batchUpdate ( sql ,    ids ,     2  ,    setter )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected [  0  ]  . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected 1  [  0  ]  ,    actualRowsAffected [  0  ]  [  0  ]  )  ;", "assertEquals ( rowsAffected 1  [  1  ]  ,    actualRowsAffected [  0  ]  [  1  ]  )  ;", "assertEquals ( rowsAffected 2  [  0  ]  ,    actualRowsAffected [  1  ]  [  0  ]  )  ;", "verify ( this . preparedStatement ,    times (  3  )  )  . addBatch (  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids . get (  0  )  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids . get (  1  )  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids . get (  2  )  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithCollectionOfObjects"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   List < Object [  ]  >    ids    =    new   ArrayList <  >  (  )  ;", "ids . add ( new   Object [  ]  {     1  0  0     }  )  ;", "ids . add ( new   Object [  ]  {     2  0  0     }  )  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( this . preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected )  ;", "mockDatabaseMetaData ( true )  ;", "template    =    new    ( this . dataSource ,    false )  ;", "int [  ]    actualRowsAffected    =    template . batchUpdate ( sql ,    ids )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( this . preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     1  0  0  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     2  0  0  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithListOfObjectArrays"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   List < Object [  ]  >    ids    =    new   ArrayList <  >  (  )  ;", "ids . add ( new   Object [  ]  {     1  0  0     }  )  ;", "ids . add ( new   Object [  ]  {     2  0  0     }  )  ;", "final   int [  ]    sqlTypes    =    new   int [  ]  {    Types . NUMERIC    }  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( this . preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected )  ;", "mockDatabaseMetaData ( true )  ;", "this . template    =    new    ( this . dataSource ,    false )  ;", "int [  ]    actualRowsAffected    =    this . template . batchUpdate ( sql ,    ids ,    sqlTypes )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( this . preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     1  0  0  ,    sqlTypes [  0  ]  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     2  0  0  ,    sqlTypes [  0  ]  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithListOfObjectArraysPlusTypeInfo"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    sql    =    new   String [  ]  {     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     1  \"  ,     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     2  \"     }  ;", "given ( this . statement . execute ( sql [  0  ]  )  )  . willReturn ( false )  ;", "given ( this . statement . getUpdateCount (  )  )  . willReturn (  1  ,     1  )  ;", "given ( this . statement . execute ( sql [  1  ]  )  )  . willReturn ( false )  ;", "mockDatabaseMetaData ( false )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "template    =    new    ( this . dataSource ,    false )  ;", "int [  ]    actualRowsAffected    =    template . batchUpdate ( sql )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "verify ( this . statement ,    never (  )  )  . addBatch ( anyString (  )  )  ;", "verify ( this . statement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithNoBatchSupport"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    sql    =    new   String [  ]  {     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     1  \"  ,     \" SELECT    *    FROM   NOSUCHTABLE \"     }  ;", "given ( this . statement . execute ( sql [  0  ]  )  )  . willReturn ( false )  ;", "given ( this . statement . getUpdateCount (  )  )  . willReturn (  1  )  ;", "given ( this . statement . execute ( sql [  1  ]  )  )  . willReturn ( true )  ;", "mockDatabaseMetaData ( false )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "template    =    new    ( this . dataSource ,    false )  ;", "this . thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "try    {", "template . batchUpdate ( sql )  ;", "}    finally    {", "verify ( this . statement ,    never (  )  )  . addBatch ( anyString (  )  )  ;", "verify ( this . statement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithNoBatchSupportAndSelect"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   int [  ]    ids    =    new   int [  ]  {     1  0  0  ,     2  0  0     }  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( this . preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected )  ;", "mockDatabaseMetaData ( true )  ;", "BatchPreparedStatementSetter   setter    =    new   BatchPreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps ,    int   i )    throws   SQLException    {", "ps . setInt (  1  ,    ids [ i ]  )  ;", "}", "@ Override", "public   int   getBatchSize (  )     {", "return   ids . length ;", "}", "}  ;", "template    =    new    ( this . dataSource ,    false )  ;", "int [  ]    actualRowsAffected    =    template . batchUpdate ( sql ,    setter )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( this . preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  0  ]  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  1  ]  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithPreparedStatement"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   int [  ]    ids    =    new   int [  ]  {     1  0  0  ,     2  0  0     }  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( this . preparedStatement . executeUpdate (  )  )  . willReturn ( rowsAffected [  0  ]  ,    rowsAffected [  1  ]  )  ;", "BatchPreparedStatementSetter   setter    =    new   BatchPreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps ,    int   i )    throws   SQLException    {", "ps . setInt (  1  ,    ids [ i ]  )  ;", "}", "@ Override", "public   int   getBatchSize (  )     {", "return   ids . length ;", "}", "}  ;", "int [  ]    actualRowsAffected    =    this . t . batchUpdate ( sql ,    setter )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( this . preparedStatement ,    never (  )  )  . addBatch (  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  0  ]  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  1  ]  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithPreparedStatementAndNoBatchSupport"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" datasource   ok \"  ,     (  ( this . template . getDataSource (  )  )     =  =     ( this . dataSource )  )  )  ;", "assertTrue (  \" ignores   warnings   by   default \"  ,    this . template . isIgnoreWarnings (  )  )  ;", "this . template . setIgnoreWarnings ( false )  ;", "assertTrue (  \" can   set   NOT   to   ignore   warnings \"  ,     (  !  ( this . template . isIgnoreWarnings (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanProperties"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   int   idParam    =     6  6  6  6  ;", "SQLException   sqlException    =    new   SQLException (  \" bad   update \"  )  ;", "given ( this . preparedStatement . executeUpdate (  )  )  . willThrow ( sqlException )  ;", ". Dispatcher   d    =    new    . Dispatcher ( idParam ,    sql )  ;", "this . thrown . expect ( UncategorizedSQLException . class )  ;", "this . thrown . expect ( exceptionCause ( equalTo ( sqlException )  )  )  ;", "try    {", "this . template . update ( d )  ;", "}    finally    {", "verify ( this . preparedStatement )  . setInt (  1  ,    idParam )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBogusUpdate"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( this . callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( this . callableStatement . getObject (  1  )  )  . willReturn (  \" X \"  )  ;", "assertTrue (  \" default   should   have   been   NOT   case   insensitive \"  ,     (  !  ( this . t . isResultsMapCaseInsensitive (  )  )  )  )  ;", "this . t . setResultsMapCaseInsensitive ( true )  ;", "assertTrue (  \" now   it   should   have   been   set   to   case   insensitive \"  ,    this . t . isResultsMapCaseInsensitive (  )  )  ;", "List < SqlParameter >    params    =    new   ArrayList <  >  (  )  ;", "params . add ( new   SqlOutParameter (  \" a \"  ,     1  2  )  )  ;", "Map < String ,    Object >    out    =    this . t . call ( new   CallableStatementCreator (  )     {", "@ Override", "public   CallableStatement   createCallableStatement ( Connection   conn )    throws   SQLException    {", "return   conn . prepareCall (  \" my   query \"  )  ;", "}", "}  ,    params )  ;", "assertThat ( out ,    instanceOf ( LinkedCaseInsensitiveMap . class )  )  ;", "assertNotNull (  \" we   should   have   gotten   the   result   with   upper   case \"  ,    out . get (  \" A \"  )  )  ;", "assertNotNull (  \" we   should   have   gotten   the   result   with   lower   case \"  ,    out . get (  \" a \"  )  )  ;", "verify ( this . callableStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testCaseInsensitiveResultsMap"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   ID ,    FORENAME   FROM   CUSTMR   WHERE   ID    <     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( false )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . preparedStatement )  ;", "RowCountCallbackHandler   rcch    =    new   RowCountCallbackHandler (  )  ;", "this . t . query ( sql ,    rcch )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testCloseConnectionOnRequest"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   result    =    this . template . execute ( new   ConnectionCallback < String >  (  )     {", "@ Override", "public   String   doInConnection ( Connection   con )     {", "assertTrue (  ( con   instanceof   ConnectionProxy )  )  ;", "assertSame (  . this . connection ,     (  ( ConnectionProxy )     ( con )  )  . getTargetConnection (  )  )  ;", "return    \" test \"  ;", "}", "}  )  ;", "assertEquals (  \" test \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testConnectionCallback"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   result    =    this . template . execute ( new   ConnectionCallback < String >  (  )     {", "@ Override", "public   String   doInConnection ( Connection   con )    throws   SQLException    {", "PreparedStatement   ps    =    con . prepareStatement (  \" some   SQL \"  )  ;", "ps . setFetchSize (  1  0  )  ;", "ps . setMaxRows (  2  0  )  ;", "ps . close (  )  ;", "return    \" test \"  ;", "}", "}  )  ;", "assertEquals (  \" test \"  ,    result )  ;", "verify ( this . preparedStatement )  . setFetchSize (  1  0  )  ;", "verify ( this . preparedStatement )  . setMaxRows (  2  0  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testConnectionCallbackWithStatementSettings"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sqlException    =    new   SQLException (  \" bar \"  )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "given ( this . resultSet . next (  )  )  . willReturn ( false )  ;", "willThrow ( sqlException )  . given ( this . resultSet )  . close (  )  ;", "willThrow ( sqlException )  . given ( this . statement )  . close (  )  ;", "willThrow ( sqlException )  . given ( this . connection )  . close (  )  ;", "RowCountCallbackHandler   rcch    =    new   RowCountCallbackHandler (  )  ;", "this . t . query (  \" SELECT   ID ,    FORENAME   FROM   CUSTMR   WHERE   ID    <     3  \"  ,    rcch )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testCouldntClose"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sqlException    =    new   SQLException (  \" foo \"  ,     \"  0  7 xxx \"  )  ;", "this . dataSource    =    mock ( DataSource . class )  ;", "given ( this . dataSource . getConnection (  )  )  . willThrow ( sqlException )  ;", "template    =    new    ( this . dataSource ,    false )  ;", "RowCountCallbackHandler   rcch    =    new   RowCountCallbackHandler (  )  ;", "this . thrown . expect ( CannotGetJdbcConnectionException . class )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "template . query (  \" SELECT   ID ,    FORENAME   FROM   CUSTMR   WHERE   ID    <     3  \"  ,    rcch )  ;", "}", "METHOD_END"], "methodName": ["testCouldntGetConnectionForOperationOrExceptionTranslator"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sqlException    =    new   SQLException (  \" foo \"  ,     \"  0  7 xxx \"  )  ;", "this . dataSource    =    mock ( DataSource . class )  ;", "given ( this . dataSource . getConnection (  )  )  . willThrow ( sqlException )  ;", "this . template    =    new    (  )  ;", "this . template . setDataSource ( this . dataSource )  ;", "this . template . afterPropertiesSet (  )  ;", "RowCountCallbackHandler   rcch    =    new   RowCountCallbackHandler (  )  ;", "this . thrown . expect ( CannotGetJdbcConnectionException . class )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "this . template . query (  \" SELECT   ID ,    FORENAME   FROM   CUSTMR   WHERE   ID    <     3  \"  ,    rcch )  ;", "}", "METHOD_END"], "methodName": ["testCouldntGetConnectionForOperationWithLazyExceptionTranslator"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestCouldntGetConnectionInOperationWithExceptionTranslatorInitialized ( false )  ;", "}", "METHOD_END"], "methodName": ["testCouldntGetConnectionInOperationWithExceptionTranslatorInitializedInAfterPropertiesSet"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestCouldntGetConnectionInOperationWithExceptionTranslatorInitialized ( true )  ;", "}", "METHOD_END"], "methodName": ["testCouldntGetConnectionInOperationWithExceptionTranslatorInitializedViaBeanProperty"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" SELECT   ID   FROM   CUSTMR \"  ;", "final   RuntimeException   runtimeException    =    new   RuntimeException (  \" Expected \"  )  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . preparedStatement )  ;", "this . thrown . expect ( sameInstance ( runtimeException )  )  ;", "try    {", "this . t . query ( sql ,    new   RowCallbackHandler (  )     {", "@ Override", "public   void   processRow ( ResultSet   rs )     {", "throw   runtimeException ;", "}", "}  )  ;", "}    finally    {", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExceptionComesBack"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . resultSet . next (  )  )  . willReturn ( true )  ;", "given ( this . callableStatement . execute (  )  )  . willReturn ( true )  ;", "given ( this . callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "List < SqlParameter >    params    =    new   ArrayList <  >  (  )  ;", "params . add ( new   SqlReturnResultSet (  \"  \"  ,    new   RowCallbackHandler (  )     {", "@ Override", "public   void   processRow ( ResultSet   rs )     {", "throw   new   InvalidDataAccessApiUsageException (  \"  \"  )  ;", "}", "}  )  )  ;", "this . thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "try    {", "this . t . call ( new   CallableStatementCreator (  )     {", "@ Override", "public   CallableStatement   createCallableStatement ( Connection   conn )    throws   SQLException    {", "return   conn . prepareCall (  \" my   query \"  )  ;", "}", "}  ,    params )  ;", "}    finally    {", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . callableStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExecuteClosed"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   forename   from   custmr \"  ;", "SQLWarning   warnings    =    new   SQLWarning (  \" My   warning \"  )  ;", "given ( this . resultSet . next (  )  )  . willReturn ( false )  ;", "given ( this . preparedStatement . getWarnings (  )  )  . willReturn ( warnings )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . preparedStatement )  ;", "t    =    new    ( this . dataSource )  ;", "t . setIgnoreWarnings ( false )  ;", "this . thrown . expect ( SQLWarningException . class )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( warnings )  )  )  ;", "try    {", "t . query ( sql ,    new   RowCallbackHandler (  )     {", "@ Override", "public   void   processRow ( ResultSet   rs )    throws   SQLException    {", "rs . getByte (  1  )  ;", "}", "}  )  ;", "}    finally    {", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testFatalWarning"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   forename   from   custmr \"  ;", "SQLWarning   warnings    =    new   SQLWarning (  \" My   warning \"  )  ;", "given ( this . resultSet . next (  )  )  . willReturn ( false )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . preparedStatement )  ;", "given ( this . preparedStatement . getWarnings (  )  )  . willReturn ( warnings )  ;", "this . t . setIgnoreWarnings ( true )  ;", "this . t . query ( sql ,    new   RowCallbackHandler (  )     {", "@ Override", "public   void   processRow ( ResultSet   rs )    throws   SQLException    {", "rs . getByte (  1  )  ;", "}", "}  )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testIgnoredWarning"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   int [  ]    ids    =    new   int [  ]  {     1  0  0  ,     2  0  0     }  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( this . preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected )  ;", "mockDatabaseMetaData ( true )  ;", "BatchPreparedStatementSetter   setter    =    new   InterruptibleBatchPreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps ,    int   i )    throws   SQLException    {", "if    ( i    <     ( ids . length )  )     {", "ps . setInt (  1  ,    ids [ i ]  )  ;", "}", "}", "@ Override", "public   int   getBatchSize (  )     {", "return    1  0  0  0  ;", "}", "@ Override", "public   boolean   isBatchExhausted ( int   i )     {", "return   i    >  =     ( ids . length )  ;", "}", "}  ;", "template    =    new    ( this . dataSource ,    false )  ;", "int [  ]    actualRowsAffected    =    template . batchUpdate ( sql ,    setter )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( this . preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  0  ]  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  1  ]  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testInterruptibleBatchUpdate"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   int [  ]    ids    =    new   int [  ]  {     1  0  0  ,     2  0  0     }  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( this . preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected )  ;", "mockDatabaseMetaData ( true )  ;", "BatchPreparedStatementSetter   setter    =    new   AbstractInterruptibleBatchPreparedStatementSetter (  )     {", "@ Override", "protected   boolean   setValuesIfAvailable ( PreparedStatement   ps ,    int   i )    throws   SQLException    {", "if    ( i    <     ( ids . length )  )     {", "ps . setInt (  1  ,    ids [ i ]  )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "}  ;", "template    =    new    ( this . dataSource ,    false )  ;", "int [  ]    actualRowsAffected    =    template . batchUpdate ( sql ,    setter )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( this . preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  0  ]  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  1  ]  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testInterruptibleBatchUpdateWithBaseClass"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   int [  ]    ids    =    new   int [  ]  {     1  0  0  ,     2  0  0     }  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( this . preparedStatement . executeUpdate (  )  )  . willReturn ( rowsAffected [  0  ]  ,    rowsAffected [  1  ]  )  ;", "mockDatabaseMetaData ( false )  ;", "BatchPreparedStatementSetter   setter    =    new   AbstractInterruptibleBatchPreparedStatementSetter (  )     {", "@ Override", "protected   boolean   setValuesIfAvailable ( PreparedStatement   ps ,    int   i )    throws   SQLException    {", "if    ( i    <     ( ids . length )  )     {", "ps . setInt (  1  ,    ids [ i ]  )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "}  ;", "template    =    new    ( this . dataSource ,    false )  ;", "int [  ]    actualRowsAffected    =    template . batchUpdate ( sql ,    setter )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( this . preparedStatement ,    never (  )  )  . addBatch (  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  0  ]  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    ids [  1  ]  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testInterruptibleBatchUpdateWithBaseClassAndNoBatchSupport"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   ID ,    FORENAME   FROM   CUSTMR   WHERE   ID    <     3  \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( false )  ;", "given ( this . connection . isClosed (  )  )  . willReturn ( false )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . preparedStatement )  ;", "willThrow ( new   RuntimeException (  )  )  . given ( this . connection )  . close (  )  ;", "SingleConnectionDataSource   scf    =    new   SingleConnectionDataSource ( this . dataSource . getConnection (  )  ,    false )  ;", "this . template    =    new    ( scf ,    false )  ;", "RowCountCallbackHandler   rcch    =    new   RowCountCallbackHandler (  )  ;", "this . template . query ( sql ,    rcch )  ;", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testLeaveConnectionOpenOnRequest"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   FOO   SET   NAME =  ?    WHERE   ID    =     1  \"  ;", "final   String   name    =     \" Gary \"  ;", "SQLException   sqlException    =    new   SQLException (  )  ;", "given ( this . preparedStatement . executeUpdate (  )  )  . willThrow ( sqlException )  ;", "PreparedStatementSetter   pss    =    new   PreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps )    throws   SQLException    {", "ps . setString (  1  ,    name )  ;", "}", "}  ;", "this . thrown . expect ( DataAccessException . class )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "try    {", "new    ( this . dataSource )  . update ( sql ,    pss )  ;", "}    finally    {", "verify ( this . preparedStatement )  . setString (  1  ,    name )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPreparedStatementSetterFails"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   FOO   SET   NAME =  ?    WHERE   ID    =     1  \"  ;", "final   String   name    =     \" Gary \"  ;", "int   expectedRowsUpdated    =     1  ;", "given ( this . preparedStatement . executeUpdate (  )  )  . willReturn ( expectedRowsUpdated )  ;", "PreparedStatementSetter   pss    =    new   PreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps )    throws   SQLException    {", "ps . setString (  1  ,    name )  ;", "}", "}  ;", "int   actualRowsUpdated    =    new    ( this . dataSource )  . update ( sql ,    pss )  ;", "assertTrue (  \" updated   correct    #    of   rows \"  ,     ( actualRowsUpdated    =  =    expectedRowsUpdated )  )  ;", "verify ( this . preparedStatement )  . setString (  1  ,    name )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPreparedStatementSetterSucceeds"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   SQLException   sqlException    =    new   SQLException (  \" I   have   a   known   problem \"  ,     \"  9  9  9  9  9  \"  ,     1  0  5  4  )  ;", "final   String   sql    =     \" SELECT   ID   FROM   CUSTOMER \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true )  ;", "mockDatabaseMetaData ( false )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . preparedStatement )  ;", "this . thrown . expect ( BadSqlGrammarException . class )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "try    {", "this . t . query ( sql ,    new   RowCallbackHandler (  )     {", "@ Override", "public   void   processRow ( ResultSet   rs )    throws   SQLException    {", "throw   sqlException ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   BadSqlGrammarException \"  )  ;", "}    finally    {", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSQLErrorCodeTranslation"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   SQLException   sqlException    =    new   SQLException (  \" I   have   a   known   problem \"  ,     \"  9  9  9  9  9  \"  ,     1  0  5  4  )  ;", "final   String   sql    =     \" SELECT   ID   FROM   CUSTOMER \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . preparedStatement )  ;", "template    =    new    (  )  ;", "template . setDataSource ( this . dataSource )  ;", "template . setDatabaseProductName (  \" MySQL \"  )  ;", "template . afterPropertiesSet (  )  ;", "this . thrown . expect ( BadSqlGrammarException . class )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "try    {", "template . query ( sql ,    new   RowCallbackHandler (  )     {", "@ Override", "public   void   processRow ( ResultSet   rs )    throws   SQLException    {", "throw   sqlException ;", "}", "}  )  ;", "}    finally    {", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSQLErrorCodeTranslationWithSpecifiedDbName"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     4  \"  ;", "int   rowsAffected    =     3  3  ;", "given ( this . statement . executeUpdate ( sql )  )  . willReturn ( rowsAffected )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "int   actualRowsAffected    =    this . t . update ( sql )  ;", "assertTrue (  \" Actual   rows   affected   is   correct \"  ,     ( actualRowsAffected    =  =    rowsAffected )  )  ;", "verify ( this . statement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSqlUpdate"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sqlException    =    new   SQLException (  \" bad   update \"  )  ;", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     4  \"  ;", "given ( this . statement . executeUpdate ( sql )  )  . willThrow ( sqlException )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "try    {", "this . t . update ( sql )  ;", "}    finally    {", "verify ( this . statement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSqlUpdateEncountersSqlException"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?    and   PR    =     ?  \"  ;", "int   rowsAffected    =     3  3  ;", "given ( this . preparedStatement . executeUpdate (  )  )  . willReturn ( rowsAffected )  ;", "int   actualRowsAffected    =    this . t . update ( sql ,    new   Object [  ]  {     4  ,    new   SqlParameterValue ( Types . NUMERIC ,     2  ,    new   Float (  1  .  4  1  4  2  )  )     }  )  ;", "assertTrue (  \" Actual   rows   affected   is   correct \"  ,     ( actualRowsAffected    =  =    rowsAffected )  )  ;", "verify ( this . preparedStatement )  . setObject (  1  ,     4  )  ;", "verify ( this . preparedStatement )  . setObject (  2  ,    new   Float (  1  .  4  1  4  2  )  ,    Types . NUMERIC ,     2  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSqlUpdateWithArguments"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     4  \"  ;", "int   rowsAffected    =     3  3  ;", "given ( this . statement . executeUpdate ( sql )  )  . willReturn ( rowsAffected )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "int   actualRowsAffected    =    this . t . update ( sql )  ;", "assertTrue (  \" Actual   rows   affected   is   correct \"  ,     ( actualRowsAffected    =  =    rowsAffected )  )  ;", "verify ( this . statement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testSqlUpdateWithThreadConnection"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   resultSet 2     =    mock ( ResultSet . class )  ;", "reset ( this . preparedStatement )  ;", "given ( this . preparedStatement . executeQuery (  )  )  . willReturn ( resultSet 2  )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . statement )  ;", "try    {", "this . t . query (  \" my   query \"  ,    new   ResultSetExtractor < Object >  (  )     {", "@ Override", "public   Object   extractData ( ResultSet   rs )     {", "throw   new   InvalidDataAccessApiUsageException (  \"  \"  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   InvalidDataAccessApiUsageException \"  )  ;", "}    catch    ( InvalidDataAccessApiUsageException   idaauex )     {", "}", "try    {", "this . t . query ( new   PreparedStatementCreator (  )     {", "@ Override", "public   PreparedStatement   createPreparedStatement ( Connection   con )    throws   SQLException    {", "return   con . prepareStatement (  \" my   query \"  )  ;", "}", "}  ,    new   ResultSetExtractor < Object >  (  )     {", "@ Override", "public   Object   extractData ( ResultSet   rs 2  )     {", "throw   new   InvalidDataAccessApiUsageException (  \"  \"  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   InvalidDataAccessApiUsageException \"  )  ;", "}    catch    ( InvalidDataAccessApiUsageException   idaauex )     {", "}", "verify ( this . resultSet )  . close (  )  ;", "verify ( resultSet 2  )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testStaticResultSetClosed"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestStrings ( null ,    null ,    null ,    null ,    new   JdbcTemplateTests . JdbcTemplateCallback (  )     {", "@ Override", "public   void   doInJdbcTemplate ( JdbcTemplate   template ,    String   sql ,    RowCallbackHandler   rch )     {", "template . query ( sql ,     (  ( Object [  ]  )     ( null )  )  ,    rch )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testStringsWithEmptyPreparedStatementArgs"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestStrings ( null ,    null ,    null ,    null ,    new   JdbcTemplateTests . JdbcTemplateCallback (  )     {", "@ Override", "public   void   doInJdbcTemplate ( JdbcTemplate   template ,    String   sql ,    RowCallbackHandler   rch )     {", "template . query ( sql ,     (  ( PreparedStatementSetter )     ( null )  )  ,    rch )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testStringsWithEmptyPreparedStatementSetter"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   Integer   argument    =     9  9  ;", "doTestStrings ( null ,    null ,    null ,    argument ,    new    . JdbcTemplateCallback (  )     {", "@ Override", "public   void   doInJdbcTemplate ( JdbcTemplate   template ,    String   sql ,    RowCallbackHandler   rch )     {", "template . query ( sql ,    new   Object [  ]  {    argument    }  ,    rch )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testStringsWithPreparedStatementArgs"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   Integer   argument    =     9  9  ;", "doTestStrings ( null ,    null ,    null ,    argument ,    new    . JdbcTemplateCallback (  )     {", "@ Override", "public   void   doInJdbcTemplate ( JdbcTemplate   template ,    String   sql ,    RowCallbackHandler   rch )     {", "template . query ( sql ,    new   PreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps )    throws   SQLException    {", "ps . setObject (  1  ,    argument )  ;", "}", "}  ,    rch )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testStringsWithPreparedStatementSetter"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestStrings ( null ,    null ,    null ,    null ,    new   JdbcTemplateTests . JdbcTemplateCallback (  )     {", "@ Override", "public   void   doInJdbcTemplate ( JdbcTemplate   template ,    String   sql ,    RowCallbackHandler   rch )     {", "template . query ( sql ,    rch )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testStringsWithStaticSql"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "doTestStrings (  1  0  ,     2  0  ,     3  0  ,    null ,    new   JdbcTemplateTests . JdbcTemplateCallback (  )     {", "@ Override", "public   void   doInJdbcTemplate ( JdbcTemplate   template ,    String   sql ,    RowCallbackHandler   rch )     {", "template . query ( sql ,    rch )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testStringsWithStaticSqlAndFetchSizeAndMaxRows"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   INVOICE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "int   idParam    =     1  1  1  1  1  ;", "given ( this . preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", ". Dispatcher   d    =    new    . Dispatcher ( idParam ,    sql )  ;", "int   rowsAffected    =    this . template . update ( d )  ;", "assertTrue (  \"  1    update   affected    1    row \"  ,     ( rowsAffected    =  =     1  )  )  ;", "verify ( this . preparedStatement )  . setInt (  1  ,    idParam )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testUpdateCount"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   SQLException   sqlException    =    new   SQLException (  \" I   have   a   known   problem \"  ,     \"  0  7  0  0  0  \"  ,     1  0  5  4  )  ;", "final   String   sql    =     \" SELECT   ID   FROM   CUSTOMER \"  ;", "given ( this . resultSet . next (  )  )  . willReturn ( true )  ;", "given ( this . connection . createStatement (  )  )  . willReturn ( this . preparedStatement )  ;", "template    =    new    (  )  ;", "template . setDataSource ( this . dataSource )  ;", "template . setExceptionTranslator ( new   SQLStateSQLExceptionTranslator (  )  )  ;", "template . afterPropertiesSet (  )  ;", "this . thrown . expect ( BadSqlGrammarException . class )  ;", "this . thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "try    {", "template . query ( sql ,    new   RowCallbackHandler (  )     {", "@ Override", "public   void   processRow ( ResultSet   rs )    throws   SQLException    {", "throw   sqlException ;", "}", "}  )  ;", "}    finally    {", "verify ( this . resultSet )  . close (  )  ;", "verify ( this . preparedStatement )  . close (  )  ;", "verify ( this . connection )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUseCustomSQLErrorCodeTranslator"], "fileName": "org.springframework.jdbc.core.JdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . declaredParameters . add ( param )  ;", "}", "METHOD_END"], "methodName": ["addParameter"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   PreparedStatementCreatorFactory . PreparedStatementCreatorImpl (  ( params    !  =    null    ?    Arrays . asList ( params )     :    Collections . emptyList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newPreparedStatementCreator"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   PreparedStatementCreatorFactory . PreparedStatementCreatorImpl ( sqlToUse ,     ( params    !  =    null    ?    Arrays . asList ( params )     :    Collections . emptyList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newPreparedStatementCreator"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   PreparedStatementCreatorFactory . PreparedStatementCreatorImpl (  ( params    !  =    null    ?    params    :    Collections . emptyList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newPreparedStatementCreator"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   PreparedStatementCreatorFactory . PreparedStatementCreatorImpl (  ( params    !  =    null    ?    Arrays . asList ( params )     :    Collections . emptyList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newPreparedStatementSetter"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   PreparedStatementCreatorFactory . PreparedStatementCreatorImpl (  ( params    !  =    null    ?    params    :    Collections . emptyList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["newPreparedStatementSetter"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "this . generatedKeysColumnNames    =    names ;", "}", "METHOD_END"], "methodName": ["setGeneratedKeysColumnNames"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "this . resultSetType    =    resultSetType ;", "}", "METHOD_END"], "methodName": ["setResultSetType"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "this . returnGeneratedKeys    =    returnGeneratedKeys ;", "}", "METHOD_END"], "methodName": ["setReturnGeneratedKeys"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "this . updatableResults    =    updatableResults ;", "}", "METHOD_END"], "methodName": ["setUpdatableResults"], "fileName": "org.springframework.jdbc.core.PreparedStatementCreatorFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . resultSetExtractor ;", "}", "METHOD_END"], "methodName": ["getResultSetExtractor"], "fileName": "org.springframework.jdbc.core.ResultSetSupportingSqlParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . rowCallbackHandler ;", "}", "METHOD_END"], "methodName": ["getRowCallbackHandler"], "fileName": "org.springframework.jdbc.core.ResultSetSupportingSqlParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . rowMapper ;", "}", "METHOD_END"], "methodName": ["getRowMapper"], "fileName": "org.springframework.jdbc.core.ResultSetSupportingSqlParameter"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( this . resultSetExtractor )     !  =    null )     |  |     (  ( this . rowCallbackHandler )     !  =    null )  )     |  |     (  ( this . rowMapper )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isResultSetSupported"], "fileName": "org.springframework.jdbc.core.ResultSetSupportingSqlParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . columnCount ;", "}", "METHOD_END"], "methodName": ["getColumnCount"], "fileName": "org.springframework.jdbc.core.RowCountCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . columnNames ;", "}", "METHOD_END"], "methodName": ["getColumnNames"], "fileName": "org.springframework.jdbc.core.RowCountCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . columnTypes ;", "}", "METHOD_END"], "methodName": ["getColumnTypes"], "fileName": "org.springframework.jdbc.core.RowCountCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . rowCount ;", "}", "METHOD_END"], "methodName": ["getRowCount"], "fileName": "org.springframework.jdbc.core.RowCountCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "result    =    template . query (  (    con )     -  >    preparedStatement ,    testRowMapper )  ;", "verify ( preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["preparedStatementCreatorWithRowMapper"], "fileName": "org.springframework.jdbc.core.RowMapperTests"}, {"methodBody": ["METHOD_START", "{", "result    =    template . query (  \" some   SQL \"  ,     (    ps )     -  >    ps . setString (  1  ,     \" test \"  )  ,    testRowMapper )  ;", "verify ( preparedStatement )  . setString (  1  ,     \" test \"  )  ;", "verify ( preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["preparedStatementSetterWithRowMapper"], "fileName": "org.springframework.jdbc.core.RowMapperTests"}, {"methodBody": ["METHOD_START", "{", "result    =    template . query (  \" some   SQL \"  ,    new   Object [  ]  {     \" test 1  \"  ,     \" test 2  \"     }  ,    testRowMapper )  ;", "preparedStatement . setString (  1  ,     \" test 1  \"  )  ;", "preparedStatement . setString (  2  ,     \" test 2  \"  )  ;", "preparedStatement . close (  )  ;", "}", "METHOD_END"], "methodName": ["queryWithArgsAndRowMapper"], "fileName": "org.springframework.jdbc.core.RowMapperTests"}, {"methodBody": ["METHOD_START", "{", "result    =    template . query (  \" some   SQL \"  ,    new   Object [  ]  {     \" test 1  \"  ,     \" test 2  \"     }  ,    new   int [  ]  {    Types . VARCHAR ,    Types . VARCHAR    }  ,    testRowMapper )  ;", "verify ( preparedStatement )  . setString (  1  ,     \" test 1  \"  )  ;", "verify ( preparedStatement )  . setString (  2  ,     \" test 2  \"  )  ;", "verify ( preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["queryWithArgsAndTypesAndRowMapper"], "fileName": "org.springframework.jdbc.core.RowMapperTests"}, {"methodBody": ["METHOD_START", "{", "given ( connection . createStatement (  )  )  . willReturn ( statement )  ;", "given ( connection . prepareStatement ( anySt (  )  )  )  . willReturn ( preparedStatement )  ;", "given ( statement . executeQuery ( anySt (  )  )  )  . willReturn ( resultSet )  ;", "given ( preparedStatement . executeQuery (  )  )  . willReturn ( resultSet )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getSt (  1  )  )  . willReturn (  \" tb 1  \"  ,     \" tb 2  \"  )  ;", "given ( resultSet . getInt (  2  )  )  . willReturn (  1  ,     2  )  ;", "template . setDataSource ( new   SingleConnectionDataSource ( connection ,    false )  )  ;", "template . setExceptionTranslator ( new   SQLStateSQLExceptionTranslator (  )  )  ;", "template . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.core.RowMapperTests"}, {"methodBody": ["METHOD_START", "{", "result    =    template . query (  \" some   SQL \"  ,    testRowMapper )  ;", "verify ( statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["staticQueryWithRowMapper"], "fileName": "org.springframework.jdbc.core.RowMapperTests"}, {"methodBody": ["METHOD_START", "{", "verify ( resultSet )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["verifyClosed"], "fileName": "org.springframework.jdbc.core.RowMapperTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( result )  ;", "assertEquals (  2  ,    result . size (  )  )  ;", "Bean   testBean 1     =    result . get (  0  )  ;", "Bean   testBean 2     =    result . get (  1  )  ;", "assertEquals (  \" tb 1  \"  ,    testBean 1  . getName (  )  )  ;", "assertEquals (  \" tb 2  \"  ,    testBean 2  . getName (  )  )  ;", "assertEquals (  1  ,    testBean 1  . getAge (  )  )  ;", "assertEquals (  2  ,    testBean 2  . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyResults"], "fileName": "org.springframework.jdbc.core.RowMapperTests"}, {"methodBody": ["METHOD_START", "{", "return   count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.jdbc.core.SimpleRowCountCallbackHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( String . class )     =  =    requiredType )     {", "return   value . toString (  )  ;", "} else", "if    ( Number . class . isAssignableFrom ( requiredType )  )     {", "if    ( value   instanceof   Number )     {", "return   util . NumberUtils . convertNumberToTargetClass (  (  ( Number )     ( value )  )  ,     (  ( Class < Number >  )     ( requiredType )  )  )  ;", "} else    {", "return   util . NumberUtils . parseNumber ( value . toString (  )  ,     (  ( Class < Number >  )     ( requiredType )  )  )  ;", "}", "} else", "if    (  (  ( this . conversionService )     !  =    null )     &  &     ( this . conversionService . canConvert ( value . getClass (  )  ,    requiredType )  )  )     {", "return   this . conversionService . convert ( value ,    requiredType )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  \" Value    [  \"     +    value )     +     \"  ]    is   of   type    [  \"  )     +     ( value . getClass (  )  . getName (  )  )  )     +     \"  ]    and   cannot   be   converted   to   required   type    [  \"  )     +     ( requiredType . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["convertValueToRequiredType"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   JdbcUtils . getResultSetValue ( rs ,    index )  ;", "}", "METHOD_END"], "methodName": ["getColumnValue"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapper"}, {"methodBody": ["METHOD_START", "{", "if    ( requiredType    !  =    null )     {", "return   JdbcUtils . getResultSetValue ( rs ,    index ,    requiredType )  ;", "} else    {", "return   getValue ( rs ,    index )  ;", "}", "}", "METHOD_END"], "methodName": ["getColumnValue"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapper"}, {"methodBody": ["METHOD_START", "{", "return   new   SingleColumnRowMapper <  >  ( requiredType )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapper"}, {"methodBody": ["METHOD_START", "{", "SingleColumnRowMapper < T >    rowMapper    =    SingleColumnRowMapper . newInstance ( requiredType )  ;", "rowMapper . setConversionService ( conversionService )  ;", "return   rowMapper ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapper"}, {"methodBody": ["METHOD_START", "{", "this . conversionService    =    conversionService ;", "}", "METHOD_END"], "methodName": ["setConversionService"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapper"}, {"methodBody": ["METHOD_START", "{", "this . requiredType    =    ClassUtils . resolvePrimitiveIfNecessary ( requiredType )  ;", "}", "METHOD_END"], "methodName": ["setRequiredType"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapper"}, {"methodBody": ["METHOD_START", "{", "SingleColumnRowMapper < LocalDateTime >    rowMapper    =    SingleColumnRowMapper . newInstance ( LocalDateTime . class ,    null )  ;", "ResultSet   resultSet    =    mock ( ResultSet . class )  ;", "ResultSetMetaData   metaData    =    mock ( ResultSetMetaData . class )  ;", "given ( metaData . getColumnCount (  )  )  . willReturn (  1  )  ;", "given ( resultSet . getMetaData (  )  )  . willReturn ( metaData )  ;", "given ( resultSet . getObject (  1  ,    LocalDateTime . class )  )  . willThrow ( new   SQLFeatureNotSupportedException (  )  )  ;", "given ( resultSet . getTimestamp (  1  )  )  . willReturn ( new   Timestamp (  0  )  )  ;", "rowMapper . mapRow ( resultSet ,     1  )  ;", "}", "METHOD_END"], "methodName": ["doesNotUseConversionService"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "Timestamp   timestamp    =    new   Timestamp (  0  )  ;", "DefaultConversionService   myConversionService    =    new   DefaultConversionService (  )  ;", "myConversionService . addConverter ( Timestamp . class ,     . MyLocalDateTime . class ,     (    source )     -  >    new   MyLocalDateTime ( source . toLocalDateTime (  )  )  )  ;", "SingleColumnRowMapper <  . MyLocalDateTime >    rowMapper    =    SingleColumnRowMapper . newInstance (  . MyLocalDateTime . class ,    myConversionService )  ;", "ResultSet   resultSet    =    mock ( ResultSet . class )  ;", "ResultSetMetaData   metaData    =    mock ( ResultSetMetaData . class )  ;", "given ( metaData . getColumnCount (  )  )  . willReturn (  1  )  ;", "given ( resultSet . getMetaData (  )  )  . willReturn ( metaData )  ;", "given ( resultSet . getObject (  1  ,     . MyLocalDateTime . class )  )  . willThrow ( new   SQLFeatureNotSupportedException (  )  )  ;", "given ( resultSet . getObject (  1  )  )  . willReturn ( timestamp )  ;", ". MyLocalDateTime   actualMyLocalDateTime    =    rowMapper . mapRow ( resultSet ,     1  )  ;", "assertNotNull ( actualMyLocalDateTime )  ;", "assertEquals ( timestamp . toLocalDateTime (  )  ,    actualMyLocalDateTime . value )  ;", "}", "METHOD_END"], "methodName": ["useCustomConversionService"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "Timestamp   timestamp    =    new   Timestamp (  0  )  ;", "< LocalDateTime >    rowMapper    =     . newInstance ( LocalDateTime . class )  ;", "ResultSet   resultSet    =    mock ( ResultSet . class )  ;", "ResultSetMetaData   metaData    =    mock ( ResultSetMetaData . class )  ;", "given ( metaData . getColumnCount (  )  )  . willReturn (  1  )  ;", "given ( resultSet . getMetaData (  )  )  . willReturn ( metaData )  ;", "given ( resultSet . getObject (  1  ,    LocalDateTime . class )  )  . willThrow ( new   SQLFeatureNotSupportedException (  )  )  ;", "given ( resultSet . getTimestamp (  1  )  )  . willReturn ( timestamp )  ;", "LocalDateTime   actualLocalDateTime    =    rowMapper . mapRow ( resultSet ,     1  )  ;", "assertEquals ( timestamp . toLocalDateTime (  )  ,    actualLocalDateTime )  ;", "}", "METHOD_END"], "methodName": ["useDefaultConversionService"], "fileName": "org.springframework.jdbc.core.SingleColumnRowMapperTests"}, {"methodBody": ["METHOD_START", "{", "return   this . sqlReturnType ;", "}", "METHOD_END"], "methodName": ["getSqlReturnType"], "fileName": "org.springframework.jdbc.core.SqlOutParameter"}, {"methodBody": ["METHOD_START", "{", "return    ( this . sqlReturnType )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isReturnTypeSupported"], "fileName": "org.springframework.jdbc.core.SqlOutParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.jdbc.core.SqlParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . scale ;", "}", "METHOD_END"], "methodName": ["getScale"], "fileName": "org.springframework.jdbc.core.SqlParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . sqlType ;", "}", "METHOD_END"], "methodName": ["getSqlType"], "fileName": "org.springframework.jdbc.core.SqlParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . typeName ;", "}", "METHOD_END"], "methodName": ["getTypeName"], "fileName": "org.springframework.jdbc.core.SqlParameter"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isInputValueProvided"], "fileName": "org.springframework.jdbc.core.SqlParameter"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isResultsParameter"], "fileName": "org.springframework.jdbc.core.SqlParameter"}, {"methodBody": ["METHOD_START", "{", "if    ( types    =  =    null )     {", "return   new   LinkedList <  >  (  )  ;", "}", "List <  >    result    =    new   ArrayList <  >  ( types . length )  ;", "for    ( int   type    :    types )     {", "result . add ( new    ( type )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["sqlTypesToAnonymousParameterList"], "fileName": "org.springframework.jdbc.core.SqlParameter"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.jdbc.core.SqlParameterValue"}, {"methodBody": ["METHOD_START", "{", "CachedRowSet   rowSet    =    newCachedRowSet (  )  ;", "rowSet . populate ( rs )  ;", "return   new   WrappingSqlRowSet ( rowSet )  ;", "}", "METHOD_END"], "methodName": ["createSqlRowSet"], "fileName": "org.springframework.jdbc.core.SqlRowSetResultSetExtractor"}, {"methodBody": ["METHOD_START", "{", "return   SqlRowSetResultSetExtractor . rowSetFactory . createCachedRowSet (  )  ;", "}", "METHOD_END"], "methodName": ["newCachedRowSet"], "fileName": "org.springframework.jdbc.core.SqlRowSetResultSetExtractor"}, {"methodBody": ["METHOD_START", "{", "if    ( paramValues    !  =    null )     {", ". cleanupParameters ( Arrays . asList ( paramValues )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupParameters"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( paramValues    !  =    null )     {", "for    ( Object   inValue    :    paramValues )     {", "if    ( inValue   instanceof   DisposableSqlTypeValue )     {", "(  ( DisposableSqlTypeValue )     ( inValue )  )  . cleanup (  )  ;", "} else", "if    ( inValue   instanceof   support . SqlValue )     {", "(  ( support . SqlValue )     ( inValue )  )  . cleanup (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["cleanupParameters"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( Date . class . isAssignableFrom ( inValueType )  )     &  &     (  !  (  (  ( isAssignableFrom ( inValueType )  )     |  |     ( Time . class . isAssignableFrom ( inValueType )  )  )     |  |     ( Timestamp . class . isAssignableFrom ( inValueType )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDateValue"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( CharSequence . class . isAssignableFrom ( inValueType )  )     |  |     ( StringWriter . class . isAssignableFrom ( inValueType )  )  ;", "}", "METHOD_END"], "methodName": ["isStringValue"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( javaType    =  =    null )     {", "return   SqlTypeValue . TYPE _ UNKNOWN ;", "}", "Integer   sqlType    =     . get ( javaType )  ;", "if    ( sqlType    !  =    null )     {", "return   sqlType ;", "}", "if    ( Number . class . isAssignableFrom ( javaType )  )     {", "return   Types . NUMERIC ;", "}", "if    (  . isStringValue ( javaType )  )     {", "return   Types . VARCHAR ;", "}", "if    (  (  . isDateValue ( javaType )  )     |  |     ( Calendar . class . isAssignableFrom ( javaType )  )  )     {", "return   Types . TIMESTAMP ;", "}", "return   SqlTypeValue . TYPE _ UNKNOWN ;", "}", "METHOD_END"], "methodName": ["javaTypeToSqlParameterType"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sqlType    =  =     ( SqlTypeValue . TYPE _ UNKNOWN )  )     |  |     (  ( sqlType    =  =     ( Types . OTHER )  )     &  &     ( typeName    =  =    null )  )  )     {", "boolean   useSetObject    =    false ;", "Integer   sqlTypeToUse    =    null ;", "if    (  !  (  . shouldIgnoreGetParameterType )  )     {", "try    {", "sqlTypeToUse    =    ps . getParameterMetaData (  )  . getParameterType ( paramIndex )  ;", "}    catch    ( SQLException   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" JDBC   getParameterType   call   failed    -    using   fallback   method   instead :     \"     +    ex )  )  ;", "}", "}", "}", "if    ( sqlTypeToUse    =  =    null )     {", "sqlTypeToUse    =    Types . NULL ;", "DatabaseMetaData   dbmd    =    ps . getConnection (  )  . getMetaData (  )  ;", "String   jdbcDriverName    =    dbmd . getDriverName (  )  ;", "String   databaseProductName    =    dbmd . getDatabaseProductName (  )  ;", "if    (  ( databaseProductName . startsWith (  \" Informix \"  )  )     |  |     (  ( jdbcDriverName . startsWith (  \" Microsoft \"  )  )     &  &     ( jdbcDriverName . contains (  \" SQL   Server \"  )  )  )  )     {", "useSetObject    =    true ;", "} else", "if    (  (  (  ( databaseProductName . startsWith (  \" DB 2  \"  )  )     |  |     ( jdbcDriverName . startsWith (  \" jConnect \"  )  )  )     |  |     ( jdbcDriverName . startsWith (  \" SQLServer \"  )  )  )     |  |     ( jdbcDriverName . startsWith (  \" Apache   Derby \"  )  )  )     {", "sqlTypeToUse    =    Types . VARCHAR ;", "}", "}", "if    ( useSetObject )     {", "ps . setObject ( paramIndex ,    null )  ;", "} else    {", "ps . setNull ( paramIndex ,    sqlTypeToUse )  ;", "}", "} else", "if    ( typeName    !  =    null )     {", "ps . setNull ( paramIndex ,    sqlType ,    typeName )  ;", "} else    {", "ps . setNull ( paramIndex ,    sqlType )  ;", "}", "}", "METHOD_END"], "methodName": ["setNull"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . setParameterValueInternal ( ps ,    paramIndex ,    sqlType ,    null ,    null ,    inValue )  ;", "}", "METHOD_END"], "methodName": ["setParameterValue"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . setParameterValueInternal ( ps ,    paramIndex ,    sqlType ,    typeName ,    null ,    inValue )  ;", "}", "METHOD_END"], "methodName": ["setParameterValue"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . setParameterValueInternal ( ps ,    paramIndex ,    param . getSqlType (  )  ,    param . getTypeName (  )  ,    param . getScale (  )  ,    inValue )  ;", "}", "METHOD_END"], "methodName": ["setParameterValue"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "String   typeNameToUse    =    typeName ;", "int   sqlTypeToUse    =    sqlType ;", "Object   inValueToUse    =    inValue ;", "if    ( inValue   instanceof   SqlParameterValue )     {", "SqlParameterValue   parameterValue    =     (  ( SqlParameterValue )     ( inValue )  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  (  \" Overriding   type   info   with   runtime   info   from   SqlParameterValue :    column   index    \"     +    paramIndex )     +     \"  ,    SQL   type    \"  )     +     ( parameterValue . getSqlType (  )  )  )     +     \"  ,    type   name    \"  )     +     ( parameterValue . getTypeName (  )  )  )  )  ;", "}", "if    (  ( parameterValue . getSqlType (  )  )     !  =     ( SqlTypeValue . TYPE _ UNKNOWN )  )     {", "sqlTypeToUse    =    parameterValue . getSqlType (  )  ;", "}", "if    (  ( parameterValue . getTypeName (  )  )     !  =    null )     {", "typeNameToUse    =    parameterValue . getTypeName (  )  ;", "}", "inValueToUse    =    parameterValue . getValue (  )  ;", "}", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  (  (  (  (  (  \" Setting   SQL   statement   parameter   value :    column   index    \"     +    paramIndex )     +     \"  ,    parameter   value    [  \"  )     +    inValueToUse )     +     \"  ]  ,    value   class    [  \"  )     +     ( inValueToUse    !  =    null    ?    inValueToUse . getClass (  )  . getName (  )     :     \" null \"  )  )     +     \"  ]  ,    SQL   type    \"  )     +     ( sqlTypeToUse    =  =     ( SqlTypeValue . TYPE _ UNKNOWN )     ?     \" unknown \"     :    Integer . toString ( sqlTypeToUse )  )  )  )  ;", "}", "if    ( inValueToUse    =  =    null )     {", ". setNull ( ps ,    paramIndex ,    sqlTypeToUse ,    typeNameToUse )  ;", "} else    {", ". setValue ( ps ,    paramIndex ,    sqlTypeToUse ,    typeNameToUse ,    scale ,    inValueToUse )  ;", "}", "}", "METHOD_END"], "methodName": ["setParameterValueInternal"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( inValue   instanceof   SqlTypeValue )     {", "(  ( SqlTypeValue )     ( inValue )  )  . setTypeValue ( ps ,    paramIndex ,    sqlType ,    typeName )  ;", "} else", "if    ( inValue   instanceof   support . SqlValue )     {", "(  ( support . SqlValue )     ( inValue )  )  . setValue ( ps ,    paramIndex )  ;", "} else", "if    (  ( sqlType    =  =     ( VARCHAR )  )     |  |     ( sqlType    =  =     ( LONGVARCHAR )  )  )     {", "ps . setString ( paramIndex ,    inValue . toString (  )  )  ;", "} else", "if    (  ( sqlType    =  =     ( NVARCHAR )  )     |  |     ( sqlType    =  =     ( LONGNVARCHAR )  )  )     {", "ps . setNString ( paramIndex ,    inValue . toString (  )  )  ;", "} else", "if    (  (  ( sqlType    =  =     ( CLOB )  )     |  |     ( sqlType    =  =     ( NCLOB )  )  )     &  &     ( StatementCreatorUtils . isStringValue ( inValue . getClass (  )  )  )  )     {", "String   strVal    =    inValue . toString (  )  ;", "if    (  ( strVal . length (  )  )     >     4  0  0  0  )     {", "if    ( sqlType    =  =     ( NCLOB )  )     {", "ps . setNClob ( paramIndex ,    new   StringReader ( strVal )  ,    strVal . length (  )  )  ;", "} else    {", "ps . setClob ( paramIndex ,    new   StringReader ( strVal )  ,    strVal . length (  )  )  ;", "}", "return ;", "} else    {", "if    ( sqlType    =  =     ( NCLOB )  )     {", "ps . setNString ( paramIndex ,    strVal )  ;", "} else    {", "ps . setString ( paramIndex ,    strVal )  ;", "}", "}", "} else", "if    (  ( sqlType    =  =     ( DECIMAL )  )     |  |     ( sqlType    =  =     ( NUMERIC )  )  )     {", "if    ( inValue   instanceof   BigDecimal )     {", "ps . setBigDecimal ( paramIndex ,     (  ( BigDecimal )     ( inValue )  )  )  ;", "} else", "if    ( scale    !  =    null )     {", "ps . setObject ( paramIndex ,    inValue ,    sqlType ,    scale )  ;", "} else    {", "ps . setObject ( paramIndex ,    inValue ,    sqlType )  ;", "}", "} else", "if    ( sqlType    =  =     ( BOOLEAN )  )     {", "if    ( inValue   instanceof   Boolean )     {", "ps . setBoolean ( paramIndex ,     (  ( Boolean )     ( inValue )  )  )  ;", "} else    {", "ps . setObject ( paramIndex ,    inValue ,    BOOLEAN )  ;", "}", "} else", "if    ( sqlType    =  =     ( DATE )  )     {", "if    ( inValue   instanceof   Date )     {", "if    ( inValue   instanceof   Date )     {", "ps . setDate ( paramIndex ,     (  ( Date )     ( inValue )  )  )  ;", "} else    {", "ps . setDate ( paramIndex ,    new   Date (  (  ( Date )     ( inValue )  )  . getTime (  )  )  )  ;", "}", "} else", "if    ( inValue   instanceof   Calendar )     {", "Calendar   cal    =     (  ( Calendar )     ( inValue )  )  ;", "ps . setDate ( paramIndex ,    new   Date ( cal . getTime (  )  . getTime (  )  )  ,    cal )  ;", "} else    {", "ps . setObject ( paramIndex ,    inValue ,    DATE )  ;", "}", "} else", "if    ( sqlType    =  =     ( TIME )  )     {", "if    ( inValue   instanceof   Date )     {", "if    ( inValue   instanceof   Time )     {", "ps . setTime ( paramIndex ,     (  ( Time )     ( inValue )  )  )  ;", "} else    {", "ps . setTime ( paramIndex ,    new   Time (  (  ( Date )     ( inValue )  )  . getTime (  )  )  )  ;", "}", "} else", "if    ( inValue   instanceof   Calendar )     {", "Calendar   cal    =     (  ( Calendar )     ( inValue )  )  ;", "ps . setTime ( paramIndex ,    new   Time ( cal . getTime (  )  . getTime (  )  )  ,    cal )  ;", "} else    {", "ps . setObject ( paramIndex ,    inValue ,    TIME )  ;", "}", "} else", "if    ( sqlType    =  =     ( TIMESTAMP )  )     {", "if    ( inValue   instanceof   Date )     {", "if    ( inValue   instanceof   Timestamp )     {", "ps . setTimestamp ( paramIndex ,     (  ( Timestamp )     ( inValue )  )  )  ;", "} else    {", "ps . setTimestamp ( paramIndex ,    new   Timestamp (  (  ( Date )     ( inValue )  )  . getTime (  )  )  )  ;", "}", "} else", "if    ( inValue   instanceof   Calendar )     {", "Calendar   cal    =     (  ( Calendar )     ( inValue )  )  ;", "ps . setTimestamp ( paramIndex ,    new   Timestamp ( cal . getTime (  )  . getTime (  )  )  ,    cal )  ;", "} else    {", "ps . setObject ( paramIndex ,    inValue ,    TIMESTAMP )  ;", "}", "} else", "if    (  ( sqlType    =  =     ( SqlTypeValue . TYPE _ UNKNOWN )  )     |  |     (  ( sqlType    =  =     ( OTHER )  )     &  &     (  \" Oracle \"  . equals ( ps . getConnection (  )  . getMetaData (  )  . getDatabaseProductName (  )  )  )  )  )     {", "if    ( StatementCreatorUtils . isStringValue ( inValue . getClass (  )  )  )     {", "ps . setString ( paramIndex ,    inValue . toString (  )  )  ;", "} else", "if    ( StatementCreatorUtils . isDateValue ( inValue . getClass (  )  )  )     {", "ps . setTimestamp ( paramIndex ,    new   Timestamp (  (  ( Date )     ( inValue )  )  . getTime (  )  )  )  ;", "} else", "if    ( inValue   instanceof   Calendar )     {", "Calendar   cal    =     (  ( Calendar )     ( inValue )  )  ;", "ps . setTimestamp ( paramIndex ,    new   Timestamp ( cal . getTime (  )  . getTime (  )  )  ,    cal )  ;", "} else    {", "ps . setObject ( paramIndex ,    inValue )  ;", "}", "} else    {", "ps . setObject ( paramIndex ,    inValue ,    sqlType )  ;", "}", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtils"}, {"methodBody": ["METHOD_START", "{", "preparedStatement    =    mock ( PreparedStatement . class )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Calendar   cal    =    new   GregorianCalendar (  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    SqlTypeValue . TYPE _ UNKNOWN ,    null ,    cal )  ;", "verify ( preparedStatement )  . setTimestamp (  1  ,    new   Timestamp ( cal . getTime (  )  . getTime (  )  )  ,    cal )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithCalendarAndUnknownType"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Calendar   cal    =    new   GregorianCalendar (  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . DATE ,    null ,    cal )  ;", "verify ( preparedStatement )  . setDate (  1  ,    new   Date ( cal . getTime (  )  . getTime (  )  )  ,    cal )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithDateAndCalendar"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Date   date    =    new   Date (  1  0  0  0  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    SqlTypeValue . TYPE _ UNKNOWN ,    null ,    date )  ;", "verify ( preparedStatement )  . setTimestamp (  1  ,    new   Timestamp (  1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithDateAndUnknownType"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Date   date    =    new   Date (  1  0  0  0  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . DATE ,    null ,    date )  ;", "verify ( preparedStatement )  . setDate (  1  ,    new   Date (  1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithDateAndUtilDate"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "ParameterMetaData   pmd    =    mock ( ParameterMetaData . class )  ;", "given ( preparedStatement . getParameterMetaData (  )  )  . willReturn ( pmd )  ;", "given ( pmd . getParameterType (  1  )  )  . willReturn ( Types . SMALLINT )  ;", ". setParameterValue ( preparedStatement ,     1  ,    SqlTypeValue . TYPE _ UNKNOWN ,    null ,    null )  ;", "verify ( pmd )  . getParameterType (  1  )  ;", "verify ( preparedStatement ,    never (  )  )  . getConnection (  )  ;", "verify ( preparedStatement )  . setNull (  1  ,    Types . SMALLINT )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithNullAndGetParameterTypeWorking"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . setParameterValue ( preparedStatement ,     1  ,    Types . VARCHAR ,    null ,    null )  ;", "verify ( preparedStatement )  . setNull (  1  ,    Types . VARCHAR )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithNullAndType"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . setParameterValue ( preparedStatement ,     1  ,    Types . VARCHAR ,     \" mytype \"  ,    null )  ;", "verify ( preparedStatement )  . setNull (  1  ,    Types . VARCHAR ,     \" mytype \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithNullAndTypeName"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . shouldIgnoreGetParameterType    =    true ;", "Connection   con    =    mock ( Connection . class )  ;", "DatabaseMetaData   dbmd    =    mock ( DatabaseMetaData . class )  ;", "given ( preparedStatement . getConnection (  )  )  . willReturn ( con )  ;", "given ( dbmd . getDatabaseProductName (  )  )  . willReturn (  \" Oracle \"  )  ;", "given ( dbmd . getDriverName (  )  )  . willReturn (  \" Oracle   Driver \"  )  ;", "given ( con . getMetaData (  )  )  . willReturn ( dbmd )  ;", "StatementCreatorUtils . setParameterValue ( preparedStatement ,     1  ,    SqlTypeValue . TYPE _ UNKNOWN ,    null ,    null )  ;", "verify ( preparedStatement )  . setNull (  1  ,    Types . NULL )  ;", "StatementCreatorUtils . shouldIgnoreGetParameterType    =    false ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithNullAndUnknownType"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . shouldIgnoreGetParameterType    =    true ;", "Connection   con    =    mock ( Connection . class )  ;", "DatabaseMetaData   dbmd    =    mock ( DatabaseMetaData . class )  ;", "given ( preparedStatement . getConnection (  )  )  . willReturn ( con )  ;", "given ( con . getMetaData (  )  )  . willReturn ( dbmd )  ;", "given ( dbmd . getDatabaseProductName (  )  )  . willReturn (  \" Apache   Derby \"  )  ;", "given ( dbmd . getDriverName (  )  )  . willReturn (  \" Apache   Derby   Embedded   Driver \"  )  ;", "StatementCreatorUtils . setParameterValue ( preparedStatement ,     1  ,    SqlTypeValue . TYPE _ UNKNOWN ,    null ,    null )  ;", "verify ( dbmd )  . getDatabaseProductName (  )  ;", "verify ( dbmd )  . getDriverName (  )  ;", "verify ( preparedStatement )  . setNull (  1  ,    Types . VARCHAR )  ;", "StatementCreatorUtils . shouldIgnoreGetParameterType    =    false ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithNullAndUnknownTypeOnDerbyEmbedded"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . shouldIgnoreGetParameterType    =    true ;", "Connection   con    =    mock ( Connection . class )  ;", "DatabaseMetaData   dbmd    =    mock ( DatabaseMetaData . class )  ;", "given ( preparedStatement . getConnection (  )  )  . willReturn ( con )  ;", "given ( con . getMetaData (  )  )  . willReturn ( dbmd )  ;", "given ( dbmd . getDatabaseProductName (  )  )  . willReturn (  \" Informix   Dynamic   Server \"  )  ;", "given ( dbmd . getDriverName (  )  )  . willReturn (  \" Informix   Driver \"  )  ;", "StatementCreatorUtils . setParameterValue ( preparedStatement ,     1  ,    SqlTypeValue . TYPE _ UNKNOWN ,    null ,    null )  ;", "verify ( dbmd )  . getDatabaseProductName (  )  ;", "verify ( dbmd )  . getDriverName (  )  ;", "verify ( preparedStatement )  . setObject (  1  ,    null )  ;", "StatementCreatorUtils . shouldIgnoreGetParameterType    =    false ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithNullAndUnknownTypeOnInformix"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . shouldIgnoreGetParameterType    =    true ;", "Connection   con    =    mock ( Connection . class )  ;", "DatabaseMetaData   dbmd    =    mock ( DatabaseMetaData . class )  ;", "given ( preparedStatement . getConnection (  )  )  . willReturn ( con )  ;", "given ( dbmd . getDatabaseProductName (  )  )  . willReturn (  \" Oracle \"  )  ;", "given ( dbmd . getDriverName (  )  )  . willReturn (  \" Oracle   Driver \"  )  ;", "given ( con . getMetaData (  )  )  . willReturn ( dbmd )  ;", "StatementCreatorUtils . setParameterValue ( preparedStatement ,     1  ,    Types . OTHER ,    null ,    null )  ;", "verify ( preparedStatement )  . setNull (  1  ,    Types . NULL )  ;", "StatementCreatorUtils . shouldIgnoreGetParameterType    =    false ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithNullAndVendorSpecificType"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Date   date    =    new   Date (  1  0  0  0  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . DATE ,    null ,    date )  ;", "verify ( preparedStatement )  . setDate (  1  ,    date )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithSqlDate"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Time   time    =    new   Time (  1  0  0  0  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . TIME ,    null ,    time )  ;", "verify ( preparedStatement )  . setTime (  1  ,    time )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithSqlTime"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Timestamp   timestamp    =    new   Timestamp (  1  0  0  0  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . TIMESTAMP ,    null ,    timestamp )  ;", "verify ( preparedStatement )  . setTimestamp (  1  ,    timestamp )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithSqlTimestamp"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . setParameterValue ( preparedStatement ,     1  ,    Types . VARCHAR ,    null ,     \" test \"  )  ;", "verify ( preparedStatement )  . setString (  1  ,     \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithString"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . setParameterValue ( preparedStatement ,     1  ,    Types . CHAR ,    null ,     \" test \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     \" test \"  ,    Types . CHAR )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithStringAndSpecialType"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StatementCreatorUtils . setParameterValue ( preparedStatement ,     1  ,    SqlTypeValue . TYPE _ UNKNOWN ,    null ,     \" test \"  )  ;", "verify ( preparedStatement )  . setString (  1  ,     \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithStringAndUnknownType"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Connection   con    =    mock ( Connection . class )  ;", "DatabaseMetaData   dbmd    =    mock ( DatabaseMetaData . class )  ;", "given ( preparedStatement . getConnection (  )  )  . willReturn ( con )  ;", "given ( dbmd . getDatabaseProductName (  )  )  . willReturn (  \" Oracle \"  )  ;", "given ( con . getMetaData (  )  )  . willReturn ( dbmd )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . OTHER ,    null ,     \" test \"  )  ;", "verify ( preparedStatement )  . setString (  1  ,     \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithStringAndVendorSpecificType"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Calendar   cal    =    new   GregorianCalendar (  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . TIME ,    null ,    cal )  ;", "verify ( preparedStatement )  . setTime (  1  ,    new   Time ( cal . getTime (  )  . getTime (  )  )  ,    cal )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithTimeAndCalendar"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Date   date    =    new   Date (  1  0  0  0  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . TIME ,    null ,    date )  ;", "verify ( preparedStatement )  . setTime (  1  ,    new   Time (  1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithTimeAndUtilDate"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Calendar   cal    =    new   GregorianCalendar (  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . TIMESTAMP ,    null ,    cal )  ;", "verify ( preparedStatement )  . setTimestamp (  1  ,    new   Timestamp ( cal . getTime (  )  . getTime (  )  )  ,    cal )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithTimestampAndCalendar"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Date   date    =    new   Date (  1  0  0  0  )  ;", ". setParameterValue ( preparedStatement ,     1  ,    Types . TIMESTAMP ,    null ,    date )  ;", "verify ( preparedStatement )  . setTimestamp (  1  ,    new   Timestamp (  1  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterValueWithTimestampAndUtilDate"], "fileName": "org.springframework.jdbc.core.StatementCreatorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . metaDataProvider )     !  =    null )  ,     \" No   CallMetaDataProvider   available \"  )  ;", "StringBuilder   callString ;", "int   parameterCount    =     0  ;", "String   catalogNameToUse ;", "String   schemaNameToUse ;", "if    (  ( this . metaDataProvider . isSupportsSchemasInProcedureCalls (  )  )     &  &     (  !  ( this . metaDataProvider . isSupportsCatalogsInProcedureCalls (  )  )  )  )     {", "schemaNameToUse    =    this . metaDataProvider . catalogNameToUse ( getCatalogName (  )  )  ;", "catalogNameToUse    =    this . metaDataProvider . schemaNameToUse ( getSchemaName (  )  )  ;", "} else    {", "catalogNameToUse    =    this . metaDataProvider . catalogNameToUse ( getCatalogName (  )  )  ;", "schemaNameToUse    =    this . metaDataProvider . schemaNameToUse ( getSchemaName (  )  )  ;", "}", "String   procedureNameToUse    =    this . metaDataProvider . procedureNameToUse ( getProcedureName (  )  )  ;", "if    (  ( isFunction (  )  )     |  |     ( isReturnValueRequired (  )  )  )     {", "callString    =    new   StringBuilder (  )  . append (  \"  {  ?     =    call    \"  )  . append (  ( StringUtils . hasLength ( catalogNameToUse )     ?    catalogNameToUse    +     \"  .  \"     :     \"  \"  )  )  . append (  ( StringUtils . hasLength ( schemaNameToUse )     ?    schemaNameToUse    +     \"  .  \"     :     \"  \"  )  )  . append ( procedureNameToUse )  . append (  \"  (  \"  )  ;", "parameterCount    =     -  1  ;", "} else    {", "callString    =    new   StringBuilder (  )  . append (  \"  { call    \"  )  . append (  ( StringUtils . hasLength ( catalogNameToUse )     ?    catalogNameToUse    +     \"  .  \"     :     \"  \"  )  )  . append (  ( StringUtils . hasLength ( schemaNameToUse )     ?    schemaNameToUse    +     \"  .  \"     :     \"  \"  )  )  . append ( procedureNameToUse )  . append (  \"  (  \"  )  ;", "}", "for    ( SqlParameter   parameter    :    this . callParameters )     {", "if    (  !  ( parameter . isResultsParameter (  )  )  )     {", "if    ( parameterCount    >     0  )     {", "callString . append (  \"  ,     \"  )  ;", "}", "if    ( parameterCount    >  =     0  )     {", "callString . append ( createParameterBinding ( parameter )  )  ;", "}", "parameterCount +  +  ;", "}", "}", "callString . append (  \"  )  }  \"  )  ;", "return   callString . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createCallString"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   isNamedBinding (  )     ?     ( parameter . getName (  )  )     +     \"     =  >     ?  \"     :     \"  ?  \"  ;", "}", "METHOD_END"], "methodName": ["createParameterBinding"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "CallMetaDataProvider   provider    =    obtainMetaDataProvider (  )  ;", "if    ( provider . isReturnResultSetSupported (  )  )     {", "return   new   SqlReturnResultSet ( parameterName ,    rowMapper )  ;", "} else    {", "if    ( provider . isRefCursorSupported (  )  )     {", "return   new   SqlOutParameter ( parameterName ,    provider . getRefCursorSqlType (  )  ,    rowMapper )  ;", "} else    {", "throw   new   InvalidDataAccessApiUsageException (  \" Return   of   a   ResultSet   from   a   stored   procedure   is   not   supported \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createReturnResultSetParameter"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . callParameters ;", "}", "METHOD_END"], "methodName": ["getCallParameters"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . catalogName ;", "}", "METHOD_END"], "methodName": ["getCatalogName"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return    ( this . actualFunctionReturnName )     !  =    null    ?    this . actualFunctionReturnName    :     \" return \"  ;", "}", "METHOD_END"], "methodName": ["getFunctionReturnName"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . limitedInParameterNames ;", "}", "METHOD_END"], "methodName": ["getLimitedInParameterNames"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . outParameterNames ;", "}", "METHOD_END"], "methodName": ["getOutParameterNames"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . procedureName ;", "}", "METHOD_END"], "methodName": ["getProcedureName"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "if    ( isFunction (  )  )     {", "return   getFunctionReturnName (  )  ;", "} else    {", "if    (  ( this . outPaterNames . size (  )  )     >     1  )     {", "logger . warn (  \" Accessing   single   output   value   when   procedure   has   more   than   one   output   pater \"  )  ;", "}", "return    !  ( this . outPaterNames . isEmpty (  )  )     ?    this . outPaterNames . get (  0  )     :    null ;", "}", "}", "METHOD_END"], "methodName": ["getScalarOutParameterName"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . schemaName ;", "}", "METHOD_END"], "methodName": ["getSchemaName"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . metaDataProvider    =    CallMetaDataProviderFactory . createMetaDataProvider ( dataSource ,    this )  ;", "}", "METHOD_END"], "methodName": ["initializeMetaData"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . accessCallParameterMetaData ;", "}", "METHOD_END"], "methodName": ["isAccessCallParameterMetaData"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . function ;", "}", "METHOD_END"], "methodName": ["isFunction"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . namedBinding ;", "}", "METHOD_END"], "methodName": ["isNamedBinding"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . returnValueRequired ;", "}", "METHOD_END"], "methodName": ["isReturnValueRequired"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   paramName    !  =    null    ?    paramName . toLowerCase (  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["lowerCase"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    matchedParameters    =    new   HashMap <  >  ( parameterValues . length )  ;", "int   i    =     0  ;", "for    ( SqlParameter   parameter    :    this . callParameters )     {", "if    ( parameter . isInputValueProvided (  )  )     {", "String   parameterName    =    parameter . getName (  )  ;", "matchedParameters . put ( parameterName ,    parameterValues [  ( i +  +  )  ]  )  ;", "}", "}", "return   matchedParameters ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithCallParameters"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "CallMetaDataProvider   provider    =    obtainMetaDataProvider (  )  ;", "if    (  !  ( provider . isProcedureColumnMetaDataUsed (  )  )  )     {", "return   inParameters ;", "}", "Map < String ,    String >    callParameterNames    =    new   HashMap <  >  ( this . callParameters . size (  )  )  ;", "for    ( SqlParameter   parameter    :    this . callParameters )     {", "if    ( parameter . isInputValueProvided (  )  )     {", "String   parameterName    =    parameter . getName (  )  ;", "String   parameterNameToMatch    =    provider . parameterNameToUse ( parameterName )  ;", "if    ( parameterNameToMatch    !  =    null )     {", "callParameterNames . put ( parameterNameToMatch . toLowerCase (  )  ,    parameterName )  ;", "}", "}", "}", "Map < String ,    Object >    matchedParameters    =    new   HashMap <  >  ( inParameters . size (  )  )  ;", "inParameters . forEach (  (    parameterName ,    parameterValue )     -  >     {", "String   parameterNameToMatch    =    provider . parameterNameToUse ( parameterName )  ;", "String   callParameterName    =    callParameterNames . get (  . lowerCase ( parameterNameToMatch )  )  ;", "if    ( callParameterName    =  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "Object   value    =    parameterValue ;", "if    ( value   instanceof   SqlParameterValue )     {", "value    =     (  ( SqlParameterValue )     ( value )  )  . getValue (  )  ;", "}", "if    ( value    !  =    null )     {", "logger . debug (  (  (  (  \" Unable   to   locate   the   corresponding   IN   or   IN - OUT   parameter   for    \\  \"  \"     +    parameterName )     +     \"  \\  \"    in   the   parameters   used :     \"  )     +     ( callParameterNames . keySet (  )  )  )  )  ;", "}", "}", "} else    {", "matchedParameters . put ( callParameterName ,    parameterValue )  ;", "}", "}  )  ;", "if    (  ( matchedParameters . size (  )  )     <     ( callParameterNames . size (  )  )  )     {", "for    ( String   parameterName    :    callParameterNames . keySet (  )  )     {", "String   parameterNameToMatch    =    provider . parameterNameToUse ( parameterName )  ;", "String   callParameterName    =    callParameterNames . get (  . lowerCase ( parameterNameToMatch )  )  ;", "if    (  !  ( matchedParameters . containsKey ( callParameterName )  )  )     {", "logger . warn (  (  (  (  \" Unable   to   locate   the   corresponding   parameter   value   for    '  \"     +    parameterName )     +     \"  '    within   the   parameter   values   provided :     \"  )     +     ( inParameters . keySet (  )  )  )  )  ;", "}", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Matching    \"     +     ( inParameters . keySet (  )  )  )     +     \"    with    \"  )     +     ( callParameterNames . values (  )  )  )  )  ;", "logger . debug (  (  \" Found   match   for    \"     +     ( matchedParameters . keySet (  )  )  )  )  ;", "}", "return   matchedParameters ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithCallParameters"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    caseInsensitiveParameterNames    =    SqlParameterSourceUtils . extractCaseInsensitiveParameterNames ( parameterSource )  ;", "Map < String ,    String >    callParameterNames    =    new   HashMap <  >  ( this . callParameters . size (  )  )  ;", "Map < String ,    Object >    matchedParameters    =    new   HashMap <  >  ( this . callParameters . size (  )  )  ;", "for    ( SqlParameter   parameter    :    this . callParameters )     {", "if    ( parameter . isInputValueProvided (  )  )     {", "String   parameterName    =    parameter . getName (  )  ;", "String   parameterNameToMatch    =    obtainProvider (  )  . parameterNameToUse ( parameterName )  ;", "if    ( parameterNameToMatch    !  =    null )     {", "callParameterNames . put ( parameterNameToMatch . toLowerCase (  )  ,    parameterName )  ;", "}", "if    ( parameterName    !  =    null )     {", "if    ( parameterSource . hasValue ( parameterName )  )     {", "matchedParameters . put ( parameterName ,    SqlParameterSourceUtils . getTypedValue ( parameterSource ,    parameterName )  )  ;", "} else    {", "String   lowerCaseName    =    parameterName . toLowerCase (  )  ;", "if    ( parameterSource . hasValue ( lowerCaseName )  )     {", "matchedParameters . put ( parameterName ,    SqlParameterSourceUtils . getTypedValue ( parameterSource ,    lowerCaseName )  )  ;", "} else    {", "String   englishLowerCaseName    =    parameterName . toLowerCase ( Locale . ENGLISH )  ;", "if    ( parameterSource . hasValue ( englishLowerCaseName )  )     {", "matchedParameters . put ( parameterName ,    SqlParameterSourceUtils . getTypedValue ( parameterSource ,    englishLowerCaseName )  )  ;", "} else    {", "String   propertyName    =    JdbcUtils . convertUnderscoreNameToPropertyName ( parameterName )  ;", "if    ( parameterSource . hasValue ( propertyName )  )     {", "matchedParameters . put ( parameterName ,    SqlParameterSourceUtils . getTypedValue ( parameterSource ,    propertyName )  )  ;", "} else    {", "if    ( caseInsensitiveParameterNames . containsKey ( lowerCaseName )  )     {", "String   sourceName    =    caseInsensitiveParameterNames . get ( lowerCaseName )  ;", "matchedParameters . put ( parameterName ,    SqlParameterSourceUtils . getTypedValue ( parameterSource ,    sourceName )  )  ;", "} else    {", "logger . warn (  (  (  (  \" Unable   to   locate   the   corresponding   parameter   value   for    '  \"     +    parameterName )     +     \"  '    within   the   parameter   values   provided :     \"  )     +     ( caseInsensitiveParameterNames . values (  )  )  )  )  ;", "}", "}", "}", "}", "}", "}", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Matching    \"     +     ( caseInsensitiveParameterNames . values (  )  )  )     +     \"    with    \"  )     +     ( callParameterNames . values (  )  )  )  )  ;", "logger . debug (  (  \" Found   match   for    \"     +     ( matchedParameters . keySet (  )  )  )  )  ;", "}", "return   matchedParameters ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithCallParameters"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . metaDataProvider )     !  =    null )  ,     \" No   CallMetaDataProvider    -    call   initializeMetaData   first \"  )  ;", "return   this . metaDataProvider ;", "}", "METHOD_END"], "methodName": ["obtainMetaDataProvider"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . callParameters    =    reconcileParameters ( parameters )  ;", "}", "METHOD_END"], "methodName": ["processParameters"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "CallMetaDataProvider   provider    =    obtainMetaDataProvider (  )  ;", "final   List < SqlParameter >    declaredReturnParams    =    new   ArrayList <  >  (  )  ;", "final   Map < String ,    SqlParameter >    declaredParams    =    new   LinkedHashMap <  >  (  )  ;", "boolean   returnDeclared    =    false ;", "List < String >    outParamNames    =    new   ArrayList <  >  (  )  ;", "List < String >    metaDataParamNames    =    new   ArrayList <  >  (  )  ;", "for    ( CallParameterMetaData   meta    :    provider . getCallParameterMetaData (  )  )     {", "if    (  !  ( meta . isReturnParameter (  )  )  )     {", "metaDataParamNames . add (  . lowerCase ( meta . getParameterName (  )  )  )  ;", "}", "}", "for    ( SqlParameter   param    :    parameters )     {", "if    ( param . isResultsParameter (  )  )     {", "declaredReturnParams . add ( param )  ;", "} else    {", "String   paramName    =    param . getName (  )  ;", "if    ( paramName    =  =    null )     {", "throw   new   IllegalArgumentException (  (  (  \" Anonymous   parameters   not   supported   for   calls    -     \"     +     \" please   specify   a   name   for   the   parameter   of   SQL   type    \"  )     +     ( param . getSqlType (  )  )  )  )  ;", "}", "String   paramNameToMatch    =     . lowerCase ( provider . parameterNameToUse ( paramName )  )  ;", "declaredParams . put ( paramNameToMatch ,    param )  ;", "if    ( param   instanceof   SqlOutParameter )     {", "outParamNames . add ( paramName )  ;", "if    (  (  ( isFunction (  )  )     &  &     (  !  ( metaDataParamNames . contains ( paramNameToMatch )  )  )  )     &  &     (  ! returnDeclared )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Using   declared   out   parameter    '  \"     +    paramName )     +     \"  '    for   function   return   value \"  )  )  ;", "}", "setFunctionReturnName ( paramName )  ;", "returnDeclared    =    true ;", "}", "}", "}", "}", "setOutParameterNames ( outParamNames )  ;", "List < SqlParameter >    workParams    =    new   ArrayList <  >  (  )  ;", "workParams . addAll ( declaredReturnParams )  ;", "if    (  !  ( provider . isProcedureColumnMetaDataUsed (  )  )  )     {", "workParams . addAll ( declaredParams . values (  )  )  ;", "return   workParams ;", "}", "Map < String ,    String >    limitedInParamNamesMap    =    new   HashMap <  >  ( this . limitedInParameterNames . size (  )  )  ;", "for    ( String   limitedParamName    :    this . limitedInParameterNames )     {", "limitedInParamNamesMap . put (  . lowerCase ( provider . parameterNameToUse ( limitedParamName )  )  ,    limitedParamName )  ;", "}", "for    ( CallParameterMetaData   meta    :    provider . getCallParameterMetaData (  )  )     {", "String   paramName    =    meta . getParameterName (  )  ;", "String   paramNameToCheck    =    null ;", "if    ( paramName    !  =    null )     {", "paramNameToCheck    =     . lowerCase ( provider . parameterNameToUse ( paramName )  )  ;", "}", "String   paramNameToUse    =    provider . parameterNameToUse ( paramName )  ;", "if    (  ( declaredParams . containsKey ( paramNameToCheck )  )     |  |     (  ( meta . isReturnParameter (  )  )     &  &    returnDeclared )  )     {", "SqlParameter   param ;", "if    ( meta . isReturnParameter (  )  )     {", "param    =    declaredParams . get ( getFunctionReturnName (  )  )  ;", "if    (  ( param    =  =    null )     &  &     (  !  ( getOutParameterNames (  )  . isEmpty (  )  )  )  )     {", "param    =    declaredParams . get ( getOutParameterNames (  )  . get (  0  )  . toLowerCase (  )  )  ;", "}", "if    ( param    =  =    null )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  \" Unable   to   locate   declared   parameter   for   function   return   value    -     \"     +     \"    add   a   SqlOutParameter   with   name    '  \"  )     +     ( getFunctionReturnName (  )  )  )     +     \"  '  \"  )  )  ;", "} else", "if    ( paramName    !  =    null )     {", "setFunctionReturnName ( paramName )  ;", "}", "} else    {", "param    =    declaredParams . get ( paramNameToCheck )  ;", "}", "if    ( param    !  =    null )     {", "workParams . add ( param )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Using   declared   parameter   for    '  \"     +     ( paramNameToUse    !  =    null    ?    paramNameToUse    :    getFunctionReturnName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "}", "} else    {", "if    ( meta . isReturnParameter (  )  )     {", "if    (  (  (  (  !  ( isFunction (  )  )  )     &  &     (  !  ( isReturnValueRequired (  )  )  )  )     &  &     ( paramName    !  =    null )  )     &  &     ( provider . byPassReturnParameter ( paramName )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Bypassing   meta - data   return   parameter   for    '  \"     +    paramName )     +     \"  '  \"  )  )  ;", "}", "} else    {", "String   returnNameToUse    =     ( StringUtils . hasLength ( paramNameToUse )  )     ?    paramNameToUse    :    getFunctionReturnName (  )  ;", "workParams . add ( provider . createDefaultOutParameter ( returnNameToUse ,    meta )  )  ;", "if    ( isFunction (  )  )     {", "setFunctionReturnName ( returnNameToUse )  ;", "outParamNames . add ( returnNameToUse )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Added   meta - data   return   parameter   for    '  \"     +    returnNameToUse )     +     \"  '  \"  )  )  ;", "}", "}", "} else    {", "if    ( paramNameToUse    =  =    null )     {", "paramNameToUse    =     \"  \"  ;", "}", "if    (  ( meta . getParameterType (  )  )     =  =     ( DatabaseMetaData . procedureColumnOut )  )     {", "workParams . add ( provider . createDefaultOutParameter ( paramNameToUse ,    meta )  )  ;", "outParamNames . add ( paramNameToUse )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Added   meta - data   out   parameter   for    '  \"     +    paramNameToUse )     +     \"  '  \"  )  )  ;", "}", "} else", "if    (  ( meta . getParameterType (  )  )     =  =     ( DatabaseMetaData . procedureColumnInOut )  )     {", "workParams . add ( provider . createDefaultInOutParameter ( paramNameToUse ,    meta )  )  ;", "outParamNames . add ( paramNameToUse )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Added   meta - data   in - out   parameter   for    '  \"     +    paramNameToUse )     +     \"  '  \"  )  )  ;", "}", "} else    {", "if    (  ( this . limitedInParameterNames . isEmpty (  )  )     |  |     ( limitedInParamNamesMap . containsKey (  . lowerCase ( paramNameToUse )  )  )  )     {", "workParams . add ( provider . createDefaultInParameter ( paramNameToUse ,    meta )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Added   meta - data   in   parameter   for    '  \"     +    paramNameToUse )     +     \"  '  \"  )  )  ;", "}", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Limited   set   of   parameters    \"     +     ( limitedInParamNamesMap . keySet (  )  )  )     +     \"    skipped   parameter   for    '  \"  )     +    paramNameToUse )     +     \"  '  \"  )  )  ;", "}", "}", "}", "}", "}", "}", "return   workParams ;", "}", "METHOD_END"], "methodName": ["reconcileParameters"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . accessCallParameterMetaData    =    accessCallParameterMetaData ;", "}", "METHOD_END"], "methodName": ["setAccessCallParameterMetaData"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . catalogName    =    catalogName ;", "}", "METHOD_END"], "methodName": ["setCatalogName"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . function    =    function ;", "}", "METHOD_END"], "methodName": ["setFunction"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . actualFunctionReturnName    =    functionReturnName ;", "}", "METHOD_END"], "methodName": ["setFunctionReturnName"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . limitedInParameterNames    =    limitedInParameterNames ;", "}", "METHOD_END"], "methodName": ["setLimitedInParameterNames"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . namedBinding    =    namedBinding ;", "}", "METHOD_END"], "methodName": ["setNamedBinding"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . outParameterNames    =    outParameterNames ;", "}", "METHOD_END"], "methodName": ["setOutParameterNames"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . procedureName    =    procedureName ;", "}", "METHOD_END"], "methodName": ["setProcedureName"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . returnValueRequired    =    returnValueRequired ;", "}", "METHOD_END"], "methodName": ["setReturnValueRequired"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . schemaName    =    schemaName ;", "}", "METHOD_END"], "methodName": ["setSchemaName"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( CallMetaDataProvider )     ( JdbcUtils . extractDatabaseMetaData ( dataSource ,     (    databaseMetaData )     -  >     {", "String   databaseProductName    =    JdbcUtils . commonDatabaseName ( databaseMetaData . getDatabaseProductName (  )  )  ;", "boolean   accessProcedureColumnMetaData    =    context . isAccessCallParameterMetaData (  )  ;", "if    ( context . isFunction (  )  )     {", "if    (  !  (  . supportedDatabaseProductsForFunctions . contains ( databaseProductName )  )  )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  (  ( databaseProductName    +     \"    is   not   one   of   the   databases   fully   supported   for   function   calls    \"  )     +     \"  -  -    supported   are :     \"  )     +     (  . supportedDatabaseProductsForFunctions )  )  )  ;", "}", "if    ( accessProcedureColumnMetaData )     {", ". logger . warn (  \" Metadata   processing   disabled    -    you   must   specify   all   parameters   explicitly \"  )  ;", "accessProcedureColumnMetaData    =    false ;", "}", "}", "} else    {", "if    (  !  (  . supportedDatabaseProductsForProcedures . contains ( databaseProductName )  )  )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  (  ( databaseProductName    +     \"    is   not   one   of   the   databases   fully   supported   for   procedure   calls    \"  )     +     \"  -  -    supported   are :     \"  )     +     (  . supportedDatabaseProductsForProcedures )  )  )  ;", "}", "if    ( accessProcedureColumnMetaData )     {", ". logger . warn (  \" Metadata   processing   disabled    -    you   must   specify   all   parameters   explicitly \"  )  ;", "accessProcedureColumnMetaData    =    false ;", "}", "}", "}", "CallMetaDataProvider   provider ;", "if    (  \" Oracle \"  . equals ( databaseProductName )  )     {", "provider    =    new   OracleCallMetaDataProvider ( databaseMetaData )  ;", "} else", "if    (  \" PostgreSQL \"  . equals ( databaseProductName )  )     {", "provider    =    new   PostgresCallMetaDataProvider ( databaseMetaData )  ;", "} else", "if    (  \" Apache   Derby \"  . equals ( databaseProductName )  )     {", "provider    =    new   DerbyCallMetaDataProvider ( databaseMetaData )  ;", "} else", "if    (  \" DB 2  \"  . equals ( databaseProductName )  )     {", "provider    =    new   Db 2 CallMetaDataProvider ( databaseMetaData )  ;", "} else", "if    (  \" HDB \"  . equals ( databaseProductName )  )     {", "provider    =    new   HanaCallMetaDataProvider ( databaseMetaData )  ;", "} else", "if    (  \" Microsoft   SQL   Server \"  . equals ( databaseProductName )  )     {", "provider    =    new   SqlServerCallMetaDataProvider ( databaseMetaData )  ;", "} else", "if    (  \" Sybase \"  . equals ( databaseProductName )  )     {", "provider    =    new   SybaseCallMetaDataProvider ( databaseMetaData )  ;", "} else    {", "provider    =    new   GenericCallMetaDataProvider ( databaseMetaData )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Using    \"     +     ( provider . getClass (  )  . getName (  )  )  )  )  ;", "}", "provider . initializeWithMetaData ( databaseMetaData )  ;", "if    ( accessProcedureColumnMetaData )     {", "provider . initializeWithProcedureColumnMetaData ( databaseMetaData ,    context . getCatalogName (  )  ,    context . getSchemaName (  )  ,    context . getProcedureName (  )  )  ;", "}", "return   provider ;", "}  )  )  )  ;", "}    catch    ( MetaDataAccessException   ex )     {", "throw   new   DataAccessResourceFailureException (  \" Error   retrieving   database   meta - data \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createMetaDataProvider"], "fileName": "org.springframework.jdbc.core.metadata.CallMetaDataProviderFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterName ;", "}", "METHOD_END"], "methodName": ["getParameterName"], "fileName": "org.springframework.jdbc.core.metadata.CallParameterMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterType ;", "}", "METHOD_END"], "methodName": ["getParameterType"], "fileName": "org.springframework.jdbc.core.metadata.CallParameterMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . sqlType ;", "}", "METHOD_END"], "methodName": ["getSqlType"], "fileName": "org.springframework.jdbc.core.metadata.CallParameterMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . typeName ;", "}", "METHOD_END"], "methodName": ["getTypeName"], "fileName": "org.springframework.jdbc.core.metadata.CallParameterMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . nullable ;", "}", "METHOD_END"], "methodName": ["isNullable"], "fileName": "org.springframework.jdbc.core.metadata.CallParameterMetaData"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . parameterType )     =  =     ( DatabaseMetaData . procedureColumnReturn )  )     |  |     (  ( this . parameterType )     =  =     ( DatabaseMetaData . procedureColumnResult )  )  ;", "}", "METHOD_END"], "methodName": ["isReturnParameter"], "fileName": "org.springframework.jdbc.core.metadata.CallParameterMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . storesLowerCaseIdentifiers ;", "}", "METHOD_END"], "methodName": ["isStoresLowerCaseIdentifiers"], "fileName": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "return   this . storesUpperCaseIdentifiers ;", "}", "METHOD_END"], "methodName": ["isStoresUpperCaseIdentifiers"], "fileName": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "String   metaDataCatalogName    =    metaDataCatalogNameToUse ( catalogName )  ;", "String   metaDataSchemaName    =    metaDataSchemaNameToUse ( schemaName )  ;", "String   metaDataProcedureName    =    procedureNameToUse ( procedureName )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  (  \" Retrieving   meta - data   for    \"     +    metaDataCatalogName )     +     '  /  '  )     +    metaDataSchemaName )     +     '  /  '  )     +    metaDataProcedureName )  )  ;", "}", "ResultSet   procs    =    null ;", "try    {", "procs    =    databaseMetaData . getProcedures ( metaDataCatalogName ,    metaDataSchemaName ,    metaDataProcedureName )  ;", "List < String >    found    =    new   ArrayList <  >  (  )  ;", "while    ( procs . next (  )  )     {", "found . add (  (  (  (  (  ( procs . getString (  \" PROCEDURE _ CAT \"  )  )     +     '  .  '  )     +     ( procs . getString (  \" PROCEDURE _ SCHEM \"  )  )  )     +     '  .  '  )     +     ( procs . getString (  \" PROCEDURE _ NAME \"  )  )  )  )  ;", "}", "procs . close (  )  ;", "if    (  ( found . size (  )  )     >     1  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  (  \" Unable   to   determine   the   correct   call   signature    -    multiple    \"     +     \" procedures / functions / signatures   for    '  \"  )     +    metaDataProcedureName )     +     \"  '  :    found    \"  )     +    found )  )  ;", "} else", "if    ( found . isEmpty (  )  )     {", "if    (  (  ( metaDataProcedureName    !  =    null )     &  &     ( metaDataProcedureName . contains (  \"  .  \"  )  )  )     &  &     (  !  ( hasText ( metaDataCatalogName )  )  )  )     {", "String   packageName    =    metaDataProcedureName . substring (  0  ,    metaDataProcedureName . indexOf (  '  .  '  )  )  ;", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  (  \" Unable   to   determine   the   correct   call   signature   for    '  \"     +    metaDataProcedureName )     +     \"  \\  '     -    package   name   should   be   specified   separately   using    \\  '  . withCatalogName (  \\  \"  \"  )     +    packageName )     +     \"  \\  \"  )  \\  '  \"  )  )  ;", "} else", "if    (  \" Oracle \"  . equals ( databaseMetaData . getDatabaseProductName (  )  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Oracle   JDBC   driver   did   not   return   procedure / function / signature   for    '  \"     +    metaDataProcedureName )     +     \"  '     -    assuming   a   non - exposed   synonym \"  )  )  ;", "}", "} else    {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  \" Unable   to   determine   the   correct   call   signature    -    no    \"     +     \" procedure / function / signature   for    '  \"  )     +    metaDataProcedureName )     +     \"  '  \"  )  )  ;", "}", "}", "procs    =    databaseMetaData . getProcedureColumns ( metaDataCatalogName ,    metaDataSchemaName ,    metaDataProcedureName ,    null )  ;", "while    ( procs . next (  )  )     {", "String   columnName    =    procs . getString (  \" COLUMN _ NAME \"  )  ;", "int   columnType    =    procs . getInt (  \" COLUMN _ TYPE \"  )  ;", "if    (  ( columnName    =  =    null )     &  &     (  (  ( columnType    =  =     ( DatabaseMetaData . procedureColumnIn )  )     |  |     ( columnType    =  =     ( DatabaseMetaData . procedureColumnInOut )  )  )     |  |     ( columnType    =  =     ( DatabaseMetaData . procedureColumnOut )  )  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  (  (  (  (  \" Skipping   meta - data   for :     \"     +    columnType )     +     \"     \"  )     +     ( procs . getInt (  \" DATA _ TYPE \"  )  )  )     +     \"     \"  )     +     ( procs . getString (  \" TYPE _ NAME \"  )  )  )     +     \"     \"  )     +     ( procs . getInt (  \" NULLABLE \"  )  )  )     +     \"     ( probably   a   member   of   a   collection )  \"  )  )  ;", "}", "} else    {", "CallParameterMetaData   meta    =    new   CallParameterMetaData ( columnName ,    columnType ,    procs . getInt (  \" DATA _ TYPE \"  )  ,    procs . getString (  \" TYPE _ NAME \"  )  ,     (  ( procs . getInt (  \" NULLABLE \"  )  )     =  =     ( DatabaseMetaData . procedureNullable )  )  )  ;", "this . callParameterMetaData . add ( meta )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  (  (  (  (  (  \" Retrieved   meta - data :     \"     +     ( meta . getParameterName (  )  )  )     +     \"     \"  )     +     ( meta . getParameterType (  )  )  )     +     \"     \"  )     +     ( meta . getSqlType (  )  )  )     +     \"     \"  )     +     ( meta . getTypeName (  )  )  )     +     \"     \"  )     +     ( meta . isNullable (  )  )  )  )  ;", "}", "}", "}", "}    catch    ( SQLException   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  \" Error   while   retrieving   meta - data   for   procedure   columns :     \"     +    ex )  )  ;", "}", "}    finally    {", "try    {", "if    ( procs    !  =    null )     {", "procs . close (  )  ;", "}", "}    catch    ( SQLException   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  \" Problem   closing   ResultSet   for   procedure   column   meta - data :     \"     +    ex )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["processProcedureColumns"], "fileName": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "this . storesLowerCaseIdentifiers    =    storesLowerCaseIdentifiers ;", "}", "METHOD_END"], "methodName": ["setStoresLowerCaseIdentifiers"], "fileName": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "this . storesUpperCaseIdentifiers    =    storesUpperCaseIdentifiers ;", "}", "METHOD_END"], "methodName": ["setStoresUpperCaseIdentifiers"], "fileName": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "this . supportsCatalogsInProcedureCalls    =    supportsCatalogsInProcedureCalls ;", "}", "METHOD_END"], "methodName": ["setSupportsCatalogsInProcedureCalls"], "fileName": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "this . supportsSchemasInProcedureCalls    =    supportsSchemasInProcedureCalls ;", "}", "METHOD_END"], "methodName": ["setSupportsSchemasInProcedureCalls"], "fileName": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( schemaName    !  =    null )     {", ". TableMetaData   tmd    =    tableMeta . get ( schemaName . toUpperCase (  )  )  ;", "if    ( tmd    =  =    null )     {", "throw   new   DataAccessResourceFailureException (  (  (  (  (  \" Unable   to   locate   table   meta - data   for    '  \"     +    tableName )     +     \"  '    in   the    '  \"  )     +    schemaName )     +     \"  '    schema \"  )  )  ;", "}", "return   tmd ;", "} else", "if    (  ( tableMeta . size (  )  )     =  =     1  )     {", "return   tableMeta . values (  )  . iterator (  )  . next (  )  ;", "} else    {", ". TableMetaData   tmd    =    tableMeta . get ( getDefaultSchema (  )  )  ;", "if    ( tmd    =  =    null )     {", "tmd    =    tableMeta . get (  (  ( this . userName )     !  =    null    ?    this . userName . toUpperCase (  )     :     \"  \"  )  )  ;", "}", "if    ( tmd    =  =    null )     {", "tmd    =    tableMeta . get (  \" PUBLIC \"  )  ;", "}", "if    ( tmd    =  =    null )     {", "tmd    =    tableMeta . get (  \" DBO \"  )  ;", "}", "if    ( tmd    =  =    null )     {", "throw   new   DataAccessResourceFailureException (  (  (  \" Unable   to   locate   table   meta - data   for    '  \"     +    tableName )     +     \"  '    in   the   default   schema \"  )  )  ;", "}", "return   tmd ;", "}", "}", "METHOD_END"], "methodName": ["findTableMetaData"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "return   this . databaseVersion ;", "}", "METHOD_END"], "methodName": ["getDatabaseVersion"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "return   this . userName ;", "}", "METHOD_END"], "methodName": ["getDefaultSchema"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "return   this . storesLowerCaseIdentifiers ;", "}", "METHOD_END"], "methodName": ["isStoresLowerCaseIdentifiers"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "return   this . storesUpperCaseIdentifiers ;", "}", "METHOD_END"], "methodName": ["isStoresUpperCaseIdentifiers"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    GenericTableMetaDataProvider . TableMetaData >    tableMeta    =    new   HashMap <  >  (  )  ;", "ResultSet   tables    =    null ;", "try    {", "tables    =    databaseMetaData . getTables ( catalogNameToUse ( catalogName )  ,    schemaNameToUse ( schemaName )  ,    tableNameToUse ( tableName )  ,    null )  ;", "while    (  ( tables    !  =    null )     &  &     ( tables . next (  )  )  )     {", "GenericTableMetaDataProvider . TableMetaData   tmd    =    new   GenericTableMetaDataProvider . TableMetaData (  )  ;", "tmd . setCatalogName ( tables . getString (  \" TABLE _ CAT \"  )  )  ;", "tmd . setSchemaName ( tables . getString (  \" TABLE _ SCHEM \"  )  )  ;", "tmd . setTableName ( tables . getString (  \" TABLE _ NAME \"  )  )  ;", "if    (  ( tmd . getSchemaName (  )  )     =  =    null )     {", "tableMeta . put (  (  ( this . userName )     !  =    null    ?    this . userName . toUpperCase (  )     :     \"  \"  )  ,    tmd )  ;", "} else    {", "tableMeta . put ( tmd . getSchemaName (  )  . toUpperCase (  )  ,    tmd )  ;", "}", "}", "}    catch    ( SQLException   ex )     {", "if    ( GenericTableMetaDataProvider . logger . isWarnEnabled (  )  )     {", "GenericTableMetaDataProvider . logger . warn (  (  \" Error   while   accessing   table   meta - data   results :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}    finally    {", "JdbcUtils . closeResultSet ( tables )  ;", "}", "if    ( tableMeta . isEmpty (  )  )     {", "if    ( GenericTableMetaDataProvider . logger . isWarnEnabled (  )  )     {", "GenericTableMetaDataProvider . logger . warn (  (  (  \" Unable   to   locate   table   meta - data   for    '  \"     +    tableName )     +     \"  '  :    column   names   must   be   provided \"  )  )  ;", "}", "} else    {", "processTableColumns ( databaseMetaData ,    findTableMetaData ( schemaName ,    tableName ,    tableMeta )  )  ;", "}", "}", "METHOD_END"], "methodName": ["locateTableAndProcessMetaData"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "ResultSet   tableColumns    =    null ;", "String   metaDataCatalogName    =    metaDataCatalogNameToUse ( tmd . getCatalogName (  )  )  ;", "String   metaDataSchemaName    =    metaDataSchemaNameToUse ( tmd . getSchemaName (  )  )  ;", "String   metaDataTableName    =    tableNameToUse ( tmd . getTableName (  )  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  (  \" Retrieving   meta - data   for    \"     +    metaDataCatalogName )     +     '  /  '  )     +    metaDataSchemaName )     +     '  /  '  )     +    metaDataTableName )  )  ;", "}", "try    {", "tableColumns    =    databaseMetaData . getColumns ( metaDataCatalogName ,    metaDataSchemaName ,    metaDataTableName ,    null )  ;", "while    ( tableColumns . next (  )  )     {", "String   columnName    =    tableColumns . getString (  \" COLUMN _ NAME \"  )  ;", "int   dataType    =    tableColumns . getInt (  \" DATA _ TYPE \"  )  ;", "if    ( dataType    =  =     ( Types . DECIMAL )  )     {", "String   typeName    =    tableColumns . getString (  \" TYPE _ NAME \"  )  ;", "int   decimalDigits    =    tableColumns . getInt (  \" DECIMAL _ DIGITS \"  )  ;", "if    (  (  \" NUMBER \"  . equals ( typeName )  )     &  &     ( decimalDigits    =  =     0  )  )     {", "dataType    =    Types . NUMERIC ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Overriding   meta - data :     \"     +    columnName )     +     \"    now   NUMERIC   instead   of   DECIMAL \"  )  )  ;", "}", "}", "}", "boolean   nullable    =    tableColumns . getBoolean (  \" NULLABLE \"  )  ;", "TableParameterMetaData   meta    =    new   TableParameterMetaData ( columnName ,    dataType ,    nullable )  ;", "this . tableParameterMetaData . add ( meta )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  (  \" Retrieved   meta - data :     \"     +     ( meta . getParameterName (  )  )  )     +     \"     \"  )     +     ( meta . getSqlType (  )  )  )     +     \"     \"  )     +     ( meta . isNullable (  )  )  )  )  ;", "}", "}", "}    catch    ( SQLException   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  \" Error   while   retrieving   meta - data   for   table   columns :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}    finally    {", "JdbcUtils . closeResultSet ( tableColumns )  ;", "}", "}", "METHOD_END"], "methodName": ["processTableColumns"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "this . generatedKeysColumnNameArraySupported    =    generatedKeysColumnNameArraySupported ;", "}", "METHOD_END"], "methodName": ["setGeneratedKeysColumnNameArraySupported"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "this . getGeneratedKeysSupported    =    getGeneratedKeysSupported ;", "}", "METHOD_END"], "methodName": ["setGetGeneratedKeysSupported"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "this . storesLowerCaseIdentifiers    =    storesLowerCaseIdentifiers ;", "}", "METHOD_END"], "methodName": ["setStoresLowerCaseIdentifiers"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "this . storesUpperCaseIdentifiers    =    storesUpperCaseIdentifiers ;", "}", "METHOD_END"], "methodName": ["setStoresUpperCaseIdentifiers"], "fileName": "org.springframework.jdbc.core.metadata.GenericTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "try    {", "CallableStatement   cstmt    =    null ;", "try    {", "Connection   con    =    databaseMetaData . getConnection (  )  ;", "if    ( con    =  =    null )     {", "Generic . logger . debug (  \" Cannot   check   default   schema    -    no   Connection   from   DatabaseMetaData \"  )  ;", "return   null ;", "}", "cstmt    =    con . prepareCall (  \"  {  ?     =    call   sys _ context (  ' USERENV '  ,     ' CURRENT _ SCHEMA '  )  }  \"  )  ;", "cstmt . registerOutParameter (  1  ,    Types . VARCHAR )  ;", "cstmt . execute (  )  ;", "return   cstmt . getString (  1  )  ;", "}    finally    {", "if    ( cstmt    !  =    null )     {", "cstmt . close (  )  ;", "}", "}", "}    catch    ( SQLException   ex )     {", "Generic . logger . debug (  \" Exception   encountered   during   default   schema   lookup \"  ,    ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["lookupDefaultSchema"], "fileName": "org.springframework.jdbc.core.metadata.OracleTableMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "Set < String >    keys    =    new   LinkedHashSet <  >  ( generatedKeyNames . length )  ;", "for    ( String   key    :    generatedKeyNames )     {", "keys . add ( key . toUpperCase (  )  )  ;", "}", "StringBuilder   insertStatement    =    new   StringBuilder (  )  ;", "insertStatement . append (  \" INSERT   INTO    \"  )  ;", "if    (  ( getSchemaName (  )  )     !  =    null )     {", "insertStatement . append ( getSchemaName (  )  )  ;", "insertStatement . append (  \"  .  \"  )  ;", "}", "insertStatement . append ( getName (  )  )  ;", "insertStatement . append (  \"     (  \"  )  ;", "int   columnCount    =     0  ;", "for    ( String   columnName    :    getColumns (  )  )     {", "if    (  !  ( keys . contains ( columnName . toUpperCase (  )  )  )  )     {", "columnCount +  +  ;", "if    ( columnCount    >     1  )     {", "insertStatement . append (  \"  ,     \"  )  ;", "}", "insertStatement . append ( columnName )  ;", "}", "}", "insertStatement . append (  \"  )    VALUES (  \"  )  ;", "if    ( columnCount    <     1  )     {", "if    ( this . generatedKeyColumnsUsed )     {", "logger . info (  (  (  \" Unable   to   locate   non - key   columns   for   table    '  \"     +     ( getName (  )  )  )     +     \"  '    so   an   empty   insert   statement   is   generated \"  )  )  ;", "} else    {", "throw   new   InvalidDataAccessApiUsageException (  (  (  \" Unable   to   locate   columns   for   table    '  \"     +     ( getName (  )  )  )     +     \"  '    so   an   insert   statement   can ' t   be   generated \"  )  )  ;", "}", "}", "for    ( int   i    =     0  ;    i    <    columnCount ;    i +  +  )     {", "if    ( i    >     0  )     {", "insertStatement . append (  \"  ,     \"  )  ;", "}", "insertStatement . append (  \"  ?  \"  )  ;", "}", "insertStatement . append (  \"  )  \"  )  ;", "return   insertStatement . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createInsertString"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "int [  ]    types    =    new   int [ getTableColumns (  )  . size (  )  ]  ;", "List < TableParameter >    parameters    =    obtainProvider (  )  . getTableParameter (  )  ;", "Map < String ,    TableParameter >    parameterMap    =    new   LinkedHashMap <  >  ( parameters . size (  )  )  ;", "for    ( TableParameter   tpmd    :    parameters )     {", "parameterMap . put ( tpmd . getParameterName (  )  . toUpperCase (  )  ,    tpmd )  ;", "}", "int   typeIndx    =     0  ;", "for    ( String   column    :    getTableColumns (  )  )     {", "if    ( column    =  =    null )     {", "types [ typeIndx ]     =    SqlTypeValue . TYPE _ UNKNOWN ;", "} else    {", "TableParameter   tpmd    =    parameterMap . get ( column . toUpperCase (  )  )  ;", "if    ( tpmd    !  =    null )     {", "types [ typeIndx ]     =    tpmd . getSqlType (  )  ;", "} else    {", "types [ typeIndx ]     =    SqlTypeValue . TYPE _ UNKNOWN ;", "}", "}", "typeIndx +  +  ;", "}", "return   types ;", "}", "METHOD_END"], "methodName": ["createInsertTypes"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . catalogName ;", "}", "METHOD_END"], "methodName": ["getCatalogName"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . schemaName ;", "}", "METHOD_END"], "methodName": ["getSchemaName"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   obtainMetaDataProvider (  )  . getSimpleQueryForGetGeneratedKey ( tableName ,    keyColumnName )  ;", "}", "METHOD_END"], "methodName": ["getSimpleQueryForGetGeneratedKey"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   getSimpleQueryForGetGeneratedKey ( tableName ,    keyColumnName )  ;", "}", "METHOD_END"], "methodName": ["getSimulationQueryForGetGeneratedKey"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . tableColumns ;", "}", "METHOD_END"], "methodName": ["getTableColumns"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . tableName ;", "}", "METHOD_END"], "methodName": ["getTableName"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . accessTableColumnMetaData ;", "}", "METHOD_END"], "methodName": ["isAccessTableColumnMetaData"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   obtainMetaDataProvider (  )  . isGeneratedKeysColumnNameArraySupported (  )  ;", "}", "METHOD_END"], "methodName": ["isGeneratedKeysColumnNameArraySupported"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   obtainMetaDataProvider (  )  . isGetGeneratedKeysSimulated (  )  ;", "}", "METHOD_END"], "methodName": ["isGetGeneratedKeysSimulated"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   obtainMetaDataProvider (  )  . isGetGeneratedKeysSupported (  )  ;", "}", "METHOD_END"], "methodName": ["isGetGeneratedKeysSupported"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "return   this . overrideIncludeSynonymsDefault ;", "}", "METHOD_END"], "methodName": ["isOverrideIncludeSynonymsDefault"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "List < Object >    values    =    new   ArrayList <  >  ( inParameters . size (  )  )  ;", "for    ( String   column    :    this . tableColumns )     {", "Object   value    =    inParameters . get ( column )  ;", "if    ( value    =  =    null )     {", "value    =    inParameters . get ( column . toLowerCase (  )  )  ;", "if    ( value    =  =    null )     {", "for    ( Map . Entry < String ,     ?  >    entry    :    inParameters . entrySet (  )  )     {", "if    ( column . equalsIgnoreCase ( entry . getKey (  )  )  )     {", "value    =    entry . getValue (  )  ;", "}", "}", "}", "}", "values . add ( value )  ;", "}", "return   values ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithInsertColumns"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "List < Object >    values    =    new   ArrayList <  >  (  )  ;", "Map < St ,    St >    caseInsensitiveParameterNames    =    SqlParameterSourceUtils . extractCaseInsensitiveParameterNames ( parameterSource )  ;", "for    ( St   column    :    this . tableColumns )     {", "if    ( parameterSource . hasValue ( column )  )     {", "values . add ( SqlParameterSourceUtils . getTypedValue ( parameterSource ,    column )  )  ;", "} else    {", "St   lowerCaseName    =    column . toLowerCase (  )  ;", "if    ( parameterSource . hasValue ( lowerCaseName )  )     {", "values . add ( SqlParameterSourceUtils . getTypedValue ( parameterSource ,    lowerCaseName )  )  ;", "} else    {", "St   propertyName    =    JdbcUtils . convertUnderscoreNameToPropertyName ( column )  ;", "if    ( parameterSource . hasValue ( propertyName )  )     {", "values . add ( SqlParameterSourceUtils . getTypedValue ( parameterSource ,    propertyName )  )  ;", "} else    {", "if    ( caseInsensitiveParameterNames . containsKey ( lowerCaseName )  )     {", "values . add ( SqlParameterSourceUtils . getTypedValue ( parameterSource ,    caseInsensitiveParameterNames . get ( lowerCaseName )  )  )  ;", "} else    {", "values . add ( null )  ;", "}", "}", "}", "}", "}", "return   values ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithInsertColumns"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . metaDataProvider )     !  =    null )  ,     \" No   TableMetaDataProvider    -    call   processMetaData   first \"  )  ;", "return   this . metaDataProvider ;", "}", "METHOD_END"], "methodName": ["obtainMetaDataProvider"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . metaDataProvider    =    TableMetaDataProviderFactory . createMetaDataProvider ( dataSource ,    this )  ;", "this . tableColumns    =    reconcileColumnsToUse ( declaredColumns ,    generatedKeyNames )  ;", "}", "METHOD_END"], "methodName": ["processMetaData"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( generatedKeyNames . length )     >     0  )     {", "this . generatedKeyColumnsUsed    =    true ;", "}", "if    (  !  ( declaredColumns . isEmpty (  )  )  )     {", "return   new   ArrayList <  >  ( declaredColumns )  ;", "}", "Set < String >    keys    =    new   LinkedHashSet <  >  ( generatedKeyNames . length )  ;", "for    ( String   key    :    generatedKeyNames )     {", "keys . add ( key . toUpperCase (  )  )  ;", "}", "List < String >    columns    =    new   ArrayList <  >  (  )  ;", "for    ( TableParameter   meta    :    obtainProvider (  )  . getTableParameter (  )  )     {", "if    (  !  ( keys . contains ( meta . getParameterName (  )  . toUpperCase (  )  )  )  )     {", "columns . add ( meta . getParameterName (  )  )  ;", "}", "}", "return   columns ;", "}", "METHOD_END"], "methodName": ["reconcileColumnsToUse"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . accessTableColumnMetaData    =    accessTableColumnMetaData ;", "}", "METHOD_END"], "methodName": ["setAccessTableColumnMetaData"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . catalogName    =    catalogName ;", "}", "METHOD_END"], "methodName": ["setCatalogName"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . overrideIncludeSynonymsDefault    =    override ;", "}", "METHOD_END"], "methodName": ["setOverrideIncludeSynonymsDefault"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . schemaName    =    schemaName ;", "}", "METHOD_END"], "methodName": ["setSchemaName"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "this . tableName    =    tableName ;", "}", "METHOD_END"], "methodName": ["setTableName"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataContext"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( TableMetaDataProvider )     ( JdbcUtils . extractDatabaseMetaData ( dataSource ,     (    databaseMetaData )     -  >     {", "String   databaseProductName    =    JdbcUtils . commonDatabaseName ( databaseMetaData . getDatabaseProductName (  )  )  ;", "boolean   accessTableColumnMetaData    =    context . isAccessTableColumnMetaData (  )  ;", "TableMetaDataProvider   provider ;", "if    (  \" Oracle \"  . equals ( databaseProductName )  )     {", "provider    =    new   OracleTableMetaDataProvider ( databaseMetaData ,    context . isOverrideIncludeSynonymsDefault (  )  )  ;", "} else", "if    (  \" PostgreSQL \"  . equals ( databaseProductName )  )     {", "provider    =    new   PostgresTableMetaDataProvider ( databaseMetaData )  ;", "} else", "if    (  \" Apache   Derby \"  . equals ( databaseProductName )  )     {", "provider    =    new   DerbyTableMetaDataProvider ( databaseMetaData )  ;", "} else", "if    (  \" HSQL   Database   Engine \"  . equals ( databaseProductName )  )     {", "provider    =    new   HsqlTableMetaDataProvider ( databaseMetaData )  ;", "} else    {", "provider    =    new   GenericTableMetaDataProvider ( databaseMetaData )  ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Using    \"     +     ( provider . getClass (  )  . getSimpleName (  )  )  )  )  ;", "}", "provider . initializeWithMetaData ( databaseMetaData )  ;", "if    ( accessTableColumnMetaData )     {", "provider . initializeWithTableColumnMetaData ( databaseMetaData ,    context . getCatalogName (  )  ,    context . getSchemaName (  )  ,    context . getTableName (  )  )  ;", "}", "return   provider ;", "}  )  )  )  ;", "}    catch    ( MetaDataAccessException   ex )     {", "throw   new   DataAccessResourceFailureException (  \" Error   retrieving   database   meta - data \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createMetaDataProvider"], "fileName": "org.springframework.jdbc.core.metadata.TableMetaDataProviderFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterName ;", "}", "METHOD_END"], "methodName": ["getParameterName"], "fileName": "org.springframework.jdbc.core.metadata.TableParameterMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . sqlType ;", "}", "METHOD_END"], "methodName": ["getSqlType"], "fileName": "org.springframework.jdbc.core.metadata.TableParameterMetaData"}, {"methodBody": ["METHOD_START", "{", "return   this . nullable ;", "}", "METHOD_END"], "methodName": ["isNullable"], "fileName": "org.springframework.jdbc.core.metadata.TableParameterMetaData"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( paramName ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . sqlTypes . put ( paramName ,    sqlType )  ;", "}", "METHOD_END"], "methodName": ["registerSqlType"], "fileName": "org.springframework.jdbc.core.namedparam.AbstractSqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( paramName ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . typeNames . put ( paramName ,    typeName )  ;", "}", "METHOD_END"], "methodName": ["registerTypeName"], "fileName": "org.springframework.jdbc.core.namedparam.AbstractSqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . propertyNames )     =  =    null )     {", "List < String >    names    =    new   ArrayList <  >  (  )  ;", "Descriptor [  ]    props    =    this . beanWrapper . getDescriptors (  )  ;", "for    ( Descriptor   pd    :    props )     {", "if    ( this . beanWrapper . isReadable ( pd . getName (  )  )  )     {", "names . add ( pd . getName (  )  )  ;", "}", "}", "this . propertyNames    =    StringUtils . toStringArray ( names )  ;", "}", "return   this . propertyNames ;", "}", "METHOD_END"], "methodName": ["getReadablePropertyNames"], "fileName": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "BeanPropertySqlParameterSource   source    =    new   BeanPropertySqlParameterSource ( new   TestBean (  )  )  ;", "source . getValue (  \" thisPropertyDoesNotExist \"  )  ;", "}", "METHOD_END"], "methodName": ["getValueWhereTheUnderlyingBeanHasNoSuchProperty"], "fileName": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "BeanPropertySqlParameterSource   source    =    new   BeanPropertySqlParameterSource ( new   BeanPropertySqlParameterSourceTests . NoReadableProperties (  )  )  ;", "source . getValue (  \" noOp \"  )  ;", "}", "METHOD_END"], "methodName": ["getValueWhereTheUnderlyingBeanPropertyIsNotReadable"], "fileName": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "BeanPropertySqlParameterSource   source    =    new   BeanPropertySqlParameterSource ( new   TestBean (  )  )  ;", "assertFalse ( source . hasValue (  \" thisPropertyDoesNotExist \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hasValueWhereTheUnderlyingBeanHasNoSuchProperty"], "fileName": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "BeanPropertySqlParameterSource   source    =    new   BeanPropertySqlParameterSource ( new   BeanPropertySqlParameterSourceTests . NoReadableProperties (  )  )  ;", "assertFalse ( source . hasValue (  \" noOp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hasValueWhereTheUnderlyingBeanPropertyIsNotReadable"], "fileName": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "BeanPropertySqlParameterSource   source    =    new   BeanPropertySqlParameterSource ( new   TestBean (  \" tb \"  ,     9  9  )  )  ;", "assertTrue ( Arrays . asList ( source . getReadablePropertyNames (  )  )  . contains (  \" name \"  )  )  ;", "assertTrue ( Arrays . asList ( source . getReadablePropertyNames (  )  )  . contains (  \" age \"  )  )  ;", "assertEquals (  \" tb \"  ,    source . getValue (  \" name \"  )  )  ;", "assertEquals (  9  9  ,    source . getValue (  \" age \"  )  )  ;", "assertEquals ( Types . VARCHAR ,    source . getSqlType (  \" name \"  )  )  ;", "assertEquals ( Types . INTEGER ,    source . getSqlType (  \" age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["successfulPropertyAccess"], "fileName": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "BeanPropertySqlParameterSource   source    =    new   BeanPropertySqlParameterSource ( new   TestBean (  \" tb \"  ,     9  9  )  )  ;", "source . registerSqlType (  \" age \"  ,    Types . NUMERIC )  ;", "assertEquals (  \" tb \"  ,    source . getValue (  \" name \"  )  )  ;", "assertEquals (  9  9  ,    source . getValue (  \" age \"  )  )  ;", "assertEquals ( Types . VARCHAR ,    source . getSqlType (  \" name \"  )  )  ;", "assertEquals ( Types . NUMERIC ,    source . getSqlType (  \" age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["successfulPropertyAccessWithOverriddenSqlType"], "fileName": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "new   BeanPropertySqlParameterSource ( null )  ;", "}", "METHOD_END"], "methodName": ["withNullBeanPassedToCtor"], "fileName": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( paramName ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . values . put ( paramName ,    value )  ;", "if    ( value   instanceof   Value )     {", "registerSqlType ( paramName ,     (  ( Value )     ( value )  )  . getSqlType (  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "org.springframework.jdbc.core.namedparam.MapSqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( paramName ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . values . put ( paramName ,    value )  ;", "registerSqlType ( paramName ,    sqlType )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "org.springframework.jdbc.core.namedparam.MapSqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( paramName ,     \" Parameter   name   must   not   be   null \"  )  ;", "this . values . put ( paramName ,    value )  ;", "registerSqlType ( paramName ,    sqlType )  ;", "registerTypeName ( paramName ,    typeName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "org.springframework.jdbc.core.namedparam.MapSqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "if    ( values    !  =    null )     {", "values . forEach (  (    key ,    value )     -  >     {", "this . values . put ( key ,    value )  ;", "if    ( value   instanceof   Value )     {", "registerSqlType ( key ,     (  ( Value )     ( value )  )  . getSqlType (  )  )  ;", "}", "}  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addValues"], "fileName": "org.springframework.jdbc.core.namedparam.MapSqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . values )  ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "org.springframework.jdbc.core.namedparam.MapSqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "MapSqlParameterSource   source    =    new   MapSqlParameterSource (  )  ;", "source . getValue (  \" pechorin   was   right !  \"  )  ;", "}", "METHOD_END"], "methodName": ["getValueChokesIfParameterIsNotPresent"], "fileName": "org.springframework.jdbc.core.namedparam.MapSqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "new   MapSqlParameterSource ( null )  ;", "}", "METHOD_END"], "methodName": ["nullParameterValuesPassedToCtorIsOk"], "fileName": "org.springframework.jdbc.core.namedparam.MapSqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "MapSqlParameterSource   msps    =    new   MapSqlParameterSource (  \" FOO \"  ,    new   SqlParameterValue (  2  ,     \" Foo \"  )  )  ;", "assertEquals (  \" Correct   SQL   Type   not   registered \"  ,     2  ,    msps . getSqlType (  \" FOO \"  )  )  ;", "MapSqlParameterSource   msps 2     =    new   MapSqlParameterSource (  )  ;", "msps 2  . addValues ( msps . getValues (  )  )  ;", "assertEquals (  \" Correct   SQL   Type   not   registered \"  ,     2  ,    msps 2  . getSqlType (  \" FOO \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sqlParameterValueRegistersSqlType"], "fileName": "org.springframework.jdbc.core.namedparam.MapSqlParameterSourceTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( batchArgs . length )     <  =     0  )     {", "return   new   int [  ]  {     0     }  ;", "}", "String   sqlToUse    =    NamedParameterUtils . substituteNamedParameters ( parsedSql ,    batchArgs [  0  ]  )  ;", "return   jdbcOperations . batchUpdate ( sqlToUse ,    new   BatchPreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps ,    int   i )    throws   SQLException    {", "Object [  ]    values    =    NamedParameterUtils . buildValueArray ( parsedSql ,    batchArgs [ i ]  ,    null )  ;", "int [  ]    columnTypes    =    NamedParameterUtils . buildSqlTypeArray ( parsedSql ,    batchArgs [ i ]  )  ;", ". setStatementParameters ( values ,    ps ,    columnTypes )  ;", "}", "@ Override", "public   int   getBatchSize (  )     {", "return   batchArgs . length ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["executeBatchUpdateWithNamedParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterBatchUpdateUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . namedParameterJdbcTemplate ;", "}", "METHOD_END"], "methodName": ["getNamedParameterJdbcTemplate"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheLimit ;", "}", "METHOD_END"], "methodName": ["getCacheLimit"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . classicJdbcTemplate )    instanceof   JdbcTemplate )  ,     \" No   JdbcTemplate   available \"  )  ;", "return    (  ( JdbcTemplate )     ( this . classicJdbcTemplate )  )  ;", "}", "METHOD_END"], "methodName": ["getJdbcTemplate"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getCacheLimit (  )  )     <  =     0  )     {", "return   Utils . parseSqlStatement ( sql )  ;", "}", "synchronized ( this . parsedSqlCache )     {", "ParsedSql   parsedSql    =    this . parsedSqlCache . get ( sql )  ;", "if    ( parsedSql    =  =    null )     {", "parsedSql    =    Utils . parseSqlStatement ( sql )  ;", "this . parsedSqlCache . put ( sql ,    parsedSql )  ;", "}", "return   parsedSql ;", "}", "}", "METHOD_END"], "methodName": ["getParsedSql"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "return   getPreparedStatementCreator ( sql ,    paramSource ,    null )  ;", "}", "METHOD_END"], "methodName": ["getPreparedStatementCreator"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "ParsedSql   parsedSql    =    getParsedSql ( sql )  ;", "String   sqlToUse    =    Utils . substitutes ( parsedSql ,    paramSource )  ;", "List < SqlParameter >    declaredParameters    =    Utils . buildSqlParameterList ( parsedSql ,    paramSource )  ;", "PreparedStatementCreatorFactory   pscf    =    new   PreparedStatementCreatorFactory ( sqlToUse ,    declaredParameters )  ;", "if    ( customizer    !  =    null )     {", "customizer . accept ( pscf )  ;", "}", "Object [  ]    params    =    Utils . buildValueArray ( parsedSql ,    paramSource ,    null )  ;", "return   pscf . newPreparedStatementCreator ( params )  ;", "}", "METHOD_END"], "methodName": ["getPreparedStatementCreator"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "this . cacheLimit    =    cacheLimit ;", "}", "METHOD_END"], "methodName": ["setCacheLimit"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"}, {"methodBody": ["METHOD_START", "{", "connection    =    mock ( Connection . class )  ;", "dataSource    =    mock ( DataSource . class )  ;", "preparedStatement    =    mock ( PreparedStatement . class )  ;", "resultSet    =    mock ( ResultSet . class )  ;", "namedParameterTemplate    =    new    ( dataSource )  ;", "databaseMetaData    =    mock ( DatabaseMetaData . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . prepareStatement ( anyString (  )  )  )  . willReturn ( preparedStatement )  ;", "given ( preparedStatement . getConnection (  )  )  . willReturn ( connection )  ;", "given ( preparedStatement . executeQuery (  )  )  . willReturn ( resultSet )  ;", "given ( databaseMetaData . getDatabaseProductName (  )  )  . willReturn (  \" MySQL \"  )  ;", "given ( databaseMetaData . supportsBatchUpdates (  )  )  . willReturn ( true )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "final   Map < String ,    Integer >  [  ]    ids    =    new   Map [  2  ]  ;", "ids [  0  ]     =    Collections . singletonMap (  \" id \"  ,     1  0  0  )  ;", "ids [  1  ]     =    Collections . singletonMap (  \" id \"  ,     2  0  0  )  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected )  ;", "given ( connection . getMetaData (  )  )  . willReturn ( databaseMetaData )  ;", "JdbcTemplate   template    =    new   JdbcTemplate ( dataSource ,    false )  ;", "namedParameterTemplate    =    new    ( template )  ;", "assertSame ( template ,    namedParameterTemplate . getJdbcTemplate (  )  )  ;", "int [  ]    actualRowsAffected    =    namedParameterTemplate . batchUpdate (  \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     : id \"  ,    ids )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( connection )  . prepareStatement (  \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  0  0  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     2  0  0  )  ;", "verify ( preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( preparedStatement ,    atLeastOnce (  )  )  . close (  )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithPlainMap"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SqlParameterSource [  ]    ids    =    new   SqlParameterSource [  2  ]  ;", "ids [  0  ]     =    new   MapSqlParameterSource (  \" id \"  ,     1  0  0  )  ;", "ids [  1  ]     =    new   MapSqlParameterSource (  \" id \"  ,     2  0  0  )  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected )  ;", "given ( connection . getMetaData (  )  )  . willReturn ( databaseMetaData )  ;", "JdbcTemplate   template    =    new   JdbcTemplate ( dataSource ,    false )  ;", "namedParameterTemplate    =    new    ( template )  ;", "assertSame ( template ,    namedParameterTemplate . getJdbcTemplate (  )  )  ;", "int [  ]    actualRowsAffected    =    namedParameterTemplate . batchUpdate (  \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     : id \"  ,    ids )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( connection )  . prepareStatement (  \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  0  0  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     2  0  0  )  ;", "verify ( preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( preparedStatement ,    atLeastOnce (  )  )  . close (  )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithSqlParameterSource"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SqlParameterSource [  ]    ids    =    new   SqlParameterSource [  2  ]  ;", "ids [  0  ]     =    new   MapSqlParameterSource (  )  . addValue (  \" id \"  ,     1  0  0  ,    Types . NUMERIC )  ;", "ids [  1  ]     =    new   MapSqlParameterSource (  )  . addValue (  \" id \"  ,     2  0  0  ,    Types . NUMERIC )  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "given ( preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected )  ;", "given ( connection . getMetaData (  )  )  . willReturn ( databaseMetaData )  ;", "JdbcTemplate   template    =    new   JdbcTemplate ( dataSource ,    false )  ;", "namedParameterTemplate    =    new    ( template )  ;", "assertSame ( template ,    namedParameterTemplate . getJdbcTemplate (  )  )  ;", "int [  ]    actualRowsAffected    =    namedParameterTemplate . batchUpdate (  \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     : id \"  ,    ids )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "verify ( connection )  . prepareStatement (  \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  0  0  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setObject (  1  ,     2  0  0  ,    Types . NUMERIC )  ;", "verify ( preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( preparedStatement ,    atLeastOnce (  )  )  . close (  )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithSqlParameterSourcePlusTypeInfo"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "params . put (  \" perfId \"  ,     1  )  ;", "params . put (  \" priceId \"  ,     1  )  ;", "Object   result    =    namedParameterTemplate . execute (  . UPDATE _ NAMED _ PARAMETERS ,    params ,     (  ( PreparedStatementCallback < Object >  )     (  (    ps )     -  >     {", "assertEquals ( preparedStatement ,    ps )  ;", "ps . executeUpdate (  )  ;", "return    \" result \"  ;", "}  )  )  )  ;", "assertEquals (  \" result \"  ,    result )  ;", "verify ( connection )  . prepareStatement (  . UPDATE _ NAMED _ PARAMETERS _ PARSED )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testExecute"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "List < Integer >    typeIds    =    Arrays . asList (  1  ,     2  ,     3  )  ;", "params . put (  \" typeIds \"  ,    typeIds )  ;", "params . put (  \" id \"  ,     1  )  ;", "Object   result    =    namedParameterTemplate . execute (  . UPDATE _ ARRAY _ PARAMETERS ,    params ,     (  ( PreparedStatementCallback < Object >  )     (  (    ps )     -  >     {", "assertEquals ( preparedStatement ,    ps )  ;", "ps . executeUpdate (  )  ;", "return    \" result \"  ;", "}  )  )  )  ;", "assertEquals (  \" result \"  ,    result )  ;", "verify ( connection )  . prepareStatement (  . UPDATE _ ARRAY _ PARAMETERS _ PARSED )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  )  ;", "verify ( preparedStatement )  . setObject (  2  ,     2  )  ;", "verify ( preparedStatement )  . setObject (  3  ,     3  )  ;", "verify ( preparedStatement )  . setObject (  4  ,     1  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testExecuteArray"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "Object   result    =    namedParameterTemplate . execute (  . SELECT _ NO _ PARAMETERS ,     (  ( PreparedStatementCallback < Object >  )     (  (    ps )     -  >     {", "assertEquals ( preparedStatement ,    ps )  ;", "ps . executeQuery (  )  ;", "return    \" result \"  ;", "}  )  )  )  ;", "assertEquals (  \" result \"  ,    result )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ NO _ PARAMETERS )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testExecuteNoParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "params . put (  \" perfId \"  ,    new   SqlParameterValue ( Types . DECIMAL ,     1  )  )  ;", "params . put (  \" priceId \"  ,    new   SqlParameterValue ( Types . INTEGER ,     1  )  )  ;", "Object   result    =    namedParameterTemplate . execute (  . UPDATE _ NAMED _ PARAMETERS ,    params ,     (  ( PreparedStatementCallback < Object >  )     (  (    ps )     -  >     {", "assertEquals ( preparedStatement ,    ps )  ;", "ps . executeUpdate (  )  ;", "return    \" result \"  ;", "}  )  )  )  ;", "assertEquals (  \" result \"  ,    result )  ;", "verify ( connection )  . prepareStatement (  . UPDATE _ NAMED _ PARAMETERS _ PARSED )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . DECIMAL )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  ,    Types . INTEGER )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testExecuteWithTypedParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "new    (  (  ( DataSource )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNullDataSourceProvidedToCtor"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "new    (  (  ( JdbcOperations )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNullJdbcTemplateProvidedToCtor"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "params . put (  \" id \"  ,    new   SqlParameterValue ( Types . DECIMAL ,     1  )  )  ;", "params . put (  \" country \"  ,     \" UK \"  )  ;", "Customer   cust    =    namedParameterTemplate . queryForObject (  . SELECT _ NAMED _ PARAMETERS ,    params ,     (    rs ,    rownum )     -  >     {", "Customer   cust 1     =    new   Customer (  )  ;", "cust 1  . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust 1  . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust 1  ;", "}  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( cust . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    cust . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ NAMED _ PARAMETERS _ PARSED )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . DECIMAL )  ;", "verify ( preparedStatement )  . setString (  2  ,     \" UK \"  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithRowMapper"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "params . put (  \" id \"  ,    new   SqlParameterValue ( Types . DECIMAL ,     1  )  )  ;", "params . put (  \" country \"  ,     \" UK \"  )  ;", "Customer   cust    =    namedParameterTemplate . query (  . SELECT _ NAMED _ PARAMETERS ,    params ,     (    rs )     -  >     {", "rs . next (  )  ;", "Customer   cust 1     =    new   Customer (  )  ;", "cust 1  . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust 1  . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust 1  ;", "}  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( cust . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    cust . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ NAMED _ PARAMETERS _ PARSED )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . DECIMAL )  ;", "verify ( preparedStatement )  . setString (  2  ,     \" UK \"  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithResultSetExtractor"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "Customer   cust    =    namedParameterTemplate . query (  . SELECT _ NO _ PARAMETERS ,     (    rs )     -  >     {", "rs . next (  )  ;", "Customer   cust 1     =    new   Customer (  )  ;", "cust 1  . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust 1  . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust 1  ;", "}  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( cust . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    cust . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ NO _ PARAMETERS )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithResultSetExtractorNoParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "params . put (  \" id \"  ,    new   SqlParameterValue ( Types . DECIMAL ,     1  )  )  ;", "params . put (  \" country \"  ,     \" UK \"  )  ;", "final   List < Customer >    customers    =    new   LinkedList <  >  (  )  ;", "namedParameterTemplate . query (  . SELECT _ NAMED _ PARAMETERS ,    params ,     (    rs )     -  >     {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "customers . add ( cust )  ;", "}  )  ;", "assertEquals (  1  ,    customers . size (  )  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( customers . get (  0  )  . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    customers . get (  0  )  . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ NAMED _ PARAMETERS _ PARSED )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . DECIMAL )  ;", "verify ( preparedStatement )  . setString (  2  ,     \" UK \"  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithRowCallbackHandler"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "final   List < Customer >    customers    =    new   LinkedList <  >  (  )  ;", "namedParameterTemplate . query (  . SELECT _ NO _ PARAMETERS ,     (    rs )     -  >     {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "customers . add ( cust )  ;", "}  )  ;", "assertEquals (  1  ,    customers . size (  )  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( customers . get (  0  )  . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    customers . get (  0  )  . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ NO _ PARAMETERS )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithRowCallbackHandlerNoParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "params . put (  \" id \"  ,    new   SqlParameterValue ( Types . DECIMAL ,     1  )  )  ;", "params . put (  \" country \"  ,     \" UK \"  )  ;", "List < Customer >    customers    =    namedParameterTemplate . query (  . SELECT _ NAMED _ PARAMETERS ,    params ,     (    rs ,    rownum )     -  >     {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}  )  ;", "assertEquals (  1  ,    customers . size (  )  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( customers . get (  0  )  . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    customers . get (  0  )  . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ NAMED _ PARAMETERS _ PARSED )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . DECIMAL )  ;", "verify ( preparedStatement )  . setString (  2  ,     \" UK \"  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithRowMapper"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "List < Customer >    customers    =    namedParameterTemplate . query (  . SELECT _ NO _ PARAMETERS ,     (    rs ,    rownum )     -  >     {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}  )  ;", "assertEquals (  1  ,    customers . size (  )  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( customers . get (  0  )  . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    customers . get (  0  )  . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ NO _ PARAMETERS )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithRowMapperNoParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "assertSame ( dataSource ,    namedParameterTemplate . getJdbcTemplate (  )  . getDataSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateConfiguration"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "params . put (  \" perfId \"  ,     1  )  ;", "params . put (  \" priceId \"  ,     1  )  ;", "int   rowsAffected    =    namedParameterTemplate . update (  . UPDATE _ NAMED _ PARAMETERS ,    params )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "verify ( connection )  . prepareStatement (  . UPDATE _ NAMED _ PARAMETERS _ PARSED )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testUpdate"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "params . put (  \" perfId \"  ,    new   SqlParameterValue ( Types . DECIMAL ,     1  )  )  ;", "params . put (  \" priceId \"  ,    new   SqlParameterValue ( Types . INTEGER ,     1  )  )  ;", "int   rowsAffected    =    namedParameterTemplate . update (  . UPDATE _ NAMED _ PARAMETERS ,    params )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "verify ( connection )  . prepareStatement (  . UPDATE _ NAMED _ PARAMETERS _ PARSED )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . DECIMAL )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  ,    Types . INTEGER )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testUpdateWithTypedParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplateTests"}, {"methodBody": ["METHOD_START", "{", "connection    =    mock ( Connection . class )  ;", "dataSource    =    mock ( DataSource . class )  ;", "preparedStatement    =    mock ( PreparedStatement . class )  ;", "resultSet    =    mock ( ResultSet . class )  ;", "resultSetMetaData    =    mock ( ResultSetMetaData . class )  ;", "template    =    new   JdbcTemplate ( dataSource )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "given ( resultSetMetaData . getColumnCount (  )  )  . willReturn (  1  )  ;", "given ( resultSetMetaData . getColumnLabel (  1  )  )  . willReturn (  \" age \"  )  ;", "given ( connection . prepareStatement ( anyString (  )  )  )  . willReturn ( preparedStatement )  ;", "given ( preparedStatement . executeQuery (  )  )  . willReturn ( resultSet )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "params . addValue (  \" id \"  ,     3  )  ;", "int   i    =    template . queryForObject (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     : id \"  ,    params ,    Integer . class )  . intValue (  )  ;", "assertEquals (  \" Return   of   an   int \"  ,     2  2  ,    i )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForIntWithParamMap"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getObject (  1  )  )  . willReturn (  1  1  ,     1  2  )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "params . addValue (  \" id \"  ,     3  )  ;", "List < Map < String ,    Object >  >    li    =    template . queryForList (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     : id \"  ,    params )  ;", "assertEquals (  \" All   rows   returned \"  ,     2  ,    li . size (  )  )  ;", "assertEquals (  \" First   row   is   Integer \"  ,     1  1  ,     (  ( Integer )     ( li . get (  0  )  . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "assertEquals (  \" Second   row   is   Integer \"  ,     1  2  ,     (  ( Integer )     ( li . get (  1  )  . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithParamMap"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( false )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "params . addValue (  \" id \"  ,     3  )  ;", "List < Map < String ,    Object >  >    li    =    template . queryForList (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     : id \"  ,    params )  ;", "assertEquals (  \" All   rows   returned \"  ,     0  ,    li . size (  )  )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithParamMapAndEmptyResult"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  1  )  )  . willReturn (  1  1  )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "params . addValue (  \" id \"  ,     3  )  ;", "List < Integer >    li    =    template . queryForList (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     : id \"  ,    params ,    Integer . class )  ;", "assertEquals (  \" All   rows   returned \"  ,     1  ,    li . size (  )  )  ;", "assertEquals (  \" First   row   is   Integer \"  ,     1  1  ,    li . get (  0  )  . intValue (  )  )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithParamMapAndIntegerElementAndSingleRowAndColumn"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getObject (  1  )  )  . willReturn (  1  1  )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "params . addValue (  \" id \"  ,     3  )  ;", "List < Map < String ,    Object >  >    li    =    template . queryForList (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     : id \"  ,    params )  ;", "assertEquals (  \" All   rows   returned \"  ,     1  ,    li . size (  )  )  ;", "assertEquals (  \" First   row   is   Integer \"  ,     1  1  ,     (  ( Integer )     ( li . get (  0  )  . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForListWithParamMapAndSingleRowAndColumn"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getLong (  1  )  )  . willReturn (  8  7 L )  ;", "BeanPropertySqlParameterSource   params    =    new   BeanPropertySqlParameterSource ( new    . ParameterBean (  3  )  )  ;", "long   l    =    template . queryForObject (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     : id \"  ,    params ,    Long . class )  . longValue (  )  ;", "assertEquals (  \" Return   of   a   long \"  ,     8  7  ,    l )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  ,    Types . INTEGER )  ;", "}", "METHOD_END"], "methodName": ["testQueryForLongWithParamBean"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getLong (  1  )  )  . willReturn (  8  7 L )  ;", "BeanPropertySqlParameterSource   params    =    new   BeanPropertySqlParameterSource ( new    . ParameterCollectionBean (  3  ,     5  )  )  ;", "long   l    =    template . queryForObject (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID   IN    (  : ids )  \"  ,    params ,    Long . class )  . longValue (  )  ;", "assertEquals (  \" Return   of   a   long \"  ,     8  7  ,    l )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID   IN    (  ?  ,     ?  )  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "verify ( preparedStatement )  . setObject (  2  ,     5  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForLongWithParamBeanWithCollection"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getObject (  1  )  )  . willReturn (  1  1  )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "params . addValue (  \" id \"  ,     3  )  ;", "Map < String ,    Object >    map    =    template . queryForMap (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     : id \"  ,    params )  ;", "assertEquals (  \" Row   is   Integer \"  ,     1  1  ,     (  ( Integer )     ( map . get (  \" age \"  )  )  )  . intValue (  )  )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    <     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForMapWithParamMapAndSingleRowAndColumn"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "Map < String ,    Object >    s    =    new   HashMap <  >  (  )  ;", "s . put (  \" id \"  ,     3  )  ;", "Object   o    =    template . queryForObject (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     : id \"  ,    s ,    Integer . class )  ;", "assertTrue (  \" Correct   result   type \"  ,     ( o   instanceof   Integer )  )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithMapAndInteger"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "params . addValue (  \" id \"  ,     3  )  ;", "Object   o    =    template . queryForObject (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     : id \"  ,    params ,    Integer . class )  ;", "assertTrue (  \" Correct   result   type \"  ,     ( o   instanceof   Integer )  )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithParamMapAndInteger"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID   IN    (  : ids )  \"  ;", "String   sqlToUse    =     \" SELECT   AGE   FROM   CUSTMR   WHERE   ID   IN    (  ?  ,     ?  )  \"  ;", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "params . addValue (  \" ids \"  ,    Arrays . asList (  3  ,     4  )  )  ;", "Object   o    =    template . queryForObject ( sql ,    params ,    Integer . class )  ;", "assertTrue (  \" Correct   result   type \"  ,     ( o   instanceof   Integer )  )  ;", "verify ( connection )  . prepareStatement ( sqlToUse )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithParamMapAndList"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "List < Object [  ]  >    l 1     =    new   ArrayList <  >  (  )  ;", "l 1  . add ( new   Object [  ]  {     3  ,     \" Rod \"     }  )  ;", "l 1  . add ( new   Object [  ]  {     4  ,     \" Juergen \"     }  )  ;", "params . addValue (  \" multiExpressionList \"  ,    l 1  )  ;", "Object   o    =    template . queryForObject (  \" SELECT   AGE   FROM   CUSTMR   WHERE    ( ID ,    NAME )    IN    (  : multiExpressionList )  \"  ,    params ,    Integer . class )  ;", "assertTrue (  \" Correct   result   type \"  ,     ( o   instanceof   Integer )  )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE    ( ID ,    NAME )    IN    (  (  ?  ,     ?  )  ,     (  ?  ,     ?  )  )  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithParamMapAndListOfExpressionLists"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  1  )  )  . willReturn (  2  2  )  ;", "MapSqlSource   params    =    new   MapSqlSource (  )  ;", "params . addValue (  \" id \"  ,     3  )  ;", "Object   o    =    template . queryForObject (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     : id \"  ,    params ,    new   RowMapper < Object >  (  )     {", "@ Override", "public   Object   mapRow ( ResultSet   rs ,    int   rowNum )    throws   SQLException    {", "return   rs . getInt (  1  )  ;", "}", "}  )  ;", "assertTrue (  \" Correct   result   type \"  ,     ( o   instanceof   Integer )  )  ;", "verify ( connection )  . prepareStatement (  \" SELECT   AGE   FROM   CUSTMR   WHERE   ID    =     ?  \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testQueryForObjectWithParamMapAndRowMapper"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "verify ( preparedStatement )  . close (  )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["verifyClose"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterQueryTests"}, {"methodBody": ["METHOD_START", "{", "parameterList . add ( new   NamedParameterUtils . ParameterHolder ( parameter ,     ( i    -    escapes )  ,     ( j    -    escapes )  )  )  ;", "totalParameterCount +  +  ;", "return   totalParameterCount ;", "}", "METHOD_END"], "methodName": ["addNamedParameter"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( namedParameters . contains ( parameter )  )  )     {", "namedParameters . add ( parameter )  ;", "namedParameterCount +  +  ;", "}", "return   namedParameterCount ;", "}", "METHOD_END"], "methodName": ["addNewNamedParameter"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "List < String >    paramNames    =    parsedSql . getParameterNames (  )  ;", "List < SqlParameter >    params    =    new   ArrayList <  >  ( paramNames . size (  )  )  ;", "for    ( String   paramName    :    paramNames )     {", "params . add ( new   SqlParameter ( paramName ,    paramSource . getSqlType ( paramName )  ,    paramSource . getTypeName ( paramName )  )  )  ;", "}", "return   params ;", "}", "METHOD_END"], "methodName": ["buildSqlParameterList"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "int [  ]    sqlTypes    =    new   int [ parsedSql . getTotalParameterCount (  )  ]  ;", "List < String >    paramNames    =    parsedSql . getParameterNames (  )  ;", "for    ( int   i    =     0  ;    i    <     ( paramNames . size (  )  )  ;    i +  +  )     {", "String   paramName    =    paramNames . get ( i )  ;", "sqlTypes [ i ]     =    paramSource . getSqlType ( paramName )  ;", "}", "return   sqlTypes ;", "}", "METHOD_END"], "methodName": ["buildSqlTypeArray"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "ParsedSql   parsedSql    =    NamedParameterUtils . parseSqlStatement ( sql )  ;", "return   NamedParameterUtils . buildValueArray ( parsedSql ,    new   MapSqlParameterSource ( paramMap )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["buildValueArray"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    paramArray    =    new   Object [ parsedSql . getTotalParameterCount (  )  ]  ;", "if    (  (  ( parsedSql . getNamedParameterCount (  )  )     >     0  )     &  &     (  ( parsedSql . getUnnamedParameterCount (  )  )     >     0  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  (  (  \" Not   allowed   to   mix   named   and   traditional    ?    placeholders .    You   have    \"     +     ( parsedSql . getNamedParameterCount (  )  )  )     +     \"    named   parameter ( s )    and    \"  )     +     ( parsedSql . getUnnamedParameterCount (  )  )  )     +     \"    traditional   placeholder ( s )    in   statement :     \"  )     +     ( parsedSql . getOriginalSql (  )  )  )  )  ;", "}", "List < String >    paramNames    =    parsedSql . getParameterNames (  )  ;", "for    ( int   i    =     0  ;    i    <     ( paramNames . size (  )  )  ;    i +  +  )     {", "String   paramName    =    paramNames . get ( i )  ;", "try    {", "Object   value    =    paramSource . getValue ( paramName )  ;", "SqlParameter   param    =     . findParameter ( declaredParams ,    paramName ,    i )  ;", "paramArray [ i ]     =     ( param    !  =    null )     ?    new   SqlParameterValue ( param ,    value )     :    value ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  \" No   value   supplied   for   the   SQL   parameter    '  \"     +    paramName )     +     \"  '  :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "return   paramArray ;", "}", "METHOD_END"], "methodName": ["buildValueArray"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( declaredParams    !  =    null )     {", "for    ( Sql   declaredParam    :    declaredParams )     {", "if    ( paramName . equals ( declaredParam . getName (  )  )  )     {", "return   declaredParam ;", "}", "}", "if    ( paramIndex    <     ( declaredParams . size (  )  )  )     {", "Sql   declaredParam    =    declaredParams . get ( paramIndex )  ;", "if    (  ( declaredParam . getName (  )  )     =  =    null )     {", "return   declaredParam ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findParameter"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( c    <     1  2  8  )     &  &     ( NamedParameterUtils . separatorIndex [ c ]  )  )     |  |     ( Character . isWhitespace ( c )  )  ;", "}", "METHOD_END"], "methodName": ["isParameterSeparator"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( sql ,     \" SQL   must   not   be   null \"  )  ;", "Set < String >    namedParameters    =    new   HashSet <  >  (  )  ;", "String   sqlToUse    =    sql ;", "List <  . ParameterHolder >    parameterList    =    new   ArrayList <  >  (  )  ;", "char [  ]    statement    =    sql . toCharArray (  )  ;", "int   namedParameterCount    =     0  ;", "int   unnamedParameterCount    =     0  ;", "int   totalParameterCount    =     0  ;", "int   escapes    =     0  ;", "int   i    =     0  ;", "while    ( i    <     ( statement . length )  )     {", "int   skipToPosition    =    i ;", "while    ( i    <     ( statement . length )  )     {", "skipToPosition    =     . skipCommentsAndQuotes ( statement ,    i )  ;", "if    ( i    =  =    skipToPosition )     {", "break ;", "} else    {", "i    =    skipToPosition ;", "}", "}", "if    ( i    >  =     ( statement . length )  )     {", "break ;", "}", "char   c    =    statement [ i ]  ;", "if    (  ( c    =  =     '  :  '  )     |  |     ( c    =  =     '  &  '  )  )     {", "int   j    =    i    +     1  ;", "if    (  (  ( j    <     ( statement . length )  )     &  &     (  ( statement [ j ]  )     =  =     '  :  '  )  )     &  &     ( c    =  =     '  :  '  )  )     {", "i    =    i    +     2  ;", "continue ;", "}", "String   parameter    =    null ;", "if    (  (  ( j    <     ( statement . length )  )     &  &     ( c    =  =     '  :  '  )  )     &  &     (  ( statement [ j ]  )     =  =     '  {  '  )  )     {", "while    (  ( j    <     ( statement . length )  )     &  &     (  ( statement [ j ]  )     !  =     '  }  '  )  )     {", "j +  +  ;", "if    (  (  ( statement [ j ]  )     =  =     '  :  '  )     |  |     (  ( statement [ j ]  )     =  =     '  {  '  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  (  (  \" Parameter   name   contains   invalid   character    '  \"     +     ( statement [ j ]  )  )     +     \"  '    at   position    \"  )     +    i )     +     \"    in   statement :     \"  )     +    sql )  )  ;", "}", "}", "if    ( j    >  =     ( statement . length )  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  \" Non - terminated   named   parameter   declaration   at   position    \"     +    i )     +     \"    in   statement :     \"  )     +    sql )  )  ;", "}", "if    (  ( j    -    i )     >     2  )     {", "parameter    =    sql . substring (  ( i    +     2  )  ,    j )  ;", "namedParameterCount    =     . addNewNamedParameter ( namedParameters ,    namedParameterCount ,    parameter )  ;", "totalParameterCount    =     . addNamedParameter ( parameterList ,    totalParameterCount ,    escapes ,    i ,     ( j    +     1  )  ,    parameter )  ;", "}", "j +  +  ;", "} else    {", "while    (  ( j    <     ( statement . length )  )     &  &     (  !  (  . isParameterSeparator ( statement [ j ]  )  )  )  )     {", "j +  +  ;", "}", "if    (  ( j    -    i )     >     1  )     {", "parameter    =    sql . substring (  ( i    +     1  )  ,    j )  ;", "namedParameterCount    =     . addNewNamedParameter ( namedParameters ,    namedParameterCount ,    parameter )  ;", "totalParameterCount    =     . addNamedParameter ( parameterList ,    totalParameterCount ,    escapes ,    i ,    j ,    parameter )  ;", "}", "}", "i    =    j    -     1  ;", "} else    {", "if    ( c    =  =     '  \\  \\  '  )     {", "int   j    =    i    +     1  ;", "if    (  ( j    <     ( statement . length )  )     &  &     (  ( statement [ j ]  )     =  =     '  :  '  )  )     {", "sqlToUse    =     ( sqlToUse . substring (  0  ,     ( i    -    escapes )  )  )     +     ( sqlToUse . substring (  (  ( i    -    escapes )     +     1  )  )  )  ;", "escapes +  +  ;", "i    =    i    +     2  ;", "continue ;", "}", "}", "if    ( c    =  =     '  ?  '  )     {", "int   j    =    i    +     1  ;", "if    (  ( j    <     ( statement . length )  )     &  &     (  (  (  ( statement [ j ]  )     =  =     '  ?  '  )     |  |     (  ( statement [ j ]  )     =  =     '  |  '  )  )     |  |     (  ( statement [ j ]  )     =  =     '  &  '  )  )  )     {", "i    =    i    +     2  ;", "continue ;", "}", "unnamedParameterCount +  +  ;", "totalParameterCount +  +  ;", "}", "}", "i +  +  ;", "}", "ParsedSql   parsedSql    =    new   ParsedSql ( sqlToUse )  ;", "for    (  . ParameterHolder   ph    :    parameterList )     {", "parsedSql . addNamedParameter ( ph . getParameterName (  )  ,    ph . getStartIndex (  )  ,    ph . getEndIndex (  )  )  ;", "}", "parsedSql . setNamedParameterCount ( namedParameterCount )  ;", "parsedSql . setUnnamedParameterCount ( unnamedParameterCount )  ;", "parsedSql . setTotalParameterCount ( totalParameterCount )  ;", "return   parsedSql ;", "}", "METHOD_END"], "methodName": ["parseSqlStatement"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "ParsedSql   parsedSql    =    NamedParameterUtils . parseSqlStatement ( sql )  ;", "return   NamedParameterUtils . substituteNamedParameters ( parsedSql ,    null )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementIntoString"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( NamedParameterUtils . START _ SKIP . length )  ;    i +  +  )     {", "if    (  ( statement [ position ]  )     =  =     ( NamedParameterUtils . START _ SKIP [ i ]  . charAt (  0  )  )  )     {", "boolean   match    =    true ;", "for    ( int   j    =     1  ;    j    <     ( NamedParameterUtils . START _ SKIP [ i ]  . length (  )  )  ;    j +  +  )     {", "if    (  ( statement [  ( position    +    j )  ]  )     !  =     ( NamedParameterUtils . START _ SKIP [ i ]  . charAt ( j )  )  )     {", "match    =    false ;", "break ;", "}", "}", "if    ( match )     {", "int   offset    =    NamedParameterUtils . START _ SKIP [ i ]  . length (  )  ;", "for    ( int   m    =    position    +    offset ;    m    <     ( statement . length )  ;    m +  +  )     {", "if    (  ( statement [ m ]  )     =  =     ( NamedParameterUtils . STOP _ SKIP [ i ]  . charAt (  0  )  )  )     {", "boolean   endMatch    =    true ;", "int   endPos    =    m ;", "for    ( int   n    =     1  ;    n    <     ( NamedParameterUtils . STOP _ SKIP [ i ]  . length (  )  )  ;    n +  +  )     {", "if    (  ( m    +    n )     >  =     ( statement . length )  )     {", "return   statement . length ;", "}", "if    (  ( statement [  ( m    +    n )  ]  )     !  =     ( NamedParameterUtils . STOP _ SKIP [ i ]  . charAt ( n )  )  )     {", "endMatch    =    false ;", "break ;", "}", "endPos    =    m    +    n ;", "}", "if    ( endMatch )     {", "return   endPos    +     1  ;", "}", "}", "}", "return   statement . length ;", "}", "}", "}", "return   position ;", "}", "METHOD_END"], "methodName": ["skipCommentsAndQuotes"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "ParsedSql   parsedSql    =    NamedParameterUtils . parseSqlStatement ( sql )  ;", "return   NamedParameterUtils . substituteNamedParameters ( parsedSql ,    paramSource )  ;", "}", "METHOD_END"], "methodName": ["substituteNamedParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "String   originalSql    =    parsedSql . getOriginalSql (  )  ;", "List < String >    paramNames    =    parsedSql . getNames (  )  ;", "if    ( paramNames . isEmpty (  )  )     {", "return   originalSql ;", "}", "StringBuilder   actualSql    =    new   StringBuilder ( originalSql . length (  )  )  ;", "int   lastIndex    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( paramNames . size (  )  )  ;    i +  +  )     {", "String   paramName    =    paramNames . get ( i )  ;", "int [  ]    indexes    =    parsedSql . getIndexes ( i )  ;", "int   startIndex    =    indexes [  0  ]  ;", "int   endIndex    =    indexes [  1  ]  ;", "actualSql . append ( originalSql ,    lastIndex ,    startIndex )  ;", "if    (  ( paramSource    !  =    null )     &  &     ( paramSource . hasValue ( paramName )  )  )     {", "Object   value    =    paramSource . getValue ( paramName )  ;", "if    ( value   instanceof   SqlValue )     {", "value    =     (  ( SqlValue )     ( value )  )  . getValue (  )  ;", "}", "if    ( value   instanceof   Collection )     {", "Iterator <  ?  >    entryIter    =     (  ( Collection <  ?  >  )     ( value )  )  . iterator (  )  ;", "int   k    =     0  ;", "while    ( entryIter . hasNext (  )  )     {", "if    ( k    >     0  )     {", "actualSql . append (  \"  ,     \"  )  ;", "}", "k +  +  ;", "Object   entryItem    =    entryIter . next (  )  ;", "if    ( entryItem   instanceof   Object [  ]  )     {", "Object [  ]    expressionList    =     (  ( Object [  ]  )     ( entryItem )  )  ;", "actualSql . append (  '  (  '  )  ;", "for    ( int   m    =     0  ;    m    <     ( expressionList . length )  ;    m +  +  )     {", "if    ( m    >     0  )     {", "actualSql . append (  \"  ,     \"  )  ;", "}", "actualSql . append (  '  ?  '  )  ;", "}", "actualSql . append (  '  )  '  )  ;", "} else    {", "actualSql . append (  '  ?  '  )  ;", "}", "}", "} else    {", "actualSql . append (  '  ?  '  )  ;", "}", "} else    {", "actualSql . append (  '  ?  '  )  ;", "}", "lastIndex    =    endIndex ;", "}", "actualSql . append ( originalSql ,    lastIndex ,    originalSql . length (  )  )  ;", "return   actualSql . toString (  )  ;", "}", "METHOD_END"], "methodName": ["substituteNamedParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtils"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" select   count (  0  )    from   foo   where   id    =     : id \"  ;", ". buildValueArray ( sql ,    Collections .  < String ,    Object > emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildValueArrayWithMissingParameterValue"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    paramMap    =    new   HashMap <  >  (  )  ;", "paramMap . put (  \" a \"  ,     \" a \"  )  ;", "paramMap . put (  \" b \"  ,     \" b \"  )  ;", "paramMap . put (  \" c \"  ,     \" c \"  )  ;", "assertSame (  3  ,     . buildValueArray (  \" xxx    : a    : b    : c \"  ,    paramMap )  . length )  ;", "assertSame (  5  ,     . buildValueArray (  \" xxx    : a    : b    : c   xx    : a    : b \"  ,    paramMap )  . length )  ;", "assertSame (  5  ,     . buildValueArray (  \" xxx    : a    : a    : a   xx    : a    : a \"  ,    paramMap )  . length )  ;", "assertEquals (  \" b \"  ,     . buildValueArray (  \" xxx    : a    : b    : c   xx    : a    : b \"  ,    paramMap )  [  4  ]  )  ;", "try    {", ". buildValueArray (  \" xxx    : a    : b    ?  \"  ,    paramMap )  ;", "fail (  \" mixed   named   parameters   and    ?    placeholders   not   detected \"  )  ;", "}    catch    ( InvalidDataAccessApiUsageException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["convertParamMapToArray"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MapSqlParameterSource   namedParams    =    new   MapSqlParameterSource (  )  ;", "namedParams . addValue (  \" a \"  ,     \" a \"  ,     1  )  . addValue (  \" b \"  ,     \" b \"  ,     2  )  . addValue (  \" c \"  ,     \" c \"  ,     3  )  ;", "assertSame (  3  ,     . buildSqlTypeArray (  . parseSqlStatement (  \" xxx    : a    : b    : c \"  )  ,    namedParams )  . length )  ;", "assertSame (  5  ,     . buildSqlTypeArray (  . parseSqlStatement (  \" xxx    : a    : b    : c   xx    : a    : b \"  )  ,    namedParams )  . length )  ;", "assertSame (  5  ,     . buildSqlTypeArray (  . parseSqlStatement (  \" xxx    : a    : a    : a   xx    : a    : a \"  )  ,    namedParams )  . length )  ;", "assertEquals (  2  ,     . buildSqlTypeArray (  . parseSqlStatement (  \" xxx    : a    : b    : c   xx    : a    : b \"  )  ,    namedParams )  [  4  ]  )  ;", "}", "METHOD_END"], "methodName": ["convertTypeMapToArray"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MapSqlParameterSource   namedParams    =    new   MapSqlParameterSource (  )  ;", "namedParams . addValue (  \" a \"  ,     \" a \"  ,     1  )  . addValue (  \" b \"  ,     \" b \"  ,     2  )  . addValue (  \" c \"  ,     \" c \"  ,     3  ,     \" SQL _ TYPE \"  )  ;", "assertSame (  3  ,     . buildSqlParameterList (  . parseSqlStatement (  \" xxx    : a    : b    : c \"  )  ,    namedParams )  . size (  )  )  ;", "assertSame (  5  ,     . buildSqlParameterList (  . parseSqlStatement (  \" xxx    : a    : b    : c   xx    : a    : b \"  )  ,    namedParams )  . size (  )  )  ;", "assertSame (  5  ,     . buildSqlParameterList (  . parseSqlStatement (  \" xxx    : a    : a    : a   xx    : a    : a \"  )  ,    namedParams )  . size (  )  )  ;", "assertEquals (  2  ,     . buildSqlParameterList (  . parseSqlStatement (  \" xxx    : a    : b    : c   xx    : a    : b \"  )  ,    namedParams )  . get (  4  )  . getSqlType (  )  )  ;", "assertEquals (  \" SQL _ TYPE \"  ,     . buildSqlParameterList (  . parseSqlStatement (  \" xxx    : a    : b    : c \"  )  ,    namedParams )  . get (  2  )  . getTypeName (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertTypeMapToSqlParameterList"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" xxx    : a   yyyy    : b    : c    : a   zzzzz \"  ;", "ParsedSql   psql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  \" xxx    ?    yyyy    ?     ?     ?    zzzzz \"  ,     . substituteNamedParameters ( psql ,    null )  )  ;", "assertEquals (  \" a \"  ,    psql . getParameterNames (  )  . get (  0  )  )  ;", "assertEquals (  \" c \"  ,    psql . getParameterNames (  )  . get (  2  )  )  ;", "assertEquals (  \" a \"  ,    psql . getParameterNames (  )  . get (  3  )  )  ;", "assertEquals (  4  ,    psql . getTotalParameterCount (  )  )  ;", "assertEquals (  3  ,    psql . getNamedParameterCount (  )  )  ;", "String   sql 2     =     \" xxx    & a   yyyy    ?    zzzzz \"  ;", "ParsedSql   psql 2     =     . parseSqlStatement ( sql 2  )  ;", "assertEquals (  \" xxx    ?    yyyy    ?    zzzzz \"  ,     . substituteNamedParameters ( psql 2  ,    null )  )  ;", "assertEquals (  \" a \"  ,    psql 2  . getParameterNames (  )  . get (  0  )  )  ;", "assertEquals (  2  ,    psql 2  . getTotalParameterCount (  )  )  ;", "assertEquals (  1  ,    psql 2  . getNamedParameterCount (  )  )  ;", "String   sql 3     =     (  \" xxx    &  ?  +  :  ?  \"     +     '  \\ t '  )     +     \"  :  \u00a8\u00b9  %  1  0    yyyy    ?    zzzzz \"  ;", "ParsedSql   psql 3     =     . parseSqlStatement ( sql 3  )  ;", "assertEquals (  \"  ?  \"  ,    psql 3  . getParameterNames (  )  . get (  0  )  )  ;", "assertEquals (  \"  ?  \"  ,    psql 3  . getParameterNames (  )  . get (  1  )  )  ;", "assertEquals (  \"  \u00a8\u00b9  \"  ,    psql 3  . getParameterNames (  )  . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["parseSql"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   sql 1     =     \"  /  *  +    HINT    *  /    xxx    /  *    comment    ?     *  /     : a   yyyy    : b    : c    : a   zzzzz    -  -     : xx   XX \\ n \"  ;", "ParsedSql   psql 1     =     . parseSqlStatement ( sql 1  )  ;", "assertEquals (  \"  /  *  +    HINT    *  /    xxx    /  *    comment    ?     *  /     ?    yyyy    ?     ?     ?    zzzzz    -  -     : xx   XX \\ n \"  ,     . substituteNamedParameters ( psql 1  ,    null )  )  ;", "MapSqlParameterSource   paramMap    =    new   MapSqlParameterSource (  )  ;", "paramMap . addValue (  \" a \"  ,     \" a \"  )  ;", "paramMap . addValue (  \" b \"  ,     \" b \"  )  ;", "paramMap . addValue (  \" c \"  ,     \" c \"  )  ;", "Object [  ]    params    =     . buildValueArray ( psql 1  ,    paramMap ,    null )  ;", "assertEquals (  4  ,    params . length )  ;", "assertEquals (  \" a \"  ,    params [  0  ]  )  ;", "assertEquals (  \" b \"  ,    params [  1  ]  )  ;", "assertEquals (  \" c \"  ,    params [  2  ]  )  ;", "assertEquals (  \" a \"  ,    params [  3  ]  )  ;", "String   sql 2     =     \"  /  *  +    HINT    *  /    xxx    /  *    comment    ?     *  /     : a   yyyy    : b    : c    : a   zzzzz    -  -     : xx   XX \"  ;", "ParsedSql   psql 2     =     . parseSqlStatement ( sql 2  )  ;", "assertEquals (  \"  /  *  +    HINT    *  /    xxx    /  *    comment    ?     *  /     ?    yyyy    ?     ?     ?    zzzzz    -  -     : xx   XX \"  ,     . substituteNamedParameters ( psql 2  ,    null )  )  ;", "String   sql 3     =     \"  /  *  +    HINT    *  /    xxx    /  *    comment    ?     *  /     : a   yyyy    : b    : c    : a   zzzzz    /  *     : xx   XX *  \"  ;", "ParsedSql   psql 3     =     . parseSqlStatement ( sql 3  )  ;", "assertEquals (  \"  /  *  +    HINT    *  /    xxx    /  *    comment    ?     *  /     ?    yyyy    ?     ?     ?    zzzzz    /  *     : xx   XX *  \"  ,     . substituteNamedParameters ( psql 3  ,    null )  )  ;", "String   sql 4     =     \"  /  *  +    HINT    *  /    xxx    /  *    comment    : a    ?     *  /     : a   yyyy    : b    : c    : a   zzzzz    /  *     : xx   XX *  \"  ;", "ParsedSql   psql 4     =     . parseSqlStatement ( sql 4  )  ;", "Map < String ,    String >    parameters    =    Collections . singletonMap (  \" a \"  ,     \"  0  \"  )  ;", "assertEquals (  \"  /  *  +    HINT    *  /    xxx    /  *    comment    : a    ?     *  /     ?    yyyy    ?     ?     ?    zzzzz    /  *     : xx   XX *  \"  ,     . substituteNamedParameters ( psql 4  ,    new   MapSqlParameterSource ( parameters )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlContainingComments"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select   foo   from   bar   where   baz    =    b ?  ? z \"  ;", "String   sql    =     \" select   foo   from   bar   where   baz    =    b :  { p 1  }  :  { p 2  } z \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  2  ,    parsedSql . getParameterNames (  )  . size (  )  )  ;", "assertEquals (  \" p 1  \"  ,    parsedSql . getParameterNames (  )  . get (  0  )  )  ;", "assertEquals (  \" p 2  \"  ,    parsedSql . getParameterNames (  )  . get (  1  )  )  ;", "String   finalSql    =     . substituteNamedParameters ( parsedSql ,    null )  ;", "assertEquals ( expectedSql ,    finalSql )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithBracketDelimitedParameterNames"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select   foo   from   bar   where   baz    =    b :  {  } z \"  ;", "String   sql    =     \" select   foo   from   bar   where   baz    =    b :  {  } z \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  0  ,    parsedSql . getParameterNames (  )  . size (  )  )  ;", "String   finalSql    =     . substituteNamedParameters ( parsedSql ,    null )  ;", "assertEquals ( expectedSql ,    finalSql )  ;", "String   expectedSql 2     =     \" select   foo   from   bar   where   baz    =     ' b :  { p 1  } z '  \"  ;", "String   sql 2     =     \" select   foo   from   bar   where   baz    =     ' b :  { p 1  } z '  \"  ;", "ParsedSql   parsedSql 2     =     . parseSqlStatement ( sql 2  )  ;", "assertEquals (  0  ,    parsedSql 2  . getParameterNames (  )  . size (  )  )  ;", "String   finalSql 2     =     . substituteNamedParameters ( parsedSql 2  ,    null )  ;", "assertEquals ( expectedSql 2  ,    finalSql 2  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithEmptyBracketsOrBracketsInQuotes"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select    \\  '  0  \\  \\  :  0  \\  '    as   a ,    foo   from   bar   where   baz    <    DATE (  ?     2  3  :  5  9  :  5  9  )    and   baz    =     ?  \"  ;", "String   sql    =     \" select    \\  '  0  \\  \\  :  0  \\  '    as   a ,    foo   from   bar   where   baz    <    DATE (  : p 1     2  3  \\  \\  :  5  9  \\  \\  :  5  9  )    and   baz    =     : p 2  \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  2  ,    parsedSql . getParameterNames (  )  . size (  )  )  ;", "assertEquals (  \" p 1  \"  ,    parsedSql . getParameterNames (  )  . get (  0  )  )  ;", "assertEquals (  \" p 2  \"  ,    parsedSql . getParameterNames (  )  . get (  1  )  )  ;", "String   finalSql    =     . substituteNamedParameters ( parsedSql ,    null )  ;", "assertEquals ( expectedSql ,    finalSql )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithEscapedColon"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" xxx    &    yyyy \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( expectedSql )  ;", "assertEquals ( expectedSql ,     . substituteNamedParameters ( parsedSql ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithLogicalAnd"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select    \\  '  [  \\  \"  3  \\  \"  ,     \\  \"  1  1  \\  \"  ]  \\  '  :  : jsonb    ?  &     \\  '  {  1  ,  3  ,  1  1  ,  1  2  ,  1  7  }  \\  '  :  : text [  ]    AND    ?     =     \\  ' Back   in   Black \\  '  \"  ;", "String   sql    =     \" select    \\  '  [  \\  \"  3  \\  \"  ,     \\  \"  1  1  \\  \"  ]  \\  '  :  : jsonb    ?  &     \\  '  {  1  ,  3  ,  1  1  ,  1  2  ,  1  7  }  \\  '  :  : text [  ]    AND    : album    =     \\  ' Back   in   Black \\  '  \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  1  ,    parsedSql . getTotalParameterCount (  )  )  ;", "assertEquals ( expectedSql ,     . substituteNamedParameters ( parsedSql ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithPostgresAllArrayStringsExistsOperator"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select    \\  '  [  \\  \"  3  \\  \"  ,     \\  \"  1  1  \\  \"  ]  \\  '  :  : jsonb    ?  |     \\  '  {  1  ,  3  ,  1  1  ,  1  2  ,  1  7  }  \\  '  :  : text [  ]  \"  ;", "String   sql    =     \" select    \\  '  [  \\  \"  3  \\  \"  ,     \\  \"  1  1  \\  \"  ]  \\  '  :  : jsonb    ?  |     \\  '  {  1  ,  3  ,  1  1  ,  1  2  ,  1  7  }  \\  '  :  : text [  ]  \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  0  ,    parsedSql . getTotalParameterCount (  )  )  ;", "assertEquals ( expectedSql ,     . substituteNamedParameters ( parsedSql ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithPostgresAnyArrayStringsExistsOperator"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select    ' first   name '    from   artists   where   id    =     ?    and   birth _ date =  ?  :  : timestamp \"  ;", "String   sql    =     \" select    ' first   name '    from   artists   where   id    =     : id   and   birth _ date =  : birthDate :  : timestamp \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( sql )  ;", "assertEquals ( expectedSql ,     . substituteNamedParameters ( parsedSql ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithPostgresCasting"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select    \\  ' first   name \\  '    from   artists   where   info -  >  \\  ' stat \\  '  -  >  \\  ' albums \\  '     =     ?  ?     ?    and    \\  '  [  \\  \"  1  \\  \"  ,  \\  \"  2  \\  \"  ,  \\  \"  3  \\  \"  ]  \\  '  :  : jsonb    ?  ?     \\  '  4  \\  '  \"  ;", "String   sql    =     \" select    \\  ' first   name \\  '    from   artists   where   info -  >  \\  ' stat \\  '  -  >  \\  ' albums \\  '     =     ?  ?     : album   and    \\  '  [  \\  \"  1  \\  \"  ,  \\  \"  2  \\  \"  ,  \\  \"  3  \\  \"  ]  \\  '  :  : jsonb    ?  ?     \\  '  4  \\  '  \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  1  ,    parsedSql . getTotalParameterCount (  )  )  ;", "assertEquals ( expectedSql ,     . substituteNamedParameters ( parsedSql ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithPostgresContainedOperator"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT    '  : foo '  '  : doo '  ,     : xxx   FROM   DUAL \"  ;", "ParsedSql   psql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  1  ,    psql . getTotalParameterCount (  )  )  ;", "assertEquals (  \" xxx \"  ,    psql . getParameterNames (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithQuotedSingleQuote"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   sql 2     =     \" SELECT    '  : foo '  /  *  : doo *  /  ,     : xxx   FROM   DUAL \"  ;", "ParsedSql   psql 2     =     . parseSqlStatement ( sql 2  )  ;", "assertEquals (  1  ,    psql 2  . getTotalParameterCount (  )  )  ;", "assertEquals (  \" xxx \"  ,    psql 2  . getParameterNames (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithQuotesAndCommentAfter"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT    /  *  : doo *  /  '  : foo '  ,     : xxx   FROM   DUAL \"  ;", "ParsedSql   psql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  1  ,    psql . getTotalParameterCount (  )  )  ;", "assertEquals (  \" xxx \"  ,    psql . getParameterNames (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithQuotesAndCommentBefore"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select   foo   from   bar   where   baz    =    b ? z \"  ;", "String   sql    =     \" select   foo   from   bar   where   baz    =    b :  { p } z \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( sql )  ;", "assertEquals (  1  ,    parsedSql . getParameterNames (  )  . size (  )  )  ;", "assertEquals (  \" p \"  ,    parsedSql . getParameterNames (  )  . get (  0  )  )  ;", "String   finalSql    =     . substituteNamedParameters ( parsedSql ,    null )  ;", "assertEquals ( expectedSql ,    finalSql )  ;", "}", "METHOD_END"], "methodName": ["parseSqlStatementWithSingleLetterInBrackets"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "MapSqlParameterSource   namedParams    =    new   MapSqlParameterSource (  )  ;", "namedParams . addValue (  \" a \"  ,     \" a \"  )  . addValue (  \" b \"  ,     \" b \"  )  . addValue (  \" c \"  ,     \" c \"  )  ;", "assertEquals (  \" xxx    ?     ?     ?  \"  ,     . substituteNamedParameters (  \" xxx    : a    : b    : c \"  ,    namedParams )  )  ;", "assertEquals (  \" xxx    ?     ?     ?    xx    ?     ?  \"  ,     . substituteNamedParameters (  \" xxx    : a    : b    : c   xx    : a    : a \"  ,    namedParams )  )  ;", "}", "METHOD_END"], "methodName": ["substituteNamedParameters"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" xxx    &    yyyy \"  ;", "String   newSql    =     . substituteNamedParameters ( expectedSql ,    new   MapSqlParameterSource (  )  )  ;", "assertEquals ( expectedSql ,    newSql )  ;", "}", "METHOD_END"], "methodName": ["substituteNamedParametersWithLogicalAnd"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select    ' first   name '    from   artists   where   id    =     ?    and   quote    =     ' exsqueeze   me ?  '  \"  ;", "String   sql    =     \" select    ' first   name '    from   artists   where   id    =     : id   and   quote    =     ' exsqueeze   me ?  '  \"  ;", "String   newSql    =     . substituteNamedParameters ( sql ,    new   MapSqlParameterSource (  )  )  ;", "assertEquals ( expectedSql ,    newSql )  ;", "}", "METHOD_END"], "methodName": ["substituteNamedParametersWithStringContainingQuotes"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" select    ' first   name '    from   artists   where   id    =     ?    and   quote    =     ' exsqueeze   me ?  '  \"  ;", "String   sql    =     \" select    ' first   name '    from   artists   where   id    =     : id   and   quote    =     ' exsqueeze   me ?  '  \"  ;", "ParsedSql   parsedSql    =     . parseSqlStatement ( sql )  ;", "assertEquals ( expectedSql ,     . substituteNamedParameters ( parsedSql ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testParseSqlStatementWithStringContainingQuotes"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedSql    =     \" x    :  =     1  \"  ;", "String   newSql    =     . substituteNamedParameters ( expectedSql ,    new   MapSqlParameterSource (  )  )  ;", "assertEquals ( expectedSql ,    newSql )  ;", "}", "METHOD_END"], "methodName": ["variableAssignmentOperator"], "fileName": "org.springframework.jdbc.core.namedparam.NamedParameterUtilsTests"}, {"methodBody": ["METHOD_START", "{", "this . parameterNames . add ( parameterName )  ;", "this . parameterIndexes . add ( new   int [  ]  {    startIndex ,    endIndex    }  )  ;", "}", "METHOD_END"], "methodName": ["addNamedParameter"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "return   this . namedParameterCount ;", "}", "METHOD_END"], "methodName": ["getNamedParameterCount"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "return   this . originalSql ;", "}", "METHOD_END"], "methodName": ["getOriginalSql"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterIndexes . get ( parameterPosition )  ;", "}", "METHOD_END"], "methodName": ["getParameterIndexes"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterNames ;", "}", "METHOD_END"], "methodName": ["getParameterNames"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "return   this . totalParameterCount ;", "}", "METHOD_END"], "methodName": ["getTotalParameterCount"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "return   this . unnamedParameterCount ;", "}", "METHOD_END"], "methodName": ["getUnnamedParameterCount"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "this . namedParameterCount    =    namedParameterCount ;", "}", "METHOD_END"], "methodName": ["setNamedParameterCount"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "this . totalParameterCount    =    totalParameterCount ;", "}", "METHOD_END"], "methodName": ["setTotalParameterCount"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "this . unnamedParameterCount    =    unnamedParameterCount ;", "}", "METHOD_END"], "methodName": ["setUnnamedParameterCount"], "fileName": "org.springframework.jdbc.core.namedparam.ParsedSql"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getParameterNames"], "fileName": "org.springframework.jdbc.core.namedparam.SqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "return   SqlParameterSource . TYPE _ UNKNOWN ;", "}", "METHOD_END"], "methodName": ["getSqlType"], "fileName": "org.springframework.jdbc.core.namedparam.SqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getTypeName"], "fileName": "org.springframework.jdbc.core.namedparam.SqlParameterSource"}, {"methodBody": ["METHOD_START", "{", "return   SqlParameterSourceUtils . createBatch ( Arrays . asList ( candidates )  )  ;", "}", "METHOD_END"], "methodName": ["createBatch"], "fileName": "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils"}, {"methodBody": ["METHOD_START", "{", "SqlParameterSource [  ]    batch    =    new   SqlParameterSource [ candidates . size (  )  ]  ;", "int   i    =     0  ;", "for    ( Object   candidate    :    candidates )     {", "batch [ i ]     =     ( candidate   instanceof   Map )     ?    new   MapSqlParameterSource (  (  ( Map < String ,     ?  >  )     ( candidate )  )  )     :    new   BeanPropertySqlParameterSource ( candidate )  ;", "i +  +  ;", "}", "return   batch ;", "}", "METHOD_END"], "methodName": ["createBatch"], "fileName": "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils"}, {"methodBody": ["METHOD_START", "{", "SqlParameterSource [  ]    batch    =    new   SqlParameterSource [ valueMaps . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( valueMaps . length )  ;    i +  +  )     {", "batch [ i ]     =    new   MapSqlParameterSource ( valueMaps [ i ]  )  ;", "}", "return   batch ;", "}", "METHOD_END"], "methodName": ["createBatch"], "fileName": "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    caseInsensitiveParameterNames    =    new   HashMap <  >  (  )  ;", "String [  ]    paramNames    =    p . getParameterNames (  )  ;", "if    ( paramNames    !  =    null )     {", "for    ( String   name    :    paramNames )     {", "caseInsensitiveParameterNames . put ( name . toLowerCase (  )  ,    name )  ;", "}", "}", "return   caseInsensitiveParameterNames ;", "}", "METHOD_END"], "methodName": ["extractCaseInsensitiveParameterNames"], "fileName": "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils"}, {"methodBody": ["METHOD_START", "{", "int   sqlType    =    source . getSqlType ( parameterName )  ;", "if    ( sqlType    !  =     (  . TYPE _ UNKNOWN )  )     {", "if    (  ( source . getTypeName ( parameterName )  )     !  =    null )     {", "return   new   SqlParameterValue ( sqlType ,    source . getTypeName ( parameterName )  ,    source . getValue ( parameterName )  )  ;", "} else    {", "return   new   SqlParameterValue ( sqlType ,    source . getValue ( parameterName )  )  ;", "}", "} else    {", "return   source . getValue ( parameterName )  ;", "}", "}", "METHOD_END"], "methodName": ["getTypedValue"], "fileName": "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( parameter ,     \" The   supplied   parameter   must   not   be   null \"  )  ;", "if    (  !  ( StringUtils . hasText ( parameter . getName (  )  )  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  \" You   must   specify   a   parameter   name   when   declaring   parameters   for    \\  \"  \"     +     ( getProcedureName (  )  )  )     +     \"  \\  \"  \"  )  )  ;", "}", "this . declaredParameters . add ( parameter )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Added   declared   parameter   for    [  \"     +     ( getProcedureName (  )  )  )     +     \"  ]  :     \"  )     +     ( parameter . getName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addDeclaredParameter"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "this . declaredRowMappers . put ( parameterName ,    rowMapper )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Added   row   mapper   for    [  \"     +     ( getProcedureName (  )  )  )     +     \"  ]  :     \"  )     +    parameterName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addDeclaredRowMapper"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isCompiled (  )  )  )     {", "logger . debug (  \"    call   not   compiled   before   execution    -    invoking   compile \"  )  ;", "compile (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkCompiled"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isCompiled (  )  )  )     {", "if    (  ( getProcedureName (  )  )     =  =    null )     {", "throw   new   InvalidDataAccessApiUsageException (  \" Procedure   or   Function   name   is   required \"  )  ;", "}", "try    {", "thisTemplate . afterPropertiesSet (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   InvalidDataAccessApiUsageException ( ex . getMessage (  )  )  ;", "}", "compileInternal (  )  ;", "this . compiled    =    true ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" SqlCall   for    \"     +     ( isFunction (  )     ?     \" function \"     :     \" procedure \"  )  )     +     \"     [  \"  )     +     ( getProcedureName (  )  )  )     +     \"  ]    compiled \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "DataSource   dataSource    =    getJdbcTemplate (  )  . getDataSource (  )  ;", "Assert . state (  ( dataSource    !  =    null )  ,     \" No   DataSource   set \"  )  ;", "this . callMetaDataContext . initializeMetaData ( dataSource )  ;", "this . declaredRowMappers . forEach (  (    key ,    value )     -  >     {", "this . declaredParameters . add ( this . callMetaDataContext . createReturnResultSetParameter ( key ,    value )  )  ;", "}  )  ;", "this . callMetaDataContext . processParameters ( this . declaredParameters )  ;", "this . callString    =    this . callMetaDataContext . createCallString (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Compiled   stored   procedure .    Call   string   is    [  \"     +     ( this . callString )  )     +     \"  ]  \"  )  )  ;", "}", "this . callableStatementFactory    =    new   CallableStatementCreatorFactory ( this . callString ,    this . callMetaDataContext . getCallParameters (  )  )  ;", "onCompileInternal (  )  ;", "}", "METHOD_END"], "methodName": ["compileInternal"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "Map < St ,     ?  >    params    =    matchInParameterValuesWithCallParameters ( args )  ;", "return   executeCallInternal ( params )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "Map < St ,     ?  >    params    =    matchInParameterValuesWithCallParameters ( args )  ;", "return   executeCallInternal ( params )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "Map < St ,    Object >    params    =    matchInParameterValuesWithCallParameters ( parameterSource )  ;", "return   executeCallInternal ( params )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "CallableStatementCreator   csc    =    getCallableStatementFactory (  )  . newCallableStatementCreator ( args )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" The   following   parameters   are   used   for   call    \"     +     ( getCallString (  )  )  )     +     \"    with    \"  )     +    args )  )  ;", "int   i    =     1  ;", "for    ( SqlParameter   param    :    getCallParameters (  )  )     {", "logger . debug (  (  (  (  (  (  (  (  (  ( i    +     \"  :     \"  )     +     ( param . getName (  )  )  )     +     \"  ,    SQL   type    \"  )     +     ( param . getSqlType (  )  )  )     +     \"  ,    type   name    \"  )     +     ( param . getTypeName (  )  )  )     +     \"  ,    parameter   class    [  \"  )     +     ( param . getClass (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "i +  +  ;", "}", "}", "return   geTemplate (  )  . call ( csc ,    getCallParameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["executeCallInternal"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . getCallParameters (  )  ;", "}", "METHOD_END"], "methodName": ["getCallParameters"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callString ;", "}", "METHOD_END"], "methodName": ["getCallString"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . callableStatementFactory )     !  =    null )  ,     \" No   CallableStatementCreatorFactory   available \"  )  ;", "return   this . callableStatementFactory ;", "}", "METHOD_END"], "methodName": ["getCallableStatementFactory"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . getCatalogName (  )  ;", "}", "METHOD_END"], "methodName": ["getCatalogName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . getLimitedInParameterNames (  )  ;", "}", "METHOD_END"], "methodName": ["getInParameterNames"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . jdbcTemplate ;", "}", "METHOD_END"], "methodName": ["getJdbcTemplate"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . getProcedureName (  )  ;", "}", "METHOD_END"], "methodName": ["getProcedureName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . getScalarOutParameterName (  )  ;", "}", "METHOD_END"], "methodName": ["getScalarOutParameterName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . getSchemaName (  )  ;", "}", "METHOD_END"], "methodName": ["getSchemaName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . compiled ;", "}", "METHOD_END"], "methodName": ["isCompiled"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . isFunction (  )  ;", "}", "METHOD_END"], "methodName": ["isFunction"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . isNamedBinding (  )  ;", "}", "METHOD_END"], "methodName": ["isNamedBinding"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . isReturnValueRequired (  )  ;", "}", "METHOD_END"], "methodName": ["isReturnValueRequired"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . matchInParameterValuesWithCallParameters ( args )  ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithCallParameters"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . matchInParameterValuesWithCallParameters ( args )  ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithCallParameters"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "return   this . callMetaDataContext . matchInParameterValuesWithCallParameters ( parameterSource )  ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithCallParameters"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "this . callMetaDataContext . setAccessCallParameterMetaData ( accessCallParameterMetaData )  ;", "}", "METHOD_END"], "methodName": ["setAccessCallParameterMetaData"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "this . callMetaDataContext . setCatalogName ( catalogName )  ;", "}", "METHOD_END"], "methodName": ["setCatalogName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "this . callMetaDataContext . setFunction ( function )  ;", "}", "METHOD_END"], "methodName": ["setFunction"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "this . callMetaDataContext . setLimitedInParameterNames ( inParameterNames )  ;", "}", "METHOD_END"], "methodName": ["setInParameterNames"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "this . callMetaDataContext . setNamedBinding ( namedBinding )  ;", "}", "METHOD_END"], "methodName": ["setNamedBinding"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "this . callMetaDataContext . setProcedureName ( procedureName )  ;", "}", "METHOD_END"], "methodName": ["setProcedureName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "this . callMetaDataContext . setReturnValueRequired ( returnValueRequired )  ;", "}", "METHOD_END"], "methodName": ["setReturnValueRequired"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "this . callMetaDataContext . setSchemaName ( schemaName )  ;", "}", "METHOD_END"], "methodName": ["setSchemaName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcCall"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isCompiled (  )  )  )     {", "logger . debug (  \"    not   compiled   before   execution    -    invoking   compile \"  )  ;", "compile (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkCompiled"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "if    ( isCompiled (  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  \" Configuration   cannot   be   altered   once   the   class   has   been   compiled   or   used \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkIfConfigurationModificationIsAllowed"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isCompiled (  )  )  )     {", "if    (  ( getTableName (  )  )     =  =    null )     {", "throw   new   InvalidDataAccessApiUsageException (  \" Table   name   is   required \"  )  ;", "}", "try    {", "this . jdbcTemplate . afterPropertiesSet (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   InvalidDataAccessApiUsageException ( ex . getMessage (  )  )  ;", "}", "compileInternal (  )  ;", "this . compiled    =    true ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \"    for   table    [  \"     +     ( getTableName (  )  )  )     +     \"  ]    compiled \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "DataSource   dataSource    =    getJdbcTemplate (  )  . getDataSource (  )  ;", "Assert . state (  ( dataSource    !  =    null )  ,     \" No   DataSource   set \"  )  ;", "this . tableMetaDataContext . processMetaData ( dataSource ,    getColumnNames (  )  ,    getGeneratedKeyNames (  )  )  ;", "this . insertString    =    this . tableMetaDataContext . createString ( getGeneratedKeyNames (  )  )  ;", "this . insertTypes    =    this . tableMetaDataContext . createTypes (  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Compiled   insert   object :    insert   string   is    [  \"     +     ( this . insertString )  )     +     \"  ]  \"  )  )  ;", "}", "onCompileInternal (  )  ;", "}", "METHOD_END"], "methodName": ["compileInternal"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "List < Object >    values    =    matchInParameterValuesWithColumns ( args )  ;", "return   executeInternal ( values )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "List < Object >    values    =    matchInParameterValuesWithColumns ( parameterSource )  ;", "return   executeInternal ( values )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "List < Object >    values    =    matchInParameterValuesWithColumns ( args )  ;", "return   executeAndReturnKeyInternal ( values )  ;", "}", "METHOD_END"], "methodName": ["doExecuteAndReturnKey"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "List < Object >    values    =    matchInParameterValuesWithColumns ( parameterSource )  ;", "return   executeAndReturnKeyInternal ( values )  ;", "}", "METHOD_END"], "methodName": ["doExecuteAndReturnKey"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "List < Object >    values    =    matchInParameterValuesWithColumns ( args )  ;", "return   executeAndReturnKeyHolderInternal ( values )  ;", "}", "METHOD_END"], "methodName": ["doExecuteAndReturnKeyHolder"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "List < Object >    values    =    matchInParameterValuesWithColumns ( parameterSource )  ;", "return   executeAndReturnKeyHolderInternal ( values )  ;", "}", "METHOD_END"], "methodName": ["doExecuteAndReturnKeyHolder"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "List < List < Object >  >    batchValues    =    new   ArrayList <  >  ( batch . length )  ;", "for    ( Map < String ,     ?  >    args    :    batch )     {", "batchValues . add ( matchInParameterValuesWithColumns ( args )  )  ;", "}", "return   executeBatchInternal ( batchValues )  ;", "}", "METHOD_END"], "methodName": ["doExecuteBatch"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "List < List < Object >  >    batchValues    =    new   ArrayList <  >  ( batch . length )  ;", "for    ( SqlParameterSource   parameterSource    :    batch )     {", "batchValues . add ( matchInParameterValuesWithColumns ( parameterSource )  )  ;", "}", "return   executeBatchInternal ( batchValues )  ;", "}", "METHOD_END"], "methodName": ["doExecuteBatch"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Executing   statement    \"     +     ( getString (  )  )  )     +     \"    with   batch   of   size :     \"  )     +     ( batchValues . size (  )  )  )  )  ;", "}", "return   getJdbcTemplate (  )  . batchUpdate ( getString (  )  ,    new   BatchPreparedStatementSetter (  )     {", "@ Override", "public   void   setValues ( PreparedStatement   ps ,    int   i )    throws   SQLException    {", "setParameterValues ( ps ,    batchValues . get ( i )  ,    getTypes (  )  )  ;", "}", "@ Override", "public   int   getBatchSize (  )     {", "return   batchValues . size (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["executeBatchInternal"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" The   following   parameters   are   used   for   call    \"     +     ( getString (  )  )  )     +     \"    with :     \"  )     +    values )  )  ;", "}", "final   KeyHolder   keyHolder    =    new   GeneratedKeyHolder (  )  ;", "if    ( this . tableMetaDataContext . isGetGeneratedKeysSupported (  )  )     {", "getJdbcTemplate (  )  . update (  (    con )     -  >     {", "PreparedStatement   ps    =    prepareStatementForGeneratedKeys ( con )  ;", "setParameterValues ( ps ,    values ,    getTypes (  )  )  ;", "return   ps ;", "}  ,    keyHolder )  ;", "} else    {", "if    (  !  ( this . tableMetaDataContext . isGetGeneratedKeysSimulated (  )  )  )     {", "throw   new   InvalidDataAccessResourceUsageException (  \" The   getGeneratedKeys   feature   is   not   supported   by   this   database \"  )  ;", "}", "if    (  ( getGeneratedKeyNames (  )  . length )     <     1  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  \" Generated   Key   Name ( s )    not   specified .     \"     +     \" Using   the   generated   keys   features   requires   specifying   the   name ( s )    of   the   generated   column ( s )  \"  )  )  ;", "}", "if    (  ( getGeneratedKeyNames (  )  . length )     >     1  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  \" Current   database   only   supports   retrieving   the   key   for   a   single   column .    There   are    \"     +     ( getGeneratedKeyNames (  )  . length )  )     +     \"    columns   specified :     \"  )     +     ( Arrays . asList ( getGeneratedKeyNames (  )  )  )  )  )  ;", "}", "Assert . state (  (  ( getTableName (  )  )     !  =    null )  ,     \" No   table   name   set \"  )  ;", "final   String   keyQuery    =    this . tableMetaDataContext . getSimpleQueryForGetGeneratedKey ( getTableName (  )  ,    getGeneratedKeyNames (  )  [  0  ]  )  ;", "Assert . state (  ( keyQuery    !  =    null )  ,     \" Query   for   simulating   get   generated   keys   must   not   be   null \"  )  ;", "if    ( keyQuery . toUpperCase (  )  . startsWith (  \" RETURNING \"  )  )     {", "Long   key    =    getJdbcTemplate (  )  . queryForObject (  (  (  ( getString (  )  )     +     \"     \"  )     +    keyQuery )  ,    values . toArray (  )  ,    Long . class )  ;", "Map < String ,    Object >    keys    =    new   HashMap <  >  (  1  )  ;", "keys . put ( getGeneratedKeyNames (  )  [  0  ]  ,    key )  ;", "keyHolder . getKeyList (  )  . add ( keys )  ;", "} else    {", "getJdbcTemplate (  )  . execute (  (  ( ConnectionCallback < Object >  )     (  (    con )     -  >     {", "PreparedStatement   ps    =    null ;", "try    {", "ps    =    con . prepareStatement ( getString (  )  )  ;", "setParameterValues ( ps ,    values ,    getTypes (  )  )  ;", "ps . executeUpdate (  )  ;", "}    finally    {", "JdbcUtils . closeStatement ( ps )  ;", "}", "Statement   keyStmt    =    null ;", "ResultSet   rs    =    null ;", "Map < String ,    Object >    keys    =    new   HashMap <  >  (  1  )  ;", "try    {", "keyStmt    =    con . createStatement (  )  ;", "rs    =    keyStmt . executeQuery ( keyQuery )  ;", "if    ( rs . next (  )  )     {", "long   key    =    rs . getLong (  1  )  ;", "keys . put ( getGeneratedKeyNames (  )  [  0  ]  ,    key )  ;", "keyHolder . getKeyList (  )  . add ( keys )  ;", "}", "}    finally    {", "JdbcUtils . closeResultSet ( rs )  ;", "JdbcUtils . closeStatement ( keyStmt )  ;", "}", "return   null ;", "}  )  )  )  ;", "}", "}", "return   keyHolder ;", "}", "METHOD_END"], "methodName": ["executeInsertAndReturnKeyHolderInternal"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "KeyHolder   kh    =    executeInsertAndReturnKeyHolderInternal ( values )  ;", "if    (  ( kh . getKey (  )  )     !  =    null )     {", "return   kh . getKey (  )  ;", "} else    {", "throw   new   DataIntegrityViolationException (  (  \" Unable   to   retrieve   the   generated   key   for   the   insert :     \"     +     ( getInsertString (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["executeInsertAndReturnKeyInternal"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" The   following   parameters   are   used   for   insert    \"     +     ( getString (  )  )  )     +     \"    with :     \"  )     +    values )  )  ;", "}", "return   getJdbcTemplate (  )  . update ( getString (  )  ,    values . toArray (  )  ,    getTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["executeInsertInternal"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . tableMetaDataContext . getCatalogName (  )  ;", "}", "METHOD_END"], "methodName": ["getCatalogName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . declaredColumns )  ;", "}", "METHOD_END"], "methodName": ["getColumnNames"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . generatedKeyNames ;", "}", "METHOD_END"], "methodName": ["getGeneratedKeyNames"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . insertString ;", "}", "METHOD_END"], "methodName": ["getInsertString"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . insertTypes ;", "}", "METHOD_END"], "methodName": ["getInsertTypes"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . jdbcTemplate ;", "}", "METHOD_END"], "methodName": ["getJdbcTemplate"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . tableMetaDataContext . getSchemaName (  )  ;", "}", "METHOD_END"], "methodName": ["getSchemaName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . tableMetaDataContext . getTableName (  )  ;", "}", "METHOD_END"], "methodName": ["getTableName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . compiled ;", "}", "METHOD_END"], "methodName": ["isCompiled"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . tableMetaDataContext . matchInParameterValuesWithInsertColumns ( args )  ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithInsertColumns"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "return   this . tableMetaDataContext . matchInParameterValuesWithInsertColumns ( parameterSource )  ;", "}", "METHOD_END"], "methodName": ["matchInParameterValuesWithInsertColumns"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getGeneratedKeyNames (  )  . length )     <     1  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  \" Generated   Key   Name ( s )    not   specified .     \"     +     \" Using   the   generated   keys   features   requires   specifying   the   name ( s )    of   the   generated   column ( s )  .  \"  )  )  ;", "}", "PreparedStatement   ps ;", "if    ( this . tableMetaDataContext . isGeneratedKeysColumnNameArraySupported (  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  \" Using   generated   keys   support   with   array   of   column   names .  \"  )  ;", "}", "ps    =    con . prepareStatement ( getString (  )  ,    getGeneratedKeyNames (  )  )  ;", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  \" Using   generated   keys   support   with   Statement . RETURN _ GENERATED _ KEYS .  \"  )  ;", "}", "ps    =    con . prepareStatement ( getString (  )  ,    Statement . RETURN _ GENERATED _ KEYS )  ;", "}", "return   ps ;", "}", "METHOD_END"], "methodName": ["prepareStatementForGeneratedKeys"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "this . tableMetaDataContext . setAccessTableColumnMetaData ( accessTableColumnMetaData )  ;", "}", "METHOD_END"], "methodName": ["setAccessTableColumnMetaData"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkIfConfigurationModificationIsAllowed (  )  ;", "this . tableMetaDataContext . setCatalogN ( catalogN )  ;", "}", "METHOD_END"], "methodName": ["setCatalogName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkIfConfigurationModificationIsAllowed (  )  ;", "this . declaredColumns . clear (  )  ;", "this . declaredColumns . addAll ( columnNs )  ;", "}", "METHOD_END"], "methodName": ["setColumnNames"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkIfConfigurationModificationIsAllowed (  )  ;", "this . generatedKeyNames    =    new   St [  ]  {    generatedKeyName    }  ;", "}", "METHOD_END"], "methodName": ["setGeneratedKeyName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkIfConfigurationModificationIsAllowed (  )  ;", "this . generatedKeyNs    =    generatedKeyNs ;", "}", "METHOD_END"], "methodName": ["setGeneratedKeyNames"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "this . tableMetaDataContext . setOverrideIncludeSynonymsDefault ( override )  ;", "}", "METHOD_END"], "methodName": ["setOverrideIncludeSynonymsDefault"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "int   colIndex    =     0  ;", "for    ( Object   value    :    values )     {", "colIndex +  +  ;", "if    (  ( columnTypes    =  =    null )     |  |     ( colIndex    >     ( columnTypes . length )  )  )     {", "StatementCreatorUtils . setPaterValue ( preparedStatement ,    colIndex ,    SqlTypeValue . TYPE _ UNKNOWN ,    value )  ;", "} else    {", "StatementCreatorUtils . setPaterValue ( preparedStatement ,    colIndex ,    columnTypes [  ( colIndex    -     1  )  ]  ,    value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setParameterValues"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkIfConfigurationModificationIsAllowed (  )  ;", "this . tableMetaDataContext . setSchemaN ( schemaN )  ;", "}", "METHOD_END"], "methodName": ["setSchemaName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "checkIfConfigurationModificationIsAllowed (  )  ;", "this . tableMetaDataContext . setTableN ( tableN )  ;", "}", "METHOD_END"], "methodName": ["setTableName"], "fileName": "org.springframework.jdbc.core.simple.AbstractJdbcInsert"}, {"methodBody": ["METHOD_START", "{", "connection    =    mock ( Connection . class )  ;", "database    =    mock ( Database . class )  ;", "given ( connection . get (  )  )  . willReturn ( database )  ;", "dataSource    =    mock ( DataSource . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.core.simple.CallMetaDataContextTests"}, {"methodBody": ["METHOD_START", "{", "final   String   TABLE    =     \" customers \"  ;", "final   String   USER    =     \" me \"  ;", "given ( database . getDatabaseProductName (  )  )  . willReturn (  \" MyDB \"  )  ;", "given ( database . getUserName (  )  )  . willReturn ( USER )  ;", "given ( database . storesLowerCaseIdentifiers (  )  )  . willReturn ( true )  ;", "List < SqlParameter >    parameters    =    new   ArrayList <  >  (  )  ;", "parameters . add ( new   SqlParameter (  \" id \"  ,    Types . NUMERIC )  )  ;", "parameters . add ( new   SqlInOutParameter (  \" name \"  ,    Types . NUMERIC )  )  ;", "parameters . add ( new   SqlOutParameter (  \" customer _ no \"  ,    Types . NUMERIC )  )  ;", "MapSqlParameterSource   parameterSource    =    new   MapSqlParameterSource (  )  ;", "parameterSource . addValue (  \" id \"  ,     1  )  ;", "parameterSource . addValue (  \" name \"  ,     \" Sven \"  )  ;", "parameterSource . addValue (  \" customer _ no \"  ,     \"  1  2  3  4  5 XYZ \"  )  ;", "context . setProcedureName ( TABLE )  ;", "context . initialize ( dataSource )  ;", "context . processParameters ( parameters )  ;", "Map < String ,    Object >    inParameters    =    context . matchInParameterValuesWithCallParameters ( parameterSource )  ;", "assertEquals (  \" Wrong   number   of   matched   in   parameter   values \"  ,     2  ,    inParameters . size (  )  )  ;", "assertTrue (  \" in   parameter   value   missing \"  ,    inParameters . containsKey (  \" id \"  )  )  ;", "assertTrue (  \" in   out   parameter   value   missing \"  ,    inParameters . containsKey (  \" name \"  )  )  ;", "assertTrue (  \" out   parameter   value   matched \"  ,     (  !  ( inParameters . containsKey (  \" customer _ no \"  )  )  )  )  ;", "List < String >    names    =    context . getOutParameterNames (  )  ;", "assertEquals (  \" Wrong   number   of   out   parameters \"  ,     2  ,    names . size (  )  )  ;", "List < SqlParameter >    callParameters    =    context . getCallParameters (  )  ;", "assertEquals (  \" Wrong   number   of   call   parameters \"  ,     3  ,    callParameters . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMatchParameterValuesAndSqlInOutParameters"], "fileName": "org.springframework.jdbc.core.simple.CallMetaDataContextTests"}, {"methodBody": ["METHOD_START", "{", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["verifyClosed"], "fileName": "org.springframework.jdbc.core.simple.CallMetaDataContextTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   proceduresResultSet    =    mock ( ResultSet . class )  ;", "ResultSet   procedureColumnsResultSet    =    mock ( ResultSet . class )  ;", "given ( databaseMetaData . getDatabaseProductName (  )  )  . willReturn (  \" Oracle \"  )  ;", "given ( databaseMetaData . getUserName (  )  )  . willReturn (  \" ME \"  )  ;", "given ( databaseMetaData . storesUpperCaseIdentifiers (  )  )  . willReturn ( true )  ;", "given ( databaseMetaData . getProcedures (  \"  \"  ,     \" ME \"  ,     \" ADD _ INVOICE \"  )  )  . willReturn ( proceduresResultSet )  ;", "given ( databaseMetaData . getProcedureColumns (  \"  \"  ,     \" ME \"  ,     \" ADD _ INVOICE \"  ,    null )  )  . willReturn ( procedureColumnsResultSet )  ;", "given ( proceduresResultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( proceduresResultSet . getSt (  \" PROCEDURE _ NAME \"  )  )  . willReturn (  \" add _ invoice \"  )  ;", "given ( procedureColumnsResultSet . next (  )  )  . willReturn ( true ,    true ,    true ,    false )  ;", "given ( procedureColumnsResultSet . getInt (  \" DATA _ TYPE \"  )  )  . willReturn (  4  )  ;", "if    ( isFunction )     {", "given ( procedureColumnsResultSet . getSt (  \" COLUMN _ NAME \"  )  )  . willReturn ( null ,     \" amount \"  ,     \" custid \"  )  ;", "given ( procedureColumnsResultSet . getInt (  \" COLUMN _ TYPE \"  )  )  . willReturn (  5  ,     1  ,     1  )  ;", "given ( connection . prepareCall (  \"  {  ?     =    call   ADD _ INVOICE (  ?  ,     ?  )  }  \"  )  )  . willReturn ( callableStatement )  ;", "given ( callableStatement . getObject (  1  )  )  . willReturn (  4 L )  ;", "} else    {", "given ( procedureColumnsResultSet . getSt (  \" COLUMN _ NAME \"  )  )  . willReturn (  \" amount \"  ,     \" custid \"  ,     \" newid \"  )  ;", "given ( procedureColumnsResultSet . getInt (  \" COLUMN _ TYPE \"  )  )  . willReturn (  1  ,     1  ,     4  )  ;", "given ( connection . prepareCall (  \"  { call   ADD _ INVOICE (  ?  ,     ?  ,     ?  )  }  \"  )  )  . willReturn ( callableStatement )  ;", "given ( callableStatement . getObject (  3  )  )  . willReturn (  4 L )  ;", "}", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["initializeAddInvoiceWithMetaData"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "given ( databaseMetaData . getDatabaseProductName (  )  )  . willReturn (  \" MyDB \"  )  ;", "given ( databaseMetaData . getUserName (  )  )  . willReturn (  \" me \"  )  ;", "given ( databaseMetaData . storesLowerCaseIdentifiers (  )  )  . willReturn ( true )  ;", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "if    ( isFunction )     {", "given ( callableStatement . getObject (  1  )  )  . willReturn (  4 L )  ;", "given ( connection . prepare (  \"  {  ?     =    call   add _ invoice (  ?  ,     ?  )  }  \"  )  )  . willReturn ( callableStatement )  ;", "} else    {", "given ( callableStatement . getObject (  3  )  )  . willReturn (  4 L )  ;", "given ( connection . prepare (  \"  { call   add _ invoice (  ?  ,     ?  ,     ?  )  }  \"  )  )  . willReturn ( callableStatement )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeAddInvoiceWithoutMetaData"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "connection    =    mock ( Connection . class )  ;", "databaseMetaData    =    mock ( DatabaseMetaData . class )  ;", "dataSource    =    mock ( DataSource . class )  ;", "callableStatement    =    mock ( ableStatement . class )  ;", "given ( connection . getMetaData (  )  )  . willReturn ( databaseMetaData )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithMetaData ( true )  ;", "adder    =    new    ( dataSource )  . withFunctionName (  \" add _ invoice \"  )  ;", "Number   newId    =    adder . executeFunction ( Number . class ,     1  1  0  3  ,     3  )  ;", "assertEquals (  4  ,    newId . intValue (  )  )  ;", "verifyAddInvoiceWithMetaData ( true )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoiceFuncWithMetaDataUsingArrayParams"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithMetaData ( true )  ;", "adder    =    new    ( dataSource )  . withFunctionName (  \" add _ invoice \"  )  ;", "Number   newId    =    adder . executeFunction ( Number . class ,    new   MapSqlParameterSource (  )  . addValue (  \" amount \"  ,     1  1  0  3  )  . addValue (  \" custid \"  ,     3  )  )  ;", "assertEquals (  4  ,    newId . intValue (  )  )  ;", "verifyAddInvoiceWithMetaData ( true )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoiceFuncWithMetaDataUsingMapParamSource"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithoutMetaData ( true )  ;", "adder    =    new    ( dataSource )  . withFunctionName (  \" add _ invoice \"  )  ;", "adder . declareParameters ( new   SqlOutParameter (  \" return \"  ,    Types . INTEGER )  ,    new   SqlParameter (  \" amount \"  ,    Types . INTEGER )  ,    new   SqlParameter (  \" custid \"  ,    Types . INTEGER )  )  ;", "Number   newId    =    adder . executeFunction ( Number . class ,     1  1  0  3  ,     3  )  ;", "assertEquals (  4  ,    newId . intValue (  )  )  ;", "verifyAddInvoiceWithoutMetaData ( true )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoiceFuncWithoutMetaDataUsingArrayParams"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithoutMetaData ( true )  ;", "adder    =    new    ( dataSource )  . withFunctionName (  \" add _ invoice \"  )  ;", "adder . declareParameters ( new   SqlOutParameter (  \" return \"  ,    Types . INTEGER )  ,    new   SqlParameter (  \" amount \"  ,    Types . INTEGER )  ,    new   SqlParameter (  \" custid \"  ,    Types . INTEGER )  )  ;", "Number   newId    =    adder . executeFunction ( Number . class ,    new   MapSqlParameterSource (  )  . addValue (  \" amount \"  ,     1  1  0  3  )  . addValue (  \" custid \"  ,     3  )  )  ;", "assertEquals (  4  ,    newId . intValue (  )  )  ;", "verifyAddInvoiceWithoutMetaData ( true )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoiceFuncWithoutMetaDataUsingMapParamSource"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithMetaData ( false )  ;", "adder    =    new    ( dataSource )  . withProcedureName (  \" add _ invoice \"  )  ;", "Number   newId    =    adder . executeObject ( Number . class ,     1  1  0  3  ,     3  )  ;", "assertEquals (  4  ,    newId . intValue (  )  )  ;", "verifyAddInvoiceWithMetaData ( false )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoiceProcWithMetaDataUsingArrayParams"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithMetaData ( false )  ;", "adder    =    new    ( dataSource )  . withProcedureName (  \" add _ invoice \"  )  ;", "Number   newId    =    adder . executeObject ( Number . class ,    new   MapSqlParameterSource (  )  . addValue (  \" amount \"  ,     1  1  0  3  )  . addValue (  \" custid \"  ,     3  )  )  ;", "assertEquals (  4  ,    newId . intValue (  )  )  ;", "verifyAddInvoiceWithMetaData ( false )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoiceProcWithMetaDataUsingMapParamSource"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithoutMetaData ( false )  ;", "adder    =    new    ( dataSource )  . withProcedureName (  \" add _ invoice \"  )  ;", "adder . declareParameters ( new   SqlParameter (  \" amount \"  ,    Types . INTEGER )  ,    new   SqlParameter (  \" custid \"  ,    Types . INTEGER )  ,    new   SqlOutParameter (  \" newid \"  ,    Types . INTEGER )  )  ;", "Number   newId    =    adder . executeObject ( Number . class ,     1  1  0  3  ,     3  )  ;", "assertEquals (  4  ,    newId . intValue (  )  )  ;", "verifyAddInvoiceWithoutMetaData ( false )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoiceProcWithoutMetaDataUsingArrayParams"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithoutMetaData ( false )  ;", "adder    =    new    ( dataSource )  . withProcedureName (  \" add _ invoice \"  )  ;", "adder . declareParameters ( new   SqlParameter (  \" amount \"  ,    Types . INTEGER )  ,    new   SqlParameter (  \" custid \"  ,    Types . INTEGER )  ,    new   SqlOutParameter (  \" newid \"  ,    Types . INTEGER )  )  ;", "Number   newId    =    adder . executeObject ( Number . class ,    new   MapSqlParameterSource (  )  . addValue (  \" amount \"  ,     1  1  0  3  )  . addValue (  \" custid \"  ,     3  )  )  ;", "assertEquals (  4  ,    newId . intValue (  )  )  ;", "verifyAddInvoiceWithoutMetaData ( false )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoiceProcWithoutMetaDataUsingMapParamSource"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithMetaData ( true )  ;", "adder    =    new    ( dataSource )  . withFunctionName (  \" add _ invoice \"  )  ;", "adder . compile (  )  ;", "verifyStatement ( adder ,     \"  {  ?     =    call   ADD _ INVOICE (  ?  ,     ?  )  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectFunctionStatement"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithMetaData ( true )  ;", "adder    =    new    ( dataSource )  . withNamedBinding (  )  . withFunctionName (  \" add _ invoice \"  )  ;", "adder . compile (  )  ;", "verifyStatement ( adder ,     \"  {  ?     =    call   ADD _ INVOICE ( AMOUNT    =  >     ?  ,    CUSTID    =  >     ?  )  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectFunctionStatementNamed"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "initializeAddInvoiceWithMetaData ( false )  ;", "adder    =    new    ( dataSource )  . withNamedBinding (  )  . withProcedureName (  \" add _ invoice \"  )  ;", "adder . compile (  )  ;", "verifyStatement ( adder ,     \"  { call   ADD _ INVOICE ( AMOUNT    =  >     ?  ,    CUSTID    =  >     ?  ,    NEWID    =  >     ?  )  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectProcedureStatementNamed"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "final   String   NO _ SUCH _ PROC    =     \" x \"  ;", "SQLException   sqlException    =    new   SQLException (  \" Syntax   error   or   access   violation   exception \"  ,     \"  4  2  0  0  0  \"  )  ;", "given ( databaseMetaData . getDatabaseProductName (  )  )  . willReturn (  \" MyDB \"  )  ;", "given ( databaseMetaData . getDatabaseProductName (  )  )  . willReturn (  \" MyDB \"  )  ;", "given ( databaseMetaData . getUserName (  )  )  . willReturn (  \" me \"  )  ;", "given ( databaseMetaData . storesLowerCaseIdentifiers (  )  )  . willReturn ( true )  ;", "given ( callableStatement . execute (  )  )  . willThrow ( sqlException )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +    NO _ SUCH _ PROC )     +     \"  (  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", "sproc    =    new    ( dataSource )  . withProcedureName ( NO _ SUCH _ PROC )  ;", "thrown . expect ( BadSqlGrammarException . class )  ;", "thrown . expect ( exceptionCause ( sameInstance ( sqlException )  )  )  ;", "try    {", "sproc . execute (  )  ;", "}    finally    {", "verify ( callableStatement )  . close (  )  ;", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNoSuchStoredProcedure"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "final   String   MY _ PROC    =     \" my _ proc \"  ;", "sproc    =    new    ( dataSource )  . withProcedureName ( MY _ PROC )  ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "sproc . addDeclaredParameter ( new   SqlParameter (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnnamedParameterHandling"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   proceduresResultSet    =    databaseMetaData . getProcedures (  \"  \"  ,     \" ME \"  ,     \" ADD _ INVOICE \"  )  ;", "ResultSet   procedureColumnsResultSet    =    databaseMetaData . getProcedureColumns (  \"  \"  ,     \" ME \"  ,     \" ADD _ INVOICE \"  ,    null )  ;", "if    ( isFunction )     {", "verify ( callableStatement )  . registerOutPater (  1  ,     4  )  ;", "verify ( callableStatement )  . setObject (  2  ,     1  1  0  3  ,     4  )  ;", "verify ( callableStatement )  . setObject (  3  ,     3  ,     4  )  ;", "} else    {", "verify ( callableStatement )  . setObject (  1  ,     1  1  0  3  ,     4  )  ;", "verify ( callableStatement )  . setObject (  2  ,     3  ,     4  )  ;", "verify ( callableStatement )  . registerOutPater (  3  ,     4  )  ;", "}", "verify ( callableStatement )  . close (  )  ;", "verify ( proceduresResultSet )  . close (  )  ;", "verify ( procedureColumnsResultSet )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["verifyAddInvoiceWithMetaData"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "if    ( isFunction )     {", "verify ( callableStatement )  . registerOutPater (  1  ,     4  )  ;", "verify ( callableStatement )  . setObject (  2  ,     1  1  0  3  ,     4  )  ;", "verify ( callableStatement )  . setObject (  3  ,     3  ,     4  )  ;", "} else    {", "verify ( callableStatement )  . setObject (  1  ,     1  1  0  3  ,     4  )  ;", "verify ( callableStatement )  . setObject (  2  ,     3  ,     4  )  ;", "verify ( callableStatement )  . registerOutPater (  3  ,     4  )  ;", "}", "verify ( callableStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["verifyAddInvoiceWithoutMetaData"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals (  \" Incorrect   call   statement \"  ,    expected ,    adder . getCallString (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyStatement"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcCallTests"}, {"methodBody": ["METHOD_START", "{", "connection    =    mock ( Connection . class )  ;", "databaseMetaData    =    mock ( DatabaseMetaData . class )  ;", "dataSource    =    mock ( DataSource . class )  ;", "given ( connection . getMetaData (  )  )  . willReturn ( databaseMetaData )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcInsertTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   resultSet    =    mock ( ResultSet . class )  ;", "given ( resultSet . next (  )  )  . willReturn ( false )  ;", "given ( databaseMetaData . getDatabaseProductName (  )  )  . willReturn (  \" MyDB \"  )  ;", "given ( databaseMetaData . getDatabaseProductName (  )  )  . willReturn (  \" MyDB \"  )  ;", "given ( databaseMetaData . getDatabaseProductVersion (  )  )  . willReturn (  \"  1  .  0  \"  )  ;", "given ( databaseMetaData . getUserName (  )  )  . willReturn (  \" me \"  )  ;", "given ( databaseMetaData . storesLowerCaseIdentifiers (  )  )  . willReturn ( true )  ;", "given ( databaseMetaData . getTables ( null ,    null ,     \" x \"  ,    null )  )  . willReturn ( resultSet )  ;", "insert    =    new    ( dataSource )  . withTableName (  \" x \"  )  ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "try    {", "insert . execute ( new   HashMap <  >  (  )  )  ;", "}    finally    {", "verify ( resultSet )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNoSuchTable"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcInsertTests"}, {"methodBody": ["METHOD_START", "{", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["verifyClosed"], "fileName": "org.springframework.jdbc.core.simple.SimpleJdbcInsertTests"}, {"methodBody": ["METHOD_START", "{", "connection    =    mock ( Connection . class )  ;", "dataSource    =    mock ( DataSource . class )  ;", "databas    =    mock ( Databas . class )  ;", "given ( connection . getMetaData (  )  )  . willReturn ( databas )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.core.simple.TableMetaDataContextTests"}, {"methodBody": ["METHOD_START", "{", "final   String   TABLE    =     \" customers \"  ;", "final   String   USER    =     \" me \"  ;", "ResultSet   metaDataResultSet    =    mock ( ResultSet . class )  ;", "given ( metaDataResultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( metaDataResultSet . getString (  \" TABLE _ SCHEM \"  )  )  . willReturn ( USER )  ;", "given ( metaDataResultSet . getString (  \" TABLE _ NAME \"  )  )  . willReturn ( TABLE )  ;", "given ( metaDataResultSet . getString (  \" TABLE _ TYPE \"  )  )  . willReturn (  \" TABLE \"  )  ;", "ResultSet   columnsResultSet    =    mock ( ResultSet . class )  ;", "given ( columnsResultSet . next (  )  )  . willReturn ( true ,    true ,    true ,    true ,    false )  ;", "given ( columnsResultSet . getString (  \" COLUMN _ NAME \"  )  )  . willReturn (  \" id \"  ,     \" name \"  ,     \" customersince \"  ,     \" version \"  )  ;", "given ( columnsResultSet . getInt (  \" DATA _ TYPE \"  )  )  . willReturn ( Types . INTEGER ,    Types . VARCHAR ,    Types . DATE ,    Types . NUMERIC )  ;", "given ( columnsResultSet . getBoolean (  \" NULLABLE \"  )  )  . willReturn ( false ,    true ,    true ,    false )  ;", "given ( databas . getDatabaseProductName (  )  )  . willReturn (  \" MyDB \"  )  ;", "given ( databas . getDatabaseProductName (  )  )  . willReturn (  \"  1  .  0  \"  )  ;", "given ( databas . getUserName (  )  )  . willReturn ( USER )  ;", "given ( databas . storesLowerCaseIdentifiers (  )  )  . willReturn ( true )  ;", "given ( databas . getTables ( null ,    null ,    TABLE ,    null )  )  . willReturn ( metaDataResultSet )  ;", "given ( databas . getColumns ( null ,    USER ,    TABLE ,    null )  )  . willReturn ( columnsResultSet )  ;", "MapSqlParameterSource   map    =    new   MapSqlParameterSource (  )  ;", "map . addValue (  \" id \"  ,     1  )  ;", "map . addValue (  \" name \"  ,     \" Sven \"  )  ;", "map . addValue (  \" customersince \"  ,    new   Date (  )  )  ;", "map . addValue (  \" version \"  ,     0  )  ;", "map . registerSqlType (  \" customersince \"  ,    Types . DATE )  ;", "map . registerSqlType (  \" version \"  ,    Types . NUMERIC )  ;", "context . setTableName ( TABLE )  ;", "context . processMetaData ( dataSource ,    new   ArrayList <  >  (  )  ,    new   String [  ]  {        }  )  ;", "List < Object >    values    =    context . matchInParameterValuesWithInsertColumns ( map )  ;", "assertEquals (  \" wrong   number   of   parameters :     \"  ,     4  ,    values . size (  )  )  ;", "assertTrue (  \" id   not   wrapped   with   type   info \"  ,     (  ( values . get (  0  )  )    instanceof   Number )  )  ;", "assertTrue (  \" name   not   wrapped   with   type   info \"  ,     (  ( values . get (  1  )  )    instanceof   String )  )  ;", "assertTrue (  \" date   wrapped   with   type   info \"  ,     (  ( values . get (  2  )  )    instanceof   SqlParameterValue )  )  ;", "assertTrue (  \" version   wrapped   with   type   info \"  ,     (  ( values . get (  3  )  )    instanceof   SqlParameterValue )  )  ;", "verify ( metaDataResultSet ,    atLeastOnce (  )  )  . next (  )  ;", "verify ( columnsResultSet ,    atLeastOnce (  )  )  . next (  )  ;", "verify ( metaDataResultSet )  . close (  )  ;", "verify ( columnsResultSet )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testMatchInParametersAndSqlTypeInfoWrapping"], "fileName": "org.springframework.jdbc.core.simple.TableMetaDataContextTests"}, {"methodBody": ["METHOD_START", "{", "final   String   TABLE    =     \" customers \"  ;", "final   String   USER    =     \" me \"  ;", "ResultSet   metaDataResultSet    =    mock ( ResultSet . class )  ;", "given ( metaDataResultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( metaDataResultSet . getString (  \" TABLE _ SCHEM \"  )  )  . willReturn ( USER )  ;", "given ( metaDataResultSet . getString (  \" TABLE _ NAME \"  )  )  . willReturn ( TABLE )  ;", "given ( metaDataResultSet . getString (  \" TABLE _ TYPE \"  )  )  . willReturn (  \" TABLE \"  )  ;", "ResultSet   columnsResultSet    =    mock ( ResultSet . class )  ;", "given ( columnsResultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( columnsResultSet . getString (  \" COLUMN _ NAME \"  )  )  . willReturn (  \" id \"  )  ;", "given ( columnsResultSet . getInt (  \" DATA _ TYPE \"  )  )  . willReturn ( Types . INTEGER )  ;", "given ( columnsResultSet . getBoolean (  \" NULLABLE \"  )  )  . willReturn ( false )  ;", "given ( databas . getDatabaseProductName (  )  )  . willReturn (  \" MyDB \"  )  ;", "given ( databas . getDatabaseProductName (  )  )  . willReturn (  \"  1  .  0  \"  )  ;", "given ( databas . getUserName (  )  )  . willReturn ( USER )  ;", "given ( databas . storesLowerCaseIdentifiers (  )  )  . willReturn ( true )  ;", "given ( databas . getTables ( null ,    null ,    TABLE ,    null )  )  . willReturn ( metaDataResultSet )  ;", "given ( databas . getColumns ( null ,    USER ,    TABLE ,    null )  )  . willReturn ( columnsResultSet )  ;", "MapSqlParameterSource   map    =    new   MapSqlParameterSource (  )  ;", "String [  ]    keyCols    =    new   String [  ]  {     \" id \"     }  ;", "context . setTableName ( TABLE )  ;", "context . processMetaData ( dataSource ,    new   ArrayList <  >  (  )  ,    keyCols )  ;", "List < Object >    values    =    context . matchInParameterValuesWithInsertColumns ( map )  ;", "String   insertString    =    context . createInsertString ( keyCols )  ;", "assertEquals (  \" wrong   number   of   parameters :     \"  ,     0  ,    values . size (  )  )  ;", "assertEquals (  \" empty   insert   not   generated   correctly \"  ,     \" INSERT   INTO   customers    (  )    VALUES (  )  \"  ,    insertString )  ;", "verify ( metaDataResultSet ,    atLeastOnce (  )  )  . next (  )  ;", "verify ( columnsResultSet ,    atLeastOnce (  )  )  . next (  )  ;", "verify ( metaDataResultSet )  . close (  )  ;", "verify ( columnsResultSet )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTableWithSingleColumnGeneratedKey"], "fileName": "org.springframework.jdbc.core.simple.TableMetaDataContextTests"}, {"methodBody": ["METHOD_START", "{", "throw   new   IncorrectResultSizeDataAccessException (  \" LobStreamingResultSetExtractor   found   multiple   rows   in   database \"  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["handleMultipleRowsFound"], "fileName": "org.springframework.jdbc.core.support.AbstractLobStreamingResultSetExtractor"}, {"methodBody": ["METHOD_START", "{", "throw   new   EmptyResultDataAccessException (  \" LobStreamingResultSetExtractor   did   not   find   row   in   database \"  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["handleNoRowFound"], "fileName": "org.springframework.jdbc.core.support.AbstractLobStreamingResultSetExtractor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( this . jdbcTemplate ,     \" Not   fully   configured    -    specify   DataSource   or   JdbcTemplate \"  )  ;", "final   Properties   props    =    new   Properties (  )  ;", "this . jdbcTemplate . query ( sql ,     (    rs )     -  >     {", "String   beanName    =    rs . getString (  1  )  ;", "String   property    =    rs . getString (  2  )  ;", "String   value    =    rs . getString (  3  )  ;", "props . setProperty (  (  ( beanName    +     '  .  '  )     +    property )  ,    value )  ;", "}  )  ;", "this . propReader . registers ( props )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.jdbc.core.support.JdbcBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.jdbc.core.support.JdbcBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNullTemplate ,     \" JdbcTemplate   must   not   be   null \"  )  ;", "thisTemplate    = Template ;", "}", "METHOD_END"], "methodName": ["setJdbcTemplate"], "fileName": "org.springframework.jdbc.core.support.JdbcBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     \" SELECT   NAME   AS   NAME ,    PROPERTY   AS   PROPERTY ,    VALUE   AS   VALUE   FROM   T \"  ;", "Connection   connection    =    mock ( Connection . class )  ;", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "ResultSet   resultSet    =    mock ( ResultSet . class )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getString (  1  )  )  . willReturn (  \" one \"  ,     \" one \"  )  ;", "given ( resultSet . getString (  2  )  )  . willReturn (  \"  ( class )  \"  ,     \" age \"  )  ;", "given ( resultSet . getString (  3  )  )  . willReturn (  \" TestBean \"  ,     \"  5  3  \"  )  ;", "Statement   statement    =    mock ( Statement . class )  ;", "given ( statement . executeQuery ( sql )  )  . willReturn ( resultSet )  ;", "given ( connection . createStatement (  )  )  . willReturn ( statement )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "reader    =    new    ( bf )  ;", "reader . setDataSource ( dataSource )  ;", "reader . loadBeanDefinitions ( sql )  ;", "assertEquals (  \" Incorrect   number   of   bean   definitions \"  ,     1  ,    bf . getBeanDefinitionCount (  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( bf . getBean (  \" one \"  )  )  )  ;", "assertEquals (  \" Age   in   TestBean   was   wrong .  \"  ,     5  3  ,    tb . getAge (  )  )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( statement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testValid"], "fileName": "org.springframework.jdbc.core.support.JdbcBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "return   new   JdbcTemplate ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["createJdbcTemplate"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupport"}, {"methodBody": ["METHOD_START", "{", "DataSource   dataSource    =    getDataSource (  )  ;", "Assestate (  ( dataSource    !  =    null )  ,     \" No   DataSource   set \"  )  ;", "return   DataSourceUtils . getConnection ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupport"}, {"methodBody": ["METHOD_START", "{", "return    ( this . jdbcTemplate )     !  =    null    ?    this . jdbcTemplate . getDataSource (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDataSource"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupport"}, {"methodBody": ["METHOD_START", "{", "JdbcTemplate   jdbcTemplate    =    getJdbcTemplate (  )  ;", "Assert . state (  ( jdbcTemplate    !  =    null )  ,     \" No   JdbcTemplate   set \"  )  ;", "return   jdbcTemplate . getExceptionTranslator (  )  ;", "}", "METHOD_END"], "methodName": ["getExceptionTranslator"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . jdbcTemplate ;", "}", "METHOD_END"], "methodName": ["getJdbcTemplate"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupport"}, {"methodBody": ["METHOD_START", "{", "DataSourceUtils . releaseConnection ( con ,    getDataSource (  )  )  ;", "}", "METHOD_END"], "methodName": ["releaseConnection"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . jdbcTemplate )     =  =    null )     |  |     ( dataSource    !  =     ( this . jdbcTemplate . getDataSource (  )  )  )  )     {", "this . jdbcTemplate    =    createJdbcTemplate ( dataSource )  ;", "initTemplateConfig (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupport"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    jdbcTemplate ;", "initTemplateConfig (  )  ;", "}", "METHOD_END"], "methodName": ["setJdbcTemplate"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupport"}, {"methodBody": ["METHOD_START", "{", "DataSource   ds    =    mock ( DataSource . class )  ;", "final   List < String >    test    =    new   ArrayList <  >  (  )  ;", "dao    =    new    (  )     {", "@ Override", "protected   void   initDao (  )     {", "test . add (  \" test \"  )  ;", "}", "}  ;", "dao . setDataSource ( ds )  ;", "dao . afterPropertiesSet (  )  ;", "assertEquals (  \" Correct   DataSource \"  ,    ds ,    dao . getDataSource (  )  )  ;", "assertEquals (  \" Correct   JdbcTemplate \"  ,    ds ,    dao . getJdbcTemplate (  )  . getDataSource (  )  )  ;", "assertEquals (  \" initDao   called \"  ,     1  ,    test . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJdbcDaoSupportWithDataSource"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupportTests"}, {"methodBody": ["METHOD_START", "{", "JdbcTemplate   template    =    new   JdbcTemplate (  )  ;", "final   List < String >    test    =    new   ArrayList <  >  (  )  ;", "dao    =    new    (  )     {", "@ Override", "protected   void   initDao (  )     {", "test . add (  \" test \"  )  ;", "}", "}  ;", "dao . setJdbcTemplate ( template )  ;", "dao . afterPropertiesSet (  )  ;", "assertEquals (  \" Correct   JdbcTemplate \"  ,    dao . getJdbcTemplate (  )  ,    template )  ;", "assertEquals (  \" initDao   called \"  ,     1  ,    test . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJdbcDaoSupportWithJdbcTemplate"], "fileName": "org.springframework.jdbc.core.support.JdbcDaoSupportTests"}, {"methodBody": ["METHOD_START", "{", "AbstractLobStreamingResultSetExtractor < Void >    lobRse    =    new   AbstractLobStreamingResultSetExtractor < Void >  (  )     {", "@ Override", "protected   void   streamData ( ResultSet   rs )    throws   IOException ,    SQLException    {", "if    ( ex )     {", "throw   new   IOException (  )  ;", "} else    {", "rs . clearWarnings (  )  ;", "}", "}", "}  ;", "return   lobRse ;", "}", "METHOD_END"], "methodName": ["getResultSetExtractor"], "fileName": "org.springframework.jdbc.core.support.LobSupportTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   rset    =    mock ( ResultSet . class )  ;", "given ( rset . next (  )  )  . willReturn ( true )  ;", "AbstracttreamingResultSetExtractor < Void >    lobRse    =    getResultSetExtractor ( true )  ;", "thrown . expect ( LobRetrievalFailureException . class )  ;", "lobRse . extractData ( rset )  ;", "}", "METHOD_END"], "methodName": ["testAbstractLobStreamingResultSetExtractorCorrectException"], "fileName": "org.springframework.jdbc.core.support.LobSupportTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   rset    =    mock ( ResultSet . class )  ;", "given ( rset . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "AbstracttreamingResultSetExtractor < Void >    lobRse    =    getResultSetExtractor ( false )  ;", "thrown . expect ( IncorrectResultSizeDataAccessException . class )  ;", "try    {", "lobRse . extractData ( rset )  ;", "}    finally    {", "verify ( rset )  . clearWarnings (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAbstractLobStreamingResultSetExtractorMultipleRows"], "fileName": "org.springframework.jdbc.core.support.LobSupportTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   rset    =    mock ( ResultSet . class )  ;", "AbstracttreamingResultSetExtractor < Void >    lobRse    =    getResultSetExtractor ( false )  ;", "thrown . expect ( IncorrectResultSizeDataAccessException . class )  ;", "try    {", "lobRse . extractData ( rset )  ;", "}    finally    {", "verify ( rset )  . next (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAbstractLobStreamingResultSetExtractorNoRows"], "fileName": "org.springframework.jdbc.core.support.LobSupportTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   rset    =    mock ( ResultSet . class )  ;", "given ( rset . next (  )  )  . willReturn ( true ,    false )  ;", "AbstracttreamingResultSetExtractor < Void >    lobRse    =    getResultSetExtractor ( false )  ;", "lobRse . extractData ( rset )  ;", "verify ( rset )  . clearWarnings (  )  ;", "}", "METHOD_END"], "methodName": ["testAbstractLobStreamingResultSetExtractorOneRow"], "fileName": "org.springframework.jdbc.core.support.LobSupportTests"}, {"methodBody": ["METHOD_START", "{", "LobHandler   handler    =    mock ( LobHandler . class )  ;", "LobCreator   creator    =    mock ( LobCreator . class )  ;", "PreparedStatement   ps    =    mock ( PreparedStatement . class )  ;", "given ( handler . getLobCreator (  )  )  . willReturn ( creator )  ;", "given ( ps . executeUpdate (  )  )  . willReturn (  3  )  ;", "class   SetValuesCalled    {", "boolean   b    =    false ;", "}", "final   SetValuesCalled   svc    =    new   SetValuesCalled (  )  ;", "AbstractLobCreatingPreparedStatementCallback   psc    =    new   AbstractLobCreatingPreparedStatementCallback ( handler )     {", "@ Override", "protected   void   setValues ( PreparedStatement   ps ,    LobCreator   lobCreator )    throws   SQLException ,    DataAccessException    {", "svc . b    =    true ;", "}", "}  ;", "assertEquals ( Integer . valueOf (  3  )  ,    psc . doInPreparedStatement ( ps )  )  ;", "assertTrue ( svc . b )  ;", "verify ( creator )  . close (  )  ;", "verify ( handler )  . getLobCreator (  )  ;", "verify ( ps )  . executeUpdate (  )  ;", "}", "METHOD_END"], "methodName": ["testCreatingPreparedStatementCallback"], "fileName": "org.springframework.jdbc.core.support.LobSupportTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "preparedStatement    =    mock ( PreparedStatement . class )  ;", "handler    =    mock ( Handler . class )  ;", "creator    =    mock ( Creator . class )  ;", "given ( handler . getCreator (  )  )  . willReturn ( creator )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    testBytes    =     \" Bla \"  . getBytes (  )  ;", "lob    =    new    ( testBytes ,    handler )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . BLOB ,     \" test \"  )  ;", "verify ( creator )  . setBlobAsBytes ( preparedStatement ,     1  ,    testBytes )  ;", "}", "METHOD_END"], "methodName": ["test1"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "String   testString    =     \" Bla \"  ;", "lob    =    new    ( testString ,    handler )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . BLOB ,     \" test \"  )  ;", "verify ( creator )  . setBlobAsBytes ( preparedStatement ,     1  ,    testString . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["test2"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "SqlLobValue   lob    =    new   SqlLobValue ( new   InputStreamReader ( new   ByteArrayInputStream (  \" Bla \"  . getBytes (  )  )  )  ,     1  2  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . BLOB ,     \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["test3"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "String   testContent    =     \" Bla \"  ;", "lob    =    new    ( testContent ,    handler )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . CLOB ,     \" test \"  )  ;", "verify ( creator )  . setClobAsString ( preparedStatement ,     1  ,    testContent )  ;", "}", "METHOD_END"], "methodName": ["test4"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    testContent    =     \" Bla \"  . getBytes (  )  ;", "lob    =    new    ( new   ByteArrayInputStream ( testContent )  ,     3  ,    handler )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . CLOB ,     \" test \"  )  ;", "verify ( creator )  . setClobAsAsciiStream ( eq ( preparedStatement )  ,    eq (  1  )  ,    inputStreamCaptor . capture (  )  ,    eq (  3  )  )  ;", "byte [  ]    bytes    =    new   byte [  3  ]  ;", "inputStreamCaptor . getValue (  )  . read ( bytes )  ;", "assertThat ( bytes ,    equalTo ( testContent )  )  ;", "}", "METHOD_END"], "methodName": ["test5"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    testContent    =     \" Bla \"  . getBytes (  )  ;", "ByteArrayInputStream   bais    =    new   ByteArrayInputStream ( testContent )  ;", "InputStreamReader   reader    =    new   InputStreamReader ( bais )  ;", "lob    =    new    ( reader ,     3  ,    handler )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . CLOB ,     \" test \"  )  ;", "verify ( creator )  . setClobAsCharacterStream ( eq ( preparedStatement )  ,    eq (  1  )  ,    eq ( reader )  ,    eq (  3  )  )  ;", "}", "METHOD_END"], "methodName": ["test6"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "SqlLobValue   lob    =    new   SqlLobValue (  \" bla \"  . getBytes (  )  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . CLOB ,     \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["test7"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "SqlLobValue   lob    =    new   SqlLobValue (  \" Bla \"  ,    handler )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . CLOB ,     \" test \"  )  ;", "lob . cleanup (  )  ;", "verify ( creator )  . setClobAsString ( preparedStatement ,     1  ,     \" Bla \"  )  ;", "verify ( creator )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testCorrectCleanup"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "SqlLobValue   lob    =    new   SqlLobValue (  \" bla \"  )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . CLOB ,     \" test \"  )  ;", "try    {", "lob    =    new   SqlLobValue (  \" bla \"  . getBytes (  )  )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . CLOB ,     \" test \"  )  ;", "fail (  \" IllegalArgumentException   should   have   been   thrown \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "}", "lob    =    new   SqlLobValue ( new   ByteArrayInputStream (  \" bla \"  . getBytes (  )  )  ,     3  )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . CLOB ,     \" test \"  )  ;", "lob    =    new   SqlLobValue ( new   InputStreamReader ( new   ByteArrayInputStream (  \" bla \"  . getBytes (  )  )  )  ,     3  )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . CLOB ,     \" test \"  )  ;", "lob    =    new   SqlLobValue (  \" bla \"  )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . BLOB ,     \" test \"  )  ;", "lob    =    new   SqlLobValue (  \" bla \"  . getBytes (  )  )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . BLOB ,     \" test \"  )  ;", "lob    =    new   SqlLobValue ( new   ByteArrayInputStream (  \" bla \"  . getBytes (  )  )  ,     3  )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . BLOB ,     \" test \"  )  ;", "lob    =    new   SqlLobValue ( new   InputStreamReader ( new   ByteArrayInputStream (  \" bla \"  . getBytes (  )  )  )  ,     3  )  ;", "try    {", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . BLOB ,     \" test \"  )  ;", "fail (  \" IllegalArgumentException   should   have   been   thrown \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "}", "}", "METHOD_END"], "methodName": ["testOtherConstructors"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "SqlLobValue   lob    =    new   SqlLobValue (  \" Bla \"  ,    handler )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "lob . setTypeValue ( preparedStatement ,     1  ,    Types . SMALLINT ,     \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["testOtherSqlType"], "fileName": "org.springframework.jdbc.core.support.SqlLobValueTests"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.jdbc.core.test.AbstractPerson"}, {"methodBody": ["METHOD_START", "{", "return   birth _ date ;", "}", "METHOD_END"], "methodName": ["getBirth_date"], "fileName": "org.springframework.jdbc.core.test.AbstractPerson"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.jdbc.core.test.AbstractPerson"}, {"methodBody": ["METHOD_START", "{", "this . age    =    age ;", "}", "METHOD_END"], "methodName": ["setAge"], "fileName": "org.springframework.jdbc.core.test.AbstractPerson"}, {"methodBody": ["METHOD_START", "{", "this . birth _ date    =    birth _ date ;", "}", "METHOD_END"], "methodName": ["setBirth_date"], "fileName": "org.springframework.jdbc.core.test.AbstractPerson"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.jdbc.core.test.AbstractPerson"}, {"methodBody": ["METHOD_START", "{", "return   balance ;", "}", "METHOD_END"], "methodName": ["getBalance"], "fileName": "org.springframework.jdbc.core.test.ConcretePerson"}, {"methodBody": ["METHOD_START", "{", "this . balance    =    balance ;", "}", "METHOD_END"], "methodName": ["setBalance"], "fileName": "org.springframework.jdbc.core.test.ConcretePerson"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.jdbc.core.test.DatePerson"}, {"methodBody": ["METHOD_START", "{", "return   balance ;", "}", "METHOD_END"], "methodName": ["getBalance"], "fileName": "org.springframework.jdbc.core.test.DatePerson"}, {"methodBody": ["METHOD_START", "{", "return   birthDate ;", "}", "METHOD_END"], "methodName": ["getBirthDate"], "fileName": "org.springframework.jdbc.core.test.DatePerson"}, {"methodBody": ["METHOD_START", "{", "return   lastName ;", "}", "METHOD_END"], "methodName": ["getLastName"], "fileName": "org.springframework.jdbc.core.test.DatePerson"}, {"methodBody": ["METHOD_START", "{", "this . age    =    age ;", "}", "METHOD_END"], "methodName": ["setAge"], "fileName": "org.springframework.jdbc.core.test.DatePerson"}, {"methodBody": ["METHOD_START", "{", "this . balance    =    balanace ;", "}", "METHOD_END"], "methodName": ["setBalance"], "fileName": "org.springframework.jdbc.core.test.DatePerson"}, {"methodBody": ["METHOD_START", "{", "this . birthDate    =    birthDate ;", "}", "METHOD_END"], "methodName": ["setBirthDate"], "fileName": "org.springframework.jdbc.core.test.DatePerson"}, {"methodBody": ["METHOD_START", "{", "this . lastName    =    lastName ;", "}", "METHOD_END"], "methodName": ["setLastName"], "fileName": "org.springframework.jdbc.core.test.DatePerson"}, {"methodBody": ["METHOD_START", "{", "return   someField ;", "}", "METHOD_END"], "methodName": ["getSomeField"], "fileName": "org.springframework.jdbc.core.test.ExtendedPerson"}, {"methodBody": ["METHOD_START", "{", "this . someField    =    someField ;", "}", "METHOD_END"], "methodName": ["setSomeField"], "fileName": "org.springframework.jdbc.core.test.ExtendedPerson"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.jdbc.core.test.Person"}, {"methodBody": ["METHOD_START", "{", "return   balance ;", "}", "METHOD_END"], "methodName": ["getBalance"], "fileName": "org.springframework.jdbc.core.test.Person"}, {"methodBody": ["METHOD_START", "{", "return   birth _ date ;", "}", "METHOD_END"], "methodName": ["getBirth_date"], "fileName": "org.springframework.jdbc.core.test.Person"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.jdbc.core.test.Person"}, {"methodBody": ["METHOD_START", "{", "this . age    =    age ;", "}", "METHOD_END"], "methodName": ["setAge"], "fileName": "org.springframework.jdbc.core.test.Person"}, {"methodBody": ["METHOD_START", "{", "this . balance    =    balanace ;", "}", "METHOD_END"], "methodName": ["setBalance"], "fileName": "org.springframework.jdbc.core.test.Person"}, {"methodBody": ["METHOD_START", "{", "this . birth _ date    =    birth _ date ;", "}", "METHOD_END"], "methodName": ["setBirth_date"], "fileName": "org.springframework.jdbc.core.test.Person"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.jdbc.core.test.Person"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.jdbc.core.test.SpacePerson"}, {"methodBody": ["METHOD_START", "{", "return   balance ;", "}", "METHOD_END"], "methodName": ["getBalance"], "fileName": "org.springframework.jdbc.core.test.SpacePerson"}, {"methodBody": ["METHOD_START", "{", "return   birthDate ;", "}", "METHOD_END"], "methodName": ["getBirthDate"], "fileName": "org.springframework.jdbc.core.test.SpacePerson"}, {"methodBody": ["METHOD_START", "{", "return   lastName ;", "}", "METHOD_END"], "methodName": ["getLastName"], "fileName": "org.springframework.jdbc.core.test.SpacePerson"}, {"methodBody": ["METHOD_START", "{", "this . age    =    age ;", "}", "METHOD_END"], "methodName": ["setAge"], "fileName": "org.springframework.jdbc.core.test.SpacePerson"}, {"methodBody": ["METHOD_START", "{", "this . balance    =    balanace ;", "}", "METHOD_END"], "methodName": ["setBalance"], "fileName": "org.springframework.jdbc.core.test.SpacePerson"}, {"methodBody": ["METHOD_START", "{", "this . birthDate    =    birthDate ;", "}", "METHOD_END"], "methodName": ["setBirthDate"], "fileName": "org.springframework.jdbc.core.test.SpacePerson"}, {"methodBody": ["METHOD_START", "{", "this . lastName    =    lastName ;", "}", "METHOD_END"], "methodName": ["setLastName"], "fileName": "org.springframework.jdbc.core.test.SpacePerson"}, {"methodBody": ["METHOD_START", "{", "return   this . catalog ;", "}", "METHOD_END"], "methodName": ["getCatalog"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "Properties   mergedProps    =    new   Properties (  )  ;", "Properties   connProps    =    getConnectionProperties (  )  ;", "if    ( connProps    !  =    null )     {", "mergedProps . putAll ( connProps )  ;", "}", "if    ( username    !  =    null )     {", "mergedProps . setProperty (  \" user \"  ,    username )  ;", "}", "if    ( password    !  =    null )     {", "mergedProps . setProperty (  \" password \"  ,    password )  ;", "}", "Connection   con    =    getConnectionFrom ( mergedProps )  ;", "if    (  ( this . catalog )     !  =    null )     {", "con . setCatalog ( this . catalog )  ;", "}", "if    (  ( this . schema )     !  =    null )     {", "con . setSchema ( this . schema )  ;", "}", "return   con ;", "}", "METHOD_END"], "methodName": ["getConnectionFromDriver"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "return   this . connectionProperties ;", "}", "METHOD_END"], "methodName": ["getConnectionProperties"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "return   this . password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "return   this . schema ;", "}", "METHOD_END"], "methodName": ["getSchema"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "return   this . url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "return   this . username ;", "}", "METHOD_END"], "methodName": ["getUsername"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "this . catalog    =    catalog ;", "}", "METHOD_END"], "methodName": ["setCatalog"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "this . connectionProperties    =    connectionProperties ;", "}", "METHOD_END"], "methodName": ["setConnectionProperties"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "this . password    =    password ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "this . schema    =    schema ;", "}", "METHOD_END"], "methodName": ["setSchema"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "this . url    =     ( url    !  =    null )     ?    url . trim (  )     :    null ;", "}", "METHOD_END"], "methodName": ["setUrl"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "this . username    =    username ;", "}", "METHOD_END"], "methodName": ["setUsername"], "fileName": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource"}, {"methodBody": ["METHOD_START", "{", "( this . savepointCounter )  +  +  ;", "return   getConnection (  )  . setSavepoint (  (  (  . SAVEPOINT _ NAME _ PREFIX )     +     ( this . savepointCounter )  )  )  ;", "}", "METHOD_END"], "methodName": ["createSavepoint"], "fileName": "org.springframework.jdbc.datasource.ConnectionHolder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( this . connectionHandle ,     \" Active   Connection   is   required \"  )  ;", "if    (  ( this . currentConnection )     =  =    null )     {", "this . currentConnection    =    this . connectionHandle . getConnection (  )  ;", "}", "return   this . currentConnection ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jdbc.datasource.ConnectionHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . connectionHandle ;", "}", "METHOD_END"], "methodName": ["getConnectionHandle"], "fileName": "org.springframework.jdbc.datasource.ConnectionHolder"}, {"methodBody": ["METHOD_START", "{", "return    ( this . connectionHandle )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasConnection"], "fileName": "org.springframework.jdbc.datasource.ConnectionHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . transactionActive ;", "}", "METHOD_END"], "methodName": ["isTransactionActive"], "fileName": "org.springframework.jdbc.datasource.ConnectionHolder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . currentConnection )     !  =    null )     {", "if    (  ( this . connectionHandle )     !  =    null )     {", "this . connectionHandle . releaseConnection ( this . currentConnection )  ;", "}", "this . currentConnection    =    null ;", "}", "if    ( connection    !  =    null )     {", "this . connectionHandle    =    new   Simpleandle ( connection )  ;", "} else    {", "this . connectionHandle    =    null ;", "}", "}", "METHOD_END"], "methodName": ["setConnection"], "fileName": "org.springframework.jdbc.datasource.ConnectionHolder"}, {"methodBody": ["METHOD_START", "{", "this . transactionActive    =    transactionActive ;", "}", "METHOD_END"], "methodName": ["setTransactionActive"], "fileName": "org.springframework.jdbc.datasource.ConnectionHolder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . savepointsSupported )     =  =    null )     {", "this . savepointsSupported    =    get (  )  . getMetaData (  )  . supportsSavepoints (  )  ;", "}", "return   this . savepointsSupported ;", "}", "METHOD_END"], "methodName": ["supportsSavepoints"], "fileName": "org.springframework.jdbc.datasource.ConnectionHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( rollback )     {", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE )  ;", "} else    {", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "}", "Manager   ptm    =    new   Manager ( userTransaction )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dataSource )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dataSource )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "Connection   c    =    DataSourceUtils . getConnection ( dataSource )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dataSource )  )  ;", "DataSourceUtils . releaseConnection ( c ,    dataSource )  ;", "c    =    DataSourceUtils . getConnection ( dataSource )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dataSource )  )  ;", "DataSourceUtils . releaseConnection ( c ,    dataSource )  ;", "if    ( rollback )     {", "status . setRollbackOnly (  )  ;", "}", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dataSource )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "verify ( userTransaction )  . begin (  )  ;", "if    ( rollback )     {", "verify ( userTransaction )  . rollback (  )  ;", "}", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestJtaTransaction"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "if    ( notSupported )     {", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE ,    STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "given ( transactionManager . suspend (  )  )  . willReturn ( transaction )  ;", "} else    {", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "}", "final   DataSource   dataSource    =    mock ( DataSource . class )  ;", "final   Connection   connection 1     =    mock ( Connection . class )  ;", "final   Connection   connection 2     =    mock ( Connection . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection 1  ,    connection 2  )  ;", "final   Manager   ptm    =    new   Manager ( userTransaction ,    transactionManager )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior (  ( notSupported    ?    TransactionDefinition . PROPAGATION _ NOT _ SUPPORTED    :    TransactionDefinition . PROPAGATION _ SUPPORTS )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertSame ( connection 1  ,    DataSourceUtils . getConnection ( dataSource )  )  ;", "assertSame ( connection 1  ,    DataSourceUtils . getConnection ( dataSource )  )  ;", "TransactionTemplate   tt 2     =    new   TransactionTemplate ( ptm )  ;", "tt 2  . setPropagationBehavior (  ( requiresNew    ?    TransactionDefinition . PROPAGATION _ REQUIRES _ NEW    :    TransactionDefinition . PROPAGATION _ REQUIRED )  )  ;", "tt 2  . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertSame ( connection 2  ,    DataSourceUtils . getConnection ( dataSource )  )  ;", "assertSame ( connection 2  ,    DataSourceUtils . getConnection ( dataSource )  )  ;", "}", "}  )  ;", "assertTrue ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "assertSame ( connection 1  ,    DataSourceUtils . getConnection ( dataSource )  )  ;", "}", "}  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "verify ( userTransaction )  . begin (  )  ;", "verify ( userTransaction )  . commit (  )  ;", "if    ( notSupported )     {", "verify ( transactionManager )  . resume ( transaction )  ;", "}", "verify ( connection 2  )  . close (  )  ;", "verify ( connection 1  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestJtaTransactionCommitWithNewTransactionWithinEmptyTransaction"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE ,    STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "final   DataSource   dataSource 1     =    mock ( DataSource . class )  ;", "final   Connection   connection 1     =    mock ( Connection . class )  ;", "given ( dataSource 1  . getConnection (  )  )  . willReturn ( connection 1  )  ;", "final   DataSource   dataSource 2     =    mock ( DataSource . class )  ;", "final   Connection   connection 2     =    mock ( Connection . class )  ;", "given ( dataSource 2  . getConnection (  )  )  . willReturn ( connection 2  )  ;", "final   IsolationLevelDataSourceRouter   dsToUse    =    new   IsolationLevelDataSourceRouter (  )  ;", "Map < Object ,    Object >    targetDataSources    =    new   HashMap <  >  (  )  ;", "if    ( dataSourceLookup )     {", "targetDataSources . put (  \" ISOLATION _ REPEATABLE _ READ \"  ,     \" ds 2  \"  )  ;", "dsToUse . setDefaultTargetDataSource (  \" ds 1  \"  )  ;", "StaticListableBeanFactory   beanFactory    =    new   StaticListableBeanFactory (  )  ;", "beanFactory . addBean (  \" ds 1  \"  ,    dataSource 1  )  ;", "beanFactory . addBean (  \" ds 2  \"  ,    dataSource 2  )  ;", "dsToUse . setDataSourceLookup ( new   BeanFactoryDataSourceLookup ( beanFactory )  )  ;", "} else    {", "targetDataSources . put (  \" ISOLATION _ REPEATABLE _ READ \"  ,    dataSource 2  )  ;", "dsToUse . setDefaultTargetDataSource ( dataSource 1  )  ;", "}", "dsToUse . setTargetDataSources ( targetDataSources )  ;", "dsToUse . afterPropertiesSet (  )  ;", "Manager   ptm    =    new   Manager ( userTransaction )  ;", "ptm . setAllowCustomIsolationLevels ( true )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "Connection   c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "assertSame ( connection 1  ,    c )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}", "}  )  ;", "tt . setIsolationLevel ( ISOLATION _ REPEATABLE _ READ )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "Connection   c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "assertSame ( connection 2  ,    c )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}", "}  )  ;", "verify ( userTransaction ,    times (  2  )  )  . begin (  )  ;", "verify ( userTransaction ,    times (  2  )  )  . commit (  )  ;", "verify ( connection 1  )  . close (  )  ;", "verify ( connection 2  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestJtaTransactionWithIsolationLevelDataSourceRouter"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "given ( transactionManager . suspend (  )  )  . willReturn ( transaction )  ;", "if    ( rollback )     {", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE )  ;", "} else    {", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "}", "given ( connection . isReadOnly (  )  )  . willReturn ( true )  ;", "final   DataSource   dsToUse    =     ( useTransactionAwareDataSource )     ?    new   TransactionAwareDataSourceProxy ( dataSource )     :    dataSource ;", "Manager   ptm    =    new   Manager ( userTransaction ,    transactionManager )  ;", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "Connection   c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "try    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "c . isReadOnly (  )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "if    (  ! openOuterConnection )     {", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}", "}    catch    ( SQLException   ex )     {", "}", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )     {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "try    {", "Connection   c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "c . isReadOnly (  )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}    catch    ( SQLException   ex )     {", "}", "}", "}  )  ;", "}", "if    ( rollback )     {", "status . setRollbackOnly (  )  ;", "}", "if    ( accessAfterResume )     {", "try    {", "if    (  ! openOuterConnection )     {", "c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "}", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "c . isReadOnly (  )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}    catch    ( SQLException   ex )     {", "}", "} else    {", "if    ( openOuterConnection )     {", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}", "}", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "verify ( userTransaction ,    times (  6  )  )  . begin (  )  ;", "verify ( transactionManager ,    times (  5  )  )  . resume ( transaction )  ;", "if    ( rollback )     {", "verify ( userTransaction ,    times (  5  )  )  . commit (  )  ;", "verify ( userTransaction )  . rollback (  )  ;", "} else    {", "verify ( userTransaction ,    times (  6  )  )  . commit (  )  ;", "}", "if    ( accessAfterResume    &  &     (  ! openOuterConnection )  )     {", "verify ( connection ,    times (  7  )  )  . close (  )  ;", "} else    {", "verify ( connection ,    times (  6  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestJtaTransactionWithPropagationRequiresNew"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "if    ( suspendException )     {", "given ( transactionManager . suspend (  )  )  . willThrow ( new   SystemException (  )  )  ;", "} else    {", "given ( transactionManager . suspend (  )  )  . willReturn ( transaction )  ;", "willThrow ( new   SystemException (  )  )  . given ( userTransaction )  . begin (  )  ;", "}", "given ( connection . isReadOnly (  )  )  . willReturn ( true )  ;", "final   DataSource   dsToUse    =     ( useTransactionAwareDataSource )     ?    new   TransactionAwareDataSourceProxy ( dataSource )     :    dataSource ;", "if    ( dsToUse   instanceof   TransactionAwareDataSourceProxy )     {", "(  ( TransactionAwareDataSourceProxy )     ( dsToUse )  )  . setReobtainTransactionalConnections ( true )  ;", "}", "Manager   ptm    =    new   Manager ( userTransaction ,    transactionManager )  ;", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "Connection   c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "try    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "c . isReadOnly (  )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "if    (  ! openOuterConnection )     {", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}", "}    catch    ( SQLException   ex )     {", "}", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "Connection   c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}", "}  )  ;", "}    finally    {", "if    ( openOuterConnection )     {", "try    {", "c . isReadOnly (  )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}    catch    ( SQLException   ex )     {", "}", "}", "}", "}", "}  )  ;", "fail (  \" Should   have   thrown   TransactionException \"  )  ;", "}    catch    ( TransactionException   ex )     {", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "verify ( userTransaction )  . begin (  )  ;", "if    ( suspendException )     {", "verify ( userTransaction )  . rollback (  )  ;", "}", "if    ( suspendException )     {", "verify ( connection ,    atLeastOnce (  )  )  . close (  )  ;", "} else    {", "verify ( connection ,    never (  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestJtaTransactionWithPropagationRequiresNewAndBeginException"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "connection    =    mock ( Connection . class )  ;", "dataSource    =    mock ( DataSource . class )  ;", "user    =    mock ( User . class )  ;", "transactionManager    =    mock ( Manager . class )  ;", "transaction    =    mock (  . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransaction ( false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommit"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionCommitWithNewTransactionWithinEmptyTransaction ( false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiredWithinNotSupported"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionCommitWithNewTransactionWithinEmptyTransaction ( false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiredWithinSupports"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( false ,    false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNew"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNewAndBeginException ( false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewAndBeginException"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNewAndBeginException ( true ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewAndSuspendException"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( false ,    false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithAccessAfterResume"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( false ,    true ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithOpenOuterConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( false ,    true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithOpenOuterConnectionAccessed"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNewAndBeginException ( false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithOpenOuterConnectionAndBeginException"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNewAndBeginException ( true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithOpenOuterConnectionAndSuspendException"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNewAndBeginException ( false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithOpenOuterConnectionAndTransactionAwareDataSourceAndBeginException"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNewAndBeginException ( true ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithOpenOuterConnectionAndTransactionAwareDataSourceAndSuspendException"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( false ,    false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithTransactionAwareDataSource"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNewAndBeginException ( false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithTransactionAwareDataSourceAndBeginException"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNewAndBeginException ( true ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithTransactionAwareDataSourceAndSuspendException"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionCommitWithNewTransactionWithinEmptyTransaction ( true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithinNotSupported"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionCommitWithNewTransactionWithinEmptyTransaction ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionCommitWithPropagationRequiresNewWithinSupports"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransaction ( true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionRollback"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( true ,    false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionRollbackWithPropagationRequiresNew"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( true ,    false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionRollbackWithPropagationRequiresNewWithAccessAfterResume"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( true ,    true ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionRollbackWithPropagationRequiresNewWithOpenOuterConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( true ,    true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionRollbackWithPropagationRequiresNewWithOpenOuterConnectionAccessed"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithPropagationRequiresNew ( true ,    false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionRollbackWithPropagationRequiresNewWithTransactionAwareDataSource"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" serial \"  )", "Manager   ptm    =    new   Manager ( userTransaction )     {", "@ Override", "protected   void   doRegisterAfterCompletionWith ( Object   txObject ,    final   List < TransactionSynchronization >    synchronizations )    throws   RollbackException ,    SystemException    {", "Thread   async    =    new   Thread (  )     {", "@ Override", "public   void   run (  )     {", "invokeAfterCompletion ( synchronizations ,    STATUS _ COMMITTED )  ;", "}", "}  ;", "async . start (  )  ;", "try    {", "async . join (  )  ;", "}    catch    ( InterruptedException   ex )     {", "ex . printStackTrace (  )  ;", "}", "}", "}  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dataSource )  )  )  )  ;", "assertTrue (  \" JTA   synchronizations   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ ACTIVE )  ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "final   boolean   releaseCon    =    i    !  =     1  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" JTA   synchronizations   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   existing   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "Connection   c    =    DataSourceUtils . getConnection ( dataSource )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dataSource )  )  ;", "DataSourceUtils . releaseConnection ( c ,    dataSource )  ;", "c    =    DataSourceUtils . getConnection ( dataSource )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dataSource )  )  ;", "if    ( releaseCon )     {", "DataSourceUtils . releaseConnection ( c ,    dataSource )  ;", "}", "}", "}  )  ;", "if    (  ! releaseCon )     {", "assertTrue (  \" Still   has   connection   holder \"  ,    TransactionSynchronizationManager . hasResource ( dataSource )  )  ;", "} else    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dataSource )  )  )  )  ;", "}", "assertTrue (  \" JTA   synchronizations   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "}", "verify ( connection ,    times (  3  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionWithConnectionHolderStillBound"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "given ( userTransaction . getStatus (  )  )  . willReturn ( STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE ,    STATUS _ NO _ TRANSACTION ,    STATUS _ ACTIVE ,    STATUS _ ACTIVE )  ;", "final   IsolationLevelDataSourceAdapter   dsToUse    =    new   IsolationLevelDataSourceAdapter (  )  ;", "dsToUse . setTargetDataSource ( dataSource )  ;", "dsToUse . afterPropertiesSet (  )  ;", "Manager   ptm    =    new   Manager ( userTransaction )  ;", "ptm . setAllowCustomIsolationLevels ( true )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( ptm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "Connection   c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "assertSame ( connection ,    c )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}", "}  )  ;", "tt . setIsolationLevel ( ISOLATION _ REPEATABLE _ READ )  ;", "tt . setReadOnly ( true )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "Connection   c    =    DataSourceUtils . getConnection ( dsToUse )  ;", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "assertSame ( connection ,    c )  ;", "DataSourceUtils . releaseConnection ( c ,    dsToUse )  ;", "}", "}  )  ;", "verify ( userTransaction ,    times (  2  )  )  . begin (  )  ;", "verify ( userTransaction ,    times (  2  )  )  . commit (  )  ;", "verify ( connection )  . setReadOnly ( true )  ;", "verify ( connection )  . setTransactionIsolation ( Connection . TRANSACTION _ REPEATABLE _ READ )  ;", "verify ( connection ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionWithIsolationLevelDataSourceAdapter"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithIsolationLevelDataSourceRouter ( false )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionWithIsolationLevelDataSourceRouter"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "doTestJtaTransactionWithIsolationLevelDataSourceRouter ( true )  ;", "}", "METHOD_END"], "methodName": ["testJtaTransactionWithIsolationLevelDataSourceRouterWithDataSourceLookup"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TransactionSynchronizationManager . getResourceMap (  )  . isEmpty (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertNull ( TransactionSynchronizationManager . getCurrentTransactionName (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertNull ( TransactionSynchronizationManager . getCurrentTransactionIsolationLevel (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyTransactionSynchronizationManagerState"], "fileName": "org.springframework.jdbc.datasource.DataSourceJtaTransactionTests"}, {"methodBody": ["METHOD_START", "{", "return   this . dataSource ;", "}", "METHOD_END"], "methodName": ["getDataSource"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManager"}, {"methodBody": ["METHOD_START", "{", "return   this . enforceReadOnly ;", "}", "METHOD_END"], "methodName": ["isEnforceReadOnly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManager"}, {"methodBody": ["METHOD_START", "{", "DataSource   dataSource    =    getDataSource (  )  ;", "Assert . state (  ( dataSource    !  =    null )  ,     \" No   DataSource   set \"  )  ;", "return   dataSource ;", "}", "METHOD_END"], "methodName": ["obtainDataSource"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( isEnforceReadOnly (  )  )     &  &     ( definition . isReadOnly (  )  )  )     {", "Statement   stmt    =    con . createStatement (  )  ;", "try    {", "stmt . executeUpdate (  \" SET   TRANSACTION   READ   ONLY \"  )  ;", "}    finally    {", "stmt . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["prepareTransactionalConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManager"}, {"methodBody": ["METHOD_START", "{", "if    ( dataSource   instanceof   TransactionAwareDataSourceProxy )     {", "this . dataSource    =     (  ( TransactionAwareDataSourceProxy )     ( dataSource )  )  . getTargetDataSource (  )  ;", "} else    {", "this . dataSource    =    dataSource ;", "}", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManager"}, {"methodBody": ["METHOD_START", "{", "this . enforceReadOnly    =    enforceReadOnly ;", "}", "METHOD_END"], "methodName": ["setEnforceReadOnly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManager"}, {"methodBody": ["METHOD_START", "{", "DatabaseMetaData   md    =    mock ( DatabaseMetaData . class )  ;", "Savepoint   sp    =    mock ( Savepoint . class )  ;", "given ( md . supportsSavepoints (  )  )  . willReturn ( true )  ;", "given ( con . getMetaData (  )  )  . willReturn ( md )  ;", "for    ( int   i    =     1  ;    i    <  =    count ;    i +  +  )     {", "given ( con . setSavepoint (  (  ( ConnectionHolder . SAVEPOINT _ NAME _ PREFIX )     +    i )  )  )  . willReturn ( sp )  ;", "}", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NESTED )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( SynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "assertTrue (  \" Isn ' t   nested   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    SynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    SynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Isn ' t   new   transaction \"  ,     (  !  ( status . isNew (  )  )  )  )  ;", "assertTrue (  \" Is   nested   transaction \"  ,    status . hasSavepoint (  )  )  ;", "}", "}  )  ;", "}", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "assertTrue (  \" Isn ' t   nested   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con ,    times ( count )  )  . releaseSavepoint ( sp )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestExistingTransactionWithPropagationNested"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "given ( con . isReadOnly (  )  )  . willReturn ( false )  ;", "if    ( failEarly )     {", "tm . setFailEarlyOnGlobalRollbackOnly ( true )  ;", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", ". TestTransactionSynchronization   synch    =    new    . TestTransactionSynchronization ( ds ,    TransactionSynchronization . STATUS _ ROLLED _ BACK )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "boolean   outerTransactionBoundaryReached    =    false ;", "try    {", "assertTrue (  \" Is   new   transaction \"  ,    ts . isNewTransaction (  )  )  ;", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Is   existing   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "assertFalse (  \" Is   not   rollback - only \"  ,    status . isRollbackOnly (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   existing   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertTrue (  \" Is   existing   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "assertTrue (  \" Is   rollback - only \"  ,    status . isRollbackOnly (  )  )  ;", "}", "}  )  ;", "outerTransactionBoundaryReached    =    true ;", "tm . commit ( ts )  ;", "fail (  \" Should   have   thrown   UnexpectedRollbackException \"  )  ;", "}    catch    ( UnexpectedRollbackException   ex )     {", "if    (  ! outerTransactionBoundaryReached )     {", "tm . rollback ( ts )  ;", "}", "if    ( failEarly )     {", "assertFalse ( outerTransactionBoundaryReached )  ;", "} else    {", "assertTrue ( outerTransactionBoundaryReached )  ;", "}", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertFalse ( synch . beforeCommitCalled )  ;", "assertTrue ( synch . beforeCompletionCalled )  ;", "assertFalse ( synch . afterCommitCalled )  ;", "assertTrue ( synch . afterCompletionCalled )  ;", "verify ( con )  . rollback (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestParticipatingTransactionWithRollbackOnly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( lazyConnection )     {", "given ( con . getAutoCommit (  )  )  . willReturn ( autoCommit )  ;", "given ( con . getTransactionIsolation (  )  )  . willReturn ( Connection . TRANSACTION _ READ _ COMMITTED )  ;", "}", "if    (  (  ! lazyConnection )     |  |    createStatement )     {", "given ( con . getAutoCommit (  )  )  . willReturn ( autoCommit )  ;", "}", "final   DataSource   dsToUse    =     ( lazyConnection )     ?    new   LazyConnectionDataSourceProxy ( ds )     :    ds ;", "tm    =    new    ( dsToUse )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "Connection   tCon    =    DataSourceUtils . getConnection ( dsToUse )  ;", "try    {", "if    ( createStatement )     {", "tCon . createStatement (  )  ;", "}", "}    catch    ( SQLException   ex )     {", "throw   new   UncategorizedSQLException (  \"  \"  ,     \"  \"  ,    ex )  ;", "}", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "if    ( autoCommit    &  &     (  (  ! lazyConnection )     |  |    createStatement )  )     {", "InOrder   ordered    =    inOrder ( con )  ;", "ordered . verify ( con )  . setAutoCommit ( false )  ;", "ordered . verify ( con )  . commit (  )  ;", "ordered . verify ( con )  . setAutoCommit ( true )  ;", "}", "if    ( createStatement )     {", "verify ( con ,    times (  2  )  )  . close (  )  ;", "} else    {", "verify ( con )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestTransactionCommitRestoringAutoCommit"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( lazyConnection )     {", "given ( con . getAutoCommit (  )  )  . willReturn ( autoCommit )  ;", "given ( con . getTransactionIsolation (  )  )  . willReturn ( Connection . TRANSACTION _ READ _ COMMITTED )  ;", "}", "if    (  (  ! lazyConnection )     |  |    createStatement )     {", "given ( con . getAutoCommit (  )  )  . willReturn ( autoCommit )  ;", "}", "final   DataSource   dsToUse    =     ( lazyConnection )     ?    new   LazyConnectionDataSourceProxy ( ds )     :    ds ;", "tm    =    new    ( dsToUse )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( dsToUse )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "final   RuntimeException   ex    =    new   RuntimeException (  \" Application   exception \"  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( dsToUse )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "Connection   con    =    DataSourceUtils . getConnection ( dsToUse )  ;", "if    ( createStatement )     {", "try    {", "con . createStatement (  )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   UncategorizedSQLException (  \"  \"  ,     \"  \"  ,    ex )  ;", "}", "}", "throw   ex ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   RuntimeException \"  )  ;", "}    catch    ( RuntimeException   ex 2  )     {", "assertTrue (  \" Correct   exception   thrown \"  ,    ex 2  . equals ( ex )  )  ;", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "if    ( autoCommit    &  &     (  (  ! lazyConnection )     |  |    createStatement )  )     {", "InOrder   ordered    =    inOrder ( con )  ;", "ordered . verify ( con )  . setAutoCommit ( false )  ;", "ordered . verify ( con )  . rollback (  )  ;", "ordered . verify ( con )  . setAutoCommit ( true )  ;", "}", "if    ( createStatement )     {", "verify ( con ,    times (  2  )  )  . close (  )  ;", "} else    {", "verify ( con )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestTransactionRollbackRestoringAutoCommit"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "PreparedStatement   ps    =    mock ( PreparedStatement . class )  ;", "given ( con . getAutoCommit (  )  )  . willReturn ( true )  ;", "given ( con . prepareStatement (  \" some   SQL   statement \"  )  )  . willReturn ( ps )  ;", "Template   tt    =    new   Template ( tm )  ;", "tt . setTimeout ( timeout )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "try    {", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )     {", "try    {", "Thread . sleep (  1  5  0  0  )  ;", "}    catch    ( InterruptedException   ex )     {", "}", "try    {", "Connection   con    =    DataSourceUtils . getConnection ( ds )  ;", "PreparedStatement   ps    =    con . prepareStatement (  \" some   SQL   statement \"  )  ;", "DataSourceUtils . applyTimeout ( ps ,    ds )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   DataAccessResourceFailureException (  \"  \"  ,    ex )  ;", "}", "}", "}  )  ;", "if    ( timeout    <  =     1  )     {", "fail (  \" Should   have   thrown   TimedOutException \"  )  ;", "}", "}    catch    ( TimedOutException   ex )     {", "if    ( timeout    <  =     1  )     {", "} else    {", "throw   ex ;", "}", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "if    ( timeout    >     1  )     {", "verify ( ps )  . setQueryTimeout (  ( timeout    -     1  )  )  ;", "verify ( con )  . commit (  )  ;", "} else    {", "verify ( con )  . rollback (  )  ;", "}", "InOrder   ordered    =    inOrder ( con )  ;", "ordered . verify ( con )  . setAutoCommit ( false )  ;", "ordered . verify ( con )  . setAutoCommit ( true )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestTransactionWithTimeout"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "ds    =    mock ( DataSource . class )  ;", "con    =    mock ( Connection . class )  ;", "given ( ds . getConnection (  )  )  . willReturn ( con )  ;", "tm    =    new    ( ds )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "DatabaseMetaData   md    =    mock ( DatabaseMetaData . class )  ;", "Savepoint   sp    =    mock ( Savepoint . class )  ;", "given ( md . supportsSavepoints (  )  )  . willReturn ( true )  ;", "given ( con . getMetaData (  )  )  . willReturn ( md )  ;", "given ( con . setSavepoint (  \" SAVEPOINT _  1  \"  )  )  . willReturn ( sp )  ;", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NESTED )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( SynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "Object   savepoint    =    status . createSavepoint (  )  ;", "status . releaseSavepoint ( savepoint )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . releaseSavepoint ( sp )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . close (  )  ;", "verify ( ds )  . getConnection (  )  ;", "}", "METHOD_END"], "methodName": ["testExistingTransactionWithManualSavepoint"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "DatabaseMetaData   md    =    mock ( DatabaseMetaData . class )  ;", "Savepoint   sp    =    mock ( Savepoint . class )  ;", "given ( md . supportsSavepoints (  )  )  . willReturn ( true )  ;", "given ( con . getMetaData (  )  )  . willReturn ( md )  ;", "given ( con . setSavepoint (  \" SAVEPOINT _  1  \"  )  )  . willReturn ( sp )  ;", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NESTED )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( SynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "Object   savepoint    =    status . createSavepoint (  )  ;", "status . rollbackToSavepoint ( savepoint )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback ( sp )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testExistingTransactionWithManualSavepointAndRollback"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestExistingTransactionWithPropagationNested (  1  )  ;", "}", "METHOD_END"], "methodName": ["testExistingTransactionWithPropagationNested"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "DatabaseMetaData   md    =    mock ( DatabaseMetaData . class )  ;", "Savepoint   sp    =    mock ( Savepoint . class )  ;", "given ( md . supportsSavepoints (  )  )  . willReturn ( true )  ;", "given ( con . getMetaData (  )  )  . willReturn ( md )  ;", "given ( con . setSavepoint (  \" SAVEPOINT _  1  \"  )  )  . willReturn ( sp )  ;", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NESTED )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( SynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "assertTrue (  \" Isn ' t   nested   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "try    {", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    SynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    SynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Isn ' t   new   transaction \"  ,     (  !  ( status . isNew (  )  )  )  )  ;", "assertTrue (  \" Is   nested   transaction \"  ,    status . hasSavepoint (  )  )  ;", "Template   ntt    =    new   Template ( tm )  ;", "ntt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    SynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    SynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Isn ' t   new   transaction \"  ,     (  !  ( status . isNew (  )  )  )  )  ;", "assertTrue (  \" Is   regular   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "throw   new   IllegalStateException (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "assertTrue (  \" Isn ' t   nested   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback ( sp )  ;", "verify ( con )  . releaseSavepoint ( sp )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . isReadOnly (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testExistingTransactionWithPropagationNestedAndRequiredRollback"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "DatabaseMetaData   md    =    mock ( DatabaseMetaData . class )  ;", "Savepoint   sp    =    mock ( Savepoint . class )  ;", "given ( md . supportsSavepoints (  )  )  . willReturn ( true )  ;", "given ( con . getMetaData (  )  )  . willReturn ( md )  ;", "given ( con . setSavepoint (  \" SAVEPOINT _  1  \"  )  )  . willReturn ( sp )  ;", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NESTED )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( SynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "assertTrue (  \" Isn ' t   nested   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "try    {", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    SynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    SynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Isn ' t   new   transaction \"  ,     (  !  ( status . isNew (  )  )  )  )  ;", "assertTrue (  \" Is   nested   transaction \"  ,    status . hasSavepoint (  )  )  ;", "Template   ntt    =    new   Template ( tm )  ;", "ntt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    SynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    SynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Isn ' t   new   transaction \"  ,     (  !  ( status . isNew (  )  )  )  )  ;", "assertTrue (  \" Is   regular   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   UnexpectedRollbackException \"  )  ;", "}    catch    ( UnexpectedRollbackException   ex )     {", "}", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "assertTrue (  \" Isn ' t   nested   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback ( sp )  ;", "verify ( con )  . releaseSavepoint ( sp )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . isReadOnly (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testExistingTransactionWithPropagationNestedAndRequiredRollbackOnly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "DatabaseMetaData   md    =    mock ( DatabaseMetaData . class )  ;", "Savepoint   sp    =    mock ( Savepoint . class )  ;", "given ( md . supportsSavepoints (  )  )  . willReturn ( true )  ;", "given ( con . getMetaData (  )  )  . willReturn ( md )  ;", "given ( con . setSavepoint (  \" SAVEPOINT _  1  \"  )  )  . willReturn ( sp )  ;", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NESTED )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( SynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "assertTrue (  \" Isn ' t   nested   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    SynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    SynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Isn ' t   new   transaction \"  ,     (  !  ( status . isNew (  )  )  )  )  ;", "assertTrue (  \" Is   nested   transaction \"  ,    status . hasSavepoint (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "assertTrue (  \" Isn ' t   nested   transaction \"  ,     (  !  ( status . hasSavepoint (  )  )  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback ( sp )  ;", "verify ( con )  . releaseSavepoint ( sp )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . isReadOnly (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testExistingTransactionWithPropagationNestedAndRollback"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestExistingTransactionWithPropagationNested (  2  )  ;", "}", "METHOD_END"], "methodName": ["testExistingTransactionWithPropagationNestedTwice"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "DataSource   ds 2     =    mock ( DataSource . class )  ;", "final   Connection   con 2     =    mock ( Connection . class )  ;", "given ( ds 2  . getConnection (  )  )  . willReturn ( con 2  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "final    . TestTransactionSynchronization   synch    =    new    . TestTransactionSynchronization ( ds ,    TransactionSynchronization . STATUS _ COMMITTED )     {", "@ Override", "protected   void   doAfterCompletion ( int   status )     {", "super . doAfterCompletion ( status )  ;", "Connection   con    =    DataSourceUtils . getConnection ( ds 2  )  ;", "DataSourceUtils . releaseConnection ( con ,    ds 2  )  ;", "}", "}  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue ( synch . beforeCommitCalled )  ;", "assertTrue ( synch . beforeCompletionCalled )  ;", "assertTrue ( synch . afterCommitCalled )  ;", "assertTrue ( synch . afterCompletionCalled )  ;", "assertNull ( synch . afterCompletionException )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . close (  )  ;", "verify ( con 2  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testParticipatingTransactionWithDifferentConnectionObtainedFromSynch"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "tm . setValidateExistingTransaction ( true )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "try    {", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "final   TransactionTemplate   tt 2     =    new   TransactionTemplate ( tm )  ;", "tt 2  . setIsolationLevel ( ISOLATION _ SERIALIZABLE )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertFalse (  \" Is   not   rollback - only \"  ,    status . isRollbackOnly (  )  )  ;", "tt 2  . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertTrue (  \" Is   rollback - only \"  ,    status . isRollbackOnly (  )  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   IllegalTransactionStateException \"  )  ;", "}    catch    ( IllegalTransactionStateException   ex )     {", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testParticipatingTransactionWithIncompatibleIsolationLevel"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "willThrow ( new   SQLException (  \" read - only   not   supported \"  )  )  . given ( con )  . setReadOnly ( true )  ;", "tm . setValidateExisting ( true )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( SynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "try    {", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setReadOnly ( true )  ;", "final   Template   tt 2     =    new   Template ( tm )  ;", "tt 2  . setReadOnly ( false )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertFalse (  \" Is   not   rollback - only \"  ,    status . isRollbackOnly (  )  )  ;", "tt 2  . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertTrue (  \" Is   rollback - only \"  ,    status . isRollbackOnly (  )  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testParticipatingTransactionWithIncompatibleReadOnly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestParticipatingTransactionWithRollbackOnly ( false )  ;", "}", "METHOD_END"], "methodName": ["testParticipatingTransactionWithRollbackOnly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestParticipatingTransactionWithRollbackOnly ( true )  ;", "}", "METHOD_END"], "methodName": ["testParticipatingTransactionWithRollbackOnlyAndFailEarly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "tm . setTransactionSynchronization ( SYNCHRONIZATION _ NEVER )  ;", "DataSourceTransactionManager   tm 2     =    new   DataSourceTransactionManager ( ds )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "TransactionStatus   ts    =    tm . getTransaction ( new   DefaultTransactionDefinition (  )  )  ;", "final    . TestTransactionSynchronization   synch    =    new    . TestTransactionSynchronization ( ds ,    TransactionSynchronization . STATUS _ UNKNOWN )  ;", "try    {", "assertTrue (  \" Is   new   transaction \"  ,    ts . isNewTransaction (  )  )  ;", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm 2  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Is   existing   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "assertFalse (  \" Is   not   rollback - only \"  ,    status . isRollbackOnly (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   existing   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertTrue (  \" Is   existing   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "assertTrue (  \" Is   rollback - only \"  ,    status . isRollbackOnly (  )  )  ;", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "}", "}  )  ;", "tm . commit ( ts )  ;", "fail (  \" Should   have   thrown   UnexpectedRollbackException \"  )  ;", "}    catch    ( UnexpectedRollbackException   ex )     {", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertFalse ( synch . beforeCommitCalled )  ;", "assertTrue ( synch . beforeCompletionCalled )  ;", "assertFalse ( synch . afterCommitCalled )  ;", "assertTrue ( synch . afterCompletionCalled )  ;", "verify ( con )  . rollback (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testParticipatingTransactionWithRollbackOnlyAndInnerSynch"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "final    . TestTransactionSynchronization   synch    =    new    . TestTransactionSynchronization ( ds ,    TransactionSynchronization . STATUS _ COMMITTED )     {", "@ Override", "protected   void   doAfterCompletion ( int   status )     {", "super . doAfterCompletion ( status )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "}", "}  )  ;", "TransactionSynchronizationManager . registerSynchronization ( new   TransactionSynchronizationAdapter (  )     {  }  )  ;", "}", "}  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "TransactionSynchronizationManager . registerSynchronization ( synch )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue ( synch . beforeCommitCalled )  ;", "assertTrue ( synch . beforeCompletionCalled )  ;", "assertTrue ( synch . afterCommitCalled )  ;", "assertTrue ( synch . afterCompletionCalled )  ;", "assertTrue (  (  ( synch . afterCompletionException )    instanceof   IllegalStateException )  )  ;", "verify ( con ,    times (  2  )  )  . commit (  )  ;", "verify ( con ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testParticipatingTransactionWithTransactionStartedFromSynch"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NEVER )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "fail (  \" Should   have   thrown   IllegalTransactionStateException \"  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   IllegalTransactionStateException \"  )  ;", "}", "}  )  ;", "}    catch    ( IllegalTransactionStateException   ex )     {", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPropagationNeverWithExistingTransaction"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NOT _ SUPPORTED )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Isn ' t   new   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPropagationNotSupportedWithExistingTransaction"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback (  )  ;", "verify ( con )  . commit (  )  ;", "verify ( con ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPropagationRequiresNewWithExistingTransaction"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "Connection   con 2     =    mock ( Connection . class )  ;", "final   DataSource   ds 2     =    mock ( DataSource . class )  ;", "given ( ds 2  . getConnection (  )  )  . willReturn ( con 2  )  ;", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "PlatformTransactionManager   tm 2     =    new    ( ds 2  )  ;", "final   TransactionTemplate   tt 2     =    new   TransactionTemplate ( tm 2  )  ;", "tt 2  . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds 2  )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "tt 2  . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds 2  )  )  )  )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . close (  )  ;", "verify ( con 2  )  . rollback (  )  ;", "verify ( con 2  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPropagationRequiresNewWithExistingTransactionAndUnrelatedDataSource"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   DataSource   ds 2     =    mock ( DataSource . class )  ;", "SQLException   failure    =    new   SQLException (  )  ;", "given ( ds 2  . getConnection (  )  )  . willThrow ( failure )  ;", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "tm 2     =    new    ( ds 2  )  ;", "tm 2  . setTransactionSynchronization ( SYNCHRONIZATION _ NEVER )  ;", "final   TransactionTemplate   tt 2     =    new   TransactionTemplate ( tm 2  )  ;", "tt 2  . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds 2  )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "tt 2  . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   CannotCreateTransactionException \"  )  ;", "}    catch    ( CannotCreateTransactionException   ex )     {", "assertSame ( failure ,    ex . getCause (  )  )  ;", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds 2  )  )  )  )  ;", "verify ( con )  . rollback (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPropagationRequiresNewWithExistingTransactionAndUnrelatedFailingDataSource"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ SUPPORTS )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "TransactionTemplate   tt 2     =    new   TransactionTemplate ( tm )  ;", "tt 2  . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "tt 2  . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "assertSame ( con ,    DataSourceUtils . getConnection ( ds )  )  ;", "assertSame ( con ,    DataSourceUtils . getConnection ( ds )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPropagationSupportsAndRequiresNew"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   Connection   con 1     =    mock ( Connection . class )  ;", "final   Connection   con 2     =    mock ( Connection . class )  ;", "given ( ds . getConnection (  )  )  . willReturn ( con 1  ,    con 2  )  ;", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ SUPPORTS )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( SynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Synchronization   active \"  ,    SynchronizationManager . isSynchronizationActive (  )  )  ;", "assertSame ( con 1  ,    DataSourceUtils . getConnection ( ds )  )  ;", "assertSame ( con 1  ,    DataSourceUtils . getConnection ( ds )  )  ;", "Template   tt 2     =    new   Template ( tm )  ;", "tt 2  . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "tt 2  . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    SynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   active \"  ,    SynchronizationManager . isSynchronizationActive (  )  )  ;", "assertTrue (  \" Is   new   transaction \"  ,    status . isNew (  )  )  ;", "assertSame ( con 2  ,    DataSourceUtils . getConnection ( ds )  )  ;", "assertSame ( con 2  ,    DataSourceUtils . getConnection ( ds )  )  ;", "}", "}  )  ;", "assertSame ( con 1  ,    DataSourceUtils . getConnection ( ds )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con 1  )  . close (  )  ;", "verify ( con 2  )  . commit (  )  ;", "verify ( con 2  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPropagationSupportsAndRequiresNewWithEarlyAccess"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "given ( con . getAutoCommit (  )  )  . willReturn ( true )  ;", "Template   tt    =    new   Template ( tm )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )     {", "assertEquals ( con ,    DataSourceUtils . getConnection ( ds )  )  ;", "AwareDataSourceProxy   dsProxy    =    new   AwareDataSourceProxy ( ds )  ;", "try    {", "assertEquals ( con ,     (  ( ConnectionProxy )     ( dsProxy . getConnection (  )  )  )  . getTargetConnection (  )  )  ;", "dsProxy . getConnection (  )  . close (  )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   UncategorizedSQLException (  \"  \"  ,     \"  \"  ,    ex )  ;", "}", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "InOrder   ordered    =    inOrder ( con )  ;", "ordered . verify ( con )  . setAutoCommit ( false )  ;", "ordered . verify ( con )  . commit (  )  ;", "ordered . verify ( con )  . setAutoCommit ( true )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionAwareDataSourceProxy"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "given ( con . getAutoCommit (  )  )  . willReturn ( true )  ;", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )     {", "assertEquals ( con ,    DataSourceUtils . getConnection ( ds )  )  ;", "final   AwareDataSourceProxy   dsProxy    =    new   AwareDataSourceProxy ( ds )  ;", "try    {", "assertEquals ( con ,     (  ( ConnectionProxy )     ( dsProxy . getConnection (  )  )  )  . getTargetConnection (  )  )  ;", "dsProxy . getConnection (  )  . close (  )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   UncategorizedSQLException (  \"  \"  ,     \"  \"  ,    ex )  ;", "}", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )     {", "assertEquals ( con ,    DataSourceUtils . getConnection ( ds )  )  ;", "try    {", "assertEquals ( con ,     (  ( ConnectionProxy )     ( dsProxy . getConnection (  )  )  )  . getTargetConnection (  )  )  ;", "dsProxy . getConnection (  )  . close (  )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   UncategorizedSQLException (  \"  \"  ,     \"  \"  ,    ex )  ;", "}", "}", "}  )  ;", "try    {", "assertEquals ( con ,     (  ( ConnectionProxy )     ( dsProxy . getConnection (  )  )  )  . getTargetConnection (  )  )  ;", "dsProxy . getConnection (  )  . close (  )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   UncategorizedSQLException (  \"  \"  ,     \"  \"  ,    ex )  ;", "}", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "InOrder   ordered    =    inOrder ( con )  ;", "ordered . verify ( con )  . setAutoCommit ( false )  ;", "ordered . verify ( con )  . commit (  )  ;", "ordered . verify ( con )  . setAutoCommit ( true )  ;", "verify ( con ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionAwareDataSourceProxyWithSuspension"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "given ( con . getAutoCommit (  )  )  . willReturn ( true )  ;", "final   Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )     {", "assertEquals ( con ,    DataSourceUtils . getConnection ( ds )  )  ;", "final   AwareDataSourceProxy   dsProxy    =    new   AwareDataSourceProxy ( ds )  ;", "dsProxy . setReobtainalConnections ( true )  ;", "try    {", "assertEquals ( con ,     (  ( ConnectionProxy )     ( dsProxy . getConnection (  )  )  )  . getTargetConnection (  )  )  ;", "dsProxy . getConnection (  )  . close (  )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   UncategorizedSQLException (  \"  \"  ,     \"  \"  ,    ex )  ;", "}", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )     {", "assertEquals ( con ,    DataSourceUtils . getConnection ( ds )  )  ;", "try    {", "assertEquals ( con ,     (  ( ConnectionProxy )     ( dsProxy . getConnection (  )  )  )  . getTargetConnection (  )  )  ;", "dsProxy . getConnection (  )  . close (  )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   UncategorizedSQLException (  \"  \"  ,     \"  \"  ,    ex )  ;", "}", "}", "}  )  ;", "try    {", "assertEquals ( con ,     (  ( ConnectionProxy )     ( dsProxy . getConnection (  )  )  )  . getTargetConnection (  )  )  ;", "dsProxy . getConnection (  )  . close (  )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   UncategorizedSQLException (  \"  \"  ,     \"  \"  ,    ex )  ;", "}", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "InOrder   ordered    =    inOrder ( con )  ;", "ordered . verify ( con )  . setAutoCommit ( false )  ;", "ordered . verify ( con )  . commit (  )  ;", "ordered . verify ( con )  . setAutoCommit ( true )  ;", "verify ( con ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionAwareDataSourceProxyWithSuspensionAndReobtaining"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionCommitRestoringAutoCommit ( false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransactionCommitWithAutoCommitFalse"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionCommitRestoringAutoCommit ( false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransactionCommitWithAutoCommitFalseAndLazyConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionCommitRestoringAutoCommit ( false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testTransactionCommitWithAutoCommitFalseAndLazyConnectionAndStatementCreated"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionCommitRestoringAutoCommit ( true ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransactionCommitWithAutoCommitTrue"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionCommitRestoringAutoCommit ( true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransactionCommitWithAutoCommitTrueAndLazyConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionCommitRestoringAutoCommit ( true ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testTransactionCommitWithAutoCommitTrueAndLazyConnectionAndStatementCreated"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "tm . setTransactionSynchronization ( SYNCHRONIZATION _ NEVER )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "ConnectionHolder   conHolder    =    new   ConnectionHolder ( con )  ;", "conHolder . setTransactionActive ( true )  ;", "TransactionSynchronizationManager . bindResource ( ds ,    conHolder )  ;", "final   RuntimeException   ex    =    new   RuntimeException (  \" Application   exception \"  )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Has   thread   connection \"  ,    TransactionSynchronizationManager . hasResource ( ds )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "assertTrue (  \" Is   existing   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "throw   ex ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   RuntimeException \"  )  ;", "}    catch    ( RuntimeException   ex 2  )     {", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "assertEquals (  \" Correct   exception   thrown \"  ,    ex ,    ex 2  )  ;", "}    finally    {", "TransactionSynchronizationManager . unbindResource ( ds )  ;", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionRollbackOnly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionRollbackRestoringAutoCommit ( false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransactionRollbackWithAutoCommitFalse"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionRollbackRestoringAutoCommit ( false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransactionRollbackWithAutoCommitFalseAndLazyConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionRollbackRestoringAutoCommit ( false ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testTransactionRollbackWithAutoCommitFalseAndLazyConnectionAndCreateStatement"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionRollbackRestoringAutoCommit ( true ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransactionRollbackWithAutoCommitTrue"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionRollbackRestoringAutoCommit ( true ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testTransactionRollbackWithAutoCommitTrueAndLazyConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionRollbackRestoringAutoCommit ( true ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testTransactionRollbackWithAutoCommitTrueAndLazyConnectionAndCreateStatement"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "tm . setEnforceReadOnly ( true )  ;", "given ( con . getAutoCommit (  )  )  . willReturn ( true )  ;", "Statement   stmt    =    mock ( Statement . class )  ;", "given ( con . createStatement (  )  )  . willReturn ( stmt )  ;", "Template   tt    =    new   Template ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "tt . setReadOnly ( true )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )     {", "assertTrue ( SynchronizationManager . isCurrentReadOnly (  )  )  ;", "assertTrue ( SynchronizationManager . isActualActive (  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "InOrder   ordered    =    inOrder ( con ,    stmt )  ;", "ordered . verify ( con )  . setAutoCommit ( false )  ;", "ordered . verify ( stmt )  . executeUpdate (  \" SET   TRANSACTION   READ   ONLY \"  )  ;", "ordered . verify ( stmt )  . close (  )  ;", "ordered . verify ( con )  . commit (  )  ;", "ordered . verify ( con )  . setAutoCommit ( true )  ;", "ordered . verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithEnforceReadOnly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "willThrow ( new   SQLException (  \" Cannot   begin \"  )  )  . given ( con )  . getAutoCommit (  )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "try    {", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "}", "}  )  ;", "fail (  \" Should   have   thrown   CannotCreatException \"  )  ;", "}    catch    ( CannotCreatException   ex )     {", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithExceptionOnBegin"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "willThrow ( new   SQLException (  \" Cannot   commit \"  )  )  . given ( con )  . commit (  )  ;", "Template   tt    =    new   Template ( tm )  ;", "try    {", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )     {", "}", "}  )  ;", "fail (  \" Should   have   thrown   SystemException \"  )  ;", "}    catch    ( SystemException   ex )     {", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithExceptionOnCommit"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "willThrow ( new   SQLException (  \" Cannot   commit \"  )  )  . given ( con )  . commit (  )  ;", "tm . setRollbackOnCommitFailure ( true )  ;", "Template   tt    =    new   Template ( tm )  ;", "try    {", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )     {", "}", "}  )  ;", "fail (  \" Should   have   thrown   SystemException \"  )  ;", "}    catch    ( SystemException   ex )     {", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithExceptionOnCommitAndRollbackOnCommitFailure"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "given ( con . getAutoCommit (  )  )  . willReturn ( true )  ;", "willThrow ( new   SQLException (  \" Cannot   rollback \"  )  )  . given ( con )  . rollback (  )  ;", "Template   tt    =    new   Template ( tm )  ;", "try    {", "tt . execute ( new   CallbackWithoutResult (  )     {", "@ Override", "protected   void   doInWithoutResult ( Status   status )    throws   RuntimeException    {", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "fail (  \" Should   have   thrown   SystemException \"  )  ;", "}    catch    ( SystemException   ex )     {", "}", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( SynchronizationManager . hasResource ( ds )  )  )  )  ;", "InOrder   ordered    =    inOrder ( con )  ;", "ordered . verify ( con )  . setAutoCommit ( false )  ;", "ordered . verify ( con )  . rollback (  )  ;", "ordered . verify ( con )  . setAutoCommit ( true )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithExceptionOnRollback"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "given ( con . getTransactionIsolation (  )  )  . willReturn ( Connection . TRANSACTION _ READ _ COMMITTED )  ;", "given ( con . getAutoCommit (  )  )  . willReturn ( true )  ;", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ REQUIRES _ NEW )  ;", "tt . setIsolationLevel ( ISOLATION _ SERIALIZABLE )  ;", "tt . setReadOnly ( true )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )     {", "assertTrue ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertTrue ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "InOrder   ordered    =    inOrder ( con )  ;", "ordered . verify ( con )  . setTransactionIsolation ( Connection . TRANSACTION _ SERIALIZABLE )  ;", "ordered . verify ( con )  . setAutoCommit ( false )  ;", "ordered . verify ( con )  . commit (  )  ;", "ordered . verify ( con )  . setAutoCommit ( true )  ;", "ordered . verify ( con )  . setTransactionIsolation ( Connection . TRANSACTION _ READ _ COMMITTED )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithIsolationAndReadOnly"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionWithTimeout (  1  0  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithLongTimeout"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NESTED )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . commit (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithPropagationNested"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "final   TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NESTED )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Synchronization   not   active \"  ,     (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Is   new   transaction \"  ,    status . isNewTransaction (  )  )  ;", "status . setRollbackOnly (  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "verify ( con )  . rollback (  )  ;", "verify ( con )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithPropagationNestedAndRollback"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NEVER )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Is   not   new   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithPropagationNever"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ NOT _ SUPPORTED )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Is   not   new   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithPropagationNotSupported"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "TransactionTemplate   tt    =    new   TransactionTemplate ( tm )  ;", "tt . setPropagationBehavior ( PROPAGATION _ SUPPORTS )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "tt . execute ( new   TransactionCallbackWithoutResult (  )     {", "@ Override", "protected   void   doInTransactionWithoutResult ( TransactionStatus   status )    throws   RuntimeException    {", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "assertTrue (  \" Is   not   new   transaction \"  ,     (  !  ( status . isNewTransaction (  )  )  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "}  )  ;", "assertTrue (  \" Hasn ' t   thread   connection \"  ,     (  !  ( TransactionSynchronizationManager . hasResource ( ds )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithPropagationSupports"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "doTestTransactionWithTimeout (  1  )  ;", "}", "METHOD_END"], "methodName": ["testTransactionWithShortTimeout"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TransactionSynchronizationManager . getResourceMap (  )  . isEmpty (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  )  ;", "assertFalse ( TransactionSynchronizationManager . isActualTransactionActive (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyTransactionSynchronizationManagerState"], "fileName": "org.springframework.jdbc.datasource.DataSourceTransactionManagerTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( stmt ,     \" No   Statement   specified \"  )  ;", "ConnectionHolder   holder    =    null ;", "if    ( d    !  =    null )     {", "holder    =     (  ( ConnectionHolder )     ( TransactionSynchronizationManager . getResource ( d )  )  )  ;", "}", "if    (  ( holder    !  =    null )     &  &     ( holder . hasTimeout (  )  )  )     {", "stmt . setQueryTimeout ( holder . getTimeToLiveInSeconds (  )  )  ;", "} else", "if    ( timeout    >  =     0  )     {", "stmt . setQueryTimeout ( timeout )  ;", "}", "}", "METHOD_END"], "methodName": ["applyTimeout"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "DataSourceUtils . applyTimeout ( stmt ,    dataSource ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["applyTransactionTimeout"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( conHolder . hasConnection (  )  )  )     {", "return   false ;", "}", "Connection   heldCon    =    conHolder . getConnection (  )  ;", "return    (  ( heldCon    =  =    passedInCon )     |  |     ( heldCon . equals ( passedInCon )  )  )     |  |     (  . getTargetConnection ( heldCon )  . equals ( passedInCon )  )  ;", "}", "METHOD_END"], "methodName": ["connectionEquals"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( dataSource   instanceof   SmartDataSource )  )     |  |     (  (  ( SmartDataSource )     ( dataSource )  )  . shouldClose ( con )  )  )     {", "con . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doCloseConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( dataSource ,     \" No   DataSource   specified \"  )  ;", "ConnectionHolder   conHolder    =     (  ( ConnectionHolder )     ( TransactionSynchronizationManager . getResource ( dataSource )  )  )  ;", "if    (  ( conHolder    !  =    null )     &  &     (  ( conHolder . hasConnection (  )  )     |  |     ( conHolder . isSynchronizedWithTransaction (  )  )  )  )     {", "conHolder . requested (  )  ;", "if    (  !  ( conHolder . hasConnection (  )  )  )     {", ". logger . debug (  \" Fetching   resumed   JDBC   Connection   from   DataSource \"  )  ;", "conHolder . setConnection (  . fetchConnection ( dataSource )  )  ;", "}", "return   conHolder . getConnection (  )  ;", "}", ". logger . debug (  \" Fetching   JDBC   Connection   from   DataSource \"  )  ;", "Connection   con    =     . fetchConnection ( dataSource )  ;", "if    ( TransactionSynchronizationManager . isSynchronizationActive (  )  )     {", ". logger . debug (  \" Registering   transaction   synchronization   for   JDBC   Connection \"  )  ;", "ConnectionHolder   holderToUse    =    conHolder ;", "if    ( holderToUse    =  =    null )     {", "holderToUse    =    new   ConnectionHolder ( con )  ;", "} else    {", "holderToUse . setConnection ( con )  ;", "}", "holderToUse . requested (  )  ;", "TransactionSynchronizationManager . registerSynchronization ( new    . ConnectionSynchronization ( holderToUse ,    dataSource )  )  ;", "holderToUse . setSynchronizedWithTransaction ( true )  ;", "if    ( holderToUse    !  =    conHolder )     {", "TransactionSynchronizationManager . bindResource ( dataSource ,    holderToUse )  ;", "}", "}", "return   con ;", "}", "METHOD_END"], "methodName": ["doGetConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( con    =  =    null )     {", "return ;", "}", "if    ( dataSource    !  =    null )     {", "ConnectionHolder   conHolder    =     (  ( ConnectionHolder )     ( TransactionSynchronizationManager . getResource ( dataSource )  )  )  ;", "if    (  ( conHolder    !  =    null )     &  &     (  . connectionEquals ( conHolder ,    con )  )  )     {", "conHolder . released (  )  ;", "return ;", "}", "}", ". logger . debug (  \" Returning   JDBC   Connection   to   DataSource \"  )  ;", ". doCloseConnection ( con ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["doReleaseConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "Connection   con    =    dataSource . getConnection (  )  ;", "if    ( con    =  =    null )     {", "throw   new   IllegalStateException (  (  \"    returned   null   from   getConnection (  )  :     \"     +    dataSource )  )  ;", "}", "return   con ;", "}", "METHOD_END"], "methodName": ["fetchConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . doGetConnection ( dataSource )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   CannotGetJdbcConnectionException (  \" Failed   to   obtain   JDBC   Connection \"  ,    ex )  ;", "}    catch    ( IllegalStateException   ex )     {", "throw   new   CannotGetJdbcConnectionException (  (  \" Failed   to   obtain   JDBC   Connection :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "int   order    =    DataSourceUtils . CONNECTION _ SYNCHRONIZATION _ ORDER ;", "DataSource   currDs    =    dataSource ;", "while    ( currDs   instanceof   DelegatingDataSource )     {", "order -  -  ;", "currDs    =     (  ( DelegatingDataSource )     ( currDs )  )  . getTargetDataSource (  )  ;", "}", "return   order ;", "}", "METHOD_END"], "methodName": ["getConnectionSynchronizationOrder"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "Connection   conToUse    =    con ;", "while    ( conToUse   instanceof   ConnectionProxy )     {", "conToUse    =     (  ( ConnectionProxy )     ( conToUse )  )  . getTargetConnection (  )  ;", "}", "return   conToUse ;", "}", "METHOD_END"], "methodName": ["getTargetConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( dataSource    =  =    null )     {", "return   false ;", "}", "ConnectionHolder   conHolder    =     (  ( ConnectionHolder )     ( TransactionSynchronizationManager . getResource ( dataSource )  )  )  ;", "return    ( conHolder    !  =    null )     &  &     (  . connectionEquals ( conHolder ,    con )  )  ;", "}", "METHOD_END"], "methodName": ["isConnectionTransactional"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( con ,     \" No   Connection   specified \"  )  ;", "if    (  ( definition    !  =    null )     &  &     ( definition . isReadOnly (  )  )  )     {", "try    {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Setting   JDBC   Connection    [  \"     +    con )     +     \"  ]    read - only \"  )  )  ;", "}", "con . setReadOnly ( true )  ;", "}    catch    ( SQLException    |    RuntimeException   ex )     {", "Throwable   exToCheck    =    ex ;", "while    ( exToCheck    !  =    null )     {", "if    ( exToCheck . getClass (  )  . getSimpleName (  )  . contains (  \" Timeout \"  )  )     {", "throw   ex ;", "}", "exToCheck    =    exToCheck . getCause (  )  ;", "}", ". logger . debug (  \" Could   not   set   JDBC   Connection   read - only \"  ,    ex )  ;", "}", "}", "Integer   previousIsolationLevel    =    null ;", "if    (  ( definition    !  =    null )     &  &     (  ( definition . getIsolationLevel (  )  )     !  =     ( TransactionDefinition . ISOLATION _ DEFAULT )  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Changing   isolation   level   of   JDBC   Connection    [  \"     +    con )     +     \"  ]    to    \"  )     +     ( definition . getIsolationLevel (  )  )  )  )  ;", "}", "int   currentIsolation    =    con . getTransactionIsolation (  )  ;", "if    ( currentIsolation    !  =     ( definition . getIsolationLevel (  )  )  )     {", "previousIsolationLevel    =    currentIsolation ;", "con . setTransactionIsolation ( definition . getIsolationLevel (  )  )  ;", "}", "}", "return   previousIsolationLevel ;", "}", "METHOD_END"], "methodName": ["prepareConnectionForTransaction"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", ". doReleaseConnection ( con ,    dataSource )  ;", "}    catch    ( SQLException   ex )     {", ". logger . debug (  \" Could   not   close   JDBC   Connection \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Unexpected   exception   on   closing   JDBC   Connection \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["releaseConnection"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( con ,     \" No   Connection   specified \"  )  ;", "try    {", "if    ( previousIsolationLevel    !  =    null )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Resetting   isolation   level   of   JDBC   Connection    [  \"     +    con )     +     \"  ]    to    \"  )     +    previousIsolationLevel )  )  ;", "}", "con . setTransactionIsolation ( previousIsolationLevel )  ;", "}", "if    ( con . isReadOnly (  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Resetting   read - only   flag   of   JDBC   Connection    [  \"     +    con )     +     \"  ]  \"  )  )  ;", "}", "con . setReadOnly ( false )  ;", "}", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Could   not   reset   JDBC   Connection   after   transaction \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["resetConnectionAfterTransaction"], "fileName": "org.springframework.jdbc.datasource.DataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . targetDataSource ;", "}", "METHOD_END"], "methodName": ["getTargetDataSource"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSource"}, {"methodBody": ["METHOD_START", "{", "DataSource   dataSource    =    getTargetDataSource (  )  ;", "Assert . state (  ( dataSource    !  =    null )  ,     \" No    ' targetDataSource '    set \"  )  ;", "return   dataSource ;", "}", "METHOD_END"], "methodName": ["obtainTargetDataSource"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSource"}, {"methodBody": ["METHOD_START", "{", "this . targetDataSource    =    targetDataSource ;", "}", "METHOD_END"], "methodName": ["setTargetDataSource"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSource"}, {"methodBody": ["METHOD_START", "{", "Connection   connection    =    mock ( Connection . class )  ;", "given ( delegate . getConnection (  )  )  . willReturn ( connection )  ;", "assertThat ( d . getConnection (  )  ,    is ( connection )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateGetConnection"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "Connection   connection    =    mock ( Connection . class )  ;", "String   username    =     \" username \"  ;", "String   password    =     \" password \"  ;", "given ( delegate . getConnection ( username ,    password )  )  . willReturn ( connection )  ;", "assertThat ( d . getConnection ( username ,    password )  ,    is ( connection )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateGetConnectionWithUsernameAndPassword"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "PrintWriter   writer    =    new   PrintWriter ( new   ByteArrayOutputStream (  )  )  ;", "given ( delegate . getLogWriter (  )  )  . willReturn ( writer )  ;", "assertThat ( d . getLogWriter (  )  ,    is ( writer )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateGetLogWriter"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "int   timeout    =     1  2  3  ;", "given ( delegate . getLoginTimeout (  )  )  . willReturn ( timeout )  ;", "assertThat ( d . getLoginTimeout (  )  ,    is ( timeout )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateGetLoginTimeout"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "dataSource    =    new   DelegatingDataSourceTests . DelegatingDataSourceWithWrapper (  )  ;", "assertThat ( dataSource . isWrapperFor ( DelegatingDataSourceTests . ExampleWrapper . class )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateIsWrapperForImplementing"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "given ( delegate . isWrapperFor ( DelegatingDataSourceTests . ExampleWrapper . class )  )  . willReturn ( true )  ;", "assertThat ( dataSource . isWrapperFor ( DelegatingDataSourceTests . ExampleWrapper . class )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateIsWrapperForWithoutImplementing"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "PrintWriter   writer    =    new   PrintWriter ( new   ByteArrayOutputStream (  )  )  ;", "d . setLogWriter ( writer )  ;", "verify ( delegate )  . setLogWriter ( writer )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateSetLogWriter"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "int   timeout    =     1  2  3  ;", "d . setLoginTimeout ( timeout )  ;", "verify ( delegate )  . setLoginTimeout ( timeout )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateSetLoginTimeoutWithSeconds"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "dataSource    =    new   DelegatingDataSourceTests . DelegatingDataSourceWithWrapper (  )  ;", "assertThat ( dataSource . unwrap ( DelegatingDataSourceTests . ExampleWrapper . class )  ,    is (  (  ( DelegatingDataSourceTests . ExampleWrapper )     ( dataSource )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateUnwrapImplementing"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "DelegatingDataSourceTests . ExampleWrapper   wrapper    =    mock ( DelegatingDataSourceTests . ExampleWrapper . class )  ;", "given ( delegate . unwrap ( DelegatingDataSourceTests . ExampleWrapper . class )  )  . willReturn ( wrapper )  ;", "assertThat ( dataSource . unwrap ( DelegatingDataSourceTests . ExampleWrapper . class )  ,    is ( wrapper )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDelegateUnwrapWithoutImplementing"], "fileName": "org.springframework.jdbc.datasource.DelegatingDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "return   DriverManager . getConnection ( url ,    props )  ;", "}", "METHOD_END"], "methodName": ["getConnectionFromDriverManager"], "fileName": "org.springframework.jdbc.datasource.DriverManagerDataSource"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( driverClassName ,     \" Property    ' driverClassName '    must   not   be   empty \"  )  ;", "String   driverClassNameToUse    =    driverClassName . trim (  )  ;", "try    {", "Class . forName ( driverClassNameToUse ,    true ,    ClassUtils . getDefaultClassLoader (  )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Could   not   load   JDBC   driver   class    [  \"     +    driverClassNameToUse )     +     \"  ]  \"  )  ,    ex )  ;", "}", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Loaded   JDBC   driver :     \"     +    driverClassNameToUse )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setDriverClassName"], "fileName": "org.springframework.jdbc.datasource.DriverManagerDataSource"}, {"methodBody": ["METHOD_START", "{", "String   bogusClassName    =     \" foobar \"  ;", "ds    =    new    (  )  ;", "try    {", "ds . setDriverClassName ( bogusClassName )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   ClassNotFoundException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testInvalidClassName"], "fileName": "org.springframework.jdbc.datasource.DriverManagerDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "final   String   jdbcUrl    =     \" url \"  ;", "final   String   uname    =     \" uname \"  ;", "final   String   pwd    =     \" pwd \"  ;", "class   Test   extends       {", "@ Override", "protected   Connection   getConnectionFromDriverManager ( String   url ,    Properties   props )     {", "assertEquals ( jdbcUrl ,    url )  ;", "assertEquals ( uname ,    props . getProperty (  \" user \"  )  )  ;", "assertEquals ( pwd ,    props . getProperty (  \" password \"  )  )  ;", "return   connection ;", "}", "}", "ds    =    new   Test (  )  ;", "ds . setUrl ( jdbcUrl )  ;", "ds . setUsername ( uname )  ;", "ds . setPassword ( pwd )  ;", "Connection   actualCon    =    ds . getConnection (  )  ;", "assertTrue (  ( actualCon    =  =     ( connection )  )  )  ;", "assertTrue ( ds . getUrl (  )  . equals ( jdbcUrl )  )  ;", "assertTrue ( ds . getPassword (  )  . equals ( pwd )  )  ;", "assertTrue ( ds . getUsername (  )  . equals ( uname )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardUsage"], "fileName": "org.springframework.jdbc.datasource.DriverManagerDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "final   String   jdbcUrl    =     \" url \"  ;", "final   Properties   connProps    =    new   Properties (  )  ;", "connProps . setProperty (  \" myProp \"  ,     \" myValue \"  )  ;", "connProps . setProperty (  \" yourProp \"  ,     \" yourValue \"  )  ;", "connProps . setProperty (  \" user \"  ,     \" uname \"  )  ;", "connProps . setProperty (  \" password \"  ,     \" pwd \"  )  ;", "class   Test   extends       {", "@ Override", "protected   Connection   getConnectionFromDriverManager ( String   url ,    Properties   props )     {", "assertEquals ( jdbcUrl ,    url )  ;", "assertEquals (  \" uname \"  ,    props . getProperty (  \" user \"  )  )  ;", "assertEquals (  \" pwd \"  ,    props . getProperty (  \" password \"  )  )  ;", "assertEquals (  \" myValue \"  ,    props . getProperty (  \" myProp \"  )  )  ;", "assertEquals (  \" yourValue \"  ,    props . getProperty (  \" yourProp \"  )  )  ;", "return   connection ;", "}", "}", "ds    =    new   Test (  )  ;", "ds . setUrl ( jdbcUrl )  ;", "ds . setConnectionProperties ( connProps )  ;", "Connection   actualCon    =    ds . getConnection (  )  ;", "assertTrue (  ( actualCon    =  =     ( connection )  )  )  ;", "assertTrue ( ds . getUrl (  )  . equals ( jdbcUrl )  )  ;", "}", "METHOD_END"], "methodName": ["testUsageWithConnectionProperties"], "fileName": "org.springframework.jdbc.datasource.DriverManagerDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "final   String   jdbcUrl    =     \" url \"  ;", "final   String   uname    =     \" uname \"  ;", "final   String   pwd    =     \" pwd \"  ;", "final   Properties   connProps    =    new   Properties (  )  ;", "connProps . setProperty (  \" myProp \"  ,     \" myValue \"  )  ;", "connProps . setProperty (  \" yourProp \"  ,     \" yourValue \"  )  ;", "connProps . setProperty (  \" user \"  ,     \" uname 2  \"  )  ;", "connProps . setProperty (  \" password \"  ,     \" pwd 2  \"  )  ;", "class   Test   extends       {", "@ Override", "protected   Connection   getConnectionFromDriverManager ( String   url ,    Properties   props )     {", "assertEquals ( jdbcUrl ,    url )  ;", "assertEquals ( uname ,    props . getProperty (  \" user \"  )  )  ;", "assertEquals ( pwd ,    props . getProperty (  \" password \"  )  )  ;", "assertEquals (  \" myValue \"  ,    props . getProperty (  \" myProp \"  )  )  ;", "assertEquals (  \" yourValue \"  ,    props . getProperty (  \" yourProp \"  )  )  ;", "return   connection ;", "}", "}", "ds    =    new   Test (  )  ;", "ds . setUrl ( jdbcUrl )  ;", "ds . setUsername ( uname )  ;", "ds . setPassword ( pwd )  ;", "ds . setConnectionProperties ( connProps )  ;", "Connection   actualCon    =    ds . getConnection (  )  ;", "assertTrue (  ( actualCon    =  =     ( connection )  )  )  ;", "assertTrue ( ds . getUrl (  )  . equals ( jdbcUrl )  )  ;", "assertTrue ( ds . getPassword (  )  . equals ( pwd )  )  ;", "assertTrue ( ds . getUsername (  )  . equals ( uname )  )  ;", "}", "METHOD_END"], "methodName": ["testUsageWithConnectionPropertiesAndUserCredentials"], "fileName": "org.springframework.jdbc.datasource.DriverManagerDataSourceTests"}, {"methodBody": ["METHOD_START", "{", "Integer   isolationLevelToUse    =    TransactionSynchronizationManager . getCurrentTransactionIsolationLevel (  )  ;", "if    ( isolationLevelToUse    =  =    null )     {", "isolationLevelToUse    =    getIsolationLevel (  )  ;", "}", "return   isolationLevelToUse ;", "}", "METHOD_END"], "methodName": ["getCurrentIsolationLevel"], "fileName": "org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "boolean   txReadOnly    =    TransactionSynchronizationManager . isCurrentTransactionReadOnly (  )  ;", "return   txReadOnly    ?    Boolean . TRUE    :    null ;", "}", "METHOD_END"], "methodName": ["getCurrentReadOnlyFlag"], "fileName": "org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . isolationLevel ;", "}", "METHOD_END"], "methodName": ["getIsolationLevel"], "fileName": "org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( IsolationLevelDataSourceAdapter . constants . getValues ( PREFIX _ ISOLATION )  . contains ( isolationLevel )  )  )     {", "throw   new   IllegalArgumentException (  \" Only   values   of   isolation   constants   allowed \"  )  ;", "}", "this . isolationLevel    =     ( isolationLevel    !  =     ( TransactionDefinition . ISOLATION _ DEFAULT )  )     ?    isolationLevel    :    null ;", "}", "METHOD_END"], "methodName": ["setIsolationLevel"], "fileName": "org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( constantName . startsWith ( PREFIX _ ISOLATION )  )  )     {", "throw   new   IllegalArgumentException (  \" Only   isolation   constants   allowed \"  )  ;", "}", "setIsolationLevel (  . constants . asNumber ( constantName )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setIsolationLevelName"], "fileName": "org.springframework.jdbc.datasource.IsolationLevelDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . connectionHolder )     !  =    null )  ,     \" No   ConnectionHolder   available \"  )  ;", "return   this . connectionHolder ;", "}", "METHOD_END"], "methodName": ["getConnectionHolder"], "fileName": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isSavepointAllowed (  )  )  )     {", "throw   new   NestedNotSupportedException (  \"    manager   does   not   allow   nested   transactions \"  )  ;", "}", "if    (  !  ( hasConnectionHolder (  )  )  )     {", "throw   new   UsageException (  \" Cannot   create   nested   transaction   when   not   exposing   a   JDBC   transaction \"  )  ;", "}", "return   getConnectionHolder (  )  ;", "}", "METHOD_END"], "methodName": ["getConnectionHolderForSavepoint"], "fileName": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . previousIsolationLevel ;", "}", "METHOD_END"], "methodName": ["getPreviousIsolationLevel"], "fileName": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport"}, {"methodBody": ["METHOD_START", "{", "return    ( this . connectionHolder )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasConnectionHolder"], "fileName": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . savepointAllowed ;", "}", "METHOD_END"], "methodName": ["isSavepointAllowed"], "fileName": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport"}, {"methodBody": ["METHOD_START", "{", "this . connectionHolder    =    connectionHolder ;", "}", "METHOD_END"], "methodName": ["setConnectionHolder"], "fileName": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport"}, {"methodBody": ["METHOD_START", "{", "this . previousIsolationLevel    =    previousIsolationLevel ;", "}", "METHOD_END"], "methodName": ["setPreviousIsolationLevel"], "fileName": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport"}, {"methodBody": ["METHOD_START", "{", "this . savepointAllowed    =    savepointAllowed ;", "}", "METHOD_END"], "methodName": ["setSavepointAllowed"], "fileName": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . defaultAutoCommit )     =  =    null )     {", "this . defaultAutoCommit    =    con . getAutoCommit (  )  ;", "}", "if    (  ( this . defaultTransaIsolation )     =  =    null )     {", "this . defaultTransaIsolation    =    con . getTransaIsolation (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkDefaultConnectionProperties"], "fileName": "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultAutoCommit ;", "}", "METHOD_END"], "methodName": ["defaultAutoCommit"], "fileName": "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultTransactionIsolation ;", "}", "METHOD_END"], "methodName": ["defaultTransactionIsolation"], "fileName": "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"}, {"methodBody": ["METHOD_START", "{", "this . defaultAutoCommit    =    defaultAutoCommit ;", "}", "METHOD_END"], "methodName": ["setDefaultAutoCommit"], "fileName": "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"}, {"methodBody": ["METHOD_START", "{", "this . defaultTransactionIsolation    =    defaultTransactionIsolation ;", "}", "METHOD_END"], "methodName": ["setDefaultTransactionIsolation"], "fileName": "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"}, {"methodBody": ["METHOD_START", "{", "setDefaultTransactionIsolation ( LazyConnectionDataSourceProxy . constants . asNumber ( constantName )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultTransactionIsolationName"], "fileName": "org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy"}, {"methodBody": ["METHOD_START", "{", "return   this . driver ;", "}", "METHOD_END"], "methodName": ["getDriver"], "fileName": "org.springframework.jdbc.datasource.SimpleDriverDataSource"}, {"methodBody": ["METHOD_START", "{", "this . driver    =    driver ;", "}", "METHOD_END"], "methodName": ["setDriver"], "fileName": "org.springframework.jdbc.datasource.SimpleDriverDataSource"}, {"methodBody": ["METHOD_START", "{", "this . driver    =    BeanUtils . instantiateClass ( driverClass )  ;", "}", "METHOD_END"], "methodName": ["setDriverClass"], "fileName": "org.springframework.jdbc.datasource.SimpleDriverDataSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . target )     !  =    null )     {", "try    {", "this . target . close (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . warn (  \" Could   not   close   shared   JDBC    \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeConnection"], "fileName": "org.springframework.jdbc.datasource.SingleConnectionDataSource"}, {"methodBody": ["METHOD_START", "{", "return   this . autoCommit ;", "}", "METHOD_END"], "methodName": ["getAutoCommitValue"], "fileName": "org.springframework.jdbc.datasource.SingleConnectionDataSource"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Connection )     ( Proxy . newProxyInstance ( ConnectionProxy . class . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    ConnectionProxy . class    }  ,    new   SingleConnectionDataSource . CloseSuppressingInvocationHandler ( target )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCloseSuppressingConnectionProxy"], "fileName": "org.springframework.jdbc.datasource.SingleConnectionDataSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getUrl (  )  )     =  =    null )     {", "throw   new   IllegalStateException (  \"  ' url '    property   is   required   for   lazily   initializing   a   Connection \"  )  ;", "}", "synchronized ( this . connectionMonitor )     {", "clos (  )  ;", "this . target    =    getConnectionFromDriver ( getUsername (  )  ,    getPassword (  )  )  ;", "prepar ( this . target )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Established   shared   JDBC   Connection :     \"     +     ( this . target )  )  )  ;", "}", "this . connection    =     ( isSuppressClose (  )  )     ?    getCloseSuppressingConnectionProxy ( this . target )     :    this . target ;", "}", "}", "METHOD_END"], "methodName": ["initConnection"], "fileName": "org.springframework.jdbc.datasource.SingleConnectionDataSource"}, {"methodBody": ["METHOD_START", "{", "return   this . suppressClose ;", "}", "METHOD_END"], "methodName": ["isSuppressClose"], "fileName": "org.springframework.jdbc.datasource.SingleConnectionDataSource"}, {"methodBody": ["METHOD_START", "{", "Boolean   autoCommit    =    getAutoCommitValue (  )  ;", "if    (  ( autoCommit    !  =    null )     &  &     (  ( con . getAutoCommit (  )  )     !  =    autoCommit )  )     {", "con . setAutoCommit ( autoCommit )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareConnection"], "fileName": "org.springframework.jdbc.datasource.SingleConnectionDataSource"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . connectionMonitor )     {", "clos (  )  ;", "this . target    =    null ;", "this . connection    =    null ;", "}", "}", "METHOD_END"], "methodName": ["resetConnection"], "fileName": "org.springframework.jdbc.datasource.SingleConnectionDataSource"}, {"methodBody": ["METHOD_START", "{", "this . autoCommit    =    autoCommit ;", "}", "METHOD_END"], "methodName": ["setAutoCommit"], "fileName": "org.springframework.jdbc.datasource.SingleConnectionDataSource"}, {"methodBody": ["METHOD_START", "{", "this . suppressClose    =    suppressClose ;", "}", "METHOD_END"], "methodName": ["setSuppressClose"], "fileName": "org.springframework.jdbc.datasource.SingleConnectionDataSource"}, {"methodBody": ["METHOD_START", "{", "this . target    =    target ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "org.springframework.jdbc.datasource.TestDataSourceWrapper"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Connection )     ( Proxy . newProxyInstance ( ConnectionProxy . class . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    ConnectionProxy . class    }  ,    new   TransactionAwareDataSourceProxy . TransactionAwareInvocationHandler ( targetDataSource )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTransactionAwareConnectionProxy"], "fileName": "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy"}, {"methodBody": ["METHOD_START", "{", "this . reobtainTransactionalConnections    =    reobtainTransactionalConnections ;", "}", "METHOD_END"], "methodName": ["setReobtainTransactionalConnections"], "fileName": "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( TransactionSynchronizationManager . isSynchronizationActive (  )  )  )     |  |     (  !  ( this . reobtainTransactionalConnections )  )  ;", "}", "METHOD_END"], "methodName": ["shouldObtainFixedConnection"], "fileName": "org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( getTargetDataSource (  )  )     !  =    null )  ,     \"  ' targetDataSource '    is   required \"  )  ;", "if    ( StringUtils . hasLength ( username )  )     {", "return   getTargetDataSource (  )  . getConnection ( username ,    password )  ;", "} else    {", "return   getTargetDataSource (  )  . getConnection (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doGetConnection"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "this . threadBoundCredentials . remove (  )  ;", "}", "METHOD_END"], "methodName": ["removeCredentialsFromCurrentThread"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "this . catalog    =    catalog ;", "}", "METHOD_END"], "methodName": ["setCatalog"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "this . threadBoundCredentials . set ( new   UserCredentialsDataSourceAdapter . JdbcUserCredentials ( username ,    password )  )  ;", "}", "METHOD_END"], "methodName": ["setCredentialsForCurrentThread"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "this . password    =    password ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "this . schema    =    schema ;", "}", "METHOD_END"], "methodName": ["setSchema"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "this . username    =    username ;", "}", "METHOD_END"], "methodName": ["setUsername"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "adapter    =    new    (  )  ;", "adapter . setTargetDataSource ( dataSource )  ;", "assertEquals ( connection ,    adapter . getConnection (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoCredentials"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapterTests"}, {"methodBody": ["METHOD_START", "{", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( dataSource . getConnection (  \" user \"  ,     \" pw \"  )  )  . willReturn ( connection )  ;", "adapter    =    new    (  )  ;", "adapter . setTargetDataSource ( dataSource )  ;", "adapter . setUsername (  \" user \"  )  ;", "adapter . setPassword (  \" pw \"  )  ;", "assertEquals ( connection ,    adapter . getConnection (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticCredentials"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapterTests"}, {"methodBody": ["METHOD_START", "{", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( dataSource . getConnection (  \" user \"  ,     \" pw \"  )  )  . willReturn ( connection )  ;", "adapter    =    new    (  )  ;", "adapter . setTargetDataSource ( dataSource )  ;", "adapter . setCredentialsForCurrentThread (  \" user \"  ,     \" pw \"  )  ;", "try    {", "assertEquals ( connection ,    adapter . getConnection (  )  )  ;", "}    finally    {", "adapter . removeCredentialsFromCurrentThread (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testThreadBoundCredentials"], "fileName": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapterTests"}, {"methodBody": ["METHOD_START", "{", "Object   connSpec    =    ReflectionUtils . invokeJdbcMethod ( this . newJdbcConnSpecMethod ,    null )  ;", "Assert . state (  ( connSpec    !  =    null )  ,     \" No   JDBCConnectionSpec \"  )  ;", "if    ( isolationLevel    !  =    null )     {", "ReflectionUtils . invokeJdbcMethod ( this . setTransactionIsolationMethod ,    connSpec ,    isolationLevel )  ;", "}", "if    ( readOnlyFlag    !  =    null )     {", "ReflectionUtils . invokeJdbcMethod ( this . setReadOnlyMethod ,    connSpec ,    readOnlyFlag )  ;", "}", "if    ( StUtils . hasLength ( username )  )     {", "ReflectionUtils . invokeJdbcMethod ( this . setUserNameMethod ,    connSpec ,    username )  ;", "ReflectionUtils . invokeJdbcMethod ( this . setPasswordMethod ,    connSpec ,    password )  ;", "}", "return   connSpec ;", "}", "METHOD_END"], "methodName": ["createConnectionSpec"], "fileName": "org.springframework.jdbc.datasource.WebSphereDataSourceAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( DerbyEmbeddedDatabaseConfigurer . instance )     =  =    null )     {", "System . setProperty (  \" derby . stream . error . method \"  ,     (  ( OutputStreamFactory . class . getName (  )  )     +     \"  . getNoopOutputStream \"  )  )  ;", "DerbyEmbeddedDatabaseConfigurer . instance    =    new   DerbyEmbeddedDatabaseConfigurer (  )  ;", "}", "return   DerbyEmbeddedDatabaseConfigurer . instance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.jdbc.datasource.embedded.DerbyEmbeddedDatabaseConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   addScripts (  \" schema . sql \"  ,     \" data . sql \"  )  ;", "}", "METHOD_END"], "methodName": ["addDefaultScripts"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator . addScript ( this . resourceLoader . getResource ( script )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addScript"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( String   script    :    scripts )     {", "addScript ( script )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addScripts"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "return   this . databaseFactory . getDatabase (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator . setContinueOnError ( flag )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["continueOnError"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databaseFactory . setGenerateUniqueDatabaseName ( flag )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["generateUniqueName"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator . setIgnoreFailedDrops ( flag )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["ignoreFailedDrops"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator . setBlockCommentEndDelimiter ( blockCommentEndDelimiter )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setBlockCommentEndDelimiter"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator . setBlockCommentStartDelimiter ( blockCommentStartDelimiter )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setBlockCommentStartDelimiter"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator . setCommentPrefix ( commentPrefix )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCommentPrefix"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( dataSourceFactory ,     \" DataSourceFactory   is   required \"  )  ;", "this . dFactory . setDataSourceFactory ( dataSourceFactory )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDataSourceFactory"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databaseFactory . setDatabaseName ( databaseName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator . setSqlScriptEncoding ( scriptEncoding )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setScriptEncoding"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator . setSeparator ( separator )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSeparator"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "this . databaseFactory . setDatabaseType ( databaseType )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder"}, {"methodBody": ["METHOD_START", "{", "doTwice ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "EmbeddedDatabase   db    =    new    (  )  . addDefaultScripts (  )  . build (  )  ;", "assertDatabaseCreatedAndShutdown ( db )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addDefaultScripts"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "doTwice ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "db    =    builder . addScript (  \" db - schema . sql \"  )  . addScript (  \" db - test - data . sql \"  )  . build (  )  ;", "assertDatabaseCreatedAndShutdown ( db )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addScript"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "new   EmbeddedDatabaseBuilder (  )  . addScript (  \" bogus . sql \"  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["addScriptWithBogusFileName"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "doTwice ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "db    =    builder . addScripts (  \" db - schema . sql \"  ,     \" db - test - data . sql \"  )  . build (  )  ;", "assertDatabaseCreatedAndShutdown ( db )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addScripts"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "doTwice ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "db    =    builder . addScripts (  \" db - schema - block - comments . sql \"  ,     \" db - test - data . sql \"  )  . setBlockCommentStartDelimiter (  \"  {  *  \"  )  . setBlockCommentEndDelimiter (  \"  *  }  \"  )  . build (  )  ;", "assertDatabaseCreatedAndShutdown ( db )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addScriptsWithCustomBlockComments"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "doTwice ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "db    =    builder . addScripts (  \" db - schema - custom - comments . sql \"  ,     \" db - test - data . sql \"  )  . setCommentPrefix (  \"  ~  \"  )  . build (  )  ;", "assertDatabaseCreatedAndShutdown ( db )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addScriptsWithCustomCommentPrefix"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "doTwice ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "db    =    builder . addScripts (  \" db - schema - comments . sql \"  ,     \" db - test - data . sql \"  )  . build (  )  ;", "assertDatabaseCreatedAndShutdown ( db )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addScriptsWithDefaultCommentPrefix"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "assertNumRowsInTestTable ( new   JdbcTemplate ( db )  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["assertDatabaseCreated"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "assertDatabaseCreated ( db )  ;", "db . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["assertDatabaseCreatedAndShutdown"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( count ,    template . queryForObject (  \" select   count (  *  )    from   T _ TEST \"  ,    Integer . class )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNumRowsInTestTable"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "EmbeddedDatabase   db 1     =    new   EmbeddedDatabaseBuilder ( new   ClassRelativeResourceLoader ( getClass (  )  )  )  . addScripts (  \" db - schema - without - dropping . sql \"  ,     \" db - test - data . sql \"  )  . generateUniqueName ( true )  . build (  )  ;", "JdbcTemplate   template 1     =    new   JdbcTemplate ( db 1  )  ;", "assertNumRowsInTestTable ( template 1  ,     1  )  ;", "template 1  . update (  \" insert   into   T _ TEST    ( NAME )    values    (  ' Sam '  )  \"  )  ;", "assertNumRowsInTestTable ( template 1  ,     2  )  ;", "EmbeddedDatabase   db 2     =    new   EmbeddedDatabaseBuilder ( new   ClassRelativeResourceLoader ( getClass (  )  )  )  . addScripts (  \" db - schema - without - dropping . sql \"  ,     \" db - test - data . sql \"  )  . generateUniqueName ( true )  . build (  )  ;", "assertDatabaseCreated ( db 2  )  ;", "db 1  . shutdown (  )  ;", "db 2  . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["createSameSchemaTwiceWithGeneratedUniqueDbNames"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "EmbeddedDatabase   db 1     =    new   EmbeddedDatabaseBuilder ( new   ClassRelativeResourceLoader ( getClass (  )  )  )  . addScripts (  \" db - schema - without - dropping . sql \"  )  . build (  )  ;", "try    {", "new   EmbeddedDatabaseBuilder ( new   ClassRelativeResourceLoader ( getClass (  )  )  )  . addScripts (  \" db - schema - without - dropping . sql \"  )  . build (  )  ;", "fail (  \" Should   have   thrown   a   ScriptStatementFailedException \"  )  ;", "}    catch    ( ScriptStatementFailedException   e )     {", "}    finally    {", "db 1  . shutdown (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createSameSchemaTwiceWithoutUniqueDbNames"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "test . run (  )  ;", "test . run (  )  ;", "}", "METHOD_END"], "methodName": ["doTwice"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "doTwice ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "db    =    builder . setType ( Type . DERBY )  . ignoreFailedDrops ( true )  . addScripts (  \" db - schema - derby - with - drop . sql \"  ,     \" db - test - data . sql \"  )  . build (  )  ;", "assertDatabaseCreatedAndShutdown ( db )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setTypeToDerbyAndIgnoreFailedDrops"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "doTwice ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "db    =    builder . setType ( Type . H 2  )  . addScripts (  \" db - schema . sql \"  ,     \" db - test - data . sql \"  )  . build (  )  ;", "assertDatabaseCreatedAndShutdown ( db )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setTypeToH2"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( type ,     \" EmbeddedDatabaseType   is   required \"  )  ;", "try    {", "switch    ( type )     {", "case   HSQL    :", "return   Hsql . getInstance (  )  ;", "case   H 2     :", "return   H 2  . getInstance (  )  ;", "case   DERBY    :", "return   Derby . getInstance (  )  ;", "default    :", "throw   new   UnsupportedOperationException (  (  (  \" Embedded   database   type    [  \"     +    type )     +     \"  ]    is   not   supported \"  )  )  ;", "}", "}    catch    ( ClassNotFoundException    |    NoClassDefFoundError   ex )     {", "throw   new   IllegalStateException (  (  (  \" Driver   for   test   database   type    [  \"     +    type )     +     \"  ]    is   not   available \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getConfigurer"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseConfigurerFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . dataSource ;", "}", "METHOD_END"], "methodName": ["getDataSource"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . dataSource )     =  =    null )     {", "initDatabase (  )  ;", "}", "return   new    . EmbeddedDataSourceProxy ( this . dataSource )  ;", "}", "METHOD_END"], "methodName": ["getDatabase"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( this . generateUniqueDatabaseName )     {", "setDatabaseName ( UUID . randomUUID (  )  . toString (  )  )  ;", "}", "if    (  ( this . databaseConfigurer )     =  =    null )     {", "this . databaseConfigurer    =    EmbeddedDatabaseConfigurerFactory . getConfigurer ( EmbeddedDatabaseType . HSQL )  ;", "}", "this . databaseConfigurer . configureConnectionProperties ( this . dataSourceFactory . getConnectionProperties (  )  ,    this . databaseName )  ;", "this . dataSource    =    this . dataSourceFactory . getDataSource (  )  ;", "if    (  . logger . isInfoEnabled (  )  )     {", "if    (  ( this . dataSource )    instanceof   SimpleDriverDataSource )     {", "SimpleDriverDataSource   simpleDriverDataSource    =     (  ( SimpleDriverDataSource )     ( this . dataSource )  )  ;", ". logger . info ( String . format (  \" Starting   embedded   database :    url =  '  % s '  ,    username =  '  % s '  \"  ,    simpleDriverDataSource . getUrl (  )  ,    simpleDriverDataSource . getUsername (  )  )  )  ;", "} else    {", ". logger . info ( String . format (  \" Starting   embedded   database    '  % s '  \"  ,    this . databaseName )  )  ;", "}", "}", "if    (  ( this . databasePopulator )     !  =    null )     {", "try    {", "DatabasePopulatorUtils . execute ( this . databasePopulator ,    this . dataSource )  ;", "}    catch    ( RuntimeException   ex )     {", "shutdownDatabase (  )  ;", "throw   ex ;", "}", "}", "}", "METHOD_END"], "methodName": ["initDatabase"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( dataSourceFactory ,     \" DataSourceFactory   is   required \"  )  ;", "this . dataSourceFactory    =    dataSourceFactory ;", "}", "METHOD_END"], "methodName": ["setDataSourceFactory"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "this . databaseConfigurer    =    configurer ;", "}", "METHOD_END"], "methodName": ["setDatabaseConfigurer"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( databaseName ,     \" Database   name   is   required \"  )  ;", "this . databaseName    =    databaseName ;", "}", "METHOD_END"], "methodName": ["setDatabaseName"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator    =    populator ;", "}", "METHOD_END"], "methodName": ["setDatabasePopulator"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "this . databaseConfigurer    =    EmbeddedDatabaseConfigurerFactory . getConfigurer ( type )  ;", "}", "METHOD_END"], "methodName": ["setDatabaseType"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "this . generateUniqueDatabaseName    =    generateUniqueDatabaseName ;", "}", "METHOD_END"], "methodName": ["setGenerateUniqueDatabaseName"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . dataSource )     !  =    null )     {", "if    (  . logger . isInfoEnabled (  )  )     {", "if    (  ( this . dataSource )    instanceof   SimpleDriverDataSource )     {", ". logger . info ( String . format (  \" Shutting   down   embedded   database :    url =  '  % s '  \"  ,     (  ( SimpleDriverDataSource )     ( this . dataSource )  )  . getUrl (  )  )  )  ;", "} else    {", ". logger . info ( String . format (  \" Shutting   down   embedded   database    '  % s '  \"  ,    this . databaseName )  )  ;", "}", "}", "if    (  ( this . databaseConfigurer )     !  =    null )     {", "this . databaseConfigurer . shutdown ( this . dataSource ,    this . databaseName )  ;", "}", "this . dataSource    =    null ;", "}", "}", "METHOD_END"], "methodName": ["shutdownDatabase"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory"}, {"methodBody": ["METHOD_START", "{", "this . databaseCleaner    =    databaseCleaner ;", "}", "METHOD_END"], "methodName": ["setDatabaseCleaner"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   resourceLoader . getResource ( path )  ;", "}", "METHOD_END"], "methodName": ["resource"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "EmbeddedDatabaseFactoryBean   bean    =    new   EmbeddedDatabaseFactoryBean (  )  ;", "ResourceDatabasePopulator   populator    =    new   ResourceDatabasePopulator ( resource (  \" db - schema . sql \"  )  ,    resource (  \" db - test - data . sql \"  )  )  ;", "bean . setDatabasePopulator ( populator )  ;", "bean . afterPropertiesSet (  )  ;", "DataSource   ds    =    bean . getObject (  )  ;", "JdbcTemplate   template    =    new   JdbcTemplate ( ds )  ;", "assertEquals (  \" Keith \"  ,    template . queryForObject (  \" select   NAME   from   T _ TEST \"  ,    String . class )  )  ;", "bean . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryBeanLifecycle"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "EmbeddedDatabaseFactoryTests . StubDatabasePopulator   populator    =    new   EmbeddedDatabaseFactoryTests . StubDatabasePopulator (  )  ;", "factory . setDatabasePopulator ( populator )  ;", "EmbeddedDatabase   db    =    factory . getDatabase (  )  ;", "assertTrue ( populator . populateCalled )  ;", "db . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["testGetDataSource"], "fileName": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactoryTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( H 2 EmbeddedDatabaseConfigurer . instance )     =  =    null )     {", "H 2 EmbeddedDatabaseConfigurer . instance    =    new   H 2 EmbeddedDatabaseConfigurer (  (  ( Class <  ?    extends   Driver >  )     ( ClassUtils . forName (  \" Driver \"  ,    H 2 EmbeddedDatabaseConfigurer . class . getClassLoader (  )  )  )  )  )  ;", "}", "return   H 2 EmbeddedDatabaseConfigurer . instance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.jdbc.datasource.embedded.H2EmbeddedDatabaseConfigurer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( HsqlEmbeddedDatabaseConfigurer . instance )     =  =    null )     {", "HsqlEmbeddedDatabaseConfigurer . instance    =    new   HsqlEmbeddedDatabaseConfigurer (  (  ( Class <  ?    extends   Driver >  )     ( ClassUtils . forName (  \" jdbcDriver \"  ,    HsqlEmbeddedDatabaseConfigurer . class . getClassLoader (  )  )  )  )  )  ;", "}", "return   HsqlEmbeddedDatabaseConfigurer . instance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.jdbc.datasource.embedded.HsqlEmbeddedDatabaseConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   new   OutputStream (  )     {", "@ Override", "public   void   write ( int   b )    throws   IOException    {", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getNoopOutputStream"], "fileName": "org.springframework.jdbc.datasource.embedded.OutputStreamFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( String   lastName    :    lastNames )     {", "assertThat (  (  (  \" Did   not   find   user   with   last   name    [  \"     +    lastName )     +     \"  ]  .  \"  )  ,    jdbcTemplate . queryForObject (  \" select   count (  0  )    from   users   where   last _ name    =     ?  \"  ,    Integer . class ,    lastName )  ,    equalTo (  1  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertUsersDatabaseCreated"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabaseInitializationTests"}, {"methodBody": ["METHOD_START", "{", "return   resource (  \" db - schema . sql \"  )  ;", "}", "METHOD_END"], "methodName": ["defaultSchema"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabaseInitializationTests"}, {"methodBody": ["METHOD_START", "{", "return   resourceLoader . getResource ( path )  ;", "}", "METHOD_END"], "methodName": ["resource"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabaseInitializationTests"}, {"methodBody": ["METHOD_START", "{", "db    =    new   EmbeddedDatabaseBuilder (  )  . setType ( getEmbeddedDatabaseType (  )  )  . build (  )  ;", "jdbcTemplate    =    new   JdbcTemplate ( db )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabaseInitializationTests"}, {"methodBody": ["METHOD_START", "{", "if    ( TransactionSynchronizationManager . isSynchronizationActive (  )  )     {", "TransactionSynchronizationManager . clear (  )  ;", "TransactionSynchronizationManager . unbindResource ( db )  ;", "}", "db . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["shutDown"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabaseInitializationTests"}, {"methodBody": ["METHOD_START", "{", "return   resource (  \" users - schema . sql \"  )  ;", "}", "METHOD_END"], "methodName": ["usersSchema"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabaseInitializationTests"}, {"methodBody": ["METHOD_START", "{", "assertTestDatabaseCreated (  \" Keith \"  )  ;", "}", "METHOD_END"], "methodName": ["assertTestDatabaseCreated"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( name ,    jdbcTemplate . queryForObject (  \" select   NAME   from   T _ TEST \"  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["assertTestDatabaseCreated"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "final   ResourceDatabasePopulator   populator    =    new   ResourceDatabasePopulator ( usersSchema (  )  ,    resource (  \" users - data - with - comments . sql \"  )  )  ;", "DatabasePopulatorUtils . execute ( populator ,    db )  ;", "assertUsersDatabaseCreated (  \" Brannen \"  ,     \" Hoeller \"  )  ;", "}", "METHOD_END"], "methodName": ["constructorWithMultipleScriptResources"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( defaultSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - huge . sql \"  )  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "}", "METHOD_END"], "methodName": ["executesHugeScriptInReasonableTime"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( usersSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" users - data - with - comments . sql \"  )  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertUsersDatabaseCreated (  \" Brannen \"  ,     \" Hoeller \"  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithCommentsWithinStatements"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( usersSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" users - data . sql \"  )  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertUsersDatabaseCreated (  \" Brannen \"  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithEolBetweenTokens"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( defaultSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - multiple . sql \"  )  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Keith '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Dave '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithMultipleStatements"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( defaultSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - endings . sql \"  )  )  ;", "databasePopulator . setSeparator (  \"  @  @  \"  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Keith '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Dave '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithMultipleStatementsAndLongSeparator"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( defaultSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - multi - newline . sql \"  )  )  ;", "databasePopulator . setSeparator (  \"  \\ n \\ n \"  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Keith '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Dave '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithMultipleStatementsAndMultipleNewlineSeparator"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( defaultSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - newline . sql \"  )  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Keith '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Dave '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithMultipleStatementsAndNewlineSeparator"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( defaultSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - whitespace . sql \"  )  )  ;", "databasePopulator . setSeparator (  \"  /  \\ n \"  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Keith '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Dave '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithMultipleStatementsAndWhitespaceSeparator"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( defaultSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - mysql - escaped - literal . sql \"  )  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertTestDatabaseCreated (  \"  \\  \\  $ Keith \\  \\  $  \"  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithMySqlEscapedLiteral"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( defaultSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - select . sql \"  )  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Keith '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "assertThat ( jdbcTemplate . queryForObject (  \" select   COUNT ( NAME )    from   T _ TEST   where   NAME =  ' Dave '  \"  ,    Integer . class )  ,    equalTo (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithSelectStatements"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( resource (  \" db - schema - failed - drop - comments . sql \"  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data . sql \"  )  )  ;", "databasePopulator . setIgnoreFailedDrops ( true )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertTestDatabaseCreated (  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithSingleLineCommentsAndFailedDrop"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( defaultSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - escaped - literal . sql \"  )  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertTestDatabaseCreated (  \"  ' Keith '  \"  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithStandardEscapedLiteral"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . setSeparator ( ScriptUtils . EOF _ STATEMENT _ SEPARATOR )  ;", "databasePopulator . addScript ( resource (  \" drop - users - schema . sql \"  )  )  ;", "databasePopulator . addScript ( resource (  \" users - schema - without - separator . sql \"  )  )  ;", "databasePopulator . addScript ( resource (  \" users - data - without - separator . sql \"  )  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "assertUsersDatabaseCreated (  \" Brannen \"  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithoutStatementSeparator"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "TransactionSynchronizationManager . initSynchronization (  )  ;", "Connection   connection    =    DataSourceUtils . getConnection ( db )  ;", "populator    =    mock (  . class )  ;", "Utils . execute ( populator ,    db )  ;", "verify ( populator )  . populate ( connection )  ;", "}", "METHOD_END"], "methodName": ["usesBoundConnectionIfAvailable"], "fileName": "org.springframework.jdbc.datasource.init.AbstractDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "this . populators . addAll ( Arrays . asList ( populators )  )  ;", "}", "METHOD_END"], "methodName": ["addPopulators"], "fileName": "org.springframework.jdbc.datasource.init.CompositeDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "this . populators . clear (  )  ;", "this . populators . addAll ( Arrays . asList ( populators )  )  ;", "}", "METHOD_END"], "methodName": ["setPopulators"], "fileName": "org.springframework.jdbc.datasource.init.CompositeDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "CompositeDatabasePopulator   populator    =    new   CompositeDatabasePopulator (  )  ;", "populator . addPopulators ( mockedDatabasePopulator 1  ,    mockedDatabasePopulator 2  )  ;", "populator . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 1  ,    times (  1  )  )  . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 2  ,    times (  1  )  )  . populate ( mockedConnection )  ;", "}", "METHOD_END"], "methodName": ["addPopulators"], "fileName": "org.springframework.jdbc.datasource.init.CompositeDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "Set < DatabasePopulator >    populators    =    new   LinkedHashSet <  >  (  )  ;", "populators . add ( mockedDatabasePopulator 1  )  ;", "populators . add ( mockedDatabasePopulator 2  )  ;", "populator    =    new    ( populators )  ;", "populator . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 1  ,    times (  1  )  )  . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 2  ,    times (  1  )  )  . populate ( mockedConnection )  ;", "}", "METHOD_END"], "methodName": ["constructWithCollection"], "fileName": "org.springframework.jdbc.datasource.init.CompositeDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "CompositeDatabasePopulator   populator    =    new   CompositeDatabasePopulator ( mockedDatabasePopulator 1  ,    mockedDatabasePopulator 2  )  ;", "populator . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 1  ,    times (  1  )  )  . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 2  ,    times (  1  )  )  . populate ( mockedConnection )  ;", "}", "METHOD_END"], "methodName": ["constructWithVarargs"], "fileName": "org.springframework.jdbc.datasource.init.CompositeDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "CompositeDatabasePopulator   populator    =    new   CompositeDatabasePopulator (  )  ;", "populator . setPopulators ( mockedDatabasePopulator 1  )  ;", "populator . setPopulators ( mockedDatabasePopulator 2  )  ;", "populator . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 1  ,    times (  0  )  )  . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 2  ,    times (  1  )  )  . populate ( mockedConnection )  ;", "}", "METHOD_END"], "methodName": ["setPopulatorsForOverride"], "fileName": "org.springframework.jdbc.datasource.init.CompositeDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "CompositeDatabasePopulator   populator    =    new   CompositeDatabasePopulator (  )  ;", "populator . setPopulators ( mockedDatabasePopulator 1  ,    mockedDatabasePopulator 2  )  ;", "populator . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 1  ,    times (  1  )  )  . populate ( mockedConnection )  ;", "verify ( mockedDatabasePopulator 2  ,    times (  1  )  )  . populate ( mockedConnection )  ;", "}", "METHOD_END"], "methodName": ["setPopulatorsWithMultiple"], "fileName": "org.springframework.jdbc.datasource.init.CompositeDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . dataSource )     !  =    null )  ,     \" DataSource   must   be   set \"  )  ;", "if    (  ( this . enabled )     &  &     ( populator    !  =    null )  )     {", "DatabasePopulatorUtils . execute ( populator ,    this . dataSource )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.datasource.init.DataSourceInitializer"}, {"methodBody": ["METHOD_START", "{", "this . dataSource    =    dataSource ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.jdbc.datasource.init.DataSourceInitializer"}, {"methodBody": ["METHOD_START", "{", "this . databaseCleaner    =    databaseCleaner ;", "}", "METHOD_END"], "methodName": ["setDatabaseCleaner"], "fileName": "org.springframework.jdbc.datasource.init.DataSourceInitializer"}, {"methodBody": ["METHOD_START", "{", "this . databasePopulator    =    databasePopulator ;", "}", "METHOD_END"], "methodName": ["setDatabasePopulator"], "fileName": "org.springframework.jdbc.datasource.init.DataSourceInitializer"}, {"methodBody": ["METHOD_START", "{", "this . enabled    =    enabled ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "org.springframework.jdbc.datasource.init.DataSourceInitializer"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( populator ,     \" DatabasePopulator   must   not   be   null \"  )  ;", "Assert . notNull ( dataSource ,     \" DataSource   must   not   be   null \"  )  ;", "try    {", "Connection   connection    =    DataSourceUtils . getConnection ( dataSource )  ;", "try    {", "populator . populate ( connection )  ;", "}    finally    {", "DataSourceUtils . releaseConnection ( connection ,    dataSource )  ;", "}", "}    catch    ( Throwable   ex )     {", "if    ( ex   instanceof   ScriptException )     {", "throw    (  ( ScriptException )     ( ex )  )  ;", "}", "throw   new   UncategorizedScriptException (  \" Failed   to   execute   database   script \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.datasource.init.DatabasePopulatorUtils"}, {"methodBody": ["METHOD_START", "{", "return   EmbeddedDatabaseType . H 2  ;", "}", "METHOD_END"], "methodName": ["getEmbeddedDatabaseType"], "fileName": "org.springframework.jdbc.datasource.init.H2DatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "databasePopulator . addScript ( usersSchema (  )  )  ;", "databasePopulator . addScript ( resource (  \" db - test - data - h 2  - alias . sql \"  )  )  ;", "databasePopulator . setSeparator (  \"  \\ n \\ n \"  )  ;", "Utils . execute ( databasePopulator ,    db )  ;", "String   sql    =     \" select   REVERSE ( first _ name )    from   users   where   last _ name =  ' Brannen '  \"  ;", "assertThat ( jdbcTemplate . queryForObject ( sql ,    String . class )  ,    equalTo (  \" maS \"  )  )  ;", "}", "METHOD_END"], "methodName": ["scriptWithH2Alias"], "fileName": "org.springframework.jdbc.datasource.init.H2DatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "return   EmbeddedDatabaseType . HSQL ;", "}", "METHOD_END"], "methodName": ["getEmbeddedDatabaseType"], "fileName": "org.springframework.jdbc.datasource.init.HsqlDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( script ,     \" Script   must   not   be   null \"  )  ;", "this . scripts . add ( script )  ;", "}", "METHOD_END"], "methodName": ["addScript"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "assertContentsOfScriptArray ( scripts )  ;", "this . scripts . addAll ( Arrays . asList ( scripts )  )  ;", "}", "METHOD_END"], "methodName": ["addScripts"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( scripts ,     \" Scripts   array   must   not   be   null \"  )  ;", "Assert . noNullElements ( scripts ,     \" Scripts   array   must   not   contain   null   elements \"  )  ;", "}", "METHOD_END"], "methodName": ["assertContentsOfScriptArray"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "DatabasePopulatorUtils . execute ( this ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( blockCommentEndDelimiter ,     \" BlockCommentEndDelimiter   must   not   be   null   or   empty \"  )  ;", "this . blockCommentEndDelimiter    =    blockCommentEndDelimiter ;", "}", "METHOD_END"], "methodName": ["setBlockCommentEndDelimiter"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( blockCommentStartDelimiter ,     \" BlockCommentStartDelimiter   must   not   be   null   or   empty \"  )  ;", "this . blockCommentStartDelimiter    =    blockCommentStartDelimiter ;", "}", "METHOD_END"], "methodName": ["setBlockCommentStartDelimiter"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "this . commentPrefix    =    commentPrefix ;", "}", "METHOD_END"], "methodName": ["setCommentPrefix"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "this . continueOnError    =    continueOnError ;", "}", "METHOD_END"], "methodName": ["setContinueOnError"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "this . ignoreFailedDrops    =    ignoreFailedDrops ;", "}", "METHOD_END"], "methodName": ["setIgnoreFailedDrops"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "assertContentsOfScriptArray ( scripts )  ;", "this . scripts    =    new   ArrayList ( Arrays . asList ( scripts )  )  ;", "}", "METHOD_END"], "methodName": ["setScripts"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "this . separator    =    separator ;", "}", "METHOD_END"], "methodName": ["setSeparator"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "this . sqlScriptEncoding    =     ( StringUtils . hasText ( sqlScriptEncoding )  )     ?    sqlScriptEncoding    :    null ;", "}", "METHOD_END"], "methodName": ["setSqlScriptEncoding"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator"}, {"methodBody": ["METHOD_START", "{", "ResourceDatabasePopulator   databasePopulator    =    new   ResourceDatabasePopulator (  )  ;", "databasePopulator . addScripts (  (  ( Resource )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addScriptsWithNullResource"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceDatabasePopulator   databasePopulator    =    new   ResourceDatabasePopulator (  )  ;", "databasePopulator . addScripts (  (  ( Resource [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["addScriptsWithNullResourceArray"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceDatabasePopulator   databasePopulator    =    new   ResourceDatabasePopulator ( ResourceDatabasePopulatorTests . script 1  ,    ResourceDatabasePopulatorTests . script 2  )  ;", "assertEquals (  2  ,    databasePopulator . scripts . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["constructWithMultipleResources"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceDatabasePopulator   databasePopulator    =    new   ResourceDatabasePopulator ( ResourceDatabasePopulatorTests . script 1  ,    ResourceDatabasePopulatorTests . script 2  )  ;", "assertEquals (  2  ,    databasePopulator . scripts . size (  )  )  ;", "databasePopulator . addScript ( ResourceDatabasePopulatorTests . script 3  )  ;", "assertEquals (  3  ,    databasePopulator . scripts . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["constructWithMultipleResourcesAndThenAddScript"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "new   ResourceDatabasePopulator (  (  ( Resource )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["constructWithNullResource"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "new   ResourceDatabasePopulator (  (  ( Resource [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["constructWithNullResourceArray"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceDatabasePopulator   databasePopulator    =    new   ResourceDatabasePopulator ( ResourceDatabasePopulatorTests . script 1  )  ;", "assertEquals (  1  ,    databasePopulator . scripts . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["constructWithResource"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceDatabasePopulator   databasePopulator    =    new   ResourceDatabasePopulator (  )  ;", "assertEquals (  0  ,    databasePopulator . scripts . size (  )  )  ;", "databasePopulator . setScripts (  . script 1  ,     . script 2  )  ;", "assertEquals (  2  ,    databasePopulator . scripts . size (  )  )  ;", "databasePopulator . addScript (  . script 3  )  ;", "assertEquals (  3  ,    databasePopulator . scripts . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["setScriptsAndThenAddScript"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceDatabasePopulator   databasePopulator    =    new   ResourceDatabasePopulator (  )  ;", "databasePopulator . setScripts (  (  ( Resource )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["setScriptsWithNullResource"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceDatabasePopulator   databasePopulator    =    new   ResourceDatabasePopulator (  )  ;", "databasePopulator . setScripts (  (  ( Resource [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["setScriptsWithNullResourceArray"], "fileName": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulatorTests"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" Failed   to   parse   SQL   script   from   resource    [  % s ]  :     % s \"  ,     ( resource    =  =    null    ?     \"  < unknown >  \"     :    resource )  ,    message )  ;", "}", "METHOD_END"], "methodName": ["buildMessage"], "fileName": "org.springframework.jdbc.datasource.init.ScriptParseException"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" Failed   to   execute   SQL   script   statement    #  % s   of    % s :     % s \"  ,    stmtNumber ,    encodedResource ,    stmt )  ;", "}", "METHOD_END"], "methodName": ["buildErrorMessage"], "fileName": "org.springframework.jdbc.datasource.init.ScriptStatementFailedException"}, {"methodBody": ["METHOD_START", "{", "if    ( separator    =  =    null )     {", "return ;", "}", "String   trimmed    =    separator . trim (  )  ;", "if    (  ( trimmed . length (  )  )     =  =     ( separator . length (  )  )  )     {", "return ;", "}", "if    (  ( sBuilder . lastIndexOf ( trimmed )  )     =  =     (  ( sBuilder . length (  )  )     -     ( trimmed . length (  )  )  )  )     {", "sBuilder . append ( separator . substring ( trimmed . length (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["appendSeparatorToScriptIfNecessary"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "boolean   inLiteral    =    false ;", "for    ( int   i    =     0  ;    i    <     ( s . length (  )  )  ;    i +  +  )     {", "if    (  ( s . charAt ( i )  )     =  =     '  \\  '  '  )     {", "inLiteral    =     ! inLiteral ;", "}", "if    (  (  ! inLiteral )     &  &     ( s . startsWith ( delim ,    i )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["containsSqlScriptDelimiters"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "ScriptUtils . executeSqlScript ( connection ,    new   EncodedResource ( resource )  )  ;", "}", "METHOD_END"], "methodName": ["executeSqlScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "ScriptUtils . executeSqlScript ( connection ,    resource ,    false ,    false ,    ScriptUtils . DEFAULT _ COMMENT _ PREFIX ,    ScriptUtils . DEFAULT _ STATEMENT _ SEPARATOR ,    ScriptUtils . DEFAULT _ BLOCK _ COMMENT _ START _ DELIMITER ,    ScriptUtils . DEFAULT _ BLOCK _ COMMENT _ END _ DELIMITER )  ;", "}", "METHOD_END"], "methodName": ["executeSqlScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  \" Executing   SQL   script   from    \"     +    resource )  )  ;", "}", "long   startTime    =    System . currentTimeMillis (  )  ;", "String   script ;", "try    {", "script    =     . readScript ( resource ,    commentPrefix ,    separator )  ;", "}    catch    ( IOException   ex )     {", "throw   new   CannotReadScriptException ( resource ,    ex )  ;", "}", "if    ( separator    =  =    null )     {", "separator    =     . DEFAULT _ STATEMENT _ SEPARATOR ;", "}", "if    (  (  !  (  . EOF _ STATEMENT _ SEPARATOR . equals ( separator )  )  )     &  &     (  !  (  . containsSqlScriptDelimiters ( script ,    separator )  )  )  )     {", "separator    =     . FALLBACK _ STATEMENT _ SEPARATOR ;", "}", "List < String >    statements    =    new   LinkedList <  >  (  )  ;", ". splitSqlScript ( resource ,    script ,    separator ,    commentPrefix ,    blockCommentStartDelimiter ,    blockCommentEndDelimiter ,    statements )  ;", "int   stmtNumber    =     0  ;", "Statement   stmt    =    connection . createStatement (  )  ;", "try    {", "for    ( String   statement    :    statements )     {", "stmtNumber +  +  ;", "try    {", "stmt . execute ( statement )  ;", "int   rowsAffected    =    stmt . getUpdateCount (  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  ( rowsAffected    +     \"    returned   as   update   count   for   SQL :     \"  )     +    statement )  )  ;", "SQLWarning   warningToLog    =    stmt . getWarnings (  )  ;", "while    ( warningToLog    !  =    null )     {", ". logger . debug (  (  (  (  (  (  (  \" SQLWarning   ignored :    SQL   state    '  \"     +     ( warningToLog . getSQLState (  )  )  )     +     \"  '  ,    error   code    '  \"  )     +     ( warningToLog . getErrorCode (  )  )  )     +     \"  '  ,    message    [  \"  )     +     ( warningToLog . getMessage (  )  )  )     +     \"  ]  \"  )  )  ;", "warningToLog    =    warningToLog . getNextWarning (  )  ;", "}", "}", "}    catch    ( SQLException   ex )     {", "boolean   dropStatement    =    StringUtils . startsWithIgnoreCase ( statement . trim (  )  ,     \" drop \"  )  ;", "if    ( continueOnError    |  |     ( dropStatement    &  &    ignoreFailedDrops )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug ( ScriptStatementFailedException . buildErrorMessage ( statement ,    stmtNumber ,    resource )  ,    ex )  ;", "}", "} else    {", "throw   new   ScriptStatementFailedException ( statement ,    stmtNumber ,    resource ,    ex )  ;", "}", "}", "}", "}    finally    {", "try    {", "stmt . close (  )  ;", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Could   not   close   JDBC   Statement \"  ,    ex )  ;", "}", "}", "long   elapsedTime    =     ( System . currentTimeMillis (  )  )     -    startTime ;", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  (  (  (  \" Executed   SQL   script   from    \"     +    resource )     +     \"    in    \"  )     +    elapsedTime )     +     \"    ms .  \"  )  )  ;", "}", "}    catch    ( Exception   ex )     {", "if    ( ex   instanceof   ScriptException )     {", "throw    (  ( ScriptException )     ( ex )  )  ;", "}", "throw   new   UncategorizedScriptException (  (  (  \" Failed   to   execute   database   script   from   resource    [  \"     +    resource )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["executeSqlScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "String   currentStatement    =    lineNumberReader . readLine (  )  ;", "StringBuilder   scriptBuilder    =    new   StringBuilder (  )  ;", "while    ( currentStatement    !  =    null )     {", "if    (  ( commentPrefix    !  =    null )     &  &     (  !  ( currentStatement . startsWith ( commentPrefix )  )  )  )     {", "if    (  ( scriptBuilder . length (  )  )     >     0  )     {", "scriptBuilder . append (  '  \\ n '  )  ;", "}", "scriptBuilder . append ( currentStatement )  ;", "}", "currentStatement    =    lineNumberReader . readLine (  )  ;", "}", ". appendSeparatorToScriptIfNecessary ( scriptBuilder ,    separator )  ;", "return   scriptBuilder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["readScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "return   ScriptUtils . readScript ( resource ,    ScriptUtils . DEFAULT _ COMMENT _ PREFIX ,    ScriptUtils . DEFAULT _ STATEMENT _ SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["readScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "LineNumberReader   lnr    =    new   LineNumberReader ( resource . getReader (  )  )  ;", "try    {", "return    . readScript ( lnr ,    commentPrefix ,    separator )  ;", "}    finally    {", "lnr . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["readScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "ScriptUtils . splitSqlScript ( script ,    String . valueOf ( separator )  ,    statements )  ;", "}", "METHOD_END"], "methodName": ["splitSqlScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "ScriptUtils . splitSqlScript ( null ,    script ,    separator ,    ScriptUtils . DEFAULT _ COMMENT _ PREFIX ,    ScriptUtils . DEFAULT _ BLOCK _ COMMENT _ START _ DELIMITER ,    ScriptUtils . DEFAULT _ BLOCK _ COMMENT _ END _ DELIMITER ,    statements )  ;", "}", "METHOD_END"], "methodName": ["splitSqlScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( script ,     \"  ' script '    must   not   be   null   or   empty \"  )  ;", "Assert . notNull ( separator ,     \"  ' separator '    must   not   be   null \"  )  ;", "Assert . hasText ( commentPrefix ,     \"  ' commentPrefix '    must   not   be   null   or   empty \"  )  ;", "Assert . hasText ( blockCommentStartDelimiter ,     \"  ' blockCommentStartDelimiter '    must   not   be   null   or   empty \"  )  ;", "Assert . hasText ( blockCommentEndDelimiter ,     \"  ' blockCommentEndDelimiter '    must   not   be   null   or   empty \"  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "boolean   inSingleQuote    =    false ;", "boolean   inDoubleQuote    =    false ;", "boolean   inEscape    =    false ;", "for    ( int   i    =     0  ;    i    <     ( script . length (  )  )  ;    i +  +  )     {", "char   c    =    script . charAt ( i )  ;", "if    ( inEscape )     {", "inEscape    =    false ;", "sb . append ( c )  ;", "continue ;", "}", "if    ( c    =  =     '  \\  \\  '  )     {", "inEscape    =    true ;", "sb . append ( c )  ;", "continue ;", "}", "if    (  (  ! inDoubleQuote )     &  &     ( c    =  =     '  \\  '  '  )  )     {", "inSingleQuote    =     ! inSingleQuote ;", "} else", "if    (  (  ! inSingleQuote )     &  &     ( c    =  =     '  \"  '  )  )     {", "inDoubleQuote    =     ! inDoubleQuote ;", "}", "if    (  (  ! inSingleQuote )     &  &     (  ! inDoubleQuote )  )     {", "if    ( script . startsWith ( separator ,    i )  )     {", "if    (  ( sb . length (  )  )     >     0  )     {", "statements . add ( sb . toString (  )  )  ;", "sb    =    new   StringBuilder (  )  ;", "}", "i    +  =     ( separator . length (  )  )     -     1  ;", "continue ;", "} else", "if    ( script . startsWith ( commentPrefix ,    i )  )     {", "int   indexOfNextNewline    =    script . indexOf (  '  \\ n '  ,    i )  ;", "if    ( indexOfNextNewline    >    i )     {", "i    =    indexOfNextNewline ;", "continue ;", "} else    {", "break ;", "}", "} else", "if    ( script . startsWith ( blockCommentStartDelimiter ,    i )  )     {", "int   indexOfCommentEnd    =    script . indexOf ( blockCommentEndDelimiter ,    i )  ;", "if    ( indexOfCommentEnd    >    i )     {", "i    =     ( indexOfCommentEnd    +     ( blockCommentEndDelimiter . length (  )  )  )     -     1  ;", "continue ;", "} else    {", "throw   new   ScriptParseException (  (  \" Missing   block   comment   end   delimiter :     \"     +    blockCommentEndDelimiter )  ,    re )  ;", "}", "} else", "if    (  (  ( c    =  =     '     '  )     |  |     ( c    =  =     '  \\ n '  )  )     |  |     ( c    =  =     '  \\ t '  )  )     {", "if    (  (  ( sb . length (  )  )     >     0  )     &  &     (  ( sb . charAt (  (  ( sb . length (  )  )     -     1  )  )  )     !  =     '     '  )  )     {", "c    =     '     '  ;", "} else    {", "continue ;", "}", "}", "}", "sb . append ( c )  ;", "}", "if    ( StringUtils . hasText ( sb )  )     {", "statements . add ( sb . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["splitSqlScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtils"}, {"methodBody": ["METHOD_START", "{", "ScriptUtils . executeSqlScript ( db . getConnection (  )  ,    resource (  \" test - data - with - multi - line - comments . sql \"  )  )  ;", "assertUsersDatabaseCreated (  \" Hoeller \"  ,     \" Brannen \"  )  ;", "}", "METHOD_END"], "methodName": ["executeSqlScriptContainingMuliLineComments"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ScriptUtils . executeSqlScript ( db . getConnection (  )  ,    resource (  \" users - data - with - single - quotes - nested - in - double - quotes . sql \"  )  )  ;", "assertUsersDatabaseCreated (  \" Hoeller \"  ,     \" Brannen \"  )  ;", "}", "METHOD_END"], "methodName": ["executeSqlScriptContainingSingleQuotesNestedInsideDoubleQuotes"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "return   EmbeddedDatabaseType . HSQL ;", "}", "METHOD_END"], "methodName": ["getEmbeddedDatabaseType"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "ScriptUtils . executeSqlScript ( db . getConnection (  )  ,    usersSchema (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUpSchema"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( ScriptUtils . containsSqlScriptDelimiters (  \" select    1  \\ n   select    \\  '  ;  \\  '  \"  ,     \"  ;  \"  )  )  ;", "assertTrue ( ScriptUtils . containsSqlScriptDelimiters (  \" select    1  ;    select    2  \"  ,     \"  ;  \"  )  )  ;", "assertFalse ( ScriptUtils . containsSqlScriptDelimiters (  \" select    1  ;    select    \\  '  \\  \\ n \\ n \\  '  ;  \"  ,     \"  \\ n \"  )  )  ;", "assertTrue ( ScriptUtils . containsSqlScriptDelimiters (  \" select    1  \\ n   select    2  \"  ,     \"  \\ n \"  )  )  ;", "assertFalse ( ScriptUtils . containsSqlScriptDelimiters (  \" select    1  \\ n   select    2  \"  ,     \"  \\ n \\ n \"  )  )  ;", "assertTrue ( ScriptUtils . containsSqlScriptDelimiters (  \" select    1  \\ n \\ n   select    2  \"  ,     \"  \\ n \\ n \"  )  )  ;", "}", "METHOD_END"], "methodName": ["containsDelimiters"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "String   script    =    readScript (  \" test - data - with - comments . sql \"  )  ;", "List < String >    statements    =    new   ArrayList <  >  (  )  ;", ". splitSqlScript ( script ,     '  ;  '  ,    statements )  ;", "String   statement 1     =     \" insert   into   customer    ( id ,    name )    values    (  1  ,     ' Rod ;    Johnson '  )  ,     (  2  ,     ' Adrian   Collier '  )  \"  ;", "String   statement 2     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )    values    (  1  ,     '  2  0  0  8  -  0  1  -  0  2  '  ,     2  )  \"  ;", "String   statement 3     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )    values    (  1  ,     '  2  0  0  8  -  0  1  -  0  2  '  ,     2  )  \"  ;", "String   statement 4     =     \" INSERT   INTO   persons (    person _ id    ,    name )    VALUES (     1     ,     ' Name '     )  \"  ;", "assertEquals (  \" wrong   number   of   statements \"  ,     4  ,    statements . size (  )  )  ;", "assertEquals (  \" statement    1    not   split   correctly \"  ,    statement 1  ,    statements . get (  0  )  )  ;", "assertEquals (  \" statement    2    not   split   correctly \"  ,    statement 2  ,    statements . get (  1  )  )  ;", "assertEquals (  \" statement    3    not   split   correctly \"  ,    statement 3  ,    statements . get (  2  )  )  ;", "assertEquals (  \" statement    4    not   split   correctly \"  ,    statement 4  ,    statements . get (  3  )  )  ;", "}", "METHOD_END"], "methodName": ["readAndSplitScriptContainingComments"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "String   script    =    readScript (  \" test - data - with - comments - and - leading - tabs . sql \"  )  ;", "List < String >    statements    =    new   ArrayList <  >  (  )  ;", ". splitSqlScript ( script ,     '  ;  '  ,    statements )  ;", "String   statement 1     =     \" insert   into   customer    ( id ,    name )    values    (  1  ,     ' Sam   Brannen '  )  \"  ;", "String   statement 2     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )    values    (  1  ,     '  2  0  1  3  -  0  6  -  0  8  '  ,     1  )  \"  ;", "String   statement 3     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )    values    (  2  ,     '  2  0  1  3  -  0  6  -  0  8  '  ,     1  )  \"  ;", "assertEquals (  \" wrong   number   of   statements \"  ,     3  ,    statements . size (  )  )  ;", "assertEquals (  \" statement    1    not   split   correctly \"  ,    statement 1  ,    statements . get (  0  )  )  ;", "assertEquals (  \" statement    2    not   split   correctly \"  ,    statement 2  ,    statements . get (  1  )  )  ;", "assertEquals (  \" statement    3    not   split   correctly \"  ,    statement 3  ,    statements . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["readAndSplitScriptContainingCommentsWithLeadingTabs"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "String   script    =    readScript (  \" test - data - with - multi - line - comments . sql \"  )  ;", "List < String >    statements    =    new   ArrayList <  >  (  )  ;", ". splitSqlScript ( script ,     '  ;  '  ,    statements )  ;", "String   statement 1     =     \" INSERT   INTO   users ( first _ name ,    last _ name )    VALUES (  ' Juergen '  ,     ' Hoeller '  )  \"  ;", "String   statement 2     =     \" INSERT   INTO   users ( first _ name ,    last _ name )    VALUES (     ' Sam '     ,     ' Brannen '     )  \"  ;", "assertEquals (  \" wrong   number   of   statements \"  ,     2  ,    statements . size (  )  )  ;", "assertEquals (  \" statement    1    not   split   correctly \"  ,    statement 1  ,    statements . get (  0  )  )  ;", "assertEquals (  \" statement    2    not   split   correctly \"  ,    statement 2  ,    statements . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["readAndSplitScriptContainingMuliLineComments"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "String   script    =    readScript (  \" db - test - data - multi - newline . sql \"  )  ;", "List < String >    statements    =    new   ArrayList <  >  (  )  ;", ". splitSqlScript ( script ,     \"  \\ n \\ n \"  ,    statements )  ;", "String   statement 1     =     \" insert   into   T _ TEST    ( NAME )    values    (  ' Keith '  )  \"  ;", "String   statement 2     =     \" insert   into   T _ TEST    ( NAME )    values    (  ' Dave '  )  \"  ;", "assertEquals (  \" wrong   number   of   statements \"  ,     2  ,    statements . size (  )  )  ;", "assertEquals (  \" statement    1    not   split   correctly \"  ,    statement 1  ,    statements . get (  0  )  )  ;", "assertEquals (  \" statement    2    not   split   correctly \"  ,    statement 2  ,    statements . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["readAndSplitScriptWithMultipleNewlinesAsSeparator"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "EncodedResource   resource    =    new   EncodedResource ( new   ClassPathResource ( path ,    getClass (  )  )  )  ;", "return    . readScript ( resource )  ;", "}", "METHOD_END"], "methodName": ["readScript"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "String   statement 1     =     \" select    \\  '  1  \\  '    as    \\  \" Dogbert \\  ' s   owner \\  ' s \\  \"    from   dual \"  ;", "String   statement 2     =     \" select    \\  '  2  \\  '    as    \\  \" Dilbert \\  ' s \\  \"    from   dual \"  ;", "char   delim    =     '  ;  '  ;", "String   script    =     (  ( statement 1     +    delim )     +    statement 2  )     +    delim ;", "List < String >    statements    =    new   ArrayList <  >  (  )  ;", ". splitSqlScript ( script ,     '  ;  '  ,    statements )  ;", "assertEquals (  \" wrong   number   of   statements \"  ,     2  ,    statements . size (  )  )  ;", "assertEquals (  \" statement    1    not   split   correctly \"  ,    statement 1  ,    statements . get (  0  )  )  ;", "assertEquals (  \" statement    2    not   split   correctly \"  ,    statement 2  ,    statements . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["splitScriptWithSingleQuotesNestedInsideDoubleQuotes"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "String   statement 1     =     \" insert   into   customer    ( id ,    name )    values    (  1  ,     \\  ' Rod    ;    Johnson \\  '  )  ,     (  2  ,     \\  ' Adrian    \\ n   Collier \\  '  )  \"  ;", "String   statement 2     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )    values    (  1  ,     '  2  0  0  8  -  0  1  -  0  2  '  ,     2  )  \"  ;", "String   statement 3     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )    values    (  1  ,     '  2  0  0  8  -  0  1  -  0  2  '  ,     2  )  \"  ;", "char   delim    =     '  \\ n '  ;", "String   script    =     (  (  (  ( statement 1     +    delim )     +    statement 2  )     +    delim )     +    statement 3  )     +    delim ;", "List < String >    statements    =    new   ArrayList <  >  (  )  ;", ". splitSqlScript ( script ,    delim ,    statements )  ;", "assertEquals (  \" wrong   number   of   statements \"  ,     3  ,    statements . size (  )  )  ;", "assertEquals (  \" statement    1    not   split   correctly \"  ,    statement 1  ,    statements . get (  0  )  )  ;", "assertEquals (  \" statement    2    not   split   correctly \"  ,    statement 2  ,    statements . get (  1  )  )  ;", "assertEquals (  \" statement    3    not   split   correctly \"  ,    statement 3  ,    statements . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["splitSqlScriptDelimitedWithNewLine"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "String   statement 1     =     \" do   something \"  ;", "String   statement 2     =     \" do   something   else \"  ;", "char   delim    =     '  \\ n '  ;", "String   script    =     (  ( statement 1     +    delim )     +    statement 2  )     +    delim ;", "List < String >    statements    =    new   ArrayList <  >  (  )  ;", ". splitSqlScript ( script ,     . DEFAULT _ STATEMENT _ SEPARATOR ,    statements )  ;", "assertEquals (  \" wrong   number   of   statements \"  ,     1  ,    statements . size (  )  )  ;", "assertEquals (  \" script   should   have   been    ' stripped '    but   not   actually    ' split '  \"  ,    script . replace (  '  \\ n '  ,     '     '  )  ,    statements . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["splitSqlScriptDelimitedWithNewLineButDefaultDelimiterSpecified"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "String   rawStatement 1     =     \" insert   into   customer    ( id ,    name )  \\ nvalues    (  1  ,     \\  ' Rod    ;    Johnson \\  '  )  ,     (  2  ,     \\  ' Adrian    \\ n   Collier \\  '  )  \"  ;", "String   cleanedStatement 1     =     \" insert   into   customer    ( id ,    name )    values    (  1  ,     \\  ' Rod    ;    Johnson \\  '  )  ,     (  2  ,     \\  ' Adrian    \\ n   Collier \\  '  )  \"  ;", "String   rawStatement 2     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )  \\ nvalues    (  1  ,     \\  '  2  0  0  8  -  0  1  -  0  2  \\  '  ,     2  )  \"  ;", "String   cleanedStatement 2     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )    values    (  1  ,     '  2  0  0  8  -  0  1  -  0  2  '  ,     2  )  \"  ;", "String   rawStatement 3     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )    values    (  1  ,     '  2  0  0  8  -  0  1  -  0  2  '  ,     2  )  \"  ;", "String   cleanedStatement 3     =     \" insert   into   orders ( id ,    order _ date ,    customer _ id )    values    (  1  ,     '  2  0  0  8  -  0  1  -  0  2  '  ,     2  )  \"  ;", "char   delim    =     '  ;  '  ;", "String   script    =     (  (  (  ( rawStatement 1     +    delim )     +    rawStatement 2  )     +    delim )     +    rawStatement 3  )     +    delim ;", "List < String >    statements    =    new   ArrayList <  >  (  )  ;", ". splitSqlScript ( script ,    delim ,    statements )  ;", "assertEquals (  \" wrong   number   of   statements \"  ,     3  ,    statements . size (  )  )  ;", "assertEquals (  \" statement    1    not   split   correctly \"  ,    cleanedStatement 1  ,    statements . get (  0  )  )  ;", "assertEquals (  \" statement    2    not   split   correctly \"  ,    cleanedStatement 2  ,    statements . get (  1  )  )  ;", "assertEquals (  \" statement    3    not   split   correctly \"  ,    cleanedStatement 3  ,    statements . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["splitSqlScriptDelimitedWithSemicolon"], "fileName": "org.springframework.jdbc.datasource.init.ScriptUtilsUnitTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( this . resolvedDataSources ,     \" DataSource   router   not   initialized \"  )  ;", "Object   lookupKey    =    determineCurrentLookupKey (  )  ;", "DataSource   dataSource    =    this . resolvedDataSources . get ( lookupKey )  ;", "if    (  ( dataSource    =  =    null )     &  &     (  ( this . lenientFallback )     |  |     ( lookupKey    =  =    null )  )  )     {", "dataSource    =    this . resolvedDefaultDataSource ;", "}", "if    ( dataSource    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" Cannot   determine   target   DataSource   for   lookup   key    [  \"     +    lookupKey )     +     \"  ]  \"  )  )  ;", "}", "return   dataSource ;", "}", "METHOD_END"], "methodName": ["determineTargetDataSource"], "fileName": "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource"}, {"methodBody": ["METHOD_START", "{", "if    ( dataSource   instanceof   DataSource )     {", "return    (  ( DataSource )     ( dataSource )  )  ;", "} else", "if    ( dataSource   instanceof   String )     {", "return   this . dataSourceLookup . getDataSource (  (  ( String )     ( dataSource )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Illegal   data   source   value    -    only    [ DataSource ]    and   String   supported :     \"     +    dataSource )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveSpecifiedDataSource"], "fileName": "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource"}, {"methodBody": ["METHOD_START", "{", "return   lookupKey ;", "}", "METHOD_END"], "methodName": ["resolveSpecifiedLookupKey"], "fileName": "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource"}, {"methodBody": ["METHOD_START", "{", "this . dataSourceLookup    =     ( dataSourceLookup    !  =    null )     ?    dataSourceLookup    :    new   JndiDataSourceLookup (  )  ;", "}", "METHOD_END"], "methodName": ["setDataSourceLookup"], "fileName": "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource"}, {"methodBody": ["METHOD_START", "{", "this . defaultTargetDataSource    =    defaultTargetDataSource ;", "}", "METHOD_END"], "methodName": ["setDefaultTargetDataSource"], "fileName": "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource"}, {"methodBody": ["METHOD_START", "{", "this . lenientFallback    =    lenientFallback ;", "}", "METHOD_END"], "methodName": ["setLenientFallback"], "fileName": "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource"}, {"methodBody": ["METHOD_START", "{", "this . targetDataSources    =    targetDataSources ;", "}", "METHOD_END"], "methodName": ["setTargetDataSources"], "fileName": "org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "StubDataSource   expectedDataSource    =    new   StubDataSource (  )  ;", "given ( beanFactory . getBean (  . DATASOURCE _ BEAN _ NAME ,    DataSource . class )  )  . willReturn ( expectedDataSource )  ;", "BeanFactoryDataSourceLookup   lookup    =    new   BeanFactoryDataSourceLookup (  )  ;", "lookup . setBeanFactory ( beanFactory )  ;", "DataSource   dataSource    =    lookup . getDataSource (  . DATASOURCE _ BEAN _ NAME )  ;", "assertNotNull (  (  \" A   DataSourceLookup   implementation   must    * never *    return   null   from    \"     +     \" getDataSource (  )  :    this   one   obviously    ( and   incorrectly )    is \"  )  ,    dataSource )  ;", "assertSame ( expectedDataSource ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["testLookupSunnyDay"], "fileName": "org.springframework.jdbc.datasource.lookup.BeanFactoryDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactoryDataSourceLookup   lookup    =    new   BeanFactoryDataSourceLookup (  )  ;", "lookup . getDataSource (  . DATASOURCE _ BEAN _ NAME )  ;", "}", "METHOD_END"], "methodName": ["testLookupWhereBeanFactoryHasNotBeenSupplied"], "fileName": "org.springframework.jdbc.datasource.lookup.BeanFactoryDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "final   BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "given ( beanFactory . getBean (  . DATASOURCE _ BEAN _ NAME ,    DataSource . class )  )  . willThrow ( new   BeanNotOfRequiredTypeException (  . DATASOURCE _ BEAN _ NAME ,    DataSource . class ,    String . class )  )  ;", "try    {", "BeanFactoryDataSourceLookup   lookup    =    new   BeanFactoryDataSourceLookup ( beanFactory )  ;", "lookup . getDataSource (  . DATASOURCE _ BEAN _ NAME )  ;", "fail (  \" should   have   thrown   DataSourceLookupFailureException \"  )  ;", "}    catch    ( DataSourceLookupFailureException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testLookupWhereBeanFactoryYieldsNonDataSourceType"], "fileName": "org.springframework.jdbc.datasource.lookup.BeanFactoryDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "JndiDataSourceLookup   lookup    =    new   JndiDataSourceLookup (  )     {", "@ Override", "protected    < T >    T   lookup ( String   jndiName ,    Class < T >    requiredType )    throws   NamingException    {", "assertEquals (  . DATA _ SOURCE _ NAME ,    jndiName )  ;", "throw   new   NamingException (  )  ;", "}", "}  ;", "lookup . getDataSource (  . DATA _ SOURCE _ NAME )  ;", "}", "METHOD_END"], "methodName": ["testNoDataSourceAtJndiLocation"], "fileName": "org.springframework.jdbc.datasource.lookup.JndiDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "final   DataSource   expectedDataSource    =    new   StubDataSource (  )  ;", "JndiDataSourceLookup   lookup    =    new   JndiDataSourceLookup (  )     {", "@ Override", "protected    < T >    T   lookup ( String   jndiName ,    Class < T >    requiredType )     {", "assertEquals (  . DATA _ SOURCE _ NAME ,    jndiName )  ;", "return   requiredType . cast ( expectedDataSource )  ;", "}", "}  ;", "DataSource   dataSource    =    lookup . getDataSource (  . DATA _ SOURCE _ NAME )  ;", "assertNotNull (  \" A   DataSourceLookup   implementation   must    * never *    return   null   from   getDataSource (  )  :    this   one   obviously    ( and   incorrectly )    is \"  ,    dataSource )  ;", "assertSame ( expectedDataSource ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDay"], "fileName": "org.springframework.jdbc.datasource.lookup.JndiDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( dataSourceName ,     \" DataSource   name   must   not   be   null \"  )  ;", "Assert . notNull ( dataSource ,     \" DataSource   must   not   be   null \"  )  ;", "this . dataSources . put ( dataSourceName ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["addDataSource"], "fileName": "org.springframework.jdbc.datasource.lookup.MapDataSourceLookup"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . dataSources )  ;", "}", "METHOD_END"], "methodName": ["getDataSources"], "fileName": "org.springframework.jdbc.datasource.lookup.MapDataSourceLookup"}, {"methodBody": ["METHOD_START", "{", "if    ( dataSources    !  =    null )     {", "this . dataSources . putAll ( dataSources )  ;", "}", "}", "METHOD_END"], "methodName": ["setDataSources"], "fileName": "org.springframework.jdbc.datasource.lookup.MapDataSourceLookup"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    DataSource >    dataSources    =    new   HashMap <  >  (  )  ;", "StubDataSource   overridenDataSource    =    new   StubDataSource (  )  ;", "StubDataSource   expectedDataSource    =    new   StubDataSource (  )  ;", "dataSources . put (  . DATA _ SOURCE _ NAME ,    overridenDataSource )  ;", "MapDataSourceLookup   lookup    =    new   MapDataSourceLookup (  )  ;", "lookup . setDataSources ( dataSources )  ;", "lookup . addDataSource (  . DATA _ SOURCE _ NAME ,    expectedDataSource )  ;", "DataSource   dataSource    =    lookup . getDataSource (  . DATA _ SOURCE _ NAME )  ;", "assertNotNull (  \" A   DataSourceLookup   implementation   must    * never *    return   null   from   getDataSource (  )  :    this   one   obviously    ( and   incorrectly )    is \"  ,    dataSource )  ;", "assertSame ( expectedDataSource ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["addingDataSourcePermitsOverride"], "fileName": "org.springframework.jdbc.datasource.lookup.MapDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "MapDataSourceLookup   lookup    =    new   MapDataSourceLookup (  )  ;", "exception . expect ( DataSourceLookupFailureException . class )  ;", "lookup . getDataSource (  . DATA _ SOURCE _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getDataSourceWhereSuppliedMapHasNoEntryForSpecifiedKey"], "fileName": "org.springframework.jdbc.datasource.lookup.MapDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "Map   dataSources    =    new   HashMap (  )  ;", "dataSources . put (  . DATA _ SOURCE _ NAME ,    new   Object (  )  )  ;", "MapDataSourceLookup   lookup    =    new   MapDataSourceLookup ( dataSources )  ;", "exception . expect ( ClassCastException . class )  ;", "lookup . getDataSource (  . DATA _ SOURCE _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getDataSourceWhereSuppliedMapHasNonDataSourceTypeUnderSpecifiedKey"], "fileName": "org.springframework.jdbc.datasource.lookup.MapDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "MapDataSourceLookup   lookup    =    new   MapDataSourceLookup (  )  ;", "Map   dataSources    =    lookup . getDataSources (  )  ;", "exception . expect ( UnsupportedOperationException . class )  ;", "dataSources . put (  \"  \"  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["getDataSourcesReturnsUnmodifiableMap"], "fileName": "org.springframework.jdbc.datasource.lookup.MapDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    DataSource >    dataSources    =    new   HashMap <  >  (  )  ;", "StubDataSource   expectedDataSource    =    new   StubDataSource (  )  ;", "dataSources . put (  . DATA _ SOURCE _ NAME ,    expectedDataSource )  ;", "MapDataSourceLookup   lookup    =    new   MapDataSourceLookup (  )  ;", "lookup . setDataSources ( dataSources )  ;", "DataSource   dataSource    =    lookup . getDataSource (  . DATA _ SOURCE _ NAME )  ;", "assertNotNull (  \" A   DataSourceLookup   implementation   must    * never *    return   null   from   getDataSource (  )  :    this   one   obviously    ( and   incorrectly )    is \"  ,    dataSource )  ;", "assertSame ( expectedDataSource ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["lookupSunnyDay"], "fileName": "org.springframework.jdbc.datasource.lookup.MapDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    DataSource >    dataSources    =    new   HashMap <  >  (  )  ;", "StubDataSource   expectedDataSource    =    new   StubDataSource (  )  ;", "dataSources . put (  . DATA _ SOURCE _ NAME ,    expectedDataSource )  ;", "MapDataSourceLookup   lookup    =    new   MapDataSourceLookup (  )  ;", "lookup . setDataSources ( dataSources )  ;", "lookup . setDataSources ( null )  ;", "DataSource   dataSource    =    lookup . getDataSource (  . DATA _ SOURCE _ NAME )  ;", "assertNotNull (  \" A   DataSourceLookup   implementation   must    * never *    return   null   from   getDataSource (  )  :    this   one   obviously    ( and   incorrectly )    is \"  ,    dataSource )  ;", "assertSame ( expectedDataSource ,    dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSourcesIsAnIdempotentOperation"], "fileName": "org.springframework.jdbc.datasource.lookup.MapDataSourceLookupTests"}, {"methodBody": ["METHOD_START", "{", "if    ( this . parameterQueue . isEmpty (  )  )     {", "return   new   int [  0  ]  ;", "}", "int [  ]    rowsAffected    =    getJdbcTemplate (  )  . batch ( resolveSql (  )  ,    new   BatchPreparedStatementSetter (  )     {", "@ Override", "public   int   getBatchSize (  )     {", "return   parameterQueue . size (  )  ;", "}", "@ Override", "public   void   setValues ( PreparedStatement   ps ,    int   index )    throws   SQLException    {", "Object [  ]    params    =    parameterQueue . removeFirst (  )  ;", "newPreparedStatementSetter ( params )  . setValues ( ps )  ;", "}", "}  )  ;", "for    ( int   rowCount    :    rowsAffected )     {", "checkRowsAffected ( rowCount )  ;", "if    ( this . trackRowsAffected )     {", "this . rowsAffected . add ( rowCount )  ;", "}", "}", "return   rowsAffected ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdate"}, {"methodBody": ["METHOD_START", "{", "return   this . rowsAffected . size (  )  ;", "}", "METHOD_END"], "methodName": ["getExecutionCount"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdate"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterQueue . size (  )  ;", "}", "METHOD_END"], "methodName": ["getQueueCount"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdate"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [ this . rowsAffected . size (  )  ]  ;", "int   i    =     0  ;", "for    ( Iterator < Integer >    it    =    this . rowsAffected . iterator (  )  ;    it . hasNext (  )  ;    i +  +  )     {", "result [ i ]     =    it . next (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getRowsAffected"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdate"}, {"methodBody": ["METHOD_START", "{", "this . parameterQueue . clear (  )  ;", "this . rowsAffected . clear (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdate"}, {"methodBody": ["METHOD_START", "{", "this . batchSize    =    batchSize ;", "}", "METHOD_END"], "methodName": ["setBatchSize"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdate"}, {"methodBody": ["METHOD_START", "{", "this . trackRowsAffected    =    trackRowsAffected ;", "}", "METHOD_END"], "methodName": ["setTrackRowsAffected"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdate"}, {"methodBody": ["METHOD_START", "{", "final   String   sql    =     \" UPDATE   NOSUCHTABLE   SET   DATE _ DISPATCHED    =    SYSDATE   WHERE   ID    =     ?  \"  ;", "final   int [  ]    ids    =    new   int [  ]  {     1  0  0  ,     2  0  0     }  ;", "final   int [  ]    rowsAffected    =    new   int [  ]  {     1  ,     2     }  ;", "Connection   connection    =    mock ( Connection . class )  ;", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "PreparedStatement   preparedStatement    =    mock ( PreparedStatement . class )  ;", "given ( preparedStatement . getConnection (  )  )  . willReturn ( connection )  ;", "given ( preparedStatement . executeBatch (  )  )  . willReturn ( rowsAffected )  ;", "DatabaseMetaData   mockDatabaseMetaData    =    mock ( DatabaseMetaData . class )  ;", "given ( mockDatabaseMetaData . supportsBatchUpdates (  )  )  . willReturn ( true )  ;", "given ( connection . prepareStatement ( sql )  )  . willReturn ( preparedStatement )  ;", "given ( connection . getMetaData (  )  )  . willReturn ( mockDatabaseMetaData )  ;", "update    =    new    ( dataSource ,    sql )  ;", "update . declareParameter ( new   SqlParameter ( Types . INTEGER )  )  ;", "if    ( flushThroughBatchSize )     {", "update . setBatchSize (  2  )  ;", "}", "update . update ( ids [  0  ]  )  ;", "update . update ( ids [  1  ]  )  ;", "if    ( flushThroughBatchSize )     {", "assertEquals (  0  ,    update . getQueueCount (  )  )  ;", "assertEquals (  2  ,    update . getRowsAffected (  )  . length )  ;", "} else    {", "assertEquals (  2  ,    update . getQueueCount (  )  )  ;", "assertEquals (  0  ,    update . getRowsAffected (  )  . length )  ;", "}", "int [  ]    actualRowsAffected    =    update . flush (  )  ;", "assertEquals (  0  ,    update . getQueueCount (  )  )  ;", "if    ( flushThroughBatchSize )     {", "assertTrue (  \" flush   did   not   execute   updates \"  ,     (  ( actualRowsAffected . length )     =  =     0  )  )  ;", "} else    {", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "}", "actualRowsAffected    =    update . getRowsAffected (  )  ;", "assertTrue (  \" executed    2    updates \"  ,     (  ( actualRowsAffected . length )     =  =     2  )  )  ;", "assertEquals ( rowsAffected [  0  ]  ,    actualRowsAffected [  0  ]  )  ;", "assertEquals ( rowsAffected [  1  ]  ,    actualRowsAffected [  1  ]  )  ;", "update . reset (  )  ;", "assertEquals (  0  ,    update . getRowsAffected (  )  . length )  ;", "verify ( preparedStatement )  . setObject (  1  ,    ids [  0  ]  ,    Types . INTEGER )  ;", "verify ( preparedStatement )  . setObject (  1  ,    ids [  1  ]  ,    Types . INTEGER )  ;", "verify ( preparedStatement ,    times (  2  )  )  . addBatch (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestBatchUpdate"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "doTestBatchUpdate ( false )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithExplicitFlush"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "doTestBatchUpdate ( true )  ;", "}", "METHOD_END"], "methodName": ["testBatchUpdateWithFlushThroughBatchSize"], "fileName": "org.springframework.jdbc.object.BatchSqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "this . rowMapper    =    rowMapper ;", "}", "METHOD_END"], "methodName": ["setRowMapper"], "fileName": "org.springframework.jdbc.object.GenericSqlQuery"}, {"methodBody": ["METHOD_START", "{", "this . rowMapperClass    =    rowMapperClass ;", "}", "METHOD_END"], "methodName": ["setRowMapperClass"], "fileName": "org.springframework.jdbc.object.GenericSqlQuery"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( preparedStatement . executeQuery (  )  )  . willReturn ( resultSet )  ;", "given ( connection . prepareStatement (  . SELECT _ ID _ FORENAME _ NAMED _ PARAMETERS _ PARSED )  )  . willReturn ( preparedStatement )  ;", "List <  ?  >    queryResults ;", "if    ( namedParameters )     {", "Map < String ,    Object >    params    =    new   HashMap <  >  (  2  )  ;", "params . put (  \" id \"  ,     1  )  ;", "params . put (  \" country \"  ,     \" UK \"  )  ;", "queryResults    =    query . executeByNamedParam ( params )  ;", "} else    {", "Object [  ]    params    =    new   Object [  ]  {     1  ,     \" UK \"     }  ;", "queryResults    =    query . execute ( params )  ;", "}", "assertTrue (  \" Customer   was   returned   correctly \"  ,     (  ( queryResults . size (  )  )     =  =     1  )  )  ;", "Customer   cust    =     (  ( Customer )     ( queryResults . get (  0  )  )  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( cust . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    cust . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . INTEGER )  ;", "verify ( preparedStatement )  . setString (  2  ,     \" UK \"  )  ;", "verify ( preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestCustomerQuery"], "fileName": "org.springframework.jdbc.object.GenericSqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   beans . factory . xml . XmlBeanDefinitionReader ( this . beanFactory )  . loadBeanDefinitions ( new   ClassPathResource (  \" jdbc / object / GenericSqlQueryTests - context . xml \"  )  )  ;", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "this . connection    =    mock ( Connection . class )  ;", "this . preparedStatement    =    mock ( PreparedStatement . class )  ;", "this . resultSet    =    mock ( ResultSet . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "TestDataSourceWrapper   testDataSource    =     (  ( TestDataSourceWrapper )     ( beanFactory . getBean (  \" dataSource \"  )  )  )  ;", "testDataSource . setTarget ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.object.GenericSqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "SqlQuery <  ?  >    query    =     (  ( SqlQuery <  ?  >  )     ( beanFactory . getBean (  \" queryWithNamedParameters \"  )  )  )  ;", "doTestCustomerQuery ( query ,    true )  ;", "}", "METHOD_END"], "methodName": ["testCustomerQueryWithNamedParameters"], "fileName": "org.springframework.jdbc.object.GenericSqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "SqlQuery <  ?  >    query    =     (  ( SqlQuery <  ?  >  )     ( beanFactory . getBean (  \" queryWithPlaceholders \"  )  )  )  ;", "doTestCustomerQuery ( query ,    false )  ;", "}", "METHOD_END"], "methodName": ["testCustomerQueryWithPlaceholders"], "fileName": "org.springframework.jdbc.object.GenericSqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "SqlQuery <  ?  >    query    =     (  ( SqlQuery <  ?  >  )     ( beanFactory . getBean (  \" queryWithRowMapperBean \"  )  )  )  ;", "doTestCustomerQuery ( query ,    true )  ;", "}", "METHOD_END"], "methodName": ["testCustomerQueryWithRowMapperInstance"], "fileName": "org.springframework.jdbc.object.GenericSqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" org / springframework / jdbc / object /  - context . xml \"  )  )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "CallableStatement   callableStatement    =    mock ( CallableStatement . class )  ;", "TestDataSourceWrapper   testDataSource    =     (  ( TestDataSourceWrapper )     ( bf . getBean (  \" dataSource \"  )  )  )  ;", "testDataSource . setTarget ( dataSource )  ;", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getObject (  3  )  )  . willReturn (  4  )  ;", "given ( connection . prepareCall (  (  \"  { call    \"     +     (  \" add _ invoice \"     +     \"  (  ?  ,     ?  ,     ?  )  }  \"  )  )  )  )  . willReturn ( callableStatement )  ;", "StoredProcedure   adder    =     (  ( StoredProcedure )     ( bf . getBean (  \" genericProcedure \"  )  )  )  ;", "Map < String ,    Object >    in    =    new   HashMap <  >  (  2  )  ;", "in . put (  \" amount \"  ,     1  1  0  6  )  ;", "in . put (  \" custid \"  ,     3  )  ;", "Map < String ,    Object >    out    =    adder . execute ( in )  ;", "Integer   id    =     (  ( Integer )     ( out . get (  \" newid \"  )  )  )  ;", "assertEquals (  4  ,    id . intValue (  )  )  ;", "verify ( callableStatement )  . setObject (  1  ,     1  1  0  6  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . setObject (  2  ,     3  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . registerOutParameter (  3  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoices"], "fileName": "org.springframework.jdbc.object.GenericStoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["allowsUnusedParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isCompiled (  )  )  )     {", "logger . debug (  \" SQL   o   not   compiled   before   execution    -    invoking   compile \"  )  ;", "compile (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkCompiled"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isCompiled (  )  )  )     {", "if    (  ( getSql (  )  )     =  =    null )     {", "throw   new   InvalidDataAccessApiUsageException (  \" Property    ' sql '    is   required \"  )  ;", "}", "try    {", "this . jdbcTemplate . afterPropertiesSet (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   InvalidDataAccessApiUsageException ( ex . getMessage (  )  )  ;", "}", "compileInternal (  )  ;", "this . compiled    =    true ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \"    with   SQL    [  \"     +     ( getSql (  )  )  )     +     \"  ]    compiled \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( isCompiled (  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  \" Cannot   add   paters   once   the   query   is   compiled \"  )  ;", "}", "this . declaredPaters . add ( param )  ;", "}", "METHOD_END"], "methodName": ["declareParameter"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . declaredParameters ;", "}", "METHOD_END"], "methodName": ["getDeclaredParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . generatedKeysColumnNames ;", "}", "METHOD_END"], "methodName": ["getGeneratedKeysColumnNames"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . jdbcTemplate ;", "}", "METHOD_END"], "methodName": ["getJdbcTemplate"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . resultSetType ;", "}", "METHOD_END"], "methodName": ["getResultSetType"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . sql ;", "}", "METHOD_END"], "methodName": ["getSql"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . compiled ;", "}", "METHOD_END"], "methodName": ["isCompiled"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . returnGeneratedKeys ;", "}", "METHOD_END"], "methodName": ["isReturnGeneratedKeys"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "return   this . updatableResults ;", "}", "METHOD_END"], "methodName": ["isUpdatableResults"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "String   sql    =    getSql (  )  ;", "Assert . state (  ( sql    !  =    null )  ,     \" No   SQL   set \"  )  ;", "return   sql ;", "}", "METHOD_END"], "methodName": ["resolveSql"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate . setDataSource ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate . setFetchSize ( fetchSize )  ;", "}", "METHOD_END"], "methodName": ["setFetchSize"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( isCompiled (  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  \" The   column   names   for   the   generated   keys   must   be   set   before   the   o   is   compiled \"  )  ;", "}", "this . generatedKeysColumnNames    =    names ;", "}", "METHOD_END"], "methodName": ["setGeneratedKeysColumnNames"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate    =    jdbcTemplate ;", "}", "METHOD_END"], "methodName": ["setJdbcTemplate"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate . setMaxRows ( maxRows )  ;", "}", "METHOD_END"], "methodName": ["setMaxRows"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( isCompiled (  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  \" Cannot   add   paters   once   the   query   is   compiled \"  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( paters . length )  ;    i +  +  )     {", "if    (  ( paters [ i ]  )     !  =    null )     {", "this . declaredPaters . add ( paters [ i ]  )  ;", "} else    {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  (  \" Cannot   add   pater   at   index    \"     +    i )     +     \"    from    \"  )     +     ( Arrays . asList ( paters )  )  )     +     \"    since   it   is    ' null '  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "this . jdbcTemplate . setQueryTimeout ( queryTimeout )  ;", "}", "METHOD_END"], "methodName": ["setQueryTimeout"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "this . resultSetType    =    resultSetType ;", "}", "METHOD_END"], "methodName": ["setResultSetType"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( isCompiled (  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  \" The   returnGeneratedKeys   flag   must   be   set   before   the   o   is   compiled \"  )  ;", "}", "this . returnGeneratedKeys    =    returnGeneratedKeys ;", "}", "METHOD_END"], "methodName": ["setReturnGeneratedKeys"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "this . sql    =    sql ;", "}", "METHOD_END"], "methodName": ["setSql"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( isCompiled (  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  \" Cannot   add   paters   once   query   is   compiled \"  )  ;", "}", "if    ( types    !  =    null )     {", "for    ( int   type    :    types )     {", "declarePater ( new   SqlPater ( type )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setTypes"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( isCompiled (  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  \" The   updateableResults   flag   must   be   set   before   the   o   is   compiled \"  )  ;", "}", "this . updatableResults    =    updatableResults ;", "}", "METHOD_END"], "methodName": ["setUpdatableResults"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["supportsLobParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "Map < String ,     ?  >    paramsToUse    =     ( parameters    !  =    null )     ?    parameters    :    Collections .  < String ,    Object > emptyMap (  )  ;", "int   declaredInParameters    =     0  ;", "for    ( SqlParameter   param    :    this . declaredParameters )     {", "if    ( param . isInputValueProvided (  )  )     {", "if    (  (  !  ( supportsLobParameters (  )  )  )     &  &     (  (  ( param . getSqlType (  )  )     =  =     ( Types . BLOB )  )     |  |     (  ( param . getSqlType (  )  )     =  =     ( Types . CLOB )  )  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  \" BLOB   or   CLOB   parameters   are   not   allowed   for   this   kind   of   o \"  )  ;", "}", "if    (  (  ( param . getName (  )  )     !  =    null )     &  &     (  !  ( paramsToUse . containsKey ( param . getName (  )  )  )  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  \" The   parameter   named    '  \"     +     ( param . getName (  )  )  )     +     \"  '    was   not   among   the   parameters   supplied :     \"  )     +     ( paramsToUse . keySet (  )  )  )  )  ;", "}", "declaredInParameters +  +  ;", "}", "}", "validateParameterCount ( paramsToUse . size (  )  ,    declaredInParameters )  ;", "}", "METHOD_END"], "methodName": ["validateNamedParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "if    ( suppliedParamCount    <    declaredInParamCount )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  (  ( suppliedParamCount    +     \"    paters   were   supplied ,    but    \"  )     +    declaredInParamCount )     +     \"    in   paters   were   declared   in   class    [  \"  )     +     ( getClass (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "if    (  ( suppliedParamCount    >     ( this . declaredPaters . size (  )  )  )     &  &     (  !  ( allowsUnusedPaters (  )  )  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  (  (  (  ( suppliedParamCount    +     \"    paters   were   supplied ,    but    \"  )     +    declaredInParamCount )     +     \"    paters   were   declared   in   class    [  \"  )     +     ( getClass (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateParameterCount"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "int   declaredInParameters    =     0  ;", "for    ( SqlParameter   param    :    this . declaredParameters )     {", "if    ( param . isInputValueProvided (  )  )     {", "if    (  (  !  ( supportsLobParameters (  )  )  )     &  &     (  (  ( param . getSqlType (  )  )     =  =     ( Types . BLOB )  )     |  |     (  ( param . getSqlType (  )  )     =  =     ( Types . CLOB )  )  )  )     {", "throw   new   InvalidDataAccessApiUsageException (  \" BLOB   or   CLOB   parameters   are   not   allowed   for   this   kind   of   o \"  )  ;", "}", "declaredInParameters +  +  ;", "}", "}", "validateParameterCount (  ( parameters    !  =    null    ?    parameters . length    :     0  )  ,    declaredInParameters )  ;", "}", "METHOD_END"], "methodName": ["validateParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperation"}, {"methodBody": ["METHOD_START", "{", "operation . setDataSource ( new   DriverManagerDataSource (  )  )  ;", "operation . setSql (  \" select    *    from   mytable \"  )  ;", "operation . setTypes ( null )  ;", "operation . compile (  )  ;", "operation . compile (  )  ;", "}", "METHOD_END"], "methodName": ["compileTwice"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "operation . setDataSource ( new   DriverManagerDataSource (  )  )  ;", "operation . setSql (  \" select    *    from   mytable \"  )  ;", "operation . compile (  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "operation . declareParameter ( new   SqlParameter ( Types . INTEGER )  )  ;", "}", "METHOD_END"], "methodName": ["declareParameterAfterCompile"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "SqlOperation   operation    =    new   SqlOperation (  )     {  }  ;", "operation . setSql (  \" select    *    from   mytable \"  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "operation . compile (  )  ;", "}", "METHOD_END"], "methodName": ["emptyDataSource"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "o . compile (  )  ;", "}", "METHOD_END"], "methodName": ["emptySql"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "operation . setSql (  \" foo \"  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "exception . expectMessage ( containsString (  \" ataSource \"  )  )  ;", "operation . compile (  )  ;", "}", "METHOD_END"], "methodName": ["operationConfiguredViaJdbcTemplateMustGetDataSource"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "SqlOperation   operation    =    new   SqlOperation (  )     {  }  ;", "DataSource   ds    =    new   DriverManagerDataSource (  )  ;", "operation . setDataSource ( ds )  ;", "operation . setFetchSize (  1  0  )  ;", "operation . setMaxRows (  2  0  )  ;", "JdbcTemplate   jt    =    operation . getJdbcTemplate (  )  ;", "assertEquals ( ds ,    jt . getDataSource (  )  )  ;", "assertEquals (  1  0  ,    jt . getFetchSize (  )  )  ;", "assertEquals (  2  0  ,    jt . getMaxRows (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterPropagation"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "DataSource   ds    =    new   DriverManagerDataSource (  )  ;", "o . setDataSource ( ds )  ;", "o . setSql (  \" select    *    from   mytable   where   one    =     ?    and   two    =     ?  \"  )  ;", "o . setParameters ( new   SqlParameter [  ]  {    new   SqlParameter (  \" one \"  ,    Types . NUMERIC )  ,    new   SqlParameter (  \" two \"  ,    Types . NUMERIC )     }  )  ;", "o . afterPropertiesSet (  )  ;", "o . validateParameters ( new   Object [  ]  {     1  ,     \"  2  \"     }  )  ;", "assertEquals (  2  ,    o . getDeclaredParameters (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parametersSetWithList"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "operation . setDataSource ( new   DriverManagerDataSource (  )  )  ;", "operation . setSql (  \" select    *    from   mytable \"  )  ;", "operation . compile (  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "operation . setTypes ( new   int [  ]  {    Types . INTEGER    }  )  ;", "}", "METHOD_END"], "methodName": ["setTypeAfterCompile"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "operation . setSql (  \" select    *    from   mytable \"  )  ;", "operation . setTypes ( new   int [  ]  {    Types . INTEGER    }  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "operation . validateNamedParameters (  (  ( Map < String ,    String >  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["tooFewMapParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "operation . setSql (  \" select    *    from   mytable \"  )  ;", "operation . setTypes ( new   int [  ]  {    Types . INTEGER    }  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "operation . validateParameters (  (  ( Object [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["tooFewParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "operation . setSql (  \" select    *    from   mytable \"  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "operation . validateParameters ( new   Object [  ]  {     1  ,     2     }  )  ;", "}", "METHOD_END"], "methodName": ["tooManyParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "operation . setSql (  \" select    *    from   mytable \"  )  ;", "Map < String ,    String >    params    =    new   HashMap <  >  (  )  ;", "params . put (  \" col 1  \"  ,     \" value \"  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "operation . validateNamedParameters ( params )  ;", "}", "METHOD_END"], "methodName": ["unspecifiedMapParameters"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "operation . setDataSource ( new   DriverManagerDataSource (  )  )  ;", "operation . setSql (  \" DUMMY _ PROC \"  )  ;", "operation . declareParameter ( new   SqlOutParameter (  \" DUMMY _ OUT _ PARAM \"  ,    Types . VARCHAR )  )  ;", "operation . declareParameter ( new   SqlInOutParameter (  \" DUMMY _ IN _ OUT _ PARAM \"  ,    Types . VARCHAR )  )  ;", "operation . validateParameters ( new   Object [  ]  {     \" DUMMY _ VALUE 1  \"  ,     \" DUMMY _ VALUE 2  \"     }  )  ;", "}", "METHOD_END"], "methodName": ["validateInOutParameter"], "fileName": "org.springframework.jdbc.object.RdbmsOperationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . callString ;", "}", "METHOD_END"], "methodName": ["getCallString"], "fileName": "org.springframework.jdbc.object.SqlCall"}, {"methodBody": ["METHOD_START", "{", "return   function ;", "}", "METHOD_END"], "methodName": ["isFunction"], "fileName": "org.springframework.jdbc.object.SqlCall"}, {"methodBody": ["METHOD_START", "{", "return   sqlReadyForUse ;", "}", "METHOD_END"], "methodName": ["isSqlReadyForUse"], "fileName": "org.springframework.jdbc.object.SqlCall"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . callableStatementFactory )     !  =    null )  ,     \" No   CallableStatementFactory   available \"  )  ;", "return   this . callableStatementFactory . newCallableStatementCreator ( inParams )  ;", "}", "METHOD_END"], "methodName": ["newCallableStatementCreator"], "fileName": "org.springframework.jdbc.object.SqlCall"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . callableStatementFactory )     !  =    null )  ,     \" No   CallableStatementFactory   available \"  )  ;", "return   this . callableStatementFactory . newCallableStatementCreator ( inParamMapper )  ;", "}", "METHOD_END"], "methodName": ["newCallableStatementCreator"], "fileName": "org.springframework.jdbc.object.SqlCall"}, {"methodBody": ["METHOD_START", "{", "this . function    =    function ;", "}", "METHOD_END"], "methodName": ["setFunction"], "fileName": "org.springframework.jdbc.object.SqlCall"}, {"methodBody": ["METHOD_START", "{", "this . sqlReadyForUse    =    sqlReadyForUse ;", "}", "METHOD_END"], "methodName": ["setSqlReadyForUse"], "fileName": "org.springframework.jdbc.object.SqlCall"}, {"methodBody": ["METHOD_START", "{", "return   run ( new   Object [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.springframework.jdbc.object.SqlFunction"}, {"methodBody": ["METHOD_START", "{", "return   run ( new   Object [  ]  {    parameter    }  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.springframework.jdbc.object.SqlFunction"}, {"methodBody": ["METHOD_START", "{", "Object   obj    =    super . findObject ( parameters )  ;", "if    (  !  ( obj   instanceof   Number )  )     {", "throw   new   TypeMismatchDataAccessException (  (  (  \" Couldn ' t   convert   result       [  \"     +    obj )     +     \"  ]    to   int \"  )  )  ;", "}", "return    (  ( Number )     ( obj )  )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.springframework.jdbc.object.SqlFunction"}, {"methodBody": ["METHOD_START", "{", "return   findObject (  (  ( Object [  ]  )     ( null )  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["runGeneric"], "fileName": "org.springframework.jdbc.object.SqlFunction"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( parameter )  ;", "}", "METHOD_END"], "methodName": ["runGeneric"], "fileName": "org.springframework.jdbc.object.SqlFunction"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( parameters )  ;", "}", "METHOD_END"], "methodName": ["runGeneric"], "fileName": "org.springframework.jdbc.object.SqlFunction"}, {"methodBody": ["METHOD_START", "{", "this . rowMapper . setRequiredType ( resultType )  ;", "}", "METHOD_END"], "methodName": ["setResultType"], "fileName": "org.springframework.jdbc.object.SqlFunction"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . parsedSqlMonitor )     {", "if    (  ( this . cachedSql )     =  =    null )     {", "this . cachedSql    =    NamedPaterUtils . parseSqlStatement ( resolveSql (  )  )  ;", "}", "return   this . cachedSql ;", "}", "}", "METHOD_END"], "methodName": ["getParsedSql"], "fileName": "org.springframework.jdbc.object.SqlOperation"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . preparedStatementFactory )     !  =    null )  ,     \" No   PreparedStatementFactory   available \"  )  ;", "return   this . preparedStatementFactory . newPreparedStatementCreator ( pas )  ;", "}", "METHOD_END"], "methodName": ["newPreparedStatementCreator"], "fileName": "org.springframework.jdbc.object.SqlOperation"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . preparedStatementFactory )     !  =    null )  ,     \" No   PreparedStatementFactory   available \"  )  ;", "return   this . preparedStatementFactory . newPreparedStatementCreator ( sqlToUse ,    pas )  ;", "}", "METHOD_END"], "methodName": ["newPreparedStatementCreator"], "fileName": "org.springframework.jdbc.object.SqlOperation"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . preparedStatementFactory )     !  =    null )  ,     \" No   PreparedStatementFactory   available \"  )  ;", "return   this . preparedStatementFactory . newPreparedStatementSetter ( pas )  ;", "}", "METHOD_END"], "methodName": ["newPreparedStatementSetter"], "fileName": "org.springframework.jdbc.object.SqlOperation"}, {"methodBody": ["METHOD_START", "{", "return   execute (  (  ( Object [  ]  )     ( null )  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute ( p 1  ,    null )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute ( p 1  ,    p 2  ,    null )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute ( new   Object [  ]  {    p 1  ,    p 2     }  ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute ( new   Object [  ]  {    p 1     }  ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute ( params ,    null )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "validateParameters ( params )  ;", "RowMapper < T >    rowMapper    =    newRowMapper ( params ,    context )  ;", "return   getJdbcTemplate (  )  . query ( newPreparedStatementCreator ( params )  ,    rowMapper )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute ( p 1  ,    null )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute ( new   Object [  ]  {    p 1     }  ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute (  (  ( Object [  ]  )     ( null )  )  ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute ( p 1  ,    null )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   execute ( new   Object [  ]  {    p 1     }  ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   executeByNamedParam ( paramMap ,    null )  ;", "}", "METHOD_END"], "methodName": ["executeByNamedParam"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "validateNamedParameters ( paramMap )  ;", "ParsedSql   parsedSql    =    getParsedSql (  )  ;", "MapSqlParameterSource   paramSource    =    new   MapSqlParameterSource ( paramMap )  ;", "String   sqlToUse    =    NamedParameterUtils . substituteNamedParameters ( parsedSql ,    paramSource )  ;", "O [  ]    params    =    NamedParameterUtils . buildValueArray ( parsedSql ,    paramSource ,    getDeclaredParameters (  )  )  ;", "RowMapper < T >    rowMapper    =    newRowMapper ( params ,    context )  ;", "return   getJdbcTemplate (  )  . query ( newPreparedStatementCreator ( sqlToUse ,    params )  ,    rowMapper )  ;", "}", "METHOD_END"], "methodName": ["executeByNamedParam"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( p 1  ,    null )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( p 1  ,    p 2  ,    null )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( new   Object [  ]  {    p 1  ,    p 2     }  ,    context )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( new   Object [  ]  {    p 1     }  ,    context )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( params ,    null )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "List < T >    results    =    execute ( params ,    context )  ;", "return   DataAccessUtils . singleResult ( results )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( p 1  ,    null )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( new   Object [  ]  {    p 1     }  ,    context )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( p 1  ,    null )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObject ( new   Object [  ]  {    p 1     }  ,    context )  ;", "}", "METHOD_END"], "methodName": ["findObject"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   findObjectByNamedParam ( paramMap ,    null )  ;", "}", "METHOD_END"], "methodName": ["findObjectByNamedParam"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "List < T >    results    =    executeByNamedParam ( paramMap ,    context )  ;", "return   DataAccessUtils . singleResult ( results )  ;", "}", "METHOD_END"], "methodName": ["findObjectByNamedParam"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "return   this . rowsExpected ;", "}", "METHOD_END"], "methodName": ["getRowsExpected"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "this . rowsExpected    =    rowsExpected ;", "}", "METHOD_END"], "methodName": ["setRowsExpected"], "fileName": "org.springframework.jdbc.object.SqlQuery"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "given ( connection . prepareStatement (  . SELECT _ ID _ FORENAME _ NAMED _ PARAMETERS _ PARSED ,    ResultSet . TYPE _ SCROLL _ SENSITIVE ,    ResultSet . CONCUR _ READ _ ONLY )  )  . willReturn ( preparedStatement )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ FORENAME _ NAMED _ PARAMETERS )  ;", "setResultSetType ( ResultSet . TYPE _ SCROLL _ SENSITIVE )  ;", "if    ( namedDeclarations )     {", "declareParameter ( new   SqlParameter (  \" country \"  ,    Types . VARCHAR )  )  ;", "declareParameter ( new   SqlParameter (  \" id \"  ,    Types . NUMERIC )  )  ;", "} else    {", "declareParameter ( new   SqlParameter ( Types . NUMERIC )  )  ;", "declareParameter ( new   SqlParameter ( Types . VARCHAR )  )  ;", "}", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   Customer   findCustomer ( int   id ,    String   country )     {", "Map < String ,    Object >    params    =    new   HashMap <  >  (  )  ;", "params . put (  \" id \"  ,    id )  ;", "params . put (  \" country \"  ,    country )  ;", "return   executeByNamedParam ( params )  . get (  0  )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "Customer   cust    =    query . findCustomer (  1  ,     \" UK \"  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( cust . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    cust . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setString (  2  ,     \" UK \"  )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["doTestNamedParameterCustomerQuery"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "this . connection    =    mock ( Connection . class )  ;", "this . dataSource    =    mock ( DataSource . class )  ;", "this . preparedStatement    =    mock ( PreparedStatement . class )  ;", "this . resultSet    =    mock ( ResultSet . class )  ;", "given ( this . dataSource . getConnection (  )  )  . willReturn ( this . connection )  ;", "given ( this . connection . prepareStatement ( anyString (  )  )  )  . willReturn ( this . preparedStatement )  ;", "given ( preparedStatement . execute (  )  )  . willReturn ( resultSet )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "given ( connection . prepareStatement (  . SELECT _ ID _ FORENAME _ WHERE ,    ResultSet . TYPE _ SCROLL _ SENSITIVE ,    ResultSet . CONCUR _ READ _ ONLY )  )  . willReturn ( preparedStatement )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ FORENAME _ WHERE )  ;", "setResultSetType ( ResultSet . TYPE _ SCROLL _ SENSITIVE )  ;", "declareParameter ( new   SqlParameter ( Types . NUMERIC )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   Customer   findCustomer ( int   id )     {", "return   findObject ( id )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "Customer   cust    =    query . findCustomer (  1  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( cust . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    cust . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testFancyCustomerQuery"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ WHERE )  ;", "declareParameter ( new   SqlParameter ( Types . NUMERIC )  )  ;", "declareParameter ( new   SqlParameter ( Types . NUMERIC )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   Customer   findCustomer ( int   id ,    int   otherNum )     {", "return   findObject ( id ,    otherNum )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "Customer   cust    =    query . findCustomer (  1  ,     1  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( cust . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    cust . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  ,    Types . NUMERIC )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ ID _ WHERE )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testFindCustomerIntInt"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "reset ( connection )  ;", "PreparedStatement   preparedStatement 2     =    mock ( PreparedStatement . class )  ;", "ResultSet   resultSet 2     =    mock ( ResultSet . class )  ;", "given ( preparedStatement 2  . executeQuery (  )  )  . willReturn ( resultSet 2  )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "given ( resultSet 2  . next (  )  )  . willReturn ( false )  ;", "given ( connection . prepareStatement (  . SELECT _ ID _ WHERE )  )  . willReturn ( preparedStatement ,    preparedStatement 2  )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ WHERE )  ;", "declareParameter ( new   SqlParameter (  . COLUMN _ NAMES [  0  ]  ,     . COLUMN _ TYPES [  0  ]  )  )  ;", "declareParameter ( new   SqlParameter (  . COLUMN _ NAMES [  1  ]  ,     . COLUMN _ TYPES [  1  ]  )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   Customer   findCustomer ( int   id ,    String   name )     {", "return   findObject ( new   Object [  ]  {    id ,    name    }  )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "Customer   cust 1     =    query . findCustomer (  1  ,     \" rod \"  )  ;", "assertTrue (  \" Found   customer \"  ,     ( cust 1     !  =    null )  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( cust 1  . getId (  )  )     =  =     1  )  )  ;", "Customer   cust 2     =    query . findCustomer (  1  ,     \" Roger \"  )  ;", "assertTrue (  \" No   customer   found \"  ,     ( cust 2     =  =    null )  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . INTEGER )  ;", "verify ( preparedStatement )  . setString (  2  ,     \" rod \"  )  ;", "verify ( preparedStatement 2  )  . setObject (  1  ,     1  ,    Types . INTEGER )  ;", "verify ( preparedStatement 2  )  . setString (  2  ,     \" Roger \"  )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( resultSet 2  )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( preparedStatement 2  )  . close (  )  ;", "verify ( connection ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testFindCustomerMixed"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ FORENAME _ WHERE )  ;", "declareParameter ( new   SqlParameter ( Types . VARCHAR )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   Customer   findCustomer ( String   id )     {", "return   findObject ( id )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "Customer   cust    =    query . findCustomer (  \" rod \"  )  ;", "assertTrue (  \" Customer   id   was   assigned   correctly \"  ,     (  ( cust . getId (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Customer   forename   was   assigned   correctly \"  ,    cust . getForename (  )  . equals (  \" rod \"  )  )  ;", "verify ( preparedStatement )  . setString (  1  ,     \" rod \"  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ ID _ FORENAME _ WHERE )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testFindCustomerString"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  ,     2  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  ,     \" rod \"  )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ FORENAME _ WHERE )  ;", "declareParameter ( new   SqlParameter ( Types . VARCHAR )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   Customer   findCustomer ( String   id )     {", "return   findObject ( id )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "thrown . expect ( IncorrectResultSizeDataAccessException . class )  ;", "try    {", "query . findCustomer (  \" rod \"  )  ;", "}    finally    {", "verify ( preparedStatement )  . setString (  1  ,     \" rod \"  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ ID _ FORENAME _ WHERE )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testFindTooManyCustomers"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  ,     2  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  ,     \" dave \"  )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ WHERE )  ;", "declareParameter ( new   SqlParameter ( Types . NUMERIC )  )  ;", "declareParameter ( new   SqlParameter ( Types . NUMERIC )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "List < Customer >    list    =    query . execute (  1  ,     1  )  ;", "assertTrue (  \"  2    results   in   list \"  ,     (  ( list . size (  )  )     =  =     2  )  )  ;", "assertThat ( list . get (  0  )  . getForename (  )  ,    is (  \" rod \"  )  )  ;", "assertThat ( list . get (  1  )  . getForename (  )  ,    is (  \" dave \"  )  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  ,    Types . NUMERIC )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ ID _ WHERE )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testListCustomersIntInt"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  ,     2  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  ,     \" dave \"  )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ FORENAME _ WHERE )  ;", "declareParameter ( new   SqlParameter ( Types . VARCHAR )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "List < Customer >    list    =    query . execute (  \" one \"  )  ;", "assertTrue (  \"  2    results   in   list \"  ,     (  ( list . size (  )  )     =  =     2  )  )  ;", "assertThat ( list . get (  0  )  . getForename (  )  ,    is (  \" rod \"  )  )  ;", "assertThat ( list . get (  1  )  . getForename (  )  ,    is (  \" dave \"  )  )  ;", "verify ( preparedStatement )  . setString (  1  ,     \" one \"  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ ID _ FORENAME _ WHERE )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testListCustomersString"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "doTestNamedParameterCustomerQuery ( true )  ;", "}", "METHOD_END"], "methodName": ["testNamedParameterCustomerQueryWithNamedDeclarations"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "doTestNamedParameterCustomerQuery ( false )  ;", "}", "METHOD_END"], "methodName": ["testNamedParameterCustomerQueryWithUnnamedDeclarations"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  ,     2  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  ,     \" juergen \"  )  ;", "given ( connection . prepareStatement (  . SELECT _ ID _ FORENAME _ WHERE _ ID _ IN _ LIST _  1  ,    ResultSet . TYPE _ SCROLL _ SENSITIVE ,    ResultSet . CONCUR _ READ _ ONLY )  )  . willReturn ( preparedStatement )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ FORENAME _ WHERE _ ID _ IN _ LIST _  2  )  ;", "setResultSetType ( ResultSet . TYPE _ SCROLL _ SENSITIVE )  ;", "declareParameter ( new   SqlParameter (  \" ids \"  ,    Types . NUMERIC )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   List < Customer >    findCustomers ( List < Integer >    ids )     {", "Map < String ,    Object >    params    =    new   HashMap <  >  (  )  ;", "params . put (  \" ids \"  ,    ids )  ;", "return   executeByNamedParam ( params )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "List < Integer >    ids    =    new   ArrayList <  >  (  )  ;", "ids . add (  1  )  ;", "ids . add (  2  )  ;", "List < Customer >    cust    =    query . findCustomers ( ids )  ;", "assertEquals (  \" We   got   two   customers   back \"  ,     2  ,    cust . size (  )  )  ;", "assertEquals (  \" First   customer   id   was   assigned   correctly \"  ,    cust . get (  0  )  . getId (  )  ,     1  )  ;", "assertEquals (  \" First   customer   forename   was   assigned   correctly \"  ,    cust . get (  0  )  . getForename (  )  ,     \" rod \"  )  ;", "assertEquals (  \" Second   customer   id   was   assigned   correctly \"  ,    cust . get (  1  )  . getId (  )  ,     2  )  ;", "assertEquals (  \" Second   customer   forename   was   assigned   correctly \"  ,    cust . get (  1  )  . getForename (  )  ,     \" juergen \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setObject (  2  ,     2  ,    Types . NUMERIC )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testNamedParameterInListQuery"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  ,     2  )  ;", "given ( resultSet . getString (  \" forename \"  )  )  . willReturn (  \" rod \"  ,     \" juergen \"  )  ;", "given ( connection . prepareStatement (  . SELECT _ ID _ FORENAME _ WHERE _ ID _ REUSED _  1  ,    ResultSet . TYPE _ SCROLL _ SENSITIVE ,    ResultSet . CONCUR _ READ _ ONLY )  )  . willReturn ( preparedStatement )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ FORENAME _ WHERE _ ID _ REUSED _  2  )  ;", "setResultSetType ( ResultSet . TYPE _ SCROLL _ SENSITIVE )  ;", "declareParameter ( new   SqlParameter (  \" id 1  \"  ,    Types . NUMERIC )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   List < Customer >    findCustomers ( Integer   id )     {", "Map < String ,    Object >    params    =    new   HashMap <  >  (  )  ;", "params . put (  \" id 1  \"  ,    id )  ;", "return   executeByNamedParam ( params )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "List < Customer >    cust    =    query . findCustomers (  1  )  ;", "assertEquals (  \" We   got   two   customers   back \"  ,     2  ,    cust . size (  )  )  ;", "assertEquals (  \" First   customer   id   was   assigned   correctly \"  ,    cust . get (  0  )  . getId (  )  ,     1  )  ;", "assertEquals (  \" First   customer   forename   was   assigned   correctly \"  ,    cust . get (  0  )  . getForename (  )  ,     \" rod \"  )  ;", "assertEquals (  \" Second   customer   id   was   assigned   correctly \"  ,    cust . get (  1  )  . getId (  )  ,     2  )  ;", "assertEquals (  \" Second   customer   forename   was   assigned   correctly \"  ,    cust . get (  1  )  . getForename (  )  ,     \" juergen \"  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  ,    Types . NUMERIC )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testNamedParameterQueryReusingParameter"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( connection . prepareStatement ( SqlQueryTests . SELECT _ ID _ FORENAME _ WHERE _ ID _ REUSED _  1  ,    ResultSet . TYPE _ SCROLL _ SENSITIVE ,    ResultSet . CONCUR _ READ _ ONLY )  )  . willReturn ( preparedStatement )  ;", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,    SqlQueryTests . SELECT _ ID _ FORENAME _ WHERE _ ID _ REUSED _  1  )  ;", "setResultSetType ( ResultSet . TYPE _ SCROLL _ SENSITIVE )  ;", "declareParameter ( new   SqlParameter (  \" id 1  \"  ,    Types . NUMERIC )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt ( SqlQueryTests . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString ( SqlQueryTests . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   List < Customer >    findCustomers ( Integer   id 1  )     {", "Map < String ,    Integer >    params    =    new   HashMap <  >  (  )  ;", "params . put (  \" id 1  \"  ,    id 1  )  ;", "return   executeByNamedParam ( params )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "query . findCustomers (  1  )  ;", "}", "METHOD_END"], "methodName": ["testNamedParameterUsingInvalidQuestionMarkPlaceHolders"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "MappingSqlQuery < Integer >    query    =    new   MappingSqlQuery < Integer >  (  )     {", "@ Override", "protected   Integer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "return   rs . getInt (  1  )  ;", "}", "}  ;", "query . setDataSource ( dataSource )  ;", "query . setSql (  . SELECT _ ID _ WHERE )  ;", "query . declareParameter ( new   SqlParameter (  . COLUMN _ NAMES [  0  ]  ,     . COLUMN _ TYPES [  0  ]  )  )  ;", "query . declareParameter ( new   SqlParameter (  . COLUMN _ NAMES [  1  ]  ,     . COLUMN _ TYPES [  1  ]  )  )  ;", "query . compile (  )  ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "query . executeByNamedParam ( Collections . singletonMap (  . COLUMN _ NAMES [  0  ]  ,     \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithMissingMapParams"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "MappingSqlQuery < Integer >    query    =    new   MappingSqlQuery < Integer >  (  )     {", "@ Override", "protected   Integer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "return   rs . getInt (  1  )  ;", "}", "}  ;", "query . setDataSource ( dataSource )  ;", "query . setSql (  . SELECT _ ID _ WHERE )  ;", "query . declareParameter ( new   SqlParameter (  . COLUMN _ NAMES [  0  ]  ,     . COLUMN _ TYPES [  0  ]  )  )  ;", "query . declareParameter ( new   SqlParameter (  . COLUMN _ NAMES [  1  ]  ,     . COLUMN _ TYPES [  1  ]  )  )  ;", "query . compile (  )  ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "query . execute (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithoutEnoughParams"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getInt (  1  )  )  . willReturn (  1  )  ;", "SqlQuery < Integer >    query    =    new   MappingSqlQueryWithParameters < Integer >  (  )     {", "@ Override", "protected   Integer   mapRow ( ResultSet   rs ,    int   rownum ,     @ Nullable", "Object [  ]    params ,     @ Nullable", "Map <  ?  ,     ?  >    context )    throws   SQLException    {", "assertTrue (  \" params   were   null \"  ,     ( params    =  =    null )  )  ;", "assertTrue (  \" context   was   null \"  ,     ( context    =  =    null )  )  ;", "return   rs . getInt (  1  )  ;", "}", "}  ;", "query . setDataSource ( dataSource )  ;", "query . setSql (  . SELECT _ ID )  ;", "query . compile (  )  ;", "List < Integer >    list    =    query . execute (  )  ;", "assertThat ( list ,    is ( equalTo ( Arrays . asList (  1  )  )  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ ID )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testQueryWithoutParams"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    dbResults    =    new   String [  ]  {     \" alpha \"  ,     \" beta \"  ,     \" charlie \"     }  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    true ,    false )  ;", "given ( resultSet . getString (  1  )  )  . willReturn ( dbResults [  0  ]  ,    dbResults [  1  ]  ,    dbResults [  2  ]  )  ;", ". StringQuery   query    =    new    . StringQuery ( dataSource ,     . SELECT _ FORENAME )  ;", "query . setRowsExpected (  3  )  ;", "String [  ]    results    =    query . run (  )  ;", "assertThat ( results ,    is ( equalTo ( dbResults )  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ FORENAME )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testStringQueryWithResults"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( false )  ;", ". StringQuery   query    =    new    . StringQuery ( dataSource ,     . SELECT _ FORENAME _ EMPTY )  ;", "String [  ]    results    =    query . run (  )  ;", "assertThat ( results ,    is ( equalTo ( new   String [  0  ]  )  )  )  ;", "verify ( connection )  . prepareStatement (  . SELECT _ FORENAME _ EMPTY )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testStringQueryWithoutResults"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "class   CustomerQuery   extends   MappingSqlQuery < Customer >     {", "public   CustomerQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ FORENAME _ WHERE )  ;", "setResultSetType ( ResultSet . TYPE _ SCROLL _ SENSITIVE )  ;", "declareParameter ( new   SqlParameter ( Types . NUMERIC )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   mapRow ( ResultSet   rs ,    int   rownum )    throws   SQLException    {", "Customer   cust    =    new   Customer (  )  ;", "cust . setId ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  ;", "cust . setForename ( rs . getString (  . COLUMN _ NAMES [  1  ]  )  )  ;", "return   cust ;", "}", "public   Customer   findCustomer ( int   id )     {", "Map < String ,    Integer >    params    =    new   HashMap <  >  (  )  ;", "params . put (  \" id \"  ,    id )  ;", "return   executeByNamedParam ( params )  . get (  0  )  ;", "}", "}", "CustomerQuery   query    =    new   CustomerQuery ( dataSource )  ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "query . findCustomer (  1  )  ;", "}", "METHOD_END"], "methodName": ["testUnnamedParameterDeclarationWithNamedParameterQuery"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getInt (  \" id \"  )  )  . willReturn (  1  ,     2  )  ;", "given ( connection . prepareStatement (  . SELECT _ ID _ FORENAME _ WHERE _ ID ,    ResultSet . TYPE _ FORWARD _ ONLY ,    ResultSet . CONCUR _ UPDATABLE )  )  . willReturn ( preparedStatement )  ;", "class   CustomerUpdateQuery   extends   UpdatableSqlQuery < Customer >     {", "public   CustomerUpdateQuery ( DataSource   ds )     {", "super ( ds ,     . SELECT _ ID _ FORENAME _ WHERE _ ID )  ;", "declareParameter ( new   SqlParameter ( Types . NUMERIC )  )  ;", "compile (  )  ;", "}", "@ Override", "protected   Customer   updateRow ( ResultSet   rs ,    int   rownum ,     @ Nullable", "Map <  ?  ,     ?  >    context )    throws   SQLException    {", "rs . updateString (  2  ,     (  \"  \"     +     ( context . get ( rs . getInt (  . COLUMN _ NAMES [  0  ]  )  )  )  )  )  ;", "return   null ;", "}", "}", "CustomerUpdateQuery   query    =    new   CustomerUpdateQuery ( dataSource )  ;", "Map < Integer ,    String >    values    =    new   HashMap <  >  (  2  )  ;", "values . put (  1  ,     \" Rod \"  )  ;", "values . put (  2  ,     \" Thomas \"  )  ;", "query . execute (  2  ,    values )  ;", "verify ( resultSet )  . updateString (  2  ,     \" Rod \"  )  ;", "verify ( resultSet )  . updateString (  2  ,     \" Thomas \"  )  ;", "verify ( resultSet ,    times (  2  )  )  . updateRow (  )  ;", "verify ( preparedStatement )  . setObject (  1  ,     2  ,    Types . NUMERIC )  ;", "verify ( resultSet )  . close (  )  ;", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testUpdateCustomers"], "fileName": "org.springframework.jdbc.object.SqlQueryTests"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . maxRowsAffected )     >     0  )     &  &     ( rowsAffected    >     ( this . maxRowsAffected )  )  )     {", "throw   new   JdbcAffectedIncorrectNumberOfRowsException ( resolveSql (  )  ,    this . maxRowsAffected ,    rowsAffected )  ;", "}", "if    (  (  ( this . requiredRowsAffected )     >     0  )     &  &     ( rowsAffected    !  =     ( this . requiredRowsAffected )  )  )     {", "throw   new   JdbcAffectedIncorrectNumberOfRowsException ( resolveSql (  )  ,    this . requiredRowsAffected ,    rowsAffected )  ;", "}", "}", "METHOD_END"], "methodName": ["checkRowsAffected"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "this . maxRowsAffected    =    maxRowsAffected ;", "}", "METHOD_END"], "methodName": ["setMaxRowsAffected"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "this . requiredRowsAffected    =    requiredRowsAffected ;", "}", "METHOD_END"], "methodName": ["setRequiredRowsAffected"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "return   update ( new   Object [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "return   update ( new   Object [  ]  {    p 1     }  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "return   update ( new   Object [  ]  {    p 1  ,    p 2     }  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "validateParameters ( params )  ;", "int   rowsAffected    =    getJdbcTemplate (  )  . u ( newPreparedStatementCreator ( params )  )  ;", "checkRowsAffected ( rowsAffected )  ;", "return   rowsAffected ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( isReturnGeneratedKeys (  )  )  )     &  &     (  ( getGeneratedKeysColumnNames (  )  )     =  =    null )  )     {", "throw   new   InvalidDataAccessApiUsageException (  (  \" The   u   method   taking   a   KeyHolder   should   only   be   used   when   generated   keys   have    \"     +     (  \" been   configured   by   calling   either    ' setReturnGeneratedKeys '    or    \"     +     \"  ' setGeneratedKeysColumnNames '  .  \"  )  )  )  ;", "}", "validateParameters ( params )  ;", "int   rowsAffected    =    getJdbcTemplate (  )  . u ( newPreparedStatementCreator ( params )  ,    generatedKeyHolder )  ;", "checkRowsAffected ( rowsAffected )  ;", "return   rowsAffected ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "return   update ( new   Object [  ]  {    p    }  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "return   update ( new   Object [  ]  {    p 1  ,    p 2     }  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "return   update ( new   Object [  ]  {    p 1     }  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "return   update ( new   Object [  ]  {    p 1  ,    p 2     }  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "validateNamedParameters ( paramMap )  ;", "ParsedSql   parsedSql    =    getParsedSql (  )  ;", "MapSqlParameterSource   paramSource    =    new   MapSqlParameterSource ( paramMap )  ;", "String   sqlToUse    =    NamedParameterUtils . substituteNamedParameters ( parsedSql ,    paramSource )  ;", "O [  ]    params    =    NamedParameterUtils . buildValueArray ( parsedSql ,    paramSource ,    getDeclaredParameters (  )  )  ;", "int   rowsAffected    =    getJdbcTemplate (  )  . update ( newPreparedStatementCreator ( sqlToUse ,    params )  )  ;", "checkRowsAffected ( rowsAffected )  ;", "return   rowsAffected ;", "}", "METHOD_END"], "methodName": ["updateByNamedParam"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "validateNamedParameters ( paramMap )  ;", "ParsedSql   parsedSql    =    getParsedSql (  )  ;", "MapSqlParameterSource   paramSource    =    new   MapSqlParameterSource ( paramMap )  ;", "String   sqlToUse    =    NamedParameterUtils . substituteNamedParameters ( parsedSql ,    paramSource )  ;", "O [  ]    params    =    NamedParameterUtils . buildValueArray ( parsedSql ,    paramSource ,    getDeclaredParameters (  )  )  ;", "int   rowsAffected    =    getJdbcTemplate (  )  . update ( newPreparedStatementCreator ( sqlToUse ,    params )  ,    generatedKeyHolder )  ;", "checkRowsAffected ( rowsAffected )  ;", "return   rowsAffected ;", "}", "METHOD_END"], "methodName": ["updateByNamedParam"], "fileName": "org.springframework.jdbc.object.SqlUpdate"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "given ( connection . prepareStatement (  . UPDATE _ INT _ INT )  )  . willReturn ( preparedStatement )  ;", "class   NamedParameterUpdater   extends   SqlUpdate    {", "public   NamedParameterUpdater (  )     {", "setSql (  . UPDATE _ NAMED _ PARAMETERS )  ;", "setDataSource ( dataSource )  ;", "if    ( namedDeclarations )     {", "declareParameter ( new   SqlParameter (  \" priceId \"  ,    Types . DECIMAL )  )  ;", "declareParameter ( new   SqlParameter (  \" perfId \"  ,    Types . NUMERIC )  )  ;", "} else    {", "declareParameter ( new   SqlParameter ( Types . NUMERIC )  )  ;", "declareParameter ( new   SqlParameter ( Types . DECIMAL )  )  ;", "}", "compile (  )  ;", "}", "public   int   run ( int   performanceId ,    int   type )     {", "Map < String ,    Integer >    params    =    new   HashMap <  >  (  )  ;", "params . put (  \" perfId \"  ,    performanceId )  ;", "params . put (  \" priceId \"  ,    type )  ;", "return   updateByNamedParam ( params )  ;", "}", "}", "NamedParameterUpdater   pc    =    new   NamedParameterUpdater (  )  ;", "int   rowsAffected    =    pc . run (  1  ,     1  )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  ,    Types . DECIMAL )  ;", "}", "METHOD_END"], "methodName": ["doTestNamedParameterUpdate"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "dataSource    =    mock ( DataSource . class )  ;", "connection    =    mock ( Connection . class )  ;", "preparedStatement    =    mock ( PreparedStatement . class )  ;", "resultSet    =    mock ( ResultSet . class )  ;", "resultSetMetaData    =    mock ( ResultSetMetaData . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  5  )  ;", "given ( connection . prepareStatement (  . UPDATE )  )  . willReturn ( preparedStatement )  ;", ". MaxRowsUpdater   pc    =    new    . MaxRowsUpdater (  )  ;", "int   rowsAffected    =    pc . run (  )  ;", "assertEquals (  5  ,    rowsAffected )  ;", "}", "METHOD_END"], "methodName": ["testMaxRows"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "doTestNamedParameterUpdate ( true )  ;", "}", "METHOD_END"], "methodName": ["testNamedParameterUpdateWithNamedDeclarations"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "doTestNamedParameterUpdate ( false )  ;", "}", "METHOD_END"], "methodName": ["testNamedParameterUpdateWithUnnamedDeclarations"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  2  )  ;", "given ( connection . prepareStatement (  . UPDATE )  )  . willReturn ( preparedStatement )  ;", "thrown . expect ( JdbcUpdateAffectedIncorrectNumberOfRowsException . class )  ;", ". RequiredRowsUpdater   pc    =    new    . RequiredRowsUpdater (  )  ;", "pc . run (  )  ;", "}", "METHOD_END"], "methodName": ["testNotRequiredRows"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  8  )  ;", "given ( connection . prepareStatement (  . UPDATE )  )  . willReturn ( preparedStatement )  ;", ". MaxRowsUpdater   pc    =    new    . MaxRowsUpdater (  )  ;", "thrown . expect ( JdbcUpdateAffectedIncorrectNumberOfRowsException . class )  ;", "pc . run (  )  ;", "}", "METHOD_END"], "methodName": ["testOverMaxRows"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  3  )  ;", "given ( connection . prepareStatement (  . UPDATE )  )  . willReturn ( preparedStatement )  ;", ". RequiredRowsUpdater   pc    =    new    . RequiredRowsUpdater (  )  ;", "int   rowsAffected    =    pc . run (  )  ;", "assertEquals (  3  ,    rowsAffected )  ;", "}", "METHOD_END"], "methodName": ["testRequiredRows"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  3  )  ;", "given ( connection . prepareStatement (  . UPDATE )  )  . willReturn ( preparedStatement )  ;", ". MaxRowsUpdater   pc    =    new    . MaxRowsUpdater (  )  ;", "int   rowsAffected    =    pc . run (  )  ;", "assertEquals (  3  ,    rowsAffected )  ;", "}", "METHOD_END"], "methodName": ["testUnderMaxRows"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "given ( connection . prepareStatement (  . UPDATE )  )  . willReturn ( preparedStatement )  ;", ". Updater   pc    =    new    . Updater (  )  ;", "int   rowsAffected    =    pc . run (  )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "}", "METHOD_END"], "methodName": ["testUpdate"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( resultSetMetaData . getColumnCount (  )  )  . willReturn (  1  )  ;", "given ( resultSetMetaData . getColumnLabel (  1  )  )  . willReturn (  \"  1  \"  )  ;", "given ( resultSet . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet . getObject (  1  )  )  . willReturn (  1  1  )  ;", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "given ( preparedStatement . getGeneratedKeys (  )  )  . willReturn ( resultSet )  ;", "given ( connection . prepareStatement (  . INSERT _ GENERATE _ KEYS ,    PreparedStatement . RETURN _ GENERATED _ KEYS )  )  . willReturn ( preparedStatement )  ;", ". GeneratedKeysUpdater   pc    =    new    . GeneratedKeysUpdater (  )  ;", "KeyHolder   generatedKeyHolder    =    new   GeneratedKeyHolder (  )  ;", "int   rowsAffected    =    pc . run (  \" rod \"  ,    generatedKeyHolder )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "assertEquals (  1  ,    generatedKeyHolder . getKeyList (  )  . size (  )  )  ;", "assertEquals (  1  1  ,    generatedKeyHolder . getKey (  )  . intValue (  )  )  ;", "verify ( preparedStatement )  . setString (  1  ,     \" rod \"  )  ;", "verify ( resultSet )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testUpdateAndGeneratedKeys"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "given ( connection . prepareStatement (  . UPDATE _ OBJECTS )  )  . willReturn ( preparedStatement )  ;", ". ConstructorUpdater   pc    =    new    . ConstructorUpdater (  )  ;", "int   rowsAffected    =    pc . run (  1  ,     1  ,     \" rod \"  ,    true )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setString (  3  ,     \" rod \"  )  ;", "verify ( preparedStatement )  . setBoolean (  4  ,    Boolean . TRUE )  ;", "}", "METHOD_END"], "methodName": ["testUpdateConstructor"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "given ( connection . prepareStatement (  . UPDATE _ INT )  )  . willReturn ( preparedStatement )  ;", ". IntUpdater   pc    =    new    . IntUpdater (  )  ;", "int   rowsAffected    =    pc . run (  1  )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "}", "METHOD_END"], "methodName": ["testUpdateInt"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "given ( connection . prepareStatement (  . UPDATE _ INT _ INT )  )  . willReturn ( preparedStatement )  ;", ". IntIntUpdater   pc    =    new    . IntIntUpdater (  )  ;", "int   rowsAffected    =    pc . run (  1  ,     1  )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  ,    Types . NUMERIC )  ;", "}", "METHOD_END"], "methodName": ["testUpdateIntInt"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "given ( connection . prepareStatement (  . UPDATE _ OBJECTS )  )  . willReturn ( preparedStatement )  ;", ". MixedUpdater   pc    =    new    . MixedUpdater (  )  ;", "int   rowsAffected    =    pc . run (  1  ,     1  ,     \" rod \"  ,    true )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "verify ( preparedStatement )  . setObject (  1  ,     1  ,    Types . NUMERIC )  ;", "verify ( preparedStatement )  . setObject (  2  ,     1  ,    Types . NUMERIC ,     2  )  ;", "verify ( preparedStatement )  . setString (  3  ,     \" rod \"  )  ;", "verify ( preparedStatement )  . setBoolean (  4  ,    Boolean . TRUE )  ;", "}", "METHOD_END"], "methodName": ["testUpdateMixed"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "given ( preparedStatement . executeUpdate (  )  )  . willReturn (  1  )  ;", "given ( connection . prepareStatement (  . UPDATE _ STRING )  )  . willReturn ( preparedStatement )  ;", ". StringUpdater   pc    =    new    . StringUpdater (  )  ;", "int   rowsAffected    =    pc . run (  \" rod \"  )  ;", "assertEquals (  1  ,    rowsAffected )  ;", "verify ( preparedStatement )  . setString (  1  ,     \" rod \"  )  ;", "}", "METHOD_END"], "methodName": ["testUpdateString"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "verify ( preparedStatement )  . close (  )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["verifyClosed"], "fileName": "org.springframework.jdbc.object.SqlUpdateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    paramsToUse    =    new   HashMap <  >  (  )  ;", "validateParameters ( inParams )  ;", "int   i    =     0  ;", "for    ( SqlParameter   sqlParameter    :    getDeclaredParameters (  )  )     {", "if    (  ( sqlParameter . isInputValueProvided (  )  )     &  &     ( i    <     ( inParams . length )  )  )     {", "paramsToUse . put ( sqlParameter . getName (  )  ,    inParams [  ( i +  +  )  ]  )  ;", "}", "}", "return   getJdbcTemplate (  )  . call ( newCallableStatementCreator ( paramsToUse )  ,    getDeclaredParameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.StoredProcedure"}, {"methodBody": ["METHOD_START", "{", "validateParameters ( inParams . values (  )  . toArray (  )  )  ;", "return   getJdbcTemplate (  )  . call ( newCallableStatementCreator ( inParams )  ,    getDeclaredParameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.StoredProcedure"}, {"methodBody": ["METHOD_START", "{", "checkCompiled (  )  ;", "return   getJdbcTemplate (  )  . call ( newCallableStatementCreator ( inParamMapper )  ,    getDeclaredPaters (  )  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.jdbc.object.StoredProcedure"}, {"methodBody": ["METHOD_START", "{", "dataSource    =    mock ( DataSource . class )  ;", "connion    =    mock ( Connion . class )  ;", "callableStatement    =    mock ( CallableStatement . class )  ;", "given ( dataSource . getConnion (  )  )  . willReturn ( connion )  ;", "given ( callableStatement . getConnion (  )  )  . willReturn ( connion )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "StoredProcedureTests . AddInvoice   adder    =    new   StoredProcedureTests . AddInvoice ( dataSource )  ;", "int   id    =    adder . execute ( amount ,    custid )  ;", "assertEquals (  4  ,    id )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoice"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "StoredProcedureTests . AddInvoiceUsingObjectArray   adder    =    new   StoredProcedureTests . AddInvoiceUsingObjectArray ( dataSource )  ;", "int   id    =    adder . execute ( amount ,    custid )  ;", "assertEquals (  5  ,    id )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoiceUsingObjectArray"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getObject (  3  )  )  . willReturn (  4  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . AddInvoice . SQL )  )     +     \"  (  ?  ,     ?  ,     ?  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", "testAddInvoice (  1  1  0  6  ,     3  )  ;", "verify ( callableStatement )  . setObject (  1  ,     1  1  0  6  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . setObject (  2  ,     3  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . registerOutParameter (  3  ,    Types . INTEGER )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoices"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getObject (  3  )  )  . willReturn (  5  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . AddInvoice . SQL )  )     +     \"  (  ?  ,     ?  ,     ?  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", "testAddInvoiceUsingObjectArray (  1  1  0  6  ,     4  )  ;", "verify ( callableStatement )  . setObject (  1  ,     1  1  0  6  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . setObject (  2  ,     4  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . registerOutParameter (  3  ,    Types . INTEGER )  ;", "}", "METHOD_END"], "methodName": ["testAddInvoicesUsingObjectArray"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getObject (  3  )  )  . willReturn (  4  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . AddInvoice . SQL )  )     +     \"  (  ?  ,     ?  ,     ?  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", "TransactionSynchronizationManager . bindResource ( dataSource ,    new   ConnectionHolder ( connection )  )  ;", "try    {", "testAddInvoice (  1  1  0  6  ,     3  )  ;", "verify ( callableStatement )  . setObject (  1  ,     1  1  0  6  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . setObject (  2  ,     3  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . registerOutParameter (  3  ,    Types . INTEGER )  ;", "verify ( connection ,    never (  )  )  . close (  )  ;", "}    finally    {", "TransactionSynchronizationManager . unbindResource ( dataSource )  ;", "connection . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAddInvoicesWithinTransaction"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "this . verifyClosedAfter    =    false ;", ". MissingParameterStoredProcedure   mp    =    new    . MissingParameterStoredProcedure ( dataSource )  ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "mp . execute (  )  ;", "fail (  \" Shouldn ' t   succeed   in   running   stored   procedure   with   missing   required   parameter \"  )  ;", "}", "METHOD_END"], "methodName": ["testMissingParameter"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sqlException    =    new   SQLException (  \" Syntax   error   or   access   violation   exception \"  ,     \"  4  2  0  0  0  \"  )  ;", "given ( callableStatement . execute (  )  )  . willThrow ( sqlException )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . NoSuchStoredProcedure . SQL )  )     +     \"  (  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", ". NoSuchStoredProcedure   sproc    =    new    . NoSuchStoredProcedure ( dataSource )  ;", "thrown . expect ( BadSqlGrammarException . class )  ;", "sproc . execute (  )  ;", "}", "METHOD_END"], "methodName": ["testNoSuchStoredProcedure"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . NullArg . SQL )  )     +     \"  (  ?  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", ". NullArg   na    =    new    . NullArg ( dataSource )  ;", "na . execute (  (  ( String )     ( null )  )  )  ;", "callableStatement . setNull (  1  ,    Types . VARCHAR )  ;", "}", "METHOD_END"], "methodName": ["testNullArg"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getObject (  1  )  )  . willReturn ( new   BigDecimal (  \"  1  2  3  4  5  .  6  7  8  9  \"  )  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . NumericWithScaleStoredProcedure . SQL )  )     +     \"  (  ?  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", ". NumericWithScaleStoredProcedure   nwssp    =    new    . NumericWithScaleStoredProcedure ( dataSource )  ;", "Map < String ,    Object >    out    =    nwssp . executeTest (  )  ;", "assertEquals ( new   BigDecimal (  \"  1  2  3  4  5  .  6  7  8  9  \"  )  ,    out . get (  \" out \"  )  )  ;", "verify ( callableStatement )  . registerOutParameter (  1  ,    Types . DECIMAL ,     4  )  ;", "}", "METHOD_END"], "methodName": ["testNumericWithScale"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getObject (  2  )  )  . willReturn (  \" OK \"  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . ParameterMapperStoredProcedure . SQL )  )     +     \"  (  ?  ,     ?  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", ". ParameterMapperStoredProcedure   pmsp    =    new    . ParameterMapperStoredProcedure ( dataSource )  ;", "Map < String ,    Object >    out    =    pmsp . executeTest (  )  ;", "assertEquals (  \" OK \"  ,    out . get (  \" out \"  )  )  ;", "verify ( callableStatement )  . setString ( eq (  1  )  ,    startsWith (  \" Mock   for   Connection \"  )  )  ;", "verify ( callableStatement )  . registerOutParameter (  2  ,    Types . VARCHAR )  ;", "}", "METHOD_END"], "methodName": ["testParameterMapper"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "int [  ]    testVal    =    new   int [  ]  {     1  ,     2     }  ;", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getObject (  2  )  )  . willReturn (  \" OK \"  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . SqlTypeValueStoredProcedure . SQL )  )     +     \"  (  ?  ,     ?  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", ". SqlTypeValueStoredProcedure   stvsp    =    new    . SqlTypeValueStoredProcedure ( dataSource )  ;", "Map < String ,    Object >    out    =    stvsp . executeTest ( testVal )  ;", "assertEquals (  \" OK \"  ,    out . get (  \" out \"  )  )  ;", "verify ( callableStatement )  . setObject (  1  ,    testVal ,    Types . ARRAY )  ;", "verify ( callableStatement )  . registerOutParameter (  2  ,    Types . VARCHAR )  ;", "}", "METHOD_END"], "methodName": ["testSqlTypeValue"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getObject (  2  )  )  . willReturn (  4  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . StoredProcedureConfiguredViaJdbcTemplate . SQL )  )     +     \"  (  ?  ,     ?  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", "JdbcTemplate   t    =    new   JdbcTemplate (  )  ;", "t . setDataSource ( dataSource )  ;", ". StoredProcedureConfiguredViaJdbcTemplate   sp    =    new    . StoredProcedureConfiguredViaJdbcTemplate ( t )  ;", "assertEquals (  4  ,    sp . execute (  1  1  0  6  )  )  ;", "verify ( callableStatement )  . setObject (  1  ,     1  1  0  6  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . registerOutParameter (  2  ,    Types . INTEGER )  ;", "}", "METHOD_END"], "methodName": ["testStoredProcedureConfiguredViaJdbcTemplate"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "given ( callableStatement . execute (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getObject (  2  )  )  . willReturn (  5  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . StoredProcedureConfiguredViaJdbcTemplate . SQL )  )     +     \"  (  ?  ,     ?  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", "class   TestJdbcTemplate   extends   JdbcTemplate    {", "int   calls ;", "@ Override", "public   Map < String ,    Object >    call ( CallableStatementCreator   csc ,    List < SqlParameter >    declaredParameters )    throws   DataAccessException    {", "( calls )  +  +  ;", "return   super . call ( csc ,    declaredParameters )  ;", "}", "}", "TestJdbcTemplate   t    =    new   TestJdbcTemplate (  )  ;", "t . setDataSource ( dataSource )  ;", "t . setExceptionTranslator ( new   SQLStateSQLExceptionTranslator (  )  )  ;", ". StoredProcedureConfiguredViaJdbcTemplate   sp    =    new    . StoredProcedureConfiguredViaJdbcTemplate ( t )  ;", "assertEquals (  5  ,    sp . execute (  1  1  )  )  ;", "assertEquals (  1  ,    t . calls )  ;", "verify ( callableStatement )  . setObject (  1  ,     1  1  ,    Types . INTEGER )  ;", "verify ( callableStatement )  . registerOutParameter (  2  ,    Types . INTEGER )  ;", "}", "METHOD_END"], "methodName": ["testStoredProcedureConfiguredViaJdbcTemplateWithCustomExceptionTranslator"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sqlException    =    new   SQLException (  \" Syntax   error   or   access   violation   exception \"  ,     \"  4  2  0  0  0  \"  )  ;", "given ( callableStatement . execute (  )  )  . willThrow ( sqlException )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . StoredProcedureExceptionTranslator . SQL )  )     +     \"  (  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", ". StoredProcedureExceptionTranslator   sproc    =    new    . StoredProcedureExceptionTranslator ( dataSource )  ;", "thrown . expect (  . CustomDataException . class )  ;", "sproc . execute (  )  ;", "}", "METHOD_END"], "methodName": ["testStoredProcedureExceptionTranslator"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "given ( callableStatement . execute (  )  )  . willReturn ( true )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . StoredProcedureWithResultSetMapped . SQL )  )     +     \"  (  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", "JdbcTemplate   jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "jdbcTemplate . setSkipResultsProcessing ( true )  ;", ". StoredProcedureWithResultSetMapped   sproc    =    new    . StoredProcedureWithResultSetMapped ( jdbcTemplate )  ;", "Map < String ,    Object >    res    =    sproc . execute (  )  ;", "assertEquals (  \" incorrect   number   of   returns \"  ,     0  ,    res . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStoredProcedureSkippingResultsProcessing"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   resultSet    =    mock ( ResultSet . class )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getString (  2  )  )  . willReturn (  \" Foo \"  ,     \" Bar \"  )  ;", "given ( callableStatement . execute (  )  )  . willReturn ( true )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getResultSet (  )  )  . willReturn ( resultSet )  ;", "given ( callableStatement . getMoreResults (  )  )  . willReturn ( true ,    false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  ,     (  -  1  )  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . StoredProcedureWithResultSetMapped . SQL )  )     +     \"  (  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", "JdbcTemplate   jdbcTemplate    =    new   JdbcTemplate ( dataSource )  ;", "jdbcTemplate . setSkipUndeclaredResults ( true )  ;", ". StoredProcedureWithResultSetMapped   sproc    =    new    . StoredProcedureWithResultSetMapped ( jdbcTemplate )  ;", "Map < String ,    Object >    res    =    sproc . execute (  )  ;", "assertEquals (  \" incorrect   number   of   returns \"  ,     1  ,    res . size (  )  )  ;", "List < String >    rs 1     =     (  ( List < String >  )     ( res . get (  \" rs \"  )  )  )  ;", "assertEquals (  2  ,    rs 1  . size (  )  )  ;", "assertEquals (  \" Foo \"  ,    rs 1  . get (  0  )  )  ;", "assertEquals (  \" Bar \"  ,    rs 1  . get (  1  )  )  ;", "verify ( resultSet )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testStoredProcedureSkippingUndeclaredResults"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   resultSet    =    mock ( ResultSet . class )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( callableStatement . execute (  )  )  . willReturn ( true )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getResultSet (  )  )  . willReturn ( resultSet )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . StoredProcedureWithResultSet . SQL )  )     +     \"  (  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", ". StoredProcedureWithResultSet   sproc    =    new    . StoredProcedureWithResultSet ( dataSource )  ;", "sproc . execute (  )  ;", "assertEquals (  2  ,    sproc . getCount (  )  )  ;", "verify ( resultSet )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testStoredProcedureWithResultSet"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   resultSet    =    mock ( ResultSet . class )  ;", "given ( resultSet . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet . getString (  2  )  )  . willReturn (  \" Foo \"  ,     \" Bar \"  )  ;", "given ( callableStatement . execute (  )  )  . willReturn ( true )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getResultSet (  )  )  . willReturn ( resultSet )  ;", "given ( callableStatement . getMoreResults (  )  )  . willReturn ( false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . StoredProcedureWithResultSetMapped . SQL )  )     +     \"  (  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", ". StoredProcedureWithResultSetMapped   sproc    =    new    . StoredProcedureWithResultSetMapped ( dataSource )  ;", "Map < String ,    Object >    res    =    sproc . execute (  )  ;", "List < String >    rs    =     (  ( List < String >  )     ( res . get (  \" rs \"  )  )  )  ;", "assertEquals (  2  ,    rs . size (  )  )  ;", "assertEquals (  \" Foo \"  ,    rs . get (  0  )  )  ;", "assertEquals (  \" Bar \"  ,    rs . get (  1  )  )  ;", "verify ( resultSet )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testStoredProcedureWithResultSetMapped"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "ResultSet   resultSet 1     =    mock ( ResultSet . class )  ;", "given ( resultSet 1  . next (  )  )  . willReturn ( true ,    true ,    false )  ;", "given ( resultSet 1  . getString (  2  )  )  . willReturn (  \" Foo \"  ,     \" Bar \"  )  ;", "ResultSetMetaData   resultSetMetaData    =    mock ( ResultSetMetaData . class )  ;", "given ( resultSetMetaData . getColumnCount (  )  )  . willReturn (  2  )  ;", "given ( resultSetMetaData . getColumnLabel (  1  )  )  . willReturn (  \" spam \"  )  ;", "given ( resultSetMetaData . getColumnLabel (  2  )  )  . willReturn (  \" eggs \"  )  ;", "ResultSet   resultSet 2     =    mock ( ResultSet . class )  ;", "given ( resultSet 2  . getMetaData (  )  )  . willReturn ( resultSetMetaData )  ;", "given ( resultSet 2  . next (  )  )  . willReturn ( true ,    false )  ;", "given ( resultSet 2  . getObject (  1  )  )  . willReturn (  \" Spam \"  )  ;", "given ( resultSet 2  . getObject (  2  )  )  . willReturn (  \" Eggs \"  )  ;", "given ( callableStatement . execute (  )  )  . willReturn ( true )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  )  ;", "given ( callableStatement . getResultSet (  )  )  . willReturn ( resultSet 1  ,    resultSet 2  )  ;", "given ( callableStatement . getMoreResults (  )  )  . willReturn ( true ,    false ,    false )  ;", "given ( callableStatement . getUpdateCount (  )  )  . willReturn (  (  -  1  )  ,     (  -  1  )  ,     0  ,     (  -  1  )  )  ;", "given ( connection . prepareCall (  (  (  \"  { call    \"     +     (  . StoredProcedureWithResultSetMapped . SQL )  )     +     \"  (  )  }  \"  )  )  )  . willReturn ( callableStatement )  ;", ". StoredProcedureWithResultSetMapped   sproc    =    new    . StoredProcedureWithResultSetMapped ( dataSource )  ;", "Map < String ,    Object >    res    =    sproc . execute (  )  ;", "assertEquals (  \" incorrect   number   of   returns \"  ,     3  ,    res . size (  )  )  ;", "List < String >    rs 1     =     (  ( List < String >  )     ( res . get (  \" rs \"  )  )  )  ;", "assertEquals (  2  ,    rs 1  . size (  )  )  ;", "assertEquals (  \" Foo \"  ,    rs 1  . get (  0  )  )  ;", "assertEquals (  \" Bar \"  ,    rs 1  . get (  1  )  )  ;", "List < Object >    rs 2     =     (  ( List < Object >  )     ( res . get (  \"  # result - set -  2  \"  )  )  )  ;", "assertEquals (  1  ,    rs 2  . size (  )  )  ;", "Object   o 2     =    rs 2  . get (  0  )  ;", "assertTrue (  \" wron   type   returned   for   result   set    2  \"  ,     ( o 2    instanceof   Map )  )  ;", "Map < String ,    String >    m 2     =     (  ( Map < String ,    String >  )     ( o 2  )  )  ;", "assertEquals (  \" Spam \"  ,    m 2  . get (  \" spam \"  )  )  ;", "assertEquals (  \" Eggs \"  ,    m 2  . get (  \" eggs \"  )  )  ;", "Number   n    =     (  ( Number )     ( res . get (  \"  # update - count -  1  \"  )  )  )  ;", "assertEquals (  \" wrong   update   count \"  ,     0  ,    n . intValue (  )  )  ;", "verify ( resultSet 1  )  . close (  )  ;", "verify ( resultSet 2  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testStoredProcedureWithUndeclaredResults"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "this . verifyClosedAfter    =    false ;", "thrown . expect ( InvalidDataAccessApiUsageException . class )  ;", "new    . UnnamedParameterStoredProcedure ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["testUnnamedParameter"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "if    ( verifyClosedAfter )     {", "verify ( callableStatement )  . close (  )  ;", "verify ( connion ,    atLeastOnce (  )  )  . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["verifyClosed"], "fileName": "org.springframework.jdbc.object.StoredProcedureTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( task    +     \"  ;     \"  )     +     ( sql    !  =    null    ?     \" SQL    [  \"     +    sql    :     \"  ]  ;     \"     +     \"  \"  )  )     +     ( ex . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildMessage"], "fileName": "org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "return   this . fallbackTranslator ;", "}", "METHOD_END"], "methodName": ["getFallbackTranslator"], "fileName": "org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "this . fallbackTranslator    =    fallback ;", "}", "METHOD_END"], "methodName": ["setFallbackTranslator"], "fileName": "org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "return   this . errorCodes ;", "}", "METHOD_END"], "methodName": ["getErrorCodes"], "fileName": "org.springframework.jdbc.support.CustomSQLErrorCodesTranslation"}, {"methodBody": ["METHOD_START", "{", "return   this . exceptionClass ;", "}", "METHOD_END"], "methodName": ["getExceptionClass"], "fileName": "org.springframework.jdbc.support.CustomSQLErrorCodesTranslation"}, {"methodBody": ["METHOD_START", "{", "this . errorCodes    =    StringUtils . sortStringArray ( errorCodes )  ;", "}", "METHOD_END"], "methodName": ["setErrorCodes"], "fileName": "org.springframework.jdbc.support.CustomSQLErrorCodesTranslation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( exceptionClass    !  =    null )     &  &     (  !  ( DataAccessException . class . isAssignableFrom ( exceptionClass )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   exception   class    [  \"     +    exceptionClass )     +     \"  ]  :    needs   to   be   a   subclass   of    [ dao . DataAccessException ]  \"  )  )  ;", "}", "this . exceptionClass    =    exceptionClass ;", "}", "METHOD_END"], "methodName": ["setExceptionClass"], "fileName": "org.springframework.jdbc.support.CustomSQLErrorCodesTranslation"}, {"methodBody": ["METHOD_START", "{", "this . translators . putAll ( translators )  ;", "}", "METHOD_END"], "methodName": ["setTranslators"], "fileName": "org.springframework.jdbc.support.CustomSQLExceptionTranslatorRegistrar"}, {"methodBody": ["METHOD_START", "{", "new   ClassPathXmlApplicationContext (  \" test - custom - translators - context . xml \"  ,    CustomSQLExceptionTranslatorRegistrarTests . class )  ;", "SQLErrorCodes   codes    =    SQLErrorCodesFactory . getInstance (  )  . getErrorCodes (  \" H 2  \"  )  ;", "SQLErrorCodeSQLExceptionTranslator   sext    =    new   SQLErrorCodeSQLExceptionTranslator (  )  ;", "sext . setSqlErrorCodes ( codes )  ;", "DataAccessException   exFor 4  2  0  0     =    sext . doTranslate (  \"  \"  ,     \"  \"  ,    new   SQLException (  \" Ouch \"  ,     \"  4  2  0  0  0  \"  ,     4  2  0  0  0  )  )  ;", "assertNotNull (  \" Should   have   been   translated \"  ,    exFor 4  2  0  0  )  ;", "assertTrue (  \" Should   have   been   instance   of   BadSqlGrammarException \"  ,    BadSqlGrammarException . class . isAssignableFrom ( exFor 4  2  0  0  . getClass (  )  )  )  ;", "DataAccessException   exFor 2     =    sext . doTranslate (  \"  \"  ,     \"  \"  ,    new   SQLException (  \" Ouch \"  ,     \"  4  2  0  0  0  \"  ,     2  )  )  ;", "assertNotNull (  \" Should   have   been   translated \"  ,    exFor 2  )  ;", "assertTrue (  \" Should   have   been   instance   of   TransientDataAccessResourceException \"  ,    TransientDataAccessResourceException . class . isAssignableFrom ( exFor 2  . getClass (  )  )  )  ;", "DataAccessException   exFor 3     =    sext . doTranslate (  \"  \"  ,     \"  \"  ,    new   SQLException (  \" Ouch \"  ,     \"  4  2  0  0  0  \"  ,     3  )  )  ;", "assertNull (  \" Should   not   have   been   translated \"  ,    exFor 3  )  ;", "}", "METHOD_END"], "methodName": ["customErrorCodeTranslation"], "fileName": "org.springframework.jdbc.support.CustomSQLExceptionTranslatorRegistrarTests"}, {"methodBody": ["METHOD_START", "{", "return   this . translatorMap . get ( dbName )  ;", "}", "METHOD_END"], "methodName": ["findTranslatorForDatabase"], "fileName": "org.springframework.jdbc.support.CustomSQLExceptionTranslatorRegistry"}, {"methodBody": ["METHOD_START", "{", "return   CustomSQLExceptionTranslatorRegistry . instance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.jdbc.support.CustomSQLExceptionTranslatorRegistry"}, {"methodBody": ["METHOD_START", "{", "SQLExceptionTranslator   replaced    =    translatorMap . put ( dbName ,    translator )  ;", "if    ( replaced    !  =    null )     {", ". logger . warn (  (  (  (  (  (  (  \" Replacing   custom   translator    [  \"     +    replaced )     +     \"  ]    for   database    '  \"  )     +    dbName )     +     \"  '    with    [  \"  )     +    translator )     +     \"  ]  \"  )  )  ;", "} else    {", ". logger . info (  (  (  (  (  \" Adding   custom   translator   of   type    [  \"     +     ( translator . getClass (  )  . getName (  )  )  )     +     \"  ]    for   database    '  \"  )     +    dbName )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerTranslator"], "fileName": "org.springframework.jdbc.support.CustomSQLExceptionTranslatorRegistry"}, {"methodBody": ["METHOD_START", "{", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createStatement (  )  )  . willReturn ( statement )  ;", "given ( statement . executeQuery (  \" select   myseq . nextval   from   dummy \"  )  )  . willReturn ( resultSet )  ;", "given ( resultSet . next (  )  )  . willReturn ( true )  ;", "given ( resultSet . getLong (  1  )  )  . willReturn (  1  0 L ,     1  2 L )  ;", "HanaSequence   incrementer    =    new   HanaSequence (  )  ;", "incrementer . setDataSource ( dataSource )  ;", "incrementer . setIncrementerName (  \" myseq \"  )  ;", "incrementer . setPaddingLength (  2  )  ;", "incrementer . afterPropertiesSet (  )  ;", "assertEquals (  1  0  ,    incrementer . nextLongValue (  )  )  ;", "assertEquals (  \"  1  2  \"  ,    incrementer . nextStringValue (  )  )  ;", "verify ( resultSet ,    times (  2  )  )  . close (  )  ;", "verify ( statement ,    times (  2  )  )  . close (  )  ;", "verify ( connection ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testHanaSequenceMaxValueIncrementer"], "fileName": "org.springframework.jdbc.support.DataFieldMaxValueIncrementerTests"}, {"methodBody": ["METHOD_START", "{", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createStatement (  )  )  . willReturn ( statement )  ;", "given ( statement . executeQuery (  \" select   max ( identity (  )  )    from   myseq \"  )  )  . willReturn ( resultSet )  ;", "given ( resultSet . next (  )  )  . willReturn ( true )  ;", "given ( resultSet . getLong (  1  )  )  . willReturn (  0 L ,     1 L ,     2 L ,     3 L ,     4 L ,     5 L )  ;", "Hsql   incrementer    =    new   Hsql (  )  ;", "incrementer . setDataSource ( dataSource )  ;", "incrementer . setIncrementerName (  \" myseq \"  )  ;", "incrementer . setColumnName (  \" seq \"  )  ;", "incrementer . setCacheSize (  3  )  ;", "incrementer . setPaddingLength (  3  )  ;", "incrementer . afterPropertiesSet (  )  ;", "assertEquals (  0  ,    incrementer . nextIntValue (  )  )  ;", "assertEquals (  1  ,    incrementer . nextLongValue (  )  )  ;", "assertEquals (  \"  0  0  2  \"  ,    incrementer . nextStringValue (  )  )  ;", "assertEquals (  3  ,    incrementer . nextIntValue (  )  )  ;", "assertEquals (  4  ,    incrementer . nextLongValue (  )  )  ;", "verify ( statement ,    times (  6  )  )  . executeUpdate (  \" insert   into   myseq   values ( null )  \"  )  ;", "verify ( statement )  . executeUpdate (  \" delete   from   myseq   where   seq    <     2  \"  )  ;", "verify ( statement )  . executeUpdate (  \" delete   from   myseq   where   seq    <     5  \"  )  ;", "verify ( resultSet ,    times (  6  )  )  . close (  )  ;", "verify ( statement ,    times (  2  )  )  . close (  )  ;", "verify ( connection ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testHsqlMaxValueIncrementer"], "fileName": "org.springframework.jdbc.support.DataFieldMaxValueIncrementerTests"}, {"methodBody": ["METHOD_START", "{", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createStatement (  )  )  . willReturn ( statement )  ;", "given ( statement . executeQuery (  \" select   max ( identity (  )  )    from   myseq \"  )  )  . willReturn ( resultSet )  ;", "given ( resultSet . next (  )  )  . willReturn ( true )  ;", "given ( resultSet . getLong (  1  )  )  . willReturn (  0 L ,     1 L ,     2 L ,     3 L ,     4 L ,     5 L )  ;", "Hsql   incrementer    =    new   Hsql (  )  ;", "incrementer . setDataSource ( dataSource )  ;", "incrementer . setIncrementerName (  \" myseq \"  )  ;", "incrementer . setColumnName (  \" seq \"  )  ;", "incrementer . setCacheSize (  3  )  ;", "incrementer . setPaddingLength (  3  )  ;", "incrementer . setDeleteSpecificValues ( true )  ;", "incrementer . afterPropertiesSet (  )  ;", "assertEquals (  0  ,    incrementer . nextIntValue (  )  )  ;", "assertEquals (  1  ,    incrementer . nextLongValue (  )  )  ;", "assertEquals (  \"  0  0  2  \"  ,    incrementer . nextStringValue (  )  )  ;", "assertEquals (  3  ,    incrementer . nextIntValue (  )  )  ;", "assertEquals (  4  ,    incrementer . nextLongValue (  )  )  ;", "verify ( statement ,    times (  6  )  )  . executeUpdate (  \" insert   into   myseq   values ( null )  \"  )  ;", "verify ( statement )  . executeUpdate (  \" delete   from   myseq   where   seq   in    (  -  1  ,     0  ,     1  )  \"  )  ;", "verify ( statement )  . executeUpdate (  \" delete   from   myseq   where   seq   in    (  2  ,     3  ,     4  )  \"  )  ;", "verify ( resultSet ,    times (  6  )  )  . close (  )  ;", "verify ( statement ,    times (  2  )  )  . close (  )  ;", "verify ( connection ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testHsqlMaxValueIncrementerWithDeleteSpecificValues"], "fileName": "org.springframework.jdbc.support.DataFieldMaxValueIncrementerTests"}, {"methodBody": ["METHOD_START", "{", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createStatement (  )  )  . willReturn ( statement )  ;", "given ( statement . executeQuery (  \" select   last _ insert _ id (  )  \"  )  )  . willReturn ( resultSet )  ;", "given ( resultSet . next (  )  )  . willReturn ( true )  ;", "given ( resultSet . getLong (  1  )  )  . willReturn (  2 L ,     4 L )  ;", "MySQL   incrementer    =    new   MySQL (  )  ;", "incrementer . setDataSource ( dataSource )  ;", "incrementer . setIncrementerName (  \" myseq \"  )  ;", "incrementer . setColumnName (  \" seq \"  )  ;", "incrementer . setCacheSize (  2  )  ;", "incrementer . setPaddingLength (  1  )  ;", "incrementer . afterPropertiesSet (  )  ;", "assertEquals (  1  ,    incrementer . nextIntValue (  )  )  ;", "assertEquals (  2  ,    incrementer . nextLongValue (  )  )  ;", "assertEquals (  \"  3  \"  ,    incrementer . nextStringValue (  )  )  ;", "assertEquals (  4  ,    incrementer . nextLongValue (  )  )  ;", "verify ( statement ,    times (  2  )  )  . executeUpdate (  \" update   myseq   set   seq    =    last _ insert _ id ( seq    +     2  )  \"  )  ;", "verify ( resultSet ,    times (  2  )  )  . close (  )  ;", "verify ( statement ,    times (  2  )  )  . close (  )  ;", "verify ( connection ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testMySQLMaxValueIncrementer"], "fileName": "org.springframework.jdbc.support.DataFieldMaxValueIncrementerTests"}, {"methodBody": ["METHOD_START", "{", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createStatement (  )  )  . willReturn ( statement )  ;", "given ( statement . executeQuery (  \" select   myseq . nextval   from   dual \"  )  )  . willReturn ( resultSet )  ;", "given ( resultSet . next (  )  )  . willReturn ( true )  ;", "given ( resultSet . getLong (  1  )  )  . willReturn (  1  0 L ,     1  2 L )  ;", "OracleSequence   incrementer    =    new   OracleSequence (  )  ;", "incrementer . setDataSource ( dataSource )  ;", "incrementer . setIncrementerName (  \" myseq \"  )  ;", "incrementer . setPaddingLength (  2  )  ;", "incrementer . afterPropertiesSet (  )  ;", "assertEquals (  1  0  ,    incrementer . nextLongValue (  )  )  ;", "assertEquals (  \"  1  2  \"  ,    incrementer . nextStringValue (  )  )  ;", "verify ( resultSet ,    times (  2  )  )  . close (  )  ;", "verify ( statement ,    times (  2  )  )  . close (  )  ;", "verify ( connection ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testOracleSequenceMaxValueIncrementer"], "fileName": "org.springframework.jdbc.support.DataFieldMaxValueIncrementerTests"}, {"methodBody": ["METHOD_START", "{", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "given ( connection . createStatement (  )  )  . willReturn ( statement )  ;", "given ( statement . executeQuery (  \" select   nextval (  ' myseq '  )  \"  )  )  . willReturn ( resultSet )  ;", "given ( resultSet . next (  )  )  . willReturn ( true )  ;", "given ( resultSet . getLong (  1  )  )  . willReturn (  1  0 L ,     1  2 L )  ;", "PostgresSequence   incrementer    =    new   PostgresSequence (  )  ;", "incrementer . setDataSource ( dataSource )  ;", "incrementer . setIncrementerName (  \" myseq \"  )  ;", "incrementer . setPaddingLength (  5  )  ;", "incrementer . afterPropertiesSet (  )  ;", "assertEquals (  \"  0  0  0  1  0  \"  ,    incrementer . nextStringValue (  )  )  ;", "assertEquals (  1  2  ,    incrementer . nextIntValue (  )  )  ;", "verify ( resultSet ,    times (  2  )  )  . close (  )  ;", "verify ( statement ,    times (  2  )  )  . close (  )  ;", "verify ( connection ,    times (  2  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testPostgresSequenceMaxValueIncrementer"], "fileName": "org.springframework.jdbc.support.DataFieldMaxValueIncrementerTests"}, {"methodBody": ["METHOD_START", "{", "this . dataSource    =    dataSource ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.jdbc.support.DatabaseStartupValidator"}, {"methodBody": ["METHOD_START", "{", "this . interval    =    interval ;", "}", "METHOD_END"], "methodName": ["setInterval"], "fileName": "org.springframework.jdbc.support.DatabaseStartupValidator"}, {"methodBody": ["METHOD_START", "{", "this . timeout    =    timeout ;", "}", "METHOD_END"], "methodName": ["setTimeout"], "fileName": "org.springframework.jdbc.support.DatabaseStartupValidator"}, {"methodBody": ["METHOD_START", "{", "this . validationQuery    =    validationQuery ;", "}", "METHOD_END"], "methodName": ["setValidationQuery"], "fileName": "org.springframework.jdbc.support.DatabaseStartupValidator"}, {"methodBody": ["METHOD_START", "{", "lobHandler . getBlobAsBinaryStream ( rs ,     1  )  ;", "verify ( rs )  . getBinaryStream (  1  )  ;", "}", "METHOD_END"], "methodName": ["testGetBlobAsBinaryStream"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "lobHandler . getBlobAsBytes ( rs ,     1  )  ;", "verify ( rs )  . getBytes (  1  )  ;", "}", "METHOD_END"], "methodName": ["testGetBlobAsBytes"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "lobHandler . getClobAsAsciiStream ( rs ,     1  )  ;", "verify ( rs )  . getAsciiStream (  1  )  ;", "}", "METHOD_END"], "methodName": ["testGetClobAsAsciiStream"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "lobHandler . getClobAsCharacterStream ( rs ,     1  )  ;", "verify ( rs )  . getCharacterStream (  1  )  ;", "}", "METHOD_END"], "methodName": ["testGetClobAsCharacterStream"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "lobHandler . getClobAsString ( rs ,     1  )  ;", "verify ( rs )  . getString (  1  )  ;", "}", "METHOD_END"], "methodName": ["testGetClobAsString"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   bis    =    new   ByteArrayInputStream (  \" testContent \"  . getBytes (  )  )  ;", "lobCreator . setBlobAsBinaryStream ( ps ,     1  ,    bis ,     1  1  )  ;", "verify ( ps )  . setBinaryStream (  1  ,    bis ,     1  1  )  ;", "}", "METHOD_END"], "methodName": ["testSetBlobAsBinaryStream"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   bis    =    new   ByteArrayInputStream (  \" testContent \"  . getBytes (  )  )  ;", "lobCreator . setBlobAsBinaryStream ( ps ,     1  ,    bis ,     (  -  1  )  )  ;", "verify ( ps )  . setBinaryStream (  1  ,    bis )  ;", "}", "METHOD_END"], "methodName": ["testSetBlobAsBinaryStreamWithoutLength"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    content    =     \" testContent \"  . getBytes (  )  ;", "lobCreator . setBlobAsBytes ( ps ,     1  ,    content )  ;", "verify ( ps )  . setBytes (  1  ,    content )  ;", "}", "METHOD_END"], "methodName": ["testSetBlobAsBytes"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   bis    =    new   ByteArrayInputStream (  \" testContent \"  . getBytes (  )  )  ;", "lobCreator . setClobAsAsciiStream ( ps ,     1  ,    bis ,     1  1  )  ;", "verify ( ps )  . setAsciiStream (  1  ,    bis ,     1  1  )  ;", "}", "METHOD_END"], "methodName": ["testSetClobAsAsciiStream"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   bis    =    new   ByteArrayInputStream (  \" testContent \"  . getBytes (  )  )  ;", "lobCreator . setClobAsAsciiStream ( ps ,     1  ,    bis ,     (  -  1  )  )  ;", "verify ( ps )  . setAsciiStream (  1  ,    bis )  ;", "}", "METHOD_END"], "methodName": ["testSetClobAsAsciiStreamWithoutLength"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Reader   str    =    new   StringReader (  \" testContent \"  )  ;", "lobCreator . setClobAsCharacterStream ( ps ,     1  ,    str ,     1  1  )  ;", "verify ( ps )  . setCharacterStream (  1  ,    str ,     1  1  )  ;", "}", "METHOD_END"], "methodName": ["testSetClobAsCharacterStream"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Reader   str    =    new   StringReader (  \" testContent \"  )  ;", "lobCreator . setClobAsCharacterStream ( ps ,     1  ,    str ,     (  -  1  )  )  ;", "verify ( ps )  . setCharacterStream (  1  ,    str )  ;", "}", "METHOD_END"], "methodName": ["testSetClobAsCharacterStreamWithoutLength"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   content    =     \" testContent \"  ;", "lobCreator . setClobAsString ( ps ,     1  ,    content )  ;", "verify ( ps )  . setString (  1  ,    content )  ;", "}", "METHOD_END"], "methodName": ["testSetClobAsString"], "fileName": "org.springframework.jdbc.support.DefaultLobHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . dataSource ;", "}", "METHOD_END"], "methodName": ["getDataSource"], "fileName": "org.springframework.jdbc.support.JdbcAccessor"}, {"methodBody": ["METHOD_START", "{", "SQLExceptionTranslator   exceptionTranslator    =    this . exceptionTranslator ;", "if    ( exceptionTranslator    !  =    null )     {", "return   exceptionTranslator ;", "}", "synchronized ( this )     {", "exceptionTranslator    =    this . exceptionTranslator ;", "if    ( exceptionTranslator    =  =    null )     {", "DataSource   dataSource    =    getDataSource (  )  ;", "if    ( dataSource    !  =    null )     {", "exceptionTranslator    =    new   SQLErrorCodeSQLExceptionTranslator ( dataSource )  ;", "} else    {", "exceptionTranslator    =    new   SQLStateSQLExceptionTranslator (  )  ;", "}", "this . exceptionTranslator    =    exceptionTranslator ;", "}", "return   exceptionTranslator ;", "}", "}", "METHOD_END"], "methodName": ["getExceptionTranslator"], "fileName": "org.springframework.jdbc.support.JdbcAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . lazyInit ;", "}", "METHOD_END"], "methodName": ["isLazyInit"], "fileName": "org.springframework.jdbc.support.JdbcAccessor"}, {"methodBody": ["METHOD_START", "{", "DataSource   dataSource    =    getDataSource (  )  ;", "Assestate (  ( dataSource    !  =    null )  ,     \" No   DataSource   set \"  )  ;", "return   dataSource ;", "}", "METHOD_END"], "methodName": ["obtainDataSource"], "fileName": "org.springframework.jdbc.support.JdbcAccessor"}, {"methodBody": ["METHOD_START", "{", "this . dataSource    =    dataSource ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.jdbc.support.JdbcAccessor"}, {"methodBody": ["METHOD_START", "{", "this . exceptionTranslator    =    new   SQLErrorCodeSQLExceptionTranslator ( dbName )  ;", "}", "METHOD_END"], "methodName": ["setDatabaseProductName"], "fileName": "org.springframework.jdbc.support.JdbcAccessor"}, {"methodBody": ["METHOD_START", "{", "this . exceptionTranslator    =    exceptionTranslator ;", "}", "METHOD_END"], "methodName": ["setExceptionTranslator"], "fileName": "org.springframework.jdbc.support.JdbcAccessor"}, {"methodBody": ["METHOD_START", "{", "this . lazyInit    =    lazyInit ;", "}", "METHOD_END"], "methodName": ["setLazyInit"], "fileName": "org.springframework.jdbc.support.JdbcAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( con    !  =    null )     {", "try    {", "con . close (  )  ;", "}    catch    ( SQLException   ex )     {", ". logger . debug (  \" Could   not   close   JDBC   Connection \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . debug (  \" Unexpected   exception   on   closing   JDBC   Connection \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeConnection"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( rs    !  =    null )     {", "try    {", "rs . close (  )  ;", "}    catch    ( SQLException   ex )     {", ". logger . trace (  \" Could   not   close   JDBC   ResultSet \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . trace (  \" Unexpected   exception   on   closing   JDBC   ResultSet \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeResultSet"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( stmt    !  =    null )     {", "try    {", "stmt . close (  )  ;", "}    catch    ( SQLException   ex )     {", ". logger . trace (  \" Could   not   close   JDBC   Statement \"  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", ". logger . trace (  \" Unexpected   exception   on   closing   JDBC   Statement \"  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["closeStatement"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "String   name    =    source ;", "if    (  ( source    !  =    null )     &  &     ( source . startsWith (  \" DB 2  \"  )  )  )     {", "name    =     \" DB 2  \"  ;", "} else", "if    (  (  (  (  \" Sybase   SQL   Server \"  . equals ( source )  )     |  |     (  \" Adaptive   Server   Enterprise \"  . equals ( source )  )  )     |  |     (  \" ASE \"  . equals ( source )  )  )     |  |     (  \" sql   server \"  . equalsIgnoreCase ( source )  )  )     {", "name    =     \" Sybase \"  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["commonDatabaseName"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "boolean   nextIsUpper    =    false ;", "if    (  ( name    !  =    null )     &  &     (  ( name . length (  )  )     >     0  )  )     {", "if    (  (  ( name . length (  )  )     >     1  )     &  &     (  ( name . charAt (  1  )  )     =  =     '  _  '  )  )     {", "result . append ( Character . toUpperCase ( name . charAt (  0  )  )  )  ;", "} else    {", "result . append ( Character . toLowerCase ( name . charAt (  0  )  )  )  ;", "}", "for    ( int   i    =     1  ;    i    <     ( name . length (  )  )  ;    i +  +  )     {", "char   c    =    name . charAt ( i )  ;", "if    ( c    =  =     '  _  '  )     {", "nextIsUpper    =    true ;", "} else    {", "if    ( nextIsUpper )     {", "result . append ( Character . toUpperCase ( c )  )  ;", "nextIsUpper    =    false ;", "} else    {", "result . append ( Character . toLowerCase ( c )  )  ;", "}", "}", "}", "}", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["convertUnderscoreNameToPropertyName"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( JdbcUtils . extractDatabaseMetaData ( dataSource ,     (    dbmd )     -  >     {", "try    {", "return   DatabaseMetaData . class . getMethod ( metaDataMethodName )  . invoke ( dbmd )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   MetaDataAccessException (  (  (  (  (  \" No   method   named    '  \"     +    metaDataMethodName )     +     \"  '    found   on   DatabaseMetaData   instance    [  \"  )     +    dbmd )     +     \"  ]  \"  )  ,    ex )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   MetaDataAccessException (  (  (  \" Could   not   access   DatabaseMetaData   method    '  \"     +    metaDataMethodName )     +     \"  '  \"  )  ,    ex )  ;", "}    catch    ( InvocationTargetException   ex )     {", "if    (  ( ex . getTargetException (  )  )    instanceof   SQLException )     {", "throw    (  ( SQLException )     ( ex . getTargetException (  )  )  )  ;", "}", "throw   new   MetaDataAccessException (  (  (  \" Invocation   of   DatabaseMetaData   method    '  \"     +    metaDataMethodName )     +     \"  '    failed \"  )  ,    ex )  ;", "}", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["extractDatabaseMetaData"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "Connection   con    =    null ;", "try    {", "con    =    DataSource . getConnection ( dataSource )  ;", "DatabaseMetaData   metaData    =    con . getMetaData (  )  ;", "if    ( metaData    =  =    null )     {", "throw   new   MetaDataAccessException (  (  (  \" DatabaseMetaData   returned   by   Connection    [  \"     +    con )     +     \"  ]    was   null \"  )  )  ;", "}", "return   action . processMetaData ( metaData )  ;", "}    catch    ( CannotGetJdbcConnectionException   ex )     {", "throw   new   MetaDataAccessException (  \" Could   not   get   Connection   for   extracting   meta - data \"  ,    ex )  ;", "}    catch    ( SQLException   ex )     {", "throw   new   MetaDataAccessException (  \" Error   while   extracting   DatabaseMetaData \"  ,    ex )  ;", "}    catch    ( AbstractMethodError   err )     {", "throw   new   MetaDataAccessException (  \" JDBC   DatabaseMetaData   method   not   implemented   by   JDBC   driver    -    upgrade   your   driver \"  ,    err )  ;", "}    finally    {", "DataSource . releaseConnection ( con ,    dataSource )  ;", "}", "}", "METHOD_END"], "methodName": ["extractDatabaseMetaData"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "Object   obj    =    rs . getObject ( index )  ;", "St   className    =    null ;", "if    ( obj    !  =    null )     {", "className    =    obj . getClass (  )  . getName (  )  ;", "}", "if    ( obj   instanceof   Blob )     {", "Blob   blob    =     (  ( Blob )     ( obj )  )  ;", "obj    =    blob . getBytes (  1  ,     (  ( int )     ( blob . length (  )  )  )  )  ;", "} else", "if    ( obj   instanceof   Clob )     {", "Clob   clob    =     (  ( Clob )     ( obj )  )  ;", "obj    =    clob . getSubSt (  1  ,     (  ( int )     ( clob . length (  )  )  )  )  ;", "} else", "if    (  (  \" oracle . sql . TIMESTAMP \"  . equals ( className )  )     |  |     (  \" oracle . sql . TIMESTAMPTZ \"  . equals ( className )  )  )     {", "obj    =    rs . getTimestamp ( index )  ;", "} else", "if    (  ( className    !  =    null )     &  &     ( className . startsWith (  \" oracle . sql . DATE \"  )  )  )     {", "St   metaDataClassName    =    rs . getMetaData (  )  . getColumnClassName ( index )  ;", "if    (  (  \" Timestamp \"  . equals ( metaDataClassName )  )     |  |     (  \" oracle . sql . TIMESTAMP \"  . equals ( metaDataClassName )  )  )     {", "obj    =    rs . getTimestamp ( index )  ;", "} else    {", "obj    =    rs . getDate ( index )  ;", "}", "} else", "if    ( obj   instanceof   Date )     {", "if    (  \" Timestamp \"  . equals ( rs . getMetaData (  )  . getColumnClassName ( index )  )  )     {", "obj    =    rs . getTimestamp ( index )  ;", "}", "}", "return   obj ;", "}", "METHOD_END"], "methodName": ["getResultSetValue"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( requiredType    =  =    null )     {", "return   JdbcUtils . getResultSetValue ( rs ,    index )  ;", "}", "Object   value ;", "if    (  ( String . class )     =  =    requiredType )     {", "return   rs . getString ( index )  ;", "} else", "if    (  (  ( boolean . class )     =  =    requiredType )     |  |     (  ( Boolean . class )     =  =    requiredType )  )     {", "value    =    rs . getBoolean ( index )  ;", "} else", "if    (  (  ( byte . class )     =  =    requiredType )     |  |     (  ( Byte . class )     =  =    requiredType )  )     {", "value    =    rs . getByte ( index )  ;", "} else", "if    (  (  ( short . class )     =  =    requiredType )     |  |     (  ( Short . class )     =  =    requiredType )  )     {", "value    =    rs . getShort ( index )  ;", "} else", "if    (  (  ( int . class )     =  =    requiredType )     |  |     (  ( Integer . class )     =  =    requiredType )  )     {", "value    =    rs . getInt ( index )  ;", "} else", "if    (  (  ( long . class )     =  =    requiredType )     |  |     (  ( Long . class )     =  =    requiredType )  )     {", "value    =    rs . getLong ( index )  ;", "} else", "if    (  (  ( float . class )     =  =    requiredType )     |  |     (  ( Float . class )     =  =    requiredType )  )     {", "value    =    rs . getFloat ( index )  ;", "} else", "if    (  (  (  ( double . class )     =  =    requiredType )     |  |     (  ( Double . class )     =  =    requiredType )  )     |  |     (  ( Number . class )     =  =    requiredType )  )     {", "value    =    rs . getDouble ( index )  ;", "} else", "if    (  ( class )     =  =    requiredType )     {", "return   rs . getBigDecimal ( index )  ;", "} else", "if    (  ( class )     =  =    requiredType )     {", "return   rs . getDate ( index )  ;", "} else", "if    (  ( class )     =  =    requiredType )     {", "return   rs . getTime ( index )  ;", "} else", "if    (  (  ( class )     =  =    requiredType )     |  |     (  ( class )     =  =    requiredType )  )     {", "return   rs . getTimestamp ( index )  ;", "} else", "if    (  ( byte [  ]  . class )     =  =    requiredType )     {", "return   rs . getBytes ( index )  ;", "} else", "if    (  ( class )     =  =    requiredType )     {", "return   rs . getBlob ( index )  ;", "} else", "if    (  ( class )     =  =    requiredType )     {", "return   rs . getClob ( index )  ;", "} else", "if    ( requiredType . isEnum (  )  )     {", "Object   obj    =    rs . getObject ( index )  ;", "if    ( obj   instanceof   String )     {", "return   obj ;", "} else", "if    ( obj   instanceof   Number )     {", "return   util . NumberUtils . convertNumberToTargetClass (  (  ( Number )     ( obj )  )  ,    Integer . class )  ;", "} else    {", "return   rs . getString ( index )  ;", "}", "} else    {", "try    {", "return   rs . getObject ( index ,    requiredType )  ;", "}    catch    ( AbstractMethodError   err )     {", "JdbcUtils . logger . debug (  \" JDBC   driver   does   not   implement   JDBC    4  .  1     ' getObject ( int ,    Class )  '    method \"  ,    err )  ;", "}    catch    ( SQLFeatureNotSupportedException   ex )     {", "JdbcUtils . logger . debug (  \" JDBC   driver   does   not   support   JDBC    4  .  1     ' getObject ( int ,    Class )  '    method \"  ,    ex )  ;", "}    catch    ( SQLException   ex )     {", "JdbcUtils . logger . debug (  \" JDBC   driver   has   limited   support   for   JDBC    4  .  1     ' getObject ( int ,    Class )  '    method \"  ,    ex )  ;", "}", "String   typeName    =    requiredType . getSimpleName (  )  ;", "if    (  \" LocalDate \"  . equals ( typeName )  )     {", "return   rs . getDate ( index )  ;", "} else", "if    (  \" LocalTime \"  . equals ( typeName )  )     {", "return   rs . getTime ( index )  ;", "} else", "if    (  \" LocalDateTime \"  . equals ( typeName )  )     {", "return   rs . getTimestamp ( index )  ;", "}", "return   JdbcUtils . getResultSetValue ( rs ,    index )  ;", "}", "return   rs . wasNull (  )     ?    null    :    value ;", "}", "METHOD_END"], "methodName": ["getResultSetValue"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  ( Types . BIT )     =  =    sqlType )     |  |     (  ( Types . BIGINT )     =  =    sqlType )  )     |  |     (  ( Types . DECIMAL )     =  =    sqlType )  )     |  |     (  ( Types . DOUBLE )     =  =    sqlType )  )     |  |     (  ( Types . FLOAT )     =  =    sqlType )  )     |  |     (  ( Types . INTEGER )     =  =    sqlType )  )     |  |     (  ( Types . NUMERIC )     =  =    sqlType )  )     |  |     (  ( Types . REAL )     =  =    sqlType )  )     |  |     (  ( Types . SMALLINT )     =  =    sqlType )  )     |  |     (  ( Types . TINYINT )     =  =    sqlType )  ;", "}", "METHOD_END"], "methodName": ["isNumeric"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "String   name    =    resultSetMetaData . getColumnLabel ( columnIndex )  ;", "if    (  ( name    =  =    null )     |  |     (  ( name . length (  )  )     <     1  )  )     {", "name    =    resultSetMetaData . getColumnName ( columnIndex )  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["lookupColumnName"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "DatabaseMetaData   dbmd    =    con . getMetaData (  )  ;", "if    ( dbmd    !  =    null )     {", "if    ( dbmd . supportsBatchUpdates (  )  )     {", ". logger . debug (  \" JDBC   driver   supports   batch   updates \"  )  ;", "return   true ;", "} else    {", ". logger . debug (  \" JDBC   driver   does   not   support   batch   updates \"  )  ;", "}", "}", "}    catch    ( SQLException   ex )     {", ". logger . debug (  \" JDBC   driver    ' supportsBatchUpdates '    method   threw   exception \"  ,    ex )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["supportsBatchUpdates"], "fileName": "org.springframework.jdbc.support.JdbcUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Oracle \"  ,    JdbcUtils . commonDatabaseName (  \" Oracle \"  )  )  ;", "assertEquals (  \" DB 2  \"  ,    JdbcUtils . commonDatabaseName (  \" DB 2  - for - Spring \"  )  )  ;", "assertEquals (  \" Sybase \"  ,    JdbcUtils . commonDatabaseName (  \" Sybase   SQL   Server \"  )  )  ;", "assertEquals (  \" Sybase \"  ,    JdbcUtils . commonDatabaseName (  \" Adaptive   Server   Enterprise \"  )  )  ;", "assertEquals (  \" MySQL \"  ,    JdbcUtils . commonDatabaseName (  \" MySQL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["commonDatabaseName"], "fileName": "org.springframework.jdbc.support.JdbcUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" myName \"  ,    JdbcUtils . convertUnderscoreNameToPropertyName (  \" MY _ NAME \"  )  )  ;", "assertEquals (  \" yourName \"  ,    JdbcUtils . convertUnderscoreNameToPropertyName (  \" yOUR _ nAME \"  )  )  ;", "assertEquals (  \" AName \"  ,    JdbcUtils . convertUnderscoreNameToPropertyName (  \" a _ name \"  )  )  ;", "assertEquals (  \" someoneElsesName \"  ,    JdbcUtils . convertUnderscoreNameToPropertyName (  \" someone _ elses _ name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertUnderscoreNameToPropertyName"], "fileName": "org.springframework.jdbc.support.JdbcUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    m    =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" key \"  ,     1  )  ;", "put (  \" seq \"  ,     2  )  ;", "}", "}  ;", "kh . getKeyList (  )  . addAll ( Arrays . asList ( m ,    m )  )  ;", "assertEquals (  \" two   rows   should   be   in   the   list \"  ,     2  ,    kh . getKeyList (  )  . size (  )  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "exception . expectMessage ( startsWith (  \" The   getKeys   method   should   only   be   used   when   keys   for   a   single   row   are   returned .  \"  )  )  ;", "kh . getKeys (  )  ;", "}", "METHOD_END"], "methodName": ["multipleKeyRows"], "fileName": "org.springframework.jdbc.support.KeyHolderTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    m    =    new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" key \"  ,     1  )  ;", "put (  \" seq \"  ,     2  )  ;", "}", "}  ;", "kh . getKeyList (  )  . addAll ( Collections . singletonList ( m )  )  ;", "assertEquals (  \" two   keys   should   be   in   the   map \"  ,     2  ,    kh . getKeys (  )  . size (  )  )  ;", "exception . expect ( InvalidDataAccessApiUsageException . class )  ;", "exception . expectMessage ( startsWith (  \" The   getKey   method   should   only   be   used   when   a   single   key   is   returned .  \"  )  )  ;", "kh . getKey (  )  ;", "}", "METHOD_END"], "methodName": ["multipleKeys"], "fileName": "org.springframework.jdbc.support.KeyHolderTests"}, {"methodBody": ["METHOD_START", "{", "kh . getKeyList (  )  . addAll ( Collections . singletonList ( Collections . emptyMap (  )  )  )  ;", "exception . expect ( DataRetrievalFailureException . class )  ;", "exception . expectMessage ( startsWith (  \" Unable   to   retrieve   the   generated   key .  \"  )  )  ;", "kh . getKey (  )  ;", "}", "METHOD_END"], "methodName": ["noKeyReturnedInMap"], "fileName": "org.springframework.jdbc.support.KeyHolderTests"}, {"methodBody": ["METHOD_START", "{", "kh . getKeyList (  )  . addAll ( Collections . singletonList ( Collections . singletonMap (  \" key \"  ,     1  )  )  )  ;", "assertEquals (  \" single   key   should   be   returned \"  ,     1  ,    kh . getKey (  )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["singleKey"], "fileName": "org.springframework.jdbc.support.KeyHolderTests"}, {"methodBody": ["METHOD_START", "{", "kh . getKeyList (  )  . addAll ( Collections . singletonList ( Collections . singletonMap (  \" key \"  ,     \"  1  \"  )  )  )  ;", "exception . expect ( DataRetrievalFailureException . class )  ;", "exception . expectMessage ( startsWith (  \" The   generated   key   is   not   of   a   ed   numeric   type .  \"  )  )  ;", "kh . getKey (  )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["singleKeyNonNumeric"], "fileName": "org.springframework.jdbc.support.KeyHolderTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "int   constructorType    =     0  ;", "Constructor <  ?  >  [  ]    constructors    =    exceptionClass . getConstructors (  )  ;", "for    ( Constructor <  ?  >    constructor    :    constructors )     {", "Class <  ?  >  [  ]    parameterTypes    =    constructor . getParameterTypes (  )  ;", "if    (  (  (  ( parameterTypes . length )     =  =     1  )     &  &     (  ( String . class )     =  =     ( parameterTypes [  0  ]  )  )  )     &  &     ( constructorType    <     (  . MESSAGE _ ONLY _ CONSTRUCTOR )  )  )     {", "constructorType    =     . MESSAGE _ ONLY _ CONSTRUCTOR ;", "}", "if    (  (  (  (  ( parameterTypes . length )     =  =     2  )     &  &     (  ( String . class )     =  =     ( parameterTypes [  0  ]  )  )  )     &  &     (  ( Throwable . class )     =  =     ( parameterTypes [  1  ]  )  )  )     &  &     ( constructorType    <     (  . MESSAGE _ THROWABLE _ CONSTRUCTOR )  )  )     {", "constructorType    =     . MESSAGE _ THROWABLE _ CONSTRUCTOR ;", "}", "if    (  (  (  (  ( parameterTypes . length )     =  =     2  )     &  &     (  ( String . class )     =  =     ( parameterTypes [  0  ]  )  )  )     &  &     (  ( SQLException . class )     =  =     ( parameterTypes [  1  ]  )  )  )     &  &     ( constructorType    <     (  . MESSAGE _ SQLEX _ CONSTRUCTOR )  )  )     {", "constructorType    =     . MESSAGE _ SQLEX _ CONSTRUCTOR ;", "}", "if    (  (  (  (  (  ( parameterTypes . length )     =  =     3  )     &  &     (  ( String . class )     =  =     ( parameterTypes [  0  ]  )  )  )     &  &     (  ( String . class )     =  =     ( parameterTypes [  1  ]  )  )  )     &  &     (  ( Throwable . class )     =  =     ( parameterTypes [  2  ]  )  )  )     &  &     ( constructorType    <     (  . MESSAGE _ SQL _ THROWABLE _ CONSTRUCTOR )  )  )     {", "constructorType    =     . MESSAGE _ SQL _ THROWABLE _ CONSTRUCTOR ;", "}", "if    (  (  (  (  (  ( parameterTypes . length )     =  =     3  )     &  &     (  ( String . class )     =  =     ( parameterTypes [  0  ]  )  )  )     &  &     (  ( String . class )     =  =     ( parameterTypes [  1  ]  )  )  )     &  &     (  ( SQLException . class )     =  =     ( parameterTypes [  2  ]  )  )  )     &  &     ( constructorType    <     (  . MESSAGE _ SQL _ SQLEX _ CONSTRUCTOR )  )  )     {", "constructorType    =     . MESSAGE _ SQL _ SQLEX _ CONSTRUCTOR ;", "}", "}", "Constructor <  ?  >    exceptionConstructor ;", "switch    ( constructorType )     {", "case    . MESSAGE _ SQL _ SQLEX _ CONSTRUCTOR    :", "Class <  ?  >  [  ]    messageAndSqlAndSqlExArgsClass    =    new   Class <  ?  >  [  ]  {    String . class ,    String . class ,    SQLException . class    }  ;", "Object [  ]    messageAndSqlAndSqlExArgs    =    new   Object [  ]  {    task ,    sql ,    sqlEx    }  ;", "exceptionConstructor    =    exceptionClass . getConstructor ( messageAndSqlAndSqlExArgsClass )  ;", "return    (  ( DataAccessException )     ( exceptionConstructor . newInstance ( messageAndSqlAndSqlExArgs )  )  )  ;", "case    . MESSAGE _ SQL _ THROWABLE _ CONSTRUCTOR    :", "Class <  ?  >  [  ]    messageAndSqlAndThrowableArgsClass    =    new   Class <  ?  >  [  ]  {    String . class ,    String . class ,    Throwable . class    }  ;", "Object [  ]    messageAndSqlAndThrowableArgs    =    new   Object [  ]  {    task ,    sql ,    sqlEx    }  ;", "exceptionConstructor    =    exceptionClass . getConstructor ( messageAndSqlAndThrowableArgsClass )  ;", "return    (  ( DataAccessException )     ( exceptionConstructor . newInstance ( messageAndSqlAndThrowableArgs )  )  )  ;", "case    . MESSAGE _ SQLEX _ CONSTRUCTOR    :", "Class <  ?  >  [  ]    messageAndSqlExArgsClass    =    new   Class <  ?  >  [  ]  {    String . class ,    SQLException . class    }  ;", "Object [  ]    messageAndSqlExArgs    =    new   Object [  ]  {     ( task    +     \"  :     \"  )     +     ( sqlEx . getMessage (  )  )  ,    sqlEx    }  ;", "exceptionConstructor    =    exceptionClass . getConstructor ( messageAndSqlExArgsClass )  ;", "return    (  ( DataAccessException )     ( exceptionConstructor . newInstance ( messageAndSqlExArgs )  )  )  ;", "case    . MESSAGE _ THROWABLE _ CONSTRUCTOR    :", "Class <  ?  >  [  ]    messageAndThrowableArgsClass    =    new   Class <  ?  >  [  ]  {    String . class ,    Throwable . class    }  ;", "Object [  ]    messageAndThrowableArgs    =    new   Object [  ]  {     ( task    +     \"  :     \"  )     +     ( sqlEx . getMessage (  )  )  ,    sqlEx    }  ;", "exceptionConstructor    =    exceptionClass . getConstructor ( messageAndThrowableArgsClass )  ;", "return    (  ( DataAccessException )     ( exceptionConstructor . newInstance ( messageAndThrowableArgs )  )  )  ;", "case    . MESSAGE _ ONLY _ CONSTRUCTOR    :", "Class <  ?  >  [  ]    messageOnlyArgsClass    =    new   Class <  ?  >  [  ]  {    String . class    }  ;", "Object [  ]    messageOnlyArgs    =    new   Object [  ]  {     ( task    +     \"  :     \"  )     +     ( sqlEx . getMessage (  )  )     }  ;", "exceptionConstructor    =    exceptionClass . getConstructor ( messageOnlyArgsClass )  ;", "return    (  ( DataAccessException )     ( exceptionConstructor . newInstance ( messageOnlyArgs )  )  )  ;", "default    :", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Unable   to   find   appropriate   constructor   of   custom   exception   class    [  \"     +     ( exceptionClass . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return   null ;", "}", "}    catch    ( Throwable   ex )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  \" Unable   to   instantiate   custom   exception   class    [  \"     +     ( exceptionClass . getName (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["createCustomException"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["customTranslate"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "return   this . sqlErrorCodes ;", "}", "METHOD_END"], "methodName": ["getSqlErrorCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "String   intro    =     ( custom )     ?     \" Custom   translation   of \"     :     \" Translating \"  ;", "logger . debug (  (  (  (  (  (  (  (  (  (  (  ( intro    +     \"       with   SQL   state    '  \"  )     +     ( sqlEx . getSQLState (  )  )  )     +     \"  '  ,    error   code    '  \"  )     +     ( sqlEx . getErrorCode (  )  )  )     +     \"  '  ,    message    [  \"  )     +     ( sqlEx . getMessage (  )  )  )     +     \"  ]  \"  )     +     ( sql    !  =    null    ?     (  \"  ;    SQL   was    [  \"     +    sql )     +     \"  ]  \"     :     \"  \"  )  )     +     \"    for   task    [  \"  )     +    task )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["logTranslation"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "this . sqlErrorCodes    =    SQLErrorCodesFactory . getInstance (  )  . getErrorCodes ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "this . sqlErrorCodes    =    SQLErrorCodesFactory . getInstance (  )  . getErrorCodes ( dbName )  ;", "}", "METHOD_END"], "methodName": ["setDatabaseProductName"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "this . sqlErrorCodes    =    sec ;", "}", "METHOD_END"], "methodName": ["setSqlErrorCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "SQLExceptionTranslator   sext    =    new   SQLErrorCodeSQLExceptionTranslator ( SQLErrorCodeSQLExceptionTranslatorTests . ERROR _ CODES )  ;", "SQLException   badSqlEx    =    new   SQLException (  \"  \"  ,     \"  \"  ,     1  )  ;", "BatchUpdateException   batchUpdateEx    =    new   BatchUpdateException (  )  ;", "batchUpdateEx . setNextException ( badSqlEx )  ;", "BadSqlGrammarException   bsgex    =     (  ( BadSqlGrammarException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    batchUpdateEx )  )  )  ;", "assertEquals (  \" SQL \"  ,    bsgex . getSql (  )  )  ;", "assertEquals ( badSqlEx ,    bsgex . getSQLException (  )  )  ;", "}", "METHOD_END"], "methodName": ["batchExceptionTranslation"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sex    =    new   SQLException (  \"  \"  ,     \"  \"  ,    errorCode )  ;", "DataAccessException   ex    =    sext . translate (  \"  \"  ,     \"  \"  ,    sex )  ;", "assertTrue ( exClass . isInstance ( ex )  )  ;", "assertTrue (  (  ( ex . getCause (  )  )     =  =    sex )  )  ;", "}", "METHOD_END"], "methodName": ["checkTranslation"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "final   String   TASK    =     \" TASK \"  ;", "final   String   SQL    =     \" SQL   SELECT    *  \"  ;", "final   SQLErrorCodes   customErrorCodes    =    new   SQLErrorCodes (  )  ;", "final   CustomSQLErrorCodesTranslation   customTranslation    =    new   CustomSQLErrorCodesTranslation (  )  ;", "customErrorCodes . setBadSqlGrammarCodes ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"     }  )  ;", "customErrorCodes . setDataIntegrityViolationCodes ( new   String [  ]  {     \"  3  \"  ,     \"  4  \"     }  )  ;", "customTranslation . setErrorCodes ( new   String [  ]  {     \"  1  \"     }  )  ;", "customTranslation . setExceptionClass ( CustomErrorCodeException . class )  ;", "customErrorCodes . setCustomTranslations ( new   CustomSQLErrorCodesTranslation [  ]  {    customTranslation    }  )  ;", "sext    =    new    (  )  ;", "sext . setSqlErrorCodes ( customErrorCodes )  ;", "SQLException   badSqlEx    =    new   SQLException (  \"  \"  ,     \"  \"  ,     1  )  ;", "assertEquals ( CustomErrorCodeException . class ,    sext . translate ( TASK ,    SQL ,    badSqlEx )  . getClass (  )  )  ;", "assertEquals ( badSqlEx ,    sext . translate ( TASK ,    SQL ,    badSqlEx )  . getCause (  )  )  ;", "SQLException   invResEx    =    new   SQLException (  \"  \"  ,     \"  \"  ,     3  )  ;", "DataIntegrityViolationException   diex    =     (  ( DataIntegrityViolationException )     ( sext . translate ( TASK ,    SQL ,    invResEx )  )  )  ;", "assertEquals ( invResEx ,    diex . getCause (  )  )  ;", "exception . expect ( IllegalArgumentException . class )  ;", "customTranslation . setExceptionClass ( String . class )  ;", "}", "METHOD_END"], "methodName": ["customExceptionTranslation"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "final   String   TASK    =     \" TASK \"  ;", "final   String   SQL    =     \" SQL   SELECT    *  \"  ;", "final   DataAccessException   customDex    =    new   DataAccessException (  \"  \"  )     {  }  ;", "final   SQLException   badSqlEx    =    new   SQLException (  \"  \"  ,     \"  \"  ,     1  )  ;", "SQLException   intVioEx    =    new   SQLException (  \"  \"  ,     \"  \"  ,     6  )  ;", "SQLErrorCodeSQLExceptionTranslator   sext    =    new   SQLErrorCodeSQLExceptionTranslator (  )     {", "@ Override", "@ Nullable", "protected   DataAccessException   customTranslate ( String   task ,     @ Nullable", "String   sql ,    SQLException   sqlex )     {", "assertEquals ( TASK ,    task )  ;", "assertEquals ( SQL ,    sql )  ;", "return   sqlex    =  =    badSqlEx    ?    customDex    :    null ;", "}", "}  ;", "sext . setSqlErrorCodes (  . ERROR _ CODES )  ;", "assertEquals ( customDex ,    sext . translate ( TASK ,    SQL ,    badSqlEx )  )  ;", "DataIntegrityViolationException   diex    =     (  ( DataIntegrityViolationException )     ( sext . translate ( TASK ,    SQL ,    intVioEx )  )  )  ;", "assertEquals ( intVioEx ,    diex . getCause (  )  )  ;", "}", "METHOD_END"], "methodName": ["customTranslateMethodTranslation"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "SQLExceptionTranslator   sext    =    new   SQLErrorCodeSQLExceptionTranslator ( SQLErrorCodeSQLExceptionTranslatorTests . ERROR _ CODES )  ;", "SQLException   dataAccessEx    =    new   SQLException (  \"  \"  ,     \"  \"  ,     5  )  ;", "DataTruncation   dataTruncation    =    new   DataTruncation (  1  ,    true ,    true ,     1  ,     1  ,    dataAccessEx )  ;", "DataAccessResourceFailureException   daex    =     (  ( DataAccessResourceFailureException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    dataTruncation )  )  )  ;", "assertEquals ( dataTruncation ,    daex . getCause (  )  )  ;", "}", "METHOD_END"], "methodName": ["dataTruncationTranslation"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "SQLExceptionTranslator   sext    =    new   SQLErrorCodeSQLExceptionTranslator ( SQLErrorCodeSQLExceptionTranslatorTests . ERROR _ CODES )  ;", "SQLException   badSqlEx    =    new   SQLException (  \"  \"  ,     \"  \"  ,     1  )  ;", "BadSqlGrammarException   bsgex    =     (  ( BadSqlGrammarException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    badSqlEx )  )  )  ;", "assertEquals (  \" SQL \"  ,    bsgex . getSql (  )  )  ;", "assertEquals ( badSqlEx ,    bsgex . getSQLException (  )  )  ;", "SQLException   invResEx    =    new   SQLException (  \"  \"  ,     \"  \"  ,     4  )  ;", "InvalidResultSetAccessException   irsex    =     (  ( InvalidResultSetAccessException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    invResEx )  )  )  ;", "assertEquals (  \" SQL \"  ,    irsex . getSql (  )  )  ;", "assertEquals ( invResEx ,    irsex . getSQLException (  )  )  ;", "checkTranslation ( sext ,     5  ,    DataAccessResourceFailureException . class )  ;", "checkTranslation ( sext ,     6  ,    DataIntegrityViolationException . class )  ;", "checkTranslation ( sext ,     7  ,    CannotAcquireLockException . class )  ;", "checkTranslation ( sext ,     8  ,    DeadlockLoserDataAccessException . class )  ;", "checkTranslation ( sext ,     9  ,    CannotSerializeTransactionException . class )  ;", "checkTranslation ( sext ,     1  0  ,    DuplicateKeyException . class )  ;", "SQLException   dupKeyEx    =    new   SQLException (  \"  \"  ,     \"  \"  ,     1  0  )  ;", "DataAccessException   dksex    =    sext . translate (  \" task \"  ,     \" SQL \"  ,    dupKeyEx )  ;", "assertTrue (  \" Not   instance   of   DataIntegrityViolationException \"  ,    DataIntegrityViolationException . class . isAssignableFrom ( dksex . getClass (  )  )  )  ;", "SQLException   sex    =    new   SQLException (  \"  \"  ,     \"  0  7 xxx \"  ,     6  6  6  6  6  6  6  6  6  )  ;", "BadSqlGrammarException   bsgex 2     =     (  ( BadSqlGrammarException )     ( sext . translate (  \" task \"  ,     \" SQL 2  \"  ,    sex )  )  )  ;", "assertEquals (  \" SQL 2  \"  ,    bsgex 2  . getSql (  )  )  ;", "assertEquals ( sex ,    bsgex 2  . getSQLException (  )  )  ;", "}", "METHOD_END"], "methodName": ["errorCodeTranslation"], "fileName": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . badSqlGrammarCodes ;", "}", "METHOD_END"], "methodName": ["getBadSqlGrammarCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . cannotAcquireLockCodes ;", "}", "METHOD_END"], "methodName": ["getCannotAcquireLockCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . cannotSerializeTransactionCodes ;", "}", "METHOD_END"], "methodName": ["getCannotSerializeTransactionCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . customSqlExceptionTranslator ;", "}", "METHOD_END"], "methodName": ["getCustomSqlExceptionTranslator"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . customTranslations ;", "}", "METHOD_END"], "methodName": ["getCustomTranslations"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . dataAccessResourceFailureCodes ;", "}", "METHOD_END"], "methodName": ["getDataAccessResourceFailureCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . dataIntegrityViolationCodes ;", "}", "METHOD_END"], "methodName": ["getDataIntegrityViolationCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . databaseProductNames )     !  =    null )     &  &     (  ( this . databaseProductNames . length )     >     0  )     ?    this . databaseProductNames [  0  ]     :    null ;", "}", "METHOD_END"], "methodName": ["getDatabaseProductName"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . databaseProductNames ;", "}", "METHOD_END"], "methodName": ["getDatabaseProductNames"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . deadlockLoserCodes ;", "}", "METHOD_END"], "methodName": ["getDeadlockLoserCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   duplicateKeyCodes ;", "}", "METHOD_END"], "methodName": ["getDuplicateKeyCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . invalidResultSetAccessCodes ;", "}", "METHOD_END"], "methodName": ["getInvalidResultSetAccessCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . permissionDeniedCodes ;", "}", "METHOD_END"], "methodName": ["getPermissionDeniedCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . transientDataAccessResourceCodes ;", "}", "METHOD_END"], "methodName": ["getTransientDataAccessResourceCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "return   this . useSqlStateForTranslation ;", "}", "METHOD_END"], "methodName": ["isUseSqlStateForTranslation"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . badSqlGrammarCodes    =    StringUtils . sortStringArray ( badSqlGrammarCodes )  ;", "}", "METHOD_END"], "methodName": ["setBadSqlGrammarCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . cannotAcquireLockCodes    =    StringUtils . sortStringArray ( cannotAcquireLockCodes )  ;", "}", "METHOD_END"], "methodName": ["setCannotAcquireLockCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . cannotSerializeTransactionCodes    =    StringUtils . sortStringArray ( cannotSerializeTransactionCodes )  ;", "}", "METHOD_END"], "methodName": ["setCannotSerializeTransactionCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . customSqlExceptionTranslator    =    customSqlExceptionTranslator ;", "}", "METHOD_END"], "methodName": ["setCustomSqlExceptionTranslator"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "if    ( customTranslatorClass    !  =    null )     {", "try    {", "this . customSqlExceptionTranslator    =    ReflectionUtils . accessibleConstructor ( customTranslatorClass )  . newInstance (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" Unable   to   instantiate   custom   translator \"  ,    ex )  ;", "}", "} else    {", "this . customSqlExceptionTranslator    =    null ;", "}", "}", "METHOD_END"], "methodName": ["setCustomSqlExceptionTranslatorClass"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . customTranslations    =    customTranslations ;", "}", "METHOD_END"], "methodName": ["setCustomTranslations"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . dataAccessResourceFailureCodes    =    StringUtils . sortStringArray ( dataAccessResourceFailureCodes )  ;", "}", "METHOD_END"], "methodName": ["setDataAccessResourceFailureCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . dataIntegrityViolationCodes    =    StringUtils . sortStringArray ( dataIntegrityViolationCodes )  ;", "}", "METHOD_END"], "methodName": ["setDataIntegrityViolationCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . databaseProductNames    =    new   String [  ]  {    databaseProductName    }  ;", "}", "METHOD_END"], "methodName": ["setDatabaseProductName"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . databaseProductNames    =    databaseProductNames ;", "}", "METHOD_END"], "methodName": ["setDatabaseProductNames"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . deadlockLoserCodes    =    StringUtils . sortStringArray ( deadlockLoserCodes )  ;", "}", "METHOD_END"], "methodName": ["setDeadlockLoserCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . duplicateKeyCodes    =    duplicateKeyCodes ;", "}", "METHOD_END"], "methodName": ["setDuplicateKeyCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . invalidResultSetAccessCodes    =    StringUtils . sortStringArray ( invalidResultSetAccessCodes )  ;", "}", "METHOD_END"], "methodName": ["setInvalidResultSetAccessCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . permissionDeniedCodes    =    StringUtils . sortStringArray ( permissionDeniedCodes )  ;", "}", "METHOD_END"], "methodName": ["setPermissionDeniedCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . transientDataAccessResourceCodes    =    StringUtils . sortStringArray ( transientDataAccessResourceCodes )  ;", "}", "METHOD_END"], "methodName": ["setTransientDataAccessResourceCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "this . useSqlStateForTranslation    =    useStateCodeForTranslation ;", "}", "METHOD_END"], "methodName": ["setUseSqlStateForTranslation"], "fileName": "org.springframework.jdbc.support.SQLErrorCodes"}, {"methodBody": ["METHOD_START", "{", "SQLExceptionTranslator   customTranslator    =    CustomSQLExceptionTranslatorRegistry . getInstance (  )  . findTranslatorForDatabase ( databaseName )  ;", "if    ( customTranslator    !  =    null )     {", "if    (  (  ( errorCodes . getCustomSqlExceptionTranslator (  )  )     !  =    null )     &  &     (  . logger . isWarnEnabled (  )  )  )     {", ". logger . warn (  (  (  (  (  (  (  \" Overriding   already   defined   custom   translator    '  \"     +     ( errorCodes . getCustomSqlExceptionTranslator (  )  . getClass (  )  . getSimpleName (  )  )  )     +     \"    with    '  \"  )     +     ( customTranslator . getClass (  )  . getSimpleName (  )  )  )     +     \"  '    found   in   the   CustomSQLExceptionTranslatorRegistry   for   database    '  \"  )     +    databaseName )     +     \"  '  \"  )  )  ;", "} else", "if    (  . logger . isInfoEnabled (  )  )     {", ". logger . info (  (  (  (  (  \" Using   custom   translator    '  \"     +     ( customTranslator . getClass (  )  . getSimpleName (  )  )  )     +     \"  '    found   in   the   CustomSQLExceptionTranslatorRegistry   for   database    '  \"  )     +    databaseName )     +     \"  '  \"  )  )  ;", "}", "errorCodes . setCustomSqlExceptionTranslator ( customTranslator )  ;", "}", "}", "METHOD_END"], "methodName": ["checkCustomTranslatorRegistry"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( databaseName ,     \" Database   product   name   must   not   be   null \"  )  ;", "SQLErrorCodes   sec    =    this . errorCodesMap . get ( databaseName )  ;", "if    ( sec    =  =    null )     {", "for    ( SQLErrorCodes   candidate    :    this . errorCodesMap . values (  )  )     {", "if    ( PatternMatchUtils . simpleMatch ( candidate . getDatabaseProductNames (  )  ,    databaseName )  )     {", "sec    =    candidate ;", "break ;", "}", "}", "}", "if    ( sec    !  =    null )     {", "checkCustomTranslatorRegistry ( databaseName ,    sec )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" SQL   error   codes   for    '  \"     +    databaseName )     +     \"  '    found \"  )  )  ;", "}", "return   sec ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" SQL   error   codes   for    '  \"     +    databaseName )     +     \"  '    not   found \"  )  )  ;", "}", "return   new   SQLErrorCodes (  )  ;", "}", "METHOD_END"], "methodName": ["getErrorCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( dataSource ,     \" DataSource   must   not   be   null \"  )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Looking   up   default   SQLErrorCodes   for   DataSource    [  \"     +     ( identify ( dataSource )  )  )     +     \"  ]  \"  )  )  ;", "}", "SQLErrorCodes   sec    =    this . dataSourceCache . get ( dataSource )  ;", "if    ( sec    =  =    null )     {", "synchronized ( this . dataSourceCache )     {", "sec    =    this . dataSourceCache . get ( dataSource )  ;", "if    ( sec    =  =    null )     {", "try    {", "String   name    =    JdbcUtils . extractDatabaseMetaData ( dataSource ,     \" getDatabaseProductName \"  )  ;", "if    ( StringUtils . hasLength ( name )  )     {", "return   registerDatabase ( dataSource ,    name )  ;", "}", "}    catch    ( MetaDataAccessException   ex )     {", ". logger . warn (  \" Error   while   extracting   database   name    -    falling   back   to   empty   error   codes \"  ,    ex )  ;", "}", "return   new   SQLErrorCodes (  )  ;", "}", "}", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" SQLErrorCodes   found   in   cache   for   DataSource    [  \"     +     ( identify ( dataSource )  )  )     +     \"  ]  \"  )  )  ;", "}", "return   sec ;", "}", "METHOD_END"], "methodName": ["getErrorCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactory"}, {"methodBody": ["METHOD_START", "{", "return   SQLErrorCodesFactory . instance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( dataSource . getClass (  )  . getName (  )  )     +     '  @  '  )     +     ( Integer . toHexString ( dataSource . hashCode (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["identify"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassPathResource ( path ,    getClass (  )  . getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadResource"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactory"}, {"methodBody": ["METHOD_START", "{", "SQLErrorCodes   sec    =    getErrorCodes ( databaseName )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  \" Caching   SQL   error   codes   for   DataSource    [  \"     +     ( identify ( dataSource )  )  )     +     \"  ]  :    database   product   name   is    '  \"  )     +    databaseName )     +     \"  '  \"  )  )  ;", "}", "this . dataSourceCache . put ( dataSource ,    sec )  ;", "return   sec ;", "}", "METHOD_END"], "methodName": ["registerDatabase"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . dataSourceCache . remove ( dataSource )  ;", "}", "METHOD_END"], "methodName": ["unregisterDatabase"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactory"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  ( sec . getBadSqlGrammarCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( sec . getDataIntegrityViolationCodes (  )  . length )     >     0  )  )  ;", "assertFalse (  (  ( Arrays . binarySearch ( sec . getBadSqlGrammarCodes (  )  ,     \"  9  4  2  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGrammarCodes (  )  ,     \"  -  2  0  4  \"  )  )     >  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertIsDB2"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    sec . getBadSqlGrammarCodes (  )  . length )  ;", "assertEquals (  0  ,    sec . getDataIntegrityViolationCodes (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["assertIsEmpty"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  ( sec . getBadSqlGrammarCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( sec . getDataIntegrityViolationCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGrammarCodes (  )  ,     \"  3  6  8  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getPermissionDeniedCodes (  )  ,     \"  1  0  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDuplicateKeyCodes (  )  ,     \"  3  0  1  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDataIntegrityViolationCodes (  )  ,     \"  4  6  1  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDataAccessResourceFailureCodes (  )  ,     \"  -  8  1  3  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getInvalidResultSetAccessCodes (  )  ,     \"  5  8  2  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getCannotAcquireLockCodes (  )  ,     \"  1  3  1  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getCannotSerializeTransactionCodes (  )  ,     \"  1  3  8  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDeadlockLoserCodes (  )  ,     \"  1  3  3  \"  )  )     >  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertIsHana"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  ( sec . getBadSqlGrammarCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( sec . getDataIntegrityViolationCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGrammarCodes (  )  ,     \"  -  2  2  \"  )  )     >  =     0  )  )  ;", "assertFalse (  (  ( Arrays . binarySearch ( sec . getBadSqlGrammarCodes (  )  ,     \"  -  9  \"  )  )     >  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertIsHsql"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  ( sec . getBadSqlGrammarCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( sec . getDataIntegrityViolationCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGrammarCodes (  )  ,     \"  9  4  2  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGrammarCodes (  )  ,     \"  6  5  5  0  \"  )  )     >  =     0  )  )  ;", "assertFalse (  (  ( Arrays . binarySearch ( sec . getBadSqlGrammarCodes (  )  ,     \"  9 xx 4  2  \"  )  )     >  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertIsOracle"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( sec . getDatabaseProductName (  )  ,    equalTo (  \" Microsoft   SQL   Server \"  )  )  ;", "assertTrue (  (  ( sec . getBadSqlGramma (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGramma (  )  ,     \"  1  5  6  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGramma (  )  ,     \"  1  7  0  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGramma (  )  ,     \"  2  0  7  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGramma (  )  ,     \"  2  0  8  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getBadSqlGramma (  )  ,     \"  2  0  9  \"  )  )     >  =     0  )  )  ;", "assertFalse (  (  ( Arrays . binarySearch ( sec . getBadSqlGramma (  )  ,     \"  9 xx 4  2  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( sec . getPermissionDeniedCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getPermissionDeniedCodes (  )  ,     \"  2  2  9  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( sec . getDuplicateKeyCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDuplicateKeyCodes (  )  ,     \"  2  6  0  1  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDuplicateKeyCodes (  )  ,     \"  2  6  2  7  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( sec . getDataIntegrityViolationCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDataIntegrityViolationCodes (  )  ,     \"  5  4  4  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDataIntegrityViolationCodes (  )  ,     \"  8  1  1  4  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDataIntegrityViolationCodes (  )  ,     \"  8  1  1  5  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( sec . getDataAccessResourceFailureCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDataAccessResourceFailureCodes (  )  ,     \"  4  0  6  0  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( sec . getCannotAcquireLockCodes (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getCannotAcquireLockCodes (  )  ,     \"  1  2  2  2  \"  )  )     >  =     0  )  )  ;", "assertTrue (  (  ( sec . getDeadlockLose (  )  . length )     >     0  )  )  ;", "assertTrue (  (  ( Arrays . binarySearch ( sec . getDeadlockLose (  )  ,     \"  1  2  0  5  \"  )  )     >  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertIsSQLServer"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DatabaseMetaData   databaseMetaData    =    mock ( DatabaseMetaData . class )  ;", "given ( databaseMetaData . getDatabaseProductName (  )  )  . willReturn ( productName )  ;", "Connection   connection    =    mock ( Connection . class )  ;", "given ( connection . getMetaData (  )  )  . willReturn ( databaseMetaData )  ;", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "secf    =    null ;", "if    ( factory    !  =    null )     {", "secf    =    factory ;", "} else    {", "secf    =     . getInstance (  )  ;", "}", "SQLErrorCodes   sec    =    secf . getErrorCodes ( dataSource )  ;", "SQLErrorCodes   sec 2     =    secf . getErrorCodes ( dataSource )  ;", "assertSame (  \" Cached   per   DataSource \"  ,    sec 2  ,    sec )  ;", "verify ( connection )  . close (  )  ;", "return   sec ;", "}", "METHOD_END"], "methodName": ["getErrorCodesFromDataSource"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SQLErrorCodes   sec    =    getErrorCodesFromDataSource (  \" DB 2  \"  ,    null )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB 2  /  \"  ,    null )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB -  2  \"  ,    null )  ;", "assertIsEmpty ( sec )  ;", "}", "METHOD_END"], "methodName": ["testDB2RecognizedFromMetadata"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Connection   connection    =    mock ( Connection . class )  ;", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "given ( dataSource . getConnection (  )  )  . willReturn ( connection )  ;", "SQLErrorCodes   sec    =     . getInstance (  )  . getErrorCodes ( dataSource )  ;", "assertIsEmpty ( sec )  ;", "verify ( connection )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testDataSourceWithNullMetadata"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SQLErrorCodes   sec    =    SQLErrorCodesFactory . getInstance (  )  . getErrorCodes (  \" xx \"  )  ;", "assertTrue (  (  ( sec . getBadSqlGrammarCodes (  )  . length )     =  =     0  )  )  ;", "assertTrue (  (  ( sec . getDataIntegrityViolationCodes (  )  . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultInstanceWithNoSuchDatabase"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SQLErrorCodes   sec    =    SQLErrorCodesFactory . getInstance (  )  . getErrorCodes (  \" Oracle \"  )  ;", "assertIsOracle ( sec )  ;", "}", "METHOD_END"], "methodName": ["testDefaultInstanceWithOracle"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "class   TestSQLErrorCodesFactory   extends   SQLErrorCodesFactory    {", "@ Override", "protected   Resource   loadResource ( String   path )     {", "if    ( SQLErrorCodesFactory . SQL _ ERROR _ CODE _ OVERRIDE _ PATH . equals ( path )  )     {", "return   new   ClassPathResource (  \" custom - error - codes . xml \"  ,     . class )  ;", "}", "return   null ;", "}", "}", "TestSQLErrorCodesFactory   sf    =    new   TestSQLErrorCodesFactory (  )  ;", "assertEquals (  1  ,    sf . getErrorCodes (  \" Oracle \"  )  . getCustomTranslations (  )  . length )  ;", "CustomSQLErrorCodesTranslation   translation    =    sf . getErrorCodes (  \" Oracle \"  )  . getCustomTranslations (  )  [  0  ]  ;", "assertEquals ( CustomErrorCodeException . class ,    translation . getExceptionClass (  )  )  ;", "assertEquals (  1  ,    translation . getErrorCodes (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testFindCustomCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "class   TestSQLErrorCodesFactory   extends   SQLErrorCodesFactory    {", "@ Override", "protected   Resource   loadResource ( String   path )     {", "if    ( SQLErrorCodesFactory . SQL _ ERROR _ CODE _ OVERRIDE _ PATH . equals ( path )  )     {", "return   new   ClassPathResource (  \" test - error - codes . xml \"  ,     . class )  ;", "}", "return   null ;", "}", "}", "TestSQLErrorCodesFactory   sf    =    new   TestSQLErrorCodesFactory (  )  ;", "assertTrue (  (  ( sf . getErrorCodes (  \" XX \"  )  . getBadSqlGrammarCodes (  )  . length )     =  =     0  )  )  ;", "assertEquals (  2  ,    sf . getErrorCodes (  \" Oracle \"  )  . getBadSqlGrammarCodes (  )  . length )  ;", "assertEquals (  \"  1  \"  ,    sf . getErrorCodes (  \" Oracle \"  )  . getBadSqlGrammarCodes (  )  [  0  ]  )  ;", "assertEquals (  \"  2  \"  ,    sf . getErrorCodes (  \" Oracle \"  )  . getBadSqlGrammarCodes (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testFindUserDefinedCodes"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   expectedSQLException    =    new   SQLException (  )  ;", "DataSource   dataSource    =    mock ( DataSource . class )  ;", "given ( dataSource . getConnection (  )  )  . willThrow ( expectedSQLException )  ;", "SQLErrorCodes   sec    =     . getInstance (  )  . getErrorCodes ( dataSource )  ;", "assertIsEmpty ( sec )  ;", "}", "METHOD_END"], "methodName": ["testGetFromDataSourceWithSQLException"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SQLErrorCodes   sec    =    getErrorCodesFromDataSource (  \" SAP   DB \"  ,    null )  ;", "assertIsHana ( sec )  ;", "}", "METHOD_END"], "methodName": ["testHanaIsRecognizedFromMetadata"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SQLErrorCodes   sec    =    getErrorCodesFromDataSource (  \" HSQL   Database   Engine \"  ,    null )  ;", "assertIsHsql ( sec )  ;", "}", "METHOD_END"], "methodName": ["testHsqlRecognizedFromMetadata"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "class   TestSQLErrorCodesFactory   extends   SQLErrorCodesFactory    {", "@ Override", "protected   Resource   loadResource ( String   path )     {", "if    ( SQLErrorCodesFactory . SQL _ ERROR _ CODE _ OVERRIDE _ PATH . equals ( path )  )     {", "return   new   ClassPathResource (  \" SQLExceptionTranslator . class \"  ,     . class )  ;", "}", "return   null ;", "}", "}", "TestSQLErrorCodesFactory   sf    =    new   TestSQLErrorCodesFactory (  )  ;", "assertTrue (  (  ( sf . getErrorCodes (  \" XX \"  )  . getBadSqlGrammarCodes (  )  . length )     =  =     0  )  )  ;", "assertEquals (  0  ,    sf . getErrorCodes (  \" Oracle \"  )  . getBadSqlGrammarCodes (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testInvalidUserDefinedCodeFormat"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "class   TestSQLErrorCodesFactory   extends   SQLErrorCodesFactory    {", "private   int   lookups    =     0  ;", "@ Override", "protected   Resource   loadResource ( String   path )     {", "+  +  ( lookups )  ;", "if    (  ( lookups )     =  =     1  )     {", "assertEquals ( SQLErrorCodesFactory . SQL _ ERROR _ CODE _ DEFAULT _ PATH ,    path )  ;", "return   null ;", "} else    {", "assertEquals (  2  ,    lookups )  ;", "assertEquals ( SQLErrorCodesFactory . SQL _ ERROR _ CODE _ OVERRIDE _ PATH ,    path )  ;", "return   null ;", "}", "}", "}", "TestSQLErrorCodesFactory   sf    =    new   TestSQLErrorCodesFactory (  )  ;", "assertTrue (  (  ( sf . getErrorCodes (  \" XX \"  )  . getBadSqlGrammarCodes (  )  . length )     =  =     0  )  )  ;", "assertTrue (  (  ( sf . getErrorCodes (  \" Oracle \"  )  . getDataIntegrityViolationCodes (  )  . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testLookupOrder"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SQLErrorCodes   sec    =    getErrorCodesFromDataSource (  \" Oracle \"  ,    null )  ;", "assertIsOracle ( sec )  ;", "}", "METHOD_END"], "methodName": ["testOracleRecognizedFromMetadata"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SQLErrorCodes   sec    =    getErrorCodesFromDataSource (  \" MS - SQL \"  ,    null )  ;", "assertIsSQLServer ( sec )  ;", "}", "METHOD_END"], "methodName": ["testSQLServerRecognizedFromMetadata"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "class   WildcardSQLErrorCodesFactory   extends   SQLErrorCodesFactory    {", "@ Override", "protected   Resource   loadResource ( String   path )     {", "if    ( SQLErrorCodesFactory . SQL _ ERROR _ CODE _ OVERRIDE _ PATH . equals ( path )  )     {", "return   new   ClassPathResource (  \" wildcard - error - codes . xml \"  ,     . class )  ;", "}", "return   null ;", "}", "}", "WildcardSQLErrorCodesFactory   factory    =    new   WildcardSQLErrorCodesFactory (  )  ;", "SQLErrorCodes   sec    =    getErrorCodesFromDataSource (  \" DB 2  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB 2    UDB   for   Xxxxx \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB 3  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB 3  /  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \"  / DB 3  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \"  / DB 3  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \"  / DB 3  /  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB -  3  \"  ,    factory )  ;", "assertIsEmpty ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB 1  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB 1  /  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \"  / DB 1  \"  ,    factory )  ;", "assertIsEmpty ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \"  / DB 1  /  \"  ,    factory )  ;", "assertIsEmpty ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB 0  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \"  / DB 0  \"  ,    factory )  ;", "assertIsDB 2  ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \" DB 0  /  \"  ,    factory )  ;", "assertIsEmpty ( sec )  ;", "sec    =    getErrorCodesFromDataSource (  \"  / DB 0  /  \"  ,    factory )  ;", "assertIsEmpty ( sec )  ;", "}", "METHOD_END"], "methodName": ["testWildCardNameRecognized"], "fileName": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   badSqlGrammarExceptionEx    =    SQLExceptionSubclassFactory . newSQLDataException (  \"  \"  ,     \"  \"  ,     1  )  ;", "DataAccessException   dae    =    sext . translate (  \" task \"  ,     \" SQL \"  ,    badSqlGrammarExceptionEx )  ;", "assertEquals ( badSqlGrammarExceptionEx ,    dae . getCause (  )  )  ;", "assertThat ( dae ,    instanceOf ( BadSqlGrammarException . class )  )  ;", "}", "METHOD_END"], "methodName": ["badSqlGrammarException"], "fileName": "org.springframework.jdbc.support.SQLExceptionCustomTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   dataAccessResourceEx    =    SQLExceptionSubclassFactory . newSQLDataException (  \"  \"  ,     \"  \"  ,     2  )  ;", "DataAccessException   dae    =    sext . translate (  \" task \"  ,     \" SQL \"  ,    dataAccessResourceEx )  ;", "assertEquals ( dataAccessResourceEx ,    dae . getCause (  )  )  ;", "assertThat ( dae ,    instanceOf ( TransientDataAccessResourceException . class )  )  ;", "}", "METHOD_END"], "methodName": ["dataAccessResourceException"], "fileName": "org.springframework.jdbc.support.SQLExceptionCustomTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLDataException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLDataException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLFeatureNotSupportedException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLFeatureNotSupportedException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLIntegrityConstraintViolationException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLIntegrityConstraintViolationException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLInvalidAuthorizationSpecException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLInvalidAuthorizationSpecException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLNonTransientConnectionException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLNonTransientConnectionException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLRecoverableException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLRecoverableException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLSyntaxErrorException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLSyntaxErrorException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLTimeoutException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLTimeoutException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLTransactionRollbackException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLTransactionRollbackException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SQLTransientConnectionException ( reason ,    SQLState ,    vendorCode )  ;", "}", "METHOD_END"], "methodName": ["newSQLTransientConnectionException"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassFactory"}, {"methodBody": ["METHOD_START", "{", "SQLExceptionTranslator   sext    =    new   SQLErrorCodeSQLExceptionTranslator ( SQLExceptionSubclassTranslatorTests . ERROR _ CODES )  ;", "SQLException   dataIntegrityViolationEx    =    SQLExceptionSubclassFactory . newSQLDataException (  \"  \"  ,     \"  \"  ,     0  )  ;", "DataIntegrityViolationException   divex    =     (  ( DataIntegrityViolationException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    dataIntegrityViolationEx )  )  )  ;", "assertEquals ( dataIntegrityViolationEx ,    divex . getCause (  )  )  ;", "SQLException   featureNotSupEx    =    SQLExceptionSubclassFactory . newSQLFeatureNotSupportedException (  \"  \"  ,     \"  \"  ,     0  )  ;", "InvalidDataAccessApiUsageException   idaex    =     (  ( InvalidDataAccessApiUsageException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    featureNotSupEx )  )  )  ;", "assertEquals ( featureNotSupEx ,    idaex . getCause (  )  )  ;", "SQLException   dataIntegrityViolationEx 2     =    SQLExceptionSubclassFactory . newSQLIntegrityConstraintViolationException (  \"  \"  ,     \"  \"  ,     0  )  ;", "DataIntegrityViolationException   divex 2     =     (  ( DataIntegrityViolationException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    dataIntegrityViolationEx 2  )  )  )  ;", "assertEquals ( dataIntegrityViolationEx 2  ,    divex 2  . getCause (  )  )  ;", "SQLException   permissionDeniedEx    =    SQLExceptionSubclassFactory . newSQLInvalidAuthorizationSpecException (  \"  \"  ,     \"  \"  ,     0  )  ;", "PermissionDeniedDataAccessException   pdaex    =     (  ( PermissionDeniedDataAccessException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    permissionDeniedEx )  )  )  ;", "assertEquals ( permissionDeniedEx ,    pdaex . getCause (  )  )  ;", "SQLException   dataAccessResourceEx    =    SQLExceptionSubclassFactory . newSQLNonTransientConnectionException (  \"  \"  ,     \"  \"  ,     0  )  ;", "DataAccessResourceFailureException   darex    =     (  ( DataAccessResourceFailureException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    dataAccessResourceEx )  )  )  ;", "assertEquals ( dataAccessResourceEx ,    darex . getCause (  )  )  ;", "SQLException   badSqlEx 2     =    SQLExceptionSubclassFactory . newSQLSyntaxErrorException (  \"  \"  ,     \"  \"  ,     0  )  ;", "BadSqlGrammarException   bsgex 2     =     (  ( BadSqlGrammarException )     ( sext . translate (  \" task \"  ,     \" SQL 2  \"  ,    badSqlEx 2  )  )  )  ;", "assertEquals (  \" SQL 2  \"  ,    bsgex 2  . getSql (  )  )  ;", "assertEquals ( badSqlEx 2  ,    bsgex 2  . getSQLException (  )  )  ;", "SQLException   tranRollbackEx    =    SQLExceptionSubclassFactory . newSQLTransactionRollbackException (  \"  \"  ,     \"  \"  ,     0  )  ;", "ConcurrencyFailureException   cfex    =     (  ( ConcurrencyFailureException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    tranRollbackEx )  )  )  ;", "assertEquals ( tranRollbackEx ,    cfex . getCause (  )  )  ;", "SQLException   transientConnEx    =    SQLExceptionSubclassFactory . newSQLTransientConnectionException (  \"  \"  ,     \"  \"  ,     0  )  ;", "TransientDataAccessResourceException   tdarex    =     (  ( TransientDataAccessResourceException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    transientConnEx )  )  )  ;", "assertEquals ( transientConnEx ,    tdarex . getCause (  )  )  ;", "SQLException   transientConnEx 2     =    SQLExceptionSubclassFactory . newSQLTimeoutException (  \"  \"  ,     \"  \"  ,     0  )  ;", "QueryTimeoutException   tdarex 2     =     (  ( QueryTimeoutException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    transientConnEx 2  )  )  )  ;", "assertEquals ( transientConnEx 2  ,    tdarex 2  . getCause (  )  )  ;", "SQLException   recoverableEx    =    SQLExceptionSubclassFactory . newSQLRecoverableException (  \"  \"  ,     \"  \"  ,     0  )  ;", "RecoverableDataAccessException   rdaex 2     =     (  ( RecoverableDataAccessException )     ( sext . translate (  \" task \"  ,     \" SQL \"  ,    recoverableEx )  )  )  ;", "assertEquals ( recoverableEx ,    rdaex 2  . getCause (  )  )  ;", "SQLException   sexEct    =    new   SQLException (  \"  \"  ,     \"  \"  ,     1  )  ;", "BadSqlGrammarException   bsgEct    =     (  ( BadSqlGrammarException )     ( sext . translate (  \" task \"  ,     \" SQL - ECT \"  ,    sexEct )  )  )  ;", "assertEquals (  \" SQL - ECT \"  ,    bsgEct . getSql (  )  )  ;", "assertEquals ( sexEct ,    bsgEct . getSQLException (  )  )  ;", "SQLException   sexFbt    =    new   SQLException (  \"  \"  ,     \"  0  7 xxx \"  ,     6  6  6  6  6  6  6  6  6  )  ;", "BadSqlGrammarException   bsgFbt    =     (  ( BadSqlGrammarException )     ( sext . translate (  \" task \"  ,     \" SQL - FBT \"  ,    sexFbt )  )  )  ;", "assertEquals (  \" SQL - FBT \"  ,    bsgFbt . getSql (  )  )  ;", "assertEquals ( sexFbt ,    bsgFbt . getSQLException (  )  )  ;", "SQLException   sexFbt 2     =    new   SQLException (  \"  \"  ,     \"  0  8 xxx \"  ,     6  6  6  6  6  6  6  6  6  )  ;", "DataAccessResourceFailureException   darfFbt    =     (  ( DataAccessResourceFailureException )     ( sext . translate (  \" task \"  ,     \" SQL - FBT 2  \"  ,    sexFbt 2  )  )  )  ;", "assertEquals ( sexFbt 2  ,    darfFbt . getCause (  )  )  ;", "}", "METHOD_END"], "methodName": ["errorCodeTranslation"], "fileName": "org.springframework.jdbc.support.SQLExceptionSubclassTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sex    =    new   SQLException (  \" Message \"  ,     \"  4  2  0  0  1  \"  ,     1  )  ;", "try    {", "throw   this . trans . translate (  \" task \"  ,     . sql ,    sex )  ;", "}    catch    ( BadSqlGrammarException   ex )     {", "assertTrue (  \" SQL   is   correct \"  ,     . sql . equals ( ex . getSql (  )  )  )  ;", "assertTrue (  \" Exception   matches \"  ,    sex . equals ( ex . getSQLException (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["badSqlGrammar"], "fileName": "org.springframework.jdbc.support.SQLStateExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sex    =    new   SQLException (  \" Message \"  ,     \" NO   SUCH   CODE \"  ,     1  )  ;", "try    {", "throw   this . trans . translate (  \" task \"  ,     . sql ,    sex )  ;", "}    catch    ( UncategorizedSQLException   ex )     {", "assertTrue (  \" SQL   is   correct \"  ,     . sql . equals ( ex . getSql (  )  )  )  ;", "assertTrue (  \" Exception   matches \"  ,    sex . equals ( ex . getSQLException (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invalidSqlStateCode"], "fileName": "org.springframework.jdbc.support.SQLStateExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "SQLException   sex    =    new   SQLException (  \" Message \"  ,    null ,     1  )  ;", "testMalformedSqlStateCode ( sex )  ;", "sex    =    new   SQLException (  \" Message \"  ,     \"  \"  ,     1  )  ;", "testMalformedSqlStateCode ( sex )  ;", "sex    =    new   SQLException (  \" Message \"  ,     \" I \"  ,     1  )  ;", "testMalformedSqlStateCode ( sex )  ;", "}", "METHOD_END"], "methodName": ["malformedSqlStateCodes"], "fileName": "org.springframework.jdbc.support.SQLStateExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "throw   this . trans . translate (  \" task \"  ,     . sql ,    sex )  ;", "}    catch    ( UncategorizedSQLException   ex )     {", "assertTrue (  \" SQL   is   correct \"  ,     . sql . equals ( ex . getSql (  )  )  )  ;", "assertTrue (  \" Exception   matches \"  ,    sex . equals ( ex . getSQLException (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMalformedSqlStateCode"], "fileName": "org.springframework.jdbc.support.SQLStateExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "String   sqlState    =    ex . getSQLState (  )  ;", "if    ( sqlState    =  =    null )     {", "nestedEx    =    ex . getNextException (  )  ;", "if    ( nestedEx    !  =    null )     {", "sqlState    =    nestedEx . getSQLState (  )  ;", "}", "}", "return   sqlState ;", "}", "METHOD_END"], "methodName": ["getSqlState"], "fileName": "org.springframework.jdbc.support.SQLStateSQLExceptionTranslator"}, {"methodBody": ["METHOD_START", "{", "SQLException   ex    =    new   SQLException ( SQLStateSQLExceptionTranslatorTests . REASON ,    sqlState )  ;", "SQLExceptionTranslator   translator    =    new   SQLStateSQLExceptionTranslator (  )  ;", "DataAccessException   dax    =    translator . translate ( SQLStateSQLExceptionTranslatorTests . TASK ,    SQLStateSQLExceptionTranslatorTests . SQL ,    ex )  ;", "assertNotNull (  \" Translation   must    * never *    result   in   a   null   DataAccessException   being   returned .  \"  ,    dax )  ;", "assertEquals (  \" Wrong   DataAccessException   type   returned   as   the   result   of   the   translation \"  ,    dataAccessExceptionType ,    dax . getClass (  )  )  ;", "assertNotNull (  \" The   original   SQLException   must   be   preserved   in   the   translated   DataAccessException \"  ,    dax . getCause (  )  )  ;", "assertSame (  \" The   exact   same   original   SQLException   must   be   preserved   in   the   translated   DataAccessException \"  ,    ex ,    dax . getCause (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "org.springframework.jdbc.support.SQLStateSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  0  7  \"  ,    BadSqlGrammarException . class )  ;", "}", "METHOD_END"], "methodName": ["testTranslateBadSqlGrammar"], "fileName": "org.springframework.jdbc.support.SQLStateSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  4  0  \"  ,    ConcurrencyFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["testTranslateConcurrencyFailure"], "fileName": "org.springframework.jdbc.support.SQLStateSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  5  3  \"  ,    DataAccessResourceFailureException . class )  ;", "}", "METHOD_END"], "methodName": ["testTranslateDataAccessResourceFailure"], "fileName": "org.springframework.jdbc.support.SQLStateSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  2  3  \"  ,    DataIntegrityViolationException . class )  ;", "}", "METHOD_END"], "methodName": ["testTranslateDataIntegrityViolation"], "fileName": "org.springframework.jdbc.support.SQLStateSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "new   SQLStateSQLExceptionTranslator (  )  . translate (  \"  \"  ,     \"  \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testTranslateNullException"], "fileName": "org.springframework.jdbc.support.SQLStateSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" S 1  \"  ,    TransientDataAccessResourceException . class )  ;", "}", "METHOD_END"], "methodName": ["testTranslateTransientDataAccessResourceFailure"], "fileName": "org.springframework.jdbc.support.SQLStateSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "doTest (  \"  0  0  0  0  0  0  0  0  \"  ,    UncategorizedSQLException . class )  ;", "}", "METHOD_END"], "methodName": ["testTranslateUncategorized"], "fileName": "org.springframework.jdbc.support.SQLStateSQLExceptionTranslatorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheSize ;", "}", "METHOD_END"], "methodName": ["getCacheSize"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractColumnMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "return   this . columnName ;", "}", "METHOD_END"], "methodName": ["getColumnName"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractColumnMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "this . cacheSize    =    cacheSize ;", "}", "METHOD_END"], "methodName": ["setCacheSize"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractColumnMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "this . columnName    =    columnName ;", "}", "METHOD_END"], "methodName": ["setColumnName"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractColumnMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "return   this . dataSource ;", "}", "METHOD_END"], "methodName": ["getDataSource"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractDataFieldMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "return   this . incrementerName ;", "}", "METHOD_END"], "methodName": ["getIncrementerName"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractDataFieldMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "return   this . paddingLength ;", "}", "METHOD_END"], "methodName": ["getPaddingLength"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractDataFieldMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "this . dataSource    =    dataSource ;", "}", "METHOD_END"], "methodName": ["setDataSource"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractDataFieldMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "this . incrementerName    =    incrementerName ;", "}", "METHOD_END"], "methodName": ["setIncrementerName"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractDataFieldMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "this . paddingLength    =    paddingLength ;", "}", "METHOD_END"], "methodName": ["setPaddingLength"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractDataFieldMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  6  4  )  ;", "sb . append (  \" delete   from    \"  )  . append ( getName (  )  )  . append (  \"    where    \"  )  . append ( getColumnName (  )  )  ;", "if    ( isDeleteSpecificValues (  )  )     {", "sb . append (  \"    in    (  \"  )  . append (  (  ( values [  0  ]  )     -     1  )  )  ;", "for    ( int   i    =     0  ;    i    <     (  ( values . length )     -     1  )  ;    i +  +  )     {", "sb . append (  \"  ,     \"  )  . append ( values [ i ]  )  ;", "}", "sb . append (  \"  )  \"  )  ;", "} else    {", "long   maxValue    =    values [  (  ( values . length )     -     1  )  ]  ;", "sb . append (  \"     <     \"  )  . append ( maxValue )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDeleteStatement"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "return   this . deleteSpecificValues ;", "}", "METHOD_END"], "methodName": ["isDeleteSpecificValues"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "this . deleteSpecificValues    =    deleteSpecificValues ;", "}", "METHOD_END"], "methodName": ["setDeleteSpecificValues"], "fileName": "org.springframework.jdbc.support.incrementer.AbstractIdentityColumnMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "return   this . dummyName ;", "}", "METHOD_END"], "methodName": ["getDummyName"], "fileName": "org.springframework.jdbc.support.incrementer.DerbyMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "this . dummyName    =    dummyName ;", "}", "METHOD_END"], "methodName": ["setDummyName"], "fileName": "org.springframework.jdbc.support.incrementer.DerbyMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "this . useNewConnection    =    useNewConnection ;", "}", "METHOD_END"], "methodName": ["setUseNewConnection"], "fileName": "org.springframework.jdbc.support.incrementer.MySQLMaxValueIncrementer"}, {"methodBody": ["METHOD_START", "{", "this . createTemporaryLob    =    createTemporaryLob ;", "}", "METHOD_END"], "methodName": ["setCreateTemporaryLob"], "fileName": "org.springframework.jdbc.support.lob.DefaultLobHandler"}, {"methodBody": ["METHOD_START", "{", "this . streamAsLob    =    streamAsLob ;", "}", "METHOD_END"], "methodName": ["setStreamAsLob"], "fileName": "org.springframework.jdbc.support.lob.DefaultLobHandler"}, {"methodBody": ["METHOD_START", "{", "this . wrapAsLob    =    wrapAsLob ;", "}", "METHOD_END"], "methodName": ["setWrapAsLob"], "fileName": "org.springframework.jdbc.support.lob.DefaultLobHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( arg   instanceof   String )     {", "given ( resultSet . findColumn (  (  ( String )     ( arg )  )  )  )  . willReturn (  1  )  ;", "given ( rsetMethod . invoke ( resultSet ,     1  )  )  . willReturn ( ret )  . willThrow ( new   SQLException (  \" test \"  )  )  ;", "} else    {", "given ( rsetMethod . invoke ( resultSet ,    arg )  )  . willReturn ( ret )  . willThrow ( new   SQLException (  \" test \"  )  )  ;", "}", "rowsetMethod . invoke ( rowSet ,    arg )  ;", "try    {", "rowsetMethod . invoke ( rowSet ,    arg )  ;", "fail (  \" InvalidAccessException   should   have   been   thrown \"  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "assertEquals ( InvalidAccessException . class ,    ex . getTargetException (  )  . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "resultSet    =    mock ( ResultSet . class )  ;", "rowSet    =    new   SqlRowSet ( resultSet )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getBigDecimal \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getBigDecimal \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,    BigDecimal . ONE )  ;", "}", "METHOD_END"], "methodName": ["testGetBigDecimalInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getBigDecimal \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getBigDecimal \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,    BigDecimal . ONE )  ;", "}", "METHOD_END"], "methodName": ["testGetBigDecimalString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getBoolean \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getBoolean \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testGetBooleanInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getBoolean \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getBoolean \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testGetBooleanString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getDate \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getDate \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,    new   Date (  1  2  3  4 L )  )  ;", "}", "METHOD_END"], "methodName": ["testGetDateInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getDate \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getDate \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,    new   Date (  1  2  3  4 L )  )  ;", "}", "METHOD_END"], "methodName": ["testGetDateString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getDouble \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getDouble \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,     1  .  0  )  ;", "}", "METHOD_END"], "methodName": ["testGetDoubleInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getDouble \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getDouble \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,     1  .  0  )  ;", "}", "METHOD_END"], "methodName": ["testGetDoubleString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getFloat \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getFloat \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,     1  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["testGetFloatInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getFloat \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getFloat \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,     1  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["testGetFloatString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getInt \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getInt \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testGetIntInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getInt \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getInt \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testGetIntString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getLong \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getLong \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,     1 L )  ;", "}", "METHOD_END"], "methodName": ["testGetLongInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getLong \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getLong \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,     1 L )  ;", "}", "METHOD_END"], "methodName": ["testGetLongString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getObject \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getObject \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,    new   Object (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetObjectInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getObject \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getObject \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,    new   Object (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetObjectString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getString \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getString \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,     \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["testGetStringInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getString \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getString \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,     \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["testGetStringString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getTime \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getTime \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,    new   Time (  1  2  3  4 L )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTimeInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getTime \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getTime \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,    new   Time (  1  2  3  4 L )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTimeString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getTimestamp \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getTimestamp \"  ,    int . class )  ;", "doTest ( rset ,    rowset ,     1  ,    new   Timestamp (  1  2  3  4 L )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTimestampInt"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "Method   rset    =    ResultSet . class . getDeclaredMethod (  \" getTimestamp \"  ,    int . class )  ;", "Method   rowset    =    SqlRowSet . class . getDeclaredMethod (  \" getTimestamp \"  ,    String . class )  ;", "doTest ( rset ,    rowset ,     \" test \"  ,    new   Timestamp (  1  2  3  4 L )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTimestampString"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingRowSetTests"}, {"methodBody": ["METHOD_START", "{", "return   this . resultSet ;", "}", "METHOD_END"], "methodName": ["getResultSet"], "fileName": "org.springframework.jdbc.support.rowset.ResultSetWrappingSqlRowSet"}]