[{"methodBody": ["METHOD_START", "{", "return   send ( message ,    MessageChannel . INDEFINITE _ TIMEOUT )  ;", "}", "METHOD_END"], "methodName": ["send"], "fileName": "org.springframework.messaging.MessageChannel"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" MessageHeaders   is   immutable \"  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   this . headers . containsKey ( key )  ;", "}", "METHOD_END"], "methodName": ["containsKey"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   this . headers . containsValue ( value )  ;", "}", "METHOD_END"], "methodName": ["containsValue"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . headers )  . entrySet (  )  ;", "}", "METHOD_END"], "methodName": ["entrySet"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   this . headers . get ( key )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . headers . get ( key )  ;", "if    ( value    =  =    null )     {", "return   null ;", "}", "if    (  !  ( type . isAssignableFrom ( value . getClass (  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  \" Incorrect   type   specified   for   header    '  \"     +    key )     +     \"  '  .    Expected    [  \"  )     +    type )     +     \"  ]    but   actual   type   is    [  \"  )     +     ( value . getClass (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return    (  ( T )     ( value )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   get ( MessageHeaders . ERROR _ CHANNEL )  ;", "}", "METHOD_END"], "methodName": ["getErrorChannel"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   get ( MessageHeaders . ID ,    UUID . class )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "IdGenerator   generator    =    MessageHeaders . idGenerator ;", "return   generator    !  =    null    ?    generator    :    MessageHeaders . defaultIdGenerator ;", "}", "METHOD_END"], "methodName": ["getIdGenerator"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getRawHeaders"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   get ( MessageHeaders . REPLY _ CHANNEL )  ;", "}", "METHOD_END"], "methodName": ["getReplyChannel"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   get ( MessageHeaders . TIMESTAMP ,    Long . class )  ;", "}", "METHOD_END"], "methodName": ["getTimestamp"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   this . headers . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( this . headers . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["keySet"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" MessageHeaders   is   immutable \"  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" MessageHeaders   is   immutable \"  )  ;", "}", "METHOD_END"], "methodName": ["putAll"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "in . defaultReadObject (  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" MessageHeaders   is   immutable \"  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   this . headers . size (  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableCollection ( this . headers . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["values"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "Set < String >    keysToIgnore    =    new   HashSet <  >  (  )  ;", "this . headers . forEach (  (    key ,    value )     -  >     {", "if    (  !  ( value   instanceof   Serializable )  )     {", "keysToIgnore . add ( key )  ;", "}", "}  )  ;", "if    ( keysToIgnore . isEmpty (  )  )     {", "out . defaultWriteObject (  )  ;", "} else    {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Ignoring   non - serializable   message   headers :     \"     +    keysToIgnore )  )  ;", "}", "out . writeObject ( new    ( this ,    keysToIgnore )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeObject"], "fileName": "org.springframework.messaging.MessageHeaders"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" name \"  ,     \" joe \"  )  ;", "map . put (  \" age \"  ,     4  2  )  ;", "input    =    new    ( map )  ;", "output    =     (  (  )     ( SerializationTestUtils . serializeAndDeserialize ( input )  )  )  ;", "assertEquals (  \" joe \"  ,    output . get (  \" name \"  )  )  ;", "assertEquals (  4  2  ,    output . get (  \" age \"  )  )  ;", "assertEquals (  \" joe \"  ,    input . get (  \" name \"  )  )  ;", "assertEquals (  4  2  ,    input . get (  \" age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["serializeWithAllSerializableHeaders"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Object   address    =    new   Object (  )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" name \"  ,     \" joe \"  )  ;", "map . put (  \" address \"  ,    address )  ;", "input    =    new    ( map )  ;", "output    =     (  (  )     ( SerializationTestUtils . serializeAndDeserialize ( input )  )  )  ;", "assertEquals (  \" joe \"  ,    output . get (  \" name \"  )  )  ;", "assertNull ( output . get (  \" address \"  )  )  ;", "assertEquals (  \" joe \"  ,    input . get (  \" name \"  )  )  ;", "assertSame ( address ,    input . get (  \" address \"  )  )  ;", "}", "METHOD_END"], "methodName": ["serializeWithNonSerializableHeader"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "final   AtomicLong   id    =    new   AtomicLong (  )  ;", "@ SuppressWarnings (  \" serial \"  )", "class   MyMH   extends       {", "public   MyMH (  )     {", "super ( null ,    new   UUID (  0  ,    id . incrementAndGet (  )  )  ,     (  -  1 L )  )  ;", "}", "}", "headers    =    new   MyMH (  )  ;", "assertEquals (  \"  0  0  0  0  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  0  0  0  0  0  0  0  0  0  0  0  1  \"  ,    headers . getId (  )  . toString (  )  )  ;", "assertEquals (  1  ,    headers . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["subclassWithCustomIdAndNoTimestamp"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" key 1  \"  ,     \" val 1  \"  )  ;", "map . put (  \" key 2  \"  ,    new   Integer (  1  2  3  )  )  ;", "headers    =    new    ( map )  ;", "Set < String >    keys    =    headers . keySet (  )  ;", "assertTrue ( keys . contains (  \" key 1  \"  )  )  ;", "assertTrue ( keys . contains (  \" key 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHeaderKeys"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Integer   value    =    new   Integer (  1  2  3  )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" test \"  ,    value )  ;", "headers    =    new    ( map )  ;", "assertEquals ( value ,    headers . get (  \" test \"  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testHeaderValueAccessWithIncorrectType"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers    =    new   MessageHeaders ( null )  ;", "assertNotNull ( headers . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["testId"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers    =    new   MessageHeaders ( null ,    MessageHeaders . ID _ VALUE _ NONE ,    null )  ;", "assertNull ( headers . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIdNone"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers 1     =    new   MessageHeaders ( null )  ;", "MessageHeaders   headers 2     =    new   MessageHeaders ( headers 1  )  ;", "assertNotSame ( headers 1  . getId (  )  ,    headers 2  . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIdOverwritten"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "UUID   id    =    new   UUID (  0 L ,     2  5 L )  ;", "headers    =    new    ( null ,    id ,    null )  ;", "assertEquals ( id ,    headers . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIdProvided"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    input    =    Collections .  < String ,    Object > singletonMap ( MessageHeaders . ID ,    new   UUID (  0 L ,     2  5 L )  )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( input ,    null ,    null )  ;", "assertNotNull ( headers . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIdProvidedNullValue"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Integer   value    =    new   Integer (  1  2  3  )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" test \"  ,    value )  ;", "headers    =    new    ( map )  ;", "assertEquals ( value ,    headers . get (  \" test \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonTypedAccessOfHeaderValue"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "headers    =    new    ( map )  ;", "assertNull ( headers . get (  \" nosuchattribute \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNullHeaderValue"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "headers    =    new    ( map )  ;", "assertNull ( headers . get (  \" nosuchattribute \"  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testNullHeaderValueWithTypedAccess"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers    =    new   MessageHeaders ( null )  ;", "assertNotNull ( headers . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTimestamp"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers    =    new   MessageHeaders ( null ,    null ,     (  -  1 L )  )  ;", "assertNull ( headers . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTimestampNone"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers 1     =    new   MessageHeaders ( null )  ;", "Thread . sleep (  5  0 L )  ;", "MessageHeaders   headers 2     =    new   MessageHeaders ( headers 1  )  ;", "assertNotSame ( headers 1  . getTimestamp (  )  ,    headers 2  . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTimestampOverwritten"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers    =    new   MessageHeaders ( null ,    null ,     1  0 L )  ;", "assertEquals (  1  0 L ,     (  ( long )     ( headers . getTimestamp (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTimestampProvided"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    input    =    Collections .  < String ,    Object > singletonMap ( MessageHeaders . TIMESTAMP ,     1 L )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( input ,    null ,    null )  ;", "assertNotNull ( headers . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTimestampProvidedNullValue"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "Integer   value    =    new   Integer (  1  2  3  )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" test \"  ,    value )  ;", "headers    =    new    ( map )  ;", "assertEquals ( value ,    headers . get (  \" test \"  ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["testTypedAccessOfHeaderValue"], "fileName": "org.springframework.messaging.MessageHeadersTests"}, {"methodBody": ["METHOD_START", "{", "return   this . failedMessage ;", "}", "METHOD_END"], "methodName": ["getFailedMessage"], "fileName": "org.springframework.messaging.MessagingException"}, {"methodBody": ["METHOD_START", "{", "return   this . messages ;", "}", "METHOD_END"], "methodName": ["getMessages"], "fileName": "org.springframework.messaging.StubMessageChannel"}, {"methodBody": ["METHOD_START", "{", "return    ( supports ( targetClass )  )     &  &     ( supportsMimeType ( message . getHeaders (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canConvertFrom"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( supports ( payload . getClass (  )  )  )     &  &     ( supportsMimeType ( headers )  )  ;", "}", "METHOD_END"], "methodName": ["canConvertTo"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["convertFromInternal"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["convertToInternal"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . contentTypeResolver ;", "}", "METHOD_END"], "methodName": ["getContentTypeResolver"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "List < MimeType >    mimeTypes    =    getSupportedMimeTypes (  )  ;", "return    !  ( mimeTypes . isEmpty (  )  )     ?    mimeTypes . get (  0  )     :    null ;", "}", "METHOD_END"], "methodName": ["getDefaultContentType"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( headers    !  =    null )     &  &     (  ( this . contentTypeResolver )     !  =    null )     ?    this . contentTypeResolver . resolve ( headers )     :    null ;", "}", "METHOD_END"], "methodName": ["getMimeType"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . serializedPayloadClass ;", "}", "METHOD_END"], "methodName": ["getSerializedPayloadClass"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . supportedMimeTypes )  ;", "}", "METHOD_END"], "methodName": ["getSupportedMimeTypes"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . strictContentTypeMatch ;", "}", "METHOD_END"], "methodName": ["isStrictContentTypeMatch"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . contentTypeResolver    =    resolver ;", "}", "METHOD_END"], "methodName": ["setContentTypeResolver"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  (  ( byte [  ]  . class )     =  =    payloadClass )     |  |     (  ( String . class )     =  =    payloadClass )  )  ,     (  )     -  >     \" Payload   class   must   be   byte [  ]    or   String :     \"     +    payloadClass )  ;", "this . serializedPayloadClass    =    payloadClass ;", "}", "METHOD_END"], "methodName": ["setSerializedPayloadClass"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( strictContentTypeMatch )     {", "Assert . notEmpty ( getSupportedMimeTypes (  )  ,     \" Strict   match   requires   non - empty   list   of   supported   mime   types \"  )  ;", "Assert . notNull ( getContentTypeResolver (  )  ,     \" Strict   match   requires   ContentTypeResolver \"  )  ;", "}", "this . strictContentTypeMatch    =    strictContentTypeMatch ;", "}", "METHOD_END"], "methodName": ["setStrictContentTypeMatch"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( getSupportedMimeTypes (  )  . isEmpty (  )  )     {", "return   true ;", "}", "MimeType   mimeType    =    getMimeType ( headers )  ;", "if    ( mimeType    =  =    null )     {", "return    !  ( isStrictContentTypeMatch (  )  )  ;", "}", "for    ( MimeType   current    :    getSupportedMimeTypes (  )  )     {", "if    (  ( current . getType (  )  . equals ( mimeType . getType (  )  )  )     &  &     ( current . getSubtype (  )  . equals ( mimeType . getSubtype (  )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["supportsMimeType"], "fileName": "org.springframework.messaging.converter.AbstractMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . converters ;", "}", "METHOD_END"], "methodName": ["getConverters"], "fileName": "org.springframework.messaging.converter.CompositeMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultMimeType ;", "}", "METHOD_END"], "methodName": ["getDefaultMimeType"], "fileName": "org.springframework.messaging.converter.DefaultContentTypeResolver"}, {"methodBody": ["METHOD_START", "{", "this . defaultMimeType    =    defaultMimeType ;", "}", "METHOD_END"], "methodName": ["setDefaultMimeType"], "fileName": "org.springframework.messaging.converter.DefaultContentTypeResolver"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( MessageHeaders . CONTENT _ TYPE ,    APPLICATION _ JSON )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( map )  ;", "assertEquals ( APPLICATION _ JSON ,    this . r . resolve ( headers )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.springframework.messaging.converter.DefaultContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setDefaultMimeType ( APPLICATION _ JSON )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( Collections .  < String ,    Object > emptyMap (  )  )  ;", "assertEquals ( APPLICATION _ JSON ,    this . resolver . resolve ( headers )  )  ;", "}", "METHOD_END"], "methodName": ["resolveDefaultMimeType"], "fileName": "org.springframework.messaging.converter.DefaultContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( MessageHeaders . CONTENT _ TYPE ,     \" invalid \"  )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( map )  ;", "this . resolver . resolve ( headers )  ;", "}", "METHOD_END"], "methodName": ["resolveInvalidStringContentType"], "fileName": "org.springframework.messaging.converter.DefaultContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers    =    new   MessageHeaders ( Collections .  < String ,    Object > emptyMap (  )  )  ;", "assertNull ( this . r . resolve ( headers )  )  ;", "}", "METHOD_END"], "methodName": ["resolveNoContentTypeHeader"], "fileName": "org.springframework.messaging.converter.DefaultContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( MessageHeaders . CONTENT _ TYPE ,    APPLICATION _ JSON _ VALUE )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( map )  ;", "assertEquals ( APPLICATION _ JSON ,    this . r . resolve ( headers )  )  ;", "}", "METHOD_END"], "methodName": ["resolveStringContentType"], "fileName": "org.springframework.messaging.converter.DefaultContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( MessageHeaders . CONTENT _ TYPE ,    new   Integer (  1  )  )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( map )  ;", "this . r . resolve ( headers )  ;", "}", "METHOD_END"], "methodName": ["resolveUnknownHeaderType"], "fileName": "org.springframework.messaging.converter.DefaultContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver    =    new   DefaultContentTypeResolver (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.converter.DefaultContentTypeResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < Integer >    content    =    MessageBuilder . withPayload (  1  2  3  4  )  . build (  )  ;", "assertNull (  \" No   from   integer   to   locale \"  ,    fromMessage ( content ,    Locale . class )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageNoConverter"], "fileName": "org.springframework.messaging.converter.GenericMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    content    =    MessageBuilder . withPayload (  \"  3  3  \"  )  . build (  )  ;", "assertEquals (  3  3  ,    fromMessage ( content ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageWithConversion"], "fileName": "org.springframework.messaging.converter.GenericMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    content    =    MessageBuilder . withPayload (  \" test   not   a   number \"  )  . build (  )  ;", "thrown . expect ( sionException . class )  ;", "thrown . expectCause ( isA ( ConversionException . class )  )  ;", "converter . fromMessage ( content ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["fromMessageWithFailedConversion"], "fileName": "org.springframework.messaging.converter.GenericMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . prettyPrint )     !  =    null )     {", "this . objectMapperfigure ( SerializationFeature . INDENT _ OUTPUT ,    this . prettyPrint )  ;", "}", "}", "METHOD_END"], "methodName": ["configurePrettyPrint"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    classes    =    annotation . value (  )  ;", "if    (  ( classes . length )     !  =     1  )     {", "throw   new   IllegalArgumentException (  (  \"  @ JsonView   only   supported   for   handler   methods   with   exactly    1    class   argument :     \"     +    sionHint )  )  ;", "}", "return   classes [  0  ]  ;", "}", "METHOD_END"], "methodName": ["extractViewClass"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( conversionHint   instanceof   MethodParameter )     {", "MethodParameter   param    =     (  ( MethodParameter )     ( conversionHint )  )  ;", "param    =    param . nestedIfOptional (  )  ;", "if    (  . class . isAssignableFrom ( param . getParameterType (  )  )  )     {", "param    =    param . nested (  )  ;", "}", "Type   genericParameterType    =    param . getNestedGenericParameterType (  )  ;", "Class <  ?  >    contextClass    =    param . getContainingClass (  )  ;", "Type   type    =    GenericTypeResolver . resolveType ( genericParameterType ,    contextClass )  ;", "return   this . objectMapper . getTypeFactory (  )  . constructType ( type )  ;", "}", "return   this . objectMapper . constructType ( targetClass )  ;", "}", "METHOD_END"], "methodName": ["getJavaType"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( contentType    !  =    null )     &  &     (  ( contentType . getCharset (  )  )     !  =    null )  )     {", "Charset   charset    =    contentType . getCharset (  )  ;", "for    ( JsonEncodencod :    JsonEncodvalues (  )  )     {", "if    ( charset . name (  )  . equals ( encodgetJavaName (  )  )  )     {", "return   encod", "}", "}", "}", "return   JsonEncodUTF 8  ;", "}", "METHOD_END"], "methodName": ["getJsonEncoding"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . objectMapper ;", "}", "METHOD_END"], "methodName": ["getObjectMapper"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( conversionHint   instanceof   MethodParameter )     {", "MethodParameter   param    =     (  ( MethodParameter )     ( conversionHint )  )  ;", "JsonView   annotation    =     (  ( param . getParameterIndex (  )  )     >  =     0  )     ?    param . getParameterAnnotation ( JsonView . class )     :    param . getMethodAnnotation ( JsonView . class )  ;", "if    ( annotation    !  =    null )     {", "return   extractViewClass ( annotation ,    conversionHint )  ;", "}", "} else", "if    ( conversionHint   instanceof   JsonView )     {", "return   extractViewClass (  (  ( JsonView )     ( conversionHint )  )  ,    conversionHint )  ;", "} else", "if    ( conversionHint   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( conversionHint )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSerializationView"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "ObjectMapper   objectMapper    =    new   ObjectMapper (  )  ;", "objectMapper . configure ( MapperFeature . DEFAULT _ VIEW _ INCLUSION ,    false )  ;", "objectMapper . configure ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES ,    false )  ;", "return   objectMapper ;", "}", "METHOD_END"], "methodName": ["initObjectMapper"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( cause    =  =    null )     {", "return ;", "}", "boolean   debugLevel    =     ( cause   instanceof   JsonException )     &  &     ( cause . getMessage (  )  . startsWith (  \" Can   not   find \"  )  )  ;", "if    ( debugLevel    ?    logger . isDebugEnabled (  )     :    logger . isWarnEnabled (  )  )     {", "String   msg    =     (  (  (  \" Failed   to   evaluate   Jackson    \"     +     ( type   instanceof   JavaType    ?     \" de \"     :     \"  \"  )  )     +     \" serialization   for   type    [  \"  )     +    type )     +     \"  ]  \"  ;", "if    ( debugLevel )     {", "logger . debug ( msg ,    cause )  ;", "} else", "if    ( logger . isDebugEnabled (  )  )     {", "logger . warn ( msg ,    cause )  ;", "} else    {", "logger . warn (  (  ( msg    +     \"  :     \"  )     +    cause )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["logWarningIfNecessary"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( objectMapper ,     \" ObjectMapper   must   not   be   null \"  )  ;", "this . objectMapper    =    objectMapper ;", "configurePrettyPrint (  )  ;", "}", "METHOD_END"], "methodName": ["setObjectMapper"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . prettyPrint    =    prettyPrint ;", "configurePrettyPrint (  )  ;", "}", "METHOD_END"], "methodName": ["setPrettyPrint"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverter"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "assertThat ( converter . getSupportedMimeTypes (  )  ,    contains ( new   MimeType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  8  )  )  )  ;", "assertFalse ( converter . getObjectMapper (  )  . getDeserializationConfig (  )  . isEnabled ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES )  )  ;", "}", "METHOD_END"], "methodName": ["defaultConstructor"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "String   payload    =     \"  {  \"     +     (  (  (  (  (  \"  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  ,  \"     +     \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"  )     +     \"  \\  \" number \\  \"  :  4  2  ,  \"  )     +     \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \"  )     +     \"  \\  \" bool \\  \"  : true ,  \"  )     +     \"  \\  \" fraction \\  \"  :  4  2  .  0  }  \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", ". MyBean   actual    =     (  (  . MyBean )     ( converter . fromMessage ( message ,     . MyBean . class )  )  )  ;", "assertEquals (  \" Foo \"  ,    actual . getString (  )  )  ;", "assertEquals (  4  2  ,    actual . getNumber (  )  )  ;", "assertEquals (  4  2  .  0 F ,    actual . getFraction (  )  ,     0  .  0 F )  ;", "assertArrayEquals ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  ,    actual . getArray (  )  )  ;", "assertTrue ( actual . isBool (  )  )  ;", "assertArrayEquals ( new   byte [  ]  {     1  ,     2     }  ,    actual . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessage"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "String   payload    =     \" FooBar \"  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", "converter . fromMessage ( message ,     . MyBean . class )  ;", "}", "METHOD_END"], "methodName": ["fromMessageInvalidJson"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "String   payload    =     \"  [  1  ,     2  ,     3  ,     4  ,     5  ,     6  ,     7  ,     8  ,     9  ]  \"  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", "Method   method    =    getClass (  )  . getDeclaredMethod (  \" handleList \"  ,    List . class )  ;", "MethodParameter   param    =    new   MethodParameter ( method ,     0  )  ;", "Object   actual    =    converter . fromMessage ( message ,    List . class ,    param )  ;", "assertNotNull ( actual )  ;", "assertEquals ( Arrays . asList (  1 L ,     2 L ,     3 L ,     4 L ,     5 L ,     6 L ,     7 L ,     8 L ,     9 L )  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["fromMessageToList"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "String   payload    =     \"  {  \\  \" string \\  \"  :  \\  \" foo \\  \"  }  \"  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", "Method   method    =    getClass (  )  . getDeclaredMethod (  \" handleMessage \"  ,    Message . class )  ;", "MethodParameter   param    =    new   MethodParameter ( method ,     0  )  ;", "Object   actual    =    converter . fromMessage ( message ,     . MyBean . class ,    param )  ;", "assertTrue (  ( actual   instanceof    . MyBean )  )  ;", "assertEquals (  \" foo \"  ,     (  (  . MyBean )     ( actual )  )  . getString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageToMessageWithPojo"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "String   payload    =     \"  {  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  ,  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  ,  \"     +     \"  \\  \" number \\  \"  :  4  2  ,  \\  \" string \\  \"  :  \\  \" Foo \\  \"  ,  \\  \" bool \\  \"  : true ,  \\  \" fraction \\  \"  :  4  2  .  0  }  \"  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "HashMap < String ,    Object >    actual    =     (  ( HashMap < String ,    Object >  )     ( converter . fromMessage ( message ,    HashMap . class )  )  )  ;", "assertEquals (  \" Foo \"  ,    actual . get (  \" string \"  )  )  ;", "assertEquals (  4  2  ,    actual . get (  \" number \"  )  )  ;", "assertEquals (  4  2  .  0  ,     (  ( Double )     ( actual . get (  \" fraction \"  )  )  )  ,     0  .  0  )  ;", "assertEquals ( Arrays . asList (  \" Foo \"  ,     \" Bar \"  )  ,    actual . get (  \" array \"  )  )  ;", "assertEquals ( Boolean . TRUE ,    actual . get (  \" bool \"  )  )  ;", "assertEquals (  \" AQI =  \"  ,    actual . get (  \" bytes \"  )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageUntyped"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "String   payload    =     \"  {  \\  \" string \\  \"  :  \\  \" string \\  \"  ,  \\  \" unknownProperty \\  \"  :  \\  \" value \\  \"  }  \"  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", ". MyBean   myBean    =     (  (  . MyBean )     ( converter . fromMessage ( message ,     . MyBean . class )  )  )  ;", "assertEquals (  \" string \"  ,    myBean . getString (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageValidJsonWithUnknownProperty"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverterTests . JacksonViewBean   bean    =    new   MappingJackson 2 MessageConverterTests . JacksonViewBean (  )  ;", "bean . setWithView 1  (  \" with \"  )  ;", "bean . setWithView 2  (  \" with \"  )  ;", "bean . setWithoutView (  \" with \"  )  ;", "return   bean ;", "}", "METHOD_END"], "methodName": ["jsonViewResponse"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   mimetype    =    new   MimeType (  \" application \"  ,     \" xml \"  ,    StandardCharsets . UTF _  8  )  ;", "converter    =    new    ( mimetype )  ;", "assertThat ( converter . getSupportedMimeTypes (  )  ,    contains ( mimetype )  )  ;", "assertFalse ( converter . getObjectMapper (  )  . getDeserializationConfig (  )  . isEnabled ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES )  )  ;", "}", "METHOD_END"], "methodName": ["mimetypeParametrizedConstructor"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MimeType   jsonMimetype    =    new   MimeType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  8  )  ;", "MimeType   xmlMimetype    =    new   MimeType (  \" application \"  ,     \" xml \"  ,    StandardCharsets . UTF _  8  )  ;", "converter    =    new    ( jsonMimetype ,    xmlMimetype )  ;", "assertThat ( converter . getSupportedMimeTypes (  )  ,    contains ( jsonMimetype ,    xmlMimetype )  )  ;", "assertFalse ( converter . getObjectMapper (  )  . getDeserializationConfig (  )  . isEnabled ( DeserializationFeature . FAIL _ ON _ UNKNOWN _ PROPERTIES )  )  ;", "}", "METHOD_END"], "methodName": ["mimetypesParametrizedConstructor"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", ". MyBean   payload    =    new    . MyBean (  )  ;", "payload . setString (  \" Foo \"  )  ;", "payload . setNumber (  4  2  )  ;", "payload . setFraction (  4  2  .  0 F )  ;", "payload . setArray ( new   String [  ]  {     \" Foo \"  ,     \" Bar \"     }  )  ;", "payload . setBool ( true )  ;", "payload . setBytes ( new   byte [  ]  {     1  ,     2     }  )  ;", "Message <  ?  >    message    =    converter . toMessage ( payload ,    null )  ;", "String   actual    =    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  ,    StandardCharsets . UTF _  8  )  ;", "assertTrue ( actual . contains (  \"  \\  \" string \\  \"  :  \\  \" Foo \\  \"  \"  )  )  ;", "assertTrue ( actual . contains (  \"  \\  \" number \\  \"  :  4  2  \"  )  )  ;", "assertTrue ( actual . contains (  \" fraction \\  \"  :  4  2  .  0  \"  )  )  ;", "assertTrue ( actual . contains (  \"  \\  \" array \\  \"  :  [  \\  \" Foo \\  \"  ,  \\  \" Bar \\  \"  ]  \"  )  )  ;", "assertTrue ( actual . contains (  \"  \\  \" bool \\  \"  : true \"  )  )  ;", "assertTrue ( actual . contains (  \"  \\  \" bytes \\  \"  :  \\  \" AQI =  \\  \"  \"  )  )  ;", "assertEquals (  \" Invalid   content - type \"  ,    new   MimeType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  8  )  ,    message . getHeaders (  )  . get ( MessageHeaders . CONTENT _ TYPE ,    MimeType . class )  )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "Method   method    =    getClass (  )  . getDeclaredMethod (  \" jsonViewResponse \"  )  ;", "MethodParameter   returnType    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "Message <  ?  >    message    =    converter . toMessage ( jsonViewResponse (  )  ,    new   MessageHeaders ( map )  ,    returnType )  ;", "String   actual    =    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  ,    StandardCharsets . UTF _  8  )  ;", "assertThat ( actual ,    containsString (  \"  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  \"  )  )  ;", "assertThat ( actual ,    containsString (  \"  \\  \" withView 2  \\  \"  :  \\  \" with \\  \"  \"  )  )  ;", "assertThat ( actual ,    not ( containsString (  \"  \\  \" withoutView \\  \"  :  \\  \" with \\  \"  \"  )  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" jsonViewPayload \"  ,     . JacksonViewBean . class )  ;", "MethodParameter   param    =    new   MethodParameter ( method ,     0  )  ;", ". JacksonViewBean   back    =     (  (  . JacksonViewBean )     ( converter . fromMessage ( message ,     . JacksonViewBean . class ,    param )  )  )  ;", "assertNull ( back . getWithView 1  (  )  )  ;", "assertEquals (  \" with \"  ,    back . getWithView 2  (  )  )  ;", "assertNull ( back . getWithoutView (  )  )  ;", "}", "METHOD_END"], "methodName": ["toMessageJsonView"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "MimeType   contentType    =    new   MimeType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  1  6 BE )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( MessageHeaders . CONTENT _ TYPE ,    contentType )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( map )  ;", "String   payload    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "Message <  ?  >    message    =    converter . toMessage ( payload ,    headers )  ;", "assertEquals (  (  (  \"  \\  \"  \"     +    payload )     +     \"  \\  \"  \"  )  ,    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  ,    StandardCharsets . UTF _  1  6 BE )  )  ;", "assertEquals ( contentType ,    message . getHeaders (  )  . get ( MessageHeaders . CONTENT _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["toMessageUtf16"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MappingJackson 2 MessageConverter   converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "converter . setSerializedPayloadClass ( String . class )  ;", "MimeType   contentType    =    new   MimeType (  \" application \"  ,     \" json \"  ,    StandardCharsets . UTF _  1  6 BE )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( MessageHeaders . CONTENT _ TYPE ,    contentType )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( map )  ;", "String   payload    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "Message <  ?  >    message    =    converter . toMessage ( payload ,    headers )  ;", "assertEquals (  (  (  \"  \\  \"  \"     +    payload )     +     \"  \\  \"  \"  )  ,    message . getPayload (  )  )  ;", "assertEquals ( contentType ,    message . getHeaders (  )  . get ( MessageHeaders . CONTENT _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["toMessageUtf16String"], "fileName": "org.springframework.messaging.converter.MappingJackson2MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . marshaller ;", "}", "METHOD_END"], "methodName": ["getMarshaller"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( payload   instanceof   byte [  ]  )     {", "return   new   StreamSource ( new   ByteArrayInputStream (  (  ( byte [  ]  )     ( payload )  )  )  )  ;", "} else    {", "return   new   StreamSource ( new   StReader (  (  ( St )     ( payload )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "return   this . unmarshaller ;", "}", "METHOD_END"], "methodName": ["getUnmarshaller"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . marshaller    =    marshaller ;", "}", "METHOD_END"], "methodName": ["setMarshaller"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "this . unmarshaller    =    unmarshaller ;", "}", "METHOD_END"], "methodName": ["setUnmarshaller"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Jaxb 2 Marshaller   marshaller    =    new   Jaxb 2 Marshaller (  )  ;", "marshaller . setClassesToBeBound (  . MyBean . class )  ;", "marshaller . afterPropertiesSet (  )  ;", "this . converter    =    new   MarshallingMessageConverter ( marshaller )  ;", "}", "METHOD_END"], "methodName": ["createMarshaller"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   payload    =     \"  < myBean >  < name > Foo <  / name >  <  / myBean >  \"  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", ". MyBean   actual    =     (  (  . MyBean )     ( this . converter . fromMessage ( message ,     . MyBean . class )  )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  \" Foo \"  ,    actual . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessage"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   payload    =     \"  < myBean >  < name > Foo <  / name >  < myBean >  \"  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", "this . converter . fromMessage ( message ,     . MyBean . class )  ;", "}", "METHOD_END"], "methodName": ["fromMessageInvalidXml"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   payload    =     \"  < myBean >  < age >  4  2  <  / age >  < myBean >  \"  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", "this . converter . fromMessage ( message ,     . MyBean . class )  ;", "}", "METHOD_END"], "methodName": ["fromMessageValidXmlWithUnknownProperty"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MarshallingMessageConverterTests . MyBean   payload    =    new   MarshallingMessageConverterTests . MyBean (  )  ;", "payload . setName (  \" Foo \"  )  ;", "Message <  ?  >    message    =    this . converter . toMessage ( payload ,    null )  ;", "assertNotNull ( message )  ;", "String   actual    =    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  ,    StandardCharsets . UTF _  8  )  ;", "DifferenceEvaluator   ev    =    chain ( Default ,    downgradeDifferencesToEqual ( XML _ STANDALONE )  )  ;", "assertThat ( actual ,    isSimilarTo (  \"  < myBean >  < name > Foo <  / name >  <  / myBean >  \"  )  . withDifferenceEvaluator ( ev )  )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.springframework.messaging.converter.MarshallingMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . converter    =    new   MessageConverterTests . TestMessageConverter ( Arrays . asList ( TEXT _ PLAIN )  )  ;", "this . converter . setStrictContentTypeMatch ( true )  ;", "Message < String >    message    =    MessageBuilder . withPayload (  \" ABC \"  )  . build (  )  ;", "assertFalse ( this . converter . canConvertFrom ( message ,    String . class )  )  ;", "message    =    MessageBuilder . withPayload (  \" ABC \"  )  . setHeader ( MessageHeaders . CONTENT _ TYPE ,    TEXT _ PLAIN )  . build (  )  ;", "assertTrue ( this . converter . canConvertFrom ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["canConvertFromStrictContentTypeMatch"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "this . converter    =    new   MessageConverterTests . TestMessageConverter ( Collections .  < MimeType > emptyList (  )  )  ;", "this . converter . setStrictContentTypeMatch ( true )  ;", "}", "METHOD_END"], "methodName": ["setStrictContentTypeMatchWithNoSupportedMimeTypes"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" ABC \"  )  . setHeader ( MessageHeaders . CONTENT _ TYPE ,    TEXT _ PLAIN )  . build (  )  ;", "assertEquals (  \" success - from \"  ,    thisfromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["supportsMimeType"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" ABC \"  )  . setHeader ( MessageHeaders . CONTENT _ TYPE ,    APPLICATION _ JSON )  . build (  )  ;", "this . converter    =    new    . TestMessageConverter ( Collections .  < MimeType > emptyList (  )  )  ;", "assertEquals (  \" success - from \"  ,    this . converter . fromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["supportsMimeTypeNoneConfigured"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" ABC \"  )  . build (  )  ;", "assertEquals (  \" success - from \"  ,    thisfromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["supportsMimeTypeNotSpecified"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" ABC \"  )  . setHeader ( MessageHeaders . CONTENT _ TYPE ,    APPLICATION _ JSON )  . build (  )  ;", "assertNull ( thisfromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["supportsMimeTypeNotSupported"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" ABC \"  )  . build (  )  ;", "assertEquals (  \" success - from \"  ,    thisfromMessage ( message ,    String . class )  )  ;", "assertNull ( thisfromMessage ( message ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["supportsTargetClass"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    this . converter . toMessage (  \" ABC \"  ,    null )  ;", "assertEquals ( TEXT _ PLAIN ,    message . getHeaders (  )  . get ( MessageHeaders . CONTENT _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["toMessageContentTypeHeader"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( map )  ;", "Message <  ?  >    message    =    thistoMessage (  \" ABC \"  ,    headers )  ;", "assertNotNull ( message . getHeaders (  )  . getId (  )  )  ;", "assertNotNull ( message . getHeaders (  )  . getTimestamp (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    message . getHeaders (  )  . get ( MessageHeaders . CONTENT _ TYPE )  )  ;", "assertEquals (  \" bar \"  ,    message . getHeaders (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["toMessageWithHeaders"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create ( SimpMessageType . MESSAGE )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar \"  )  ;", "accessor . setNativeHeader (  \" fooNative \"  ,     \" barNative \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "Message <  ?  >    message    =    thistoMessage (  \" ABC \"  ,    headers )  ;", "assertSame ( headers ,    message . getHeaders (  )  )  ;", "assertNull ( message . getHeaders (  )  . getId (  )  )  ;", "assertNull ( message . getHeaders (  )  . getTimestamp (  )  )  ;", "assertEquals ( TEXT _ PLAIN ,    message . getHeaders (  )  . get ( MessageHeaders . CONTENT _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["toMessageWithMutableMessageHeaders"], "fileName": "org.springframework.messaging.converter.MessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers    =    new   MessageHeaders ( Collections .  < String ,    Object > singletonMap (  \" foo \"  ,     \" bar \"  )  )  ;", "Message <  ?  >    message    =    thistoMessage (  \" payload \"  ,    headers )  ;", "assertEquals (  \" payload \"  ,    message . getPayload (  )  )  ;", "assertEquals (  \" bar \"  ,    message . getHeaders (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["toMessageWithPayloadAndHeaders"], "fileName": "org.springframework.messaging.converter.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "Message <  ?  >    message    =    thistoMessage (  \" payload \"  ,    headers )  ;", "assertEquals (  \" payload \"  ,    message . getPayload (  )  )  ;", "assertSame ( headers ,    message . getHeaders (  )  )  ;", "assertEquals (  \" bar \"  ,    message . getHeaders (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["toMessageWithPayloadAndMutableHeaders"], "fileName": "org.springframework.messaging.converter.SimpleMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mimeType    !  =    null )     &  &     (  ( mimeType . getCharset (  )  )     !  =    null )  )     {", "return   mimeType . getCharset (  )  ;", "} else    {", "return   this . defaultCharset ;", "}", "}", "METHOD_END"], "methodName": ["getContentTypeCharset"], "fileName": "org.springframework.messaging.converter.StringMessageConverter"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload (  \" ABC \"  . getBytes (  )  )  . setHeader ( MessageHeaders . CONTENT _ TYPE ,    TEXT _ PLAIN )  . build (  )  ;", "assertEquals (  \" ABC \"  ,    thisfromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["fromByteArrayMessage"], "fileName": "org.springframework.messaging.converter.StringMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload (  \" ABC \"  . getBytes (  )  )  . setHeader ( MessageHeaders . CONTENT _ TYPE ,    TEXT _ PLAIN )  . build (  )  ;", "assertEquals (  \" ABC \"  ,    thisfromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageByteArray"], "fileName": "org.springframework.messaging.converter.StringMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   payload    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . ISO _  8  8  5  9  _  1  )  )  . setHeader ( MessageHeaders . CONTENT _ TYPE ,    new   MimeType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . ISO _  8  8  5  9  _  1  )  )  . build (  )  ;", "assertEquals ( payload ,    thisfromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageCharset"], "fileName": "org.springframework.messaging.converter.StringMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "String   payload    =     \" H \\ u 0  0 e 9 llo   W \\ u 0  0 f 6 rld \"  ;", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  . build (  )  ;", "assertEquals ( payload ,    thisfromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageDefaultCharset"], "fileName": "org.springframework.messaging.converter.StringMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload (  \" ABC \"  . getBytes (  )  )  . build (  )  ;", "assertEquals (  \" ABC \"  ,    thisfromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageNoContentTypeHeader"], "fileName": "org.springframework.messaging.converter.StringMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload (  \" ABC \"  . getBytes (  )  )  . build (  )  ;", "assertNull ( thisfromMessage ( message ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["fromMessageTargetClassNotSupported"], "fileName": "org.springframework.messaging.converter.StringMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" ABC \"  )  . setHeader ( MessageHeaders . CONTENT _ TYPE ,    TEXT _ PLAIN )  . build (  )  ;", "assertEquals (  \" ABC \"  ,    thisfromMessage ( message ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["fromStringMessage"], "fileName": "org.springframework.messaging.converter.StringMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( MessageHeaders . CONTENT _ TYPE ,    TEXT _ PLAIN )  ;", "MessageHeaders   headers    =    new   MessageHeaders ( map )  ;", "Message <  ?  >    message    =    thistoMessage (  \" ABC \"  ,    headers )  ;", "assertEquals (  \" ABC \"  ,    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.springframework.messaging.converter.StringMessageConverterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationResolver ;", "}", "METHOD_END"], "methodName": ["getDestinationResolver"], "fileName": "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . destinationResolver )     !  =    null )  ,     \" DestinationResolver   is   required   to   resolve   destination   names \"  )  ;", "return   this . destinationResolver . resolveDestination ( destinationName )  ;", "}", "METHOD_END"], "methodName": ["resolveDestination"], "fileName": "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . destinationResolver    =    destinationResolver ;", "}", "METHOD_END"], "methodName": ["setDestinationResolver"], "fileName": "org.springframework.messaging.core.AbstractDestinationResolvingMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "MessageConverter   messageConverter    =    getMessageConverter (  )  ;", "T   value    =     (  ( T )     ( messageConverter . fromMessage ( message ,    targetClass )  )  )  ;", "if    ( value    =  =    null )     {", "throw   new   MessageConversionException ( message ,     (  (  (  (  (  (  \" Unable   to   convert   payload    [  \"     +     ( message . getPayload (  )  )  )     +     \"  ]    to   type    [  \"  )     +    targetClass )     +     \"  ]    using   converter    [  \"  )     +    messageConverter )     +     \"  ]  \"  )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["doConvert"], "fileName": "org.springframework.messaging.core.AbstractMessageReceivingTemplate"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   messageHeaders    =    null ;", "Object   conversionHint    =     ( headers    !  =    null )     ?    headers . get (  . CONVERSION _ HINT _ HEADER )     :    null ;", "Map < String ,    Object >    headersToUse    =    processHeadersToSend ( headers )  ;", "if    ( headersToUse    !  =    null )     {", "if    ( headersToUse   instanceof   MessageHeaders )     {", "messageHeaders    =     (  ( MessageHeaders )     ( headersToUse )  )  ;", "} else    {", "messageHeaders    =    new   MessageHeaders ( headersToUse )  ;", "}", "}", "MessageConverter   converter    =    getMessageConverter (  )  ;", "Message <  ?  >    message    =     ( converter   instanceof   SmartMessageConverter )     ?     (  ( SmartMessageConverter )     ( converter )  )  . toMessage ( payload ,    messageHeaders ,    conversionHint )     :    converter . toMessage ( payload ,    messageHeaders )  ;", "if    ( message    =  =    null )     {", "String   payloadType    =    payload . getClass (  )  . getName (  )  ;", "Object   contentType    =     ( messageHeaders    !  =    null )     ?    messageHeaders . get ( MessageHeaders . CONTENT _ TYPE )     :    null ;", "throw   new   MessageConversionException (  (  (  (  (  (  (  \" Unable   to   convert   payload   with   type =  '  \"     +    payloadType )     +     \"  '  ,    contentType =  '  \"  )     +    contentType )     +     \"  '  ,    converter =  [  \"  )     +     ( getMessageConverter (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "if    ( postProcessor    !  =    null )     {", "message    =    postProcessor . postProcessMessage ( message )  ;", "}", "return   message ;", "}", "METHOD_END"], "methodName": ["doConvert"], "fileName": "org.springframework.messaging.core.AbstractMessageSendingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultDestination ;", "}", "METHOD_END"], "methodName": ["getDefaultDestination"], "fileName": "org.springframework.messaging.core.AbstractMessageSendingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . converter ;", "}", "METHOD_END"], "methodName": ["getMessageConverter"], "fileName": "org.springframework.messaging.core.AbstractMessageSendingTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . defaultDestination )     !  =    null )  ,     \" No    ' defaultDestination '    configured \"  )  ;", "return   this . defaultDestination ;", "}", "METHOD_END"], "methodName": ["getRequiredDefaultDestination"], "fileName": "org.springframework.messaging.core.AbstractMessageSendingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   headers ;", "}", "METHOD_END"], "methodName": ["processHeadersToSend"], "fileName": "org.springframework.messaging.core.AbstractMessageSendingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . defaultDestination    =    defaultDestination ;", "}", "METHOD_END"], "methodName": ["setDefaultDestination"], "fileName": "org.springframework.messaging.core.AbstractMessageSendingTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messageConverter ,     \" MessageConverter   must   not   be   null \"  )  ;", "this . converter    =    messageConverter ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.messaging.core.AbstractMessageSendingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . targetDestinationResolver    =    targetDestinationResolver ;", "}", "METHOD_END"], "methodName": ["setTargetDestinationResolver"], "fileName": "org.springframework.messaging.core.CachingDestinationResolverProxy"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "DestinationResolver < String >    resolver    =    mock ( DestinationResolver . class )  ;", "Proxy < String >    resolverProxy    =    new   Proxy <  >  ( resolver )  ;", "given ( resolver . resolveDestination (  \" abcd \"  )  )  . willReturn (  \" dcba \"  )  ;", "given ( resolver . resolveDestination (  \"  1  2  3  4  \"  )  )  . willReturn (  \"  4  3  2  1  \"  )  ;", "assertEquals (  \" dcba \"  ,    resolverProxy . resolveDestination (  \" abcd \"  )  )  ;", "assertEquals (  \"  4  3  2  1  \"  ,    resolverProxy . resolveDestination (  \"  1  2  3  4  \"  )  )  ;", "assertEquals (  \"  4  3  2  1  \"  ,    resolverProxy . resolveDestination (  \"  1  2  3  4  \"  )  )  ;", "assertEquals (  \" dcba \"  ,    resolverProxy . resolveDestination (  \" abcd \"  )  )  ;", "verify ( resolver ,    times (  1  )  )  . resolveDestination (  \" abcd \"  )  ;", "verify ( resolver ,    times (  1  )  )  . resolveDestination (  \"  1  2  3  4  \"  )  ;", "}", "METHOD_END"], "methodName": ["cachedDestination"], "fileName": "org.springframework.messaging.core.CachingDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "CachingDestinationResolverProxy < String >    resolverProxy    =    new   CachingDestinationResolverProxy <  >  (  )  ;", "resolverProxy . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["noTargetSet"], "fileName": "org.springframework.messaging.core.CachingDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   CachingDestinationResolverProxy < String >  ( null )  ;", "}", "METHOD_END"], "methodName": ["nullTargetThroughConstructor"], "fileName": "org.springframework.messaging.core.CachingDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . template . convertAndSend (  \" myChannel \"  ,     \" payload \"  )  ;", "assertSame ( this . myChannel ,    this . template . messageChannel )  ;", "assertNotNull ( this . template . message )  ;", "assertSame (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayload"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . convertAndSend (  \" myChannel \"  ,     \" payload \"  ,    this . headers )  ;", "assertSame ( this . myChannel ,    this . template . messageChannel )  ;", "assertNotNull ( this . template . message )  ;", "assertEquals (  \" value \"  ,    this . template . message . getHeaders (  )  . get (  \" key \"  )  )  ;", "assertEquals (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadAndHeaders"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . convertAndSend (  \" myChannel \"  ,     \" payload \"  ,    this . headers ,    this . postProcessor )  ;", "assertSame ( this . myChannel ,    this . template . messageChannel )  ;", "assertNotNull ( this . template . message )  ;", "assertEquals (  \" value \"  ,    this . template . message . getHeaders (  )  . get (  \" key \"  )  )  ;", "assertEquals (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "assertNotNull ( this . postProcessor . getMessage (  )  )  ;", "assertSame ( this . postProcessor . getMessage (  )  ,    this . template . message )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadAndHeadersWithPostProcessor"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . convertAndSend (  \" myChannel \"  ,     \" payload \"  ,    this . postProcessor )  ;", "assertSame ( this . myChannel ,    this . template . messageChannel )  ;", "assertNotNull ( this . template . message )  ;", "assertEquals (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "assertNotNull ( this . postProcessor . getMessage (  )  )  ;", "assertSame ( this . postProcessor . getMessage (  )  ,    this . template . message )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadWithPostProcessor"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . t . setReceiveMessage ( responseMessage )  ;", "String   actual    =    this . t . convertSendAndReceive (  \" myChannel \"  ,     \" request \"  ,    String . class )  ;", "assertEquals (  \" request \"  ,    this . t . message . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    actual )  ;", "assertSame ( this . myChannel ,    this . t . messageChannel )  ;", "}", "METHOD_END"], "methodName": ["convertSendAndReceive"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . t . setReceiveMessage ( responseMessage )  ;", "String   actual    =    this . t . convertSendAndReceive (  \" myChannel \"  ,     \" request \"  ,    this . headers ,    String . class )  ;", "assertEquals (  \" value \"  ,    this . t . message . getHeaders (  )  . get (  \" key \"  )  )  ;", "assertEquals (  \" request \"  ,    this . t . message . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    actual )  ;", "assertSame ( this . myChannel ,    this . t . messageChannel )  ;", "}", "METHOD_END"], "methodName": ["convertSendAndReceiveWithHeaders"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . t . setReceiveMessage ( responseMessage )  ;", "String   actual    =    this . t . convertSendAndReceive (  \" myChannel \"  ,     \" request \"  ,    this . headers ,    String . class ,    this . postProcessor )  ;", "assertEquals (  \" value \"  ,    this . t . message . getHeaders (  )  . get (  \" key \"  )  )  ;", "assertEquals (  \" request \"  ,    this . t . message . getPayload (  )  )  ;", "assertSame (  \" request \"  ,    this . postProcessor . getMessage (  )  . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    actual )  ;", "assertSame ( this . myChannel ,    this . t . messageChannel )  ;", "}", "METHOD_END"], "methodName": ["convertSendAndReceiveWithHeadersAndPostProcessor"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . t . setReceiveMessage ( responseMessage )  ;", "String   actual    =    this . t . convertSendAndReceive (  \" myChannel \"  ,     \" request \"  ,    String . class ,    this . postProcessor )  ;", "assertEquals (  \" request \"  ,    this . t . message . getPayload (  )  )  ;", "assertSame (  \" request \"  ,    this . postProcessor . getMessage (  )  . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    actual )  ;", "assertSame ( this . myChannel ,    this . t . messageChannel )  ;", "}", "METHOD_END"], "methodName": ["convertSendAndReceiveWithPostProcessor"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    new   GenericMessage < Object >  (  \" payload \"  )  ;", "this . t . setReceiveMessage ( expected )  ;", "Message <  ?  >    actual    =    this . t . receive (  \" myChannel \"  )  ;", "assertSame ( expected ,    actual )  ;", "assertSame ( this . myChannel ,    this . t . messageChannel )  ;", "}", "METHOD_END"], "methodName": ["receive"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    new   GenericMessage < Object >  (  \" payload \"  )  ;", "this . t . setReceiveMessage ( expected )  ;", "String   payload    =    this . t . receiveAndConvert (  \" myChannel \"  ,    String . class )  ;", "assertEquals (  \" payload \"  ,    payload )  ;", "assertSame ( this . myChannel ,    this . t . messageChannel )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvert"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    new   GenericMessage < Object >  (  \" payload \"  )  ;", "this . t . send (  \" myChannel \"  ,    message )  ;", "assertSame ( this . myChannel ,    this . t . messageChannel )  ;", "assertSame ( message ,    this . t . message )  ;", "}", "METHOD_END"], "methodName": ["send"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    requestMessage    =    new   GenericMessage < Object >  (  \" request \"  )  ;", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . t . setReceiveMessage ( responseMessage )  ;", "Message <  ?  >    actual    =    this . t . sendAndReceive (  \" myChannel \"  ,    requestMessage )  ;", "assertEquals ( requestMessage ,    this . t . message )  ;", "assertSame ( responseMessage ,    actual )  ;", "assertSame ( this . myChannel ,    this . t . messageChannel )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceive"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "DestinationResolvingMessagingTemplateTests . TestDestinationResolvingMessagingTemplate   template    =    new   DestinationResolvingMessagingTemplateTests . TestDestinationResolvingMessagingTemplate (  )  ;", "template . send (  \" myChannel \"  ,    new   GenericMessage < Object >  (  \" payload \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sendNoDestinationResolver"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "TestMessageChannelDestinationResolver   resolver    =    new   TestMessageChannelDestinationResolver (  )  ;", "this . myChannel    =    new   ExecutorSubscribableChannel (  )  ;", "resolver . registerMessageChannel (  \" myChannel \"  ,    this . myChannel )  ;", "this . template    =    new    . TestDestinationResolvingMessagingTemplate (  )  ;", "this . template . setDestinationResolver ( resolver )  ;", "this . headers    =    Collections .  < String ,    Object > singletonMap (  \" key \"  ,     \" value \"  )  ;", "this . postProcessor    =    new   TestMessagePostProcessor (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.core.DestinationResolvingMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( channel ,     \" MessageChannel   is   required \"  )  ;", "Assert . state (  ( channel   instanceof   PollableChannel )  ,     \" A   PollableChannel   is   required   to   receive   messages \"  )  ;", "Message <  ?  >    message    =     ( timeout    >  =     0  )     ?     (  ( PollableChannel )     ( channel )  )  . receive ( timeout )     :     (  ( PollableChannel )     ( channel )  )  . receive (  )  ;", "if    (  ( message    =  =    null )     &  &     ( this . logger . isTraceEnabled (  )  )  )     {", "this . logger . trace (  (  (  (  \" Failed   to   receive   message   from   channel    '  \"     +    channel )     +     \"  '    within   timeout :     \"  )     +    timeout )  )  ;", "}", "return   message ;", "}", "METHOD_END"], "methodName": ["doReceive"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( channel ,     \" MessageChannel   is   required \"  )  ;", "Message <  ?  >    messageToSend    =    message ;", "MessageHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    MessageHeaderAccessor . class )  ;", "if    (  ( accessor    !  =    null )     &  &     ( accessor . isMutable (  )  )  )     {", "accessor . removeHeader ( this . sendTimeoutHeader )  ;", "accessor . removeHeader ( this . receiveTimeoutHeader )  ;", "accessor . setImmutable (  )  ;", "} else", "if    (  ( message . getHeaders (  )  . containsKey ( this . sendTimeoutHeader )  )     |  |     ( message . getHeaders (  )  . containsKey ( this . receiveTimeoutHeader )  )  )     {", "messageToSend    =    support . MessageBuilder . fromMessage ( message )  . setHeader ( this . sendTimeoutHeader ,    null )  . setHeader ( this . receiveTimeoutHeader ,    null )  . build (  )  ;", "}", "boolean   sent    =     ( timeout    >  =     0  )     ?    channel . send ( messageToSend ,    timeout )     :    channel . send ( messageToSend )  ;", "if    (  ! sent )     {", "throw   new   MessageDeliveryException ( message ,     (  (  (  \" Failed   to   send   message   to   channel    '  \"     +    channel )     +     \"  '    within   timeout :     \"  )     +    timeout )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doSend"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . receiveTimeout ;", "}", "METHOD_END"], "methodName": ["getReceiveTimeout"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . receiveTimeoutHeader ;", "}", "METHOD_END"], "methodName": ["getReceiveTimeoutHeader"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . sendTimeout ;", "}", "METHOD_END"], "methodName": ["getSendTimeout"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . sendTimeoutHeader ;", "}", "METHOD_END"], "methodName": ["getSendTimeoutHeader"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "if    ( headerValue   instanceof   Number )     {", "return    (  ( Number )     ( headerValue )  )  . longValue (  )  ;", "} else", "if    ( headerValue   instanceof   St )     {", "return   Long . parseLong (  (  ( St )     ( headerValue )  )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["headerToLong"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "Long   receiveTimeout    =    headerToLong ( requestMessage . getHeaders (  )  . get ( this . receiveTimeoutHeader )  )  ;", "return   receiveTimeout    !  =    null    ?    receiveTimeout    :    this . receiveTimeout ;", "}", "METHOD_END"], "methodName": ["receiveTimeout"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "Long   sendTimeout    =    headerToLong ( requestMessage . getHeaders (  )  . get ( this . sendTimeoutHeader )  )  ;", "return   sendTimeout    !  =    null    ?    sendTimeout    :    this . sendTimeout ;", "}", "METHOD_END"], "methodName": ["sendTimeout"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . receiveTimeout    =    receiveTimeout ;", "}", "METHOD_END"], "methodName": ["setReceiveTimeout"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( receiveTimeoutHeader ,     \"  ' receiveTimeoutHeader '    cannot   be   null \"  )  ;", "this . receiveTimeoutHeader    =    receiveTimeoutHeader ;", "}", "METHOD_END"], "methodName": ["setReceiveTimeoutHeader"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . sendTimeout    =    sendTimeout ;", "}", "METHOD_END"], "methodName": ["setSendTimeout"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( sendTimeoutHeader ,     \"  ' sendTimeoutHeader '    cannot   be   null \"  )  ;", "this . sendTimeoutHeader    =    sendTimeoutHeader ;", "}", "METHOD_END"], "methodName": ["setSendTimeoutHeader"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . throwExceptionOnLateReply    =    throwExceptionOnLateReply ;", "}", "METHOD_END"], "methodName": ["setThrowExceptionOnLateReply"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setHeader (  \" key \"  ,     \" value \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "this . t . convertAndSend (  \" channel \"  ,     \" data \"  ,    headers )  ;", "List < Message < byte [  ]  >  >    messages    =    this . messageChannel . getMessages (  )  ;", "Message < byte [  ]  >    message    =    messages . get (  0  )  ;", "assertSame ( headers ,    message . getHeaders (  )  )  ;", "assertFalse ( accessor . isMutable (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendWithSimpMessageHeaders"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "MessageHandler   handler    =     (    message )     -  >     {", "try    {", "Thread . sleep (  5  0  0  )  ;", "MessageChannel   replyChannel    =     (  ( MessageChannel )     ( message . getHeaders (  )  . getReplyChannel (  )  )  )  ;", "replyChannel . send ( new   e <  >  (  \" response \"  )  )  ;", "failure . set ( new   IllegalStateException (  \" Expected   exception \"  )  )  ;", "}    catch    ( InterruptedException   e )     {", "failure . set ( e )  ;", "}    catch    ( MessageDeliveryException   ex )     {", "String   expected    =     \" Reply   message   received   but   the   receiving   thread   has   exited   due   to   a   timeout \"  ;", "String   actual    =    ex . getMessage (  )  ;", "if    (  !  ( expected . equals ( actual )  )  )     {", "failure . set ( new   IllegalStateException (  (  (  \" Unexpected   error :     '  \"     +    actual )     +     \"  '  \"  )  )  )  ;", "}", "}    finally    {", "latch . countDown (  )  ;", "}", "}  ;", "return   handler ;", "}", "METHOD_END"], "methodName": ["createLateReplier"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SubscribableChannel   channel    =    new   ExecutorSubscribableChannel ( this . executor )  ;", "channel . subscribe ( new   MessageHandler (  )     {", "@ Override", "public   void   handleMessage ( Message <  ?  >    message )    throws   MessagingException    {", "MessageChannel   replyChannel    =     (  ( MessageChannel )     ( message . getHeaders (  )  . getReplyChannel (  )  )  )  ;", "replyChannel . send ( new   e <  >  (  \" response \"  )  )  ;", "}", "}  )  ;", "String   actual    =    this . template . convertSendAndReceive ( channel ,     \" request \"  ,    String . class )  ;", "assertEquals (  \" response \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceive"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   AtomicReference < Throwable >    failure    =    new   AtomicReference < Throwable >  (  )  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "this . t . setReceiveTimeout (  1  )  ;", "this . t . setSendTimeout (  3  0  0  0  0 L )  ;", "this . t . setThrowExceptionOnLateReply ( true )  ;", "SubscribableChannel   channel    =    mock ( SubscribableChannel . class )  ;", "MessageHandler   handler    =    createLateReplier ( latch ,    failure )  ;", "doAnswer (  (    invocation )     -  >     {", "this . executor . execute (  (  )     -  >     {", "handler . handleMessage ( invocation . getArgument (  0  )  )  ;", "}  )  ;", "return   true ;", "}  )  . when ( channel )  . send ( any ( Message . class )  ,    anyLong (  )  )  ;", "assertNull ( this . t . convertSendAndReceive ( channel ,     \" request \"  ,    String . class )  )  ;", "assertTrue ( latch . await (  1  0  0  0  0  ,    TimeUnit . MILLISECONDS )  )  ;", "Throwable   ex    =    failure . get (  )  ;", "if    ( ex    !  =    null )     {", "throw   new   AssertionError ( ex )  ;", "}", "verify ( channel )  . send ( any ( Message . class )  ,    eq (  3  0  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceiveTimeout"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   AtomicReference < Throwable >    failure    =    new   AtomicReference < Throwable >  (  )  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "this . template . setSendTimeout (  2  0  0  0  0  )  ;", "this . template . setReceiveTimeout (  1  0  0  0  0  )  ;", "this . template . setThrowExceptionOnLateReply ( true )  ;", "SubscribableChannel   channel    =    mock ( SubscribableChannel . class )  ;", "MessageHandler   handler    =    createLateReplier ( latch ,    failure )  ;", "doAnswer (  (    invocation )     -  >     {", "this . executor . execute (  (  )     -  >     {", "handler . handleMessage ( invocation . getArgument (  0  )  )  ;", "}  )  ;", "return   true ;", "}  )  . when ( channel )  . send ( any ( Message . class )  ,    anyLong (  )  )  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" request \"  )  . setHeader (  . DEFAULT _ SEND _ TIMEOUT _ HEADER ,     3  0  0  0  0 L )  . setHeader (  . DEFAULT _ RECEIVE _ TIMEOUT _ HEADER ,     1 L )  . build (  )  ;", "assertNull ( this . template . sendAndReceive ( channel ,    message )  )  ;", "assertTrue ( latch . await (  1  0  0  0  0  ,    TimeUnit . MILLISECONDS )  )  ;", "Throwable   ex    =    failure . get (  )  ;", "if    ( ex    !  =    null )     {", "throw   new   AssertionError ( ex )  ;", "}", "verify ( channel )  . send ( any ( Message . class )  ,    eq (  3  0  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceiveVariableTimeout"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "final   AtomicReference < Throwable >    failure    =    new   AtomicReference < Throwable >  (  )  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "this . t . setSendTimeout (  2  0  0  0  0  )  ;", "this . t . setReceiveTimeout (  1  0  0  0  0  )  ;", "this . t . setThrowExceptionOnLateReply ( true )  ;", "this . t . setSendTimeoutHeader (  \" sto \"  )  ;", "this . t . setReceiveTimeoutHeader (  \" rto \"  )  ;", "SubscribableChannel   channel    =    mock ( SubscribableChannel . class )  ;", "MessageHandler   handler    =    createLateReplier ( latch ,    failure )  ;", "doAnswer (  (    invocation )     -  >     {", "this . executor . execute (  (  )     -  >     {", "handler . handleMessage ( invocation . getArgument (  0  )  )  ;", "}  )  ;", "return   true ;", "}  )  . when ( channel )  . send ( any ( Message . class )  ,    anyLong (  )  )  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" request \"  )  . setHeader (  \" sto \"  ,     3  0  0  0  0 L )  . setHeader (  \" rto \"  ,     1 L )  . build (  )  ;", "assertNull ( this . t . sendAndReceive ( channel ,    message )  )  ;", "assertTrue ( latch . await (  1  0  0  0  0  ,    TimeUnit . MILLISECONDS )  )  ;", "Throwable   ex    =    failure . get (  )  ;", "if    ( ex    !  =    null )     {", "throw   new   AssertionError ( ex )  ;", "}", "verify ( channel )  . send ( any ( Message . class )  ,    eq (  3  0  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceiveVariableTimeoutCustomHeaders"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SubscribableChannel   channel    =    mock ( SubscribableChannel . class )  ;", "final   AtomicReference < Message <  ?  >  >    sent    =    new   AtomicReference <  >  (  )  ;", "doAnswer (  (    invocation )     -  >     {", "sent . set ( invocation . getArgument (  0  )  )  ;", "return   true ;", "}  )  . when ( channel )  . send ( any ( Message . class )  ,    eq (  3  0  0  0  0 L )  )  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" request \"  )  . setHeader (  . DEFAULT _ SEND _ TIMEOUT _ HEADER ,     3  0  0  0  0 L )  . setHeader (  . DEFAULT _ RECEIVE _ TIMEOUT _ HEADER ,     1 L )  . build (  )  ;", "this . template . send ( channel ,    message )  ;", "verify ( channel )  . send ( any ( Message . class )  ,    eq (  3  0  0  0  0 L )  )  ;", "assertNotNull ( sent . get (  )  )  ;", "assertFalse ( sent . get (  )  . getHeaders (  )  . containsKey (  . DEFAULT _ SEND _ TIMEOUT _ HEADER )  )  ;", "assertFalse ( sent . get (  )  . getHeaders (  )  . containsKey (  . DEFAULT _ RECEIVE _ TIMEOUT _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["sendWithTimeout"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SubscribableChannel   channel    =    mock ( SubscribableChannel . class )  ;", "final   AtomicReference < Message <  ?  >  >    sent    =    new   AtomicReference <  >  (  )  ;", "doAnswer (  (    invocation )     -  >     {", "sent . set ( invocation . getArgument (  0  )  )  ;", "return   true ;", "}  )  . when ( channel )  . send ( any ( Message . class )  ,    eq (  3  0  0  0  0 L )  )  ;", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setLeaveMutable ( true )  ;", "Message <  ?  >    message    =    new   GenericMessage <  >  (  \" request \"  ,    accessor . getMessageHeaders (  )  )  ;", "accessor . setHeader (  . DEFAULT _ SEND _ TIMEOUT _ HEADER ,     3  0  0  0  0 L )  ;", "this . template . send ( channel ,    message )  ;", "verify ( channel )  . send ( any ( Message . class )  ,    eq (  3  0  0  0  0 L )  )  ;", "assertNotNull ( sent . get (  )  )  ;", "assertFalse ( sent . get (  )  . getHeaders (  )  . containsKey (  . DEFAULT _ SEND _ TIMEOUT _ HEADER )  )  ;", "assertFalse ( sent . get (  )  . getHeaders (  )  . containsKey (  . DEFAULT _ RECEIVE _ TIMEOUT _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["sendWithTimeoutMutable"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messageChannel    =    new   StubMessageChannel (  )  ;", "this . template    =    new   GenericMessagingTemplate (  )  ;", "this . template . setDefaultDestination ( this . messageChannel )  ;", "this . template . setDestinationResolver ( new    . TestDestinationResolver (  )  )  ;", "this . executor    =    new   ThreadPoolTaskExecutor (  )  ;", "this . executor . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.core.GenericMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    new   GenericMessage <  >  (  \" payload \"  )  ;", "this . template . setDefaultDestination (  \" home \"  )  ;", "this . template . setReceiveMessage ( expected )  ;", "Message <  ?  >    actual    =    this . template . receive (  )  ;", "assertEquals (  \" home \"  ,    this . template . destination )  ;", "assertSame ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["receive"], "fileName": "org.springframework.messaging.core.MessageReceivingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    new   GenericMessage <  >  (  \" payload \"  )  ;", "this . template . setDefaultDestination (  \" home \"  )  ;", "this . template . setReceiveMessage ( expected )  ;", "String   payload    =    this . template . receiveAndConvert ( String . class )  ;", "assertEquals (  \" home \"  ,    this . template . destination )  ;", "assertSame (  \" payload \"  ,    payload )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvert"], "fileName": "org.springframework.messaging.core.MessageReceivingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    new   GenericMessage <  >  (  \" not   a   number   test \"  )  ;", "this . template . setReceiveMessage ( expected )  ;", "this . template . setMessageConverter ( new   GenericMessageConverter (  )  )  ;", "thrown . expect ( MessageConversionException . class )  ;", "thrown . expectCause ( isA ( ConversionFailedException . class )  )  ;", "this . template . receiveAndConvert (  \" somewhere \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvertFailed"], "fileName": "org.springframework.messaging.core.MessageReceivingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    new   GenericMessage <  >  (  \" payload \"  )  ;", "this . template . setReceiveMessage ( expected )  ;", "String   payload    =    this . template . receiveAndConvert (  \" somewhere \"  ,    String . class )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertSame (  \" payload \"  ,    payload )  ;", "}", "METHOD_END"], "methodName": ["receiveAndConvertFromDestination"], "fileName": "org.springframework.messaging.core.MessageReceivingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    new   GenericMessage <  >  (  \" payload \"  )  ;", "this . template . setDefaultDestination (  \" home \"  )  ;", "this . template . setReceiveMessage ( expected )  ;", "this . template . setMessageConverter ( new   GenericMessageConverter (  )  )  ;", "try    {", "this . template . receiveAndConvert ( Writer . class )  ;", "}    catch    ( MessageConversionException   ex )     {", "assertTrue (  (  (  \" Invalid   exception   message    '  \"     +     ( ex . getMessage (  )  )  )     +     \"  '  \"  )  ,    ex . getMessage (  )  . contains (  \" payload \"  )  )  ;", "assertSame ( expected ,    ex . getFailedMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["receiveAndConvertNoConverter"], "fileName": "org.springframework.messaging.core.MessageReceivingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    new   GenericMessage <  >  (  \" payload \"  )  ;", "this . template . setReceiveMessage ( expected )  ;", "Message <  ?  >    actual    =    this . template . receive (  \" somewhere \"  )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertSame ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["receiveFromDestination"], "fileName": "org.springframework.messaging.core.MessageReceivingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . receive (  )  ;", "}", "METHOD_END"], "methodName": ["receiveMissingDefaultDestination"], "fileName": "org.springframework.messaging.core.MessageReceivingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template    =    new   MessageReceivingTemplateTests . TestMessagingTemplate (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.core.MessageReceivingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . template . setDefaultDestination (  \" home \"  )  ;", "this . template . setReceiveMessage ( responseMessage )  ;", "String   response    =    this . template . convertSendAndReceive (  \" request \"  ,    String . class )  ;", "assertEquals (  \" home \"  ,    this . template . destination )  ;", "assertSame (  \" request \"  ,    this . template . requestMessage . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    response )  ;", "}", "METHOD_END"], "methodName": ["convertAndSend"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . template . setReceiveMessage ( responseMessage )  ;", "String   response    =    this . template . convertSendAndReceive (  \" somewhere \"  ,     \" request \"  ,    String . class )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertSame (  \" request \"  ,    this . template . requestMessage . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    response )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendToDestination"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . template . setReceiveMessage ( responseMessage )  ;", "String   response    =    this . template . convertSendAndReceive (  \" somewhere \"  ,     \" request \"  ,    this . headers ,    String . class )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertEquals (  \" value \"  ,    this . template . requestMessage . getHeaders (  )  . get (  \" key \"  )  )  ;", "assertSame (  \" request \"  ,    this . template . requestMessage . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    response )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendToDestinationWithHeaders"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . template . setReceiveMessage ( responseMessage )  ;", "String   response    =    this . template . convertSendAndReceive (  \" somewhere \"  ,     \" request \"  ,    this . headers ,    String . class ,    this . postProcessor )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertEquals (  \" value \"  ,    this . template . requestMessage . getHeaders (  )  . get (  \" key \"  )  )  ;", "assertSame (  \" request \"  ,    this . template . requestMessage . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    response )  ;", "assertSame ( this . postProcessor . getMessage (  )  ,    this . template . requestMessage )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendToDestinationWithHeadersAndPostProcessor"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . template . setReceiveMessage ( responseMessage )  ;", "String   response    =    this . template . convertSendAndReceive (  \" somewhere \"  ,     \" request \"  ,    String . class ,    this . postProcessor )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertSame (  \" request \"  ,    this . template . requestMessage . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    response )  ;", "assertSame ( this . postProcessor . getMessage (  )  ,    this . template . requestMessage )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendToDestinationWithPostProcessor"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . template . setDefaultDestination (  \" home \"  )  ;", "this . template . setReceiveMessage ( responseMessage )  ;", "String   response    =    this . template . convertSendAndReceive (  \" request \"  ,    String . class ,    this . postProcessor )  ;", "assertEquals (  \" home \"  ,    this . template . destination )  ;", "assertSame (  \" request \"  ,    this . template . requestMessage . getPayload (  )  )  ;", "assertSame (  \" response \"  ,    response )  ;", "assertSame ( this . postProcessor . getMessage (  )  ,    this . template . requestMessage )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendWithPostProcessor"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    requestMessage    =    new   GenericMessage < Object >  (  \" request \"  )  ;", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . template . setDefaultDestination (  \" home \"  )  ;", "this . template . setReceiveMessage ( responseMessage )  ;", "Message <  ?  >    actual    =    this . template . sendAndReceive ( requestMessage )  ;", "assertEquals (  \" home \"  ,    this . template . destination )  ;", "assertSame ( requestMessage ,    this . template . requestMessage )  ;", "assertSame ( responseMessage ,    actual )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceive"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . sendAndReceive ( new   GenericMessage < Object >  (  \" request \"  )  )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceiveMissingDestination"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    requestMessage    =    new   GenericMessage < Object >  (  \" request \"  )  ;", "Message <  ?  >    responseMessage    =    new   GenericMessage < Object >  (  \" response \"  )  ;", "this . template . setReceiveMessage ( responseMessage )  ;", "Message <  ?  >    actual    =    this . template . sendAndReceive (  \" somewhere \"  ,    requestMessage )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertSame ( requestMessage ,    this . template . requestMessage )  ;", "assertSame ( responseMessage ,    actual )  ;", "}", "METHOD_END"], "methodName": ["sendAndReceiveToDestination"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template    =    new   MessageRequestReplyTemplateTests . TestMessagingTemplate (  )  ;", "this . postProcessor    =    new   TestMessagePostProcessor (  )  ;", "this . headers    =    Collections .  < String ,    Object > singletonMap (  \" key \"  ,     \" value \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.core.MessageRequestReplyTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . convertAndSend (  \" somewhere \"  ,     \" payload \"  ,    headers ,    this . postProcessor )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertNotNull ( this . template . message )  ;", "assertEquals (  \" value \"  ,    this . template . message . getHeaders (  )  . get (  \" key \"  )  )  ;", "assertEquals (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "assertNotNull ( this . postProcessor . getMessage (  )  )  ;", "assertSame ( this . template . message ,    this . postProcessor . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSend"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "MessageConverter   converter    =    new   CompositeMessageConverter ( Arrays .  < MessageConverter > asList ( new   MappingJackson 2 MessageConverter (  )  )  )  ;", "this . template . setMessageConverter ( converter )  ;", "this . headers . put ( MessageHeaders . CONTENT _ TYPE ,    APPLICATION _ XML )  ;", "this . template . convertAndSend (  \" home \"  ,     \" payload \"  ,    new   MessageHeaders ( this . headers )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendNoMatchingConverter"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . setDefaultDestination (  \" home \"  )  ;", "this . template . convertAndSend (  \" payload \"  )  ;", "assertEquals (  \" home \"  ,    this . template . destination )  ;", "assertNotNull ( this . template . message )  ;", "assertEquals (  \" expected    ' id '    and    ' timestamp '    headers   only \"  ,     2  ,    this . template . message . getHeaders (  )  . size (  )  )  ;", "assertEquals (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayload"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . convertAndSend (  \" somewhere \"  ,     \" payload \"  ,    headers )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertNotNull ( this . template . message )  ;", "assertEquals (  \" value \"  ,    this . template . message . getHeaders (  )  . get (  \" key \"  )  )  ;", "assertEquals (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadAndHeadersToDestination"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   messageHeaders    =    accessor . getMessageHeaders (  )  ;", "this . template . setMessageConverter ( new   StringMessageConverter (  )  )  ;", "this . template . convertAndSend (  \" somewhere \"  ,     \" payload \"  ,    messageHeaders )  ;", "MessageHeaders   actual    =    this . template . message . getHeaders (  )  ;", "assertSame ( messageHeaders ,    actual )  ;", "assertEquals ( new   MimeType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . UTF _  8  )  ,    actual . get ( MessageHeaders . CONTENT _ TYPE )  )  ;", "assertEquals (  \" bar \"  ,    actual . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadAndMutableHeadersToDestination"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . convertAndSend (  \" somewhere \"  ,     \" payload \"  )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertNotNull ( this . template . message )  ;", "assertEquals (  \" expected    ' id '    and    ' timestamp '    headers   only \"  ,     2  ,    this . template . message . getHeaders (  )  . size (  )  )  ;", "assertEquals (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadToDestination"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . setDefaultDestination (  \" home \"  )  ;", "this . template . convertAndSend (  (  ( Object )     (  \" payload \"  )  )  ,    this . postProcessor )  ;", "assertEquals (  \" home \"  ,    this . template . destination )  ;", "assertNotNull ( this . template . message )  ;", "assertEquals (  \" expected    ' id '    and    ' timestamp '    headers   only \"  ,     2  ,    this . template . message . getHeaders (  )  . size (  )  )  ;", "assertEquals (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "assertNotNull ( this . postProcessor . getMessage (  )  )  ;", "assertSame ( this . template . message ,    this . postProcessor . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadWithPostProcessor"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template . convertAndSend (  \" somewhere \"  ,     \" payload \"  ,    this . postProcessor )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertNotNull ( this . template . message )  ;", "assertEquals (  \" expected    ' id '    and    ' timestamp '    headers   only \"  ,     2  ,    this . template . message . getHeaders (  )  . size (  )  )  ;", "assertEquals (  \" payload \"  ,    this . template . message . getPayload (  )  )  ;", "assertNotNull ( this . postProcessor . getMessage (  )  )  ;", "assertSame ( this . template . message ,    this . postProcessor . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendPayloadWithPostProcessorToDestination"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    new   GenericMessage < Object >  (  \" payload \"  )  ;", "this . template . setDefaultDestination (  \" home \"  )  ;", "this . template . send ( message )  ;", "assertEquals (  \" home \"  ,    this . template . destination )  ;", "assertSame ( message ,    this . template . message )  ;", "}", "METHOD_END"], "methodName": ["send"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    new   GenericMessage < Object >  (  \" payload \"  )  ;", "this . template . send ( message )  ;", "}", "METHOD_END"], "methodName": ["sendMissingDestination"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    new   GenericMessage < Object >  (  \" payload \"  )  ;", "this . template . send (  \" somewhere \"  ,    message )  ;", "assertEquals (  \" somewhere \"  ,    this . template . destination )  ;", "assertSame ( message ,    this . template . message )  ;", "}", "METHOD_END"], "methodName": ["sendToDestination"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . template    =    new   MessageSendingTemplateTests . TestMessageSendingTemplate (  )  ;", "this . postProcessor    =    new   TestMessagePostProcessor (  )  ;", "this . headers    =    new   HashMap <  >  (  )  ;", "this . headers . put (  \" key \"  ,     \" value \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.core.MessageSendingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . channels . put ( name ,    channel )  ;", "}", "METHOD_END"], "methodName": ["registerMessageChannel"], "fileName": "org.springframework.messaging.core.TestMessageChannelDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . message ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.messaging.core.TestMessagePostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   this . patterns ;", "}", "METHOD_END"], "methodName": ["getPatterns"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageCondition"}, {"methodBody": ["METHOD_START", "{", "boolean   slashSeparator    =    pathMatcher . combine (  \" a \"  ,     \" a \"  )  . equals (  \" a / a \"  )  ;", "Set < String >    result    =    new   LinkedHashSet <  >  ( p . size (  )  )  ;", "for    ( String   pattern    :    p )     {", "if    (  ( slashSeparator    &  &     ( StringUtils . hasLength ( pattern )  )  )     &  &     (  !  ( pattern . startsWith (  \"  /  \"  )  )  )  )     {", "pattern    =     \"  /  \"     +    pattern ;", "}", "result . add ( pattern )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["prependLeadingSlash"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageCondition"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   c 1     =    condition (  )  ;", "DestinationPatternsMessageCondition   c 2     =    condition (  )  ;", "assertEquals ( condition (  \"  \"  )  ,    c 1  . combine ( c 2  )  )  ;", "}", "METHOD_END"], "methodName": ["combineEmptySets"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   c 1     =    condition (  \"  / t 1  \"  ,     \"  / t 2  \"  )  ;", "DestinationPatternsMessageCondition   c 2     =    condition (  \"  / m 1  \"  ,     \"  / m 2  \"  )  ;", "assertEquals ( new   DestinationPatternsMessageCondition (  \"  / t 1  / m 1  \"  ,     \"  / t 1  / m 2  \"  ,     \"  / t 2  / m 1  \"  ,     \"  / t 2  / m 2  \"  )  ,    c 1  . combine ( c 2  )  )  ;", "}", "METHOD_END"], "methodName": ["combineMultiplePatterns"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   c 1     =    condition (  \"  / type 1  \"  ,     \"  / type 2  \"  )  ;", "DestinationPatternsMessageCondition   c 2     =    condition (  )  ;", "assertEquals ( condition (  \"  / type 1  \"  ,     \"  / type 2  \"  )  ,    c 1  . combine ( c 2  )  )  ;", "c 1     =    condition (  )  ;", "c 2     =    condition (  \"  / method 1  \"  ,     \"  / method 2  \"  )  ;", "assertEquals ( condition (  \"  / method 1  \"  ,     \"  / method 2  \"  )  ,    c 1  . combine ( c 2  )  )  ;", "}", "METHOD_END"], "methodName": ["combineOnePatternWithEmptySet"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   c 1     =    condition (  \"  / foo *  \"  )  ;", "DestinationPatternsMessageCondition   c 2     =    condition (  \"  / foo *  \"  )  ;", "assertEquals (  0  ,    c 1  . compareTo ( c 2  ,    messageTo (  \"  / foo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compareEqualPatterns"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    messageTo (  \"  / foo \"  )  ;", "c 1     =    condition (  \"  / foo \"  ,     \" bar \"  )  ;", "c 2     =    condition (  \"  / foo \"  ,     \" f *  \"  )  ;", "match 1     =    c 1  . getMatchingCondition ( message )  ;", "match 2     =    c 2  . getMatchingCondition ( message )  ;", "assertEquals (  1  ,    match 1  . compareTo ( match 2  ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["compareNumberOfMatchingPatterns"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   c 1     =    condition (  \"  / fo *  \"  )  ;", "DestinationPatternsMessageCondition   c 2     =    condition (  \"  / foo \"  )  ;", "assertEquals (  1  ,    c 1  . compareTo ( c 2  ,    messageTo (  \"  / foo \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["comparePatternSpecificity"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   DestinationPatternsMessageCondition ( patterns )  ;", "}", "METHOD_END"], "methodName": ["condition"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   condition    =    condition (  \"  / foo \"  )  ;", "DestinationPatternsMessageCondition   match    =    condition . getMatchingCondition ( messageTo (  \"  / foo \"  )  )  ;", "assertNotNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchDirectPath"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   condition    =    condition (  \"  / foo /  *  \"  )  ;", "DestinationPatternsMessageCondition   match    =    condition . getMatchingCondition ( messageTo (  \"  / foo / bar \"  )  )  ;", "assertNotNull ( match )  ;", "}", "METHOD_END"], "methodName": ["matchPattern"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   condition    =    condition (  \"  /  *  *  \"  ,     \"  / foo / bar \"  ,     \"  / foo /  *  \"  )  ;", "DestinationPatternsMessageCondition   match    =    condition . getMatchingCondition ( messageTo (  \"  / foo / bar \"  )  )  ;", "DestinationPatternsMessageCondition   expected    =    condition (  \"  / foo / bar \"  ,     \"  / foo /  *  \"  ,     \"  /  *  *  \"  )  ;", "assertEquals ( expected ,    match )  ;", "}", "METHOD_END"], "methodName": ["matchSortPatterns"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeader ( DestinationPatternsMessageCondition . LOOKUP _ DESTINATION _ HEADER ,    destination )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["messageTo"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   c    =    condition (  \"  \"  )  ;", "assertEquals (  \"  \"  ,    c . getPatterns (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["prependNonEmptyPatternsOnly"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   c    =    condition (  \" foo \"  )  ;", "assertEquals (  \"  / foo \"  ,    c . getPatterns (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["prependSlash"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "DestinationPatternsMessageCondition   c    =    new   DestinationPatternsMessageCondition ( new   String [  ]  {     \" foo \"     }  ,    new   AntPathMatcher (  \"  .  \"  )  )  ;", "assertEquals (  \" Pre - pending   should   be   disabled   when   not   using    '  /  '    as   path   separator \"  ,     \" foo \"  ,    c . getPatterns (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["prependSlashWithCustomPathSeparator"], "fileName": "org.springframework.messaging.handler.DestinationPatternsMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "Object   handler    =    this . bean ;", "if    (  ( this . bean )    instanceof   String )     {", "Assert . state (  (  ( this . beanFactory )     !  =    null )  ,     \" Cannot   resolve   bean   name   without   BeanFactory \"  )  ;", "String   beanName    =     (  ( String )     ( this . bean )  )  ;", "handler    =    this . beanFactory . getBean ( beanName )  ;", "}", "return   new    ( this ,    handler )  ;", "}", "METHOD_END"], "methodName": ["createWithResolvedBean"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . bean ;", "}", "METHOD_END"], "methodName": ["getBean"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . beanType ;", "}", "METHOD_END"], "methodName": ["getBeanType"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . bridgedMethod ;", "}", "METHOD_END"], "methodName": ["getBridgedMethod"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . findMergedAnnotation ( this . method ,    annotationType )  ;", "}", "METHOD_END"], "methodName": ["getMethodAnnotation"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . parameters ;", "}", "METHOD_END"], "methodName": ["getMethodParameters"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . resolvedFromHandlerMethod ;", "}", "METHOD_END"], "methodName": ["getResolvedFromHandlerMethod"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   HandlerMethod . HandlerMethodParameter (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   HandlerMethod . ReturnValueMethodParameter ( returnValue )  ;", "}", "METHOD_END"], "methodName": ["getReturnValueType"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "int   args    =    this . method . getParameterCount (  )  ;", "return    (  (  (  (  ( getBeanType (  )  . getName (  )  )     +     \"  #  \"  )     +     ( this . method . getName (  )  )  )     +     \"  [  \"  )     +    args )     +     \"    args ]  \"  ;", "}", "METHOD_END"], "methodName": ["getShortLogMessage"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   AnnotatedElementUtils . hasAnnotation ( this . method ,    annotationType )  ;", "}", "METHOD_END"], "methodName": ["hasMethodAnnotation"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "int   count    =    this . bridgedMethod . getParameterCount (  )  ;", "MethodParameter [  ]    result    =    new   MethodParameter [ count ]  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "Parameter   parameter    =    newParameter ( i )  ;", "GenericTypeResolver . resolveParameterType ( parameter ,    this . beanType )  ;", "result [ i ]     =    parameter ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["initMethodParameters"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   Void . TYPE . equals ( getReturnType (  )  . getParameterType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isVoid"], "fileName": "org.springframework.messaging.handler.HandlerMethod"}, {"methodBody": ["METHOD_START", "{", "AbstractNamedValueMethodArgumentResolver . NamedValueInfo   namedValueInfo    =    this . namedValueInfoCache . get ( parameter )  ;", "if    ( namedValueInfo    =  =    null )     {", "namedValueInfo    =    createNamedValueInfo ( parameter )  ;", "namedValueInfo    =    updateNamedValueInfo ( parameter ,    namedValueInfo )  ;", "this . namedValueInfoCache . put ( parameter ,    namedValueInfo )  ;", "}", "return   namedValueInfo ;", "}", "METHOD_END"], "methodName": ["getNamedValueInfo"], "fileName": "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "if    ( Boolean . TYPE . equals ( paramType )  )     {", "return   Boolean . FALSE ;", "} else", "if    ( paramType . isPrimitive (  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Optional    \"     +    paramType )     +     \"    parameter    '  \"  )     +    name )     +     \"  '    is   present   but   c   be   translated   into   a   null   value   due   to   being    \"  )     +     \" declared   as   a   primitive   type .    Consider   declaring   it   as   object   wrapper    \"  )     +     \" for   the   corresponding   primitive   type .  \"  )  )  ;", "}", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["handleNullValue"], "fileName": "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . configurableBeanFactory )     =  =    null )     {", "return   value ;", "}", "String   placeholdersResolved    =    this . configurableBeanFactory . resolveEmbeddedValue ( value )  ;", "BeanExpression   expr    =    this . configurableBeanFactory . getBeanExpression (  )  ;", "if    ( expr    =  =    null )     {", "return   value ;", "}", "return   expr . evaluate ( placeholdersResolved ,    this . expressionContext )  ;", "}", "METHOD_END"], "methodName": ["resolveStringValue"], "fileName": "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "String   name    =    info . name ;", "if    ( info . name . isEmpty (  )  )     {", "name    =    parameter . getParameterName (  )  ;", "if    ( name    =  =    null )     {", "throw   new   IllegalArgumentException (  (  (  \" Name   for   argument   type    [  \"     +     ( parameter . getParameterType (  )  . getName (  )  )  )     +     \"  ]    not   available ,    and   parameter   name   information   not   found   in   class   file   either .  \"  )  )  ;", "}", "}", "String   defaultValue    =     ( ValueConstants . DEFAULT _ NONE . equals ( info . defaultValue )  )     ?    null    :    info . defaultValue ;", "return   new    . NamedValueInfo ( name ,    info . required ,    defaultValue )  ;", "}", "METHOD_END"], "methodName": ["updateNamedValueInfo"], "fileName": "org.springframework.messaging.handler.annotation.support.AbstractNamedValueMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Map < Method ,    MessageExceptionHandler >    methods    =    MethodIntrospector . selectMethods ( handlerType ,     (  ( MethodIntrospector . MetadataLookup < MessageExceptionHandler >  )     (  (    method )     -  >    AnnotationUtils . findAnnotation ( method ,     . class )  )  )  )  ;", "Map < Class <  ?    extends   Throwable >  ,    Method >    result    =    new   HashMap <  >  (  )  ;", "for    ( Map . Entry < Method ,    MessageExceptionHandler >    entry    :    methods . entrySet (  )  )     {", "Method   method    =    entry . getKey (  )  ;", "List < Class <  ?    extends   Throwable >  >    exceptionTypes    =    new   ArrayList <  >  (  )  ;", "exceptionTypes . addAll ( Arrays . asList ( entry . getValue (  )  . value (  )  )  )  ;", "if    ( exceptionTypes . isEmpty (  )  )     {", "exceptionTypes . addAll ( Abstract . getExceptionsFromMethodSignature ( method )  )  ;", "}", "for    ( Class <  ?    extends   Throwable >    exceptionType    :    exceptionTypes )     {", "Method   oldMethod    =    result . put ( exceptionType ,    method )  ;", "if    (  ( oldMethod    !  =    null )     &  &     (  !  ( oldMethod . equals ( method )  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Ambiguous    @ ExceptionHandler   method   mapped   for    [  \"     +    exceptionType )     +     \"  ]  :     {  \"  )     +    oldMethod )     +     \"  ,     \"  )     +    method )     +     \"  }  \"  )  )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["initExceptionMappings"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "new   AnnotationExceptionHandlerMethodResolver ( AnnotationExceptionHandlerMethodResolverTests . AmbiguousController . class )  ;", "}", "METHOD_END"], "methodName": ["ambiguousExceptionMapping"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   AnnotationExceptionHandlerMethodResolver ( AnnotationExceptionHandlerMethodResolverTests . NoExceptionController . class )  ;", "}", "METHOD_END"], "methodName": ["noExceptionMapping"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "SocketException   exception    =    new   SocketException (  )  ;", "assertEquals (  \" handleSocketException \"  ,    this . resolver . resolveMethod ( exception )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodBestMatch"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "IOException   ioException    =    new   FileNotFoundException (  )  ;", "assertEquals (  \" handleIOException \"  ,    this . resolver . resolveMethod ( ioException )  . getName (  )  )  ;", "SocketException   bindException    =    new   BindException (  )  ;", "assertEquals (  \" handleSocketException \"  ,    this . resolver . resolveMethod ( bindException )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodExceptionSubType"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "IOException   exception    =    new   IOException (  )  ;", "assertEquals (  \" handleIOException \"  ,    this . resolver . resolveMethod ( exception )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodFromAnnotation"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "IllegalArgumentException   exception    =    new   IllegalArgumentException (  )  ;", "assertEquals (  \" handleIllegalArgumentException \"  ,    this . resolver . resolveMethod ( exception )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodFromArgument"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "AssertionError   exception    =    new   AssertionError (  )  ;", "assertEquals (  \" handleAssertionError \"  ,    this . resolver . resolveMethod ( new   IllegalState ( exception )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodFromArgumentWithErrorType"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "IOException   exception    =    new   IOException (  )  ;", "assertEquals (  \" handleIOException \"  ,    this . resolver . resolveMethod ( exception )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodInherited"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "Exception   exception    =    new   Exception (  )  ;", "assertNull (  \"  1 st   lookup \"  ,    this . resolver . resolveMethod ( exception )  )  ;", "assertNull (  \"  2 nd   lookup   from   cache \"  ,    this . resolver . resolveMethod ( exception )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMethodNoMatch"], "fileName": "org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < HandlerMethodArgumentResolver >    resolvers    =    new   ArrayList <  >  (  )  ;", "ConfigurableBeanFactory   cbf    =     (  ( this . beanFactory )    instanceof   ConfigurableBeanFactory )     ?     (  ( ConfigurableBeanFactory )     ( this . beanFactory )  )     :    null ;", "resolvers . add ( new   HeaderMethodArgumentResolver ( this . conversionService ,    cbf )  )  ;", "resolvers . add ( new   HeadersMethodArgumentResolver (  )  )  ;", "resolvers . add ( new   MessageMethodArgumentResolver ( this . messageConverter )  )  ;", "if    (  ( this . customArgumentResolvers )     !  =    null )     {", "resolvers . addAll ( this . customArgumentResolvers )  ;", "}", "resolvers . add ( new   PayloadArgumentResolver ( this . messageConverter ,    this . validator )  )  ;", "return   resolvers ;", "}", "METHOD_END"], "methodName": ["initArgumentResolvers"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( argumentResolvers    =  =    null )     {", "this . argumentResolvers . clear (  )  ;", "return ;", "}", "this . argumentResolvers . addResolvers ( argumentResolvers )  ;", "}", "METHOD_END"], "methodName": ["setArgumentResolvers"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory"}, {"methodBody": ["METHOD_START", "{", "this . conversionService    =    conversionService ;", "}", "METHOD_END"], "methodName": ["setConversionService"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory"}, {"methodBody": ["METHOD_START", "{", "this . customArgumentResolvers    =    customArgumentResolvers ;", "}", "METHOD_END"], "methodName": ["setCustomArgumentResolvers"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory"}, {"methodBody": ["METHOD_START", "{", "this . messageConverter    =    messageConverter ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory"}, {"methodBody": ["METHOD_START", "{", "this . validator    =    validator ;", "}", "METHOD_END"], "methodName": ["setValidator"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  (  \" Method    \"     +    methodName )     +     \"    should   have   been   invoked \"  )  ,    bean . invocations . get ( methodName )  )  ;", "}", "METHOD_END"], "methodName": ["assertMethodInvocation"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageHandlerMethodFactory   factory    =    new   DefaultMessageHandlerMethodFactory (  )  ;", "factory . setBeanFactory ( new   StaticListableBeanFactory (  )  )  ;", "return   factory ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   factory . createInvocableHandlerMethod ( sample ,    getListenerMethod ( methodName ,    parameterTypes )  )  ;", "}", "METHOD_END"], "methodName": ["createInvocableHandlerMethod"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageHandlerMethodFactory   instance    =    createInstance (  )  ;", "List < HandlerMethodArgumentResolver >    customResolvers    =    new   ArrayList <  >  (  )  ;", "customResolvers . add ( new    . CustomHandlerMethodArgumentResolver (  )  )  ;", "instance . setCustomArgumentResolvers ( customResolvers )  ;", "instance . afterPropertiesSet (  )  ;", "InvocableHandlerMethod   invocableHandlerMethod    =    createInvocableHandlerMethod ( instance ,     \" customArgumentResolver \"  ,    Locale . class )  ;", "invocableHandlerMethod . invoke ( MessageBuilder . withPayload (  1  2  3  )  . build (  )  )  ;", "assertMethodInvocation ( sample ,     \" customArgumentResolver \"  )  ;", "}", "METHOD_END"], "methodName": ["customArgumentResolver"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageHandlerMethodFactory   instance    =    createInstance (  )  ;", "GenericConversionService   conversionService    =    new   GenericConversionService (  )  ;", "conversionService . addConverter (  . SampleBean . class ,    String . class ,    new   Converter <  . SampleBean ,    String >  (  )     {", "@ Override", "public   String   convert (  . SampleBean   source )     {", "return    \" foo   bar \"  ;", "}", "}  )  ;", "instance . setConversionService ( conversionService )  ;", "instance . afterPropertiesSet (  )  ;", "InvocableHandlerMethod   invocableHandlerMethod    =    createInvocableHandlerMethod ( instance ,     \" simpleString \"  ,    String . class )  ;", "invocableHandlerMethod . invoke ( MessageBuilder . withPayload ( sample )  . build (  )  )  ;", "assertMethodInvocation ( sample ,     \" simpleString \"  )  ;", "}", "METHOD_END"], "methodName": ["customConversion"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageHandlerMethodFactory   instance    =    createInstance (  )  ;", "GenericConversionService   conversionService    =    new   GenericConversionService (  )  ;", "assertFalse (  \" conversion   service   should   fail   to   convert   payload \"  ,    conversionService . canConvert ( Integer . class ,    String . class )  )  ;", "instance . setConversionService ( conversionService )  ;", "instance . afterPropertiesSet (  )  ;", "InvocableHandlerMethod   invocableHandlerMethod    =    createInvocableHandlerMethod ( instance ,     \" simpleString \"  ,    String . class )  ;", "thrown . expect ( MessageConversionException . class )  ;", "invocableHandlerMethod . invoke ( MessageBuilder . withPayload (  1  2  3  )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["customConversionServiceFailure"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageHandlerMethodFactory   instance    =    createInstance (  )  ;", "MessageConverter   messageConverter    =    new   ByteArrayMessageConverter (  )  ;", "instance . setMessageConverter ( messageConverter )  ;", "instance . afterPropertiesSet (  )  ;", "InvocableHandlerMethod   invocableHandlerMethod    =    createInvocableHandlerMethod ( instance ,     \" simpleString \"  ,    String . class )  ;", "thrown . expect ( MessageConversionException . class )  ;", "invocableHandlerMethod . invoke ( MessageBuilder . withPayload (  1  2  3  )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["customMessageConverterFailure"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageHandlerMethodFactory   instance    =    createInstance (  )  ;", "instance . setValidator ( new   Validator (  )     {", "@ Override", "public   boolean   supports ( Class <  ?  >    clazz )     {", "return   String . class . isAssignableFrom ( clazz )  ;", "}", "@ Override", "public   void   validate ( Object   target ,    Errors   errors )     {", "String   value    =     (  ( String )     ( target )  )  ;", "if    (  \" failure \"  . equals ( value )  )     {", "errors . reject (  \" not   a   valid   value \"  )  ;", "}", "}", "}  )  ;", "instance . afterPropertiesSet (  )  ;", "InvocableHandlerMethod   invocableHandlerMethod    =    createInvocableHandlerMethod ( instance ,     \" payloadValidation \"  ,    String . class )  ;", "thrown . expect ( MethodArgumentNotValidException . class )  ;", "invocableHandlerMethod . invoke ( MessageBuilder . withPayload (  \" failure \"  )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["customValidation"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    ReflectionUtils . findMethod ( DefaultMessageHandlerMethodFactoryTests . SampleBean . class ,    methodName ,    parameterTypes )  ;", "assertNotNull (  (  (  (  \" no   method   found   with   name    \"     +    methodName )     +     \"    and   parameters    \"  )     +     ( Arrays . toString ( parameterTypes )  )  )  )  ;", "return   method ;", "}", "METHOD_END"], "methodName": ["getListenerMethod"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageHandlerMethodFactory   instance    =    createInstance (  )  ;", "instance . afterPropertiesSet (  )  ;", "InvocableHandlerMethod   invocableHandlerMethod    =    createInvocableHandlerMethod ( instance ,     \" payloadValidation \"  ,    String . class )  ;", "invocableHandlerMethod . invoke ( MessageBuilder . withPayload (  \" failure \"  )  . build (  )  )  ;", "assertMethodInvocation ( sample ,     \" payloadValidation \"  )  ;", "}", "METHOD_END"], "methodName": ["noValidationByDefault"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultMessageHandlerMethodFactory   instance    =    createInstance (  )  ;", "List < HandlerMethodArgumentResolver >    customResolvers    =    new   ArrayList <  >  (  )  ;", "customResolvers . add ( new    . CustomHandlerMethodArgumentResolver (  )  )  ;", "instance . setArgumentResolvers ( customResolvers )  ;", "instance . afterPropertiesSet (  )  ;", "Message < String >    message    =    MessageBuilder . withPayload (  \" sample \"  )  . build (  )  ;", "InvocableHandlerMethod   invocableHandlerMethod    =    createInvocableHandlerMethod ( instance ,     \" customArgumentResolver \"  ,    Locale . class )  ;", "invocableHandlerMethod . invoke ( message )  ;", "assertMethodInvocation ( sample ,     \" customArgumentResolver \"  )  ;", "InvocableHandlerMethod   invocableHandlerMethod 2     =    createInvocableHandlerMethod ( instance ,     \" simpleString \"  ,    String . class )  ;", "thrown . expect ( MethodArgumentResolutionException . class )  ;", "thrown . expectMessage (  \" No   suitable   resolver   for \"  )  ;", "invocableHandlerMethod 2  . invoke ( message )  ;", "}", "METHOD_END"], "methodName": ["overrideArgumentResolvers"], "fileName": "org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    vars    =    new   HashMap <  >  (  )  ;", "vars . put (  \" foo \"  ,     \" bar \"  )  ;", "vars . put (  \" name \"  ,     \" value \"  )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeader (  . DESTINATION _ TEMPLATE _ VARIABLES _ HEADER ,    vars )  . build (  )  ;", "Object   result    =    this . resolver . resolveArgument ( this . paramAnnotated ,    message )  ;", "assertEquals (  \" bar \"  ,    result )  ;", "result    =    this . resolver . resolveArgument ( this . paramAnnotatedValue ,    message )  ;", "assertEquals (  \" value \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.messaging.handler.annotation.support.DestinationVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . build (  )  ;", "this . resolver . resolve ( this . paramAnnotated ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentNotFound"], "fileName": "org.springframework.messaging.handler.annotation.support.DestinationVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver    =    new   DestinationVariableMethodArgumentResolver ( new   DefaultConversionService (  )  )  ;", "Method   method    =    getClass (  )  . getDeclaredMethod (  \" handleMessage \"  ,    String . class ,    String . class ,    String . class )  ;", "this . paramAnnotated    =    new   MethodParameter ( method ,     0  )  ;", "this . paramAnnotatedValue    =    new   MethodParameter ( method ,     1  )  ;", "this . paramNotAnnotated    =    new   MethodParameter ( method ,     2  )  ;", "this . paramAnnotated . initParameterNameDiscovery ( new   DefaultParameterNameDiscoverer (  )  )  ;", "GenericTypeResolver . resolveParameterType ( this . paramAnnotated ,    DestinationVariableMethodArgumentResolver . class )  ;", "this . paramAnnotatedValue . initParameterNameDiscovery ( new   DefaultParameterNameDiscoverer (  )  )  ;", "GenericTypeResolver . resolveParameterType ( this . paramAnnotatedValue ,    DestinationVariableMethodArgumentResolver . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.handler.annotation.support.DestinationVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( resolver . supportsParameter ( paramAnnotated )  )  ;", "assertTrue ( resolver . supportsParameter ( paramAnnotatedValue )  )  ;", "assertFalse ( resolver . supportsParameter ( paramNotAnnotated )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.messaging.handler.annotation.support.DestinationVariableMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    nativeHeaders    =    getNativeHeaders ( message )  ;", "if    ( name . startsWith (  \" nativeHeaders .  \"  )  )     {", "name    =    name . substring (  \" nativeHeaders .  \"  . length (  )  )  ;", "}", "if    (  ( nativeHeaders    =  =    null )     |  |     (  !  ( nativeHeaders . containsKey ( name )  )  )  )     {", "return   null ;", "}", "List <  ?  >    nativeHeaderValues    =    nativeHeaders . get ( name )  ;", "return    ( nativeHeaderValues . size (  )  )     =  =     1     ?    nativeHeaderValues . get (  0  )     :    nativeHeaderValues ;", "}", "METHOD_END"], "methodName": ["getNativeHeaderValue"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Map < String ,    List < String >  >  )     ( message . getHeaders (  )  . get ( NativeMessageHeaderAccessor . NATIVE _ HEADERS )  )  )  ;", "}", "METHOD_END"], "methodName": ["getNativeHeaders"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeader (  \" param 1  \"  ,     \" foo \"  )  . build (  )  ;", "Object   result    =    this . resolver . resolve ( this . paramRequired ,    message )  ;", "assertEquals (  \" foo \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveArgument"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . build (  )  ;", "Object   result    =    this . resolver . resolve ( this . paramNamedDefaultValueStringHeader ,    message )  ;", "assertEquals (  \" bar \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentDefaultValue"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "HeaderMethodArgumentResolverTests . TestMessageHeaderAccessor   headers    =    new   HeaderMethodArgumentResolverTests . TestMessageHeaderAccessor (  )  ;", "headers . setNativeHeader (  \" param 1  \"  ,     \" foo \"  )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeaders ( headers )  . build (  )  ;", "assertEquals (  \" foo \"  ,    this . resolver . resolveArgument ( this . paramRequired ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentNativeHeader"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "HeaderMethodArgumentResolverTests . TestMessageHeaderAccessor   headers    =    new   HeaderMethodArgumentResolverTests . TestMessageHeaderAccessor (  )  ;", "headers . setHeader (  \" param 1  \"  ,     \" foo \"  )  ;", "headers . setNativeHeader (  \" param 1  \"  ,     \" native - foo \"  )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeaders ( headers )  . build (  )  ;", "assertEquals (  \" foo \"  ,    this . resolver . resolveArgument ( this . paramRequired ,    message )  )  ;", "assertEquals (  \" native - foo \"  ,    this . resolver . resolveArgument ( this . paramNativeHeader ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentNativeHeaderAmbiguity"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . build (  )  ;", "this . resolver . resolve ( this . paramRequired ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentNotFound"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" systemProperty \"  ,     \" sysbar \"  )  ;", "try    {", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . build (  )  ;", "Object   result    =    resolver . resolve ( paramSystemPropertyDefaultValue ,    message )  ;", "assertEquals (  \" sysbar \"  ,    result )  ;", "}    finally    {", "System . clearProperty (  \" systemProperty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveDefaultValueSystemProperty"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" systemProperty \"  ,     \" sysbar \"  )  ;", "try    {", "Message < byte [  ]  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeader (  \" sysbar \"  ,     \" foo \"  )  . build (  )  ;", "Object   result    =    resolver . resolve ( paramSystemPropertyName ,    message )  ;", "assertEquals (  \" foo \"  ,    result )  ;", "}    finally    {", "System . clearProperty (  \" systemProperty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveNameFromSystemProperty"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   cxt    =    new   GenericApplicationContext (  )  ;", "cxt . refresh (  )  ;", "resolver    =    new    ( new   DefaultConversionService (  )  ,    cxt . getBeanFactory (  )  )  ;", "Message < String >    message    =    MessageBuilder . withPayload (  \" foo \"  )  . build (  )  ;", "Object   result    =    resolver . resolveArgument ( paramOptional ,    message )  ;", "assertEquals ( Optional . empty (  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveOptionalHeaderAsEmpty"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "GenericApplicationContext   cxt    =    new   GenericApplicationContext (  )  ;", "cxt . refresh (  )  ;", "resolver    =    new    ( new   DefaultConversionService (  )  ,    cxt . getBeanFactory (  )  )  ;", "Message < String >    message    =    MessageBuilder . withPayload (  \" foo \"  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Object   result    =    resolver . resolveArgument ( paramOptional ,    message )  ;", "assertEquals ( Optional . of (  \" bar \"  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["resolveOptionalHeaderWithValue"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" resource \"  )", "GenericApplicationContext   cxt    =    new   GenericApplicationContext (  )  ;", "cxt . refresh (  )  ;", "this . resolver    =    new    ( new   DefaultConversionService (  )  ,    cxt . getBeanFactory (  )  )  ;", "Method   method    =    ReflectionUtils . findMethod ( getClass (  )  ,     \" handleMessage \"  ,     (  ( Class <  ?  >  [  ]  )     ( null )  )  )  ;", "this . paramRequired    =    new   SynthesizingMethodParameter ( method ,     0  )  ;", "this . paramNamedDefaultValueStringHeader    =    new   SynthesizingMethodParameter ( method ,     1  )  ;", "this . paramSystemPropertyDefaultValue    =    new   SynthesizingMethodParameter ( method ,     2  )  ;", "this . paramSystemPropertyName    =    new   SynthesizingMethodParameter ( method ,     3  )  ;", "this . paramNotAnnotated    =    new   SynthesizingMethodParameter ( method ,     4  )  ;", "this . paramOptional    =    new   SynthesizingMethodParameter ( method ,     5  )  ;", "this . paramNativeHeader    =    new   SynthesizingMethodParameter ( method ,     6  )  ;", "this . paramRequired . initParameterNameDiscovery ( new   DefaultParameterNameDiscoverer (  )  )  ;", "GenericTypeResolver . resolveParameterType ( this . paramRequired ,     . class )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( resolver . supportsParameter ( paramNamedDefaultValueStringHeader )  )  ;", "assertFalse ( resolver . supportsParameter ( paramNotAnnotated )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.messaging.handler.annotation.support.HeaderMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Object   resolved    =    this . resolver . resolveArgument ( this . paramAnnotated ,    this . message )  ;", "assertTrue (  ( resolved   instanceof   Map )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    Object >    headers    =     (  ( Map < String ,    Object >  )     ( resolved )  )  ;", "assertEquals (  \" bar \"  ,    headers . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentAnnotated"], "fileName": "org.springframework.messaging.handler.annotation.support.HeadersMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . resolveArgument ( this . paramAnnotatedNotMap ,    this . message )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentAnnotatedNotMap"], "fileName": "org.springframework.messaging.handler.annotation.support.HeadersMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Object   resolved    =    this . resolver . resolveArgument ( this . paramMessageHeaderAccessor ,    this . message )  ;", "assertTrue (  ( resolved   instanceof   MessageHeaderAccessor )  )  ;", "MessageHeaderAccessor   headers    =     (  ( MessageHeaderAccessor )     ( resolved )  )  ;", "assertEquals (  \" bar \"  ,    headers . getHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentMessageHeaderAccessor"], "fileName": "org.springframework.messaging.handler.annotation.support.HeadersMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Object   resolved    =    this . resolver . resolveArgument ( this . paramMessageHeaderAccessorSubclass ,    this . message )  ;", "assertTrue (  ( resolved   instanceof    . TestMessageHeaderAccessor )  )  ;", ". TestMessageHeaderAccessor   headers    =     (  (  . TestMessageHeaderAccessor )     ( resolved )  )  ;", "assertEquals (  \" bar \"  ,    headers . getHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentMessageHeaderAccessorSubclass"], "fileName": "org.springframework.messaging.handler.annotation.support.HeadersMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Object   resolved    =    this . resolver . resolveArgument ( this . paramMessageHeaders ,    this . message )  ;", "assertTrue (  ( resolved   instanceof   MessageHeaders )  )  ;", "MessageHeaders   headers    =     (  ( MessageHeaders )     ( resolved )  )  ;", "assertEquals (  \" bar \"  ,    headers . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveArgumentMessageHeaders"], "fileName": "org.springframework.messaging.handler.annotation.support.HeadersMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver    =    new   HeadersMethodArgumentResolver (  )  ;", "Method   method    =    getClass (  )  . getDeclaredMethod (  \" handleMessage \"  ,    Map . class ,    String . class ,    MessageHeaders . class ,    MessageHeaderAccessor . class ,     . TestMessageHeaderAccessor . class )  ;", "this . paramAnnotated    =    new   MethodParameter ( method ,     0  )  ;", "this . paramAnnotatedNotMap    =    new   MethodParameter ( method ,     1  )  ;", "this . paramMessageHeaders    =    new   MethodParameter ( method ,     2  )  ;", "this . paramMessageHeaderAccessor    =    new   MethodParameter ( method ,     3  )  ;", "this . paramMessageHeaderAccessorSubclass    =    new   MethodParameter ( method ,     4  )  ;", "Map < String ,    Object >    headers    =    new   HashMap <  >  (  )  ;", "headers . put (  \" foo \"  ,     \" bar \"  )  ;", "this . message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . copyHeaders ( headers )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.handler.annotation.support.HeadersMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . paramAnnotated )  )  ;", "assertFalse ( this . resolver . supportsParameter ( this . paramAnnotatedNotMap )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . paramMessageHeaders )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . paramMessageHeaderAccessor )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . paramMessageHeaderAccessorSubclass )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.messaging.handler.annotation.support.HeadersMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    null ;", "if    (  ( this . converter )    instanceof   SmartConverter )     {", "SmartConverter   smartConverter    =     (  ( SmartConverter )     ( this . converter )  )  ;", "result    =    smartConverter . from ( message ,    targetPayloadType ,    parameter )  ;", "} else", "if    (  ( this . converter )     !  =    null )     {", "result    =    this . converter . from ( message ,    targetPayloadType )  ;", "}", "if    ( result    =  =    null )     {", "throw   new   ConversionException ( message ,     (  (  (  (  \" No   converter   found   from   actual   payload   type    '  \"     +     ( ClassUtils . getDescriptiveType ( message . getPayload (  )  )  )  )     +     \"  '    to   expected   payload   type    '  \"  )     +     ( ClassUtils . getQualifiedName ( targetPayloadType )  )  )     +     \"  '  \"  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["convertPayload"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Type   genericParamType    =    parameter . getGenericParameterType (  )  ;", "ResolvableType   resolvableType    =    ResolvableType . forType ( genericParamType )  . as (  . class )  ;", "return   resolvableType . getGeneric (  0  )  . resolve ( Object . class )  ;", "}", "METHOD_END"], "methodName": ["getPayloadType"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( payload    =  =    null )     {", "return   true ;", "} else", "if    ( payload   instanceof   byte [  ]  )     {", "return    (  (  ( byte [  ]  )     ( payload )  )  . length )     =  =     0  ;", "} else", "if    ( payload   instanceof   String )     {", "return    !  ( util . StringUtils . hasText (  (  ( String )     ( payload )  )  )  )  ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isEmptyPayload"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "ErrorMessage   message    =    new   ErrorMessage ( new   UedOperationException (  )  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     4  )  ;", "assertTrue ( this . resolversParameter ( parameter )  )  ;", "assertSame ( message ,    this . resolver . resolveArgument ( parameter ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMessageSubclassMatch"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" test \"  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     1  )  ;", "when ( this . converter . fromMessage ( message ,    Integer . class )  )  . thenReturn (  4  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Message < Integer >    actual    =     (  ( Message < Integer >  )     ( this . resolver . resolve ( parameter ,    message )  )  )  ;", "assertNotNull ( actual )  ;", "assertSame ( message . getHeaders (  )  ,    actual . getHeaders (  )  )  ;", "assertEquals ( new   Integer (  4  )  ,    actual . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithConversion"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \"  \"  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     1  )  ;", "assertTrue ( this . resolversParameter ( parameter )  )  ;", "thrown . expect ( MessageConversionException . class )  ;", "thrown . expectMessage (  \" payload   is   empty \"  )  ;", "thrown . expectMessage ( Integer . class . getName (  )  )  ;", "thrown . expectMessage ( String . class . getName (  )  )  ;", "this . resolver . resolveArgument ( parameter ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveWithConversionEmptyPayload"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver    =    new   MessageMethodArgumentResolver (  )  ;", "Message < String >    message    =    MessageBuilder . withPayload (  \"  \"  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     1  )  ;", "assertTrue ( this . resolver . supportsParameter ( parameter )  )  ;", "thrown . expect ( MessageConversionException . class )  ;", "thrown . expectMessage (  \" payload   is   empty \"  )  ;", "thrown . expectMessage ( Integer . class . getName (  )  )  ;", "thrown . expectMessage ( String . class . getName (  )  )  ;", "this . resolver . resolveArgument ( parameter ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveWithConversionEmptyPayloadButNoConverter"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver    =    new   MessageMethodArgumentResolver (  )  ;", "Message < String >    message    =    MessageBuilder . withPayload (  \" test \"  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     1  )  ;", "assertTrue ( this . resolver . supportsParameter ( parameter )  )  ;", "thrown . expect ( MessageConversionException . class )  ;", "thrown . expectMessage ( Integer . class . getName (  )  )  ;", "thrown . expectMessage ( String . class . getName (  )  )  ;", "this . resolver . resolveArgument ( parameter ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveWithConversionNeededButNoConverter"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" test \"  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     1  )  ;", "assertTrue ( this . resolversParameter ( parameter )  )  ;", "thrown . expect ( MessageConversionException . class )  ;", "thrown . expectMessage ( Integer . class . getName (  )  )  ;", "thrown . expectMessage ( String . class . getName (  )  )  ;", "this . resolver . resolveArgument ( parameter ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveWithConversionNoMatchingConverter"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    inMessage    =    MessageBuilder . withPayload (  \"  {  \\  \" foo \\  \"  :  \\  \" bar \\  \"  }  \"  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     5  )  ;", "this . resolver    =    new   MessageMethodArgumentResolver ( new   MappingJackson 2 MessageConverter (  )  )  ;", "Object   actual    =    this . resolver . resolveArgument ( parameter ,    inMessage )  ;", "assertTrue (  ( actual   instanceof   Message )  )  ;", "Message <  ?  >    outMessage    =     (  ( Message <  ?  >  )     ( actual )  )  ;", "assertTrue (  (  ( outMessage . getPayload (  )  )    instanceof    . Foo )  )  ;", "assertEquals (  \" bar \"  ,     (  (  . Foo )     ( outMessage . getPayload (  )  )  )  . getFoo (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithJacksonConverter"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < Integer >    message    =    MessageBuilder . withPayload (  1  2  3  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     1  )  ;", "assertTrue ( this . resolversParameter ( parameter )  )  ;", "assertSame ( message ,    this . resolver . resolveArgument ( parameter ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithMatchingPayloadType"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "ErrorMessage   message    =    new   ErrorMessage ( new   UedOperationException (  )  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     0  )  ;", "assertTrue ( this . resolversParameter ( parameter )  )  ;", "assertSame ( message ,    this . resolver . resolveArgument ( parameter ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithMessageSubclassAndPayloadWildcard"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" test \"  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     0  )  ;", "assertTrue ( this . resolversParameter ( parameter )  )  ;", "assertSame ( message ,    this . resolver . resolveArgument ( parameter ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithPayloadTypeAsWildcard"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver    =    new   MessageMethodArgumentResolver (  )  ;", "Message < String >    message    =    MessageBuilder . withPayload (  \" test \"  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     0  )  ;", "assertTrue ( this . resolver . supportsParameter ( parameter )  )  ;", "assertSame ( message ,    this . resolver . resolveArgument ( parameter ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithPayloadTypeAsWildcardAndNoConverter"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < Locale >    message    =    MessageBuilder . withPayload ( Locale . getDefault (  )  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     3  )  ;", "assertTrue ( this . resolversParameter ( parameter )  )  ;", "thrown . expect ( MessageConversionException . class )  ;", "thrown . expectMessage ( Number . class . getName (  )  )  ;", "thrown . expectMessage ( Locale . class . getName (  )  )  ;", "this . resolver . resolveArgument ( parameter ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveWithPayloadTypeOutOfBound"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < Integer >    message    =    MessageBuilder . withPayload (  1  2  3  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     2  )  ;", "assertTrue ( this . resolversParameter ( parameter )  )  ;", "assertSame ( message ,    this . resolver . resolveArgument ( parameter ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithPayloadTypeSubclass"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message < Integer >    message    =    MessageBuilder . withPayload (  1  2  3  )  . build (  )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     3  )  ;", "assertTrue ( this . resolversParameter ( parameter )  )  ;", "assertSame ( message ,    this . resolver . resolveArgument ( parameter ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithPayloadTypeUpperBound"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "UnsupportedOperationException   ex    =    new   UnsupportedOperationException (  )  ;", "Message <  ?    extends   Throwable >    message    =    new   GenericMessage < Throwable >  ( ex )  ;", "MethodParameter   parameter    =    new   MethodParameter ( this . method ,     4  )  ;", "assertTrue ( this . resolver . supportsParameter ( parameter )  )  ;", "thrown . expect ( TypeMismatchException . class )  ;", "thrown . expectMessage ( ErrorMessage . class . getName (  )  )  ;", "thrown . expectMessage ( GenericMessage . class . getName (  )  )  ;", "assertSame ( message ,    this . resolver . resolveArgument ( parameter ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWithWrongMessageType"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . method    =    MessageMethodArgumentResolverTests . class . getDeclaredMethod (  \" handle \"  ,    Message . class ,    Message . class ,    Message . class ,    Message . class ,    ErrorMessage . class ,    Message . class )  ;", "this . converter    =    mock ( MessageConverter . class )  ;", "this . resolver    =    new   MessageMethodArgumentResolver ( this . converter )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.handler.annotation.support.MessageMethodArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . bindingResult ;", "}", "METHOD_END"], "methodName": ["getBindingResult"], "fileName": "org.springframework.messaging.handler.annotation.support.MethodArgumentNotValidException"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append ( bindingResult . getErrorCount (  )  )  . append (  \"    error ( s )  :     \"  )  ;", "for    ( ObjectError   error    :    bindingResult . getAllErrors (  )  )     {", "sb . append (  \"  [  \"  )  . append ( error )  . append (  \"  ]     \"  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getValidationErrorMessage"], "fileName": "org.springframework.messaging.handler.annotation.support.MethodArgumentNotValidException"}, {"methodBody": ["METHOD_START", "{", "String   paramName    =    param . getParameterName (  )  ;", "return   paramName    !  =    null    ?    paramName    :     \" Arg    \"     +     ( param . getParameterIndex (  )  )  ;", "}", "METHOD_END"], "methodName": ["getParameterName"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( payload    =  =    null )     {", "return   true ;", "} else", "if    ( payload   instanceof   byte [  ]  )     {", "return    (  (  ( byte [  ]  )     ( payload )  )  . length )     =  =     0  ;", "} else", "if    ( payload   instanceof   String )     {", "return    !  ( util . StringUtils . hasText (  (  ( String )     ( payload )  )  )  )  ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isEmptyPayload"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . validator )     =  =    null )     {", "return ;", "}", "for    ( Annotation   ann    :    parameter . getParameterAnnotations (  )  )     {", "Validated   validatedAnn    =    AnnotationUtils . getAnnotation ( ann ,    Validated . class )  ;", "if    (  ( validatedAnn    !  =    null )     |  |     ( annType (  )  . getSimpleName (  )  . startsWith (  \" Valid \"  )  )  )     {", "Object   hints    =     ( validatedAnn    !  =    null )     ?    validatedAnn . value (  )     :    AnnotationUtils . getValue ( ann )  ;", "Object [  ]    validationHints    =     ( hints   instanceof   Object [  ]  )     ?     (  ( Object [  ]  )     ( hints )  )     :    new   Object [  ]  {    hints    }  ;", "BeanPropertyBindingResult   bindingResult    =    new   BeanPropertyBindingResult ( target ,    getParameterName ( parameter )  )  ;", "if    (  (  !  ( ObjectUtils . isEmpty ( validationHints )  )  )     &  &     (  ( this . validator )    instanceof   SmartValidator )  )     {", "(  ( SmartValidator )     ( this . validator )  )  . validate ( target ,    bindingResult ,    validationHints )  ;", "} else    {", "this . validator . validate ( target ,    bindingResult )  ;", "}", "if    ( bindingResult . hasErrors (  )  )     {", "throw   new   MethodArgumentNotValidException ( message ,    parameter ,    bindingResult )  ;", "}", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolver"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" invalidValue \"  . getBytes (  )  )  . build (  )  ;", "thrown . expect ( MethoNotValidException . class )  ;", "this . resolver . resolveArgument ( this . paramValidated ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveFailValidation"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" invalidValue \"  )  . build (  )  ;", "thrown . expect ( MethoNotValidException . class )  ;", "this . resolver . resolveArgument ( this . paramValidated ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveFailValidationNoConversionNecessary"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    notEmptyMessage    =    MessageBuilder . withPayload (  \" ABC \"  . getBytes (  )  )  . build (  )  ;", "assertEquals (  \" ABC \"  ,    this . resolver . resolveArgument ( this . paramNotAnnotated ,    notEmptyMessage )  )  ;", "Message <  ?  >    emptyStringMessage    =    MessageBuilder . withPayload (  \"  \"  )  . build (  )  ;", "thrown . expect ( MethoNotValidException . class )  ;", "this . resolver . resolveArgument ( this . paramValidated ,    emptyStringMessage )  ;", "}", "METHOD_END"], "methodName": ["resolveNonAnnotatedParameter"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" invalidValue \"  . getBytes (  )  )  . build (  )  ;", "thrown . expect ( MethoNotValidException . class )  ;", "thrown . expectMessage (  \" invalid   value \"  )  ;", "assertEquals (  \" invalidValue \"  ,    this . resolver . resolveArgument ( this . paramValidatedNotAnnotated ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["resolveNonAnnotatedParameterFailValidation"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    notEmptyMessage    =    MessageBuilder . withPayload (  1  2  3  )  . build (  )  ;", "thrown . expect ( MessageConversionException . class )  ;", "thrown . expectMessage (  \" Cannot   convert \"  )  ;", "this . resolver . resolve ( this . paramAnnotatedRequired ,    notEmptyMessage )  ;", "}", "METHOD_END"], "methodName": ["resolveNonConvertibleParam"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    emptyByteArrayMessage    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . build (  )  ;", "assertNull ( this . resolver . resolve ( this . paramAnnotatedNotRequired ,    emptyByteArrayMessage )  )  ;", "Message <  ?  >    emptyStringMessage    =    MessageBuilder . withPayload (  \"  \"  )  . build (  )  ;", "assertNull ( this . resolver . resolve ( this . paramAnnotatedNotRequired ,    emptyStringMessage )  )  ;", "Message <  ?  >    notEmptyMessage    =    MessageBuilder . withPayload (  \" ABC \"  . getBytes (  )  )  . build (  )  ;", "assertEquals (  \" ABC \"  ,    this . resolver . resolve ( this . paramAnnotatedNotRequired ,    notEmptyMessage )  )  ;", "}", "METHOD_END"], "methodName": ["resolveNotRequired"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" ABC \"  . getBytes (  )  )  . build (  )  ;", "Object   actual    =    this . resolver . resolve ( paramAnnotated ,    message )  ;", "assertEquals (  \" ABC \"  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["resolveRequired"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \"  \"  )  . build (  )  ;", "thrown . expect ( MethoNotValidException . class )  ;", "this . resolver . resolveArgument ( paramAnnotated ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveRequiredEmpty"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \"  \"  )  . build (  )  ;", "thrown . expect ( MethoNotValidException . class )  ;", "this . resolver . resolveArgument ( this . paramNotAnnotated ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveRequiredEmptyNonAnnotatedParameter"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" ABC \"  . getBytes (  )  )  . build (  )  ;", "thrown . expect ( IllegalStateException . class )  ;", "this . resolver . resolve ( paramWithSpelExpression ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveSpelExpressionNotSupported"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" ABC \"  . getBytes (  )  )  . build (  )  ;", "this . resolver . resolve ( this . paramValidated ,    message )  ;", "}", "METHOD_END"], "methodName": ["resolveValidation"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver    =    new   PayloadArgumentResolver ( new   StringMessageConverter (  )  ,    testValidator (  )  )  ;", "Method   payloadMethod    =     . class . getDeclaredMethod (  \" handleMessage \"  ,    String . class ,    String . class ,    Locale . class ,    String . class ,    String . class ,    String . class ,    String . class )  ;", "this . paramAnnotated    =    new   SynthesizingMethodParameter ( payloadMethod ,     0  )  ;", "this . paramAnnotatedNotRequired    =    new   SynthesizingMethodParameter ( payloadMethod ,     1  )  ;", "this . paramAnnotatedRequired    =    new   SynthesizingMethodParameter ( payloadMethod ,     2  )  ;", "this . paramWithSpelExpression    =    new   SynthesizingMethodParameter ( payloadMethod ,     3  )  ;", "this . paramValidated    =    new   SynthesizingMethodParameter ( payloadMethod ,     4  )  ;", "this . paramValidated . initParameterNameDiscovery ( new   LocalVariableTableParameterNameDiscoverer (  )  )  ;", "this . paramValidatedNotAnnotated    =    new   SynthesizingMethodParameter ( payloadMethod ,     5  )  ;", "this . paramNotAnnotated    =    new   SynthesizingMethodParameter ( payloadMethod ,     6  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . resolver . supportsParameter ( this . paramAnnotated )  )  ;", "assertTrue ( this . resolver . supportsParameter ( this . paramNotAnnotated )  )  ;", "strictResolver    =    new    ( new   StringMessageConverter (  )  ,    testValidator (  )  ,    false )  ;", "assertTrue ( strictResolver . supportsParameter ( this . paramAnnotated )  )  ;", "assertFalse ( strictResolver . supportsParameter ( this . paramNotAnnotated )  )  ;", "}", "METHOD_END"], "methodName": ["supportsParameter"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Validator (  )     {", "@ Override", "public   boolean   s ( Class <  ?  >    clazz )     {", "return   String . class . isAssignableFrom ( clazz )  ;", "}", "@ Override", "public   void   validate ( Object   target ,    Errors   errors )     {", "String   value    =     (  ( String )     ( target )  )  ;", "if    (  \" invalidValue \"  . equals ( value )  )     {", "errors . reject (  \" invalid   value \"  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["testValidator"], "fileName": "org.springframework.messaging.handler.annotation.support.PayloadArgumentResolverTests"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?    extends   Throwable >  >    result    =    new   ArrayList <  >  (  )  ;", "for    ( Class <  ?  >    paramType    :    method . getParameterTypes (  )  )     {", "if    ( Throwable . class . isAssignableFrom ( paramType )  )     {", "result . add (  (  ( Class <  ?    extends   Throwable >  )     ( paramType )  )  )  ;", "}", "}", "if    ( result . isEmpty (  )  )     {", "throw   new   IllegalState (  (  \" No   exception   types   mapped   to    \"     +    method )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getExceptionsFromMethodSignature"], "fileName": "org.springframework.messaging.handler.invocation.AbstractExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?    extends   Throwable >  >    matches    =    new   ArrayList <  >  (  )  ;", "for    ( Class <  ?    extends   Throwable >    mapped    :    this . mappedMethods . keySet (  )  )     {", "if    ( mapped . isAssignableFrom ( exceptionType )  )     {", "matches . add ( mapped )  ;", "}", "}", "if    (  !  ( matches . isEmpty (  )  )  )     {", "matches . sort ( new   DepthComparator ( exceptionType )  )  ;", "return   this . mappedMethods . get ( matches . get (  0  )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getMappedMethod"], "fileName": "org.springframework.messaging.handler.invocation.AbstractExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . mappedMethods . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasExceptionMappings"], "fileName": "org.springframework.messaging.handler.invocation.AbstractExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    resolveMethodByExceptionType ( exception . getClass (  )  )  ;", "if    ( method    =  =    null )     {", "Throwable   cause    =    exception . getCause (  )  ;", "if    ( cause    !  =    null )     {", "method    =    resolveMethodByExceptionType ( cause . getClass (  )  )  ;", "}", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["resolveMethod"], "fileName": "org.springframework.messaging.handler.invocation.AbstractExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    this . exceptionLookupCache . get ( exceptionType )  ;", "if    ( method    =  =    null )     {", "method    =    getMappedMethod ( exceptionType )  ;", "this . exceptionLookupCache . put ( exceptionType ,    method )  ;", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["resolveMethodByExceptionType"], "fileName": "org.springframework.messaging.handler.invocation.AbstractExceptionHandlerMethodResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( T   mapping    :    mappingsToCheck )     {", "T   match    =    getMatchingMapping ( mapping ,    message )  ;", "if    ( match    !  =    null )     {", "matches . add ( new   Match ( match ,    thisMethods . get ( mapping )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addMatchesToCollection"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "HandlerMethod   handlerMethod ;", "if    ( handler   instanceof   String )     {", "ApplicationContext   context    =    getApplicationContext (  )  ;", "Assert . state (  ( context    !  =    null )  ,     \" ApplicationContext   is   required   for   resolving   handler   bean   names \"  )  ;", "String   beanName    =     (  ( String )     ( handler )  )  ;", "handlerMethod    =    new   HandlerMethod ( beanName ,    context . getAutowireCapableBeanFactory (  )  ,    method )  ;", "} else    {", "handlerMethod    =    new   HandlerMethod ( handler ,    method )  ;", "}", "return   handlerMethod ;", "}", "METHOD_END"], "methodName": ["createHandlerMethod"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    ype ;", "if    ( instanceof   String )     {", "ApplicationContext   context    =    getApplicationContext (  )  ;", "Assert . state (  ( context    !  =    null )  ,     \" ApplicationContext   is   required   for   resolving   bean   names \"  )  ;", "ype    =    context . getType (  (  ( String )     (  )  )  ;", "} else    {", "ype    =    getClass (  )  ;", "}", "if    ( ype    !  =    null )     {", "final   Class <  ?  >    userType    =    ClassUtils . getUserClass ( ype )  ;", "Map < Method ,    T >    methods    =    MethodIntrospector . selectMethods ( userType ,     (  ( MethodIntrospector . MetadataLookup < T >  )     (  (    method )     -  >    getMappingForMethod ( method ,    userType )  )  )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  ( methods . size (  )  )     +     \"    message   methods   found   on    \"  )     +    userType )     +     \"  :     \"  )     +    methods )  )  ;", "}", "methods . forEach (  (    key ,    value )     -  >    registerHandlerMethod (    key ,    value )  )  ;", "}", "}", "METHOD_END"], "methodName": ["detectHandlerMethods"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . argumentResolvers . getResolvers (  )  ;", "}", "METHOD_END"], "methodName": ["getArgumentResolvers"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . customArgumentResolvers ;", "}", "METHOD_END"], "methodName": ["getCustomArgumentResolvers"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . customReturnValueHandlers ;", "}", "METHOD_END"], "methodName": ["getCustomReturnValueHandlers"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationPrefixes ;", "}", "METHOD_END"], "methodName": ["getDestinationPrefixes"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Searching   methods   to   handle    \"     +     ( exception . getClass (  )  . getSimpleName (  )  )  )  )  ;", "}", "Class <  ?  >    beanType    =    handlerMethod . getBeanType (  )  ;", "ExceptionHandlerMethodResolver   resolver    =    this . exceptionHandlerCache . get ( beanType )  ;", "if    ( resolver    =  =    null )     {", "resolver    =    createExceptionHandlerMethodResolverFor ( beanType )  ;", "this . exceptionHandlerCache . put ( beanType ,    resolver )  ;", "}", "Method   method    =    resolver . resolveMethod ( exception )  ;", "if    ( method    !  =    null )     {", "return   new   InvocableHandlerMethod ( handlerMethod . getBean (  )  ,    method )  ;", "}", "for    ( MessagingAdviceBean   advice    :    this . exceptionHandlerAdviceCache . keySet (  )  )     {", "if    ( advice . isApplicableToBeanType ( beanType )  )     {", "resolver    =    this . exceptionHandlerAdviceCache . get ( advice )  ;", "method    =    resolver . resolveMethod ( exception )  ;", "if    ( method    !  =    null )     {", "return   new   InvocableHandlerMethod ( advice . resolveBean (  )  ,    method )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getExceptionHandlerMethod"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . handlerMethods )  ;", "}", "METHOD_END"], "methodName": ["getHandlerMethods"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( destin =  =    null )     {", "return   null ;", "}", "if    ( CollectionUtils . isEmpty ( this . destinrefixes )  )     {", "return   destin", "}", "for    ( int   i    =     0  ;    i    <     ( this . destinrefixes . size (  )  )  ;    i +  +  )     {", "String   prefix    =    this . destinrefixes . get ( i )  ;", "if    ( destinstartsWith ( prefix )  )     {", "return   destinsubstring ( prefix . length (  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getLookupDestination"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . returnValueHandlers . getReturnValueHandlers (  )  ;", "}", "METHOD_END"], "methodName": ["getReturnValueHandlers"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Invoking    \"     +     ( handlerMethod . getShortLogMessage (  )  )  )  )  ;", "}", "handlerMethod    =    handlerMethod . createWithResolvedBean (  )  ;", "InvocablMethod   invocable    =    new   InvocablMethod ( handlerMethod )  ;", "invocable . setMessageMethodArgumentResolvers ( this . argumentResolvers )  ;", "try    {", "Object   returnValue    =    invocable . invoke ( message )  ;", "MethodParameter   returnType    =    handlerMethod . getReturnType (  )  ;", "if    (  ( void . class )     =  =     ( returnType . getParameterType (  )  )  )     {", "return ;", "}", "if    (  ( returnValue    !  =    null )     &  &     ( this . returnValus . isAsyncReturnValue ( returnValue ,    returnType )  )  )     {", "ListenableFuture <  ?  >    future    =    this . returnValus . toListenableFuture ( returnValue ,    returnType )  ;", "if    ( future    !  =    null )     {", "future . addCallback ( new   ReturnValueListenableFutureCallback ( invocable ,    message )  )  ;", "}", "} else    {", "this . returnValus . handleReturnValue ( returnValue ,    returnType ,    message )  ;", "}", "}    catch    ( Exception   ex )     {", "processHandlerMethodException ( handlerMethod ,    ex ,    message )  ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  \" Error   while   processing   message    \"     +    message )  ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleMatch"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "List < AbstractMethodMessageHandler < T >  . Match >    matches    =    new   ArrayList <  >  (  )  ;", "List < T >    mappingsByUrl    =    this . destinationLookup . get ( lookupDestination )  ;", "if    ( mappingsByUrl    !  =    null )     {", "addMatchesToCollection ( mappingsByUrl ,    message ,    matches )  ;", "}", "if    ( matches . isEmpty (  )  )     {", "Set < T >    allMappings    =    this . handlerMethods . keySet (  )  ;", "addMatchesToCollection ( allMappings ,    message ,    matches )  ;", "}", "if    ( matches . isEmpty (  )  )     {", "handleNoMatch ( this . handlerMethods . keySet (  )  ,    lookupDestination ,    message )  ;", "return ;", "}", "Comparator < AbstractMethodMessageHandler < T >  . Match >    comparator    =    new   MatchComparator ( getMappingComparator ( message )  )  ;", "matches . sort ( comparator )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Found    \"     +     ( matches . size (  )  )  )     +     \"    handler   methods :     \"  )     +    matches )  )  ;", "}", "AbstractMethodMessageHandler < T >  . Match   bestMatch    =    matches . get (  0  )  ;", "if    (  ( matches . size (  )  )     >     1  )     {", "AbstractMethodMessageHandler < T >  . Match   secondBestMatch    =    matches . get (  1  )  ;", "if    (  ( comparator . compare ( bestMatch ,    secondBestMatch )  )     =  =     0  )     {", "Method   m 1     =    bestMatch . handlerMethod . getMethod (  )  ;", "Method   m 2     =    secondBestMatch . handlerMethod . getMethod (  )  ;", "throw   new   IllegalStateException (  (  (  (  (  (  (  \" Ambiguous   handler   methods   mapped   for   destination    '  \"     +    lookupDestination )     +     \"  '  :     {  \"  )     +    m 1  )     +     \"  ,     \"  )     +    m 2  )     +     \"  }  \"  )  )  ;", "}", "}", "handleMatch ( bestMatch . mapping ,    bestMatch . handlerMethod ,    lookupDestination ,    message )  ;", "}", "METHOD_END"], "methodName": ["handleMessageInternal"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  \" No   matching   message   handler   methods .  \"  )  ;", "}", "METHOD_END"], "methodName": ["handleNoMatch"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "InvocableHandlerMethod   invocable    =    getExceptionHandlerMethod ( handlerMethod ,    ex )  ;", "if    ( invocable    =  =    null )     {", "logger . error (  \" Unhandled   exception   from   message   handler   method \"  ,    ex )  ;", "return ;", "}", "invocable . setMessageMethodArgumentResolvers ( this . argumentResolvers )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Invoking    \"     +     ( invocable . getShortLogMessage (  )  )  )  )  ;", "}", "try    {", "Object   returnValue    =    invocable . invoke ( message ,    ex ,    handlerMethod )  ;", "MethodParameter   returnType    =    invocable . getReturnType (  )  ;", "if    (  ( void . class )     =  =     ( returnType . getParameterType (  )  )  )     {", "return ;", "}", "this . returnValueHandlers . handleReturnValue ( returnValue ,    returnType ,    message )  ;", "}    catch    ( Throwable   ex 2  )     {", "logger . error (  \" Error   while   processing   handler   method   exception \"  ,    ex 2  )  ;", "}", "}", "METHOD_END"], "methodName": ["processHandlerMethodException"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . exceptionHandlerAdviceCache . put ( bean ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["registerExceptionHandlerAdvice"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( mapping ,     \" Mapping   must   not   be   null \"  )  ;", "HandlerMethod   newHandlerMethod    =    creatMethod ( handler ,    method )  ;", "HandlerMethod   oldHandlerMethod    =    this . handlerMethods . get ( mapping )  ;", "if    (  ( oldHandlerMethod    !  =    null )     &  &     (  !  ( oldHandlerMethod . equals ( newHandlerMethod )  )  )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  (  (  (  (  (  \" Ambiguous   mapping   found .    Cannot   map    '  \"     +     ( newHandlerMethod . getBean (  )  )  )     +     \"  \\  '    bean   method    \\ n \"  )     +    newHandlerMethod )     +     \"  \\ nto    \"  )     +    mapping )     +     \"  :    There   is   already    '  \"  )     +     ( oldHandlerMethod . getBean (  )  )  )     +     \"  \\  '    bean   method \\ n \"  )     +    oldHandlerMethod )     +     \"    mapped .  \"  )  )  ;", "}", "this . handlerMethods . put ( mapping ,    newHandlerMethod )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  \" Mapped    \\  \"  \"     +    mapping )     +     \"  \\  \"    onto    \"  )     +    newHandlerMethod )  )  ;", "}", "for    ( String   pattern    :    getDirectLookupDestinations ( mapping )  )     {", "this . destinationLookup . add ( pattern ,    mapping )  ;", "}", "}", "METHOD_END"], "methodName": ["registerHandlerMethod"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( argumentResolvers    =  =    null )     {", "this . argumentResolvers . clear (  )  ;", "return ;", "}", "this . argumentResolvers . addResolvers ( argumentResolvers )  ;", "}", "METHOD_END"], "methodName": ["setArgumentResolvers"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . customArgumentResolvers . clear (  )  ;", "if    ( customArgumentResolvers    !  =    null )     {", "this . customArgumentResolvers . addAll ( customArgumentResolvers )  ;", "}", "}", "METHOD_END"], "methodName": ["setCustomArgumentResolvers"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . customReturnValueHandlers . clear (  )  ;", "if    ( customReturnValueHandlers    !  =    null )     {", "this . customReturnValueHandlers . addAll ( customReturnValueHandlers )  ;", "}", "}", "METHOD_END"], "methodName": ["setCustomReturnValueHandlers"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . destinationPrefixes . clear (  )  ;", "if    ( prefixes    !  =    null )     {", "for    ( String   prefix    :    prefixes )     {", "prefix    =    prefix . trim (  )  ;", "this . destinationPrefixes . add ( prefix )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setDestinationPrefixes"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( returnValueHandlers    =  =    null )     {", "this . returnValueHandlers . clear (  )  ;", "return ;", "}", "this . returnValueHandlers . addHandlers ( returnValueHandlers )  ;", "}", "METHOD_END"], "methodName": ["setReturnValueHandlers"], "fileName": "org.springframework.messaging.handler.invocation.AbstractMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . argumentResolvers . add ( argumentResolver )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addResolver"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "if    ( argumentResolvers    !  =    null )     {", "this . argumentResolvers . addAll ( argumentResolvers )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addResolvers"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "if    ( resolvers    !  =    null )     {", "for    (    resolver    :    resolvers )     {", "this . argumentResolvers . add ( resolver )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addResolvers"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "this . argumentResolvers . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "HandlerMethodArgumentResolver   result    =    this . argumentResolverCache . get ( parameter )  ;", "if    ( result    =  =    null )     {", "for    ( HandlerMethodArgumentResolver   resolver    :    this . argumentResolvers )     {", "if    ( resolver . supportsParameter ( parameter )  )     {", "result    =    resolver ;", "this . argumentResolverCache . put ( parameter ,    result )  ;", "break ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getArgumentResolver"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . argumentResolvers )  ;", "}", "METHOD_END"], "methodName": ["getResolvers"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolverComposite"}, {"methodBody": ["METHOD_START", "{", "this . returnValueHandlers . add ( returnValueHandler )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addHandler"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "if    ( handlers    !  =    null )     {", "this . rs . addAll ( handlers )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addHandlers"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "this . returnValueHandlers . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( this . returnValueHandlers . size (  )  )  ;    i +  +  )     {", "handler    =    this . returnValueHandlers . get ( i )  ;", "if    ( handler . supportsReturnType ( returnType )  )     {", "return   handler ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getReturnValueHandler"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . returnValueHandlers )  ;", "}", "METHOD_END"], "methodName": ["getReturnValueHandlers"], "fileName": "org.springframework.messaging.handler.invocation.HandlerMethodReturnValueHandlerComposite"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    methodDeclaringClass    =    method . getDeclaringClass (  )  ;", "Class <  ?  >    targetBeanClass    =    targetBean . getClass (  )  ;", "if    (  !  ( methodDeclaringClass . isAssignableFrom ( targetBeanClass )  )  )     {", "String   text    =     (  (  (  (  \" The   mapped   handler   method   class    '  \"     +     ( methodDeclaringClass . getName (  )  )  )     +     \"  '    is   not   an   instance   of   the   actual   endpoint   bean   class    '  \"  )     +     ( targetBeanClass . getName (  )  )  )     +     \"  '  .    If   the   endpoint   requires   proxying    \"  )     +     \"  ( e . g .    due   to    @ Transactional )  ,    please   use   class - based   proxying .  \"  ;", "throw   new   IllegalStateException ( getIErrorMessage ( text ,    args )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertTargetBean"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "ReflectionUtils . makeAccessible ( getBridgedMethod (  )  )  ;", "try    {", "return   getBridgedMethod (  )  . invoke ( getBean (  )  ,    args )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTargetBean ( getBridgedMethod (  )  ,    getBean (  )  ,    args )  ;", "String   text    =     (  ( ex . getMessage (  )  )     !  =    null )     ?    ex . getMessage (  )     :     \" Illegal   argument \"  ;", "throw   new   IllegalStateException ( getIErrorMessage ( text ,    args )  ,    ex )  ;", "}    catch    ( ITargetException   ex )     {", "Throwable   targetException    =    ex . getTargetException (  )  ;", "if    ( targetException   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( targetException )  )  ;", "} else", "if    ( targetException   instanceof   Error )     {", "throw    (  ( Error )     ( targetException )  )  ;", "} else", "if    ( targetException   instanceof   Exception )     {", "throw    (  ( Exception )     ( targetException )  )  ;", "} else    {", "String   text    =    getIErrorMessage (  \" Failed   to   invoke   handler   method \"  ,    args )  ;", "throw   new   IllegalStateException ( text ,    targetException )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doInvoke"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    paramType    =    getMethodParameters (  )  [ index ]  . getParameterType (  )  ;", "return    (  (  (  ( text    +     \"    argument    \"  )     +    index )     +     \"    of   type    '  \"  )     +     ( paramType . getName (  )  )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["getArgumentResolutionErrorMessage"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   InvocableHandlerMethod . AsyncResultMethodParameter ( returnValue )  ;", "}", "METHOD_END"], "methodName": ["getAsyncReturnValueType"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( text )  . append (  \"  \\ n \"  )  ;", "sb . append (  \"    details :     \\ n \"  )  ;", "sb . append (  \" Endpoint    [  \"  )  . append ( getBeanType (  )  . getName (  )  )  . append (  \"  ]  \\ n \"  )  ;", "sb . append (  \" Method    [  \"  )  . append ( getBridgedMethod (  )  . toGenericString (  )  )  . append (  \"  ]  \\ n \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDetailedErrorMessage"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( getDetailedErrorMessage ( text )  )  ;", "sb . append (  \" Resolved   arguments :     \\ n \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( resolvedArgs . length )  ;    i +  +  )     {", "sb . append (  \"  [  \"  )  . append ( i )  . append (  \"  ]     \"  )  ;", "if    (  ( resolvedArgs [ i ]  )     =  =    null )     {", "sb . append (  \"  [ null ]     \\ n \"  )  ;", "} else    {", "sb . append (  \"  [ type =  \"  )  . append ( resolvedArgs [ i ]  . getClass (  )  . getName (  )  )  . append (  \"  ]     \"  )  ;", "sb . append (  \"  [ value =  \"  )  . append ( resolvedArgs [ i ]  )  . append (  \"  ]  \\ n \"  )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getInvocationErrorMessage"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "MethodParameter [  ]    parameters    =    getMethodParameters (  )  ;", "Object [  ]    args    =    new   Object [ parameters . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( parameters . length )  ;    i +  +  )     {", "MethodParameter   parameter    =    parameters [ i ]  ;", "parameter . initParameterNameDiscovery ( this . parameterNameDiscoverer )  ;", "args [ i ]     =    resolveProvidedArgument ( parameter ,    providedArgs )  ;", "if    (  ( args [ i ]  )     !  =    null )     {", "continue ;", "}", "if    ( this . argumentResolvers . supportsParameter ( parameter )  )     {", "try    {", "args [ i ]     =    this . argumentResolvers . resolveArgument ( parameter ,    message )  ;", "continue ;", "}    catch    ( Exception   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug ( getArgumentResolutionErrorMessage (  \" Failed   to   resolve \"  ,    i )  ,    ex )  ;", "}", "throw   ex ;", "}", "}", "if    (  ( args [ i ]  )     =  =    null )     {", "throw   new   MethodArgumentResolutionException ( message ,    parameter ,    getArgumentResolutionErrorMessage (  \" No   suitable   resolver   for \"  ,    i )  )  ;", "}", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["getMethodArgumentValues"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    args    =    getMethodArgumentValues ( message ,    providedArgs )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  \" Invoking    '  \"     +     ( ClassUtils . getQualifiedMethodName ( getMethod (  )  ,    getBeanType (  )  )  )  )     +     \"  '    with   arguments    \"  )     +     ( Arrays . toString ( args )  )  )  )  ;", "}", "Object   returnValue    =    doInvoke ( args )  ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  \" Method    [  \"     +     ( ClassUtils . getQualifiedMethodName ( getMethod (  )  ,    getBeanType (  )  )  )  )     +     \"  ]    returned    [  \"  )     +    returnValue )     +     \"  ]  \"  )  )  ;", "}", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   providedArg    :    providedArgs )     {", "if    ( pater . getPaterType (  )  . isInstance ( providedArg )  )     {", "return   providedArg ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveProvidedArgument"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . argumentResolvers    =    argumentResolvers ;", "}", "METHOD_END"], "methodName": ["setMessageMethodArgumentResolvers"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "this . parameterNameDiscoverer    =    parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["setParameterNameDiscoverer"], "fileName": "org.springframework.messaging.handler.invocation.InvocableHandlerMethod"}, {"methodBody": ["METHOD_START", "{", "return   this . parameter ;", "}", "METHOD_END"], "methodName": ["getMethodParameter"], "fileName": "org.springframework.messaging.handler.invocation.MethodArgumentResolutionException"}, {"methodBody": ["METHOD_START", "{", "return    (  (  \" Could   not   resolve   method   parameter   at   index    \"     +     ( parameter . getParameterIndex (  )  )  )     +     \"    in    \"  )     +     ( parameter . getExecutable (  )  . toGenericString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMethodParameterMessage"], "fileName": "org.springframework.messaging.handler.invocation.MethodArgumentResolutionException"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    this . testController . getClass (  )  . getMethod (  \" handlerPathMatchWildcard \"  )  ;", "this . m . registerHandlerMethod ( this . testController ,    method ,     \"  / handlerPathMatch *  \"  )  ;", "this . m . handleMessage ( toDestination (  \"  / test / handlerPathMatchFoo \"  )  )  ;", "assertEquals (  \" pathMatchWildcard \"  ,    this . testController . method )  ;", "}", "METHOD_END"], "methodName": ["antPatchMatchWildcard"], "fileName": "org.springframework.messaging.handler.invocation.MethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . handleMessage ( toDestination (  \"  / test / handlerArgumentResolver \"  )  )  ;", "assertEquals (  \" handlerArgumentResolver \"  ,    this . testController . method )  ;", "assertNotNull ( this . testController . arguments . get (  \" message \"  )  )  ;", "}", "METHOD_END"], "methodName": ["argumentResolution"], "fileName": "org.springframework.messaging.handler.invocation.MethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    this . testController . getClass (  )  . getMethod (  \" bestMatch \"  )  ;", "this . m . registerHandlerMethod ( this . testController ,    method ,     \"  / bestmatch /  { foo }  / path \"  )  ;", "method    =    this . testController . getClass (  )  . getMethod (  \" secondBestMatch \"  )  ;", "this . m . registerHandlerMethod ( this . testController ,    method ,     \"  / bestmatch /  *  /  *  \"  )  ;", "this . m . handleMessage ( toDestination (  \"  / test / bestmatch / bar / path \"  )  )  ;", "assertEquals (  \" bestMatch \"  ,    this . testController . method )  ;", "}", "METHOD_END"], "methodName": ["bestMatchWildcard"], "fileName": "org.springframework.messaging.handler.invocation.MethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . registerHandler ( new   MethodMessageHandlerTests . DuplicateMappingsController (  )  )  ;", "}", "METHOD_END"], "methodName": ["duplicateMapping"], "fileName": "org.springframework.messaging.handler.invocation.MethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . handleMessage ( toDestination (  \"  / test / handlerThrowsExc \"  )  )  ;", "assertEquals (  \" illegalStateException \"  ,    this . testController . method )  ;", "assertNotNull ( this . testController . arguments . get (  \" exception \"  )  )  ;", "}", "METHOD_END"], "methodName": ["exceptionHandled"], "fileName": "org.springframework.messaging.handler.invocation.MethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    HandlerMethod >    handlerMethods    =    this . messageHandler . getHandlerMethods (  )  ;", "assertNotNull ( handlerMethods )  ;", "assertThat ( handlerMethods . keySet (  )  ,    Matchers . hasSize (  3  )  )  ;", "}", "METHOD_END"], "methodName": ["registeredMappings"], "fileName": "org.springframework.messaging.handler.invocation.MethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    destinationPrefixes    =    Arrays . asList (  \"  / test \"  )  ;", "this . messageHandler    =    new    . TestMethodMessageHandler (  )  ;", "this . messageHandler . setApplicationContext ( new   StaticApplicationContext (  )  )  ;", "this . messageHandler . setDestinationPrefixes ( destinationPrefixes )  ;", "this . messageHandler . afterPropertiesSet (  )  ;", "this . testController    =    new    . TestController (  )  ;", "this . messageHandler . registerHandler ( this . testController )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.handler.invocation.MethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeader ( MethodMessageHandlerTests . DESTINATION _ HEADER ,    destination )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toDestination"], "fileName": "org.springframework.messaging.handler.invocation.MethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . attributes . forEach (  (    key ,    value )     -  >     {", "if    ( key . startsWith (  . DESTRUCTION _ CALLBACK _ NAME _ PREFIX )  )     {", "try    {", "(  ( Runnable )     ( value )  )  . run (  )  ;", "}    catch    ( Throwable   ex )     {", ". logger . error (  \" Uncaught   error   in   session   attribute   destruction   callback \"  ,    ex )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["executeDestructionCallbacks"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( message ,     \" Message   must   not   be   null \"  )  ;", "MessageHeaders   headers    =    message . getHeaders (  )  ;", "String   sessionId    =    SimpMessageHeaderAccessor . getSessionId ( headers )  ;", "Map < String ,    Object >    sessionAttributes    =    SimpMessageHeaderAccessor . getSessionAttributes ( headers )  ;", "if    ( sessionId    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   session   id   in    \"     +    message )  )  ;", "}", "if    ( sessionAttributes    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   session   attributes   in    \"     +    message )  )  ;", "}", "return   new    ( sessionId ,    sessionAttributes )  ;", "}", "METHOD_END"], "methodName": ["fromMessage"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . attributes . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . toStringArray ( this . attributes . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeNames"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionId ;", "}", "METHOD_END"], "methodName": ["getSessionId"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "Object   mutex    =    this . attributes . get ( SimpAttributes . SESSION _ MUTEX _ NAME )  ;", "if    ( mutex    =  =    null )     {", "mutex    =    this . attributes ;", "}", "return   mutex ;", "}", "METHOD_END"], "methodName": ["getSessionMutex"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "return    ( this . attributes . get ( SimpAttributes . SESSION _ COMPLETED _ NAME )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isSessionCompleted"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "synchronized ( getSessionMutex (  )  )     {", "if    ( isSessionCompleted (  )  )     {", "throw   new   IllegalStateException (  (  (  \" Session   id =  \"     +     ( getSessionId (  )  )  )     +     \"    already   completed \"  )  )  ;", "}", "this . attributes . put (  (  (  . DESTRUCTION _ CALLBACK _ NAME _ PREFIX )     +    name )  ,    callback )  ;", "}", "}", "METHOD_END"], "methodName": ["registerDestructionCallback"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "this . attributes . remove ( name )  ;", "removeDestructionCallback ( name )  ;", "}", "METHOD_END"], "methodName": ["removeAttribute"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "synchronized ( getSessionMutex (  )  )     {", "this . attributes . remove (  (  (  . DESTRUCTION _ CALLBACK _ NAME _ PREFIX )     +    name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["removeDestructionCallback"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "synchronized ( getSessionMutex (  )  )     {", "if    (  !  ( isSessionCompleted (  )  )  )     {", "executeDestructionCallbacks (  )  ;", "this . attributes . put (  . SESSION _ COMPLETED _ NAME ,    Boolean . TRUE )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["sessionCompleted"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "this . attributes . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setAttribute"], "fileName": "org.springframework.messaging.simp.SimpAttributes"}, {"methodBody": ["METHOD_START", "{", "SimpAttributes   attributes    =    SimpAttributesContextHolder . getAttributes (  )  ;", "if    ( attributes    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   thread - bound   SimpAttributes   found .     \"     +     (  \" Your   code   is   probably   not   processing   a   client   message   and   executing   in    \"     +     \" message - handling   methods   invoked   by   the   SimpAnnotationMethodMessageHandler ?  \"  )  )  )  ;", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["currentAttributes"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolder"}, {"methodBody": ["METHOD_START", "{", "return   SimpAttributesContextHolder . attributesHolder . get (  )  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolder"}, {"methodBody": ["METHOD_START", "{", "SimpAttributesContextHolder . attributesHolder . remove (  )  ;", "}", "METHOD_END"], "methodName": ["resetAttributes"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( attributes    !  =    null )     {", ". attributesHolder . set ( attributes )  ;", "} else    {", ". resetAttributes (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAttributes"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolder"}, {"methodBody": ["METHOD_START", "{", "SimpAttributesContextHolder . setAttributes ( SimpAttributes . fromMessage ( message )  )  ;", "}", "METHOD_END"], "methodName": ["setAttributesFromMessage"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolder"}, {"methodBody": ["METHOD_START", "{", "SimpAttributesContextHolder . setAttributes ( this . simpAttributes )  ;", "assertThat ( SimpAttributesContextHolder . currentAttributes (  )  ,    sameInstance ( this . simpAttributes )  )  ;", "}", "METHOD_END"], "methodName": ["currentAttributes"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage ( startsWith (  \" No   thread - bound   SimpAttributes   found \"  )  )  ;", ". currentAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["currentAttributesNone"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( SimpAttributesContextHolder . getAttributes (  )  ,    nullValue (  )  )  ;", "SimpAttributesContextHolder . setAttributes ( this . simpAttributes )  ;", "assertThat ( SimpAttributesContextHolder . getAttributes (  )  ,    sameInstance ( this . simpAttributes )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "SimpAttributesContextHolder . setAttributes ( this . simpAttributes )  ;", "assertThat ( SimpAttributesContextHolder . getAttributes (  )  ,    sameInstance ( this . simpAttributes )  )  ;", "SimpAttributesContextHolder . resetAttributes (  )  ;", "assertThat ( SimpAttributesContextHolder . getAttributes (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["resetAttributes"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "SimpAttributesContextHolder . setAttributes ( this . simpAttributes )  ;", "assertThat ( SimpAttributesContextHolder . getAttributes (  )  ,    sameInstance ( this . simpAttributes )  )  ;", "SimpAttributesContextHolder . setAttributes ( null )  ;", "assertThat ( SimpAttributesContextHolder . getAttributes (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setAttributes"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" session 1  \"  ;", "ConcurrentHashMap < String ,    Object >    map    =    new   ConcurrentHashMap <  >  (  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    SimpMessageHeaderAccessor . create (  )  ;", "headerAccessor . setSessionId ( sessionId )  ;", "headerAccessor . setSessionAttributes ( map )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \"  \"  ,    headerAccessor . getMessageHeaders (  )  )  ;", ". setAttributesFromMessage ( message )  ;", "SimpAttributes   attrs    =     . getAttributes (  )  ;", "assertThat ( attrs ,    notNullValue (  )  )  ;", "assertThat ( attrs . getSessionId (  )  ,    is ( sessionId )  )  ;", "attrs . setAttribute (  \" name 1  \"  ,     \" value 1  \"  )  ;", "assertThat ( map . get (  \" name 1  \"  )  ,    is (  \" value 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setAttributesFromMessage"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage ( startsWith (  \" No   session   attributes   in \"  )  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    SimpMessageHeaderAccessor . create (  )  ;", "headerAccessor . setSessionId (  \" session 1  \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \"  \"  ,    headerAccessor . getMessageHeaders (  )  )  ;", ". setAttributesFromMessage ( message )  ;", "}", "METHOD_END"], "methodName": ["setAttributesFromMessageWithMissingSessionAttributes"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage ( startsWith (  \" No   session   id   in \"  )  )  ;", ". setAttributesFromMessage ( new   GenericMessage < Object >  (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setAttributesFromMessageWithMissingSessionId"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   ConcurrentHashMap <  >  (  )  ;", "this . simpAttributes    =    new    (  \" session 1  \"  ,    map )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "SimpAttributesContextHolder . resetAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.messaging.simp.SimpAttributesContextHolderTests"}, {"methodBody": ["METHOD_START", "{", "this . simpAttributes . setAttribute (  \" name 1  \"  ,     \" value 1  \"  )  ;", "assertThat ( this . simpAttributes . getAttribute (  \" name 1  \"  )  ,    is (  \" value 1  \"  )  )  ;", "assertThat ( this . simpAttributes . getAttribute (  \" name 2  \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "this . simpAttributes . setAttribute (  \" name 1  \"  ,     \" value 1  \"  )  ;", "this . simpAttributes . setAttribute (  \" name 2  \"  ,     \" value 1  \"  )  ;", "this . simpAttributes . setAttribute (  \" name 3  \"  ,     \" value 1  \"  )  ;", "assertThat ( this . simpAttributes . getAttributeNames (  )  ,    arrayContainingInAnyOrder (  \" name 1  \"  ,     \" name 2  \"  ,     \" name 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeNames"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . simpAttributes . getSessionMutex (  )  ,    sameInstance ( this . map )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionMutex"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Object   mutex    =    new   Object (  )  ;", "this . simpAttributes . setAttribute (  . SESSION _ MUTEX _ NAME ,    mutex )  ;", "assertThat ( this . simpAttributes . getSessionMutex (  )  ,    sameInstance ( mutex )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionMutexExplicit"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   callback    =    Mockito . mock ( Runnable . class )  ;", "this . simpAttributes . registerDestructionCallback (  \" name 1  \"  ,    callback )  ;", "assertThat ( this . simpAttributes . getAttribute (  (  (  . DESTRUCTION _ CALLBACK _ NAME _ PREFIX )     +     \" name 1  \"  )  )  ,    sameInstance ( callback )  )  ;", "}", "METHOD_END"], "methodName": ["registerDestructionCallback"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "this . simpAttributes . sessionCompleted (  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage ( containsString (  \" already   completed \"  )  )  ;", "this . simpAttributes . registerDestructionCallback (  \" name 1  \"  ,    Mockito . mock ( Runnable . class )  )  ;", "}", "METHOD_END"], "methodName": ["registerDestructionCallbackAfterSessionCompleted"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   callback 1     =    Mockito . mock ( Runnable . class )  ;", "Runnable   callback 2     =    Mockito . mock ( Runnable . class )  ;", "this . s . registerDestructionCallback (  \" name 1  \"  ,    callback 1  )  ;", "this . s . registerDestructionCallback (  \" name 2  \"  ,    callback 2  )  ;", "assertThat ( this . s . getAttributeNames (  )  . length ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["removeDestructionCallback"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   callback 1     =    Mockito . mock ( Runnable . class )  ;", "Runnable   callback 2     =    Mockito . mock ( Runnable . class )  ;", "this . s . registerDestructionCallback (  \" name 1  \"  ,    callback 1  )  ;", "this . s . registerDestructionCallback (  \" name 2  \"  ,    callback 2  )  ;", "this . s . sessionCompleted (  )  ;", "verify ( callback 1  ,    times (  1  )  )  . run (  )  ;", "verify ( callback 2  ,    times (  1  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["sessionCompleted"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   callback 1     =    Mockito . mock ( Runnable . class )  ;", "this . s . registerDestructionCallback (  \" name 1  \"  ,    callback 1  )  ;", "this . s . sessionCompleted (  )  ;", "this . s . sessionCompleted (  )  ;", "this . s . sessionCompleted (  )  ;", "verify ( callback 1  ,    times (  1  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["sessionCompletedIsIdempotent"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "this . map    =    new   ConcurrentHashMap <  >  (  )  ;", "this . simpAttributes    =    new    (  \" session 1  \"  ,    this . map )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.SimpAttributesTests"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpMessageHeaderAccessor ( SimpMessageType . MESSAGE ,    null )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpMessageHeaderAccessor ( messageType ,    null )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "Type   messageType    =    getMessageType (  )  ;", "sb . append (  ( messageType    !  =    null    ?    messageType . name (  )     :    Type . OTHER )  )  ;", "String   destination    =    getDestination (  )  ;", "if    ( destination    !  =    null )     {", "sb . append (  \"    destination =  \"  )  . append ( destination )  ;", "}", "String   subscriptionId    =    getSubscriptionId (  )  ;", "if    ( subscriptionId    !  =    null )     {", "sb . append (  \"    subscriptionId =  \"  )  . append ( subscriptionId )  ;", "}", "sb . append (  \"    session =  \"  )  . append ( getSessionId (  )  )  ;", "Principal   user    =    getUser (  )  ;", "if    ( user    !  =    null )     {", "sb . append (  \"    user =  \"  )  . append ( user . getName (  )  )  ;", "}", "return   sb ;", "}", "METHOD_END"], "methodName": ["getBaseLogMessage"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( getHeader ( SimpMessageHeaderAccessor . DESTINATION _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDestination"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( headers . get ( SimpMessageHeaderAccessor . DESTINATION _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDestination"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( long [  ]  )     ( headers . get ( SimpMessageHeaderAccessor . HEART _ BEAT _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getHeartbeat"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( SimpMessageType )     ( getHeader ( SimpMessageHeaderAccessor . MESSAGE _ TYPE _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessageType"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( SimpMessageType )     ( headers . get ( SimpMessageHeaderAccessor . MESSAGE _ TYPE _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessageType"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Map < String ,    Object >  )     ( getHeader ( SimpMessageHeaderAccessor . SESSION _ ATTRIBUTES )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionAttributes"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Map < String ,    Object >  )     ( headers . get ( SimpMessageHeaderAccessor . SESSION _ ATTRIBUTES )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionAttributes"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( getHeader ( SimpMessageHeaderAccessor . SESSION _ ID _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionId"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( headers . get ( SimpMessageHeaderAccessor . SESSION _ ID _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionId"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( getHeader ( SimpMessageHeaderAccessor . SUBSCRIPTION _ ID _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSubscriptionId"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( headers . get ( SimpMessageHeaderAccessor . SUBSCRIPTION _ ID _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSubscriptionId"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Principal )     ( getHeader ( SimpMessageHeaderAccessor . USER _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getUser"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Principal )     ( headers . get ( SimpMessageHeaderAccessor . USER _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getUser"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( SimpMessageHeaderAccessor . DESTINATION _ HEADER ,    destination )  ;", "}", "METHOD_END"], "methodName": ["setDestination"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getMessageType (  )  )     =  =    null )     {", "setHeader (  . MESSAGE _ TYPE _ HEADER ,    messageType )  ;", "}", "}", "METHOD_END"], "methodName": ["setMessageTypeIfNotSet"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( SimpMessageHeaderAccessor . SESSION _ ATTRIBUTES ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["setSessionAttributes"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( SimpMessageHeaderAccessor . SESSION _ ID _ HEADER ,    sessionId )  ;", "}", "METHOD_END"], "methodName": ["setSessionId"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( SimpMessageHeaderAccessor . SUBSCRIPTION _ ID _ HEADER ,    subscriptionId )  ;", "}", "METHOD_END"], "methodName": ["setSubscriptionId"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( SimpMessageHeaderAccessor . USER _ HEADER ,    principal )  ;", "}", "METHOD_END"], "methodName": ["setUser"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpMessageHeaderAccessor ( message )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create (  )  ;", "accessor . setDestination (  \"  / destination \"  )  ;", "accessor . setSubscriptionId (  \" subscription \"  )  ;", "accessor . setSessionId (  \" session \"  )  ;", "accessor . setUser ( new   TestPrincipal (  \" user \"  )  )  ;", "accessor . setSessionAttributes ( Collections .  < String ,    Object > singletonMap (  \" key \"  ,     \" value \"  )  )  ;", "accessor . setNativeHeader (  \" nativeKey \"  ,     \" nativeValue \"  )  ;", "assertEquals (  (  \" MESSAGE   destination =  / destination   subscriptionId = subscription    \"     +     (  \" session = session   user = user   attributes =  { key = value }    nativeHeaders =  \"     +     \"  { nativeKey =  [ nativeValue ]  }    payload = p \"  )  )  ,    accessor . getDetailedLogMessage (  \" p \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getDetailedLogMessageWithValuesSet"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create (  )  ;", "accessor . setDestination (  \"  / destination \"  )  ;", "accessor . setSubscriptionId (  \" subscription \"  )  ;", "accessor . setSessionId (  \" session \"  )  ;", "accessor . setUser ( new   TestPrincipal (  \" user \"  )  )  ;", "accessor . setSessionAttributes ( Collections .  < String ,    Object > singletonMap (  \" key \"  ,     \" value \"  )  )  ;", "assertEquals (  (  \" MESSAGE   destination =  / destination   subscriptionId = subscription    \"     +     \" session = session   user = user   attributes [  1  ]    payload = p \"  )  ,    accessor . getShortLogMessage (  \" p \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getLogMessageWithValuesSet"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" MESSAGE   session = null   payload = p \"  ,    SimpMessageHeaderAccessor . create (  )  . getShortLogMessage (  \" p \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getShortLogMessage"], "fileName": "org.springframework.messaging.simp.SimpMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationConditions ;", "}", "METHOD_END"], "methodName": ["getDestinationConditions"], "fileName": "org.springframework.messaging.simp.SimpMessageMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . messageTypeMessageCondition ;", "}", "METHOD_END"], "methodName": ["getMessageTypeMessageCondition"], "fileName": "org.springframework.messaging.simp.SimpMessageMappingInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . messageType ;", "}", "METHOD_END"], "methodName": ["getMessageType"], "fileName": "org.springframework.messaging.simp.SimpMessageTypeMessageCondition"}, {"methodBody": ["METHOD_START", "{", "SimpMessageType   messageType    =    SimpMessageType . MESSAGE ;", "SimpMessageType   subscribeType    =    SimpMessageType . SUBSCRIBE ;", "SimpMessageType   actual    =    condition ( messageType )  . combine ( condition ( subscribeType )  )  . getMessageType (  )  ;", "assertEquals ( subscribeType ,    actual )  ;", "actual    =    condition ( messageType )  . combine ( condition ( messageType )  )  . getMessageType (  )  ;", "assertEquals ( messageType ,    actual )  ;", "actual    =    condition ( subscribeType )  . combine ( condition ( subscribeType )  )  . getMessageType (  )  ;", "assertEquals ( subscribeType ,    actual )  ;", "}", "METHOD_END"], "methodName": ["combine"], "fileName": "org.springframework.messaging.simp.SimpMessageTypeMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    message ( null )  ;", "assertEquals (  0  ,    condition (  . MESSAGE )  . compareTo ( condition (  . MESSAGE )  ,    message )  )  ;", "assertEquals (  0  ,    condition (  . MESSAGE )  . compareTo ( condition (  . SUBSCRIBE )  ,    message )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.springframework.messaging.simp.SimpMessageTypeMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpMessageTypeMessageCondition ( messageType )  ;", "}", "METHOD_END"], "methodName": ["condition"], "fileName": "org.springframework.messaging.simp.SimpMessageTypeMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    message ( SimpMessageType . MESSAGE )  ;", "condition    =    condition ( SimpMessageType . MESSAGE )  ;", "actual    =    condition . getMatchingCondition ( message )  ;", "assertNotNull ( actual )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    actual . getMessageType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMatchingCondition"], "fileName": "org.springframework.messaging.simp.SimpMessageTypeMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    message ( null )  ;", "condition    =    condition ( SimpMessageType . MESSAGE )  ;", "assertNull ( condition . getMatchingCondition ( message )  )  ;", "}", "METHOD_END"], "methodName": ["getMatchingConditionNoMessageType"], "fileName": "org.springframework.messaging.simp.SimpMessageTypeMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "MessageBuilder < byte [  ]  >    builder    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  ;", "if    ( messageType    !  =    null )     {", "builder . setHeader ( HeaderAccessor . MESSAGE _ TYPE _ HEADER ,    messageType )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["message"], "fileName": "org.springframework.messaging.simp.SimpMessageTypeMessageConditionTests"}, {"methodBody": ["METHOD_START", "{", "return   this . headerInitializer ;", "}", "METHOD_END"], "methodName": ["getHeaderInitializer"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . messageChannel ;", "}", "METHOD_END"], "methodName": ["getMessageChannel"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . sendTimeout ;", "}", "METHOD_END"], "methodName": ["getSendTimeout"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationPrefix ;", "}", "METHOD_END"], "methodName": ["getUserDestinationPrefix"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getHeaderInitializer (  )  )     !  =    null )     {", "getHeaderInitializer (  )  . initHeaders ( Accessor )  ;", "}", "}", "METHOD_END"], "methodName": ["initHeaders"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "String   destination    =    SimpMessageHeaderAccessor . getDestination ( message . getHeaders (  )  )  ;", "Assert . notNull ( destination ,     \" Destination   header   required \"  )  ;", "long   timeout    =    this . sendTimeout ;", "boolean   sent    =     ( timeout    >  =     0  )     ?    this . messageChannel . send ( message ,    timeout )     :    this . messageChannel . send ( message )  ;", "if    (  ! sent )     {", "throw   new   MessageDeliveryException ( message ,     (  (  (  \" Failed   to   send   message   to   destination    '  \"     +    destination )     +     \"  '    within   timeout :     \"  )     +    timeout )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sendInternal"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . headerInitializer    =    headerInitializer ;", "}", "METHOD_END"], "methodName": ["setHeaderInitializer"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . sendTimeout    =    sendTimeout ;", "}", "METHOD_END"], "methodName": ["setSendTimeout"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( prefix ,     \" User   destination   prefix   must   not   be   empty \"  )  ;", "this . destinationPrefix    =     ( prefix . endsWith (  \"  /  \"  )  )     ?    prefix    :    prefix    +     \"  /  \"  ;", "}", "METHOD_END"], "methodName": ["setUserDestinationPrefix"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplate"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . convertAndSendToUser (  \" joe \"  ,     \"  / queue / foo \"  ,     \" data \"  )  ;", "List < Message < byte [  ]  >  >    messages    =    this . messageChannel . getMessages (  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "Message < byte [  ]  >    message    =    messages . get (  0  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    MessageHeaderAccessor . getAccessor ( message ,    SimpMessageHeaderAccessor . class )  ;", "assertNotNull ( headerAccessor )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    headerAccessor . getMessageType (  )  )  ;", "assertEquals (  \"  / user / joe / queue / foo \"  ,    headerAccessor . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendToUser"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . convertAndSendToUser (  \" http :  /  / joe . openid . example . org /  \"  ,     \"  / queue / foo \"  ,     \" data \"  )  ;", "List < Message < byte [  ]  >  >    messages    =    this . messageChannel . getMessages (  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    MessageHeaderAccessor . getAccessor ( messages . get (  0  )  ,    SimpMessageHeaderAccessor . class )  ;", "assertNotNull ( headerAccessor )  ;", "assertEquals (  \"  / user / http :  %  2 F %  2 Fjoe . openid . example . org %  2 F / queue / foo \"  ,    headerAccessor . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendToUserWithEncoding"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messagingTemplate . setUserDestinationPrefix (  \"  / prefix \"  )  ;", "this . messagingTemplate . convertAndSendToUser (  \" joe \"  ,     \"  / queue / foo \"  ,     \" data \"  )  ;", "List < Message < byte [  ]  >  >    messages    =    this . messageChannel . getMessages (  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "Message < byte [  ]  >    message    =    messages . get (  0  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    MessageHeaderAccessor . getAccessor ( message ,    SimpMessageHeaderAccessor . class )  ;", "assertNotNull ( headerAccessor )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    headerAccessor . getMessageType (  )  )  ;", "assertEquals (  \"  / prefix / joe / queue / foo \"  ,    headerAccessor . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendWithCustomDestinationPrefix"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    headers    =    Collections .  < String ,    Object > singletonMap (  \" key \"  ,     \" value \"  )  ;", "this . m . convertAndSend (  \"  / foo \"  ,     \" data \"  ,    headers )  ;", "List < Message < byte [  ]  >  >    messages    =    this . messageChannel . getMessages (  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    MessageHeaderAccessor . getAccessor ( messages . get (  0  )  ,    SimpMessageHeaderAccessor . class )  ;", "assertNotNull ( headerAccessor )  ;", "assertNull ( headerAccessor . toMap (  )  . get (  \" key \"  )  )  ;", "assertEquals ( Arrays . asList (  \" value \"  )  ,    headerAccessor . getNativeHeader (  \" key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendWithCustomHeader"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    headers    =    new   HashMap <  >  (  )  ;", "headers . put (  \" key \"  ,     \" value \"  )  ;", "headers . put ( NativeMessageHeaderAccessor . NATIVE _ HEADERS ,    new   util . LinkedMultiValueMap < String ,    String >  (  )  )  ;", "this . messagingTemplate . convertAndSend (  \"  / foo \"  ,     \" data \"  ,    headers )  ;", "List < Message < byte [  ]  >  >    messages    =    this . messageChannel . getMessages (  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    MessageHeaderAccessor . getAccessor ( messages . get (  0  )  ,    SimpMessageHeaderAccessor . class )  ;", "assertNotNull ( headerAccessor )  ;", "assertEquals (  \" value \"  ,    headerAccessor . toMap (  )  . get (  \" key \"  )  )  ;", "assertNull ( headerAccessor . getNativeHeader (  \" key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendWithCustomHeaderNonNative"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create (  )  ;", "accessor . setHeader (  \" key \"  ,     \" value \"  )  ;", "accessor . setNativeHeader (  \" fooNative \"  ,     \" barNative \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "this . m . convertAndSend (  \"  / foo \"  ,     \" data \"  ,    headers )  ;", "List < Message < byte [  ]  >  >    messages    =    this . messageChannel . getMessages (  )  ;", "Message < byte [  ]  >    message    =    messages . get (  0  )  ;", "assertSame ( headers ,    message . getHeaders (  )  )  ;", "assertFalse ( accessor . isMutable (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertAndSendWithMutableSimpMessageHeaders"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create (  )  ;", "accessor . setHeader (  \" key \"  ,     \" value \"  )  ;", "accessor . setNativeHeader (  \" fooNative \"  ,     \" barNative \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \" payload \"  ,    headers )  ;", "this . m . doSend (  \"  / topic / foo \"  ,    message )  ;", "List < Message < byte [  ]  >  >    messages    =    this . messageChannel . getMessages (  )  ;", "Message < byte [  ]  >    sentMessage    =    messages . get (  0  )  ;", "assertSame ( message ,    sentMessage )  ;", "assertFalse ( accessor . isMutable (  )  )  ;", "}", "METHOD_END"], "methodName": ["doSendWithMutableHeaders"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . SUBSCRIBE )  ;", "accessor . setDestination (  \"  / user / queue / foo \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    accessor . getMessageHeaders (  )  )  ;", "this . m . doSend (  \"  / queue / foo - user 1  2  3  \"  ,    message )  ;", "List < Message < byte [  ]  >  >    messages    =    this . messageChannel . getMessages (  )  ;", "Message < byte [  ]  >    sentMessage    =    messages . get (  0  )  ;", "MessageHeaderAccessor   sentAccessor    =    MessageHeaderAccessor . getAccessor ( sentMessage ,    MessageHeaderAccessor . class )  ;", "assertEquals ( StompHeaderAccessor . class ,    sentAccessor . getClass (  )  )  ;", "assertEquals (  \"  / queue / foo - user 1  2  3  \"  ,     (  ( StompHeaderAccessor )     ( sentAccessor )  )  . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["doSendWithStompHeaders"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    this . messagingTemplate . processHeadersToSend ( null )  ;", "assertNotNull ( map )  ;", "assertTrue (  (  \" Actual :     \"     +     ( map . getClass (  )  . toString (  )  )  )  ,    MessageHeaders . class . isAssignableFrom ( map . getClass (  )  )  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    MessageHeaderAccessor . getAccessor (  (  ( MessageHeaders )     ( map )  )  ,    SimpMessageHeaderAccessor . class )  ;", "assertTrue ( headerAccessor . isMutable (  )  )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    headerAccessor . getMessageType (  )  )  ;", "}", "METHOD_END"], "methodName": ["processHeadersToSend"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . messageChannel    =    new   StubMessageChannel (  )  ;", "this . messagingTemplate    =    new    ( this . messageChannel )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.SimpMessagingTemplateTests"}, {"methodBody": ["METHOD_START", "{", "this . simpAttributes . setAttribute (  \" name \"  ,     \" value \"  )  ;", "Object   actual    =    this . scope . get (  \" name \"  ,    this . objectFactory )  ;", "assertThat ( actual ,    is (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.messaging.simp.SimpSessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . scope . getConversationId (  )  ,    is (  \" session 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionId"], "fileName": "org.springframework.messaging.simp.SimpSessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . objectFactory . getObject (  )  )  . willReturn (  \" value \"  )  ;", "Object   actual    =    this . scope . get (  \" name \"  ,    this . objectFactory )  ;", "assertThat ( actual ,    is (  \" value \"  )  )  ;", "assertThat ( thisAttributes . getAttribute (  \" name \"  )  ,    is (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getWithObjectFactory"], "fileName": "org.springframework.messaging.simp.SimpSessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   runnable    =    Mockito . mock ( Runnable . class )  ;", "this . scope . registerDestructionCallback (  \" name \"  ,    runnable )  ;", "this . simpAttributes . sCompleted (  )  ;", "verify ( runnable ,    times (  1  )  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["registerDestructionCallback"], "fileName": "org.springframework.messaging.simp.SimpSessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "this . simpAttributes . setAttribute (  \" name \"  ,     \" value \"  )  ;", "Object   removed    =    this . scope . remove (  \" name \"  )  ;", "assertThat ( removed ,    is (  \" value \"  )  )  ;", "assertThat ( this . simpAttributes . getAttribute (  \" name \"  )  ,    nullValue (  )  )  ;", "removed    =    this . scope . remove (  \" name \"  )  ;", "assertThat ( removed ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.springframework.messaging.simp.SimpSessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "this . scope    =    new   SimpSessionScope (  )  ;", "this . objectFactory    =    Mockito . mock ( ObjectFactory . class )  ;", "this . simpAttributes    =    new   SimpAttributes (  \" session 1  \"  ,    new   ConcurrentHashMap <  >  (  )  )  ;", "SimpAttributesContextHolder . setAttributes ( this . simpAttributes )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.messaging.simp.SimpSessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "SimpAttributesContextHolder . resetAttributes (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.messaging.simp.SimpSessionScopeTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   headerAccessor    =    SimpMessageHeaderAccessor . create ( SimpMessageType . MESSAGE )  ;", "if    (  ( getHeaderInitializer (  )  )     !  =    null )     {", "getHeaderInitializer (  )  . initHeaders ( headerAccessor )  ;", "}", "if    ( sessionId    !  =    null )     {", "headerAccessor . setSessionId ( sessionId )  ;", "}", "headerAccessor . setHeader ( SimpMTemplate . CONVERSION _ HINT _ HEADER ,    returnType )  ;", "headerAccessor . setLeaveMutable ( true )  ;", "return   headerAccessor . getMessageHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["createHeaders"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "Annotation [  ]    anns    =    new   Annotation [  4  ]  ;", "anns [  0  ]     =    AnnotatedElementUtils . findMergedAnnotation ( returnType . getExecutable (  )  ,    SendToUser . class )  ;", "anns [  1  ]     =    AnnotatedElementUtils . findMergedAnnotation ( returnType . getExecutable (  )  ,    SendTo . class )  ;", "anns [  2  ]     =    AnnotatedElementUtils . findMergedAnnotation ( returnType . getDeclaringClass (  )  ,    SendToUser . class )  ;", "anns [  3  ]     =    AnnotatedElementUtils . findMergedAnnotation ( returnType . getDeclaringClass (  )  ,    SendTo . class )  ;", "if    (  (  ( anns [  0  ]  )     !  =    null )     &  &     (  !  ( ObjectUtils . isEmpty (  (  ( SendToUser )     ( anns [  0  ]  )  )  . value (  )  )  )  )  )     {", "return   anns [  0  ]  ;", "}", "if    (  (  ( anns [  1  ]  )     !  =    null )     &  &     (  !  ( ObjectUtils . isEmpty (  (  ( SendTo )     ( anns [  1  ]  )  )  . value (  )  )  )  )  )     {", "return   anns [  1  ]  ;", "}", "if    (  (  ( anns [  2  ]  )     !  =    null )     &  &     (  !  ( ObjectUtils . isEmpty (  (  ( SendToUser )     ( anns [  2  ]  )  )  . value (  )  )  )  )  )     {", "return   anns [  2  ]  ;", "}", "if    (  (  ( anns [  3  ]  )     !  =    null )     &  &     (  !  ( ObjectUtils . isEmpty (  (  ( SendTo )     ( anns [  3  ]  )  )  . value (  )  )  )  )  )     {", "return   anns [  3  ]  ;", "}", "for    ( int   i    =     0  ;    i    <     4  ;    i +  +  )     {", "if    (  ( anns [ i ]  )     !  =    null )     {", "return   anns [ i ]  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findAnnotation"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultDestinationPrefix ;", "}", "METHOD_END"], "methodName": ["getDefaultDestinationPrefix"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultUserDestinationPrefix ;", "}", "METHOD_END"], "methodName": ["getDefaultUserDestinationPrefix"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . headerInitializer ;", "}", "METHOD_END"], "methodName": ["getHeaderInitializer"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( annotation    !  =    null )     {", "String [  ]    value    =     (  ( String [  ]  )     ( AnnotationUtils . getValue ( annotation )  )  )  ;", "if    (  !  ( ObjectUtils . isEmpty ( value )  )  )     {", "return   value ;", "}", "}", "String   name    =    DestinationPatternsMessageCondition . LOOKUP _ DESTINATION _ HEADER ;", "String   destination    =     (  ( String )     ( message . getHeaders (  )  . get ( name )  )  )  ;", "if    (  !  ( StringUtils . hasText ( destination )  )  )     {", "throw   new   IllegalStateException (  (  \" No   lookup   destination   header   in    \"     +    message )  )  ;", "}", "return   destination . startsWith (  \"  /  \"  )     ?    new   String [  ]  {    defaultPrefix    +    destination    }     :    new   String [  ]  {     ( defaultPrefix    +     '  /  '  )     +    destination    }  ;", "}", "METHOD_END"], "methodName": ["getTargetDestinations"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "Principal   principal    =    SimpMessageHeaderAccessor . getUser ( headers )  ;", "if    ( principal    !  =    null )     {", "return   principal   instanceof   DestinationUserNameProvider    ?     (  ( DestinationUserNameProvider )     ( principal )  )  . getDestinationUserName (  )     :    principal . getName (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getUserName"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "String   name    =    DestinationVariableMethodArgumentResolver . DESTINATION _ TEMPLATE _ VARIABLES _ HEADER ;", "Map < String ,    String >    vars    =     (  ( Map < String ,    String >  )     ( headers . get ( name )  )  )  ;", "return   new    . DestinationVariablePlaceholderResolver ( vars )  ;", "}", "METHOD_END"], "methodName": ["initVarResolver"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "this . defaultDestinationPrefix    =    defaultDestinationPrefix ;", "}", "METHOD_END"], "methodName": ["setDefaultDestinationPrefix"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "this . defaultUserDestinationPrefix    =    prefix ;", "}", "METHOD_END"], "methodName": ["setDefaultUserDestinationPrefix"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "this . headerInitializer    =    headerInitializer ;", "}", "METHOD_END"], "methodName": ["setHeaderInitializer"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    getCapturedAccessor ( index )  ;", "assertEquals ( sessionId ,    accessor . getSessionId (  )  )  ;", "assertEquals ( destination ,    accessor . getDestination (  )  )  ;", "assertEquals (  . MIME _ TYPE ,    accessor . getContentType (  )  )  ;", "assertNull (  \" Subscription   id   should   not   be   copied \"  ,    accessor . getSubscriptionId (  )  )  ;", "assertEquals ( methodParameter ,    accessor . getHeader ( SimpMessagingTemplate . CONVERSION _ HINT _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["assertResponse"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   headerAccessor    =    SimpMessageHeaderAccessor . create (  )  ;", "headerAccessor . setSessionId ( sessId )  ;", "headerAccessor . setSubscriptionId ( subsId )  ;", "if    (  ( dest    !  =    null )     &  &     ( destPrefix    !  =    null )  )     {", "headerAccessor . setDestination (  ( destPrefix    +    dest )  )  ;", "headerAccessor . setHeader ( DestinationPatternsMessageCondition . LOOKUP _ DESTINATION _ HEADER ,    dest )  ;", "}", "if    ( user    !  =    null )     {", "headerAccessor . setUser ( user )  ;", "}", "return   MessageBuilder . createMessage ( new   byte [  0  ]  ,    headerAccessor . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    this . messageCaptor . getAllValues (  )  . get ( index )  ;", "return   MessageHeaderAccessor . getAccessor ( message ,    SimpMessageHeaderAccessor . class )  ;", "}", "METHOD_END"], "methodName": ["getCapturedAccessor"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SendToMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["handleAndSendTo"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SendToMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["handleAndSendToDefaultDestination"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SendToMethodReturnValueHandlerTests . JacksonViewBean   payload    =    new   SendToMethodReturnValueHandlerTests . JacksonViewBean (  )  ;", "payload . setWithView 1  (  \" with \"  )  ;", "payload . setWithView 2  (  \" with \"  )  ;", "payload . setWithoutView (  \" without \"  )  ;", "return   payload ;", "}", "METHOD_END"], "methodName": ["handleAndSendToJsonView"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SendToMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["handleAndSendToUser"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SendToMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["handleAndSendToUserDefaultDestination"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SendToMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["handleAndSendToUserDefaultDestinationSingleSession"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SendToMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["handleAndSendToUserSingleSession"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SendToMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["handleAndSendToWithPlaceholders"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SendToMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["handleNoAnnotations"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,     \"  / app \"  ,     \"  / dest \"  ,    null )  ;", "this . jsonHandler . handle ( handleAndSendToJsonView (  )  ,    this . jsonViewReturnType ,    inputMessage )  ;", "verify ( this . messageChannel )  . send ( this . messageCaptor . capture (  )  )  ;", "Message <  ?  >    message    =    this . messageCaptor . getValue (  )  ;", "assertNotNull ( message )  ;", "String   bytes    =    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  ,    StandardCharsets . UTF _  8  )  ;", "assertEquals (  \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  }  \"  ,    bytes )  ;", "}", "METHOD_END"], "methodName": ["jsonView"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( this . sendToReturnType ,    sessionId ,     0  ,     \"  / dest 1  \"  )  ;", "assertResponse ( this . sendToReturnType ,    sessionId ,     1  ,     \"  / dest 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["sendTo"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . defaultEmptyAnnotation ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( this . defaultEmptyAnnotation ,    sessionId ,     0  ,     \"  / dest - default \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToClassDefaultEmptyAnnotation"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . defaultNoAnnotation ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( this . defaultNoAnnotation ,    sessionId ,     0  ,     \"  / dest - default \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToClassDefaultNoAnnotation"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . defaultOverrideAnnotation ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( this . defaultOverrideAnnotation ,    sessionId ,     0  ,     \"  / dest 3  \"  )  ;", "assertResponse ( this . defaultOverrideAnnotation ,    sessionId ,     1  ,     \"  / dest 4  \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToClassDefaultOverride"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,     \"  / app \"  ,     \"  / dest \"  ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToDefaultDestReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( this . sendToDefaultDestReturnType ,    sessionId ,     0  ,     \"  / topic / dest \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToDefaultDestination"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "Message <  ?  >    inputMessage    =    createMessage (  \" sess 1  \"  ,     \" sub 1  \"  ,     \"  / app /  \"  ,     \" dest . foo . bar \"  ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToDefaultDestReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "SimpMessageHeaderAccessor   accessor    =    getCapturedAccessor (  0  )  ;", "assertEquals (  \"  / topic / dest . foo . bar \"  ,    accessor . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendToDefaultDestinationWhenUsingDotPathSeparator"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,     \"  / app \"  ,     \"  / dest \"  ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . noAnnotationsReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( this . noAnnotationsReturnType ,    sessionId ,     0  ,     \"  / topic / dest \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToNoAnnotations"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", ". TestUser   user    =    new    . TestUser (  )  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    user )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToUserReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "SimpMessageHeaderAccessor   accessor    =    getCapturedAccessor (  0  )  ;", "assertNull ( accessor . getSessionId (  )  )  ;", "assertNull ( accessor . getSubscriptionId (  )  )  ;", "assertEquals (  (  (  \"  / user /  \"     +     ( user . getName (  )  )  )     +     \"  / dest 1  \"  )  ,    accessor . getDestination (  )  )  ;", "accessor    =    getCapturedAccessor (  1  )  ;", "assertNull ( accessor . getSessionId (  )  )  ;", "assertNull ( accessor . getSubscriptionId (  )  )  ;", "assertEquals (  (  (  \"  / user /  \"     +     ( user . getName (  )  )  )     +     \"  / dest 2  \"  )  ,    accessor . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendToUser"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . userDefaultEmptyAnnotation ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( this . userDefaultEmptyAnnotation ,    sessionId ,     0  ,     \"  / user / sess 1  / dest - default \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserClassDefaultEmptyAnnotation"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . userDefaultNoAnnotation ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( this . userDefaultNoAnnotation ,    sessionId ,     0  ,     \"  / user / sess 1  / dest - default \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserClassDefaultNoAnnotation"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . userDefaultOverrideAnnotation ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( this . userDefaultOverrideAnnotation ,    sessionId ,     0  ,     \"  / user / sess 1  / dest 3  \"  )  ;", "assertResponse ( this . userDefaultOverrideAnnotation ,    sessionId ,     1  ,     \"  / user / sess 1  / dest 4  \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserClassDefaultOverride"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", ". TestUser   user    =    new    . TestUser (  )  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,     \"  / app \"  ,     \"  / dest \"  ,    user )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToUserDefaultDestReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "SimpMessageHeaderAccessor   accessor    =    getCapturedAccessor (  0  )  ;", "assertNull ( accessor . getSessionId (  )  )  ;", "assertNull ( accessor . getSubscriptionId (  )  )  ;", "assertEquals (  (  (  \"  / user /  \"     +     ( user . getName (  )  )  )     +     \"  / queue / dest \"  )  ,    accessor . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserDefaultDestination"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", ". TestUser   user    =    new    . TestUser (  )  ;", "Message <  ?  >    message    =    createMessage ( sessionId ,     \" sub 1  \"  ,     \"  / app \"  ,     \"  / dest \"  ,    user )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToUserSingleSessionDefaultDestReturnType ,    message )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "SimpMessageHeaderAccessor   accessor    =    getCapturedAccessor (  0  )  ;", "assertEquals ( sessionId ,    accessor . getSessionId (  )  )  ;", "assertEquals (  (  (  \"  / user /  \"     +     ( user . getName (  )  )  )     +     \"  / queue / dest \"  )  ,    accessor . getDestination (  )  )  ;", "assertEquals (  . MIME _ TYPE ,    accessor . getContentType (  )  )  ;", "assertNull (  \" Subscription   id   should   not   be   copied \"  ,    accessor . getSubscriptionId (  )  )  ;", "assertEquals ( this . sendToUserSingleSessionDefaultDestReturnType ,    accessor . getHeader ( SimpMessagingTemplate . CONVERSION _ HINT _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserDefaultDestinationSingleSession"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", ". TestUser   user    =    new    . TestUser (  )  ;", "Message <  ?  >    inputMessage    =    createMessage (  \" sess 1  \"  ,     \" sub 1  \"  ,     \"  / app /  \"  ,     \" dest . foo . bar \"  ,    user )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToUserDefaultDestReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "SimpMessageHeaderAccessor   accessor    =    getCapturedAccessor (  0  )  ;", "assertEquals (  (  (  \"  / user /  \"     +     ( user . getName (  )  )  )     +     \"  / queue / dest . foo . bar \"  )  ,    accessor . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserDefaultDestinationWhenUsingDotPathSeparator"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToUserReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "SimpMessageHeaderAccessor   accessor    =    getCapturedAccessor (  0  )  ;", "assertEquals (  \"  / user / sess 1  / dest 1  \"  ,    accessor . getDestination (  )  )  ;", "assertEquals (  \" sess 1  \"  ,    accessor . getSessionId (  )  )  ;", "accessor    =    getCapturedAccessor (  1  )  ;", "assertEquals (  \"  / user / sess 1  / dest 2  \"  ,    accessor . getDestination (  )  )  ;", "assertEquals (  \" sess 1  \"  ,    accessor . getSessionId (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserSessionWithoutUserName"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", ". TestUser   user    =    new    . TestUser (  )  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    user )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToUserSingleSessionReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "SimpMessageHeaderAccessor   accessor    =    getCapturedAccessor (  0  )  ;", "assertEquals ( sessionId ,    accessor . getSessionId (  )  )  ;", "assertEquals (  . MIME _ TYPE ,    accessor . getContentType (  )  )  ;", "assertEquals (  (  (  \"  / user /  \"     +     ( user . getName (  )  )  )     +     \"  / dest 1  \"  )  ,    accessor . getDestination (  )  )  ;", "assertNull (  \" Subscription   id   should   not   be   copied \"  ,    accessor . getSubscriptionId (  )  )  ;", "assertEquals ( this . sendToUserSingleSessionReturnType ,    accessor . getHeader ( SimpMessagingTemplate . CONVERSION _ HINT _ HEADER )  )  ;", "accessor    =    getCapturedAccessor (  1  )  ;", "assertEquals ( sessionId ,    accessor . getSessionId (  )  )  ;", "assertEquals (  (  (  \"  / user /  \"     +     ( user . getName (  )  )  )     +     \"  / dest 2  \"  )  ,    accessor . getDestination (  )  )  ;", "assertEquals (  . MIME _ TYPE ,    accessor . getContentType (  )  )  ;", "assertNull (  \" Subscription   id   should   not   be   copied \"  ,    accessor . getSubscriptionId (  )  )  ;", "assertEquals ( this . sendToUserSingleSessionReturnType ,    accessor . getHeader ( SimpMessagingTemplate . CONVERSION _ HINT _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserSingleSession"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "Class <  ?  >    clazz    =     . SendToUserWithSendToOverrideTestBean . class ;", "Method   method    =    clazz . getDeclaredMethod (  \" handleAndSendToDefaultDestination \"  )  ;", "MethodParameter   parameter    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    parameter ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( parameter ,    sessionId ,     0  ,     \"  / user / sess 1  / dest - default \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserWithSendToDefaultOverride"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "Class <  ?  >    clazz    =     . SendToUserWithSendToOverrideTestBean . class ;", "Method   method    =    clazz . getDeclaredMethod (  \" handleAndSendToOverride \"  )  ;", "MethodParameter   parameter    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "String   sessionId    =     \" sess 1  \"  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    parameter ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertResponse ( parameter ,    sessionId ,     0  ,     \"  / dest 3  \"  )  ;", "assertResponse ( parameter ,    sessionId ,     1  ,     \"  / dest 4  \"  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserWithSendToOverride"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", ". TestUser   user    =    new    . UniqueUser (  )  ;", "Message <  ?  >    inputMessage    =    createMessage ( sessionId ,     \" sub 1  \"  ,    null ,    null ,    user )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToUserReturnType ,    inputMessage )  ;", "verify ( this . messageChannel ,    times (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "SimpMessageHeaderAccessor   accessor    =    getCapturedAccessor (  0  )  ;", "assertEquals (  \"  / user / Me   myself   and   I / dest 1  \"  ,    accessor . getDestination (  )  )  ;", "accessor    =    getCapturedAccessor (  1  )  ;", "assertEquals (  \"  / user / Me   myself   and   I / dest 2  \"  ,    accessor . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendToUserWithUserNameProvider"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "Map < String ,    String >    vars    =    new   LinkedHashMap <  >  (  1  )  ;", "vars . put (  \" roomName \"  ,     \" roomA \"  )  ;", "String   sessionId    =     \" sess 1  \"  ;", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create (  )  ;", "accessor . setSessionId ( sessionId )  ;", "accessor . setSubscriptionId (  \" sub 1  \"  )  ;", "accessor . setHeader ( DestinationVariableMethodArgumentResolver . DESTINATION _ TEMPLATE _ VARIABLES _ HEADER ,    vars )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  . PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . sendToWithPlaceholdersReturnType ,    message )  ;", "verify ( this . messageChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "SimpMessageHeaderAccessor   actual    =    getCapturedAccessor (  0  )  ;", "assertEquals ( sessionId ,    actual . getSessionId (  )  )  ;", "assertEquals (  \"  / topic / chat . message . filtered . roomA \"  ,    actual . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendToWithDestinationPlaceholders"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "SimpMessagingTemplate   messagingTemplate    =    new   SimpMessagingTemplate ( this . messageChannel )  ;", "messagingTemplate . setMessageConverter ( new   StringMessageConverter (  )  )  ;", "this . handler    =    new   SendToMethodReturnValueHandler ( messagingTemplate ,    true )  ;", "this . handlerAnnotationNotRequired    =    new   SendToMethodReturnValueHandler ( messagingTemplate ,    false )  ;", "SimpMessagingTemplate   jsonMessagingTemplate    =    new   SimpMessagingTemplate ( this . messageChannel )  ;", "jsonMessagingTemplate . setMessageConverter ( new   MappingJackson 2 MessageConverter (  )  )  ;", "this . jsonHandler    =    new   SendToMethodReturnValueHandler ( jsonMessagingTemplate ,    true )  ;", "Method   method    =    getClass (  )  . getDeclaredMethod (  \" handleNoAnnotations \"  )  ;", "this . noAnnotationsReturnType    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" handleAndSendToDefaultDestination \"  )  ;", "this . sendToDefaultDestReturnType    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" handleAndSendTo \"  )  ;", "this . sendToReturnType    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" handleAndSendToWithPlaceholders \"  )  ;", "this . sendToWithPlaceholdersReturnType    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" handleAndSendToUser \"  )  ;", "this . sendToUserReturnType    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" handleAndSendToUserSingleSession \"  )  ;", "this . sendToUserSingleSessionReturnType    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" handleAndSendToUserDefaultDestination \"  )  ;", "this . sendToUserDefaultDestReturnType    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" handleAndSendToUserDefaultDestinationSingleSession \"  )  ;", "this . sendToUserSingleSessionDefaultDestReturnType    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =    getClass (  )  . getDeclaredMethod (  \" handleAndSendToJsonView \"  )  ;", "this . jsonViewReturnType    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =     . SendToTestBean . class . getDeclaredMethod (  \" handleNoAnnotation \"  )  ;", "this . defaultNoAnnotation    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =     . SendToTestBean . class . getDeclaredMethod (  \" handleAndSendToDefaultDestination \"  )  ;", "this . defaultEmptyAnnotation    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =     . SendToTestBean . class . getDeclaredMethod (  \" handleAndSendToOverride \"  )  ;", "this . defaultOverrideAnnotation    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =     . SendToUserTestBean . class . getDeclaredMethod (  \" handleNoAnnotation \"  )  ;", "this . userDefaultNoAnnotation    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =     . SendToUserTestBean . class . getDeclaredMethod (  \" handleAndSendToDefaultDestination \"  )  ;", "this . userDefaultEmptyAnnotation    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "method    =     . SendToUserTestBean . class . getDeclaredMethod (  \" handleAndSendToOverride \"  )  ;", "this . userDefaultOverrideAnnotation    =    new   SynthesizingMethodParameter ( method ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . handler . supportsReturnType ( this . sendToReturnType )  )  ;", "assertTrue ( this . handler . supportsReturnType ( this . sendToUserReturnType )  )  ;", "assertFalse ( this . handler . supportsReturnType ( this . noAsReturnType )  )  ;", "assertTrue ( this . handlerANotRequired . supportsReturnType ( this . noAsReturnType )  )  ;", "assertTrue ( this . handler . supportsReturnType ( this . defaultNoA )  )  ;", "assertTrue ( this . handler . supportsReturnType ( this . defaultEmptyA )  )  ;", "assertTrue ( this . handler . supportsReturnType ( this . defaultOverrideA )  )  ;", "assertTrue ( this . handler . supportsReturnType ( this . userDefaultNoA )  )  ;", "assertTrue ( this . handler . supportsReturnType ( this . userDefaultEmptyA )  )  ;", "assertTrue ( this . handler . supportsReturnType ( this . userDefaultOverrideA )  )  ;", "}", "METHOD_END"], "methodName": ["supportsReturnType"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    createMessage (  \" sess 1  \"  ,     \" sub 1  \"  ,     \"  / app \"  ,     \"  / dest \"  ,    null )  ;", "SimpMessageSendingOperations   messagingTemplate    =    Mockito . mock ( SimpMessageSendingOperations . class )  ;", "SendToMethodReturnValueHandler   handler    =    new   SendToMethodReturnValueHandler ( messagingTemplate ,    false )  ;", "handler . handleReturnValue (  . PAYLOAD ,    this . noAnnotationsReturnType ,    message )  ;", "ArgumentCaptor < MessageHeaders >    captor    =    ArgumentCaptor . forClass ( MessageHeaders . class )  ;", "verify ( messagingTemplate )  . convertAndSend ( eq (  \"  / topic / dest \"  )  ,    eq (  . PAYLOAD )  ,    captor . capture (  )  )  ;", "MessageHeaders   headers    =    captor . getValue (  )  ;", "SimpMessageHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( headers ,    SimpMessageHeaderAccessor . class )  ;", "assertNotNull ( accessor )  ;", "assertTrue ( accessor . isMutable (  )  )  ;", "assertEquals (  \" sess 1  \"  ,    accessor . getSessionId (  )  )  ;", "assertNull (  \" Subscription   id   should   not   be   copied \"  ,    accessor . getSubscriptionId (  )  )  ;", "assertEquals ( this . noAnnotationsReturnType ,    accessor . getHeader ( SimpMessagingTemplate . CONVERSION _ HINT _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["testHeadersToSend"], "fileName": "org.springframework.messaging.simp.annotation.support.SendToMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( prefixes )  )     {", "return   prefixes ;", "}", "Collection < String >    result    =    new   ArrayList <  >  ( prefixes . size (  )  )  ;", "for    ( String   prefix    :    prefixes )     {", "if    (  !  ( prefix . endsWith (  \"  /  \"  )  )  )     {", "prefix    =    prefix    +     \"  /  \"  ;", "}", "result . add ( prefix )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["appendSlashes"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "String [  ]    resolvedDestinations    =    resolveEmbeddedValuesInDestinations ( destinations )  ;", "return   new   SimpMappingInfo ( SimpTypeCondition . MESSAGE ,    new   DestinationPatternsCondition ( resolvedDestinations ,    this . pathMatcher )  )  ;", "}", "METHOD_END"], "methodName": ["createMessageMappingCondition"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "String [  ]    resolvedDestinations    =    resolveEmbeddedValuesInDestinations ( destinations )  ;", "return   new   SimpMappingInfo ( SimpTypeCondition . SUBSCRIBE ,    new   DestinationPatternsCondition ( resolvedDestinations ,    this . pathMatcher )  )  ;", "}", "METHOD_END"], "methodName": ["createSubscribeMappingCondition"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . conversionService ;", "}", "METHOD_END"], "methodName": ["getConversionService"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . headerInitializer ;", "}", "METHOD_END"], "methodName": ["getHeaderInitializer"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . messageConverter ;", "}", "METHOD_END"], "methodName": ["getMessageConverter"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . pathMatcher ;", "}", "METHOD_END"], "methodName": ["getPathMatcher"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . validator ;", "}", "METHOD_END"], "methodName": ["getValidator"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    getApplicationContext (  )  ;", "ConfigurableBeanFactory   beanFactory    =     ( context   instanceof   ConfigurableApplicationContext )     ?     (  ( ConfigurableApplicationContext )     ( context )  )  . getBeanFactory (  )     :    null ;", "List < MethodArgumentResolver >    resolvers    =    new   ArrayList <  >  (  )  ;", "resolvers . add ( new   HeaderMethodArgumentResolver ( this . conversionService ,    beanFactory )  )  ;", "resolvers . add ( new   HeadersMethodArgumentResolver (  )  )  ;", "resolvers . add ( new   DestinationVariableMethodArgumentResolver ( this . conversionService )  )  ;", "resolvers . add ( new   PrincipalMethodArgumentResolver (  )  )  ;", "resolvers . add ( new   MessageMethodArgumentResolver ( this . messageConverter )  )  ;", "resolvers . addAll ( getCustomArgumentResolvers (  )  )  ;", "resolvers . add ( new   PayloadArgumentResolver ( this . messageConverter ,    this . validator )  )  ;", "return   resolvers ;", "}", "METHOD_END"], "methodName": ["initArgumentResolvers"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . valueResolver )     =  =    null )     {", "return   destins ;", "}", "String [  ]    result    =    new   String [ destins . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( destins . length )  ;    i +  +  )     {", "result [ i ]     =    this . valueResolver . resolveStringValue ( destins [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["resolveEmbeddedValuesInDestinations"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . conversionService    =    conversionService ;", "}", "METHOD_END"], "methodName": ["setConversionService"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . headerInitializer    =    headerInitializer ;", "}", "METHOD_END"], "methodName": ["setHeaderInitializer"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . messageConverter    =    converter ;", "(  ( AbstractMessageSendingTemplate <  ?  >  )     ( this . clientMTemplate )  )  . setMessageConverter ( converter )  ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( pathMatcher ,     \" PathMatcher   must   not   be   null \"  )  ;", "this . pathMatcher    =    pathMatcher ;", "this . slashPathSeparator    =    this . pathMatcher . combine (  \" a \"  ,     \" a \"  )  . equals (  \" a / a \"  )  ;", "}", "METHOD_END"], "methodName": ["setPathMatcher"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . validator    =    validator ;", "}", "METHOD_END"], "methodName": ["setValidator"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler"}, {"methodBody": ["METHOD_START", "{", "Message   emptyMessage    =     (  ( Message )     ( MessageBuilder . withPayload ( new   byte [  0  ]  )  . build (  )  )  )  ;", "given ( this . channel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "given ( this . converter . toMessage ( any (  )  ,    any ( MessageHeaders . class )  )  )  . willReturn ( emptyMessage )  ;", ". CompletableFutureController   controller    =    new    . CompletableFutureController (  )  ;", "this . messageHandler . registerHandler ( controller )  ;", "this . messageHandler . setDestinationPrefixes ( Arrays . asList (  \"  / app 1  \"  ,     \"  / app 2  /  \"  )  )  ;", "Message <  ?  >    message    =    createMessage (  \"  / app 1  / completable - future \"  )  ;", "this . messageHandler . handleMessage ( message )  ;", "controller . future . completeExceptionally ( new   IllegalStateException (  )  )  ;", "assertTrue ( controller . exceptionCaught )  ;", "}", "METHOD_END"], "methodName": ["completableFutureFailure"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message   emptyMessage    =     (  ( Message )     ( MessageBuilder . withPayload ( new   byte [  0  ]  )  . build (  )  )  )  ;", "given ( this . channel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "given ( this . converter . toMessage ( any (  )  ,    any ( MessageHeaders . class )  )  )  . willReturn ( emptyMessage )  ;", ". CompletableFutureController   controller    =    new    . CompletableFutureController (  )  ;", "this . messageHandler . registerHandler ( controller )  ;", "this . messageHandler . setDestinationPrefixes ( Arrays . asList (  \"  / app 1  \"  ,     \"  / app 2  /  \"  )  )  ;", "Message <  ?  >    message    =    createMessage (  \"  / app 1  / completable - future \"  )  ;", "this . messageHandler . handleMessage ( message )  ;", "assertNotNull ( controller . future )  ;", "controller . future . complete (  \" foo \"  )  ;", "verify ( this . converter )  . toMessage ( this . payloadCaptor . capture (  )  ,    any ( MessageHeaders . class )  )  ;", "assertEquals (  \" foo \"  ,    this . payloadCaptor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["completableFutureSuccess"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   createMessage ( destination ,    null )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   createMessage ( SimpMessageType . MESSAGE ,    destination ,    headers )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create ( messageType )  ;", "accessor . setSessionId (  \" session 1  \"  )  ;", "accessor . setSessionAttributes ( new   HashMap <  >  (  )  )  ;", "accessor . setDestination ( destination )  ;", "if    ( headers    !  =    null )     {", "for    ( Map . Entry < String ,    Object >    entry    :    headers . entrySet (  )  )     {", "accessor . setHeader ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "return   MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeaders ( accessor )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SimpAnnotationMethodMessageHandlerTests . DotPathSeparatorController   controller    =    new   SimpAnnotationMethodMessageHandlerTests . DotPathSeparatorController (  )  ;", "this . messageHandler . setPathMatcher ( new   AntPathMatcher (  \"  .  \"  )  )  ;", "this . messageHandler . registerHandler ( controller )  ;", "this . messageHandler . setDestinationPrefixes ( Arrays . asList (  \"  / app 1  \"  ,     \"  / app 2  /  \"  )  )  ;", "Message <  ?  >    message    =    createMessage (  \"  / app 1  / pre . foo \"  )  ;", "this . messageHandler . registerHandler ( this . testController )  ;", "this . messageHandler . handleMessage ( message )  ;", "assertEquals (  \" handleFoo \"  ,    controller . method )  ;", "message    =    createMessage (  \"  / app 2  / pre . foo \"  )  ;", "this . messageHandler . handleMessage ( message )  ;", "assertEquals (  \" handleFoo \"  ,    controller . method )  ;", "}", "METHOD_END"], "methodName": ["dotPathSeparator"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    createMessage (  \"  / pre / illegalState \"  )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" handleExceptionWithHandlerMethodArg \"  ,    this . testController . method )  ;", "HandlerMethod   handlerMethod    =     (  ( HandlerMethod )     ( this . testController . arguments . get (  \" handlerMethod \"  )  )  )  ;", "assertNotNull ( handlerMethod )  ;", "assertEquals (  \" illegalState \"  ,    handlerMethod . getMethod (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["exceptionWithHandlerMethodArg"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    headers    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "Message <  ?  >    message    =    createMessage (  \"  / pre / headers \"  ,    headers )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" headers \"  ,    this . testController . method )  ;", "assertEquals (  \" bar \"  ,    this . testController . arguments . get (  \" foo \"  )  )  ;", "assertEquals (  \" bar \"  ,     (  ( Map < String ,    Object >  )     ( this . testController . arguments . get (  \" headers \"  )  )  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["headerArgumentResolution"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message   emptyMessage    =     (  ( Message )     ( MessageBuilder . withPayload ( new   byte [  0  ]  )  . build (  )  )  )  ;", "given ( this . channel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "given ( this . converter . toMessage ( any (  )  ,    any ( MessageHeaders . class )  )  )  . willReturn ( emptyMessage )  ;", ". ListenableFutureController   controller    =    new    . ListenableFutureController (  )  ;", "this . messageHandler . registerHandler ( controller )  ;", "this . messageHandler . setDestinationPrefixes ( Arrays . asList (  \"  / app 1  \"  ,     \"  / app 2  /  \"  )  )  ;", "Message <  ?  >    message    =    createMessage (  \"  / app 1  / listenable - future / failure \"  )  ;", "this . messageHandler . handleMessage ( message )  ;", "controller . future . run (  )  ;", "assertTrue ( controller . exceptionCaught )  ;", "}", "METHOD_END"], "methodName": ["listenableFutureFailure"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message   emptyMessage    =     (  ( Message )     ( MessageBuilder . withPayload ( new   byte [  0  ]  )  . build (  )  )  )  ;", "given ( this . channel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "given ( this . converter . toMessage ( any (  )  ,    any ( MessageHeaders . class )  )  )  . willReturn ( emptyMessage )  ;", ". ListenableFutureController   controller    =    new    . ListenableFutureController (  )  ;", "this . messageHandler . registerHandler ( controller )  ;", "this . messageHandler . setDestinationPrefixes ( Arrays . asList (  \"  / app 1  \"  ,     \"  / app 2  /  \"  )  )  ;", "Message <  ?  >    message    =    createMessage (  \"  / app 1  / listenable - future / success \"  )  ;", "this . messageHandler . handleMessage ( message )  ;", "assertNotNull ( controller . future )  ;", "controller . future . run (  )  ;", "verify ( this . converter )  . toMessage ( this . payloadCaptor . capture (  )  ,    any ( MessageHeaders . class )  )  ;", "assertEquals (  \" foo \"  ,    this . payloadCaptor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["listenableFutureSuccess"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    createMessage (  \"  / pre / message / bar / value \"  )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" messageMappingDestinationVariable \"  ,    this . testController . method )  ;", "assertEquals (  \" bar \"  ,    this . testController . arguments . get (  \" foo \"  )  )  ;", "assertEquals (  \" value \"  ,    this . testController . arguments . get (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["messageMappingDestinationVariableResolution"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    createMessage (  \"  / pre / optionalHeaders \"  )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" optionalHeaders \"  ,    this . testController . method )  ;", "assertNull ( this . testController . arguments . get (  \" foo 1  \"  )  )  ;", "assertNull ( this . testController . arguments . get (  \" foo 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["optionalHeaderArgumentResolutionWhenNotPresent"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    headers    =    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  ;", "Message <  ?  >    message    =    createMessage (  \"  / pre / optionalHeaders \"  ,    headers )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" optionalHeaders \"  ,    this . testController . method )  ;", "assertEquals (  \" bar \"  ,    this . testController . arguments . get (  \" foo 1  \"  )  )  ;", "assertEquals (  \" bar \"  ,    this . testController . arguments . get (  \" foo 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["optionalHeaderArgumentResolutionWhenPresent"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    createMessage (  \"  / pre / myValue \"  )  ;", "this . m . setEmbeddedValueResolver (  (    value )     -  >     \"  /  $  { myProperty }  \"  . equals ( value )     ?     \"  / myValue \"     :    value )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" placeholder \"  ,    this . testController . method )  ;", "}", "METHOD_END"], "methodName": ["placeholder"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "SimpMessagingTemplate   brokerTemplate    =    new   SimpMessagingTemplate ( this . channel )  ;", "brokerTemplate . setMessageConverter ( this . converter )  ;", "this . messageHandler    =    new    . TestSimpAnnotationMethodMessageHandler ( brokerTemplate ,    this . channel ,    this . channel )  ;", "this . messageHandler . setApplicationContext ( new   StaticApplicationContext (  )  )  ;", "this . messageHandler . setValidator ( new    . StringTestValidator (  . TEST _ INVALID _ VALUE )  )  ;", "this . messageHandler . afterPropertiesSet (  )  ;", "this . testController    =    new    . TestController (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    sessionAttributes    =    new   ConcurrentHashMap <  >  (  )  ;", "sessionAttributes . put (  \" name \"  ,     \" value \"  )  ;", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . create (  )  ;", "headers . setSessionId (  \" session 1  \"  )  ;", "headers . setSessionAttributes ( sessionAttributes )  ;", "headers . setDestination (  \"  / pre / scope \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeaders ( headers )  . build (  )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" scope \"  ,    this . testController . method )  ;", "}", "METHOD_END"], "methodName": ["simpScope"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    createMessage (  \"  / pre / binding / id /  1  2  \"  )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" simpleBinding \"  ,    this . testController . method )  ;", "assertTrue (  \" should   be   bound   to   type   long \"  ,     (  ( this . testController . arguments . get (  \" id \"  )  )    instanceof   Long )  )  ;", "assertEquals (  1  2 L ,    this . testController . arguments . get (  \" id \"  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleBinding"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    createMessage ( SimpMessageType . SUBSCRIBE ,     \"  / pre / sub / bar / value \"  ,    null )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" subscribeEventDestinationVariable \"  ,    this . testController . method )  ;", "assertEquals (  \" bar \"  ,    this . testController . arguments . get (  \" foo \"  )  )  ;", "assertEquals (  \" value \"  ,    this . testController . arguments . get (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["subscribeEventDestinationVariableResolution"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    createMessage (  \"  / pre / validation / payload \"  )  ;", "this . m . registerHandler ( this . testController )  ;", "this . m . handleMessage ( message )  ;", "assertEquals (  \" handleValidationException \"  ,    this . testController . method )  ;", "}", "METHOD_END"], "methodName": ["validationError"], "fileName": "org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create ( SimpMessageType . MESSAGE )  ;", "if    (  ( getHeaderInitializer (  )  )     !  =    null )     {", "getHeaderInitializer (  )  . initHeaders ( accessor )  ;", "}", "if    ( sessionId    !  =    null )     {", "accessor . setSessionId ( sessionId )  ;", "}", "accessor . setId ( subscriptionId )  ;", "accessor . setHeader ( SimpMessagingTemplate . CONVERSION _ HINT _ HEADER ,    returnType )  ;", "accessor . setLeaveMutable ( true )  ;", "return   accessor . getMessageHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["createHeaders"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . headerInitializer ;", "}", "METHOD_END"], "methodName": ["getHeaderInitializer"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "this . headerInitializer    =    headerInitializer ;", "}", "METHOD_END"], "methodName": ["setHeaderInitializer"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandler"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . create (  )  ;", "headers . setSessionId ( sessId )  ;", "headers . setId ( subsId )  ;", "headers . setDestination ( dest )  ;", "headers . setUser ( principal )  ;", "return   MessageBuilder . withPayload ( new   byte [  0  ]  )  . copyHeaders ( headers . toMap (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createInputMessage"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SubscriptionMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["getData"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SubscriptionMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["getDataAndSendTo"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SubscriptionMethodReturnValueHandlerTests . JacksonViewBean   payload    =    new   SubscriptionMethodReturnValueHandlerTests . JacksonViewBean (  )  ;", "payload . setWithView 1  (  \" with \"  )  ;", "payload . setWithView 2  (  \" with \"  )  ;", "payload . setWithoutView (  \" without \"  )  ;", "return   payload ;", "}", "METHOD_END"], "methodName": ["getJsonView"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   SubscriptionMethodReturnValueHandlerTests . PAYLOAD ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "SimpMessagingTemplate   messagingTemplate    =    new   SimpMessagingTemplate ( this . messageChannel )  ;", "messagingTemplate . setMessageConverter ( new   StringMessageConverter (  )  )  ;", "this . handler    =    new    ( messagingTemplate )  ;", "SimpMessagingTemplate   jsonMessagingTemplate    =    new   SimpMessagingTemplate ( this . messageChannel )  ;", "jsonMessagingTemplate . setMessageConverter ( new   MappingJackson 2 MessageConverter (  )  )  ;", "this . jsonHandler    =    new    ( jsonMessagingTemplate )  ;", "Method   method    =    this . getClass (  )  . getDeclaredMethod (  \" getData \"  )  ;", "this . subscribeEventReturnType    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "method    =    this . getClass (  )  . getDeclaredMethod (  \" getDataAndSendTo \"  )  ;", "this . subscribeEventSendToReturnType    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "method    =    this . getClass (  )  . getDeclaredMethod (  \" handle \"  )  ;", "this . messageMappingReturnType    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "method    =    this . getClass (  )  . getDeclaredMethod (  \" getJsonView \"  )  ;", "this . subscribeEventJsonViewReturnType    =    new   MethodParameter ( method ,     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( this . handler . supportsReturnType ( this . subscribeEventReturnType )  )  ;", "assertFalse ( this . handler . supportsReturnType ( this . subscribeEventSendToReturnType )  )  ;", "assertFalse ( this . handler . supportsReturnType ( this . messageMappingReturnType )  )  ;", "}", "METHOD_END"], "methodName": ["supportsReturnType"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" sess 1  \"  ;", "String   subscriptionId    =     \" subs 1  \"  ;", "String   destination    =     \"  / dest \"  ;", "Message <  ?  >    inputMessage    =    createInputMessage ( sessionId ,    subscriptionId ,    destination ,    null )  ;", "MessageSendingOperations   messagingTemplate    =    Mockito . mock ( MessageSendingOperations . class )  ;", "SubscriptionMethodReturnValueHandler   handler    =    new   SubscriptionMethodReturnValueHandler ( messagingTemplate )  ;", "handler . handleReturnValue (  . PAYLOAD ,    this . subscribeEventReturnType ,    inputMessage )  ;", "ArgumentCaptor < MessageHeaders >    captor    =    ArgumentCaptor . forClass ( MessageHeaders . class )  ;", "verify ( messagingTemplate )  . convertAndSend ( eq (  \"  / dest \"  )  ,    eq (  . PAYLOAD )  ,    captor . capture (  )  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    MessageHeaderAccessor . getAccessor ( captor . getValue (  )  ,    SimpMessageHeaderAccessor . class )  ;", "assertNotNull ( headerAccessor )  ;", "assertTrue ( headerAccessor . isMutable (  )  )  ;", "assertEquals ( sessionId ,    headerAccessor . getSessionId (  )  )  ;", "assertEquals ( subscriptionId ,    headerAccessor . getSubscriptionId (  )  )  ;", "assertEquals ( this . subscribeEventReturnType ,    headerAccessor . getHeader ( SimpMessagingTemplate . CONVERSION _ HINT _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["testHeadersPassedToMessagingTemplate"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "String   sId    =     \" subs 1  \"  ;", "String   destination    =     \"  / dest \"  ;", "Message <  ?  >    inputMessage    =    createInputMessage ( sessionId ,    sId ,    destination ,    null )  ;", "this . jsonHandler . handleReturnValue ( getJsonView (  )  ,    this . subscribeEventJsonViewReturnType ,    inputMessage )  ;", "verify ( this . messageChannel )  . send ( this . messageCaptor . capture (  )  )  ;", "Message <  ?  >    message    =    this . messageCaptor . getValue (  )  ;", "assertNotNull ( message )  ;", "assertEquals (  \"  {  \\  \" withView 1  \\  \"  :  \\  \" with \\  \"  }  \"  ,    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["testJsonView"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . messageChannel . send ( any ( Message . class )  )  )  . willReturn ( true )  ;", "String   sessionId    =     \" sess 1  \"  ;", "String   subscriptionId    =     \" subs 1  \"  ;", "String   destination    =     \"  / dest \"  ;", "Message <  ?  >    inputMessage    =    createInputMessage ( sessionId ,    subscriptionId ,    destination ,    null )  ;", "this . handler . handleReturnValue (  . PAYLOAD ,    this . subscribeEventReturnType ,    inputMessage )  ;", "verify ( this . messageChannel )  . send ( this . messageCaptor . capture (  )  )  ;", "assertNotNull ( this . messageCaptor . getValue (  )  )  ;", "Message <  ?  >    message    =    this . messageCaptor . getValue (  )  ;", "SimpMessageHeaderAccessor   headerAccessor    =    SimpMessageHeaderAccessor . wrap ( message )  ;", "assertNull (  \" SimpMessageHeaderAccessor   should   have   disabled   id \"  ,    headerAccessor . getId (  )  )  ;", "assertNull (  \" SimpMessageHeaderAccessor   should   have   disabled   timestamp \"  ,    headerAccessor . getTimestamp (  )  )  ;", "assertEquals ( sessionId ,    headerAccessor . getSessionId (  )  )  ;", "assertEquals ( subscriptionId ,    headerAccessor . getSubscriptionId (  )  )  ;", "assertEquals ( destination ,    headerAccessor . getDestination (  )  )  ;", "assertEquals (  . MIME _ TYPE ,    headerAccessor . getContentType (  )  )  ;", "assertEquals ( this . subscribeEventReturnType ,    headerAccessor . getHeader ( SimpMessagingTemplate . CONVERSION _ HINT _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["testMessageSentToChannel"], "fileName": "org.springframework.messaging.simp.annotation.support.SubscriptionMethodReturnValueHandlerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( destination    =  =    null )     |  |     ( CollectionUtils . isEmpty ( this . destinationPrefixes )  )  )     {", "return   true ;", "}", "for    ( St   prefix    :    this . destinationPrefixes )     {", "if    ( destination . startsWith ( prefix )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkDestinationPrefix"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . eventPublisher ;", "}", "METHOD_END"], "methodName": ["getApplicationEventPublisher"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . brokerChannel ;", "}", "METHOD_END"], "methodName": ["getBrokerChannel"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . clientInboundChannel ;", "}", "METHOD_END"], "methodName": ["getClientInboundChannel"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . clientOutboundChannel ;", "}", "METHOD_END"], "methodName": ["getClientOutboundChannel"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationPrefixes ;", "}", "METHOD_END"], "methodName": ["getDestinationPrefixes"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . brokerAvailable . get (  )  ;", "}", "METHOD_END"], "methodName": ["isBrokerAvailable"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "boolean   shouldPublish    =    this . brokerAvailable . compareAndSet ( false ,    true )  ;", "if    (  (  ( this . eventPublisher )     !  =    null )     &  &    shouldPublish )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info ( this . availableEvent )  ;", "}", "this . eventPublisher . publishEvent ( this . availableEvent )  ;", "}", "}", "METHOD_END"], "methodName": ["publishBrokerAvailableEvent"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "boolean   shouldPublish    =    this . brokerAvailable . compareAndSet ( true ,    false )  ;", "if    (  (  ( this . eventPublisher )     !  =    null )     &  &    shouldPublish )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info ( this . notAvailableEvent )  ;", "}", "this . eventPublisher . publishEvent ( this . notAvailableEvent )  ;", "}", "}", "METHOD_END"], "methodName": ["publishBrokerUnavailableEvent"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . brokerAvailable ;", "}", "METHOD_END"], "methodName": ["isBrokerAvailable"], "fileName": "org.springframework.messaging.simp.broker.BrokerAvailabilityEvent"}, {"methodBody": ["METHOD_START", "{", "this . handler . handleMessage ( new   GenericMessage < Object >  (  \" payload \"  )  )  ;", "assertEquals ( Collections . emptyList (  )  ,    this . handler . messages )  ;", "}", "METHOD_END"], "methodName": ["handleMessageWhenBrokerNotRunning"], "fileName": "org.springframework.messaging.simp.broker.BrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . handler . isBrokerAvailable (  )  )  ;", "assertEquals ( Collections . emptyList (  )  ,    this . handler . availabilityEvents )  ;", "this . handler . publishBrokerAvailableEvent (  )  ;", "assertTrue ( this . handler . isBrokerAvailable (  )  )  ;", "assertEquals ( Arrays . asList ( true )  ,    this . handler . availabilityEvents )  ;", "}", "METHOD_END"], "methodName": ["publishBrokerAvailableEvent"], "fileName": "org.springframework.messaging.simp.broker.BrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . publishBrokerAvailableEvent (  )  ;", "this . handler . publishBrokerAvailableEvent (  )  ;", "assertEquals ( Arrays . asList ( true )  ,    this . handler . availabilityEvents )  ;", "}", "METHOD_END"], "methodName": ["publishBrokerAvailableEventWhenAlreadyAvailable"], "fileName": "org.springframework.messaging.simp.broker.BrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . publishBrokerAvailableEvent (  )  ;", "assertTrue ( this . handler . isBrokerAvailable (  )  )  ;", "this . handler . publishBrokerUnavailableEvent (  )  ;", "assertFalse ( this . handler . isBrokerAvailable (  )  )  ;", "assertEquals ( Arrays . asList ( true ,    false )  ,    this . handler . availabilityEvents )  ;", "}", "METHOD_END"], "methodName": ["publishBrokerUnavailableEvent"], "fileName": "org.springframework.messaging.simp.broker.BrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . publishBrokerAvailableEvent (  )  ;", "this . handler . publishBrokerUnavailableEvent (  )  ;", "this . handler . publishBrokerUnavailableEvent (  )  ;", "assertEquals ( Arrays . asList ( true ,    false )  ,    this . handler . availabilityEvents )  ;", "}", "METHOD_END"], "methodName": ["publishBrokerUnavailableEventWhenAlreadyUnvailable"], "fileName": "org.springframework.messaging.simp.broker.BrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "this . handler    =    new    . TestBrokerMesageHandler (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.broker.BrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . start (  )  ;", "this . handler . stop (  )  ;", "assertEquals ( Collections . emptyList (  )  ,    this . handler . availabilityEvents )  ;", "}", "METHOD_END"], "methodName": ["startAndStopShouldNotPublishBrokerAvailabilityEvents"], "fileName": "org.springframework.messaging.simp.broker.BrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . handler . isRunning (  )  )  ;", "this . handler . start (  )  ;", "assertTrue ( this . handler . isRunning (  )  )  ;", "}", "METHOD_END"], "methodName": ["startShouldUpdateIsRunning"], "fileName": "org.springframework.messaging.simp.broker.BrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . start (  )  ;", "assertTrue ( this . handler . isRunning (  )  )  ;", "this . handler . stop (  )  ;", "assertFalse ( this . handler . isRunning (  )  )  ;", "}", "METHOD_END"], "methodName": ["stopShouldUpdateIsRunning"], "fileName": "org.springframework.messaging.simp.broker.BrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . selectorHeaderInUse )  )     {", "return   allMatches ;", "}", "MultiValueMap < String ,    String >    result    =    new   LinkedMultiValueMap ( allMatches . size (  )  )  ;", "allMatches . forEach (  (    sessionId ,    subIds )     -  >     {", "for    ( String   subId    :    subIds )     {", "SessionSubscriptionInfo   info    =    this . subscriptionRegistry . getSubscriptions ( sessionId )  ;", "if    ( info    =  =    null )     {", "continue ;", "}", "Subscription   sub    =    info . getSubscription ( subId )  ;", "if    ( sub    =  =    null )     {", "continue ;", "}", "Expression   expression    =    sub . getSelectorExpression (  )  ;", "if    ( expression    =  =    null )     {", "result . add ( sessionId ,    subId )  ;", "continue ;", "}", "try    {", "if    ( Boolean . TRUE . equals ( expression . getValue (  . messageEvalContext ,    message ,     . class )  )  )     {", "result . add ( sessionId ,    subId )  ;", "}", "}    catch    (    ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Failed   to   evaluate   selector :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}    catch    (    ex )     {", "logger . debug (  \" Failed   to   evaluate   selector \"  ,    ex )  ;", "}", "}", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["filterSubscriptions"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . cacheLimit ;", "}", "METHOD_END"], "methodName": ["getCacheLimit"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . pathMatcher ;", "}", "METHOD_END"], "methodName": ["getPathMatcher"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    null ;", "if    (  ( getSelectorHeaderName (  )  )     !  =    null )     {", "String   selector    =    SimpMessageHeaderAccessor . getFirstNativeHeader ( getSelectorHeaderName (  )  ,    headers )  ;", "if    ( selector    !  =    null )     {", "try    {", "expression    =    this . expressionParser . parseExpression ( selector )  ;", "this . selectorHeaderInUse    =    true ;", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  \"    selector :     [  \"     +    selector )     +     \"  ]  \"  )  )  ;", "}", "}    catch    ( Throwable   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Failed   to   parse   selector :     \"     +    selector )  ,    ex )  ;", "}", "}", "}", "}", "return   expression ;", "}", "METHOD_END"], "methodName": ["getSelectorExpression"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . selectorHeaderName ;", "}", "METHOD_END"], "methodName": ["getSelectorHeaderName"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry"}, {"methodBody": ["METHOD_START", "{", "this . cacheLimit    =    cacheLimit ;", "}", "METHOD_END"], "methodName": ["setCacheLimit"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry"}, {"methodBody": ["METHOD_START", "{", "this . pathMatcher    =    pathMatcher ;", "}", "METHOD_END"], "methodName": ["setPathMatcher"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry"}, {"methodBody": ["METHOD_START", "{", "this . selectorHeaderName    =     ( StringUtils . hasText ( selectorHeaderName )  )     ?    selectorHeaderName    :    null ;", "}", "METHOD_END"], "methodName": ["setSelectorHeaderName"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry"}, {"methodBody": ["METHOD_START", "{", "this . registry . setCacheLimit (  1  )  ;", "this . registry . register ( subscribeMessage (  \" sess 1  \"  ,     \"  1  \"  ,     \"  / foo \"  )  )  ;", "this . registry . register ( subscribeMessage (  \" sess 1  \"  ,     \"  2  \"  ,     \"  / bar \"  )  )  ;", "assertEquals (  1  ,    this . registry . finds ( createMessage (  \"  / foo \"  )  )  . size (  )  )  ;", "assertEquals (  1  ,    this . registry . finds ( createMessage (  \"  / bar \"  )  )  . size (  )  )  ;", "this . registry . register ( subscribeMessage (  \" sess 2  \"  ,     \"  1  \"  ,     \"  / foo \"  )  )  ;", "this . registry . register ( subscribeMessage (  \" sess 2  \"  ,     \"  2  \"  ,     \"  / bar \"  )  )  ;", "assertEquals (  2  ,    this . registry . finds ( createMessage (  \"  / foo \"  )  )  . size (  )  )  ;", "assertEquals (  2  ,    this . registry . finds ( createMessage (  \"  / bar \"  )  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["cacheLimitExceeded"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create (  )  ;", "accessor . setDestination ( destination )  ;", "return   MessageBuilder . createMessage (  \"  \"  ,    accessor . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    actual    =    this . registry . findSubscriptions ( createMessage (  \"  / foo \"  )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  (  \" Expected   no   elements    \"     +    actual )  ,     0  ,    actual . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["findSubscriptionsNoMatches"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . registry . registerSubscription ( subscribeMessage (  \" sess 1  \"  ,     \"  1  \"  ,     \"  / foo \"  )  )  ;", "this . registry . registerSubscription ( subscribeMessage (  \" sess 2  \"  ,     \"  1  \"  ,     \"  / foo \"  )  )  ;", "MultiValueMap < String ,    String >    subscriptions    =    this . registry . findSubscriptions ( createMessage (  \"  / foo \"  )  )  ;", "assertNotNull ( subscriptions )  ;", "assertEquals (  2  ,    subscriptions . size (  )  )  ;", "Iterator < Map . Entry < String ,    List < String >  >  >    iterator    =    subscriptions . entrySet (  )  . iterator (  )  ;", "iterator . next (  )  ;", "this . registry . registerSubscription ( subscribeMessage (  \" sess 3  \"  ,     \"  1  \"  ,     \"  / foo \"  )  )  ;", "iterator . next (  )  ;", "}", "METHOD_END"], "methodName": ["findSubscriptionsReturnsMapSafeToIterate"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . registry . registerSubscription ( subscribeMessage (  \" sess 1  \"  ,     \"  1  \"  ,     \"  / foo \"  )  )  ;", "this . registry . registerSubscription ( subscribeMessage (  \" sess 1  \"  ,     \"  2  \"  ,     \"  / foo \"  )  )  ;", "MultiValueMap < String ,    String >    allSubscriptions    =    this . registry . findSubscriptions ( createMessage (  \"  / foo \"  )  )  ;", "assertNotNull ( allSubscriptions )  ;", "assertEquals (  1  ,    allSubscriptions . size (  )  )  ;", "Iterator < String >    iteratorValues    =    allSubscriptions . get (  \" sess 1  \"  )  . iterator (  )  ;", "iteratorValues . next (  )  ;", "this . registry . unregisterSubscription ( unsubscribeMessage (  \" sess 1  \"  ,     \"  2  \"  )  )  ;", "iteratorValues . next (  )  ;", "}", "METHOD_END"], "methodName": ["findSubscriptionsReturnsMapSafeToIterateIncludingValues"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "String   sess 1     =     \" sess 0  1  \"  ;", "String   sess 2     =     \" sess 0  2  \"  ;", "String   subs 1     =     \" subs 0  1  \"  ;", "String   subs 2     =     \" subs 0  2  \"  ;", "String   subs 3     =     \" subs 0  3  \"  ;", "String   subs 4     =     \" subs 0  4  \"  ;", "String   subs 5     =     \" subs 0  5  \"  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 1  ,     \"  / topic / PRICE . STOCK . NASDAQ . IBM \"  )  )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 2  ,     \"  / topic / PRICE . STOCK . NYSE . IBM \"  )  )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 3  ,     \"  / topic / PRICE . STOCK . NASDAQ . GOOG \"  )  )  ;", "this . registry . finds ( createMessage (  \"  / topic / PRICE . STOCK . NYSE . IBM \"  )  )  ;", "this . registry . finds ( createMessage (  \"  / topic / PRICE . STOCK . NASDAQ . GOOG \"  )  )  ;", "this . registry . finds ( createMessage (  \"  / topic / PRICE . STOCK . NASDAQ . IBM \"  )  )  ;", "this . registry . unregister ( unsubscribeMessage ( sess 1  ,    subs 1  )  )  ;", "this . registry . unregister ( unsubscribeMessage ( sess 1  ,    subs 2  )  )  ;", "this . registry . unregister ( unsubscribeMessage ( sess 1  ,    subs 3  )  )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 1  ,     \"  / topic / PRICE . STOCK . NASDAQ . IBM \"  )  )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 2  ,     \"  / topic / PRICE . STOCK . NYSE . IBM \"  )  )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 3  ,     \"  / topic / PRICE . STOCK . NASDAQ . GOOG \"  )  )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 4  ,     \"  / topic / PRICE . STOCK . NYSE . IBM \"  )  )  ;", "this . registry . register ( subscribeMessage ( sess 2  ,    subs 5  ,     \"  / topic / PRICE . STOCK . NASDAQ . GOOG \"  )  )  ;", "this . registry . unregisterAlls ( sess 1  )  ;", "this . registry . unregisterAlls ( sess 2  )  ;", "}", "METHOD_END"], "methodName": ["registerAndUnregisterMultipleDestinations"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "String   sessId    =     \" sess 0  1  \"  ;", "String   subsId    =     \" subs 0  1  \"  ;", "String   dest    =     \"  / foo \"  ;", "this . registry . register ( subscribeMessage ( sessId ,    subsId ,    dest )  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( createMessage ( dest )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  (  \" Expected   one   element    \"     +    actual )  ,     1  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList ( subsId )  ,    actual . get ( sessId )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscription"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "String   sessId    =     \" sess 0  1  \"  ;", "String   subsId    =     \" subs 0  1  \"  ;", "String   dest    =     \"  / foo \"  ;", "this . registry . register ( subscribeMessage ( null ,    subsId ,    dest )  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( createMessage ( dest )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  0  ,    actual . size (  )  )  ;", "this . registry . register ( subscribeMessage ( sessId ,    null ,    dest )  )  ;", "actual    =    this . registry . finds ( createMessage ( dest )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  0  ,    actual . size (  )  )  ;", "this . registry . register ( subscribeMessage ( sessId ,    subsId ,    null )  )  ;", "actual    =    this . registry . finds ( createMessage ( dest )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  0  ,    actual . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscriptionInvalidInput"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    sessIds    =    Arrays . asList (  \" sess 0  1  \"  ,     \" sess 0  2  \"  ,     \" sess 0  3  \"  )  ;", "List < String >    subscriptionIds    =    Arrays . asList (  \" subs 0  1  \"  ,     \" subs 0  2  \"  ,     \" subs 0  3  \"  )  ;", "String   dest    =     \"  / foo \"  ;", "for    ( String   sessId    :    sessIds )     {", "for    ( String   subsId    :    subscriptionIds )     {", "this . registry . register ( subscribeMessage ( sessId ,    subsId ,    dest )  )  ;", "}", "}", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( createMessage ( dest )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  3  ,    actual . size (  )  )  ;", "assertEquals ( subscriptionIds ,    sort ( actual . get ( sessIds . get (  0  )  )  )  )  ;", "assertEquals ( subscriptionIds ,    sort ( actual . get ( sessIds . get (  1  )  )  )  )  ;", "assertEquals ( subscriptionIds ,    sort ( actual . get ( sessIds . get (  2  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscriptionMultipleSessions"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "String   sessId    =     \" sess 0  1  \"  ;", "List < String >    subscriptionIds    =    Arrays . asList (  \" subs 0  1  \"  ,     \" subs 0  2  \"  ,     \" subs 0  3  \"  )  ;", "String   dest    =     \"  / foo \"  ;", "for    ( String   subId    :    subscriptionIds )     {", "this . registry . register ( subscribeMessage ( sessId ,    subId ,    dest )  )  ;", "}", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( createMessage ( dest )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  1  ,    actual . size (  )  )  ;", "assertEquals ( subscriptionIds ,    sort ( actual . get ( sessId )  )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscriptionOneSession"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . registry . registerSubscription ( subscribeMessage (  \" sess 0  1  \"  ,     \" subs 0  1  \"  ,     \"  / foo \"  )  )  ;", "this . registry . registerSubscription ( subscribeMessage (  \" sess 0  1  \"  ,     \" subs 0  2  \"  ,     \"  / foo \"  )  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . findSubscriptions ( createMessage (  \"  / foo \"  )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  \" Expected    1    element \"  ,     1  ,    actual . size (  )  )  ;", "assertEquals ( Arrays . asList (  \" subs 0  1  \"  ,     \" subs 0  2  \"  )  ,    actual . get (  \" sess 0  1  \"  )  )  ;", "this . registry . unregisterSubscription ( unsubscribeMessage (  \" sess 0  1  \"  ,     \" subs 0  1  \"  )  )  ;", "actual    =    this . registry . findSubscriptions ( createMessage (  \"  / foo \"  )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  \" Expected    1    element \"  ,     1  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList (  \" subs 0  2  \"  )  ,    actual . get (  \" sess 0  1  \"  )  )  ;", "this . registry . unregisterSubscription ( unsubscribeMessage (  \" sess 0  1  \"  ,     \" subs 0  2  \"  )  )  ;", "actual    =    this . registry . findSubscriptions ( createMessage (  \"  / foo \"  )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  \" Expected   no   element \"  ,     0  ,    actual . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscriptionTwiceAndUnregister"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "String   sessId    =     \" sess 0  1  \"  ;", "String   subsId    =     \" subs 0  1  \"  ;", "String   destPattern    =     \"  / topic / PRICE . STOCK .  *  . IBM \"  ;", "String   dest    =     \"  / topic / PRICE . STOCK . NASDAQ . IBM \"  ;", "this . registry . register ( subscribeMessage ( sessId ,    subsId ,    destPattern )  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( createMessage ( dest )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  (  \" Expected   one   element    \"     +    actual )  ,     1  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList ( subsId )  ,    actual . get ( sessId )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscriptionWithDestinationPattern"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "String   sessId    =     \" sess 0  1  \"  ;", "String   subsId    =     \" subs 0  1  \"  ;", "String   destPattern    =     \"  / topic / PRICE . STOCK .  *  .  { ticker :  ( IBM | MSFT )  }  \"  ;", "this . registry . register ( subscribeMessage ( sessId ,    subsId ,    destPattern )  )  ;", "Message <  ?  >    message    =    createMessage (  \"  / topic / PRICE . STOCK . NASDAQ . IBM \"  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( message )  ;", "assertNotNull ( actual )  ;", "assertEquals (  (  \" Expected   one   element    \"     +    actual )  ,     1  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList ( subsId )  ,    actual . get ( sessId )  )  ;", "message    =    createMessage (  \"  / topic / PRICE . STOCK . NASDAQ . MSFT \"  )  ;", "actual    =    this . registry . finds ( message )  ;", "assertNotNull ( actual )  ;", "assertEquals (  (  \" Expected   one   element    \"     +    actual )  ,     1  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList ( subsId )  ,    actual . get ( sessId )  )  ;", "message    =    createMessage (  \"  / topic / PRICE . STOCK . NASDAQ . VMW \"  )  ;", "actual    =    this . registry . finds ( message )  ;", "assertNotNull ( actual )  ;", "assertEquals (  (  \" Expected   no   elements    \"     +    actual )  ,     0  ,    actual . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscriptionWithDestinationPatternRegex"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" sess 0  1  \"  ;", "String   subscriptionId    =     \" subs 0  1  \"  ;", "String   destination    =     \"  / foo \"  ;", "String   selector    =     \" headers . foo    =  =     ' bar '  \"  ;", "this . registry . register ( subscribeMessage ( sessionId ,    subscriptionId ,    destination ,    selector )  )  ;", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create (  )  ;", "accessor . setDestination ( destination )  ;", "accessor . setNativeHeader (  \" foo \"  ,     \" bar \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \"  \"  ,    accessor . getMessageHeaders (  )  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( message )  ;", "assertNotNull ( actual )  ;", "assertEquals (  1  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList ( subscriptionId )  ,    actual . get ( sessionId )  )  ;", "actual    =    this . registry . finds ( createMessage ( destination )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  0  ,    actual . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscriptionWithSelector"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "String   sessionId    =     \" sess 0  1  \"  ;", "String   subscriptionId    =     \" subs 0  1  \"  ;", "String   destination    =     \"  / foo \"  ;", "String   selector    =     \" headers . foo    =  =     ' bar '  \"  ;", "this . registry . setSelectorHeaderName ( null )  ;", "this . registry . register ( subscribeMessage ( sessionId ,    subscriptionId ,    destination ,    selector )  )  ;", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create (  )  ;", "accessor . setDestination ( destination )  ;", "accessor . setNativeHeader (  \" foo \"  ,     \" bazz \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \"  \"  ,    accessor . getMessageHeaders (  )  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( message )  ;", "assertNotNull ( actual )  ;", "assertEquals (  1  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList ( subscriptionId )  ,    actual . get ( sessionId )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscriptionWithSelectorNotSupported"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "String   sess 1     =     \" sess 0  1  \"  ;", "String   sess 2     =     \" sess 0  2  \"  ;", "String   subs 1     =     \" subs 0  1  \"  ;", "String   subs 2     =     \" subs 0  2  \"  ;", "String   subs 3     =     \" subs 0  3  \"  ;", "String   destNasdaqIbm    =     \"  / topic / PRICE . STOCK . NASDAQ . IBM \"  ;", "Message <  ?  >    destNasdaqIbmMessage    =    createMessage ( destNasdaqIbm )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 2  ,    destNasdaqIbm )  )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 1  ,     \"  / topic / PRICE . STOCK .  *  . IBM \"  )  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( destNasdaqIbmMessage )  ;", "assertNotNull ( actual )  ;", "assertEquals (  1  ,    actual . size (  )  )  ;", "assertEquals ( Arrays . asList ( subs 2  ,    subs 1  )  ,    actual . get ( sess 1  )  )  ;", "this . registry . register ( subscribeMessage ( sess 2  ,    subs 1  ,    destNasdaqIbm )  )  ;", "this . registry . register ( subscribeMessage ( sess 2  ,    subs 2  ,     \"  / topic / PRICE . STOCK . NYSE . IBM \"  )  )  ;", "this . registry . register ( subscribeMessage ( sess 2  ,    subs 3  ,     \"  / topic / PRICE . STOCK . NASDAQ . GOOG \"  )  )  ;", "actual    =    this . registry . finds ( destNasdaqIbmMessage )  ;", "assertNotNull ( actual )  ;", "assertEquals (  2  ,    actual . size (  )  )  ;", "assertEquals ( Arrays . asList ( subs 2  ,    subs 1  )  ,    actual . get ( sess 1  )  )  ;", "assertEquals ( Collections . singletonList ( subs 1  )  ,    actual . get ( sess 2  )  )  ;", "this . registry . unregisterAlls ( sess 1  )  ;", "actual    =    this . registry . finds ( destNasdaqIbmMessage )  ;", "assertNotNull ( actual )  ;", "assertEquals (  1  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList ( subs 1  )  ,    actual . get ( sess 2  )  )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 1  ,     \"  / topic / PRICE . STOCK .  *  . IBM \"  )  )  ;", "this . registry . register ( subscribeMessage ( sess 1  ,    subs 2  ,    destNasdaqIbm )  )  ;", "actual    =    this . registry . finds ( destNasdaqIbmMessage )  ;", "assertNotNull ( actual )  ;", "assertEquals (  2  ,    actual . size (  )  )  ;", "assertEquals ( Arrays . asList ( subs 1  ,    subs 2  )  ,    actual . get ( sess 1  )  )  ;", "assertEquals ( Collections . singletonList ( subs 1  )  ,    actual . get ( sess 2  )  )  ;", "this . registry . unregister ( unsubscribeMessage ( sess 1  ,    subs 2  )  )  ;", "actual    =    this . registry . finds ( destNasdaqIbmMessage )  ;", "assertNotNull ( actual )  ;", "assertEquals (  2  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList ( subs 1  )  ,    actual . get ( sess 1  )  )  ;", "assertEquals ( Collections . singletonList ( subs 1  )  ,    actual . get ( sess 2  )  )  ;", "this . registry . unregister ( unsubscribeMessage ( sess 1  ,    subs 1  )  )  ;", "actual    =    this . registry . finds ( destNasdaqIbmMessage )  ;", "assertNotNull ( actual )  ;", "assertEquals (  1  ,    actual . size (  )  )  ;", "assertEquals ( Collections . singletonList ( subs 1  )  ,    actual . get ( sess 2  )  )  ;", "this . registry . unregister ( unsubscribeMessage ( sess 2  ,    subs 1  )  )  ;", "actual    =    this . registry . finds ( destNasdaqIbmMessage )  ;", "assertNotNull ( actual )  ;", "assertEquals (  0  ,    actual . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerSubscriptionsWithSimpleAndPatternDestinations"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "Collections . sort ( list )  ;", "return   list ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "return   subscribeMessage ( sessionId ,    subscriptionId ,    destination ,    null )  ;", "}", "METHOD_END"], "methodName": ["subscribeMessage"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create ( SimpMessageType . SUBSCRIBE )  ;", "accessor . setSessionId ( sessionId )  ;", "accessor . seId ( subscriptionId )  ;", "if    ( dest    !  =    null )     {", "accessor . setDestination ( dest )  ;", "}", "if    ( selector    !  =    null )     {", "accessor . setNativeHeader (  \" selector \"  ,    selector )  ;", "}", "return   MessageBuilder . createMessage (  \"  \"  ,    accessor . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["subscribeMessage"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    sessIds    =    Arrays . asList (  \" sess 0  1  \"  ,     \" sess 0  2  \"  ,     \" sess 0  3  \"  )  ;", "List < String >    subscriptionIds    =    Arrays . asList (  \" subs 0  1  \"  ,     \" subs 0  2  \"  ,     \" subs 0  3  \"  )  ;", "String   dest    =     \"  / foo \"  ;", "for    ( String   sessId    :    sessIds )     {", "for    ( String   subsId    :    subscriptionIds )     {", "this . registry . register ( subscribeMessage ( sessId ,    subsId ,    dest )  )  ;", "}", "}", "this . registry . unregisterAlls ( sessIds . get (  0  )  )  ;", "this . registry . unregisterAlls ( sessIds . get (  1  )  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( createMessage ( dest )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  (  \" Expected   one   element :     \"     +    actual )  ,     1  ,    actual . size (  )  )  ;", "assertEquals ( subscriptionIds ,    sort ( actual . get ( sessIds . get (  2  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["unregisterAllSubscriptions"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . registry . unregisterAllSubscriptions (  \" bogus \"  )  ;", "}", "METHOD_END"], "methodName": ["unregisterAllSubscriptionsNoMatch"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    sessIds    =    Arrays . asList (  \" sess 0  1  \"  ,     \" sess 0  2  \"  ,     \" sess 0  3  \"  )  ;", "List < String >    subscriptionIds    =    Arrays . asList (  \" subs 0  1  \"  ,     \" subs 0  2  \"  ,     \" subs 0  3  \"  )  ;", "String   dest    =     \"  / foo \"  ;", "for    ( String   sessId    :    sessIds )     {", "for    ( String   subsId    :    subscriptionIds )     {", "this . registry . register ( subscribeMessage ( sessId ,    subsId ,    dest )  )  ;", "}", "}", "this . registry . unregister ( unsubscribeMessage ( sessIds . get (  0  )  ,    subscriptionIds . get (  0  )  )  )  ;", "this . registry . unregister ( unsubscribeMessage ( sessIds . get (  0  )  ,    subscriptionIds . get (  1  )  )  )  ;", "this . registry . unregister ( unsubscribeMessage ( sessIds . get (  0  )  ,    subscriptionIds . get (  2  )  )  )  ;", "MultiValueMap < String ,    String >    actual    =    this . registry . finds ( createMessage ( dest )  )  ;", "assertNotNull ( actual )  ;", "assertEquals (  (  \" Expected   two   elements :     \"     +    actual )  ,     2  ,    actual . size (  )  )  ;", "assertEquals ( subscriptionIds ,    sort ( actual . get ( sessIds . get (  1  )  )  )  )  ;", "assertEquals ( subscriptionIds ,    sort ( actual . get ( sessIds . get (  2  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["unregisterSubscription"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create ( SimpMessageType . UNSUBSCRIBE )  ;", "accessor . setSessionId ( sessionId )  ;", "accessor . seId ( subscriptionId )  ;", "return   MessageBuilder . createMessage (  \"  \"  ,    accessor . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["unsubscribeMessage"], "fileName": "org.springframework.messaging.simp.broker.DefaultSubscriptionRegistryTests"}, {"methodBody": ["METHOD_START", "{", "return   this . headerInitializer ;", "}", "METHOD_END"], "methodName": ["getHeaderInitializer"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . heartbeatValue ;", "}", "METHOD_END"], "methodName": ["getHeartbeatValue"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionRegistry ;", "}", "METHOD_END"], "methodName": ["getSubscriptionRegistry"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . taskScheduler ;", "}", "METHOD_END"], "methodName": ["getTaskScheduler"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . sessions . remove ( sessionId )  ;", "this . subscriptionRegistry . unregisterAllSubscriptions ( sessionId )  ;", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create ( SimpMessageType . DISCONNECT _ ACK )  ;", "accessor . setSessionId ( sessionId )  ;", "if    ( user    !  =    null )     {", "accessor . setUser ( user )  ;", "}", "if    ( origMessage    !  =    null )     {", "accessor . setHeader ( SimpMessageHeaderAccessor . DISCONNECT _ MESSAGE _ HEADER ,    origMessage )  ;", "}", "initHeaders ( accessor )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage (  . EMPTY _ PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "getClientOutboundChannel (  )  . send ( message )  ;", "}", "METHOD_END"], "methodName": ["handleDisconnect"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . cacheLimit )     !  =    null )     &  &     (  ( this . subscriptionRegistry )    instanceof   DefaultSubscriptionRegistry )  )     {", "(  ( DefaultSubscriptionRegistry )     ( this . subscriptionRegistry )  )  . setCacheLimit ( this . cacheLimit )  ;", "}", "}", "METHOD_END"], "methodName": ["initCacheLimitToUse"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getHeaderInitializer (  )  )     !  =    null )     {", "getHeaderInitializer (  )  . initHeaders ( accor )  ;", "}", "}", "METHOD_END"], "methodName": ["initHeaders"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getHeartbeatValue (  )  )     =  =    null )     {", "return    0  ;", "} else", "if    (  (  ( getHeartbeatValue (  )  [  0  ]  )     >     0  )     &  &     (  ( getHeartbeatValue (  )  [  1  ]  )     >     0  )  )     {", "return   Math . min ( getHeartbeatValue (  )  [  0  ]  ,    getHeartbeatValue (  )  [  1  ]  )  ;", "} else    {", "return    ( getHeartbeatValue (  )  [  0  ]  )     >     0     ?    getHeartbeatValue (  )  [  0  ]     :    getHeartbeatValue (  )  [  1  ]  ;", "}", "}", "METHOD_END"], "methodName": ["initHeartbeatTaskDelay"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . pathMatcher )     !  =    null )     &  &     (  ( this . subscriptionRegistry )    instanceof   DefaultSubscriptionRegistry )  )     {", "(  ( DefaultSubscriptionRegistry )     ( this . subscriptionRegistry )  )  . setPathMatcher ( this . pathMatcher )  ;", "}", "}", "METHOD_END"], "methodName": ["initPathMatcherToUse"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . subscriptionRegistry )    instanceof   DefaultSubscriptionRegistry )     {", "(  ( DefaultSubscriptionRegistry )     ( this . subscriptionRegistry )  )  . setSelectorHeaderN ( this . selectorHeaderN )  ;", "}", "}", "METHOD_END"], "methodName": ["initSelectorHeaderNameToUse"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "SimpeaderAccessor   accessor    =    eaderAccessor . getAccessor ( message ,    SimpeaderAccessor . class )  ;", "accessor    =     ( accessor    !  =    null )     ?    accessor    :    SimpeaderAccessor . wrap ( message )  ;", "logger . debug (  (  \" Processing    \"     +     ( accessor . getShortLogMessage ( message . getPayload (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["logMessage"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    subscriptions    =    this . subscriptionRegistry . findSubscriptions ( message )  ;", "if    (  (  !  ( subscriptions . isEmpty (  )  )  )     &  &     ( logger . isDebugEnabled (  )  )  )     {", "logger . debug (  (  (  \" Broadcasting   to    \"     +     ( subscriptions . size (  )  )  )     +     \"    sessions .  \"  )  )  ;", "}", "long   now    =    System . currentTimeMillis (  )  ;", "subscriptions . forEach (  (    sessionId ,    subscriptionIds )     -  >     {", "for    ( String   subscriptionId    :    subscriptionIds )     {", "SimpeaderAccessor   headerAccessor    =    SimpeaderAccessor . create ( SimpMessageType . MESSAGE )  ;", "initHeaders ( headerAccessor )  ;", "headerAccessor . setSessionId ( sessionId )  ;", "headerAccessor . setSubscriptionId ( subscriptionId )  ;", "headerAccessor . copyHeadersIfAbsent ( message . getHeaders (  )  )  ;", "Object   payload    =    message . getPayload (  )  ;", "Message <  ?  >    reply    =    MessageBuilder . createMessage ( payload ,    headerAccessor . geteaders (  )  )  ;", "try    {", "getClientOutboundChannel (  )  . send ( reply )  ;", "}    catch    (    ex )     {", "if    ( logger . isErrorEnabled (  )  )     {", "logger . error (  (  \" Failed   to   send    \"     +    message )  ,    ex )  ;", "}", "}    finally    {", "SessionInfo   info    =    this . sessions . get ( sessionId )  ;", "if    ( info    !  =    null )     {", "info . setLastWriteTime ( now )  ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["sendMessageToSubscribers"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . cacheLimit    =    cacheLimit ;", "initCacheLimitToUse (  )  ;", "}", "METHOD_END"], "methodName": ["setCacheLimit"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . headerInitializer    =    headerInitializer ;", "}", "METHOD_END"], "methodName": ["setHeaderInitializer"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( heartbeat    !  =    null )     &  &     (  (  (  ( heartbeat . length )     !  =     2  )     |  |     (  ( heartbeat [  0  ]  )     <     0  )  )     |  |     (  ( heartbeat [  1  ]  )     <     0  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Invalid   heart - beat :     \"     +     ( Arrays . toSt ( heartbeat )  )  )  )  ;", "}", "this . heartbeatValue    =    heartbeat ;", "}", "METHOD_END"], "methodName": ["setHeartbeatValue"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . pathMatcher    =    pathMatcher ;", "initPathMatcherToUse (  )  ;", "}", "METHOD_END"], "methodName": ["setPathMatcher"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . selectorHeaderName    =    selectorHeaderName ;", "initSelectorHeaderNameToUse (  )  ;", "}", "METHOD_END"], "methodName": ["setSelectorHeaderName"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( subscriptionRegistry ,     \" SubscriptionRegistry   must   not   be   null \"  )  ;", "this . subscriptionRegistry    =    subscriptionRegistry ;", "initPathMatcherToUse (  )  ;", "initCacheLimitToUse (  )  ;", "initSelectorHeaderNToUse (  )  ;", "}", "METHOD_END"], "methodName": ["setSubscriptionRegistry"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . taskScheduler    =    taskScheduler ;", "if    (  ( taskScheduler    !  =    null )     &  &     (  ( this . heartbeatValue )     =  =    null )  )     {", "this . heartbeatValue    =    new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ;", "}", "}", "METHOD_END"], "methodName": ["setTaskScheduler"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( sessionId    !  =    null )     {", ". SessionInfo   info    =    this . sessions . get ( sessionId )  ;", "if    ( info    !  =    null )     {", "info . setLastReadTime ( System . currentTimeMillis (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateSessionReadTime"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . start (  )  ;", "String   id    =     \" sess 1  \"  ;", "Message < String >    connectMessage    =    createConnectMessage ( id ,    new   TestPrincipal (  \" joe \"  )  ,    null )  ;", "this . messageHandler . setTaskScheduler ( this . taskScheduler )  ;", "this . messageHandler . handleMessage ( connectMessage )  ;", "verify ( this . clientOutboundChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "Message <  ?  >    connectAckMessage    =    this . messageCaptor . getValue (  )  ;", "SimpMessageHeaderAccessor   connectAckHeaders    =    SimpMessageHeaderAccessor . wrap ( connectAckMessage )  ;", "assertEquals ( connectMessage ,    connectAckHeaders . getHeader ( SimpMessageHeaderAccessor . CONNECT _ MESSAGE _ HEADER )  )  ;", "assertEquals ( id ,    connectAckHeaders . getSessionId (  )  )  ;", "assertEquals (  \" joe \"  ,    connectAckHeaders . getUser (  )  . getName (  )  )  ;", "assertArrayEquals ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ,    SimpMessageHeaderAccessor . getHeartbeat ( connectAckHeaders . getMessageHeaders (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create ( SimpMessageType . CONNECT )  ;", "accessor . setSessionId ( sessionId )  ;", "accessor . setUser ( user )  ;", "accessor . setHeader ( SimpMessageHeaderAccessor . HEART _ BEAT _ HEADER ,    heartbeat )  ;", "return   MessageBuilder . createMessage (  \"  \"  ,    accessor . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["createConnectMessage"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . create ( SimpMessageType . MESSAGE )  ;", "headers . setDestination ( destination )  ;", "return   MessageBuilder . createMessage ( payload ,    headers . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . create ( SimpMessageType . SUBSCRIBE )  ;", "headers . setSubscriptionId ( subcriptionId )  ;", "headers . setDestination ( destination )  ;", "headers . setSessionId ( sessionId )  ;", "return   MessageBuilder . createMessage (  \"  \"  ,    headers . getMessageHeaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["createSubscriptionMessage"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( this . messageHandler . getHeartbeatValue (  )  )  ;", "this . messageHandler . setTaskScheduler ( this . taskScheduler )  ;", "assertNotNull ( this . messageHandler . getHeartbeatValue (  )  )  ;", "assertArrayEquals ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ,    this . messageHandler . getHeartbeatValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["heartbeatValueWithAndWithoutTaskScheduler"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "for    ( Message <  ?  >    message    :    this . messageCaptor . getAllValues (  )  )     {", "SimpeaderAccessor   headers    =    SimpeaderAccessor . wrap ( message )  ;", "if    ( sessionId . equals ( headers . getSessionId (  )  )  )     {", "if    ( subcriptionId . equals ( headers . getSubscriptionId (  )  )  )     {", "if    ( destination . equals ( headers . getDestination (  )  )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["messageCaptured"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . setHeartbeatValue ( new   long [  ]  {     0  ,     1     }  )  ;", "this . messageHandler . setTaskScheduler ( this . taskScheduler )  ;", "this . messageHandler . start (  )  ;", "ArgumentCaptor < Runnable >    taskCaptor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "verify ( this . taskScheduler )  . scheduleWithFixedDelay ( taskCaptor . capture (  )  ,    eq (  1 L )  )  ;", "Runnable   heartbeatTask    =    taskCaptor . getValue (  )  ;", "assertNotNull ( heartbeatTask )  ;", "String   id    =     \" sess 1  \"  ;", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "Message < String >    connectMessage    =    createConnectMessage ( id ,    user ,    new   long [  ]  {     1  ,     0     }  )  ;", "this . messageHandler . handleMessage ( connectMessage )  ;", "Thread . sleep (  1  0  )  ;", "heartbeatTask . run (  )  ;", "verify ( this . clientOutboundChannel ,    atLeast (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "List < Message <  ?  >  >    messages    =    this . messageCaptor . getAllValues (  )  ;", "assertEquals (  2  ,    messages . size (  )  )  ;", "MessageHeaders   headers    =    messages . get (  0  )  . getHeaders (  )  ;", "assertEquals ( SimpMessageType . CONNECT _ ACK ,    headers . get ( SimpMessageHeaderAccessor . MESSAGE _ TYPE _ HEADER )  )  ;", "headers    =    messages . get (  1  )  . getHeaders (  )  ;", "assertEquals ( SimpMessageType . DISCONNECT _ ACK ,    headers . get ( SimpMessageHeaderAccessor . MESSAGE _ TYPE _ HEADER )  )  ;", "assertEquals ( id ,    headers . get ( SimpMessageHeaderAccessor . SESSION _ ID _ HEADER )  )  ;", "assertEquals ( user ,    headers . get ( SimpMessageHeaderAccessor . USER _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["readInactivity"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . setHeartbeatValue ( new   long [  ]  {     1  ,     1     }  )  ;", "this . messageHandler . setTaskScheduler ( this . taskScheduler )  ;", "this . messageHandler . start (  )  ;", "ArgumentCaptor < Runnable >    taskCaptor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "verify ( this . taskScheduler )  . scheduleWithFixedDelay ( taskCaptor . capture (  )  ,    eq (  1 L )  )  ;", "Runnable   heartbeatTask    =    taskCaptor . getValue (  )  ;", "assertNotNull ( heartbeatTask )  ;", "String   id    =     \" sess 1  \"  ;", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "Message < String >    connectMessage    =    createConnectMessage ( id ,    user ,    new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  )  ;", "this . messageHandler . handleMessage ( connectMessage )  ;", "Thread . sleep (  1  0  )  ;", "heartbeatTask . run (  )  ;", "verify ( this . clientOutboundChannel ,    times (  1  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "List < Message <  ?  >  >    messages    =    this . messageCaptor . getAllValues (  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "assertEquals ( SimpMessageType . CONNECT _ ACK ,    messages . get (  0  )  . getHeaders (  )  . get ( SimpMessageHeaderAccessor . MESSAGE _ TYPE _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["readWriteIntervalCalculation"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "this . messageHandler    =    new    ( this . clientInboundChannel ,    this . clientOutboundChannel ,    this . brokerChannel ,    Collections . emptyList (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ScheduledFuture   future    =    mock ( ScheduledFuture . class )  ;", "when ( this . taskScheduler . scheduleWithFixedDelay ( any ( Runnable . class )  ,    eq (  1  5  0  0  0 L )  )  )  . thenReturn ( future )  ;", "this . m . setTaskScheduler ( this . taskScheduler )  ;", "this . m . setHeartbeatValue ( new   long [  ]  {     1  5  0  0  0  ,     1  6  0  0  0     }  )  ;", "this . m . start (  )  ;", "verify ( this . taskScheduler )  . scheduleWithFixedDelay ( any ( Runnable . class )  ,    eq (  1  5  0  0  0 L )  )  ;", "verifyNoMoreInteractions ( this . taskScheduler ,    future )  ;", "this . m . stop (  )  ;", "verify ( future )  . cancel ( true )  ;", "verifyNoMoreInteractions ( future )  ;", "}", "METHOD_END"], "methodName": ["startAndStopWithHeartbeatValue"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . setHeartbeatValue ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  )  ;", "this . messageHandler . start (  )  ;", "}", "METHOD_END"], "methodName": ["startWithHeartbeatValueWithoutTaskScheduler"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . setTaskScheduler ( this . taskScheduler )  ;", "this . messageHandler . setHeartbeatValue ( new   long [  ]  {     0  ,     1  0  0  0  0     }  )  ;", "this . messageHandler . start (  )  ;", "verify ( this . taskScheduler )  . scheduleWithFixedDelay ( any ( Runnable . class )  ,    eq (  1  0  0  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["startWithOneZeroHeartbeatValue"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   sess 1     =     \" sess 1  \"  ;", "String   sess 2     =     \" sess 2  \"  ;", "this . m . start (  )  ;", "this . m . handleMessage ( createSubscriptionMessage ( sess 1  ,     \" sub 1  \"  ,     \"  / foo \"  )  )  ;", "this . m . handleMessage ( createSubscriptionMessage ( sess 1  ,     \" sub 2  \"  ,     \"  / foo \"  )  )  ;", "this . m . handleMessage ( createSubscriptionMessage ( sess 1  ,     \" sub 3  \"  ,     \"  / bar \"  )  )  ;", "this . m . handleMessage ( createSubscriptionMessage ( sess 2  ,     \" sub 1  \"  ,     \"  / foo \"  )  )  ;", "this . m . handleMessage ( createSubscriptionMessage ( sess 2  ,     \" sub 2  \"  ,     \"  / foo \"  )  )  ;", "this . m . handleMessage ( createSubscriptionMessage ( sess 2  ,     \" sub 3  \"  ,     \"  / bar \"  )  )  ;", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . create ( SimpMessageType . DISCONNECT )  ;", "headers . setSessionId ( sess 1  )  ;", "headers . setUser ( new   TestPrincipal (  \" joe \"  )  )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers . getMessageHeaders (  )  )  ;", "this . m . handleMessage ( message )  ;", "this . m . handleMessage ( createMessage (  \"  / foo \"  ,     \" message 1  \"  )  )  ;", "this . m . handleMessage ( createMessage (  \"  / bar \"  ,     \" message 2  \"  )  )  ;", "verify ( this . clientOutboundChannel ,    times (  4  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "Message <  ?  >    captured    =    this . messageCaptor . getAllValues (  )  . get (  0  )  ;", "assertEquals ( SimpMessageType . DISCONNECT _ ACK ,    SimpMessageHeaderAccessor . getMessageType ( captured . getHeaders (  )  )  )  ;", "assertSame ( message ,    captured . getHeaders (  )  . get ( SimpMessageHeaderAccessor . DISCONNECT _ MESSAGE _ HEADER )  )  ;", "assertEquals ( sess 1  ,    SimpMessageHeaderAccessor . getSessionId ( captured . getHeaders (  )  )  )  ;", "assertEquals (  \" joe \"  ,    SimpMessageHeaderAccessor . getUser ( captured . getHeaders (  )  )  . getName (  )  )  ;", "assertTrue ( messageCaptured ( sess 2  ,     \" sub 1  \"  ,     \"  / foo \"  )  )  ;", "assertTrue ( messageCaptured ( sess 2  ,     \" sub 2  \"  ,     \"  / foo \"  )  )  ;", "assertTrue ( messageCaptured ( sess 2  ,     \" sub 3  \"  ,     \"  / bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["subcribeDisconnectPublish"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . start (  )  ;", "this . messageHandler . handleMessage ( createSubscriptionMessage (  \" sess 1  \"  ,     \" sub 1  \"  ,     \"  / foo \"  )  )  ;", "this . messageHandler . handleMessage ( createSubscriptionMessage (  \" sess 1  \"  ,     \" sub 2  \"  ,     \"  / foo \"  )  )  ;", "this . messageHandler . handleMessage ( createSubscriptionMessage (  \" sess 1  \"  ,     \" sub 3  \"  ,     \"  / bar \"  )  )  ;", "this . messageHandler . handleMessage ( createSubscriptionMessage (  \" sess 2  \"  ,     \" sub 1  \"  ,     \"  / foo \"  )  )  ;", "this . messageHandler . handleMessage ( createSubscriptionMessage (  \" sess 2  \"  ,     \" sub 2  \"  ,     \"  / foo \"  )  )  ;", "this . messageHandler . handleMessage ( createSubscriptionMessage (  \" sess 2  \"  ,     \" sub 3  \"  ,     \"  / bar \"  )  )  ;", "this . messageHandler . handleMessage ( createMessage (  \"  / foo \"  ,     \" message 1  \"  )  )  ;", "this . messageHandler . handleMessage ( createMessage (  \"  / bar \"  ,     \" message 2  \"  )  )  ;", "verify ( this . clientOutboundChannel ,    times (  6  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "assertTrue ( messageCaptured (  \" sess 1  \"  ,     \" sub 1  \"  ,     \"  / foo \"  )  )  ;", "assertTrue ( messageCaptured (  \" sess 1  \"  ,     \" sub 2  \"  ,     \"  / foo \"  )  )  ;", "assertTrue ( messageCaptured (  \" sess 2  \"  ,     \" sub 1  \"  ,     \"  / foo \"  )  )  ;", "assertTrue ( messageCaptured (  \" sess 2  \"  ,     \" sub 2  \"  ,     \"  / foo \"  )  )  ;", "assertTrue ( messageCaptured (  \" sess 1  \"  ,     \" sub 3  \"  ,     \"  / bar \"  )  )  ;", "assertTrue ( messageCaptured (  \" sess 2  \"  ,     \" sub 3  \"  ,     \"  / bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["subcribePublish"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . messageHandler . setHeartbeatValue ( new   long [  ]  {     1  ,     0     }  )  ;", "this . messageHandler . setTaskScheduler ( this . taskScheduler )  ;", "this . messageHandler . start (  )  ;", "ArgumentCaptor < Runnable >    taskCaptor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "verify ( this . taskScheduler )  . scheduleWithFixedDelay ( taskCaptor . capture (  )  ,    eq (  1 L )  )  ;", "Runnable   heartbeatTask    =    taskCaptor . getValue (  )  ;", "assertNotNull ( heartbeatTask )  ;", "String   id    =     \" sess 1  \"  ;", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "Message < String >    connectMessage    =    createConnectMessage ( id ,    user ,    new   long [  ]  {     0  ,     1     }  )  ;", "this . messageHandler . handleMessage ( connectMessage )  ;", "Thread . sleep (  1  0  )  ;", "heartbeatTask . run (  )  ;", "verify ( this . clientOutboundChannel ,    times (  2  )  )  . send ( this . messageCaptor . capture (  )  )  ;", "List < Message <  ?  >  >    messages    =    this . messageCaptor . getAllValues (  )  ;", "assertEquals (  2  ,    messages . size (  )  )  ;", "MessageHeaders   headers    =    messages . get (  0  )  . getHeaders (  )  ;", "assertEquals ( SimpMessageType . CONNECT _ ACK ,    headers . get ( SimpMessageHeaderAccessor . MESSAGE _ TYPE _ HEADER )  )  ;", "headers    =    messages . get (  1  )  . getHeaders (  )  ;", "assertEquals ( SimpMessageType . HEARTBEAT ,    headers . get ( SimpMessageHeaderAccessor . MESSAGE _ TYPE _ HEADER )  )  ;", "assertEquals ( id ,    headers . get ( SimpMessageHeaderAccessor . SESSION _ ID _ HEADER )  )  ;", "assertEquals ( user ,    headers . get ( SimpMessageHeaderAccessor . USER _ HEADER )  )  ;", "}", "METHOD_END"], "methodName": ["writeInactivity"], "fileName": "org.springframework.messaging.simp.broker.SimpleBrokerMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . clientInboundChannel ;", "}", "METHOD_END"], "methodName": ["getClientInboundChannel"], "fileName": "org.springframework.messaging.simp.config.AbstractBrokerRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . clientOutboundChannel ;", "}", "METHOD_END"], "methodName": ["getClientOutboundChannel"], "fileName": "org.springframework.messaging.simp.config.AbstractBrokerRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationPrefixes ;", "}", "METHOD_END"], "methodName": ["getDestinationPrefixes"], "fileName": "org.springframework.messaging.simp.config.AbstractBrokerRegistration"}, {"methodBody": ["METHOD_START", "{", "ChannelRegistration   reg    =    getBrokerRegistry (  )  . getBrokerChannelRegistration (  )  ;", "ExecutorSubscribableChannel   channel    =     ( reg . hasTaskExecutor (  )  )     ?    new   ExecutorSubscribableChannel ( brokerChannelExecutor (  )  )     :    new   ExecutorSubscribableChannel (  )  ;", "reg . interceptors ( new   ImmutableMessageChannelInterceptor (  )  )  ;", "channel . setInterceptors ( reg . getInterceptors (  )  )  ;", "return   channel ;", "}", "METHOD_END"], "methodName": ["brokerChannel"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "ChannelRegistration   reg    =    getBrokerRegistry (  )  . getBrokerChannelRegistration (  )  ;", "ThreadPoolTaskExecutor   executor ;", "if    ( reg . hasTaskExecutor (  )  )     {", "executor    =    reg . taskExecutor (  )  . getTaskExecutor (  )  ;", "} else    {", "executor    =    new   ThreadPoolTaskExecutor (  )  ;", "executor . setCorePoolSize (  0  )  ;", "executor . setMaxPoolSize (  1  )  ;", "executor . setQueueCapacity (  0  )  ;", "}", "executor . setThreadNamePrefix (  \" brokerChannel -  \"  )  ;", "return   executor ;", "}", "METHOD_END"], "methodName": ["brokerChannelExecutor"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "List < MessageConverter >    converters    =    new   ArrayList <  >  (  )  ;", "boolean   registerDefaults    =    configureMessageConverters ( converters )  ;", "if    ( registerDefaults )     {", "converters . add ( new   StringMessageConverter (  )  )  ;", "converters . add ( new   ByteArrayMessageConverter (  )  )  ;", "if    (  . jackson 2 Present )     {", "converters . add ( createJacksonConverter (  )  )  ;", "}", "}", "return   new   CompositeMessageConverter ( converters )  ;", "}", "METHOD_END"], "methodName": ["brokerMessageConverter"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "SimpMessagingTemplate   template    =    new   SimpMessagingTemplate ( brokerChannel (  )  )  ;", "String   prefix    =    getBrokerRegistry (  )  . getUserDestinationPrefix (  )  ;", "if    ( prefix    !  =    null )     {", "template . setUserDestinationPrefix ( prefix )  ;", "}", "template . setMessageConverter ( brokerMessageConverter (  )  )  ;", "return   template ;", "}", "METHOD_END"], "methodName": ["brokerMessagingTemplate"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "ExecutorSubscribableChannel   channel    =    new   ExecutorSubscribableChannel ( clientInboundChannelExecutor (  )  )  ;", "ChannelRegist   reg    =    getClientInboundChannelRegist (  )  ;", "if    ( reg . hasInterceptors (  )  )     {", "channel . setInterceptors ( reg . getInterceptors (  )  )  ;", "}", "return   channel ;", "}", "METHOD_END"], "methodName": ["clientInboundChannel"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "TaskExecutorRegistration   reg    =    getClientInboundChannelRegistration (  )  . taskExecutor (  )  ;", "ThreadPoolTaskExecutor   executor    =    reg . getTaskExecutor (  )  ;", "executor . setThreadNamePrefix (  \" clientInboundChannel -  \"  )  ;", "return   executor ;", "}", "METHOD_END"], "methodName": ["clientInboundChannelExecutor"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "ExecutorSubscribableChannel   channel    =    new   ExecutorSubscribableChannel ( clientOutboundChannelExecutor (  )  )  ;", "ChannelRegist   reg    =    getClientOutboundChannelRegist (  )  ;", "if    ( reg . hasInterceptors (  )  )     {", "channel . setInterceptors ( reg . getInterceptors (  )  )  ;", "}", "return   channel ;", "}", "METHOD_END"], "methodName": ["clientOutboundChannel"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "TaskExecutorRegistration   reg    =    getClientOutboundChannelRegistration (  )  . taskExecutor (  )  ;", "ThreadPoolTaskExecutor   executor    =    reg . getTaskExecutor (  )  ;", "executor . setThreadNamePrefix (  \" clientOutboundChannel -  \"  )  ;", "return   executor ;", "}", "METHOD_END"], "methodName": ["clientOutboundChannelExecutor"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["configureMessageConverters"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpAnnotationMethodMessageHandler ( clientInboundChannel (  )  ,    clientOutboundChannel (  )  ,    brokerMessagingTemplate (  )  )  ;", "}", "METHOD_END"], "methodName": ["createAnnotationMethodMessageHandler"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "DefaultContentTypeResolver   resolver    =    new   DefaultContentTypeResolver (  )  ;", "resolver . setDefaultMimeType ( APPLICATION _ JSON )  ;", "MappingJackson 2 Converter   converter    =    new   MappingJackson 2 Converter (  )  ;", "converter . setContentTypeResolver ( resolver )  ;", "return   converter ;", "}", "METHOD_END"], "methodName": ["createJacksonConverter"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . applicationContext ;", "}", "METHOD_END"], "methodName": ["getApplicationContext"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . brokerRegistry )     =  =    null )     {", "Registry   registry    =    new   Registry ( clientInboundChannel (  )  ,    clientOutboundChannel (  )  )  ;", "configure ( registry )  ;", "this . brokerRegistry    =    registry ;", "}", "return   this . brokerRegistry ;", "}", "METHOD_END"], "methodName": ["getBrokerRegistry"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . clientInboundChannelRegistration )     =  =    null )     {", "ChannelRegistration   registration    =    new   ChannelRegistration (  )  ;", "ceClientInboundChannel ( registration )  ;", "registration . interceptors ( new   ImmutableMessageChannelInterceptor (  )  )  ;", "this . clientInboundChannelRegistration    =    registration ;", "}", "return   this . clientInboundChannelRegistration ;", "}", "METHOD_END"], "methodName": ["getClientInboundChannelRegistration"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . clientOutboundChannelRegistration )     =  =    null )     {", "ChannelRegistration   registration    =    new   ChannelRegistration (  )  ;", "ceClientOutboundChannel ( registration )  ;", "registration . interceptors ( new   ImmutableMessageChannelInterceptor (  )  )  ;", "this . clientOutboundChannelRegistration    =    registration ;", "}", "return   this . clientOutboundChannelRegistration ;", "}", "METHOD_END"], "methodName": ["getClientOutboundChannelRegistration"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   getBrokerRegistry (  )  . getPathMatcher (  )  ;", "}", "METHOD_END"], "methodName": ["getPathMatcher"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getValidator"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "ThreadPoolTaskScheduler   scheduler    =    new   ThreadPoolTaskScheduler (  )  ;", "scheduler . setThreadNamePrefix (  \"  -  \"  )  ;", "scheduler . setPoolSize ( Runtime . getRuntime (  )  . availableProcessors (  )  )  ;", "scheduler . setRemoveOnCancelPolicy ( true )  ;", "return   scheduler ;", "}", "METHOD_END"], "methodName": ["messageBrokerTaskScheduler"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "SimpAnnotationMethodMessageHandler   handler    =    createAnnotationMethodMessageHandler (  )  ;", "handler . setDestinationPrefixes ( getBrokerRegistry (  )  . getApplicationDestinationPrefixes (  )  )  ;", "handler . seConverter ( brokerMessageConverter (  )  )  ;", "handler . setValidator ( simpValidator (  )  )  ;", "List < HandlerMethodArgumentResolver >    argumentResolvers    =    new   ArrayList <  >  (  )  ;", "addArgumentResolvers ( argumentResolvers )  ;", "handler . setCustomArgumentResolvers ( argumentResolvers )  ;", "List < HandlerMethodReturnValueHandler >    returnValueHandlers    =    new   ArrayList <  >  (  )  ;", "addReturnValueHandlers ( returnValueHandlers )  ;", "handler . setCustomReturnValueHandlers ( returnValueHandlers )  ;", "PathMatcher   pathMatcher    =    getBrokerRegistry (  )  . getPathMatcher (  )  ;", "if    ( pathMatcher    !  =    null )     {", "handler . setPathMatcher ( pathMatcher )  ;", "}", "return   handler ;", "}", "METHOD_END"], "methodName": ["simpAnnotationMethodMessageHandler"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "Validator   validator    =    getValidator (  )  ;", "if    ( validator    =  =    null )     {", "if    (  (  ( this . applicationContext )     !  =    null )     &  &     ( this . applicationContext . containsBean (  . MVC _ VALIDATOR _ NAME )  )  )     {", "validator    =    this . applicationContext . getBean (  . MVC _ VALIDATOR _ NAME ,    Validator . class )  ;", "} else", "if    ( isPresent (  \" Validator \"  ,    getClass (  )  . getClassLoader (  )  )  )     {", "Class <  ?  >    clazz ;", "try    {", "String   className    =     \" OptionalValidatorFactoryBean \"  ;", "clazz    =    forName ( className ,     . class . getClassLoader (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanInitializationException (  \" Could   not   find   default   validator   class \"  ,    ex )  ;", "}", "validator    =     (  ( Validator )     ( instantiateClass ( clazz )  )  )  ;", "} else    {", "validator    =    new   Validator (  )     {", "@ Override", "public   boolean   supports ( Class <  ?  >    clazz )     {", "return   false ;", "}", "@ Override", "public   void   validate (  @ Nullable", "Object   target ,    Errors   errors )     {", "}", "}  ;", "}", "}", "return   validator ;", "}", "METHOD_END"], "methodName": ["simpValidator"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "SimpleBrokerMessageHandler   handler    =    getBrokerRegistry (  )  . getSimpleBroker ( brokerChannel (  )  )  ;", "if    ( handler    =  =    null )     {", "return   new    . NoOpBrokerMessageHandler (  )  ;", "}", "updateUserDestinationResolver ( handler )  ;", "return   handler ;", "}", "METHOD_END"], "methodName": ["simpleBrokerMessageHandler"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandler   handler    =    getBrokerRegistry (  )  . getStompBrokerRelay ( brokerChannel (  )  )  ;", "if    ( handler    =  =    null )     {", "return   new    . NoOpBrokerMessageHandler (  )  ;", "}", "Map < String ,    MessageHandler >    subscriptions    =    new   HashMap <  >  (  1  )  ;", "String   destination    =    getBrokerRegistry (  )  . getUserDestinationBroadcast (  )  ;", "if    ( destination    !  =    null )     {", "subscriptions . put ( destination ,    userDestinationMessageHandler (  )  )  ;", "}", "destination    =    getBrokerRegistry (  )  . getUserRegistryBroadcast (  )  ;", "if    ( destination    !  =    null )     {", "subscriptions . put ( destination ,    userRegistryMessageHandler (  )  )  ;", "}", "handler . setSystemSubscriptions ( subscriptions )  ;", "updateUserDestinationResolver ( handler )  ;", "return   handler ;", "}", "METHOD_END"], "methodName": ["stompBrokerRelayMessageHandler"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    prefixes    =    handler . getDestinationPrefixes (  )  ;", "if    (  (  !  ( prefixes . isEmpty (  )  )  )     &  &     (  !  ( prefixes . iterator (  )  . next (  )  . startsWith (  \"  /  \"  )  )  )  )     {", "(  ( DefaultUserDestinationResolver )     ( userDestinationResolver (  )  )  )  . setRemoveLeadingSlash ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["updateUserDestinationResolver"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "UserDestinationMessageHandler   handler    =    new   UserDestinationMessageHandler ( clientInboundChannel (  )  ,    brokerChannel (  )  ,    userDestinationResolver (  )  )  ;", "String   destination    =    getBrokerRegistry (  )  . getUserDestinationBroadcast (  )  ;", "if    ( destination    !  =    null )     {", "handler . setBroadcastDestination ( destination )  ;", "}", "return   handler ;", "}", "METHOD_END"], "methodName": ["userDestinationMessageHandler"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "DefaultUserDestinationResolver   resolver    =    new   DefaultUserDestinationResolver ( userRegistry (  )  )  ;", "String   prefix    =    getRegistry (  )  . getUserDestinationPrefix (  )  ;", "if    ( prefix    !  =    null )     {", "resolver . setUserDestinationPrefix ( prefix )  ;", "}", "return   resolver ;", "}", "METHOD_END"], "methodName": ["userDestinationResolver"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "return    ( getBrokerRegistry (  )  . getUserRegistryBroadcast (  )  )     !  =    null    ?    new   MultiServerUserRegistry ( createLocalUserRegistry (  )  )     :    createLocalUserRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["userRegistry"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getBrokerRegistry (  )  . getUserRegistryBroadcast (  )  )     =  =    null )     {", "return   new    . NoOpMessageHandler (  )  ;", "}", "SimpUserRegistry   userRegistry    =    userRegistry (  )  ;", "Assert . isInstanceOf ( MultiServerUserRegistry . class ,    userRegistry ,     \" MultiServerUserRegistry   required \"  )  ;", "return   new   UserRegistryMessageHandler (  (  ( MultiServerUserRegistry )     ( userRegistry )  )  ,    brokerMessagingTemplate (  )  ,    getBrokerRegistry (  )  . getUserRegistryBroadcast (  )  ,    messageBrokerTaskScheduler (  )  )  ;", "}", "METHOD_END"], "methodName": ["userRegistryMessageHandler"], "fileName": "org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . interceptors ;", "}", "METHOD_END"], "methodName": ["getInterceptors"], "fileName": "org.springframework.messaging.simp.config.ChannelRegistration"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . interceptors . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasInterceptors"], "fileName": "org.springframework.messaging.simp.config.ChannelRegistration"}, {"methodBody": ["METHOD_START", "{", "return    ( this . registration )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasTaskExecutor"], "fileName": "org.springframework.messaging.simp.config.ChannelRegistration"}, {"methodBody": ["METHOD_START", "{", "this . interceptors . addAll ( Arrays . asList ( interceptors )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["interceptors"], "fileName": "org.springframework.messaging.simp.config.ChannelRegistration"}, {"methodBody": ["METHOD_START", "{", "if    ( interceptors    !  =    null )     {", "this . interceptors . addAll ( Arrays . asL ( interceptors )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["setInterceptors"], "fileName": "org.springframework.messaging.simp.config.ChannelRegistration"}, {"methodBody": ["METHOD_START", "{", "return   taskExecutor ( null )  ;", "}", "METHOD_END"], "methodName": ["taskExecutor"], "fileName": "org.springframework.messaging.simp.config.ChannelRegistration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . registration )     =  =    null )     {", "this . registration    =     ( taskExecutor    !  =    null )     ?    new   TaskExecutor ( taskExecutor )     :    new   TaskExecutor (  )  ;", "}", "return   this . registration ;", "}", "METHOD_END"], "methodName": ["taskExecutor"], "fileName": "org.springframework.messaging.simp.config.ChannelRegistration"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . SimpleBrokerConfig . class )  ;", "MessageBrokerConfigurationTests . TestChannel   channel    =    context . getBean (  \" brokerChannel \"  ,    MessageBrokerConfigurationTests . TestChannel . class )  ;", "Set < MessageHandler >    handlers    =    channel . getSubscribers (  )  ;", "assertEquals (  2  ,    handlers . size (  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( UserDestinationMessageHandler . class )  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( SimpleBrokerMessageHandler . class )  )  )  ;", "assertNull ( channel . getExecutor (  )  )  ;", "}", "METHOD_END"], "methodName": ["brokerChannel"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . CustomConfig . class )  ;", "AbstractSubscribableChannel   channel    =    context . getBean (  \" brokerChannel \"  ,    AbstractSubscribableChannel . class )  ;", "assertEquals (  4  ,    channel . getInterceptors (  )  . size (  )  )  ;", "ThreadPoolTaskExecutor   taskExecutor    =    context . getBean (  \" brokerChannelExecutor \"  ,    ThreadPoolTaskExecutor . class )  ;", "assertEquals (  3  1  ,    taskExecutor . getCorePoolSize (  )  )  ;", "assertEquals (  3  2  ,    taskExecutor . getMaxPoolSize (  )  )  ;", "assertEquals (  3  3  ,    taskExecutor . getKeepAliveSeconds (  )  )  ;", "}", "METHOD_END"], "methodName": ["brokerChannelCustomized"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . SimpleBrokerConfig . class )  ;", "MessageBrokerConfigurationTests . TestChannel   channel    =    context . getBean (  \" brokerChannel \"  ,    MessageBrokerConfigurationTests . TestChannel . class )  ;", "SimpAnnotationMethodMessageHandler   messageHandler    =    context . getBean ( SimpAnnotationMethodMessageHandler . class )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SEND )  ;", "headers . setSessionId (  \" sess 1  \"  )  ;", "headers . setSessionAttributes ( new   ConcurrentHashMap <  >  (  )  )  ;", "headers . setDestination (  \"  / foo \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers . getMessageHeaders (  )  )  ;", "messageHandler . handleMessage ( message )  ;", "message    =    channel . messages . get (  0  )  ;", "headers    =    StompHeaderAccessor . wrap ( message )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    headers . getMessageType (  )  )  ;", "assertEquals (  \"  / bar \"  ,    headers . getDestination (  )  )  ;", "assertEquals (  \" bar \"  ,    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["brokerChannelUsedByAnnotatedMethod"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . BrokerRelayConfig . class )  ;", "MessageBrokerConfigurationTests . TestChannel   channel    =    context . getBean (  \" brokerChannel \"  ,    MessageBrokerConfigurationTests . TestChannel . class )  ;", "Set < MessageHandler >    handlers    =    channel . getSubscribers (  )  ;", "assertEquals (  2  ,    handlers . size (  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( UserDestinationMessageHandler . class )  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( StompBrokerRelayMessageHandler . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["brokerChannelWithBrokerRelay"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . SimpleBrokerConfig . class )  ;", "MessageBrokerConfigurationTests . TestChannel   channel    =    context . getBean (  \" clientInboundChannel \"  ,    MessageBrokerConfigurationTests . TestChannel . class )  ;", "Set < MessageHandler >    handlers    =    channel . getSubscribers (  )  ;", "assertEquals (  3  ,    handlers . size (  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( SimpAnnotationMethodMessageHandler . class )  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( UserDestinationMessageHandler . class )  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( SimpleBrokerMessageHandler . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["clientInboundChannel"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . CustomConfig . class )  ;", "AbstractSubscribableChannel   channel    =    context . getBean (  \" clientInboundChannel \"  ,    AbstractSubscribableChannel . class )  ;", "assertEquals (  3  ,    channel . getInterceptors (  )  . size (  )  )  ;", "MessageBrokerConfigurationTests . CustomThreadPoolTaskExecutor   taskExecutor    =    context . getBean (  \" clientInboundChannelExecutor \"  ,    MessageBrokerConfigurationTests . CustomThreadPoolTaskExecutor . class )  ;", "assertEquals (  1  1  ,    taskExecutor . getCorePoolSize (  )  )  ;", "assertEquals (  1  2  ,    taskExecutor . getMaxPoolSize (  )  )  ;", "assertEquals (  1  3  ,    taskExecutor . getKeepAliveSeconds (  )  )  ;", "}", "METHOD_END"], "methodName": ["clientInboundChannelCustomized"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . BrokerRelayConfig . class )  ;", "MessageBrokerConfigurationTests . TestChannel   channel    =    context . getBean (  \" clientInboundChannel \"  ,    MessageBrokerConfigurationTests . TestChannel . class )  ;", "Set < MessageHandler >    handlers    =    channel . getSubscribers (  )  ;", "assertEquals (  3  ,    handlers . size (  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( SimpAnnotationMethodMessageHandler . class )  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( UserDestinationMessageHandler . class )  )  )  ;", "assertTrue ( handlers . contains ( context . getBean ( StompBrokerRelayMessageHandler . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["clientInboundChannelWithBrokerRelay"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . CustomConfig . class )  ;", "AbstractSubscribableChannel   channel    =    context . getBean (  \" clientOutboundChannel \"  ,    AbstractSubscribableChannel . class )  ;", "assertEquals (  3  ,    channel . getInterceptors (  )  . size (  )  )  ;", "ThreadPoolTaskExecutor   taskExecutor    =    context . getBean (  \" clientOutboundChannelExecutor \"  ,    ThreadPoolTaskExecutor . class )  ;", "assertEquals (  2  1  ,    taskExecutor . getCorePoolSize (  )  )  ;", "assertEquals (  2  2  ,    taskExecutor . getMaxPoolSize (  )  )  ;", "assertEquals (  2  3  ,    taskExecutor . getKeepAliveSeconds (  )  )  ;", "}", "METHOD_END"], "methodName": ["clientOutboundChannelCustomized"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . SimpleBrokerConfig . class )  ;", "MessageBrokerConfigurationTests . TestChannel   channel    =    context . getBean (  \" clientOutboundChannel \"  ,    MessageBrokerConfigurationTests . TestChannel . class )  ;", "SimpAnnotationMethodMessageHandler   messageHandler    =    context . getBean ( SimpAnnotationMethodMessageHandler . class )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SUBSCRIBE )  ;", "headers . setSessionId (  \" sess 1  \"  )  ;", "headers . setSessionAttributes ( new   ConcurrentHashMap <  >  (  )  )  ;", "headers . setSubscriptionId (  \" subs 1  \"  )  ;", "headers . setDestination (  \"  / foo \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeaders ( headers )  . build (  )  ;", "messageHandler . handleMessage ( message )  ;", "message    =    channel . messages . get (  0  )  ;", "headers    =    StompHeaderAccessor . wrap ( message )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    headers . getMessageType (  )  )  ;", "assertEquals (  \"  / foo \"  ,    headers . getDestination (  )  )  ;", "assertEquals (  \" bar \"  ,    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["clientOutboundChannelUsedByAnnotatedMethod"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . SimpleBrokerConfig . class )  ;", "MessageBrokerConfigurationTests . TestChannel   channel    =    context . getBean (  \" clientOutboundChannel \"  ,    MessageBrokerConfigurationTests . TestChannel . class )  ;", "SimpleBrokerMessageHandler   broker    =    context . getBean ( SimpleBrokerMessageHandler . class )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SUBSCRIBE )  ;", "headers . setSessionId (  \" sess 1  \"  )  ;", "headers . setSubscriptionId (  \" subs 1  \"  )  ;", "headers . setDestination (  \"  / foo \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers . getMessageHeaders (  )  )  ;", "broker . handleMessage ( message )  ;", "headers    =    StompHeaderAccessor . create ( StompCommand . SEND )  ;", "headers . setSessionId (  \" sess 1  \"  )  ;", "headers . setDestination (  \"  / foo \"  )  ;", "message    =    MessageBuilder . createMessage (  \" bar \"  . getBytes (  )  ,    headers . getMessageHeaders (  )  )  ;", "broker . handleMessage ( message )  ;", "message    =    channel . messages . get (  0  )  ;", "headers    =    StompHeaderAccessor . wrap ( message )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    headers . getMessageType (  )  )  ;", "assertEquals (  \"  / foo \"  ,    headers . getDestination (  )  )  ;", "assertEquals (  \" bar \"  ,    new   String (  (  ( byte [  ]  )     ( message . getPayload (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["clientOutboundChannelUsedBySimpleBroker"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "final   MessageConverter   testConverter    =    mock ( MessageConverter . class )  ;", "AbstractMessageBrokerConfiguration   config    =    new    . BaseTestMessageBrokerConfig (  )     {", "@ Override", "protected   boolean   configureMessageConverters ( List < MessageConverter >    messageConverters )     {", "messageConverters . add ( testConverter )  ;", "return   false ;", "}", "}  ;", "CompositeMessageConverter   compositeConverter    =    config . brokerMessageConverter (  )  ;", "assertThat ( compositeConverter . getConverters (  )  . size (  )  ,    Matchers . is (  1  )  )  ;", "Iterator < MessageConverter >    iterator    =    compositeConverter . getConverters (  )  . iterator (  )  ;", "assertThat ( iterator . next (  )  ,    Matchers . is ( testConverter )  )  ;", "}", "METHOD_END"], "methodName": ["configureMessageConvertersCustom"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "final   MessageConverter   testConverter    =    mock ( MessageConverter . class )  ;", "AbstractMessageBrokerConfiguration   config    =    new    . BaseTestMessageBrokerConfig (  )     {", "@ Override", "protected   boolean   configureMessageConverters ( List < MessageConverter >    messageConverters )     {", "messageConverters . add ( testConverter )  ;", "return   true ;", "}", "}  ;", "CompositeMessageConverter   compositeConverter    =    config . brokerMessageConverter (  )  ;", "assertThat ( compositeConverter . getConverters (  )  . size (  )  ,    Matchers . is (  4  )  )  ;", "Iterator < MessageConverter >    iterator    =    compositeConverter . getConverters (  )  . iterator (  )  ;", "assertThat ( iterator . next (  )  ,    Matchers . is ( testConverter )  )  ;", "assertThat ( iterator . next (  )  ,    Matchers . instanceOf ( StringMessageConverter . class )  )  ;", "assertThat ( iterator . next (  )  ,    Matchers . instanceOf ( ByteArrayMessageConverter . class )  )  ;", "assertThat ( iterator . next (  )  ,    Matchers . instanceOf ( MappingJackson 2 MessageConverter . class )  )  ;", "}", "METHOD_END"], "methodName": ["configureMessageConvertersCustomAndDefault"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AbstractMessageBrokerConfiguration   config    =    new   MessageBrokerConfigurationTests . BaseTestMessageBrokerConfig (  )  ;", "CompositeMessageConverter   compositeConverter    =    config . brokerMessageConverter (  )  ;", "List < MessageConverter >    converters    =    compositeConverter . getConverters (  )  ;", "assertThat ( converters . size (  )  ,    Matchers . is (  3  )  )  ;", "assertThat ( converters . get (  0  )  ,    Matchers . instanceOf ( StringMessageConverter . class )  )  ;", "assertThat ( converters . get (  1  )  ,    Matchers . instanceOf ( ByteArrayMessageConverter . class )  )  ;", "assertThat ( converters . get (  2  )  ,    Matchers . instanceOf ( MappingJackson 2 MessageConverter . class )  )  ;", "ContentTypeResolver   resolver    =     (  ( MappingJackson 2 MessageConverter )     ( converters . get (  2  )  )  )  . getContentTypeResolver (  )  ;", "assertEquals ( APPLICATION _ JSON ,     (  ( DefaultContentTypeResolver )     ( resolver )  )  . getDefaultMimeType (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureMessageConvertersDefault"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . CustomConfig . class )  ;", "SimpAnnotationMethodMessageHandler   handler    =    context . getBean ( SimpAnnotationMethodMessageHandler . class )  ;", "List < HandlerMethodArgumentResolver >    customResolvers    =    handler . getCustomArgumentResolvers (  )  ;", "assertEquals (  1  ,    customResolvers . size (  )  )  ;", "assertTrue ( handler . getArgumentResolvers (  )  . contains ( customResolvers . get (  0  )  )  )  ;", "List < HandlerMethodReturnValueHandler >    customHandlers    =    handler . getCustomReturnValueHandlers (  )  ;", "assertEquals (  1  ,    customHandlers . size (  )  )  ;", "assertTrue ( handler . getReturnValueHandlers (  )  . contains ( customHandlers . get (  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["customArgumentAndReturnValueTypes"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . CustomConfig . class )  ;", "SimpleBrokerMessageHandler   broker    =    context . getBean ( SimpleBrokerMessageHandler . class )  ;", "DefaultSubscriptionRegistry   registry    =     (  ( DefaultSubscriptionRegistry )     ( broker . getSubscriptionRegistry (  )  )  )  ;", "assertEquals (  8  1  9  2  ,    registry . getCacheLimit (  )  )  ;", "}", "METHOD_END"], "methodName": ["customCacheLimit"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . CustomConfig . class )  ;", "SimpleBrokerMessageHandler   broker    =    context . getBean ( SimpleBrokerMessageHandler . class )  ;", "DefaultSubscriptionRegistry   registry    =     (  ( DefaultSubscriptionRegistry )     ( broker . getSubscriptionRegistry (  )  )  )  ;", "assertEquals (  \" a . a \"  ,    registry . getPathMatcher (  )  . combine (  \" a \"  ,     \" a \"  )  )  ;", "PathMatcher   pathMatcher    =    context . getBean ( SimpAnnotationMethodMessageHandler . class )  . getPathMatcher (  )  ;", "assertEquals (  \" a . a \"  ,    pathMatcher . combine (  \" a \"  ,     \" a \"  )  )  ;", "DefaultUserDestinationResolver   resolver    =    context . getBean ( DefaultUserDestinationResolver . class )  ;", "assertNotNull ( resolver )  ;", "assertEquals ( false ,    resolver . isRemoveLeadingSlash (  )  )  ;", "}", "METHOD_END"], "methodName": ["customPathMatcher"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . DotSeparatorWithDotBrokerConventionConfig . class )  ;", "testDotSeparator ( context ,    false )  ;", "}", "METHOD_END"], "methodName": ["dotSeparatorWithBrokerDotConvention"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . DotSeparatorWithSlashBrokerConventionConfig . class )  ;", "testDotSeparator ( context ,    true )  ;", "}", "METHOD_END"], "methodName": ["dotSeparatorWithBrokerSlashConvention"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "return   new   AnnotationConfigApplicationContext ( configClass )  ;", "}", "METHOD_END"], "methodName": ["loadConfig"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "final   Validator   validator    =    mock ( Validator . class )  ;", "AbstractMessageBrokerConfiguration   config    =    new    . BaseTestMessageBrokerConfig (  )     {", "@ Override", "public   Validator   getValidator (  )     {", "return   validator ;", "}", "}  ;", "assertSame ( validator ,    config . simpValidator (  )  )  ;", "}", "METHOD_END"], "methodName": ["simpValidatorCustom"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "AbstractMessageBrokerConfiguration   config    =    new   MessageBrokerConfigurationTests . BaseTestMessageBrokerConfig (  )     {  }  ;", "config . setApplicationContext ( new   StaticApplicationContext (  )  )  ;", "assertThat ( config . simpValidator (  )  ,    Matchers . notNullValue (  )  )  ;", "assertThat ( config . simpValidator (  )  ,    Matchers . instanceOf ( OptionalValidatorFactoryBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["simpValidatorDefault"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . SimpleBrokerConfig . class )  ;", "SimpAnnotationMethodMessageHandler   messageHandler    =    context . getBean ( SimpAnnotationMethodMessageHandler . class )  ;", "assertThat ( messageHandler . getValidator (  )  ,    Matchers . notNullValue ( Validator . class )  )  ;", "}", "METHOD_END"], "methodName": ["simpValidatorInjected"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "StaticApplicationContext   appCxt    =    new   StaticApplicationContext (  )  ;", "appCxt . registerSingleton (  \" mvcValidator \"  ,     . TestValidator . class )  ;", "AbstractMessageBrokerConfiguration   config    =    new    . BaseTestMessageBrokerConfig (  )     {  }  ;", "config . setApplicationContext ( appCxt )  ;", "assertThat ( config . simpValidator (  )  ,    Matchers . notNullValue (  )  )  ;", "assertThat ( config . simpValidator (  )  ,    Matchers . instanceOf (  . TestValidator . class )  )  ;", "}", "METHOD_END"], "methodName": ["simpValidatorMvc"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "MessageChannel   inChannel    =    context . getBean (  \" clientInboundChannel \"  ,    MessageChannel . class )  ;", ". TestChannel   outChannel    =    context . getBean (  \" clientOutboundChannel \"  ,     . TestChannel . class )  ;", "MessageChannel   brokerChannel    =    context . getBean (  \" brokerChannel \"  ,    MessageChannel . class )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SUBSCRIBE )  ;", "headers . setSessionId (  \" sess 1  \"  )  ;", "headers . setSubscriptionId (  \" subs 1  \"  )  ;", "headers . setDestination (  \"  / user / queue . q 1  \"  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers . getMessageHeaders (  )  )  ;", "inChannel . send ( message )  ;", "headers    =    StompHeaderAccessor . create ( StompCommand . SEND )  ;", "headers . setSessionId (  \" sess 1  \"  )  ;", "headers . setDestination (  \"  / user / sess 1  / queue . q 1  \"  )  ;", "message    =    MessageBuilder . createMessage (  \"  1  2  3  \"  . getBytes (  )  ,    headers . getMessageHeaders (  )  )  ;", "inChannel . send ( message )  ;", "assertEquals (  1  ,    outChannel . messages . size (  )  )  ;", "Message <  ?  >    outputMessage    =    outChannel . messages . remove (  0  )  ;", "headers    =    StompHeaderAccessor . wrap ( outputMessage )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    headers . getMessageType (  )  )  ;", "assertEquals (  ( expectLeadingSlash    ?     \"  / queue . q 1  - usersess 1  \"     :     \" queue . q 1  - usersess 1  \"  )  ,    headers . getDestination (  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    new   String (  (  ( byte [  ]  )     ( outputMessage . getPayload (  )  )  )  )  )  ;", "SimpMessagingTemplate   template    =    new   SimpMessagingTemplate ( brokerChannel )  ;", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . create (  )  ;", "accessor . setSessionId (  \" sess 1  \"  )  ;", "template . convertAndSendToUser (  \" sess 1  \"  ,     \" queue . q 1  \"  ,     \"  4  5  6  \"  . getBytes (  )  ,    accessor . getMessageHeaders (  )  )  ;", "assertEquals (  1  ,    outChannel . messages . size (  )  )  ;", "outputMessage    =    outChannel . messages . remove (  0  )  ;", "headers    =    StompHeaderAccessor . wrap ( outputMessage )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    headers . getMessageType (  )  )  ;", "assertEquals (  ( expectLeadingSlash    ?     \"  / queue . q 1  - usersess 1  \"     :     \" queue . q 1  - usersess 1  \"  )  ,    headers . getDestination (  )  )  ;", "assertEquals (  \"  4  5  6  \"  ,    new   String (  (  ( byte [  ]  )     ( outputMessage . getPayload (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDotSeparator"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . DefaultConfig . class )  ;", "String   name    =     \" clientInboundChannelExecutor \"  ;", "ThreadPoolTaskExecutor   executor    =    context . getBean ( name ,    ThreadPoolTaskExecutor . class )  ;", "assertEquals (  (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     2  )  ,    executor . getCorePoolSize (  )  )  ;", "name    =     \" clientOutboundChannelExecutor \"  ;", "executor    =    context . getBean ( name ,    ThreadPoolTaskExecutor . class )  ;", "assertEquals (  (  ( Runtime . getRuntime (  )  . availableProcessors (  )  )     *     2  )  ,    executor . getCorePoolSize (  )  )  ;", "name    =     \" brokerChannelExecutor \"  ;", "executor    =    context . getBean ( name ,    ThreadPoolTaskExecutor . class )  ;", "assertEquals (  0  ,    executor . getCorePoolSize (  )  )  ;", "assertEquals (  1  ,    executor . getMaxPoolSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["threadPoolSizeDefault"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . BrokerRelayConfig . class )  ;", "SimpUserRegistry   userRegistry    =    context . getBean ( SimpUserRegistry . class )  ;", "assertEquals ( MultiServerUserRegistry . class ,    userRegistry . getClass (  )  )  ;", "UserDestinationMessageHandler   handler 1     =    context . getBean ( UserDestinationMessageHandler . class )  ;", "assertEquals (  \"  / topic / unresolved - user - destination \"  ,    handler 1  . getBroadcastDestination (  )  )  ;", "UserRegistryMessageHandler   handler 2     =    context . getBean ( UserRegistryMessageHandler . class )  ;", "assertEquals (  \"  / topic / simp - user - registry \"  ,    handler 2  . getBroadcastDestination (  )  )  ;", "StompBrokerRelayMessageHandler   relay    =    context . getBean ( StompBrokerRelayMessageHandler . class )  ;", "assertNotNull ( relay . getSystemSubscriptions (  )  )  ;", "assertEquals (  2  ,    relay . getSystemSubscriptions (  )  . size (  )  )  ;", "assertSame ( handler 1  ,    relay . getSystemSubscriptions (  )  . get (  \"  / topic / unresolved - user - destination \"  )  )  ;", "assertSame ( handler 2  ,    relay . getSystemSubscriptions (  )  . get (  \"  / topic / simp - user - registry \"  )  )  ;", "}", "METHOD_END"], "methodName": ["userBroadcasts"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "ApplicationContext   context    =    loadConfig ( MessageBrokerConfigurationTests . SimpleBrokerConfig . class )  ;", "SimpUserRegistry   registry    =    context . getBean ( SimpUserRegistry . class )  ;", "assertNotNull ( registry )  ;", "assertNotEquals ( MultiServerUserRegistry . class ,    registry . getClass (  )  )  ;", "UserDestinationMessageHandler   handler    =    context . getBean ( UserDestinationMessageHandler . class )  ;", "assertNull ( handler . getBroadcastDestination (  )  )  ;", "String   name    =     \" userRegistryMessageHandler \"  ;", "MessageHandler   messageHandler    =    context . getBean ( name ,    MessageHandler . class )  ;", "assertNotEquals ( UserRegistryMessageHandler . class ,    messageHandler . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["userBroadcastsDisabledWithSimpleBroker"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerConfigurationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . brokerChannelRegistration ;", "}", "METHOD_END"], "methodName": ["configureBrokerChannel"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . simpleBrokerRegistration    =    new   SimpleBrokerRegistration ( this . clientInboundChannel ,    this . clientOutboundChannel ,    destinationPrefixes )  ;", "return   this . simpleBrokerRegistration ;", "}", "METHOD_END"], "methodName": ["enableSimpleBroker"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . brokerRelayRegistration    =    new   StompBrokerRelayRegistration ( this . clientInboundChannel ,    this . clientOutboundChannel ,    destinationPrefixes )  ;", "return   this . brokerRelayRegistration ;", "}", "METHOD_END"], "methodName": ["enableStompBrokerRelay"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "return    ( this . applicationDestinationPrefixes )     !  =    null    ?    Arrays . asList ( this . applicationDestinationPrefixes )     :    null ;", "}", "METHOD_END"], "methodName": ["getApplicationDestinationPrefixes"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . brokerChannelRegistration ;", "}", "METHOD_END"], "methodName": ["getBrokerChannelRegistration"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . pathMatcher ;", "}", "METHOD_END"], "methodName": ["getPathMatcher"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . simpleBrokerRegistration )     =  =    null )     &  &     (  ( this . brokerRelayRegistration )     =  =    null )  )     {", "enableSimpleBroker (  )  ;", "}", "if    (  ( this . simpleBrokerRegistration )     !  =    null )     {", "SimpleBrokerMessageHandler   handler    =    this . simpleBrokerRegistration . getMessageHandler ( brokerChannel )  ;", "handler . setPathMatcher ( this . pathMatcher )  ;", "handler . setCacheLimit ( this . cacheLimit )  ;", "return   handler ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSimpleBroker"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . brokerRelayRegistration )     !  =    null )     {", "return   this . brokerRelayRegistration . getMessageHandler ( brokerChannel )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getStompBrokerRelay"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "return    ( this . brokerRelayRegistration )     !  =    null    ?    this . brokerRelayRegistration . getUserDestinationBroadcast (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getUserDestinationBroadcast"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . userDestinationPrefix ;", "}", "METHOD_END"], "methodName": ["getUserDestinationPrefix"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "return    ( this . brokerRelayRegistration )     !  =    null    ?    this . brokerRelayRegistration . getUserRegistryBroadcast (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getUserRegistryBroadcast"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . applicationDestinationPrefixes    =    prefixes ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setApplicationDestinationPrefixes"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . cacheLimit    =    cacheLimit ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCacheLimit"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . pathMatcher    =    pathMatcher ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPathMatcher"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . userDestinationPrefix    =    destinationPrefix ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setUserDestinationPrefix"], "fileName": "org.springframework.messaging.simp.config.MessageBrokerRegistry"}, {"methodBody": ["METHOD_START", "{", "this . heartbeat    =    heartbeat ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHeartbeatValue"], "fileName": "org.springframework.messaging.simp.config.SimpleBrokerRegistration"}, {"methodBody": ["METHOD_START", "{", "this . selectorHeaderName    =    selectorHeaderName ;", "}", "METHOD_END"], "methodName": ["setSelectorHeaderName"], "fileName": "org.springframework.messaging.simp.config.SimpleBrokerRegistration"}, {"methodBody": ["METHOD_START", "{", "this . taskScheduler    =    taskScheduler ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTaskScheduler"], "fileName": "org.springframework.messaging.simp.config.SimpleBrokerRegistration"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandler   handler    =    new   StompBrokerRelayMessageHandler ( getClientInboundChannel (  )  ,    getClientOutboundChannel (  )  ,    brokerChannel ,    getDestinationPrefixes (  )  )  ;", "handler . setRelayHost ( this . relayHost )  ;", "handler . setRelayPort ( this . relayPort )  ;", "handler . setClientLogin ( this . clientLogin )  ;", "handler . setClientPasscode ( this . clientPasscode )  ;", "handler . setSystemLogin ( this . systemLogin )  ;", "handler . setSystemPasscode ( this . systemPasscode )  ;", "if    (  ( this . systemHeartbeatSendInterval )     !  =    null )     {", "handler . setSystemHeartbeatSendInterval ( this . systemHeartbeatSendInterval )  ;", "}", "if    (  ( this . systemHeartbeatReceiveInterval )     !  =    null )     {", "handler . setSystemHeartbeatReceiveInterval ( this . systemHeartbeatReceiveInterval )  ;", "}", "if    (  ( this . virtualHost )     !  =    null )     {", "handler . setVirtualHost ( this . virtualHost )  ;", "}", "if    (  ( this . tcpClient )     !  =    null )     {", "handler . setTcpClient ( this . tcpClient )  ;", "}", "handler . setAutoStartup ( this . autoStartup )  ;", "return   handler ;", "}", "METHOD_END"], "methodName": ["getMessageHandler"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . userDestinationBroadcast ;", "}", "METHOD_END"], "methodName": ["getUserDestinationBroadcast"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "return   this . userRegistryBroadcast ;", "}", "METHOD_END"], "methodName": ["getUserRegistryBroadcast"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "this . autoStartup    =    autoStartup ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAutoStartup"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( login ,     \" clientLogin   must   not   be   empty \"  )  ;", "this . clientLogin    =    login ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setClientLogin"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( passcode ,     \" clientPasscode   must   not   be   empty \"  )  ;", "this . clientPasscode    =    passcode ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setClientPasscode"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( relayHost ,     \" relayHost   must   not   be   empty \"  )  ;", "this . relayHost    =    relayHost ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRelayHost"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "this . relayPort    =    relayPort ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRelayPort"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "this . systemHeartbeatReceiveInterval    =    heartbeatReceiveInterval ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSystemHeartbeatReceiveInterval"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "this . systemHeartbeatSendInterval    =    systemHeartbeatSendInterval ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSystemHeartbeatSendInterval"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( login ,     \" systemLogin   must   not   be   empty \"  )  ;", "this . systemLogin    =    login ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSystemLogin"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( passcode ,     \" systemPasscode   must   not   be   empty \"  )  ;", "this . systemPasscode    =    passcode ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSystemPasscode"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "this . tcpClient    =    tcpClient ;", "}", "METHOD_END"], "methodName": ["setTcpClient"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "this . userDestinationBroadcast    =    destination ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setUserDestinationBroadcast"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "this . userRegistryBroadcast    =    destination ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setUserRegistryBroadcast"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "this . virtualHost    =    virtualHost ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setVirtualHost"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistration"}, {"methodBody": ["METHOD_START", "{", "SubscribableChannel   inChannel    =    new   StubMessageChannel (  )  ;", "MessageChannel   outChannel    =    new   StubMessageChannel (  )  ;", "String [  ]    prefixes    =    new   String [  ]  {     \"  / foo \"  ,     \"  / bar \"     }  ;", "registration    =    new    ( inChannel ,    outChannel ,    prefixes )  ;", "registration . setClientLogin (  \" clientlogin \"  )  ;", "registration . setClientPasscode (  \" clientpasscode \"  )  ;", "registration . setSystemLogin (  \" syslogin \"  )  ;", "registration . setSystemPasscode (  \" syspasscode \"  )  ;", "registration . setSystemHeartbeatReceiveInterval (  1  2  3  )  ;", "registration . setSystemHeartbeatSendInterval (  4  5  6  )  ;", "registration . setVirtualHost (  \" example . org \"  )  ;", "StompBrokerRelayMessageHandler   handler    =    registration . getMessageHandler ( new   StubMessageChannel (  )  )  ;", "assertArrayEquals ( prefixes ,    StringUtils . toStringArray ( handler . getDestinationPrefixes (  )  )  )  ;", "assertEquals (  \" clientlogin \"  ,    handler . getClientLogin (  )  )  ;", "assertEquals (  \" clientpasscode \"  ,    handler . getClientPasscode (  )  )  ;", "assertEquals (  \" syslogin \"  ,    handler . getSystemLogin (  )  )  ;", "assertEquals (  \" syspasscode \"  ,    handler . getSystemPasscode (  )  )  ;", "assertEquals (  1  2  3  ,    handler . getSystemHeartbeatReceiveInterval (  )  )  ;", "assertEquals (  4  5  6  ,    handler . getSystemHeartbeatSendInterval (  )  )  ;", "assertEquals (  \" example . org \"  ,    handler . getVirtualHost (  )  )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "org.springframework.messaging.simp.config.StompBrokerRelayRegistrationTests"}, {"methodBody": ["METHOD_START", "{", "this . corePoolSize    =    corePoolSize ;", "return   this ;", "}", "METHOD_END"], "methodName": ["corePoolSize"], "fileName": "org.springframework.messaging.simp.config.TaskExecutorRegistration"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . corePoolSize )     !  =    null )     {", "this . t . setCorePoolSize ( this . corePoolSize )  ;", "}", "if    (  ( this . maxPoolSize )     !  =    null )     {", "this . t . setMaxPoolSize ( this . maxPoolSize )  ;", "}", "if    (  ( this . keepAliveSeconds )     !  =    null )     {", "this . t . setKeepAliveSeconds ( this . keepAliveSeconds )  ;", "}", "if    (  ( this . queueCapacity )     !  =    null )     {", "this . t . setQueueCapacity ( this . queueCapacity )  ;", "}", "return   this . t ;", "}", "METHOD_END"], "methodName": ["getTaskExecutor"], "fileName": "org.springframework.messaging.simp.config.TaskExecutorRegistration"}, {"methodBody": ["METHOD_START", "{", "this . keepAliveSeconds    =    keepAliveSeconds ;", "return   this ;", "}", "METHOD_END"], "methodName": ["keepAliveSeconds"], "fileName": "org.springframework.messaging.simp.config.TaskExecutorRegistration"}, {"methodBody": ["METHOD_START", "{", "this . maxPoolSize    =    maxPoolSize ;", "return   this ;", "}", "METHOD_END"], "methodName": ["maxPoolSize"], "fileName": "org.springframework.messaging.simp.config.TaskExecutorRegistration"}, {"methodBody": ["METHOD_START", "{", "this . queueCapacity    =    queueCapacity ;", "return   this ;", "}", "METHOD_END"], "methodName": ["queueCapacity"], "fileName": "org.springframework.messaging.simp.config.TaskExecutorRegistration"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   result ;", "if    (  ( this . chunks . size (  )  )     =  =     1  )     {", "result    =    this . chunks . remove (  )  ;", "} else    {", "result    =    ByteBuffer . allocate ( getBufferSize (  )  )  ;", "for    ( ByteBuffer   partial    :    this . chunks )     {", "result . put ( partial )  ;", "}", "result . flip (  )  ;", "}", "this . chunks . clear (  )  ;", "this . expectedContentLength    =    null ;", "return   result ;", "}", "METHOD_END"], "methodName": ["assembleChunksAndReset"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoder"}, {"methodBody": ["METHOD_START", "{", "Integer   contentLength    =    this . expectedContentLength ;", "if    (  ( contentLength    !  =    null )     &  &     ( contentLength    >     ( this . bufferSizeLimit )  )  )     {", "throw   new   StompConversionException (  (  (  (  \" STOMP    ' content - length '    header   value    \"     +     ( this . expectedContentLength )  )     +     \"       exceeds   configured   buffer   size   limit    \"  )     +     ( this . bufferSizeLimit )  )  )  ;", "}", "if    (  ( getSize (  )  )     >     ( this . bufferSizeLimit )  )     {", "throw   new   StompConversionException (  (  (  \" The   configured   STOMP   buffer   size   limit   of    \"     +     ( this . bufferSizeLimit )  )     +     \"    bytes   has   been   exceeded \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkBufferLimits"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoder"}, {"methodBody": ["METHOD_START", "{", "this . chunks . add ( newBuffer )  ;", "checkBufferLimits (  )  ;", "Integer   contentLength    =    this . expectedContentLength ;", "if    (  ( contentLength    !  =    null )     &  &     (  ( getBufferSize (  )  )     <    contentLength )  )     {", "return   Collections . emptyList (  )  ;", "}", "ByteBuffer   bufferToDecode    =    assembleChunksAndReset (  )  ;", "MultiValueMap < String ,    String >    headers    =    new   util . LinkedMultiValueMap (  )  ;", "List < Message < byte [  ]  >  >    messages    =    this . stompDecoder . decode ( bufferToDecode ,    headers )  ;", "if    ( bufferToDecode . hasRemaining (  )  )     {", "this . chunks . add ( bufferToDecode )  ;", "this . expectedContentLength    =    StompHeaderAccessor . getContentLength ( headers )  ;", "}", "return   messages ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoder"}, {"methodBody": ["METHOD_START", "{", "int   size    =     0  ;", "for    ( Byte   buffer    :    this . chunks )     {", "size    =    size    +     ( buffer . remaining (  )  )  ;", "}", "return   size ;", "}", "METHOD_END"], "methodName": ["getBufferSize"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoder"}, {"methodBody": ["METHOD_START", "{", "return   this . bufferSizeLimit ;", "}", "METHOD_END"], "methodName": ["getBufferSizeLimit"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoder"}, {"methodBody": ["METHOD_START", "{", "return   this . expectedContentLength ;", "}", "METHOD_END"], "methodName": ["getExpectedContentLength"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoder"}, {"methodBody": ["METHOD_START", "{", "return   this . stompDecoder ;", "}", "METHOD_END"], "methodName": ["getStompDecoder"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoder"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "String   chunk    =     \" SEND \\ na : alpha \\ n \\ nMessage   body \\ u 0  0  0  0  \"  ;", "List < Message < byte [  ]  >  >    messages    =    stompDecoder . decode ( toByteBuffer ( chunk )  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "assertEquals (  \" Message   body \"  ,    new   String ( messages . get (  0  )  . getPayload (  )  )  )  ;", "assertEquals (  0  ,    stompDecoder . getBufferSize (  )  )  ;", "assertNull ( stompDecoder . getExpectedContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["basic"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  0  )  ;", "String   payload    =     \" SEND \\ na : alpha \\ n \\ nMessage   body \"  ;", "stompDecoder . decode ( toByteBuffer ( payload )  )  ;", "}", "METHOD_END"], "methodName": ["bufferSizeLimit"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "String   chunk    =     \" MESSAG \"  ;", "List < Message < byte [  ]  >  >    messages    =    stompDecoder . decode ( toByteBuffer ( chunk )  )  ;", "assertEquals (  0  ,    messages . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["incompleteCommand"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "String   chunk    =     \" SEND \\ na : long \\  \\  \"  ;", "List < Message < byte [  ]  >  >    messages    =    stompDecoder . decode ( toByteBuffer ( chunk )  )  ;", "assertEquals (  0  ,    messages . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["incompleteHeaderWithPartialEscapeSequence"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "String   payload    =     \" SEND \\ na : alpha \\  \\ x \\  \\ n \\ nMessage   body \\ u 0  0  0  0  \"  ;", "stompDecoder . decode ( toByteBuffer ( payload )  )  ;", "}", "METHOD_END"], "methodName": ["invalidEscapeSequence"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "String   payload    =     \" SEND \\ na : alpha \\  \\  \\ n \\ nMessage   body \\ u 0  0  0  0  \"  ;", "stompDecoder . decode ( toByteBuffer ( payload )  )  ;", "}", "METHOD_END"], "methodName": ["invalidEscapeSequenceWithSingleSlashAtEndOfHeaderValue"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "int   contentLength    =     \" Payload 2 a - Payload 2 b \"  . getBytes (  )  . length ;", "String   chunk 1     =     (  \" SEND \\ na : alpha \\ n \\ nPayload 1  \\ u 0  0  0  0 SEND \\ ncontent - length :  \"     +    contentLength )     +     \"  \\ n \"  ;", "List < Message < byte [  ]  >  >    messages    =    stompDecoder . decode ( toByteBuffer ( chunk 1  )  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "assertEquals (  \" Payload 1  \"  ,    new   String ( messages . get (  0  )  . getPayload (  )  )  )  ;", "assertEquals (  2  3  ,    stompDecoder . getBufferSize (  )  )  ;", "assertEquals ( contentLength ,     (  ( int )     ( stompDecoder . getExpectedContentLength (  )  )  )  )  ;", "String   chunk 2     =     \"  \\ nPayload 2 a \"  ;", "messages    =    stompDecoder . decode ( toByteBuffer ( chunk 2  )  )  ;", "assertEquals (  0  ,    messages . size (  )  )  ;", "assertEquals (  3  3  ,    stompDecoder . getBufferSize (  )  )  ;", "assertEquals ( contentLength ,     (  ( int )     ( stompDecoder . getExpectedContentLength (  )  )  )  )  ;", "String   chunk 3     =     \"  - Payload 2 b \\ u 0  0  0  0  \"  ;", "messages    =    stompDecoder . decode ( toByteBuffer ( chunk 3  )  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "assertEquals (  \" Payload 2 a - Payload 2 b \"  ,    new   String ( messages . get (  0  )  . getPayload (  )  )  )  ;", "assertEquals (  0  ,    stompDecoder . getBufferSize (  )  )  ;", "assertNull ( stompDecoder . getExpectedContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["oneFullAndOneSplitMessageContentLength"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "String   chunk 1     =     \" SEND \\ na : alpha \\ n \\ nPayload 1  \\ u 0  0  0  0 SEND \\ na : alpha \\ n \"  ;", "List < Message < byte [  ]  >  >    messages    =    stompDecoder . decode ( toByteBuffer ( chunk 1  )  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "assertEquals (  \" Payload 1  \"  ,    new   String ( messages . get (  0  )  . getPayload (  )  )  )  ;", "assertEquals (  1  3  ,    stompDecoder . getBufferSize (  )  )  ;", "assertNull ( stompDecoder . getExpectedContentLength (  )  )  ;", "String   chunk 2     =     \"  \\ nPayload 2 a \"  ;", "messages    =    stompDecoder . decode ( toByteBuffer ( chunk 2  )  )  ;", "assertEquals (  0  ,    messages . size (  )  )  ;", "assertEquals (  2  3  ,    stompDecoder . getBufferSize (  )  )  ;", "assertNull ( stompDecoder . getExpectedContentLength (  )  )  ;", "String   chunk 3     =     \"  - Payload 2 b \\ u 0  0  0  0  \"  ;", "messages    =    stompDecoder . decode ( toByteBuffer ( chunk 3  )  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "assertEquals (  \" Payload 2 a - Payload 2 b \"  ,    new   String ( messages . get (  0  )  . getPayload (  )  )  )  ;", "assertEquals (  0  ,    stompDecoder . getBufferSize (  )  )  ;", "assertNull ( stompDecoder . getExpectedContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["oneFullAndOneSplitMessageNoContentLength"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "String   chunk 1     =     \" SEND \\ na : alpha \\ n \\ nPayload 1  \\ u 0  0  0  0 SEND \\ ncontent - length :  1  2  9  \\ n \"  ;", "List < Message < byte [  ]  >  >    messages    =    stompDecoder . decode ( toByteBuffer ( chunk 1  )  )  ;", "assertEquals (  \" We   should   have   gotten   the    1 st   message \"  ,     1  ,    messages . size (  )  )  ;", "assertEquals (  \" Payload 1  \"  ,    new   String ( messages . get (  0  )  . getPayload (  )  )  )  ;", "assertEquals (  2  4  ,    stompDecoder . getBufferSize (  )  )  ;", "assertEquals (  1  2  9  ,     (  ( int )     ( stompDecoder . getExpectedContentLength (  )  )  )  )  ;", "try    {", "String   chunk 2     =     \"  \\ nPayload 2 a \"  ;", "stompDecoder . decode ( toByteBuffer ( chunk 2  )  )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( StompConversionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["oneFullAndOneSplitWithContentLengthExceedingBufferSize"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "String   chunk 1     =     \" SEND \\ na : alpha \\ n \\ nMessage \"  ;", "String   chunk 2     =     \"    body \\ u 0  0  0  0  \"  ;", "List < Message < byte [  ]  >  >    messages    =    stompDecoder . decode ( toByteBuffer ( chunk 1  )  )  ;", "assertEquals ( Collections .  < Message < byte [  ]  >  > emptyList (  )  ,    messages )  ;", "messages    =    stompDecoder . decode ( toByteBuffer ( chunk 2  )  )  ;", "assertEquals (  1  ,    messages . size (  )  )  ;", "assertEquals (  \" Message   body \"  ,    new   String ( messages . get (  0  )  . getPayload (  )  )  )  ;", "assertEquals (  0  ,    stompDecoder . getBufferSize (  )  )  ;", "assertNull ( stompDecoder . getExpectedContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["oneMessageInTwoChunks"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "return   ByteBuffer . wrap ( chunk . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["toByteBuffer"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "BufferingStompDecoder   stompDecoder    =    new   BufferingStompDecoder ( STOMP _ DECODER ,     1  2  8  )  ;", "String   chunk    =     \" SEND \\ na : alpha \\ n \\ nPayload 1  \\ u 0  0  0  0  \"     +     \" SEND \\ na : alpha \\ n \\ nPayload 2  \\ u 0  0  0  0  \"  ;", "List < Message < byte [  ]  >  >    messages    =    stompDecoder . decode ( toByteBuffer ( chunk )  )  ;", "assertEquals (  2  ,    messages . size (  )  )  ;", "assertEquals (  \" Payload 1  \"  ,    new   String ( messages . get (  0  )  . getPayload (  )  )  )  ;", "assertEquals (  \" Payload 2  \"  ,    new   String ( messages . get (  1  )  . getPayload (  )  )  )  ;", "assertEquals (  0  ,    stompDecoder . getBufferSize (  )  )  ;", "assertNull ( stompDecoder . getExpectedContentLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["twoMessagesInOneChunk"], "fileName": "org.springframework.messaging.simp.stomp.BufferingStompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "String   receiptId    =    headers . getReceipt (  )  ;", "if    (  ( isAutoReceiptEnabled (  )  )     &  &     ( receiptId    =  =    null )  )     {", "receiptId    =    String . valueOf ( this . receiptIndex . getAndIncrement (  )  )  ;", "headers . setReceipt ( receiptId )  ;", "}", "return   receiptId ;", "}", "METHOD_END"], "methodName": ["checkOrAddReceipt"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( command )  ;", "accessor . setId ( this . sessionId )  ;", "accessor . setLeaveMutable ( true )  ;", "return   accessor ;", "}", "METHOD_END"], "methodName": ["createHeaderAccessor"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "accessor . updateSimpMessageHeadersFromStompHeaders (  )  ;", "Message < byte [  ]  >    message ;", "if    ( payload    =  =    null )     {", "message    =    MessageBuilder . createMessage ( DefaultStompSession . EMPTY _ PAYLOAD ,    accessor . getMessageHeaders (  )  )  ;", "} else", "if    ( payload   instanceof   byte [  ]  )     {", "message    =    MessageBuilder . createMessage (  (  ( byte [  ]  )     ( payload )  )  ,    accessor . getMessageHeaders (  )  )  ;", "} else    {", "message    =     (  ( Message < byte [  ]  >  )     ( getMessageConverter (  )  . toMessage ( payload ,    accessor . getMessageHeaders (  )  )  )  )  ;", "accessor . updateStompHeadersFromSimpMessageHeaders (  )  ;", "if    ( message    =  =    null )     {", "throw   new   converter . MessageConversionException (  (  (  (  (  (  (  \" Unable   to   convert   payload   with   type =  '  \"     +     ( payload . getClass (  )  . getName (  )  )  )     +     \"  '  ,    contentType =  '  \"  )     +     ( accessor . getContentType (  )  )  )     +     \"  '  ,    converter =  [  \"  )     +     ( getMessageConverter (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "}", "return   message ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "if    ( DefaultStompSession . logger . isTraceEnabled (  )  )     {", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "if    ( accessor    !  =    null )     {", "DefaultStompSession . logger . trace (  (  \" Sending    \"     +     ( accessor . getDetailedLogMessage ( message . getPayload (  )  )  )  )  )  ;", "}", "}", "TcpConnection < byte [  ]  >    conn    =    this . connection ;", "Assert . state (  ( conn    !  =    null )  ,     \" Connection   closed \"  )  ;", "try    {", "conn . send ( message )  . get (  )  ;", "}    catch    ( ExecutionException   ex )     {", "throw   new   MessageDeliveryException ( message ,    ex . getCause (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   MessageDeliveryException ( message ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "return   this . converter ;", "}", "METHOD_END"], "methodName": ["getMessageConverter"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "return   this . receiptTimeLimit ;", "}", "METHOD_END"], "methodName": ["getReceiptTimeLimit"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "return   this . sessionHandler ;", "}", "METHOD_END"], "methodName": ["getSessionHandler"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "return   this . taskScheduler ;", "}", "METHOD_END"], "methodName": ["getTaskScheduler"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "long [  ]    connect    =    this . connectHeaders . getHeartbeat (  )  ;", "long [  ]    connected    =    connectedHeaders . getHeartbeat (  )  ;", "if    (  ( connect    =  =    null )     |  |     ( connected    =  =    null )  )     {", "return ;", "}", "TcpConnection < byte [  ]  >    con    =    this . connection ;", "Assert . state (  ( con    !  =    null )  ,     \" No   TcpConnection   available \"  )  ;", "if    (  (  ( connect [  0  ]  )     >     0  )     &  &     (  ( connected [  1  ]  )     >     0  )  )     {", "long   interval    =    Math . max ( connect [  0  ]  ,    connected [  1  ]  )  ;", "con . onWriteInactivity ( new    . WriteInactivityTask (  )  ,    interval )  ;", "}", "if    (  (  ( connect [  1  ]  )     >     0  )     &  &     (  ( connected [  0  ]  )     >     0  )  )     {", "long   interval    =     ( Math . max ( connect [  1  ]  ,    connected [  0  ]  )  )     *     (  . HEARTBEAT _ MULTIPLIER )  ;", "con . onReadInactivity ( new    . ReadInactivityTask (  )  ,    interval )  ;", "}", "}", "METHOD_END"], "methodName": ["initHeartbeatTasks"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "if    (  ( message . getPayload (  )  . length )     =  =     0  )     {", "handler . handleFrame ( headers ,    null )  ;", "return ;", "}", "Type   payloadType    =    handler . getPayloadType ( headers )  ;", "Class <  ?  >    resolvedType    =    ResolvableType . forType ( payloadType )  . resolve (  )  ;", "if    ( resolvedType    =  =    null )     {", "throw   new   MessageConversionException (  (  (  (  (  \" Unresolvable   payload   type    [  \"     +    payloadType )     +     \"  ]    from   handler   type    [  \"  )     +     ( handler . getClass (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "Object   object    =    getMessageConverter (  )  . fromMessage ( message ,    resolvedType )  ;", "if    ( object    =  =    null )     {", "throw   new   MessageConversionException (  (  (  (  (  \" No   suitable   converter   for   payload   type    [  \"     +    payloadType )     +     \"  ]    from   handler   type    [  \"  )     +     ( handler . getClass (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "handler . handleFrame ( headers ,    object )  ;", "}", "METHOD_END"], "methodName": ["invokeHandler"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "return   this . autoReceiptEnabled ;", "}", "METHOD_END"], "methodName": ["isAutoReceiptEnabled"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "TcpConnection <  ?  >    conn    =    this . connection ;", "this . connection    =    null ;", "if    ( conn    !  =    null )     {", "try    {", "conn . close (  )  ;", "}    catch    ( Throwable   ex )     {", "}", "}", "}", "METHOD_END"], "methodName": ["resetConnection"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( messageConverter ,     \" MessageConverter   must   not   be   null \"  )  ;", "this . converter    =    messageConverter ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( receiptTimeLimit    >     0  )  ,     \" Receipt   time   limit   must   be   larger   than   zero \"  )  ;", "this . receiptTimeLimit    =    receiptTimeLimit ;", "}", "METHOD_END"], "methodName": ["setReceiptTimeLimit"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "this . taskScheduler    =    taskScheduler ;", "}", "METHOD_END"], "methodName": ["setTaskScheduler"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    createHeaderAccessor ( StompCommand . UNSUBSCRIBE )  ;", "if    ( headers    !  =    null )     {", "accessor . addNativeHeaders ( headers )  ;", "}", "accessor . setSubscriptionId ( id )  ;", "Message < byte [  ]  >    message    =    createMessage ( accessor ,     . EMPTY _ PAYLOAD )  ;", "execute ( message )  ;", "}", "METHOD_END"], "methodName": ["unsubscribe"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSession"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "StringeId    =     \"  1  2  3  \"  ;", "this . session . acknowledgeeId ,    true )  ;", "Message < byte [  ]  > e    =    thiseCaptor . getValue (  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessore ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . ACK ,    accessor . getCommand (  )  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "assertEquals ( stompHeaders . toString (  )  ,     1  ,    stompHeaders . size (  )  )  ;", "assertEqualseId ,    stompHeaders . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["ack"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "IllegalStateException   exception    =    new   IllegalStateException (  \" simulated   exception \"  )  ;", "this . s . afterConnectFailure ( exception )  ;", "verify ( this . sHandler )  . handleTransportError ( this . s ,    exception )  ;", "verifyNoMoreInteractions ( this . sHandler )  ;", "}", "METHOD_END"], "methodName": ["afterConnectFailure"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( this . session . isConnected (  )  )  ;", "this . connectHeaders . setHost (  \" my - host \"  )  ;", "this . connectHeaders . setHeartbeat ( new   long [  ]  {     1  1  ,     1  2     }  )  ;", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "Message < byte [  ]  > e    =    thiseCaptor . getValue (  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessore ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . CONNECT ,    accessor . getCommand (  )  )  ;", "assertEquals (  \" my - host \"  ,    accessor . getHost (  )  )  ;", "assertThat ( accessor . getAcceptVersion (  )  ,    containsInAnyOrder (  \"  1  .  1  \"  ,     \"  1  .  2  \"  )  )  ;", "assertArrayEquals ( new   long [  ]  {     1  1  ,     1  2     }  ,    accessor . getHeartbeat (  )  )  ;", "}", "METHOD_END"], "methodName": ["afterConnected"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnectionClosed (  )  ;", "verify ( this . sessionHandler )  . handleTransportError ( same ( this . session )  ,    any ( ConnectionLostException . class )  )  ;", "verifyNoMoreInteractions ( this . sessionHandler )  ;", "}", "METHOD_END"], "methodName": ["afterConnectionClosed"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "this . session . disconnect (  )  ;", "assertFalse ( this . session . isConnected (  )  )  ;", "verifyNoMoreInteractions ( this . sessionHandler )  ;", "}", "METHOD_END"], "methodName": ["disconnect"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "this . connectHeaders . setHeartbeat ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . CONNECTED )  ;", "accessor . setVersion (  \"  1  .  2  \"  )  ;", "accessor . setHeartbeat (  1  0  0  0  0  ,     1  0  0  0  0  )  ;", "accessor . setLeaveMutable ( true )  ;", "this . session . handleMessage ( MessageBuilder . createMessage ( new   byte [  0  ]  ,    accessor . getMessageHeaders (  )  )  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "verify ( this . sessionHandler )  . afterConnected ( this . session ,    stompHeaders )  ;", "verifyNoMoreInteractions ( this . sessionHandler )  ;", "}", "METHOD_END"], "methodName": ["handleConnectedFrame"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . ERROR )  ;", "accessor . setContentType ( new   MimeType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . UTF _  8  )  )  ;", "accessor . addNativeHeader (  \" foo \"  ,     \" bar \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "String   payload    =     \" Oops \"  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "when ( this . sHandler . getPayloadType ( stompHeaders )  )  . thenReturn ( String . class )  ;", "this . s . handleMessage ( MessageBuilder . createMessage ( payload . getBytes ( StandardCharsets . UTF _  8  )  ,    accessor . getMessageHeaders (  )  )  )  ;", "verify ( this . sHandler )  . getPayloadType ( stompHeaders )  ;", "verify ( this . sHandler )  . handleFrame ( stompHeaders ,    payload )  ;", "verifyNoMoreInteractions ( this . sHandler )  ;", "}", "METHOD_END"], "methodName": ["handleErrorFrame"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . ERROR )  ;", "accessor . setContentType ( APPLICATION _ JSON )  ;", "accessor . addNativeHeader (  \" foo \"  ,     \" bar \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "byte [  ]    payload    =     \"  {  ' foo '  :  ' bar '  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "when ( this . sHandler . getPayloadType ( stompHeaders )  )  . thenReturn ( Map . class )  ;", "this . s . handleMessage ( MessageBuilder . createMessage ( payload ,    accessor . getMessageHeaders (  )  )  )  ;", "verify ( this . sHandler )  . getPayloadType ( stompHeaders )  ;", "verify ( this . sHandler )  . handleException ( same ( this . s )  ,    same ( StompCommand . ERROR )  ,    eq ( stompHeaders )  ,    same ( payload )  ,    any ( MessageConversionException . class )  )  ;", "verifyNoMoreInteractions ( this . sHandler )  ;", "}", "METHOD_END"], "methodName": ["handleErrorFrameWithConversionException"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . ERROR )  ;", "accessor . addNativeHeader (  \" foo \"  ,     \" bar \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "this . s . handleMessage ( MessageBuilder . createMessage ( new   byte [  0  ]  ,    accessor . getMessageHeaders (  )  )  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "verify ( this . sHandler )  . handleFrame ( stompHeaders ,    null )  ;", "verifyNoMoreInteractions ( this . sHandler )  ;", "}", "METHOD_END"], "methodName": ["handleErrorFrameWithEmptyPayload"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "IllegalStateException   exception    =    new   IllegalStateException (  \" simulated   exception \"  )  ;", "this . s . handleFailure ( exception )  ;", "verify ( this . sHandler )  . handleTransportError ( this . s ,    exception )  ;", "verifyNoMoreInteractions ( this . sHandler )  ;", "}", "METHOD_END"], "methodName": ["handleFailure"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "StompFrameHandler   frameHandler    =    mock ( StompFrameHandler . class )  ;", "String   destination    =     \"  / topic / foo \"  ;", ". Subscription   subscription    =    this . session . subscribe ( destination ,    frameHandler )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . MESSAGE )  ;", "accessor . setDestination ( destination )  ;", "accessor . setSubscriptionId ( subscription . getSubscriptionId (  )  )  ;", "accessor . setContentType ( TEXT _ PLAIN )  ;", "accessor . setMessageId (  \"  1  \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "String   payload    =     \" sample   payload \"  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "when ( frameHandler . getPayloadType ( stompHeaders )  )  . thenReturn ( String . class )  ;", "this . session . handleMessage ( MessageBuilder . createMessage ( payload . getBytes ( StandardCharsets . UTF _  8  )  ,    accessor . getMessageHeaders (  )  )  )  ;", "verify ( frameHandler )  . getPayloadType ( stompHeaders )  ;", "verify ( frameHandler )  . handleFrame ( stompHeaders ,    payload )  ;", "verifyNoMoreInteractions ( frameHandler )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFrame"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "StompFrameHandler   frameHandler    =    mock ( StompFrameHandler . class )  ;", "String   destination    =     \"  / topic / foo \"  ;", ". Subscription   subscription    =    this . session . subscribe ( destination ,    frameHandler )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . MESSAGE )  ;", "accessor . setDestination ( destination )  ;", "accessor . setSubscriptionId ( subscription . getSubscriptionId (  )  )  ;", "accessor . setContentType ( APPLICATION _ JSON )  ;", "accessor . setMessageId (  \"  1  \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "byte [  ]    payload    =     \"  {  ' foo '  :  ' bar '  }  \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "when ( frameHandler . getPayloadType ( stompHeaders )  )  . thenReturn ( Map . class )  ;", "this . session . handleMessage ( MessageBuilder . createMessage ( payload ,    accessor . getMessageHeaders (  )  )  )  ;", "verify ( frameHandler )  . getPayloadType ( stompHeaders )  ;", "verifyNoMoreInteractions ( frameHandler )  ;", "verify ( this . sessionHandler )  . handleException ( same ( this . session )  ,    same ( StompCommand . MESSAGE )  ,    eq ( stompHeaders )  ,    same ( payload )  ,    any ( MessageConversionException . class )  )  ;", "verifyNoMoreInteractions ( this . sessionHandler )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFrameWithConversionException"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "verify ( this . connection )  . send ( any (  )  )  ;", "this . connectHeaders . setHeartbeat ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . CONNECTED )  ;", "accessor . setVersion (  \"  1  .  2  \"  )  ;", "accessor . setHeartbeat (  0  ,     0  )  ;", "accessor . setLeaveMutable ( true )  ;", "this . session . handleMessage ( MessageBuilder . createMessage ( new   byte [  0  ]  ,    accessor . getMessageHeaders (  )  )  )  ;", "verifyNoMoreInteractions ( this . connection )  ;", "}", "METHOD_END"], "methodName": ["heartbeatNotSupportedByServer"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "verify ( this . connection )  . send ( any (  )  )  ;", "this . connectHeaders . setHeartbeat ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  )  ;", "StompHeaderAccessor   connected    =    StompHeaderAccessor . create ( StompCommand . CONNECTED )  ;", "connected . setVersion (  \"  1  .  2  \"  )  ;", "connected . setHeartbeat (  1  0  0  0  0  ,     1  0  0  0  0  )  ;", "connected . setLeaveMutable ( true )  ;", "this . session . handleMessage ( MessageBuilder . createMessage ( new   byte [  0  ]  ,    connected . getMessageHeaders (  )  )  )  ;", "ArgumentCaptor < Runnable >    writeTaskCaptor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "ArgumentCaptor < Runnable >    readTaskCaptor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "verify ( this . connection )  . onWriteInactivity ( writeTaskCaptor . capture (  )  ,    any ( Long . class )  )  ;", "verify ( this . connection )  . onReadInactivity ( readTaskCaptor . capture (  )  ,    any ( Long . class )  )  ;", "Runnable   writeTask    =    writeTaskCaptor . getValue (  )  ;", "Runnable   readTask    =    readTaskCaptor . getValue (  )  ;", "assertNotNull ( writeTask )  ;", "assertNotNull ( readTask )  ;", "writeTask . run (  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . createForHeartbeat (  )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage ( new   byte [  ]  {     '  \\ n '     }  ,    accessor . getMessageHeaders (  )  )  ;", "verify ( this . connection )  . send ( eq ( message )  )  ;", "verifyNoMoreInteractions ( this . connection )  ;", "reset ( this . sessionHandler )  ;", "readTask . run (  )  ;", "verify ( this . sessionHandler )  . handleTransportError ( same ( this . session )  ,    any ( IllegalStateException . class )  )  ;", "verifyNoMoreInteractions ( this . sessionHandler )  ;", "}", "METHOD_END"], "methodName": ["heartbeatTasks"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "this . connectHeaders . setHeartbeat ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . CONNECTED )  ;", "accessor . setVersion (  \"  1  .  2  \"  )  ;", "accessor . setHeartbeat (  2  0  0  0  0  ,     2  0  0  0  0  )  ;", "accessor . setLeaveMutable ( true )  ;", "this . session . handleMessage ( MessageBuilder . createMessage ( new   byte [  0  ]  ,    accessor . getMessageHeaders (  )  )  )  ;", "ArgumentCaptor < Long >    writeInterval    =    ArgumentCaptor . forClass ( Long . class )  ;", "verify ( this . connection )  . onWriteInactivity ( any ( Runnable . class )  ,    writeInterval . capture (  )  )  ;", "assertEquals (  2  0  0  0  0  ,     (  ( long )     ( writeInterval . getValue (  )  )  )  )  ;", "ArgumentCaptor < Long >    readInterval    =    ArgumentCaptor . forClass ( Long . class )  ;", "verify ( this . connection )  . onReadInactivity ( any ( Runnable . class )  ,    readInterval . capture (  )  )  ;", "assertEquals (  6  0  0  0  0  ,     (  ( long )     ( readInterval . getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["heartbeatValues"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "StringeId    =     \"  1  2  3  \"  ;", "this . session . acknowledgeeId ,    false )  ;", "Message < byte [  ]  > e    =    thiseCaptor . getValue (  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessore ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . NACK ,    accessor . getCommand (  )  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "assertEquals ( stompHeaders . toString (  )  ,     1  ,    stompHeaders . size (  )  )  ;", "assertEqualseId ,    stompHeaders . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["nack"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "TaskScheduler   taskScheduler    =    mock ( TaskScheduler . class )  ;", "this . session . afterConnected ( this . connection )  ;", "this . session . setTaskScheduler ( taskScheduler )  ;", "AtomicReference < Boolean >    notReceived    =    new   AtomicReference <  >  (  )  ;", "ScheduledFuture   future    =    mock ( ScheduledFuture . class )  ;", "when ( taskScheduler . schedule ( any ( Runnable . class )  ,    any ( Date . class )  )  )  . thenReturn ( future )  ;", "StompHeaders   headers    =    new   StompHeaders (  )  ;", "headers . setDestination (  \"  / topic / foo \"  )  ;", "headers . setReceipt (  \" my - receipt \"  )  ;", ". Receiptable   receiptable    =    this . session . send ( headers ,     \" payload \"  )  ;", "receiptable . addReceiptLostTask (  (  )     -  >    notReceived . set ( true )  )  ;", "ArgumentCaptor < Runnable >    taskCaptor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "verify ( taskScheduler )  . schedule ( taskCaptor . capture (  )  ,     (  ( Date )     ( notNull (  )  )  )  )  ;", "Runnable   scheduledTask    =    taskCaptor . getValue (  )  ;", "assertNotNull ( scheduledTask )  ;", "assertNull ( notReceived . get (  )  )  ;", "scheduledTask . run (  )  ;", "assertTrue ( notReceived . get (  )  )  ;", "verify ( future )  . cancel ( true )  ;", "verifyNoMoreInteractions ( future )  ;", "}", "METHOD_END"], "methodName": ["receiptNotReceived"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "this . session . setTaskScheduler ( mock ( TaskScheduler . class )  )  ;", "AtomicReference < Boolean >    received    =    new   AtomicReference <  >  (  )  ;", "StompHeaders   headers    =    new   StompHeaders (  )  ;", "headers . setDestination (  \"  / topic / foo \"  )  ;", "headers . setReceipt (  \" my - receipt \"  )  ;", ". Subscription   subscription    =    this . session . subscribe ( headers ,    mock ( StompFrameHandler . class )  )  ;", "subscription . addReceiptTask (  (  )     -  >    received . set ( true )  )  ;", "assertNull ( received . get (  )  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . RECEIPT )  ;", "accessor . setReceiptId (  \" my - receipt \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "this . session . handleMessage ( MessageBuilder . createMessage ( new   byte [  0  ]  ,    accessor . getMessageHeaders (  )  )  )  ;", "assertNotNull ( received . get (  )  )  ;", "assertTrue ( received . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["receiptReceived"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "this . session . setTaskScheduler ( mock ( TaskScheduler . class )  )  ;", "AtomicReference < Boolean >    received    =    new   AtomicReference <  >  (  )  ;", "StompHeaders   headers    =    new   StompHeaders (  )  ;", "headers . setDestination (  \"  / topic / foo \"  )  ;", "headers . setReceipt (  \" my - receipt \"  )  ;", ". Subscription   subscription    =    this . session . subscribe ( headers ,    mock ( StompFrameHandler . class )  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . RECEIPT )  ;", "accessor . setReceiptId (  \" my - receipt \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "this . session . handleMessage ( MessageBuilder . createMessage ( new   byte [  0  ]  ,    accessor . getMessageHeaders (  )  )  )  ;", "subscription . addReceiptTask (  (  )     -  >    received . set ( true )  )  ;", "assertNotNull ( received . get (  )  )  ;", "assertTrue ( received . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["receiptReceivedBeforeTaskAdded"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "String   destination    =     \"  / topic / foo \"  ;", "String   payload    =     \" sample   payload \"  ;", "this . session . send ( destination ,    payload )  ;", "Message < byte [  ]  > e    =    thiseCaptor . getValue (  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessore ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . SEND ,    accessor . getCommand (  )  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "assertEquals ( stompHeaders . toString (  )  ,     2  ,    stompHeaders . size (  )  )  ;", "assertEquals ( destination ,    stompHeaders . getDestination (  )  )  ;", "assertEquals ( new   MimeType (  \" text \"  ,     \" plain \"  ,    StandardCharsets . UTF _  8  )  ,    stompHeaders . getContentType (  )  )  ;", "assertEquals (  (  -  1  )  ,    stompHeaders . getContentLength (  )  )  ;", "assertEquals ( payload ,    new   Stringe . getPayload (  )  ,    StandardCharsets . UTF _  8  )  )  ;", "}", "METHOD_END"], "methodName": ["send"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "StompHeaders   stompHeaders    =    new   StompHeaders (  )  ;", "stompHeaders . setDestination (  \"  / topic / foo \"  )  ;", "stompHeaders . setContentType ( APPLICATION _ JSON )  ;", "String   payload    =     \"  {  ' foo '  :  ' bar '  }  \"  ;", "this . expected . expect ( MessageConversionException . class )  ;", "this . session . send ( stompHeaders ,    payload )  ;", "verifyNoMoreInteractions ( this . connection )  ;", "}", "METHOD_END"], "methodName": ["sendWithConversionException"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "IllegalStateException   exception    =    new   IllegalStateException (  \" simulated   exception \"  )  ;", "SettableListenableFuture < Void >    future    =    new   SettableListenableFuture (  )  ;", "future . setException ( exception )  ;", "when ( this . connection . send ( any (  )  )  )  . thenReturn ( future )  ;", "this . expected . expect ( MessageDeliveryException . class )  ;", "this . expected . expectCause ( Matchers . sameInstance ( exception )  )  ;", "this . session . send (  \"  / topic / foo \"  ,     \" sample   payload \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "verifyNoMoreInteractions ( this . connection )  ;", "}", "METHOD_END"], "methodName": ["sendWithExecutionException"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "this . session . setTaskScheduler ( mock ( TaskScheduler . class )  )  ;", "this . session . setAutoReceipt ( true )  ;", "this . session . send (  \"  / topic / foo \"  ,     \" sample   payload \"  )  ;", "Message < byte [  ]  > e    =    thiseCaptor . getValue (  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessore ,    StompHeaderAccessor . class )  ;", "assertNotNull ( accessor . getReceipt (  )  )  ;", "StompHeaders   stompHeaders    =    new   StompHeaders (  )  ;", "stompHeaders . setDestination (  \"  / topic / foo \"  )  ;", "stompHeaders . setReceipt (  \" my - receipt \"  )  ;", "this . session . send ( stompHeaders ,     \" sample   payload \"  )  ;", "e    =    thiseCaptor . getValue (  )  ;", "accessor    =    MessageHeaderAccessor . getAccessore ,    StompHeaderAccessor . class )  ;", "assertEquals (  \" my - receipt \"  ,    accessor . getReceipt (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendWithReceipt"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "this . sessionHandler    =    mock ( StompSessionHandler . class )  ;", "this . connectHeaders    =    new   StompHeaders (  )  ;", "this . session    =    new    ( this . sessionHandler ,    this . connectHeaders )  ;", "this . session . setMessageConverter ( new   StringMessageConverter (  )  )  ;", "SettableListenableFuture < Void >    future    =    new   SettableListenableFuture (  )  ;", "future . set ( null )  ;", "when ( this . connection . send ( this . messageCaptor . capture (  )  )  )  . thenReturn ( future )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "String   destination    =     \"  / topic / foo \"  ;", "StompFrameHandler   frameHandler    =    mock ( StompFrameHandler . class )  ;", ". Subscription   subscription    =    this . session . subscribe ( destination ,    frameHandler )  ;", "Message < byte [  ]  >    message    =    this . messageCaptor . getValue (  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . SUBSCRIBE ,    accessor . getCommand (  )  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "assertEquals ( stompHeaders . toString (  )  ,     2  ,    stompHeaders . size (  )  )  ;", "assertEquals ( destination ,    stompHeaders . getDestination (  )  )  ;", "assertEquals ( subscription . getSubscriptionId (  )  ,    stompHeaders . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["subscribe"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "String   subscriptionId    =     \"  1  2  3  \"  ;", "String   destination    =     \"  / topic / foo \"  ;", "StompHeaders   stompHeaders    =    new   StompHeaders (  )  ;", "stompHeaders . setId ( subscriptionId )  ;", "stompHeaders . setDestination ( destination )  ;", "StompFrameHandler   frameHandler    =    mock ( StompFrameHandler . class )  ;", ". Subscription   subscription    =    this . session . subscribe ( stompHeaders ,    frameHandler )  ;", "assertEquals ( subscriptionId ,    subscription . getSubscriptionId (  )  )  ;", "Message < byte [  ]  >    message    =    this . messageCaptor . getValue (  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . SUBSCRIBE ,    accessor . getCommand (  )  )  ;", "stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "assertEquals ( stompHeaders . toString (  )  ,     2  ,    stompHeaders . size (  )  )  ;", "assertEquals ( destination ,    stompHeaders . getDestination (  )  )  ;", "assertEquals ( subscriptionId ,    stompHeaders . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["subscribeWithHeaders"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "String   destination    =     \"  / topic / foo \"  ;", "StompFrameHandler   frameHandler    =    mock ( StompFrameHandler . class )  ;", ". Subscription   subscription    =    this . session . subscribe ( destination ,    frameHandler )  ;", "subscription . unsubscribe (  )  ;", "Message < byte [  ]  >    message    =    this . messageCaptor . getValue (  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . UNSUBSCRIBE ,    accessor . getCommand (  )  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "assertEquals ( stompHeaders . toString (  )  ,     1  ,    stompHeaders . size (  )  )  ;", "assertEquals ( subscription . getSubscriptionId (  )  ,    stompHeaders . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["unsubscribe"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "this . session . afterConnected ( this . connection )  ;", "assertTrue ( this . session . isConnected (  )  )  ;", "String   headerName    =     \" durable - subscription - name \"  ;", "String   headerValue    =     \"  1  2  3  \"  ;", "StompHeaders   subscribeHeaders    =    new   StompHeaders (  )  ;", "subscribeHeaders . setDestination (  \"  / topic / foo \"  )  ;", "subscribeHeaders . set ( headerName ,    headerValue )  ;", "StompFrameHandler   frameHandler    =    mock ( StompFrameHandler . class )  ;", ". Subscription   subscription    =    this . session . subscribe ( subscribeHeaders ,    frameHandler )  ;", "StompHeaders   unsubscribeHeaders    =    new   StompHeaders (  )  ;", "unsubscribeHeaders . set ( headerName ,    subscription . getSubscriptionHeaders (  )  . getFirst ( headerName )  )  ;", "subscription . unsubscribe ( unsubscribeHeaders )  ;", "Message < byte [  ]  >    message    =    this . messageCaptor . getValue (  )  ;", "StompHeaderAccessor   accessor    =    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . UNSUBSCRIBE ,    accessor . getCommand (  )  )  ;", "StompHeaders   stompHeaders    =    StompHeaders . readOnlyStompHeaders ( accessor . getNativeHeaders (  )  )  ;", "assertEquals ( stompHeaders . toString (  )  ,     2  ,    stompHeaders . size (  )  )  ;", "assertEquals ( subscription . getSubscriptionId (  )  ,    stompHeaders . getId (  )  )  ;", "assertEquals ( headerValue ,    stompHeaders . getFirst ( headerName )  )  ;", "}", "METHOD_END"], "methodName": ["unsubscribeWithCustomHeader"], "fileName": "org.springframework.messaging.simp.stomp.DefaultStompSessionTests"}, {"methodBody": ["METHOD_START", "{", "ConnectionHandlingStompSession   session    =    createSession ( connectHeaders ,    handler )  ;", "this . tc . connect ( session )  ;", "return   session . getSessionFuture (  )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient"}, {"methodBody": ["METHOD_START", "{", "return   connect ( null ,    handler )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient"}, {"methodBody": ["METHOD_START", "{", "this . tcpClient . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClient"}, {"methodBody": ["METHOD_START", "{", "String   destination    =     \"  / topic / foo \"  ;", ". ConsumingHandler   consumingHandler 1     =    new    . ConsumingHandler ( destination )  ;", "ListenableFuture < StompSession >    consumerFuture 1     =    this . client . connect ( consumingHandler 1  )  ;", ". ConsumingHandler   consumingHandler 2     =    new    . ConsumingHandler ( destination )  ;", "ListenableFuture < StompSession >    consumerFuture 2     =    this . client . connect ( consumingHandler 2  )  ;", "assertTrue ( consumingHandler 1  . awaitForSubscriptions (  5  0  0  0  )  )  ;", "assertTrue ( consumingHandler 2  . awaitForSubscriptions (  5  0  0  0  )  )  ;", ". ProducingHandler   producingHandler    =    new    . ProducingHandler (  )  ;", "producingHandler . addToSend ( destination ,     \" foo 1  \"  )  ;", "producingHandler . addToSend ( destination ,     \" foo 2  \"  )  ;", "ListenableFuture < StompSession >    producerFuture    =    this . client . connect ( producingHandler )  ;", "assertTrue ( consumingHandler 1  . awaitForMessageCount (  2  ,     5  0  0  0  )  )  ;", "assertThat ( consumingHandler 1  . getReceived (  )  ,    containsInAnyOrder (  \" foo 1  \"  ,     \" foo 2  \"  )  )  ;", "assertTrue ( consumingHandler 2  . awaitForMessageCount (  2  ,     5  0  0  0  )  )  ;", "assertThat ( consumingHandler 2  . getReceived (  )  ,    containsInAnyOrder (  \" foo 1  \"  ,     \" foo 2  \"  )  )  ;", "consumerFuture 1  . get (  )  . disconnect (  )  ;", "consumerFuture 2  . get (  )  . disconnect (  )  ;", "producerFuture . get (  )  . disconnect (  )  ;", "}", "METHOD_END"], "methodName": ["publishSubscribe"], "fileName": "org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests"}, {"methodBody": ["METHOD_START", "{", "ReactorNettyTcpStompClientTests . logger . debug (  (  (  \" Setting   up   before    '  \"     +     ( this . testName . getMethodName (  )  )  )     +     \"  '  \"  )  )  ;", "int   port    =    SocketUtils . findAvailableTcpPort (  6  1  6  1  3  )  ;", "this . activeMQBroker    =    new   BrokerService (  )  ;", "this . activeMQBroker . addConnector (  (  \" stomp :  /  /  1  2  7  .  0  .  0  .  1  :  \"     +    port )  )  ;", "this . activeMQBroker . setStartAsync ( false )  ;", "this . activeMQBroker . setPersistent ( false )  ;", "this . activeMQBroker . setUseJmx ( false )  ;", "this . activeMQBroker . getSystemUsage (  )  . getMemoryUsage (  )  . setLimit (  (  (  1  0  2  4     *     1  0  2  4  )     *     5  )  )  ;", "this . activeMQBroker . getSystemUsage (  )  . getTempUsage (  )  . setLimit (  (  (  1  0  2  4     *     1  0  2  4  )     *     5  )  )  ;", "this . activeMQBroker . start (  )  ;", "ThreadPoolTaskScheduler   taskScheduler    =    new   ThreadPoolTaskScheduler (  )  ;", "taskScheduler . afterPropertiesSet (  )  ;", "this . client    =    new   ReactorNettyTcpStompClient (  \"  1  2  7  .  0  .  0  .  1  \"  ,    port )  ;", "this . client . setMessageConverter ( new   StringMessageConverter (  )  )  ;", "this . client . setTaskScheduler ( taskScheduler )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . client . shutdown (  )  ;", "}    catch    ( Throwable   ex )     {", ". logger . error (  \" Failed   to   shut   client \"  ,    ex )  ;", "}", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "this . activeMQBroker . addShutdownHook ( latch :  : countDown )  ;", ". logger . debug (  \" Stopping   ActiveMQ   broker   and   will   await   shutdown \"  )  ;", "this . activeMQBroker . stop (  )  ;", "if    (  !  ( latch . await (  5  ,    TimeUnit . SECONDS )  )  )     {", ". logger . debug (  \" ActiveMQ   broker   did   not   shut   in   the   expected   time .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.messaging.simp.stomp.ReactorNettyTcpStompClientTests"}, {"methodBody": ["METHOD_START", "{", "return   this . clientLogin ;", "}", "METHOD_END"], "methodName": ["getClientLogin"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . clientPasscode ;", "}", "METHOD_END"], "methodName": ["getClientPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . connectionHandlers . size (  )  ;", "}", "METHOD_END"], "methodName": ["getConnectionCount"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . headerInitializer ;", "}", "METHOD_END"], "methodName": ["getHeaderInitializer"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . relayHost ;", "}", "METHOD_END"], "methodName": ["getRelayHost"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . relayPort ;", "}", "METHOD_END"], "methodName": ["getRelayPort"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . stats . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getStatsInfo"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . systemHeartbeatReceiveInterval ;", "}", "METHOD_END"], "methodName": ["getSystemHeartbeatReceiveInterval"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . systemHeartbeatSendInterval ;", "}", "METHOD_END"], "methodName": ["getSystemHeartbeatSendInterval"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . systemLogin ;", "}", "METHOD_END"], "methodName": ["getSystemLogin"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . systemPasscode ;", "}", "METHOD_END"], "methodName": ["getSystemPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . systemSubscriptions ;", "}", "METHOD_END"], "methodName": ["getSystemSubscriptions"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . tcpClient ;", "}", "METHOD_END"], "methodName": ["getTcpClient"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . virtualHost ;", "}", "METHOD_END"], "methodName": ["getVirtualHost"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( clientLogin ,     \" clientLogin   must   not   be   empty \"  )  ;", "this . clientLogin    =    clientLogin ;", "}", "METHOD_END"], "methodName": ["setClientLogin"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( clientPasscode ,     \" clientPasscode   must   not   be   empty \"  )  ;", "this . clientPasscode    =    clientPasscode ;", "}", "METHOD_END"], "methodName": ["setClientPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . headerInitializer    =    headerInitializer ;", "}", "METHOD_END"], "methodName": ["setHeaderInitializer"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( relayHost ,     \" relayHost   must   not   be   empty \"  )  ;", "this . relayHost    =    relayHost ;", "}", "METHOD_END"], "methodName": ["setRelayHost"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . relayPort    =    relayPort ;", "}", "METHOD_END"], "methodName": ["setRelayPort"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . systemHeartbeatReceiveInterval    =    heartbeatReceiveInterval ;", "}", "METHOD_END"], "methodName": ["setSystemHeartbeatReceiveInterval"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . systemHeartbeatSendInterval    =    systemHeartbeatSendInterval ;", "}", "METHOD_END"], "methodName": ["setSystemHeartbeatSendInterval"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( systemLogin ,     \" systemLogin   must   not   be   empty \"  )  ;", "this . systemLogin    =    systemLogin ;", "}", "METHOD_END"], "methodName": ["setSystemLogin"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . systemPasscode    =    systemPasscode ;", "}", "METHOD_END"], "methodName": ["setSystemPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . systemSubscriptions . clear (  )  ;", "if    ( subscriptions    !  =    null )     {", "this . systemSubscriptions . putAll ( subscriptions )  ;", "}", "}", "METHOD_END"], "methodName": ["setSystemSubscriptions"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . tcpClient    =    tcpClient ;", "}", "METHOD_END"], "methodName": ["setTcpClient"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . virtualHost    =    virtualHost ;", "}", "METHOD_END"], "methodName": ["setVirtualHost"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  \" Starting   test   brokerAvailabilityEventWhenStopped (  )  \"  )  ;", "stopActiveMqBrokerAndAwait (  )  ;", "this . eventPublisher . expectBrokerAvailabilityEvent ( false )  ;", "}", "METHOD_END"], "methodName": ["brokerAvailabilityEventWhenStopped"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  \" Starting   test   brokerBecomingUnvailableTriggersErrorFrame (  )  \"  )  ;", "String   sess 1     =     \" sess 1  \"  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   connect    =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . connect ( sess 1  )  . build (  )  ;", "this . relay . handleMessage ( connect . message )  ;", "this . responseHandler . expectMessages ( connect )  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   error    =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . error ( sess 1  )  . build (  )  ;", "stopActiveMqBrokerAndAwait (  )  ;", "this . eventPublisher . expectBrokerAvailabilityEvent ( false )  ;", "this . responseHandler . expectMessages ( error )  ;", "}", "METHOD_END"], "methodName": ["brokerBecomingUnvailableTriggersErrorFrame"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . relay    =    new   StompBrokerRelayMessageHandler ( new   StubMessageChannel (  )  ,    this . responseChannel ,    new   StubMessageChannel (  )  ,    Arrays . asList (  \"  / queue /  \"  ,     \"  / topic /  \"  )  )  ;", "this . relay . setRelayPort ( this . port )  ;", "this . relay . setApplicationEventPublisher ( this . eventPublisher )  ;", "this . relay . setSystemHeartbeatReceiveInterval (  0  )  ;", "this . relay . setSystemHeartbeatSendInterval (  0  )  ;", "this . relay . start (  )  ;", "this . eventPublisher . expectBrokerAvailabilityEvent ( true )  ;", "}", "METHOD_END"], "methodName": ["createAndStartRelay"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  \" Starting   test   disconnectWithReceipt (  )  \"  )  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   connect    =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . connect (  \" sess 1  \"  )  . build (  )  ;", "this . relay . handleMessage ( connect . message )  ;", "this . responseHandler . expectMessages ( connect )  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   disconnect    =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . disconnectWithReceipt (  \" sess 1  \"  ,     \" r 1  2  3  \"  )  . build (  )  ;", "this . relay . handleMessage ( disconnect . message )  ;", "this . responseHandler . expectMessages ( disconnect )  ;", "}", "METHOD_END"], "methodName": ["disconnectWithReceipt"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  \" Starting   test   messageDeliveryExceptionIfSystemSessionForwardFails (  )  \"  )  ;", "stopActiveMqBrokerAndAwait (  )  ;", "this . eventPublisher . expectBrokerAvailabilityEvent ( false )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SEND )  ;", "this . relay . handleMessage ( MessageBuilder . createMessage (  \" test \"  . getBytes (  )  ,    headers . getMessageHeaders (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["messageDeliveryExceptionIfSystemSessionForwardFails"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  \" Starting   test   publishSubscribe (  )  \"  )  ;", "String   sess 1     =     \" sess 1  \"  ;", "String   sess 2     =     \" sess 2  \"  ;", "String   subs 1     =     \" subs 1  \"  ;", "String   destination    =     \"  / topic / test \"  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   conn 1     =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . connect ( sess 1  )  . build (  )  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   conn 2     =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . connect ( sess 2  )  . build (  )  ;", "this . relay . handleMessage ( conn 1  . message )  ;", "this . relay . handleMessage ( conn 2  . message )  ;", "this . responseHandler . expectMessages ( conn 1  ,    conn 2  )  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   subscribe    =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . subscribeWithReceipt ( sess 1  ,    subs 1  ,    destination ,     \" r 1  \"  )  . build (  )  ;", "this . relay . handleMessage ( subscribe . message )  ;", "this . responseHandler . expectMessages ( subscribe )  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   send    =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . send ( destination ,     \" foo \"  )  . andExpectMessage ( sess 1  ,    subs 1  )  . build (  )  ;", "this . relay . handleMessage ( send . message )  ;", "this . responseHandler . expectMessages ( send )  ;", "}", "METHOD_END"], "methodName": ["publishSubscribe"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  \" Starting   test   relayReconnectsIfBrokerComesBackUp (  )  \"  )  ;", "String   sess 1     =     \" sess 1  \"  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   conn 1     =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . connect ( sess 1  )  . build (  )  ;", "this . relay . handleMessage ( conn 1  . message )  ;", "this . responseHandler . expectMessages ( conn 1  )  ;", "String   subs 1     =     \" subs 1  \"  ;", "String   destination    =     \"  / topic / test \"  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   subscribe    =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . subscribeWithReceipt ( sess 1  ,    subs 1  ,    destination ,     \" r 1  \"  )  . build (  )  ;", "this . relay . handleMessage ( subscribe . message )  ;", "this . responseHandler . expectMessages ( subscribe )  ;", "StompBrokerRelayMessageHandlerIntegrationTests . MessageExchange   error    =    StompBrokerRelayMessageHandlerIntegrationTests . MessageExchangeBuilder . error ( sess 1  )  . build (  )  ;", "stopActiveMqBrokerAndAwait (  )  ;", "this . responseHandler . expectMessages ( error )  ;", "this . eventPublisher . expectBrokerAvailabilityEvent ( false )  ;", "startActiveMqBroker (  )  ;", "this . eventPublisher . expectBrokerAvailabilityEvent ( true )  ;", "}", "METHOD_END"], "methodName": ["relayReconnectsIfBrokerComesBackUp"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  (  (  \" Setting   up   before    '  \"     +     ( this . testName . getMethodName (  )  )  )     +     \"  '  \"  )  )  ;", "this . port    =    SocketUtils . findAvailableTcpPort (  6  1  6  1  3  )  ;", "this . responseChannel    =    new   ExecutorSubscribableChannel (  )  ;", "this . responseHandler    =    new   StompBrokerRelayMessageHandlerIntegrationTests . TestMessageHandler (  )  ;", "this . responseChannel . subscribe ( this . responseHandler )  ;", "this . eventPublisher    =    new   StompBrokerRelayMessageHandlerIntegrationTests . TestEventPublisher (  )  ;", "startActiveMqBroker (  )  ;", "createAndStartRelay (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "this . activeMQBroker    =    new   BrokerService (  )  ;", "this . activeMQBroker . addConnector (  (  \" stomp :  /  / localhost :  \"     +     ( this . port )  )  )  ;", "this . activeMQBroker . setStartAsync ( false )  ;", "this . activeMQBroker . setPersistent ( false )  ;", "this . activeMQBroker . setUseJmx ( false )  ;", "this . activeMQBroker . getSystemUsage (  )  . getMemoryUsage (  )  . setLimit (  (  (  1  0  2  4     *     1  0  2  4  )     *     5  )  )  ;", "this . activeMQBroker . getSystemUsage (  )  . getTempUsage (  )  . setLimit (  (  (  1  0  2  4     *     1  0  2  4  )     *     5  )  )  ;", "this . activeMQBroker . start (  )  ;", "}", "METHOD_END"], "methodName": ["startActiveMqBroker"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  \" Stopping   ActiveMQ   broker   and   will   await   shutdown \"  )  ;", "if    (  !  ( this . activeMQBroker . isStarted (  )  )  )     {", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  \" Broker   not   running \"  )  ;", "return ;", "}", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "this . activeMQBroker . addShutdownHook ( new   Runnable (  )     {", "public   void   run (  )     {", "latch . countDown (  )  ;", "}", "}  )  ;", "this . activeMQBroker . stop (  )  ;", "assertTrue (  \" Broker   did   not   stop \"  ,    latch . await (  5  ,    TimeUnit . SECONDS )  )  ;", "StompBrokerRelayMessageHandlerIntegrationTests . logger . debug (  \" Broker   stopped \"  )  ;", "}", "METHOD_END"], "methodName": ["stopActiveMqBrokerAndAwait"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", ". logger . debug (  (  \" STOMP   broker   relay   stats :     \"     +     ( this . relay . getStatsInfo (  )  )  )  )  ;", "this . relay . stop (  )  ;", "}    finally    {", "stopActiveMqBrokerAndAwait (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerIntegrationTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . CONNECT )  ;", "headers . setSessionId ( sessionId )  ;", "headers . setUser ( new   TestPrincipal ( user )  )  ;", "return   MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers . geteaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["connectMessage"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . brokerRelay . start (  )  ;", "this . brokerRelay . stopInternal (  )  ;", "this . brokerRelay . handleMessage ( connectMessage (  \" sess 1  \"  ,     \" joe \"  )  )  ;", "Message < byte [  ]  >    message    =    this . outboundChannel . getMessages (  )  . get (  0  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . ERROR ,    accessor . getCommand (  )  )  ;", "assertEquals (  \" sess 1  \"  ,    accessor . getSessionId (  )  )  ;", "assertEquals (  \" joe \"  ,    accessor . getUser (  )  . getName (  )  )  ;", "assertEquals (  \" Broker   not   available .  \"  ,    accessor . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["connectWhenBrokerNotAvailable"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . brokerRelay . start (  )  ;", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . create ( SimpMessageType . MESSAGE )  ;", "headers . setSessionId (  \" sess 1  \"  )  ;", "headers . setDestination (  \"  / user / daisy / foo \"  )  ;", "this . brokerRelay . handleMessage ( MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers . getMessageHeaders (  )  )  )  ;", "assertEquals (  1  ,    this . tcpClient . getSentMessages (  )  . size (  )  )  ;", "StompHeaderAccessor   headers 1     =    this . tcpClient . getSentHeaders (  0  )  ;", "assertEquals ( StompCommand . CONNECT ,    headers 1  . getCommand (  )  )  ;", "assertEquals (  . SYSTEM _ SESSION _ ID ,    headers 1  . getSessionId (  )  )  ;", "}", "METHOD_END"], "methodName": ["destinationExcluded"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFutureTask < Boolean >    futureTask    =    new   ListenableFutureTask ( new   Callable < Boolean >  (  )     {", "@ Override", "public   Boolean   call (  )    throws   Exception    {", "return   null ;", "}", "}  )  ;", "futureTask . run (  )  ;", "return   futureTask ;", "}", "METHOD_END"], "methodName": ["getBooleanFuture"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ListenableFutureTask < Void >    futureTask    =    new   ListenableFutureTask ( new   Callable < Void >  (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "return   null ;", "}", "}  )  ;", "futureTask . run (  )  ;", "return   futureTask ;", "}", "METHOD_END"], "methodName": ["getVoidFuture"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . brokerRelay . setSystemLogin (  \" syslogin \"  )  ;", "this . brokerRelay . setSystemPasscode (  \" syspasscode \"  )  ;", "this . brokerRelay . setClientLogin (  \" clientlogin \"  )  ;", "this . brokerRelay . setClientPasscode (  \" clientpasscode \"  )  ;", "this . brokerRelay . start (  )  ;", "this . brokerRelay . handleMessage ( connectMessage (  \" sess 1  \"  ,     \" joe \"  )  )  ;", "assertEquals (  2  ,    this . tcpClient . getSentMessages (  )  . size (  )  )  ;", "StompHeaderAccessor   headers 1     =    this . tcpClient . getSentHeaders (  0  )  ;", "assertEquals ( StompCommand . CONNECT ,    headers 1  . getCommand (  )  )  ;", "assertEquals (  \" syslogin \"  ,    headers 1  . getLogin (  )  )  ;", "assertEquals (  \" syspasscode \"  ,    headers 1  . getPasscode (  )  )  ;", "StompHeaderAccessor   headers 2     =    this . tcpClient . getSentHeaders (  1  )  ;", "assertEquals ( StompCommand . CONNECT ,    headers 2  . getCommand (  )  )  ;", "assertEquals (  \" clientlogin \"  ,    headers 2  . getLogin (  )  )  ;", "assertEquals (  \" clientpasscode \"  ,    headers 2  . getPasscode (  )  )  ;", "}", "METHOD_END"], "methodName": ["loginAndPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( command )  ;", "if    ( sessionId    !  =    null )     {", "accessor . setSessionId ( sessionId )  ;", "}", "if    ( user    !  =    null )     {", "accessor . setUser ( new   TestPrincipal ( user )  )  ;", "}", "if    ( destination    !  =    null )     {", "accessor . setDestination ( destination )  ;", "}", "accessor . setLeaveMutable ( true )  ;", "return   MessageBuilder . createMessage ( new   byte [  0  ]  ,    accessor . geteaders (  )  )  ;", "}", "METHOD_END"], "methodName": ["message"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . brokerRelay . start (  )  ;", "this . brokerRelay . handleMessage ( connectMessage (  \" sess 1  \"  ,     \" joe \"  )  )  ;", "assertEquals (  2  ,    this . tcpClient . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( StompCommand . CONNECT ,    this . tcpClient . getSentHeaders (  0  )  . getCommand (  )  )  ;", "assertEquals ( StompCommand . CONNECT ,    this . tcpClient . getSentHeaders (  1  )  . getCommand (  )  )  ;", "this . tcpClient . handleMessage ( message ( StompCommand . MESSAGE ,    null ,    null ,    null )  )  ;", "Message < byte [  ]  >    message    =    this . outboundChannel . getMessages (  )  . get (  0  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "assertEquals (  \" sess 1  \"  ,    accessor . getSessionId (  )  )  ;", "assertEquals (  \" joe \"  ,    accessor . getUser (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["messageFromBrokerIsEnriched"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . brokerRelay . start (  )  ;", "assertEquals (  1  ,    this . brokerRelay . getConnectionCount (  )  )  ;", "this . brokerRelay . handleMessage ( connectMessage (  \" sess 1  \"  ,     \" joe \"  )  )  ;", "assertEquals (  2  ,    this . brokerRelay . getConnectionCount (  )  )  ;", "this . brokerRelay . stopInternal (  )  ;", "this . brokerRelay . handleMessage ( message ( StompCommand . SEND ,     \" sess 1  \"  ,     \" joe \"  ,     \"  / foo \"  )  )  ;", "assertEquals (  1  ,    this . brokerRelay . getConnectionCount (  )  )  ;", "Message < byte [  ]  >    message    =    this . outboundChannel . getMessages (  )  . get (  0  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  ;", "assertEquals ( StompCommand . ERROR ,    accessor . getCommand (  )  )  ;", "assertEquals (  \" sess 1  \"  ,    accessor . getSessionId (  )  )  ;", "assertEquals (  \" joe \"  ,    accessor . getUser (  )  . getName (  )  )  ;", "assertEquals (  \" Broker   not   available .  \"  ,    accessor . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendAfterBrokerUnavailable"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . outboundChannel    =    new   StubMessageChannel (  )  ;", "this . brokerRelay    =    new   StompBrokerRelayMessageHandler ( new   StubMessageChannel (  )  ,    this . outboundChannel ,    new   StubMessageChannel (  )  ,    Arrays . asList (  \"  / topic \"  )  )     {", "@ Override", "protected   void   startInternal (  )     {", "publishBrokerAvailableEvent (  )  ;", "super . startInternal (  )  ;", "}", "}  ;", "this . tcpClient    =    new    . StubTcpOperations (  )  ;", "this . brokerRelay . setTcpClient ( this . tcpClient )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MessageHandler   handler    =    mock ( MessageHandler . class )  ;", "this . brokerRelay . setSystemSubscriptions ( Collections . singletonMap (  \"  / topic / foo \"  ,    handler )  )  ;", "this . brokerRelay . start (  )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . CONNECTED )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "this . tcpClient . handleMessage ( MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers )  )  ;", "assertEquals (  2  ,    this . tcpClient . getSentMessages (  )  . size (  )  )  ;", "assertEquals ( StompCommand . CONNECT ,    this . tcpClient . getSentHeaders (  0  )  . getCommand (  )  )  ;", "assertEquals ( StompCommand . SUBSCRIBE ,    this . tcpClient . getSentHeaders (  1  )  . getCommand (  )  )  ;", "assertEquals (  \"  / topic / foo \"  ,    this . tcpClient . getSentHeaders (  1  )  . getDestination (  )  )  ;", "Message < byte [  ]  >    message    =    message ( StompCommand . MESSAGE ,    null ,    null ,     \"  / topic / foo \"  )  ;", "this . tcpClient . handleMessage ( message )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "verify ( handler )  . handleMessage ( captor . capture (  )  )  ;", "assertSame ( message ,    captor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["systemSubscription"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . brokerRelay . setVirtualHost (  \" ABC \"  )  ;", "this . brokerRelay . start (  )  ;", "this . brokerRelay . handleMessage ( connectMessage (  \" sess 1  \"  ,     \" joe \"  )  )  ;", "assertEquals (  2  ,    this . tcpClient . getSentMessages (  )  . size (  )  )  ;", "StompHeaderAccessor   headers 1     =    this . tcpClient . getSentHeaders (  0  )  ;", "assertEquals ( StompCommand . CONNECT ,    headers 1  . getCommand (  )  )  ;", "assertEquals (  . SYSTEM _ SESSION _ ID ,    headers 1  . getSessionId (  )  )  ;", "assertEquals (  \" ABC \"  ,    headers 1  . getHost (  )  )  ;", "StompHeaderAccessor   headers 2     =    this . tcpClient . getSentHeaders (  1  )  ;", "assertEquals ( StompCommand . CONNECT ,    headers 2  . getCommand (  )  )  ;", "assertEquals (  \" sess 1  \"  ,    headers 2  . getSessionId (  )  )  ;", "assertEquals (  \" ABC \"  ,    headers 2  . getHost (  )  )  ;", "}", "METHOD_END"], "methodName": ["virtualHost"], "fileName": "org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "connectHeaders    =    processConnectHeaders ( connectHeaders )  ;", "DefaultSession   session    =    new   DefaultSession ( handler ,    connectHeaders )  ;", "session . setMessageConverter ( getMessageConverter (  )  )  ;", "session . setTaskScheduler ( getTaskScheduler (  )  )  ;", "session . setReceiptTimeLimit ( getReceiptTimeLimit (  )  )  ;", "return   session ;", "}", "METHOD_END"], "methodName": ["createSession"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultHeartbeat ;", "}", "METHOD_END"], "methodName": ["getDefaultHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . messageConverter ;", "}", "METHOD_END"], "methodName": ["getMessageConverter"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . receiptTimeLimit ;", "}", "METHOD_END"], "methodName": ["getReceiptTimeLimit"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . taskScheduler ;", "}", "METHOD_END"], "methodName": ["getTaskScheduler"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "long [  ]    heartbeat    =    getDefaultHeartbeat (  )  ;", "return    (  ( heartbeat [  0  ]  )     !  =     0  )     &  &     (  ( heartbeat [  1  ]  )     !  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultHeartbeatEnabled"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "connectHeaders    =     ( connectHeaders    !  =    null )     ?    connectHeaders    :    new   StompHeaders (  )  ;", "if    (  ( connectHeaders . getHeartbeat (  )  )     =  =    null )     {", "connectHeaders . setHeartbeat ( getDefaultHeartbeat (  )  )  ;", "}", "return   connectHeaders ;", "}", "METHOD_END"], "methodName": ["processConnectHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( heartbeat . length )     !  =     2  )     |  |     (  ( heartbeat [  0  ]  )     <     0  )  )     |  |     (  ( heartbeat [  1  ]  )     <     0  )  )     {", "throw   new   IllegalArgumentException (  (  \" Invalid   heart - beat :     \"     +     ( Arrays . toSt ( heartbeat )  )  )  )  ;", "}", "this . defaultHeartbeat    =    heartbeat ;", "}", "METHOD_END"], "methodName": ["setDefaultHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNulleConverter ,     \" MessageConverter   must   not   be   null \"  )  ;", "thiseConverter    = eConverter ;", "}", "METHOD_END"], "methodName": ["setMessageConverter"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( receiptTimeLimit    >     0  )  ,     \" Receipt   time   limit   must   be   larger   than   zero \"  )  ;", "this . receiptTimeLimit    =    receiptTimeLimit ;", "}", "METHOD_END"], "methodName": ["setReceiptTimeLimit"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "this . taskScheduler    =    taskScheduler ;", "}", "METHOD_END"], "methodName": ["setTaskScheduler"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupport"}, {"methodBody": ["METHOD_START", "{", "trySetDefaultHeartbeat ( new   long [  ]  {     -  1  ,     0     }  )  ;", "trySetDefaultHeartbeat ( new   long [  ]  {     0  ,     -  1     }  )  ;", "}", "METHOD_END"], "methodName": ["defaultHeartbeatValidation"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupportTests"}, {"methodBody": ["METHOD_START", "{", "assertArrayEquals ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ,    this . stompClient . getDefaultHeartbeat (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultHeartbeatValue"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupportTests"}, {"methodBody": ["METHOD_START", "{", "assertArrayEquals ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ,    this . stompClient . getDefaultHeartbeat (  )  )  ;", "assertTrue ( this . stompClient . isDefaultHeartbeatEnabled (  )  )  ;", "this . stompClient . setDefaultHeartbeat ( new   long [  ]  {     0  ,     0     }  )  ;", "assertFalse ( this . stompClient . isDefaultHeartbeatEnabled (  )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultHeartbeatEnabled"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupportTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaders   connectHeaders    =    this . stompClient . processConnectHeaders ( null )  ;", "assertNotNull ( connectHeaders )  ;", "assertArrayEquals ( new   long [  ]  {     1  0  0  0  0  ,     1  0  0  0  0     }  ,    connectHeaders . getHeartbeat (  )  )  ;", "}", "METHOD_END"], "methodName": ["processConnectHeadersDefault"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupportTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaders   connectHeaders    =    new   StompHeaders (  )  ;", "connectHeaders . setHeartbeat ( new   long [  ]  {     1  5  0  0  0  ,     1  5  0  0  0     }  )  ;", "connectHeaders    =    this . s . processConnectHeaders ( connectHeaders )  ;", "assertNotNull ( connectHeaders )  ;", "assertArrayEquals ( new   long [  ]  {     1  5  0  0  0  ,     1  5  0  0  0     }  ,    connectHeaders . getHeartbeat (  )  )  ;", "}", "METHOD_END"], "methodName": ["processConnectHeadersWithExplicitHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupportTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . s . setDefaultHeartbeat ( heartbeat )  ;", "fail (  \" Expected   exception \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["trySetDefaultHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompClientSupportTests"}, {"methodBody": ["METHOD_START", "{", "return   this . messageType ;", "}", "METHOD_END"], "methodName": ["getMessageType"], "fileName": "org.springframework.messaging.simp.stomp.StompCommand"}, {"methodBody": ["METHOD_START", "{", "return   this . body ;", "}", "METHOD_END"], "methodName": ["isBodyAllowed"], "fileName": "org.springframework.messaging.simp.stomp.StompCommand"}, {"methodBody": ["METHOD_START", "{", "return   this . body ;", "}", "METHOD_END"], "methodName": ["requiresContentLength"], "fileName": "org.springframework.messaging.simp.stomp.StompCommand"}, {"methodBody": ["METHOD_START", "{", "return   this . destination ;", "}", "METHOD_END"], "methodName": ["requiresDestination"], "fileName": "org.springframework.messaging.simp.stomp.StompCommand"}, {"methodBody": ["METHOD_START", "{", "return   this . subscriptionId ;", "}", "METHOD_END"], "methodName": ["requiresSubscriptionId"], "fileName": "org.springframework.messaging.simp.stomp.StompCommand"}, {"methodBody": ["METHOD_START", "{", "for    ( StompCommand   stompCommand    :    StompCommand . values (  )  )     {", "SimpMessageType   simp    =     . messageTypes . get ( stompCommand )  ;", "if    ( simp    =  =    null )     {", "simp    =    SimpMessageType . OTHER ;", "}", "assertSame ( simp ,    stompCommand . getMessageType (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getMessageType"], "fileName": "org.springframework.messaging.simp.stomp.StompCommandTests"}, {"methodBody": ["METHOD_START", "{", "for    ( StompCommand   stompCommand    :    StompCommand . values (  )  )     {", "assertEquals (  . bodyAllowed . contains ( stompCommand )  ,    stompCommand . isBodyAllowed (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isBodyAllowed"], "fileName": "org.springframework.messaging.simp.stomp.StompCommandTests"}, {"methodBody": ["METHOD_START", "{", "for    ( StompCommand   stompCommand    :    StompCommand . values (  )  )     {", "assertEquals (  . contentLengthRequired . contains ( stompCommand )  ,    stompCommand . requiresContentLength (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["requiresContentLength"], "fileName": "org.springframework.messaging.simp.stomp.StompCommandTests"}, {"methodBody": ["METHOD_START", "{", "for    ( StompCommand   stompCommand    :    StompCommand . values (  )  )     {", "assertEquals (  . destinationRequired . contains ( stompCommand )  ,    stompCommand . requiresDestination (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["requiresDestination"], "fileName": "org.springframework.messaging.simp.stomp.StompCommandTests"}, {"methodBody": ["METHOD_START", "{", "for    ( StompCommand   stompCommand    :    StompCommand . values (  )  )     {", "assertEquals (  . subscriptionIdRequired . contains ( stompCommand )  ,    stompCommand . requiresSubscriptionId (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["requiresSubscriptionId"], "fileName": "org.springframework.messaging.simp.stomp.StompCommandTests"}, {"methodBody": ["METHOD_START", "{", "return   decode ( byteBuffer ,    null )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "List < Message < byte [  ]  >  >    messages    =    new   ArrayList <  >  (  )  ;", "while    ( byteBuffer . hasRemaining (  )  )     {", "Message < byte [  ]  >    message    =    decodeMessage ( byteBuffer ,    partialMessageHeaders )  ;", "if    ( message    !  =    null )     {", "messages . add ( message )  ;", "} else    {", "break ;", "}", "}", "return   messages ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    decodedMessage    =    null ;", "skipLeadingEol ( byteBuffer )  ;", "Buffer   buffer    =    byteBuffer ;", "buffer . mark (  )  ;", "String   command    =    readCommand ( byteBuffer )  ;", "if    (  ( command . length (  )  )     >     0  )     {", "StompHeaderAccessor   headerAccessor    =    null ;", "byte [  ]    payload    =    null ;", "if    (  ( byteBuffer . remaining (  )  )     >     0  )     {", "StompCommand   stompCommand    =    StompCommand . valueOf ( command )  ;", "headerAccessor    =    StompHeaderAccessor . create ( stompCommand )  ;", "initHeaders ( headerAccessor )  ;", "readHeaders ( byteBuffer ,    headerAccessor )  ;", "payload    =    readPayload ( byteBuffer ,    headerAccessor )  ;", "}", "if    ( payload    !  =    null )     {", "if    (  ( payload . length )     >     0  )     {", "StompCommand   stompCommand    =    headerAccessor . getCommand (  )  ;", "if    (  ( stompCommand    !  =    null )     &  &     (  !  ( stompCommand . isBodyAllowed (  )  )  )  )     {", "throw   new   StompConversionException (  (  (  (  ( stompCommand    +     \"    shouldn ' t   have   a   payload :    length =  \"  )     +     ( payload . length )  )     +     \"  ,    headers =  \"  )     +    headers )  )  ;", "}", "}", "headerAccessor . updateSimpMessageHeadersFromStompHeaders (  )  ;", "headerAccessor . setLeaveMutable ( true )  ;", "decodedMessage    =    MessageBuilder . createMessage ( payload ,    headerAccessor . getMessageHeaders (  )  )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  \" Decoded    \"     +     ( headerAccessor . getDetailedLogMessage ( payload )  )  )  )  ;", "}", "} else    {", ". logger . trace (  \" Incomplete   frame ,    resetting   input   buffer .  .  .  \"  )  ;", "if    (  ( headers    !  =    null )     &  &     ( headerAccessor    !  =    null )  )     {", "String   name    =    NativeMessageHeaderAccessor . NATIVE _ HEADERS ;", "@ SuppressWarnings (  \" unchecked \"  )", "MultiValueMap < String ,    String >    map    =     (  ( MultiValueMap < String ,    String >  )     ( headerAccessor . getHeader ( name )  )  )  ;", "if    ( map    !  =    null )     {", "headers . putAll ( map )  ;", "}", "}", "buffer . reset (  )  ;", "}", "} else    {", "StompHeaderAccessor   headerAccessor    =    StompHeaderAccessor . createForHeartbeat (  )  ;", "initHeaders ( headerAccessor )  ;", "headerAccessor . setLeaveMutable ( true )  ;", "decodedMessage    =    MessageBuilder . createMessage (  . HEARTBEAT _ PAYLOAD ,    headerAccessor . getMessageHeaders (  )  )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  \" Decoded    \"     +     ( headerAccessor . getDetailedLogMessage ( null )  )  )  )  ;", "}", "}", "return   decodedMessage ;", "}", "METHOD_END"], "methodName": ["decodeMessage"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "return   this . headerInitializer ;", "}", "METHOD_END"], "methodName": ["getHeaderInitializer"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderInitializer   initializer    =    getHeaderInitializer (  )  ;", "if    ( initializer    !  =    null )     {", "initializer . initHeaders ( headerAccessor )  ;", "}", "}", "METHOD_END"], "methodName": ["initHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   command    =    new   ByteArrayOutputStream (  2  5  6  )  ;", "while    (  (  ( byteBuffer . remaining (  )  )     >     0  )     &  &     (  !  ( tryConsumeEndOfLine ( byteBuffer )  )  )  )     {", "command . write ( byteBuffer . get (  )  )  ;", "}", "return   new   St ( command . toByteArray (  )  ,    StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["readCommand"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "ByteArrayOutputStream   headerStream    =    new   ByteArrayOutputStream (  2  5  6  )  ;", "boolean   headerComplete    =    false ;", "while    ( byteBuffer . hasRemaining (  )  )     {", "if    ( tryConsumeEndOfLine ( byteBuffer )  )     {", "headerComplete    =    true ;", "break ;", "}", "headerStream . write ( byteBuffer . get (  )  )  ;", "}", "if    (  (  ( headerStream . size (  )  )     >     0  )     &  &    headerComplete )     {", "String   header    =    new   String ( headerStream . toByteArray (  )  ,    StandardCharsets . UTF _  8  )  ;", "int   colonIndex    =    header . indexOf (  '  :  '  )  ;", "if    ( colonIndex    <  =     0  )     {", "if    (  ( byteBuffer . remaining (  )  )     >     0  )     {", "throw   new   ConversionException (  (  (  \" Illegal   header :     '  \"     +    header )     +     \"  '  .    A   header   must   be   of   the   form    < name >  :  [  < value >  ]  .  \"  )  )  ;", "}", "} else    {", "String   headerName    =    unescape ( header . substring (  0  ,    colonIndex )  )  ;", "String   headerValue    =    unescape ( header . substring (  ( colonIndex    +     1  )  )  )  ;", "try    {", "headerAccessor . addNativeHeader ( headerName ,    headerValue )  ;", "}    catch    ( InvalidMimeTypeException   ex )     {", "if    (  ( byteBuffer . remaining (  )  )     >     0  )     {", "throw   ex ;", "}", "}", "}", "} else    {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["readHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "Integer   contentLength ;", "try    {", "contentLength    =    headerAccessor . getContentLength (  )  ;", "}    catch    ( NumberFormatException   ex )     {", "if    (  . logger . isWarnEnabled (  )  )     {", ". logger . warn (  (  \" Ignoring   invalid   content - length :     '  \"     +    headerAccessor )  )  ;", "}", "contentLength    =    null ;", "}", "if    (  ( contentLength    !  =    null )     &  &     ( contentLength    >  =     0  )  )     {", "if    (  ( byteBuffer . remaining (  )  )     >    contentLength )     {", "byte [  ]    payload    =    new   byte [ contentLength ]  ;", "byteBuffer . get ( payload )  ;", "if    (  ( byteBuffer . get (  )  )     !  =     0  )     {", "throw   new   StompConversionException (  \" Frame   must   be   terminated   with   a   null   octet \"  )  ;", "}", "return   payload ;", "} else    {", "return   null ;", "}", "} else    {", "ByteArrayOutputStream   payload    =    new   ByteArrayOutputStream (  2  5  6  )  ;", "while    (  ( byteBuffer . remaining (  )  )     >     0  )     {", "byte   b    =    byteBuffer . get (  )  ;", "if    ( b    =  =     0  )     {", "return   payload . toByteArray (  )  ;", "} else    {", "payload . write ( b )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["readPayload"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "this . headerInitializer    =    headerInitializer ;", "}", "METHOD_END"], "methodName": ["setHeaderInitializer"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "if    (  !  ( tryConsuEndOfLine ( byteBuffer )  )  )     {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["skipLeadingEol"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( byteBuffer . remaining (  )  )     >     0  )     {", "byte   b    =    byteBuffer . get (  )  ;", "if    ( b    =  =     '  \\ n '  )     {", "return   true ;", "} else", "if    ( b    =  =     '  \\ r '  )     {", "if    (  (  ( byteBuffer . remaining (  )  )     >     0  )     &  &     (  ( byteBuffer . get (  )  )     =  =     '  \\ n '  )  )     {", "return   true ;", "} else    {", "throw   new   ConversionException (  \"  \\  '  \\  \\ r \\  '    must   be   followed   by    \\  '  \\  \\ n \\  '  \"  )  ;", "}", "}", "(  ( Buffer )     ( byteBuffer )  )  . position (  (  ( byteBuffer . position (  )  )     -     1  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["tryConsumeEndOfLine"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( inString . length (  )  )  ;", "int   pos    =     0  ;", "int   index    =    inString . indexOf (  '  \\  \\  '  )  ;", "while    ( index    >  =     0  )     {", "sb . append ( inStrubstring ( pos ,    index )  )  ;", "if    (  ( index    +     1  )     >  =     ( inString . length (  )  )  )     {", "throw   new   StompConversionException (  (  (  (  \" Illegal   escape   sequence   at   index    \"     +    index )     +     \"  :     \"  )     +    inString )  )  ;", "}", "Character   c    =    inString . charAt (  ( index    +     1  )  )  ;", "if    ( c    =  =     ' r '  )     {", "sb . append (  '  \\ r '  )  ;", "} else", "if    ( c    =  =     ' n '  )     {", "sb . append (  '  \\ n '  )  ;", "} else", "if    ( c    =  =     ' c '  )     {", "sb . append (  '  :  '  )  ;", "} else", "if    ( c    =  =     '  \\  \\  '  )     {", "sb . append (  '  \\  \\  '  )  ;", "} else    {", "throw   new   StompConversionException (  (  (  (  \" Illegal   escape   sequence   at   index    \"     +    index )     +     \"  :     \"  )     +    inString )  )  ;", "}", "pos    =    index    +     2  ;", "index    =    inString . indexOf (  '  \\  \\  '  ,    pos )  ;", "}", "sb . append ( inStrubstring ( pos )  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["unescape"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoder"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . wrap ( partialFrame . getBytes (  )  )  ;", "assertNull ( d ( buffer )  )  ;", "assertEquals (  0  ,    buffer . position (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertIncompleteDecode"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "ByteBuffer   buffer    =    ByteBuffer . wrap ( stompFrame . getBytes (  )  )  ;", "return   decode ( buffer )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "List < Message < byte [  ]  >  >    messages    =    this . decoder . decode ( buffer )  ;", "if    ( messages . isEmpty (  )  )     {", "return   null ;", "} else    {", "return   messages . get (  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    frame    =    decode (  \" SEND \\ ndestination : test \\ n \\ nThe   body   of   the   message \\ u 0  0  0  0  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap ( frame )  ;", "assertEquals ( StompCommand . SEND ,    headers . getCommand (  )  )  ;", "assertEquals ( headers . toNativeHeaderMap (  )  . toString (  )  ,     1  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals (  \" test \"  ,    headers . getDestination (  )  )  ;", "String   bodyText    =    new   String ( frame . getPayload (  )  )  ;", "assertEquals (  \" The   body   of   the   message \"  ,    bodyText )  ;", "}", "METHOD_END"], "methodName": ["decodeFrame"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "decode (  \" CONNECT \\ naccept - version :  1  .  2  \\ n \\ nThe   body   of   the   message \\ u 0  0  0  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameBodyNotAllowed"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    decode (  \" SEND \\ ncontent - length :  2  3  \\ n \\ nThe   body   of   the   message \\ u 0  0  0  0  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap ( message )  ;", "assertEquals ( StompCommand . SEND ,    headers . getCommand (  )  )  ;", "assertEquals (  1  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals ( Integer . valueOf (  2  3  )  ,    headers . getContentLength (  )  )  ;", "String   bodyText    =    new   String ( message . getPayload (  )  )  ;", "assertEquals (  \" The   body   of   the   message \"  ,    bodyText )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithContentLength"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    frame    =    decode (  \" SEND \\ ncontent - length :  0  \\ n \\ n \\ u 0  0  0  0  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap ( frame )  ;", "assertEquals ( StompCommand . SEND ,    headers . getCommand (  )  )  ;", "assertEquals (  1  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals ( Integer . valueOf (  0  )  ,    headers . getContentLength (  )  )  ;", "String   bodyText    =    new   String ( frame . getPayload (  )  )  ;", "assertEquals (  \"  \"  ,    bodyText )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithContentLengthZero"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    frame    =    decode (  \" DISCONNECT \\ r \\ n \\ r \\ n \\ u 0  0  0  0  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap ( frame )  ;", "assertEquals ( StompCommand . DISCONNECT ,    headers . getCommand (  )  )  ;", "assertEquals (  0  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals (  0  ,    frame . getPayload (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithCrLfEols"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    frame    =    decode (  \" DISCONNECT \\ na \\  \\ c \\  \\ r \\  \\ n \\  \\  \\  \\ b : alpha \\  \\ cbravo \\  \\ r \\  \\ n \\  \\  \\  \\  \\ n \\ n \\ u 0  0  0  0  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap ( frame )  ;", "assertEquals ( StompCommand . DISCONNECT ,    headers . getCommand (  )  )  ;", "assertEquals (  1  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals (  \" alpha : bravo \\ r \\ n \\  \\  \"  ,    headers . getFirstNativeHeader (  \" a :  \\ r \\ n \\  \\ b \"  )  )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithEscapedHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "String   accept    =     \" accept - version :  1  .  1  \\ n \"  ;", "String   valuelessKey    =     \" key :  \\ n \"  ;", "Message < byte [  ]  >        =    decode (  (  (  (  \" CONNECT \\ n \"     +    accept )     +    valuelessKey )     +     \"  \\ n \\ u 0  0  0  0  \"  )  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap (  )  ;", "assertEquals ( StompCommand . CONNECT ,    headers . getCommand (  )  )  ;", "assertEquals (  2  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals (  \"  1  .  1  \"  ,    headers . getFirstNativeHeader (  \" accept - version \"  )  )  ;", "assertEquals (  \"  \"  ,    headers . getFirstNativeHeader (  \" key \"  )  )  ;", "assertEquals (  0  ,     . getPayload (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithHeaderWithEmptyValue"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertIncompleteDecode (  \" MESSAG \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithIncompleteCommand"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertIncompleteDecode (  \" SEND \\ ncontent - type : text / plain ; charset = U \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithIncompleteContentType"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertIncompleteDecode (  \" SEND \\ ndestination \"  )  ;", "assertIncompleteDecode (  \" SEND \\ ndestination :  \"  )  ;", "assertIncompleteDecode (  \" SEND \\ ndestination : test \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithIncompleteHeader"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "decode (  \" SEND \\ ncontent - length :  2  3  \\ n \\ nThe   body   of   the   message *  \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithIncorrectTerminator"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertIncompleteDecode (  \" SEND \\ ncontent - length :  2  3  \\ n \\ nThe   body   of   the   mess \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithInsufficientContent"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    message    =    decode (  \" SEND \\ ncontent - length :  -  1  \\ n \\ nThe   body   of   the   message \\ u 0  0  0  0  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap ( message )  ;", "assertEquals ( StompCommand . SEND ,    headers . getCommand (  )  )  ;", "assertEquals (  1  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals ( Integer . valueOf (  (  -  1  )  )  ,    headers . getContentLength (  )  )  ;", "String   bodyText    =    new   String ( message . getPayload (  )  )  ;", "assertEquals (  \" The   body   of   the   message \"  ,    bodyText )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithInvalidContentLength"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertIncompleteDecode (  \" SEND \\ ncontent - type : text / plain ; charset = U \\ n \\ nThe   body \\ u 0  0  0  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithInvalidContentType"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "String   accept    =     \" accept - version :  1  .  1  \\ n \"  ;", "String   host    =     \" host : github . org \\ n \"  ;", "Message < byte [  ]  >        =    decode (  (  (  (  \" CONNECT \\ n \"     +    accept )     +    host )     +     \"  \\ n \\ u 0  0  0  0  \"  )  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap (  )  ;", "assertEquals ( StompCommand . CONNECT ,    headers . getCommand (  )  )  ;", "assertEquals (  2  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals (  \"  1  .  1  \"  ,    headers . getFirstNativeHeader (  \" accept - version \"  )  )  ;", "assertEquals (  \" github . org \"  ,    headers . getHost (  )  )  ;", "assertEquals (  0  ,     . getPayload (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithNoBody"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    frame    =    decode (  \" DISCONNECT \\ n \\ n \\ u 0  0  0  0  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap ( frame )  ;", "assertEquals ( StompCommand . DISCONNECT ,    headers . getCommand (  )  )  ;", "assertEquals (  0  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals (  0  ,    frame . getPayload (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithNoHeadersAndNoBody"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Message < byte [  ]  >    frame    =    decode (  \" SEND \\ ncontent - length :  2  3  \\ n \\ nThe   b \\ u 0  0  0  0 dy    \\ u 0  0  0  0 f   the   message \\ u 0  0  0  0  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . wrap ( frame )  ;", "assertEquals ( StompCommand . SEND ,    headers . getCommand (  )  )  ;", "assertEquals (  1  ,    headers . toNativeHeaderMap (  )  . size (  )  )  ;", "assertEquals ( Integer . valueOf (  2  3  )  ,    headers . getContentLength (  )  )  ;", "String   bodyText    =    new   String ( frame . getPayload (  )  )  ;", "assertEquals (  \" The   b \\ u 0  0  0  0 dy    \\ u 0  0  0  0 f   the   message \"  ,    bodyText )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithNullOctectsInTheBody"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "assertIncompleteDecode (  \" SEND \\ ndestination : test \\ n \"  )  ;", "assertIncompleteDecode (  \" SEND \\ ndestination : test \\ n \\ n \"  )  ;", "assertIncompleteDecode (  \" SEND \\ ndestination : test \\ n \\ nThe   body \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeFrameWithoutNullOctetTerminator"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "String   frame    =     \"  \\ n \"  ;", "ByteBuffer   buffer    =    ByteBuffer . wrap ( frame . getBytes (  )  )  ;", "final   List < Message < byte [  ]  >  >    es    =    decoder . decode ( buffer )  ;", "assertEquals (  1  ,    es . size (  )  )  ;", "assertEquals ( SimpMessageType . HEARTBEAT ,    StompHeaderAccessor . wrap ( es . get (  0  )  )  . getMessageType (  )  )  ;", "}", "METHOD_END"], "methodName": ["decodeHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "String   frame 1     =     \" SEND \\ ndestination : test \\ n \\ nThe   body   of   the   message \\ u 0  0  0  0  \"  ;", "String   frame 2     =     \" DISCONNECT \\ n \\ n \\ u 0  0  0  0  \"  ;", "ByteBuffer   buffer    =    ByteBuffer . wrap (  ( frame 1     +    frame 2  )  . getBytes (  )  )  ;", "final   List < Message < byte [  ]  >  >    messages    =    decoder . decode ( buffer )  ;", "assertEquals (  2  ,    messages . size (  )  )  ;", "assertEquals ( StompCommand . SEND ,    StompHeaderAccessor . wrap ( messages . get (  0  )  )  . getCommand (  )  )  ;", "assertEquals ( StompCommand . DISCONNECT ,    StompHeaderAccessor . wrap ( messages . get (  1  )  )  . getCommand (  )  )  ;", "}", "METHOD_END"], "methodName": ["decodeMultipleFramesFromSameBuffer"], "fileName": "org.springframework.messaging.simp.stomp.StompDecoderTests"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( headers ,     \"  ' headers '    is   required \"  )  ;", "Assert . notNull ( payload ,     \"  ' payload '    is   required \"  )  ;", "try    {", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  (  1  2  8     +     ( payload . length )  )  )  ;", "DataOutputStream   output    =    new   DataOutputStream ( baos )  ;", "if    ( SimpMessageType . HEARTBEAT . equals ( SimpMessageHeaderAccessor . getMessageType ( headers )  )  )     {", ". logger . trace (  \" Encoding   heartbeat \"  )  ;", "output . write ( StompDecoder . HEARTBEAT _ PAYLOAD )  ;", "} else    {", "StompCommand   command    =    StompHeaderAccessor . getCommand ( headers )  ;", "if    ( command    =  =    null )     {", "throw   new   IllegalStateException (  (  \" Missing   STOMP   command :     \"     +    headers )  )  ;", "}", "output . write ( command . toString (  )  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "output . write (  . LF )  ;", "writeHeaders ( command ,    headers ,    payload ,    output )  ;", "output . write (  . LF )  ;", "writeBody ( payload ,    output )  ;", "output . write (  (  ( byte )     (  0  )  )  )  ;", "}", "return   baos . toByteArray (  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   StompConversionException (  (  \" Failed   to   encode   STOMP   frame ,    headers =  \"     +    headers )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoder"}, {"methodBody": ["METHOD_START", "{", "return   encode ( message . getHeaders (  )  ,    message . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoder"}, {"methodBody": ["METHOD_START", "{", "String   inputToUse    =     ( escape )     ?    escape ( input )     :    input ;", "if    ( this . headerKeyAccessCache . containsKey ( inputToUse )  )     {", "return   this . headerKeyAccessCache . get ( inputToUse )  ;", "}", "synchronized ( this . headerKeyUpdateCache )     {", "byte [  ]    bytes    =    this . headerKeyUpdateCache . get ( inputToUse )  ;", "if    ( bytes    =  =    null )     {", "bytes    =    inputToUse . getBytes ( StandardCharsets . UTF _  8  )  ;", "this . headerKeyAccessCache . put ( inputToUse ,    bytes )  ;", "this . headerKeyUpdateCache . put ( inputToUse ,    bytes )  ;", "}", "return   bytes ;", "}", "}", "METHOD_END"], "methodName": ["encodeHeaderKey"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoder"}, {"methodBody": ["METHOD_START", "{", "String   inputToUse    =     ( escape )     ?    escape ( input )     :    input ;", "return   inputToUse . getBytes ( StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["encodeHeaderValue"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoder"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    null ;", "for    ( int   i    =     0  ;    i    <     ( inString . length (  )  )  ;    i +  +  )     {", "char   c    =    inString . charAt ( i )  ;", "if    ( c    =  =     '  \\  \\  '  )     {", "sb    =    getStringBuilder ( sb ,    inString ,    i )  ;", "sb . append (  \"  \\  \\  \\  \\  \"  )  ;", "} else", "if    ( c    =  =     '  :  '  )     {", "sb    =    getStringBuilder ( sb ,    inString ,    i )  ;", "sb . append (  \"  \\  \\ c \"  )  ;", "} else", "if    ( c    =  =     '  \\ n '  )     {", "sb    =    getStringBuilder ( sb ,    inString ,    i )  ;", "sb . append (  \"  \\  \\ n \"  )  ;", "} else", "if    ( c    =  =     '  \\ r '  )     {", "sb    =    getStringBuilder ( sb ,    inString ,    i )  ;", "sb . append (  \"  \\  \\ r \"  )  ;", "} else", "if    ( sb    !  =    null )     {", "sb . append ( c )  ;", "}", "}", "return   sb    !  =    null    ?    sb . toString (  )     :    inString ;", "}", "METHOD_END"], "methodName": ["escape"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoder"}, {"methodBody": ["METHOD_START", "{", "if    ( sb    =  =    null )     {", "sb    =    new   StringBuilder ( inString . length (  )  )  ;", "sb . append ( inStrubstring (  0  ,    i )  )  ;", "}", "return   sb ;", "}", "METHOD_END"], "methodName": ["getStringBuilder"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoder"}, {"methodBody": ["METHOD_START", "{", "output . write ( payload )  ;", "}", "METHOD_END"], "methodName": ["writeBody"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoder"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    List < String >  >    nativeHeaders    =     (  ( Map < String ,    List < String >  >  )     ( headers . get ( NativeMessageHeaderAccessor . NATIVE _ HEADERS )  )  )  ;", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  (  \" Encoding   STOMP    \"     +    command )     +     \"  ,    headers =  \"  )     +    nativeHeaders )  )  ;", "}", "if    ( nativeHeaders    =  =    null )     {", "return ;", "}", "boolean   shouldEscape    =     ( command    !  =     ( StompCommand . CONNECT )  )     &  &     ( command    !  =     ( StompCommand . CONNECTED )  )  ;", "for    ( Map . Entry < String ,    List < String >  >    entry    :    nativeHeaders . entrySet (  )  )     {", "if    (  ( command . requiresContentLength (  )  )     &  &     (  \" content - length \"  . equals ( entry . getKey (  )  )  )  )     {", "continue ;", "}", "List < String >    values    =    entry . getValue (  )  ;", "if    (  ( StompCommand . CONNECT . equals ( command )  )     &  &     ( StompHeaderAccessor . STOMP _ PASSCODE _ HEADER . equals ( entry . getKey (  )  )  )  )     {", "values    =    Collections . singletonList ( StompHeaderAccessor . getPasscode ( headers )  )  ;", "}", "byte [  ]    encodedKey    =    encodeHeaderKey ( entry . getKey (  )  ,    shouldEscape )  ;", "for    ( String   value    :    values )     {", "output . write ( encodedKey )  ;", "output . write (  . COLON )  ;", "output . write ( encodeHeaderValue ( value ,    shouldEscape )  )  ;", "output . write (  . LF )  ;", "}", "}", "if    ( command . requiresContentLength (  )  )     {", "int   contentLength    =    payload . length ;", "output . write (  \" content - length :  \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "output . write ( Integer . toString ( contentLength )  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "output . write (  . LF )  ;", "}", "}", "METHOD_END"], "methodName": ["writeHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoder"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SEND )  ;", "headers . setContentLength (  1  2  )  ;", "Message < byte [  ]  >    frame    =    MessageBuilder . createMessage (  \" Message   body \"  . getBytes (  )  ,    headers . getMessageHeaders (  )  )  ;", "assertEquals (  \" SEND \\ ncontent - length :  1  2  \\ n \\ nMessage   body \\ u 0  0  0  0  \"  ,    new   String ( e . encode ( frame )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeFrameWithContentLengthPresent"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoderTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . CONNECT )  ;", "headers . setAcceptVersion (  \"  1  .  2  \"  )  ;", "headers . setHost (  \" github . org \"  )  ;", "Message < byte [  ]  >    frame    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers . getMessageHeaders (  )  )  ;", "String   frameString    =    new   String ( e . encode ( frame )  )  ;", "assertTrue (  (  (  \" CONNECT \\ naccept - version :  1  .  2  \\ nhost : github . org \\ n \\ n \\ u 0  0  0  0  \"  . equals ( frameString )  )     |  |     (  \" CONNECT \\ nhost : github . org \\ naccept - version :  1  .  2  \\ n \\ n \\ u 0  0  0  0  \"  . equals ( frameString )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeFrameWithHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoderTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SEND )  ;", "headers . addNativeHeader (  \" a \"  ,     \" alpha \"  )  ;", "Message < byte [  ]  >    frame    =    MessageBuilder . createMessage (  \" Message   body \"  . getBytes (  )  ,    headers . getMessageHeaders (  )  )  ;", "assertEquals (  \" SEND \\ na : alpha \\ ncontent - length :  1  2  \\ n \\ nMessage   body \\ u 0  0  0  0  \"  ,    new   String ( e . encode ( frame )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeFrameWithHeadersBody"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoderTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . DISCONNECT )  ;", "headers . addNativeHeader (  \" a :  \\ r \\ n \\  \\ b \"  ,     \" alpha : bravo \\ r \\ n \\  \\  \"  )  ;", "Message < byte [  ]  >    frame    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers . getMessageHeaders (  )  )  ;", "assertEquals (  \" DISCONNECT \\ na \\  \\ c \\  \\ r \\  \\ n \\  \\  \\  \\ b : alpha \\  \\ cbravo \\  \\ r \\  \\ n \\  \\  \\  \\  \\ n \\ n \\ u 0  0  0  0  \"  ,    new   String ( e . encode ( frame )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeFrameWithHeadersThatShouldBeEscaped"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoderTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . DISCONNECT )  ;", "Message < byte [  ]  >    frame    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    headers . getMessageHeaders (  )  )  ;", "assertEquals (  \" DISCONNECT \\ n \\ n \\ u 0  0  0  0  \"  ,    new   String ( e . encode ( frame )  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeFrameWithNoHeadersAndNoBody"], "fileName": "org.springframework.messaging.simp.stomp.StompEncoderTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( payload . getClass (  )  )     !  =     ( byte [  ]  . class )  )     {", "throw   new   IllegalStateException (  (  \" Expected   byte   array   payload   but   got :     \"     +     ( ClassUtils . getQualifiedName ( payload . getClass (  )  )  )  )  )  ;", "}", "byte [  ]    bytes    =     (  ( byte [  ]  )     ( payload )  )  ;", "MimeType   mimeType    =    getContentType (  )  ;", "St   contentType    =     ( mimeType    !  =    null )     ?     \"     \"     +     ( mimeType . toSt (  )  )     :     \"  \"  ;", "if    (  (  (  ( bytes . length )     =  =     0  )     |  |     ( mimeType    =  =    null )  )     |  |     (  !  ( isReadableContentType (  )  )  )  )     {", "return   contentType ;", "}", "Charset   charset    =    mimeType . getCharset (  )  ;", "charset    =     ( charset    !  =    null )     ?    charset    :    StandardCharsets . UTF _  8  ;", "return    ( bytes . length )     <     8  0     ?     ( contentType    +     \"    payload =  \"  )     +     ( new   St ( bytes ,    charset )  )     :     (  ( contentType    +     \"    payload =  \"  )     +     ( new   St ( Arrays . copyOf ( bytes ,     8  0  )  ,    charset )  )  )     +     \"  .  .  .  ( truncated )  \"  ;", "}", "METHOD_END"], "methodName": ["appendPayload"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    \"    session =  \"     +     ( getSessionId (  )  )  ;", "}", "METHOD_END"], "methodName": ["appendSession"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   StompHeaderAccessor ( command ,    null )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   StompHeaderAccessor ( command ,    headers )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   StompHeaderAccessor (  )  ;", "}", "METHOD_END"], "methodName": ["createForHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "String   rawValue    =    getFirstNativeHeader ( StompHeaderAccessor . STOMP _ ACCEPT _ VERSION _ HEADER )  ;", "return   rawValue    !  =    null    ?    StringUtils . commaDelimitedListToSet ( rawValue )     :    Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["getAcceptVersion"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getFirstNativeHeader ( StompHeaderAccessor . STOMP _ ACK _ HEADER )  ;", "}", "METHOD_END"], "methodName": ["getAck"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( StompCommand )     ( getHeader ( StompHeaderAccessor . COMMAND _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCommand"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( StompCommand )     ( headers . get ( StompHeaderAccessor . COMMAND _ HEADER )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCommand"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "String   header    =    getFirstNativeHeader ( StompHeaderAccessor . STOMP _ CONTENT _ LENGTH _ HEADER )  ;", "return   header    !  =    null    ?    Integer . valueOf ( header )     :    null ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "List < String >    values    =    nativeHeaders . get ( StompHeaderAccessor . STOMP _ CONTENT _ LENGTH _ HEADER )  ;", "return    !  ( CollectionUtils . isEmpty ( values )  )     ?    Integer . valueOf ( values . get (  0  )  )     :    null ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "String   rawValue    =    getFirstNativeHeader ( StompHeaderAccessor . STOMP _ HEARTBEAT _ HEADER )  ;", "String [  ]    rawValues    =    StringUtils . split ( rawValue ,     \"  ,  \"  )  ;", "if    ( rawValues    =  =    null )     {", "return   Arrays . copyOf ( StompHeaderAccessor . DEFAULT _ HEARTBEAT ,     2  )  ;", "}", "return   new   long [  ]  {    Long . valueOf ( rawValues [  0  ]  )  ,    Long . valueOf ( rawValues [  1  ]  )     }  ;", "}", "METHOD_END"], "methodName": ["getHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getFirstNativeHeader ( StompHeaderAccessor . STOMP _ HOST _ HEADER )  ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getFirstNativeHeader ( StompHeaderAccessor . STOMP _ LOGIN _ HEADER )  ;", "}", "METHOD_END"], "methodName": ["getLogin"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getFirstNativeHeader ( StompHeaderAccessor . STOMP _ MESSAGE _ HEADER )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getFirstNativeHeader ( StompHeaderAccessor . STOMP _ MESSAGE _ ID _ HEADER )  ;", "}", "METHOD_END"], "methodName": ["getMessageId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getFirstNativeHeader ( StompHeaderAccessor . STOMP _ NACK _ HEADER )  ;", "}", "METHOD_END"], "methodName": ["getNack"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor . StompPasscode   credentials    =     (  ( StompHeaderAccessor . StompPasscode )     ( getHeader ( StompHeaderAccessor . CREDENTIALS _ HEADER )  )  )  ;", "return   credentials    !  =    null    ?    credentials . passcode    :    null ;", "}", "METHOD_END"], "methodName": ["getPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor . StompPasscode   credentials    =     (  ( StompHeaderAccessor . StompPasscode )     ( headers . get ( StompHeaderAccessor . CREDENTIALS _ HEADER )  )  )  ;", "return   credentials    !  =    null    ?    credentials . passcode    :    null ;", "}", "METHOD_END"], "methodName": ["getPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getFirstNativeHeader ( StompHeaderAccessor . STOMP _ RECEIPT _ HEADER )  ;", "}", "METHOD_END"], "methodName": ["getReceipt"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getFirstNativeHeader ( StompHeaderAccessor . STOMP _ RECEIPT _ ID _ HEADER )  ;", "}", "METHOD_END"], "methodName": ["getReceiptId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getFirstNativeHeader ( StompHeaderAccessor . STOMP _ VERSION _ HEADER )  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    ( SimpMessageType . HEARTBEAT )     =  =     ( getMessageType (  )  )  ;", "}", "METHOD_END"], "methodName": ["isHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirstNativeHeader ( StompHeaderAccessor . STOMP _ PASSCODE _ HEADER )  ;", "if    (  ( value    !  =    null )     &  &     (  !  (  \" PROTECTED \"  . equals ( value )  )  )  )     {", "setHeader ( StompHeaderAccessor . CREDENTIALS _ HEADER ,    new   StompHeaderAccessor . StompPasscode ( value )  )  ;", "setNativeHeader ( StompHeaderAccessor . STOMP _ PASSCODE _ HEADER ,     \" PROTECTED \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["protectPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ ACCEPT _ VERSION _ HEADER ,    acceptVersion )  ;", "}", "METHOD_END"], "methodName": ["setAcceptVersion"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ ACK _ HEADER ,    ack )  ;", "}", "METHOD_END"], "methodName": ["setAck"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ CONTENT _ LENGTH _ HEADER ,    String . valueOf ( contentLength )  )  ;", "}", "METHOD_END"], "methodName": ["setContentLength"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ HEARTBEAT _ HEADER ,     (  ( cx    +     \"  ,  \"  )     +    cy )  )  ;", "}", "METHOD_END"], "methodName": ["setHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ HOST _ HEADER ,    host )  ;", "}", "METHOD_END"], "methodName": ["setHost"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ LOGIN _ HEADER ,    login )  ;", "}", "METHOD_END"], "methodName": ["setLogin"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ MESSAGE _ HEADER ,    content )  ;", "}", "METHOD_END"], "methodName": ["setMessage"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ MESSAGE _ ID _ HEADER ,    id )  ;", "}", "METHOD_END"], "methodName": ["setMessageId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ NACK _ HEADER ,    nack )  ;", "}", "METHOD_END"], "methodName": ["setNack"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ PASSCODE _ HEADER ,    passcode )  ;", "protectPasscode (  )  ;", "}", "METHOD_END"], "methodName": ["setPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ RECEIPT _ HEADER ,    receiptId )  ;", "}", "METHOD_END"], "methodName": ["setReceipt"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ RECEIPT _ ID _ HEADER ,    receiptId )  ;", "}", "METHOD_END"], "methodName": ["setReceiptId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setNativeHeader ( StompHeaderAccessor . STOMP _ VERSION _ HEADER ,    version )  ;", "}", "METHOD_END"], "methodName": ["setVersion"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "String   subscriptionId    =    getSubscriptionId (  )  ;", "if    ( subscriptionId    !  =    null )     {", "StompCommand   command    =    getCommand (  )  ;", "if    (  ( command    !  =    null )     &  &     ( StompCommand . MESSAGE . equals ( command )  )  )     {", "setNativeHeader (  . STOMP _ SUBSCRIPTION _ HEADER ,    subscriptionId )  ;", "} else    {", "SimpMessageType   messageType    =    getMessageType (  )  ;", "if    (  ( SimpMessageType . SUBSCRIBE . equals ( messageType )  )     |  |     ( SimpMessageType . UNSUBSCRIBE . equals ( messageType )  )  )     {", "setNativeHeader (  . STOMP _ ID _ HEADER ,    subscriptionId )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["trySetStompHeaderForSubscriptionId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getNativeHeaders (  )  )     =  =    null )     {", "return ;", "}", "String   value    =    getFirstNativeHeader (  . STOMP _ DESTINATION _ HEADER )  ;", "if    ( value    !  =    null )     {", "super . setDestination ( value )  ;", "}", "value    =    getFirstNativeHeader (  . STOMP _ CONTENT _ TYPE _ HEADER )  ;", "if    ( value    !  =    null )     {", "super . setContentType ( MimeTypeUtils . parseMimeType ( value )  )  ;", "}", "StompCommand   command    =    getCommand (  )  ;", "if    ( StompCommand . MESSAGE . equals ( command )  )     {", "value    =    getFirstNativeHeader (  . STOMP _ SUBSCRIPTION _ HEADER )  ;", "if    ( value    !  =    null )     {", "super . setSubscriptionId ( value )  ;", "}", "} else", "if    (  ( StompCommand . SUBSCRIBE . equals ( command )  )     |  |     ( StompCommand . UNSUBSCRIBE . equals ( command )  )  )     {", "value    =    getFirstNativeHeader (  . STOMP _ ID _ HEADER )  ;", "if    ( value    !  =    null )     {", "super . setSubscriptionId ( value )  ;", "}", "} else", "if    ( StompCommand . CONNECT . equals ( command )  )     {", "protectPasscode (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateSimpMessageHeadersFromStompHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "SimpMessageType   messageType    =    getMessageType (  )  ;", "if    ( messageType    !  =     ( SimpMessageType . MESSAGE )  )     {", "throw   new   IllegalStateException (  (  \" Unexpected   message   type    \"     +    messageType )  )  ;", "}", "StompCommand   command    =    getCommand (  )  ;", "if    ( command    =  =    null )     {", "command    =    StompCommand . SEND ;", "setHeader (  . COMMAND _ HEADER ,    command )  ;", "} else", "if    (  !  ( command . equals ( StompCommand . SEND )  )  )     {", "throw   new   IllegalStateException (  (  \" Unexpected   STOMP   command    \"     +    command )  )  ;", "}", "return   command ;", "}", "METHOD_END"], "methodName": ["updateStompCommandAsClientMessage"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "SimpMessageType   messageType    =    getMessageType (  )  ;", "if    ( messageType    !  =     ( SimpMessageType . MESSAGE )  )     {", "throw   new   IllegalStateException (  (  \" Unexpected   message   type    \"     +    messageType )  )  ;", "}", "StompCommand   command    =    getCommand (  )  ;", "if    (  ( command    =  =    null )     |  |     ( StompCommand . SEND . equals ( command )  )  )     {", "setHeader (  . COMMAND _ HEADER ,    StompCommand . MESSAGE )  ;", "} else", "if    (  !  ( StompCommand . MESSAGE . equals ( command )  )  )     {", "throw   new   IllegalStateException (  (  \" Unexpected   STOMP   command    \"     +    command )  )  ;", "}", "trySetStompHeaderForSubscriptionId (  )  ;", "if    (  ( getMessageId (  )  )     =  =    null )     {", "String   messageId    =     (  ( getSessionId (  )  )     +     '  -  '  )     +     (  . messageIdCounter . getAndIncrement (  )  )  ;", "setNativeHeader (  . STOMP _ MESSAGE _ ID _ HEADER ,    messageId )  ;", "}", "}", "METHOD_END"], "methodName": ["updateStompCommandAsServerMessage"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "String   destination    =    getDestination (  )  ;", "if    ( destination    !  =    null )     {", "setNativeHeader (  . STOMP _ DESTINATION _ HEADER ,    destination )  ;", "}", "MimeType   contentType    =    getContentType (  )  ;", "if    ( contentType    !  =    null )     {", "setNativeHeader (  . STOMP _ CONTENT _ TYPE _ HEADER ,    contentType . toString (  )  )  ;", "}", "trySetStompHeaderForSubscriptionId (  )  ;", "}", "METHOD_END"], "methodName": ["updateStompHeadersFromSimpMessageHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   StompHeaderAccessor ( message )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . CONNECTED )  ;", "assertEquals ( StompCommand . CONNECTED ,    accessor . getCommand (  )  )  ;", "accessor    =    StompHeaderAccessor . create ( StompCommand . CONNECTED ,    new   util . LinkedMultiValueMap (  )  )  ;", "assertEquals ( StompCommand . CONNECTED ,    accessor . getCommand (  )  )  ;", "}", "METHOD_END"], "methodName": ["createWithCommand"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    extHeaders    =    new   LinkedMultiValueMap (  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ LOGIN _ HEADER ,     \" joe \"  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ PASSCODE _ HEADER ,     \" joe 1  2  3  \"  )  ;", "StompHeaderAccessor   headerAccessor    =    StompHeaderAccessor . create ( StompCommand . CONNECT ,    extHeaders )  ;", "assertEquals ( StompCommand . CONNECT ,    headerAccessor . getCommand (  )  )  ;", "assertEquals ( SimpMessageType . CONNECT ,    headerAccessor . getMessageType (  )  )  ;", "assertNotNull ( headerAccessor . getHeader (  \" stompCredentials \"  )  )  ;", "assertEquals (  \" joe \"  ,    headerAccessor . getLogin (  )  )  ;", "assertEquals (  \" joe 1  2  3  \"  ,    headerAccessor . getPasscode (  )  )  ;", "assertThat ( headerAccessor . toString (  )  ,    CoreMatchers . containsString (  \" passcode =  [ PROTECTED ]  \"  )  )  ;", "Map < String ,    List < String >  >    output    =    headerAccessor . toNativeHeaderMap (  )  ;", "assertEquals (  \" joe \"  ,    output . get ( StompHeaderAccessor . STOMP _ LOGIN _ HEADER )  . get (  0  )  )  ;", "assertEquals (  \" PROTECTED \"  ,    output . get ( StompHeaderAccessor . STOMP _ PASSCODE _ HEADER )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["createWithConnectNativeHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    extHeaders    =    new   LinkedMultiValueMap (  )  ;", "extHeaders . add ( StompHeaderAccessor . DESTINATION _ HEADER ,     \"  / d \"  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ SUBSCRIPTION _ HEADER ,     \" s 1  \"  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ CONTENT _ TYPE _ HEADER ,     \" application / json \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . MESSAGE ,    extHeaders )  ;", "assertEquals ( StompCommand . MESSAGE ,    headers . getCommand (  )  )  ;", "assertEquals ( SimpMessageType . MESSAGE ,    headers . getMessageType (  )  )  ;", "assertEquals (  \" s 1  \"  ,    headers . getSubscriptionId (  )  )  ;", "}", "METHOD_END"], "methodName": ["createWithMessageFrameNativeHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    extHeaders    =    new   LinkedMultiValueMap (  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ ID _ HEADER ,     \" s 1  \"  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ DESTINATION _ HEADER ,     \"  / d \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SUBSCRIBE ,    extHeaders )  ;", "assertEquals ( StompCommand . SUBSCRIBE ,    headers . getCommand (  )  )  ;", "assertEquals ( SimpMessageType . SUBSCRIBE ,    headers . getMessageType (  )  )  ;", "assertEquals (  \"  / d \"  ,    headers . getDestination (  )  )  ;", "assertEquals (  \" s 1  \"  ,    headers . getSubscriptionId (  )  )  ;", "}", "METHOD_END"], "methodName": ["createWithSubscribeNativeHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    extHeaders    =    new   LinkedMultiValueMap (  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ ID _ HEADER ,     \" s 1  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . UNSUBSCRIBE ,    extHeaders )  ;", "assertEquals ( StompCommand . UNSUBSCRIBE ,    headers . getCommand (  )  )  ;", "assertEquals ( SimpMessageType . UNSUBSCRIBE ,    headers . getMessageType (  )  )  ;", "assertEquals (  \" s 1  \"  ,    headers . getSubscriptionId (  )  )  ;", "}", "METHOD_END"], "methodName": ["createWithUnubscribeNativeHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    extHeaders    =    new   LinkedMultiValueMap (  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ LOGIN _ HEADER ,     \" joe \"  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ PASSCODE _ HEADER ,     \" joe 1  2  3  \"  )  ;", "StompHeaderAccessor   headerAccessor    =    StompHeaderAccessor . create ( StompCommand . CONNECT ,    extHeaders )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    headerAccessor . getMessageHeaders (  )  )  ;", "byte [  ]    bytes    =    new   StompEncoder (  )  . encode ( message )  ;", "assertEquals (  \" CONNECT \\ nlogin : joe \\ npasscode : joe 1  2  3  \\ n \\ n \\ u 0  0  0  0  \"  ,    new   String ( bytes ,     \" UTF -  8  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeConnectWithLoginAndPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headerAccessor    =    StompHeaderAccessor . create ( StompCommand . CONNECT )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    headerAccessor . getMessageHeaders (  )  )  ;", "assertSame ( headerAccessor ,    MessageHeaderAccessor . getAccessor ( message ,    StompHeaderAccessor . class )  )  ;", "}", "METHOD_END"], "methodName": ["getAccessor"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . SEND )  ;", "accessor . setDestination (  \"  / foo \"  )  ;", "accessor . setContentType ( APPLICATION _ JSON )  ;", "accessor . setSessionId (  \"  1  2  3  \"  )  ;", "String   actual    =    accessor . getShortLogMessage (  \" payload \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  \" SEND    / foo   session =  1  2  3    application / json   payload = payload \"  ,    actual )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     8  0  ;    i +  +  )     {", "sb . append (  \" a \"  )  ;", "}", "final   String   payload    =     ( sb . toString (  )  )     +     \"     >     8  0  \"  ;", "actual    =    accessor . getShortLogMessage ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  (  (  \" SEND    / foo   session =  1  2  3    application / json   payload =  \"     +    sb )     +     \"  .  .  .  ( truncated )  \"  )  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["getShortLogMessage"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headerAccessor    =    StompHeaderAccessor . create ( StompCommand . SEND )  ;", "MessageHeaders   headers    =    headerAccessor . getMessageHeaders (  )  ;", "assertNull ( headers . getId (  )  )  ;", "assertNull ( headers . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["messageIdAndTimestampDefaultBehavior"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IdTimestampMessageHeaderInitializer   headerInitializer    =    new   IdTimestampMessageHeaderInitializer (  )  ;", "headerInitializer . setIdGenerator ( new   AlternativeJdkIdGenerator (  )  )  ;", "headerInitializer . setEnableTimestamp ( true )  ;", "headerAccessor    =     . create ( StompCommand . SEND )  ;", "headerInitializer . initHeaders ( headerAccessor )  ;", "assertNotNull ( headerAccessor . getMessageHeaders (  )  . getId (  )  )  ;", "assertNotNull ( headerAccessor . getMessageHeaders (  )  . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["messageIdAndTimestampEnabled"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    extHeaders    =    new   LinkedMultiValueMap (  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ ID _ HEADER ,     \" s 1  \"  )  ;", "extHeaders . add ( StompHeaderAccessor . STOMP _ DESTINATION _ HEADER ,     \"  / d \"  )  ;", "extHeaders . add (  \" accountId \"  ,     \" ABC 1  2  3  \"  )  ;", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SUBSCRIBE ,    extHeaders )  ;", "String   accountId    =    headers . getFirstNativeHeader (  \" accountId \"  )  ;", "headers . setNativeHeader (  \" accountId \"  ,    accountId . toLowerCase (  )  )  ;", "Map < String ,    List < String >  >    actual    =    headers . toNativeHeaderMap (  )  ;", "assertEquals (  3  ,    actual . size (  )  )  ;", "assertEquals (  \" s 1  \"  ,    actual . get ( StompHeaderAccessor . STOMP _ ID _ HEADER )  . get (  0  )  )  ;", "assertEquals (  \"  / d \"  ,    actual . get ( StompHeaderAccessor . STOMP _ DESTINATION _ HEADER )  . get (  0  )  )  ;", "assertNotNull (  \" abc 1  2  3  \"  ,    actual . get (  \" accountId \"  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["modifyCustomNativeHeader"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   simpHeaderAccessor    =    SimpMessageHeaderAccessor . create (  )  ;", "simpHeaderAccessor . setContentType ( MimeType . valueOf (  \" application / atom + xml \"  )  )  ;", "Message < byte [  ]  >    message    =    MessageBuilder . createMessage ( new   byte [  0  ]  ,    simpHeaderAccessor . getMessageHeaders (  )  )  ;", "stompHeaderAccessor    =     . wrap ( message )  ;", "Map < String ,    List < String >  >    map    =    stompHeaderAccessor . toNativeHeaderMap (  )  ;", "assertEquals (  \" application / atom + xml \"  ,    map . get (  . STOMP _ CONTENT _ TYPE _ HEADER )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["toNativeHeadersContentType"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . MESSAGE )  ;", "headers . setSubscriptionId (  \" s 1  \"  )  ;", "headers . setDestination (  \"  / d \"  )  ;", "headers . setContentType ( APPLICATION _ JSON )  ;", "headers . updateStompCommandAsServerMessage (  )  ;", "Map < String ,    List < String >  >    actual    =    headers . toNativeHeaderMap (  )  ;", "assertEquals ( actual . toString (  )  ,     4  ,    actual . size (  )  )  ;", "assertEquals (  \" s 1  \"  ,    actual . get ( StompHeaderAccessor . STOMP _ SUBSCRIPTION _ HEADER )  . get (  0  )  )  ;", "assertEquals (  \"  / d \"  ,    actual . get ( StompHeaderAccessor . STOMP _ DESTINATION _ HEADER )  . get (  0  )  )  ;", "assertEquals (  \" application / json \"  ,    actual . get ( StompHeaderAccessor . STOMP _ CONTENT _ TYPE _ HEADER )  . get (  0  )  )  ;", "assertNotNull (  \" message - id   was   not   created \"  ,    actual . get ( StompHeaderAccessor . STOMP _ MESSAGE _ ID _ HEADER )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["toNativeHeadersMessageFrame"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . SUBSCRIBE )  ;", "headers . setSubscriptionId (  \" s 1  \"  )  ;", "headers . setDestination (  \"  / d \"  )  ;", "Map < String ,    List < String >  >    actual    =    headers . toNativeHeaderMap (  )  ;", "assertEquals (  2  ,    actual . size (  )  )  ;", "assertEquals (  \" s 1  \"  ,    actual . get ( StompHeaderAccessor . STOMP _ ID _ HEADER )  . get (  0  )  )  ;", "assertEquals (  \"  / d \"  ,    actual . get ( StompHeaderAccessor . STOMP _ DESTINATION _ HEADER )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["toNativeHeadersSubscribe"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "StompHeaderAccessor   headers    =    StompHeaderAccessor . create ( StompCommand . UNSUBSCRIBE )  ;", "headers . setSubscriptionId (  \" s 1  \"  )  ;", "Map < String ,    List < String >  >    actual    =    headers . toNativeHeaderMap (  )  ;", "assertEquals (  1  ,    actual . size (  )  )  ;", "assertEquals (  \" s 1  \"  ,    actual . get ( StompHeaderAccessor . STOMP _ ID _ HEADER )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["toNativeHeadersUnsubscribe"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . ACK )  ;", "}", "METHOD_END"], "methodName": ["getAck"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( StompHeaders . CONTENT _ LENGTH )  ;", "return   value    !  =    null    ?    Long . parseLong ( value )     :     -  1  ;", "}", "METHOD_END"], "methodName": ["getContentLength"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "String   value    =    getFirst ( StompHeaders . CONTENT _ TYPE )  ;", "return   StringUtils . hasLength ( value )     ?    MimeTypeUtils . parseMimeType ( value )     :    null ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . DESTINATION )  ;", "}", "METHOD_END"], "methodName": ["getDestination"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "String   rawValue    =    getFirst ( StompHeaders . HEARTBEAT )  ;", "String [  ]    rawValues    =    StringUtils . split ( rawValue ,     \"  ,  \"  )  ;", "if    ( rawValues    =  =    null )     {", "return   null ;", "}", "return   new   long [  ]  {    Long . valueOf ( rawValues [  0  ]  )  ,    Long . valueOf ( rawValues [  1  ]  )     }  ;", "}", "METHOD_END"], "methodName": ["getHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . HOST )  ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . ID )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . LOGIN )  ;", "}", "METHOD_END"], "methodName": ["getLogin"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . MESSAGE _ ID )  ;", "}", "METHOD_END"], "methodName": ["getMessageId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . PASSCODE )  ;", "}", "METHOD_END"], "methodName": ["getPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . RECEIPT )  ;", "}", "METHOD_END"], "methodName": ["getReceipt"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . RECEIPT _ ID )  ;", "}", "METHOD_END"], "methodName": ["getReceiptId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . SERVER )  ;", "}", "METHOD_END"], "methodName": ["getServer"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . SESSION )  ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   getFirst ( StompHeaders . SUBSCRIPTION )  ;", "}", "METHOD_END"], "methodName": ["getSubscription"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "long [  ]    heartbeat    =    getHeartbeat (  )  ;", "return    (  ( heartbeat    !  =    null )     &  &     (  ( heartbeat [  0  ]  )     !  =     0  )  )     &  &     (  ( heartbeat [  1  ]  )     !  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isHeartbeatEnabled"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   new   StompHeaders (  ( headers    !  =    null    ?    headers    :    Collections . emptyMap (  )  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["readOnlyStompHeaders"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . ACK ,    ack )  ;", "}", "METHOD_END"], "methodName": ["setAck"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . CONTENT _ LENGTH ,    Long . toString ( contentLength )  )  ;", "}", "METHOD_END"], "methodName": ["setContentLength"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "if    ( mimeType    !  =    null )     {", "Assert . isTrue (  (  !  ( mimeType . isWildcardType (  )  )  )  ,     \"  ' Content - Type '    cannot   contain   wildcard   type    '  *  '  \"  )  ;", "Assert . isTrue (  (  !  ( mimeType . isWildcardSubtype (  )  )  )  ,     \"  ' Content - Type '    cannot   contain   wildcard   subtype    '  *  '  \"  )  ;", "set (  . CONTENT _ TYPE ,    mimeType . toString (  )  )  ;", "} else    {", "set (  . CONTENT _ TYPE ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["setContentType"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . DESTINATION ,    destination )  ;", "}", "METHOD_END"], "methodName": ["setDestination"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "if    (  ( heartbeat    =  =    null )     |  |     (  ( heartbeat . length )     !  =     2  )  )     {", "throw   new   IllegalArgumentException (  (  \" Heart - beat   array   must   be   of   length    2  ,    not    \"     +     ( heartbeat    !  =    null    ?    heartbeat . length    :     \" null \"  )  )  )  ;", "}", "String   value    =     (  ( heartbeat [  0  ]  )     +     \"  ,  \"  )     +     ( heartbeat [  1  ]  )  ;", "if    (  (  ( heartbeat [  0  ]  )     <     0  )     |  |     (  ( heartbeat [  1  ]  )     <     0  )  )     {", "throw   new   IllegalArgumentException (  (  \" Heart - beat   values   cannot   be   negative :     \"     +    value )  )  ;", "}", "set (  . HEARTBEAT ,    value )  ;", "}", "METHOD_END"], "methodName": ["setHeartbeat"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . HOST ,    host )  ;", "}", "METHOD_END"], "methodName": ["setHost"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . ID ,    id )  ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . LOGIN ,    login )  ;", "}", "METHOD_END"], "methodName": ["setLogin"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . MESSAGE _ ID ,    messageId )  ;", "}", "METHOD_END"], "methodName": ["setMessageId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . PASSCODE ,    passcode )  ;", "}", "METHOD_END"], "methodName": ["setPasscode"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . RECEIPT ,    receipt )  ;", "}", "METHOD_END"], "methodName": ["setReceipt"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . RECEIPT _ ID ,    receiptId )  ;", "}", "METHOD_END"], "methodName": ["setReceiptId"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . SERVER ,    server )  ;", "}", "METHOD_END"], "methodName": ["setServer"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . SESSION ,    session )  ;", "}", "METHOD_END"], "methodName": ["setSession"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "set ( StompHeaders . SUBSCRIPTION ,    subscription )  ;", "}", "METHOD_END"], "methodName": ["setSubscription"], "fileName": "org.springframework.messaging.simp.stomp.StompHeaders"}, {"methodBody": ["METHOD_START", "{", "return   ByteBuffer . wrap ( this . encoder . encode ( message )  )  ;", "}", "METHOD_END"], "methodName": ["encodeInternal"], "fileName": "org.springframework.messaging.simp.stomp.StompReactorNettyCodec"}, {"methodBody": ["METHOD_START", "{", "return   destination . startsWith ( requiredPrefix )  ;", "}", "METHOD_END"], "methodName": ["checkDestination"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . prefix ;", "}", "METHOD_END"], "methodName": ["getDestinationPrefix"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "Set < String >    sessionIds ;", "SimpUser    =    thisRegistry . getUserName )  ;", "if       !  =    null )     {", "if    (  ( sessionId    !  =    null )     &  &     (  . getSession ( sessionId )  )     !  =    null )  )     {", "sessionIds    =    Collections . singleton ( sessionId )  ;", "} else    {", "Set < SimpSession >    sessions    =  . getSessions (  )  ;", "sessionIds    =    new   HashSet <  >  ( sessions . size (  )  )  ;", "for    ( SimpSession   session    :    sessions )     {", "sessionIds . add ( session . getId (  )  )  ;", "}", "}", "} else    {", "sessionIds    =    Collections . emptySet (  )  ;", "}", "return   sessionIds ;", "}", "METHOD_END"], "methodName": ["getSessionIdsByUser"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . userRegistry ;", "}", "METHOD_END"], "methodName": ["getSimpUserRegistry"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "return    ( actualDestination    +     \"  - user \"  )     +    sessionId ;", "}", "METHOD_END"], "methodName": ["getTargetDestination"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . removeLeadingSlash ;", "}", "METHOD_END"], "methodName": ["isRemoveLeadingSlash"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers    =    message . getHeaders (  )  ;", "String   source    =    SimpMessageHeaderAccessor . get ( headers )  ;", "if    (  ( source    =  =    null )     |  |     (  !  ( check ( source ,    this . prefix )  )  )  )     {", "return   null ;", "}", "SimpMessageType   messageType    =    SimpMessageHeaderAccessor . getMessageType ( headers )  ;", "if    ( messageType    !  =    null )     {", "switch    ( messageType )     {", "case   SUBSCRIBE    :", "case   UNSUBSCRIBE    :", "return   parseSubscriptionMessage ( message ,    source )  ;", "case   MESSAGE    :", "return   parseMessage ( headers ,    source )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "int   prefixEnd    =    this . prefix . length (  )  ;", "int   userEnd    =    sourceDest . indexOf (  '  /  '  ,    prefixEnd )  ;", "Assert . isTrue (  ( userEnd    >     0  )  ,     \" Expected   destination   pattern    \\  \"  / user /  { userId }  /  *  *  \\  \"  \"  )  ;", "String   actualDest    =    sourceDest . substring ( userEnd )  ;", "String   subscribeDest    =     ( this . prefix . substring (  0  ,     ( prefixEnd    -     1  )  )  )     +    actualDest ;", "String   userName    =    sourceDest . substring ( prefixEnd ,    userEnd )  ;", "userName    =    StringUtils . replace ( userName ,     \"  %  2 F \"  ,     \"  /  \"  )  ;", "String   sessionId    =    SimpMessageHeaderAccessor . getSessionId ( headers )  ;", "Set < String >    sessionIds ;", "if    ( userName . equals ( sessionId )  )     {", "userName    =    null ;", "sessionIds    =    Collections . singleton ( sessionId )  ;", "} else    {", "sessionIds    =    getSessionIdsByUser ( userName ,    sessionId )  ;", "}", "if    ( isRemoveLeadingSlash (  )  )     {", "actualDest    =    actualDest . substring (  1  )  ;", "}", "return   new    . ParseResult ( sourceDest ,    actualDest ,    subscribeDest ,    sessionIds ,    userName )  ;", "}", "METHOD_END"], "methodName": ["parseMessage"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "MessageHeaders   headers    =    message . getHeaders (  )  ;", "String   sessionId    =    SimpMessageHeaderAccessor . getSessionId ( headers )  ;", "if    ( sessionId    =  =    null )     {", ". logger . error (  (  \" No   session   id .    Ignoring    \"     +    message )  )  ;", "return   null ;", "}", "int   prefixEnd    =     ( this . prefix . length (  )  )     -     1  ;", "String   actualDestination    =    sourceDestination . substring ( prefixEnd )  ;", "if    ( isRemoveLeadingSlash (  )  )     {", "actualDestination    =    actualDestination . substring (  1  )  ;", "}", "Principal   principal    =    SimpMessageHeaderAccessor . getUser ( headers )  ;", "String   user    =     ( principal    !  =    null )     ?    principal . getName (  )     :    null ;", "Set < String >    sessionIds    =    Collections . singleton ( sessionId )  ;", "return   new    . ParseResult ( sourceDestination ,    actualDestination ,    sourceDestination ,    sessionIds ,    user )  ;", "}", "METHOD_END"], "methodName": ["parseSubscriptionMessage"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "this . removeLeadingSlash    =    remove ;", "}", "METHOD_END"], "methodName": ["setRemoveLeadingSlash"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( prefix ,     \" Prefix   must   not   be   empty \"  )  ;", "this . prefix    =     ( prefix . endsWith (  \"  /  \"  )  )     ?    prefix    :    prefix    +     \"  /  \"  ;", "}", "METHOD_END"], "methodName": ["setUserDestinationPrefix"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolver"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . create ( type )  ;", "if    ( destination    !  =    null )     {", "headers . set ( destination )  ;", "}", "if    ( user    !  =    null )     {", "headers . setUser ( user )  ;", "}", "if    ( sessionId    !  =    null )     {", "headers . setSessionId ( sessionId )  ;", "}", "return   MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeaders ( headers )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "String   sourceDestination    =     \"  / user / joe / queue / foo \"  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . MESSAGE ,    user ,     \"  1  2  3  \"  ,    sourceDestination )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals ( sourceDestination ,    actual . getSourceDestination (  )  )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  \"  / queue / foo - user 1  2  3  \"  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "assertEquals (  \"  / user / queue / foo \"  ,    actual . getSubscribeDestination (  )  )  ;", "assertEquals ( user . getName (  )  ,    actual . getUser (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessage"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   userName    =     \" http :  /  / joe . openid . example . org /  \"  ;", "TestSimpUser   simpUser    =    new   TestSimpUser ( userName )  ;", "simpUser . addSessions ( new   TestSimpSession (  \" openid 1  2  3  \"  )  )  ;", "when ( this . registry . getUser ( userName )  )  . thenReturn ( simpUser )  ;", "String   destination    =     (  \"  / user /  \"     +     ( StringUtils . replace ( userName ,     \"  /  \"  ,     \"  %  2 F \"  )  )  )     +     \"  / queue / foo \"  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . MESSAGE ,    new   TestPrincipal (  \" joe \"  )  ,    null ,    destination )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  \"  / queue / foo - useropenid 1  2  3  \"  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageEncodedUserName"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setRemoveLeadingSlash ( true )  ;", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "String   destination    =     \"  / user / joe / jms . queue . call \"  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . MESSAGE ,    user ,     \"  1  2  3  \"  ,    destination )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  \" jms . queue . call - user 1  2  3  \"  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "assertEquals (  \"  / user / jms . queue . call \"  ,    actual . getSubscribeDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageForDestinationWithDotSeparator"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   otherSimpUser    =    new   TestSimpUser (  \" anna \"  )  ;", "otherSimpUser . addSessions ( new   TestSimpSession (  \"  4  5  6  \"  )  )  ;", "when ( this . registry . getUser (  \" anna \"  )  )  . thenReturn ( otherSimpUser )  ;", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "TestPrincipal   otherUser    =    new   TestPrincipal (  \" anna \"  )  ;", "String   sourceDestination    =     \"  / user / anna / queue / foo \"  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . MESSAGE ,    user ,     \"  4  5  6  \"  ,    sourceDestination )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals ( sourceDestination ,    actual . getSourceDestination (  )  )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  \"  / queue / foo - user 4  5  6  \"  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "assertEquals (  \"  / user / queue / foo \"  ,    actual . getSubscribeDestination (  )  )  ;", "assertEquals ( otherUser . getName (  )  ,    actual . getUser (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageToOtherUser"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   sourceDestination    =     \"  / user /  \"     +     (  \"  1  2  3  \"     +     \"  / queue / foo \"  )  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . MESSAGE ,    null ,     \"  1  2  3  \"  ,    sourceDestination )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals ( sourceDestination ,    actual . getSourceDestination (  )  )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  \"  / queue / foo - user 1  2  3  \"  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "assertEquals (  \"  / user / queue / foo \"  ,    actual . getSubscribeDestination (  )  )  ;", "assertNull ( actual . getUser (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageWithNoUser"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "String   sourceDestination    =     \"  / user / queue / foo \"  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . SUBSCRIBE ,    user ,     \"  1  2  3  \"  ,    sourceDestination )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals ( sourceDestination ,    actual . getSourceDestination (  )  )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  \"  / queue / foo - user 1  2  3  \"  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( sourceDestination ,    actual . getSubscribeDestination (  )  )  ;", "assertEquals ( user . getName (  )  ,    actual . getUser (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleSubscribe"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "this . resolver . setRemoveLeadingSlash ( true )  ;", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "String   destination    =     \"  / user / jms . queue . call \"  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . SUBSCRIBE ,    user ,     \"  1  2  3  \"  ,    destination )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  \" jms . queue . call - user 1  2  3  \"  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( destination ,    actual . getSubscribeDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleSubscribeForDestinationWithoutLeadingSlash"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   sourceDestination    =     \"  / user / queue / foo \"  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . SUBSCRIBE ,    null ,     \"  1  2  3  \"  ,    sourceDestination )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals ( sourceDestination ,    actual . getSourceDestination (  )  )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  (  \"  / queue / foo - user \"     +     \"  1  2  3  \"  )  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( sourceDestination ,    actual . getSubscribeDestination (  )  )  ;", "assertNull ( actual . getUser (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleSubscribeNoUser"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   simpUser    =    new   TestSimpUser (  \" joe \"  )  ;", "simpUser . addSessions ( new   TestSimpSession (  \"  1  2  3  \"  )  ,    new   TestSimpSession (  \"  4  5  6  \"  )  )  ;", "when ( this . registry . getUser (  \" joe \"  )  )  . thenReturn ( simpUser )  ;", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . SUBSCRIBE ,    user ,     \"  4  5  6  \"  ,     \"  / user / queue / foo \"  )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  \"  / queue / foo - user 4  5  6  \"  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleSubscribeOneUserMultipleSessions"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . UNSUBSCRIBE ,    user ,     \"  1  2  3  \"  ,     \"  / user / queue / foo \"  )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertEquals (  1  ,    actual . getTargetDestinations (  )  . size (  )  )  ;", "assertEquals (  \"  / queue / foo - user 1  2  3  \"  ,    actual . getTargetDestinations (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleUnsubscribe"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "TestPrincipal   user    =    new   TestPrincipal (  \" joe \"  )  ;", "Message <  ?  >    message    =    createMessage ( SimpMessageType . MESSAGE ,    user ,     \"  1  2  3  \"  ,    null )  ;", "ult   actual    =    this . resolver . resolveDestination ( message )  ;", "assertNull ( actual )  ;", "message    =    createMessage ( SimpMessageType . MESSAGE ,    user ,     \"  1  2  3  \"  ,     \"  / queue / foo \"  )  ;", "actual    =    this . resolver . resolveDestination ( message )  ;", "assertNull ( actual )  ;", "message    =    createMessage ( SimpMessageType . SUBSCRIBE ,    user ,     \"  1  2  3  \"  ,     \"  / queue / foo \"  )  ;", "actual    =    this . resolver . resolveDestination ( message )  ;", "assertNull ( actual )  ;", "message    =    createMessage ( SimpMessageType . CONNECT ,    user ,     \"  1  2  3  \"  ,     \" user / joe / queue / foo \"  )  ;", "actual    =    this . resolver . resolveDestination ( message )  ;", "assertNull ( actual )  ;", "}", "METHOD_END"], "methodName": ["ignoreMessage"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   simpUser    =    new   TestSimpUser (  \" joe \"  )  ;", "simpUser . addSessions ( new   TestSimpSession (  \"  1  2  3  \"  )  )  ;", "this . registry    =    mock ( SimpUserRegistry . class )  ;", "when ( this . registry . getUser (  \" joe \"  )  )  . thenReturn ( simpUser )  ;", "this . resolver    =    new    ( this . registry )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.user.DefaultUserDestinationResolverTests"}, {"methodBody": ["METHOD_START", "{", "MultiServerUserRegistry . UserRegistrySnapshot   registry    =     (  ( MultiServerUserRegistry . UserRegistrySnapshot )     ( converter . fromMessage ( message ,    MultiServerUserRegistry . UserRegistrySnapshot . class )  )  )  ;", "if    (  ( registry    !  =    null )     &  &     (  !  ( registry . getId (  )  . equals ( this . id )  )  )  )     {", "registry . init ( expirationPeriod ,    this . sessionLookup )  ;", "this . remoteRegistries . put ( registry . getId (  )  ,    registry )  ;", "}", "}", "METHOD_END"], "methodName": ["addRemoteRegistryDto"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistry"}, {"methodBody": ["METHOD_START", "{", "String   host ;", "try    {", "host    =    InetAddress . getLocalHost (  )  . getHostAddress (  )  ;", "}    catch    ( UnknownHostException   ex )     {", "host    =     \" unknown \"  ;", "}", "return    ( host    +     '  -  '  )     +     ( UUID . randomUUID (  )  )  ;", "}", "METHOD_END"], "methodName": ["generateId"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistry"}, {"methodBody": ["METHOD_START", "{", "return   new   MultiServerUserRegistry . UserRegistrySnapshot ( this . id ,    this . localRegistry )  ;", "}", "METHOD_END"], "methodName": ["getLocalRegistryDto"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistry"}, {"methodBody": ["METHOD_START", "{", "long   now    =    System . currentTimeMillis (  )  ;", "this . remoteies . entrySet (  )  . removeIf (  (    entry )     -  >    entry . getValue (  )  . isExpired ( now )  )  ;", "}", "METHOD_END"], "methodName": ["purgeExpiredRegistries"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistry"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   user 1     =    new   TestSimpUser (  \" joe \"  )  ;", "TestSimpUser   user 2     =    new   TestSimpUser (  \" jane \"  )  ;", "TestSimpUser   user 3     =    new   TestSimpUser (  \" jack \"  )  ;", "TestSimpSession   session 1     =    new   TestSimpSession (  \" sess 1  \"  )  ;", "TestSimpSession   session 2     =    new   TestSimpSession (  \" sess 2  \"  )  ;", "TestSimpSession   session 3     =    new   TestSimpSession (  \" sess 3  \"  )  ;", "session 1  . addSubscriptions ( new   TestSimpSubscription (  \" sub 1  \"  ,     \"  / match \"  )  )  ;", "session 2  . addSubscriptions ( new   TestSimpSubscription (  \" sub 1  \"  ,     \"  / match \"  )  )  ;", "session 3  . addSubscriptions ( new   TestSimpSubscription (  \" sub 1  \"  ,     \"  / not - a - match \"  )  )  ;", "user 1  . addSessions ( session 1  )  ;", "user 2  . addSessions ( session 2  )  ;", "user 3  . addSessions ( session 3  )  ;", "SimpUserRegistry   userRegistry    =    mock ( SimpUserRegistry . class )  ;", "when ( userRegistry . getUsers (  )  )  . thenReturn ( new   HashSet ( Arrays . asList ( user 1  ,    user 2  ,    user 3  )  )  )  ;", "Object   registryDto    =    new    ( userRegistry )  . getLocalRegistryDto (  )  ;", "Message <  ?  >    message    =    this . converter . toMessage ( registryDto ,    null )  ;", "this . registry . addRemoteRegistryDto ( message ,    this . converter ,     2  0  0  0  0  )  ;", "assertEquals (  3  ,    this . registry . getUserCount (  )  )  ;", "Set < SimpSubscription >    matches    =    this . registry . findSubscriptions (  (    s )     -  >    s . getDestination (  )  . equals (  \"  / match \"  )  )  ;", "assertEquals (  2  ,    matches . size (  )  )  ;", "Iterator < SimpSubscription >    iterator    =    matches . iterator (  )  ;", "Set < String >    sessionIds    =    new   HashSet <  >  (  2  )  ;", "sessionIds . add ( iterator . next (  )  . getSession (  )  . getId (  )  )  ;", "sessionIds . add ( iterator . next (  )  . getSession (  )  . getId (  )  )  ;", "assertEquals ( new   HashSet ( Arrays . asList (  \" sess 1  \"  ,     \" sess 2  \"  )  )  ,    sessionIds )  ;", "}", "METHOD_END"], "methodName": ["findSubscriptionsFromRemoteRegistry"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   localUser    =    new   TestSimpUser (  \" joe \"  )  ;", "TestSimpSession   localSession    =    new   TestSimpSession (  \" sess 1  2  3  \"  )  ;", "localUser . addSessions ( localSession )  ;", "when ( this . localRegistry . getUser (  \" joe \"  )  )  . thenReturn ( localUser )  ;", "TestSimpUser   remoteUser    =    new   TestSimpUser (  \" joe \"  )  ;", "TestSimpSession   remoteSession    =    new   TestSimpSession (  \" sess 4  5  6  \"  )  ;", "remoteUser . addSessions ( remoteSession )  ;", "SimpUserRegistry   remoteRegistry    =    mock ( SimpUserRegistry . class )  ;", "when ( remoteRegistry . getUsers (  )  )  . thenReturn ( Collections . singleton ( remoteUser )  )  ;", "Object   remoteRegistryDto    =    new    ( remoteRegistry )  . getLocalRegistryDto (  )  ;", "Message <  ?  >    message    =    this . converter . toMessage ( remoteRegistryDto ,    null )  ;", "this . registry . addRemoteRegistryDto ( message ,    this . converter ,     2  0  0  0  0  )  ;", "assertEquals (  1  ,    this . registry . getUserCount (  )  )  ;", "SimpUser   user    =    this . registry . getUsers (  )  . iterator (  )  . next (  )  ;", "assertTrue ( user . hasSessions (  )  )  ;", "assertEquals (  2  ,    user . getSessions (  )  . size (  )  )  ;", "assertThat ( user . getSessions (  )  ,    containsInAnyOrder ( localSession ,    remoteSession )  )  ;", "assertSame ( localSession ,    user . getSession (  \" sess 1  2  3  \"  )  )  ;", "assertEquals ( remoteSession ,    user . getSession (  \" sess 4  5  6  \"  )  )  ;", "user    =    this . registry . getUser (  \" joe \"  )  ;", "assertEquals (  2  ,    user . getSessions (  )  . size (  )  )  ;", "assertThat ( user . getSessions (  )  ,    containsInAnyOrder ( localSession ,    remoteSession )  )  ;", "assertSame ( localSession ,    user . getSession (  \" sess 1  2  3  \"  )  )  ;", "assertEquals ( remoteSession ,    user . getSession (  \" sess 4  5  6  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getSessionsWhenUserIsConnectedToMultipleServers"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "SimpUser   user    =    Mockito . mock ( SimpUser . class )  ;", "Set < SimpUser >    users    =    Collections . singleton ( user )  ;", "when ( this . local . getUsers (  )  )  . thenReturn ( users )  ;", "when ( this . local . getUserCount (  )  )  . thenReturn (  1  )  ;", "when ( this . local . getUser (  \" joe \"  )  )  . thenReturn ( user )  ;", "assertEquals (  1  ,    this . registry . getUserCount (  )  )  ;", "assertSame ( user ,    this . registry . getUser (  \" joe \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getUserFromLocalRegistry"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   testUser    =    new   TestSimpUser (  \" joe \"  )  ;", "TestSimpSession   testSession    =    new   TestSimpSession (  \" remote - sess \"  )  ;", "testSession . addSubscriptions ( new   TestSimpSubscription (  \" remote - sub \"  ,     \"  / remote - dest \"  )  )  ;", "testUser . addSessions ( testSession )  ;", "SimpUserRegistry   testRegistry    =    mock ( SimpUserRegistry . class )  ;", "when ( testRegistry . getUsers (  )  )  . thenReturn ( Collections . singleton ( testUser )  )  ;", "Object   registryDto    =    new    ( testRegistry )  . getLocalRegistryDto (  )  ;", "Message <  ?  >    message    =    this . converter . toMessage ( registryDto ,    null )  ;", "this . registry . addRemoteRegistryDto ( message ,    this . converter ,     2  0  0  0  0  )  ;", "assertEquals (  1  ,    this . registry . getUserCount (  )  )  ;", "SimpUser   user    =    this . registry . getUser (  \" joe \"  )  ;", "assertNotNull ( user )  ;", "assertTrue ( user . hasSessions (  )  )  ;", "assertEquals (  1  ,    user . getSessions (  )  . size (  )  )  ;", "SimpSession   session    =    user . getSession (  \" remote - sess \"  )  ;", "assertNotNull ( session )  ;", "assertEquals (  \" remote - sess \"  ,    session . getId (  )  )  ;", "assertSame ( user ,    session . getUser (  )  )  ;", "assertEquals (  1  ,    session . getSubscriptions (  )  . size (  )  )  ;", "SimpSubscription   subscription    =    session . getSubscriptions (  )  . iterator (  )  . next (  )  ;", "assertEquals (  \" remote - sub \"  ,    subscription . getId (  )  )  ;", "assertSame ( session ,    subscription . getSession (  )  )  ;", "assertEquals (  \"  / remote - dest \"  ,    subscription . getDestination (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUserFromRemoteRegistry"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   testUser    =    new   TestSimpUser (  \" joe \"  )  ;", "testUser . addSessions ( new   TestSimpSession (  \" remote - sub \"  )  )  ;", "SimpUserRegistry   testRegistry    =    mock ( SimpUserRegistry . class )  ;", "when ( testRegistry . getUsers (  )  )  . thenReturn ( Collections . singleton ( testUser )  )  ;", "Object   registryDto    =    new    ( testRegistry )  . getLocalRegistryDto (  )  ;", "Message <  ?  >    message    =    this . converter . toMessage ( registryDto ,    null )  ;", "this . registry . addRemoteRegistryDto ( message ,    this . converter ,     (  -  1  )  )  ;", "assertEquals (  1  ,    this . registry . getUserCount (  )  )  ;", "this . registry . purgeExpiredRegistries (  )  ;", "assertEquals (  0  ,    this . registry . getUserCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["purgeExpiredRegistries"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "this . localRegistry    =    Mockito . mock ( SimpUserRegistry . class )  ;", "this . registry    =    new    ( this . localRegistry )  ;", "this . converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.user.MultiServerUserRegistryTests"}, {"methodBody": ["METHOD_START", "{", "for    ( TestSimpSubscription   subscription    :    subscriptions )     {", "subscription . setSession ( this )  ;", "this . subscriptions . add ( subscription )  ;", "}", "}", "METHOD_END"], "methodName": ["addSubscriptions"], "fileName": "org.springframework.messaging.simp.user.TestSimpSession"}, {"methodBody": ["METHOD_START", "{", "this . user    =    user ;", "}", "METHOD_END"], "methodName": ["setUser"], "fileName": "org.springframework.messaging.simp.user.TestSimpSession"}, {"methodBody": ["METHOD_START", "{", "this . session    =    session ;", "}", "METHOD_END"], "methodName": ["setSession"], "fileName": "org.springframework.messaging.simp.user.TestSimpSubscription"}, {"methodBody": ["METHOD_START", "{", "for    ( TestSimpSession   session    :    sessions )     {", "session . setUser ( this )  ;", "this . sessions . put ( session . getId (  )  ,    session )  ;", "}", "}", "METHOD_END"], "methodName": ["addSessions"], "fileName": "org.springframework.messaging.simp.user.TestSimpUser"}, {"methodBody": ["METHOD_START", "{", "return    ( this . broadcastHandler )     !  =    null    ?    this . broadcastHandler . getBroadcastDestination (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getBroadcastDestination"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . messagingTemplate ;", "}", "METHOD_END"], "methodName": ["getBrokerMessagingTemplate"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . headerInitializer ;", "}", "METHOD_END"], "methodName": ["getHeaderInitializer"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . destinationResolver ;", "}", "METHOD_END"], "methodName": ["getUserDestinationResolver"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getHeaderInitializer (  )  )     !  =    null )     {", "getHeaderInitializer (  )  . initHeaders ( headerAccor )  ;", "}", "}", "METHOD_END"], "methodName": ["initHeaders"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . broadcastHandler    =     ( StringUtils . hasText ( destination )  )     ?    new   UserDestinationMessageHandler . BroadcastHandler ( this . messagingTemplate ,    destination )     :    null ;", "}", "METHOD_END"], "methodName": ["setBroadcastDestination"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . headerInitializer    =    headerInitializer ;", "}", "METHOD_END"], "methodName": ["setHeaderInitializer"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandler"}, {"methodBody": ["METHOD_START", "{", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . create ( type )  ;", "if    ( destination    !  =    null )     {", "headers . set ( destination )  ;", "}", "if    ( user    !  =    null )     {", "headers . setUser ( new   TestPrincipal ( user )  )  ;", "}", "if    ( sessionId    !  =    null )     {", "headers . setSessionId ( sessionId )  ;", "}", "return   MessageBuilder . withPayload ( new   byte [  0  ]  )  . setHeaders ( headers )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createWith"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   simpUser    =    new   TestSimpUser (  \" joe \"  )  ;", "simpUser . addSessions ( new   TestSimpSession (  \"  1  2  3  \"  )  )  ;", "when ( this . registry . getUser (  \" joe \"  )  )  . thenReturn ( simpUser )  ;", "given ( this . brokerChannel . send ( Mockito . any ( Message . class )  )  )  . willReturn ( true )  ;", "this . handler . handleMessage ( createWith ( SimpMessageType . MESSAGE ,     \" joe \"  ,     \"  1  2  3  \"  ,     \"  / user / joe / queue / foo \"  )  )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "Mockito . verify ( this . brokerChannel )  . send ( captor . capture (  )  )  ;", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . wrap ( captor . getValue (  )  )  ;", "assertEquals (  \"  / queue / foo - user 1  2  3  \"  ,    accessor . get (  )  )  ;", "assertEquals (  \"  / user / queue / foo \"  ,    accessor . getFirstNativeHeader ( SimpMessageHeaderAccessor . ORIGINAL _ DESTINATION )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessage"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   simpUser    =    new   TestSimpUser (  \" joe \"  )  ;", "simpUser . addSessions ( new   TestSimpSession (  \"  1  2  3  \"  )  )  ;", "when ( this . registry . getUser (  \" joe \"  )  )  . thenReturn ( simpUser )  ;", "this . handler . setBroadcast (  \"  / topic / unresolved \"  )  ;", "given ( this . brokerChannel . send ( Mockito . any ( Message . class )  )  )  . willReturn ( true )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . MESSAGE )  ;", "accessor . setSessionId (  \" system 1  2  3  \"  )  ;", "accessor . set (  \"  / topic / unresolved \"  )  ;", "accessor . setNativeHeader ( SimpMessageHeaderAccessor . ORIGINAL _ DESTINATION ,     \"  / user / joe / queue / foo \"  )  ;", "accessor . setNativeHeader (  \" customHeader \"  ,     \" customHeaderValue \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "byte [  ]    payload    =     \" payload \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "this . handler . handleMessage ( MessageBuilder . createMessage ( payload ,    accessor . getMessageHeaders (  )  )  )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "Mockito . verify ( this . brokerChannel )  . send ( captor . capture (  )  )  ;", "assertNotNull ( captor . getValue (  )  )  ;", "SimpMessageHeaderAccessor   headers    =    SimpMessageHeaderAccessor . wrap ( captor . getValue (  )  )  ;", "assertEquals (  \"  / queue / foo - user 1  2  3  \"  ,    headers . get (  )  )  ;", "assertEquals (  \"  / user / queue / foo \"  ,    headers . getFirstNativeHeader ( SimpMessageHeaderAccessor . ORIGINAL _ DESTINATION )  )  ;", "assertEquals (  \" customHeaderValue \"  ,    headers . getFirstNativeHeader (  \" customHeader \"  )  )  ;", "assertArrayEquals ( payload ,     (  ( byte [  ]  )     ( captor . getValue (  )  . getPayload (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFromBrokerWithActiveSession"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . setBroadcastDestination (  \"  / topic / unresolved \"  )  ;", "given ( this . brokerChannel . send ( Mockito . any ( Message . class )  )  )  . willReturn ( true )  ;", "StompHeaderAccessor   accessor    =    StompHeaderAccessor . create ( StompCommand . MESSAGE )  ;", "accessor . setSessionId (  \" system 1  2  3  \"  )  ;", "accessor . setDestination (  \"  / topic / unresolved \"  )  ;", "accessor . setNativeHeader ( SimpMessageHeaderAccessor . ORIGINAL _ DESTINATION ,     \"  / user / joe / queue / foo \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "byte [  ]    payload    =     \" payload \"  . getBytes ( StandardCharsets . UTF _  8  )  ;", "this . handler . handleMessage ( MessageBuilder . createMessage ( payload ,    accessor . getMessageHeaders (  )  )  )  ;", "verifyNoMoreInteractions ( this . brokerChannel )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFromBrokerWithoutActiveSession"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . setBroadcastDestination (  \"  / topic / unresolved \"  )  ;", "given ( this . brokerChannel . send ( Mockito . any ( Message . class )  )  )  . willReturn ( true )  ;", "this . handler . handleMessage ( createWith ( SimpMessageType . MESSAGE ,     \" joe \"  ,     \"  1  2  3  \"  ,     \"  / user / joe / queue / foo \"  )  )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "Mockito . verify ( this . brokerChannel )  . send ( captor . capture (  )  )  ;", "Message   message    =    captor . getValue (  )  ;", "SimpMessageHeaderAccessor   accessor    =    SimpMessageHeaderAccessor . wrap ( message )  ;", "assertEquals (  \"  / topic / unresolved \"  ,    accessor . getDestination (  )  )  ;", "assertEquals (  \"  / user / joe / queue / foo \"  ,    accessor . getFirstNativeHeader ( SimpMessageHeaderAccessor . ORIGINAL _ DESTINATION )  )  ;", "this . handler . handleMessage ( message )  ;", "Mockito . verifyNoMoreInteractions ( this . brokerChannel )  ;", "}", "METHOD_END"], "methodName": ["handleMessageWithoutActiveSession"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . brokerChannel . send ( Mockito . any ( Message . class )  )  )  . willReturn ( true )  ;", "this . handler . handleMessage ( createWith ( SimpMessageType . SUBSCRIBE ,     \" joe \"  ,     . SESSION _ ID ,     \"  / user / queue / foo \"  )  )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "Mockito . verify ( this . brokerChannel )  . send ( captor . capture (  )  )  ;", "Message   message    =    captor . getValue (  )  ;", "assertEquals (  \"  / queue / foo - user 1  2  3  \"  ,    SimpMessageHeaderAccessor . getDestination ( message . getHeaders (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleSubscribe"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "given ( this . brokerChannel . send ( Mockito . any ( Message . class )  )  )  . willReturn ( true )  ;", "this . handler . handleMessage ( createWith ( SimpMessageType . UNSUBSCRIBE ,     \" joe \"  ,     \"  1  2  3  \"  ,     \"  / user / queue / foo \"  )  )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "Mockito . verify ( this . brokerChannel )  . send ( captor . capture (  )  )  ;", "Message   message    =    captor . getValue (  )  ;", "assertEquals (  \"  / queue / foo - user 1  2  3  \"  ,    SimpMessageHeaderAccessor . get ( message . getHeaders (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleUnsubscribe"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . handler . handleMessage ( createWith ( SimpMessageType . MESSAGE ,     \" joe \"  ,     \"  1  2  3  \"  ,    null )  )  ;", "Mockito . verifyZeroInteractions ( this . brokerChannel )  ;", "this . handler . handleMessage ( createWith ( SimpMessageType . MESSAGE ,     \" joe \"  ,     \"  1  2  3  \"  ,     \"  / queue / foo \"  )  )  ;", "Mockito . verifyZeroInteractions ( this . brokerChannel )  ;", "this . handler . handleMessage ( createWith ( SimpMessageType . SUBSCRIBE ,     \" joe \"  ,     \"  1  2  3  \"  ,     \"  / queue / foo \"  )  )  ;", "Mockito . verifyZeroInteractions ( this . brokerChannel )  ;", "this . handler . handleMessage ( createWith ( SimpMessageType . CONNECT ,     \" joe \"  ,     \"  1  2  3  \"  ,     \" user / joe / queue / foo \"  )  )  ;", "Mockito . verifyZeroInteractions ( this . brokerChannel )  ;", "}", "METHOD_END"], "methodName": ["ignoreMessage"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . registry    =    mock ( SimpUserRegistry . class )  ;", "this . brokerChannel    =    mock ( SubscribableChannel . class )  ;", "UserDestinationResolver   resolver    =    new   DefaultUserDestinationResolver ( this . registry )  ;", "this . handler    =    new    ( new   StubMessageChannel (  )  ,    this . brokerChannel ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.simp.user.UserDestinationMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "return   this . sourceDestination ;", "}", "METHOD_END"], "methodName": ["getSourceDestination"], "fileName": "org.springframework.messaging.simp.user.UserDestinationResult"}, {"methodBody": ["METHOD_START", "{", "return   this . subscribeDestination ;", "}", "METHOD_END"], "methodName": ["getSubscribeDestination"], "fileName": "org.springframework.messaging.simp.user.UserDestinationResult"}, {"methodBody": ["METHOD_START", "{", "return   this . targetDestinations ;", "}", "METHOD_END"], "methodName": ["getTargetDestinations"], "fileName": "org.springframework.messaging.simp.user.UserDestinationResult"}, {"methodBody": ["METHOD_START", "{", "return   this . user ;", "}", "METHOD_END"], "methodName": ["getUser"], "fileName": "org.springframework.messaging.simp.user.UserDestinationResult"}, {"methodBody": ["METHOD_START", "{", "return   this . broadcastDestination ;", "}", "METHOD_END"], "methodName": ["getBroadcastDestination"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandler"}, {"methodBody": ["METHOD_START", "{", "return   this . registryExpirationPeriod ;", "}", "METHOD_END"], "methodName": ["getRegistryExpirationPeriod"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandler"}, {"methodBody": ["METHOD_START", "{", "this . registryExpirationPeriod    =    milliseconds ;", "}", "METHOD_END"], "methodName": ["setRegistryExpirationPeriod"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandler"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   simpUser 1     =    new   TestSimpUser (  \" joe \"  )  ;", "TestSimpUser   simpUser 2     =    new   TestSimpUser (  \" jane \"  )  ;", "simpUser 1  . addSessions ( new   TestSimpSession (  \"  1  2  3  \"  )  )  ;", "simpUser 1  . addSessions ( new   TestSimpSession (  \"  4  5  6  \"  )  )  ;", "HashSet < SimpUser >    simpUsers    =    new   HashSet <  >  ( Arrays . asList ( simpUser 1  ,    simpUser 2  )  )  ;", "when ( this . localRegistry . getUsers (  )  )  . thenReturn ( simpUsers )  ;", "getTask (  )  . run (  )  ;", "ArgumentCaptor < Message >    captor    =    ArgumentCaptor . forClass ( Message . class )  ;", "verify ( this . brokerChannel )  . send ( captor . capture (  )  )  ;", "Message <  ?  >    message    =    captor . getValue (  )  ;", "assertNotNull ( message )  ;", "MessageHeaders   headers    =    message . getHeaders (  )  ;", "assertEquals (  \"  / topic / simp - user - registry \"  ,    SimpMessageHeaderAccessor . getDestination ( headers )  )  ;", "MultiServer   remoteRegistry    =    new   MultiServer ( mock ( Simp . class )  )  ;", "remoteRegistry . addRemoteRegistryDto ( message ,    this . converter ,     2  0  0  0  0  )  ;", "assertEquals (  2  ,    remoteRegistry . getUserCount (  )  )  ;", "assertNotNull ( remoteRegistry . getUser (  \" joe \"  )  )  ;", "assertNotNull ( remoteRegistry . getUser (  \" jane \"  )  )  ;", "}", "METHOD_END"], "methodName": ["broadcastRegistry"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Runnable   runnable    =    getUserRegistryTask (  )  ;", "assertNotNull ( runnable )  ;", "}", "METHOD_END"], "methodName": ["brokerAvailableEvent"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ScheduledFuture   future    =    Mockito . mock ( ScheduledFuture . class )  ;", "when ( this . taskScheduler . scheduleWithFixedDelay ( any ( Runnable . class )  ,    any ( Long . class )  )  )  . thenReturn ( future )  ;", "BrokerAvailabilityEvent   event    =    new   BrokerAvailabilityEvent ( true ,    this )  ;", "this . h . onApplicationEvent ( event )  ;", "verifyNoMoreInteractions ( future )  ;", "event    =    new   BrokerAvailabilityEvent ( false ,    this )  ;", "this . h . onApplicationEvent ( event )  ;", "verify ( future )  . cancel ( true )  ;", "}", "METHOD_END"], "methodName": ["brokerUnavailableEvent"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "BrokerAvailabilityEvent   event    =    new   BrokerAvailabilityEvent ( true ,    this )  ;", "this . h . onApplicationEvent ( event )  ;", "ArgumentCaptor <  ?    extends   Runnable >    captor    =    ArgumentCaptor . forClass ( Runnable . class )  ;", "verify ( this . taskScheduler )  . scheduleWithFixedDelay ( captor . capture (  )  ,    eq (  1  0  0  0  0 L )  )  ;", "return   captor . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getUserRegistryTask"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   simpUser 1     =    new   TestSimpUser (  \" joe \"  )  ;", "TestSimpUser   simpUser 2     =    new   TestSimpUser (  \" jane \"  )  ;", "simpUser 1  . addSessions ( new   TestSimpSession (  \"  1  2  3  \"  )  )  ;", "simpUser 2  . addSessions ( new   TestSimpSession (  \"  4  5  6  \"  )  )  ;", "HashSet < SimpUser >    simpUsers    =    new   HashSet <  >  ( Arrays . asList ( simpUser 1  ,    simpUser 2  )  )  ;", "Simp   remote    =    mock ( Simp . class )  ;", "when ( remote . getUserCount (  )  )  . thenReturn (  2  )  ;", "when ( remote . getUsers (  )  )  . thenReturn ( simpUsers )  ;", "MultiServer   remoteRegistry    =    new   MultiServer ( remote )  ;", "Message <  ?  >    message    =    this . converter . toMessage ( remoteRegistry . getLocalRegistryDto (  )  ,    null )  ;", "this . handler . handleMessage ( message )  ;", "assertEquals (  2  ,    remoteRegistry . getUserCount (  )  )  ;", "assertNotNull ( this . multiServerRegistry . getUser (  \" joe \"  )  )  ;", "assertNotNull ( this . multiServerRegistry . getUser (  \" jane \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessage"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestSimpUser   simpUser    =    new   TestSimpUser (  \" joe \"  )  ;", "simpUser . addSessions ( new   TestSimpSession (  \"  1  2  3  \"  )  )  ;", "when ( this . localRegistry . getUserCount (  )  )  . thenReturn (  1  )  ;", "when ( this . localRegistry . getUsers (  )  )  . thenReturn ( Collections . singleton ( simpUser )  )  ;", "assertEquals (  1  ,    this . multiServ . getUserCount (  )  )  ;", "Message <  ?  >    message    =    this . converter . toMessage ( this . multiServ . getLocalRegistryDto (  )  ,    null )  ;", "this . multiServ . addRemoteRegistryDto ( message ,    this . converter ,     2  0  0  0  0  )  ;", "assertEquals (  1  ,    this . multiServ . getUserCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleMessageFromOwnBroadcast"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "when ( this . brokerChannel . send ( any (  )  )  )  . thenReturn ( true )  ;", "this . converter    =    new   MappingJackson 2 MessageConverter (  )  ;", "SimpMessagingTemplate   brokerTemplate    =    new   SimpMessagingTemplate ( this . brokerChannel )  ;", "brokerTemplate . setMessageConverter ( this . converter )  ;", "this . localRegistry    =    mock ( SimpUserRegistry . class )  ;", "this . multiServerRegistry    =    new   MultiServerUserRegistry ( this . localRegistry )  ;", "this . handler    =    new    ( this . multiServerRegistry ,    brokerTemplate ,     \"  / topic / simp - user - registry \"  ,    this . taskScheduler )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.messaging.simp.user.UserRegistryMessageHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   propertyName    =    headerName ;", "if    (  ( StringUtils . hasText ( this . outboundPrefix )  )     &  &     (  !  ( propertyName . startsWith ( this . outboundPrefix )  )  )  )     {", "propertyName    =     ( this . outboundPrefix )     +    headerName ;", "}", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["fromHeaderName"], "fileName": "org.springframework.messaging.support.AbstractHeaderMapper"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    headers . get ( name )  ;", "if    ( value    =  =    null )     {", "return   null ;", "}", "if    (  !  ( type . isAssignableFrom ( value . getClass (  )  )  )  )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  (  (  (  (  \" Skipping   header    '  \"     +    name )     +     \"  ' expected   type    [  \"  )     +    type )     +     \"  ]  ,    but   got    [  \"  )     +     ( value . getClass (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return   null ;", "} else    {", "return   type . cast ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["getHeaderIfAvailable"], "fileName": "org.springframework.messaging.support.AbstractHeaderMapper"}, {"methodBody": ["METHOD_START", "{", "this . inboundPrefix    =     ( inboundPrefix    !  =    null )     ?    inboundPrefix    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setInboundPrefix"], "fileName": "org.springframework.messaging.support.AbstractHeaderMapper"}, {"methodBody": ["METHOD_START", "{", "this . outboundPrefix    =     ( outboundPrefix    !  =    null )     ?    outboundPrefix    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setOutboundPrefix"], "fileName": "org.springframework.messaging.support.AbstractHeaderMapper"}, {"methodBody": ["METHOD_START", "{", "String   headerName    =    propertyName ;", "if    (  ( StringUtils . hasText ( this . inboundPrefix )  )     &  &     (  !  ( headerName . startsWith ( this . inboundPrefix )  )  )  )     {", "headerName    =     ( this . inboundPrefix )     +    propertyName ;", "}", "return   headerName ;", "}", "METHOD_END"], "methodName": ["toHeaderName"], "fileName": "org.springframework.messaging.support.AbstractHeaderMapper"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.messaging.support.AbstractMessageChannel"}, {"methodBody": ["METHOD_START", "{", "return   Collections .  < MessageHandler > unmodifiableSet ( this . handlers )  ;", "}", "METHOD_END"], "methodName": ["getSubscribers"], "fileName": "org.springframework.messaging.support.AbstractSubscribableChannel"}, {"methodBody": ["METHOD_START", "{", "return   this . handlers . contains ( handler )  ;", "}", "METHOD_END"], "methodName": ["hasSubscription"], "fileName": "org.springframework.messaging.support.AbstractSubscribableChannel"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["preReceive"], "fileName": "org.springframework.messaging.support.ChannelInterceptorAdapter"}, {"methodBody": ["METHOD_START", "{", "ChannelInterceptorTests . PreSendInterceptor   interceptor 1     =    new   ChannelInterceptorTests . PreSendInterceptor (  )  ;", "ChannelInterceptorTests . PreSendInterceptor   interceptor 2     =    new   ChannelInterceptorTests . PreSendInterceptor (  )  ;", "interceptor 2  . setExceptionToRaise ( new   RuntimeException (  \" Simulated   exception \"  )  )  ;", "this . channel . addInterceptor ( interceptor 1  )  ;", "this . channel . addInterceptor ( interceptor 2  )  ;", "try    {", "this . channel . send ( MessageBuilder . withPayload (  \" test \"  )  . build (  )  )  ;", "}    catch    ( Exception   ex )     {", "assertEquals (  \" Simulated   exception \"  ,    ex . getCause (  )  . getMessage (  )  )  ;", "}", "assertTrue ( interceptor 1  . wasAfterCompletionInvoked (  )  )  ;", "assertFalse ( interceptor 2  . wasAfterCompletionInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["afterCompletionWithPreSendException"], "fileName": "org.springframework.messaging.support.ChannelInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   AbstractMessageChannel   testChannel    =    new   AbstractMessageChannel (  )     {", "@ Override", "protected   boolean   sendInternal ( Message <  ?  >    message ,    long   timeout )     {", "throw   new   RuntimeException (  \" Simulated   exception \"  )  ;", "}", "}  ;", ". PreSendInterceptor   interceptor 1     =    new    . PreSendInterceptor (  )  ;", ". PreSendInterceptor   interceptor 2     =    new    . PreSendInterceptor (  )  ;", "testChannel . addInterceptor ( interceptor 1  )  ;", "testChannel . addInterceptor ( interceptor 2  )  ;", "try    {", "testChannel . send ( MessageBuilder . withPayload (  \" test \"  )  . build (  )  )  ;", "}    catch    ( Exception   ex )     {", "assertEquals (  \" Simulated   exception \"  ,    ex . getCause (  )  . getMessage (  )  )  ;", "}", "assertTrue ( interceptor 1  . wasAfterCompletionInvoked (  )  )  ;", "assertTrue ( interceptor 2  . wasAfterCompletionInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["afterCompletionWithSendException"], "fileName": "org.springframework.messaging.support.ChannelInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   AbstractMessageChannel   testChannel    =    new   AbstractMessageChannel (  )     {", "@ Override", "protected   boolean   sendInternal ( Message <  ?  >    message ,    long   timeout )     {", "return   false ;", "}", "}  ;", "final   AtomicBoolean   preSendInvoked    =    new   AtomicBoolean ( false )  ;", "final   AtomicBoolean   completionInvoked    =    new   AtomicBoolean ( false )  ;", "testChannel . addInterceptor ( new   Adapter (  )     {", "@ Override", "public   void   postSend ( Message <  ?  >    message ,    MessageChannel   channel ,    boolean   sent )     {", "assertInput ( message ,    channel ,    sent )  ;", "preSendInvoked . set ( true )  ;", "}", "@ Override", "public   void   afterSendCompletion ( Message <  ?  >    message ,    MessageChannel   channel ,    boolean   sent ,    Exception   ex )     {", "assertInput ( message ,    channel ,    sent )  ;", "completionInvoked . set ( true )  ;", "}", "private   void   assertInput ( Message <  ?  >    message ,    MessageChannel   channel ,    boolean   sent )     {", "assertNotNull ( message )  ;", "assertNotNull ( channel )  ;", "assertSame ( testChannel ,    channel )  ;", "assertFalse ( sent )  ;", "}", "}  )  ;", "testChannel . send ( MessageBuilder . withPayload (  \" test \"  )  . build (  )  )  ;", "assertTrue ( preSendInvoked . get (  )  )  ;", "assertTrue ( completionInvoked . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["postSendInterceptorMessageWasNotSent"], "fileName": "org.springframework.messaging.support.ChannelInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "final   AtomicBoolean   preSendInvoked    =    new   AtomicBoolean ( false )  ;", "final   AtomicBoolean   completionInvoked    =    new   AtomicBoolean ( false )  ;", "this . channel . addInterceptor ( new   ChannelInterceptorAdapter (  )     {", "@ Override", "public   void   postSend ( Message <  ?  >    message ,    MessageChannel   channel ,    boolean   sent )     {", "assertInput ( message ,    channel ,    sent )  ;", "preSendInvoked . set ( true )  ;", "}", "@ Override", "public   void   afterSendCompletion ( Message <  ?  >    message ,    MessageChannel   channel ,    boolean   sent ,    Exception   ex )     {", "assertInput ( message ,    channel ,    sent )  ;", "completionInvoked . set ( true )  ;", "}", "private   void   assertInput ( Message <  ?  >    message ,    MessageChannel   channel ,    boolean   sent )     {", "assertNotNull ( message )  ;", "assertNotNull ( channel )  ;", "assertSame (  . this . channel ,    channel )  ;", "assertTrue ( sent )  ;", "}", "}  )  ;", "this . channel . send ( MessageBuilder . withPayload (  \" test \"  )  . build (  )  )  ;", "assertTrue ( preSendInvoked . get (  )  )  ;", "assertTrue ( completionInvoked . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["postSendInterceptorMessageWasSent"], "fileName": "org.springframework.messaging.support.ChannelInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    mock ( Message . class )  ;", ". PreSendInterceptor   interceptor    =    new    . PreSendInterceptor (  )  ;", "interceptor . setMessageToReturn ( expected )  ;", "this . channel . addInterceptor ( interceptor )  ;", "this . channel . send ( MessageBuilder . withPayload (  \" test \"  )  . build (  )  )  ;", "assertEquals (  1  ,    this . messageHandler . getMessages (  )  . size (  )  )  ;", "Message <  ?  >    result    =    this . messageHandler . getMessages (  )  . get (  0  )  ;", "assertNotNull ( result )  ;", "assertSame ( expected ,    result )  ;", "assertTrue ( interceptor . wasAfterCompletionInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["preSendInterceptorReturningModifiedMessage"], "fileName": "org.springframework.messaging.support.ChannelInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "ChannelInterceptorTests . PreSendInterceptor   interceptor 1     =    new   ChannelInterceptorTests . PreSendInterceptor (  )  ;", "ChannelInterceptorTests . NullReturningPreSendInterceptor   interceptor 2     =    new   ChannelInterceptorTests . NullReturningPreSendInterceptor (  )  ;", "this . channel . addInterceptor ( interceptor 1  )  ;", "this . channel . addInterceptor ( interceptor 2  )  ;", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" test \"  )  . build (  )  ;", "this . channel . send ( message )  ;", "assertEquals (  1  ,    interceptor 1  . getCounter (  )  . get (  )  )  ;", "assertEquals (  1  ,    interceptor 2  . getCounter (  )  . get (  )  )  ;", "assertEquals (  0  ,    this . messageHandler . getMessages (  )  . size (  )  )  ;", "assertTrue ( interceptor 1  . wasAfterCompletionInvoked (  )  )  ;", "assertFalse ( interceptor 2  . wasAfterCompletionInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["preSendInterceptorReturningNull"], "fileName": "org.springframework.messaging.support.ChannelInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "this . channel    =    new   ExecutorSubscribableChannel (  )  ;", "this . messageHandler    =    new    . TestMessageHandler (  )  ;", "this . channel . subscribe ( this . messageHandler )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.support.ChannelInterceptorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . originalMessage ;", "}", "METHOD_END"], "methodName": ["getOriginalMessage"], "fileName": "org.springframework.messaging.support.ErrorMessage"}, {"methodBody": ["METHOD_START", "{", "ErrorMessage   em    =    new   ErrorMessage ( new   RuntimeException (  \" foo \"  )  )  ;", "String   emString    =    em . toString (  )  ;", "assertThat ( emString ,    not ( containsString (  \" original \"  )  )  )  ;", "em    =    new   ErrorMessage ( new   RuntimeException (  \" foo \"  )  ,    new   GenericMessage <  >  (  \" bar \"  )  )  ;", "emString    =    em . toString (  )  ;", "assertThat ( emString ,    containsString (  \" original \"  )  )  ;", "assertThat ( emString ,    containsString ( em . getOriginalMessage (  )  . toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testToString"], "fileName": "org.springframework.messaging.support.ErrorMessageTests"}, {"methodBody": ["METHOD_START", "{", "return   this . executor ;", "}", "METHOD_END"], "methodName": ["getExecutor"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannel"}, {"methodBody": ["METHOD_START", "{", "this . channel . subscribe (  (    message 1  )     -  >    channel . unsubscribe ( handler )  )  ;", "this . channel . subscribe ( this . handler )  ;", "this . channel . send ( this . message )  ;", "verify ( this . handler )  . handleMessage ( this . message )  ;", "}", "METHOD_END"], "methodName": ["concurrentModification"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "RuntimeException   ex    =    new   RuntimeException (  )  ;", "willThrow ( ex )  . given ( this . handler )  . handleMessage ( thise )  ;", "MessageHandler   secondHandler    =    mock ( MessageHandler . class )  ;", "this . channel . subscribe ( this . handler )  ;", "this . channel . subscribe ( secondHandler )  ;", "try    {", "this . channel . sende )  ;", "}    catch    ( MessageDeliveryException   actualException )     {", "assertThat ( actualException . getCause (  )  ,    equalTo ( ex )  )  ;", "}", "verifyZeroInteractions ( secondHandler )  ;", "}", "METHOD_END"], "methodName": ["failurePropagates"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "IllegalStateException   expected    =    new   IllegalStateException (  \" Fake   exception \"  )  ;", "willThrow ( expected )  . given ( this . handler )  . handleMessage ( this . message )  ;", ". BeforeHandleInterceptor   interceptor    =    new    . BeforeHandleInterceptor (  )  ;", "this . channel . addInterceptor ( interceptor )  ;", "this . channel . subscribe ( this . handler )  ;", "try    {", "this . channel . send ( this . message )  ;", "}    catch    ( MessageDeliveryException   actual )     {", "assertSame ( expected ,    actual . getCause (  )  )  ;", "}", "verify ( this . handler )  . handleMessage ( this . message )  ;", "assertEquals (  1  ,    interceptor . getCounter (  )  . get (  )  )  ;", "assertTrue ( interceptor . wasAfterHandledInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["interceptorWithException"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    expected    =    mock ( Message . class )  ;", ". BeforeHandleInterceptor   interceptor    =    new    . BeforeHandleInterceptor (  )  ;", "interceptor . setMessageToReturn ( expected )  ;", "this . channel . addInterceptor ( interceptor )  ;", "this . channel . subscribe ( this . handler )  ;", "this . channel . send ( this . message )  ;", "verify ( this . handler )  . handleMessage ( expected )  ;", "assertEquals (  1  ,    interceptor . getCounter (  )  . get (  )  )  ;", "assertTrue ( interceptor . wasAfterHandledInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["interceptorWithModifiedMessage"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "ExecutorSubscribableChannelTests . BeforeHandleInterceptor   interceptor 1     =    new   ExecutorSubscribableChannelTests . BeforeHandleInterceptor (  )  ;", "ExecutorSubscribableChannelTests . NullReturningBeforeHandleInterceptor   interceptor 2     =    new   ExecutorSubscribableChannelTests . NullReturningBeforeHandleInterceptor (  )  ;", "this . channel . addInterceptor ( interceptor 1  )  ;", "this . channel . addInterceptor ( interceptor 2  )  ;", "this . channel . subscribe ( this . handler )  ;", "this . channel . send ( this . message )  ;", "verifyNoMoreInteractions ( this . handler )  ;", "assertEquals (  1  ,    interceptor 1  . getCounter (  )  . get (  )  )  ;", "assertEquals (  1  ,    interceptor 2  . getCounter (  )  . get (  )  )  ;", "assertTrue ( interceptor 1  . wasAfterHandledInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["interceptorWithNull"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( IllegalArgumentException . class )  ;", "thrown . expectMessage (  \" Message   must   not   be   null \"  )  ;", "this . c . send ( null )  ;", "}", "METHOD_END"], "methodName": ["messageMustNotBeNull"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "ExecutorSubscribableChannelTests . BeforeHandleInterceptor   interceptor    =    new   ExecutorSubscribableChannelTests . BeforeHandleInterceptor (  )  ;", "TaskExecutor   executor    =    mock ( TaskExecutor . class )  ;", "ExecutorSubscribableChannel   testChannel    =    new   ExecutorSubscribableChannel ( executor )  ;", "testChannel . addInterceptor ( interceptor )  ;", "testChannel . subscribe ( this . handler )  ;", "testChannel . send ( this . message )  ;", "verify ( executor )  . execute ( this . runnableCaptor . capture (  )  )  ;", "verify ( this . handler ,    never (  )  )  . handleMessage ( this . message )  ;", "this . runnableCaptor . getValue (  )  . run (  )  ;", "verify ( this . handler )  . handleMessage ( this . message )  ;", "assertEquals (  1  ,    interceptor . getCounter (  )  . get (  )  )  ;", "assertTrue ( interceptor . wasAfterHandledInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendWithExecutor"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "ExecutorSubscribableChannelTests . BeforeHandleInterceptor   interceptor    =    new   ExecutorSubscribableChannelTests . BeforeHandleInterceptor (  )  ;", "this . channel . addInterceptor ( interceptor )  ;", "this . channel . subscribe ( this . handler )  ;", "this . channel . send ( this . message )  ;", "verify ( this . handler )  . handleMessage ( this . message )  ;", "assertEquals (  1  ,    interceptor . getCounter (  )  . get (  )  )  ;", "assertTrue ( interceptor . wasAfterHandledInvoked (  )  )  ;", "}", "METHOD_END"], "methodName": ["sendWithoutExecutor"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "MockitoAnnotations . initMocks ( this )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . channel . subscribe ( this . handler )  ,    equalTo ( true )  )  ;", "assertThat ( this . channel . subscribe ( this . handler )  ,    equalTo ( false )  )  ;", "this . channel . send ( this . message )  ;", "verify ( this . handler ,    times (  1  )  )  . handleMessage ( this . message )  ;", "}", "METHOD_END"], "methodName": ["subscribeTwice"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "this . channel . subscribe ( this . handler )  ;", "assertThat ( this . channel . unsubscribe ( this . handler )  ,    equalTo ( true )  )  ;", "assertThat ( this . channel . unsubscribe ( this . handler )  ,    equalTo ( false )  )  ;", "this . channel . send ( this . message )  ;", "verify ( this . handler ,    never (  )  )  . handleMessage ( this . message )  ;", "}", "METHOD_END"], "methodName": ["unsubscribeTwice"], "fileName": "org.springframework.messaging.support.ExecutorSubscribableChannelTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    other )     {", "return   true ;", "}", "if    (  !  ( other   instanceof    )  )     {", "return   false ;", "}", "<  ?  >    otherMsg    =     (  (  <  ?  >  )     ( other )  )  ;", "return    ( ObjectUtils . nullSafeEquals ( this . payload ,    otherMsg . payload )  )     &  &     ( this . headers . equals ( otherMsg . headers )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.springframework.messaging.support.GenericMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . headers ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.springframework.messaging.support.GenericMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . payload ;", "}", "METHOD_END"], "methodName": ["getPayload"], "fileName": "org.springframework.messaging.support.GenericMessage"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ObjectUtils . nullSafeHashCode ( this . payload )  )     *     2  3  )     +     ( this . headers . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.springframework.messaging.support.GenericMessage"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( getClass (  )  . getSimpleName (  )  )  ;", "sb . append (  \"     [ payload =  \"  )  ;", "if    (  ( this . payload )    instanceof   byte [  ]  )     {", "sb . append (  \" byte [  \"  )  . append (  (  ( byte [  ]  )     ( this . payload )  )  . length )  . append (  \"  ]  \"  )  ;", "} else    {", "sb . append ( this . payload )  ;", "}", "sb . append (  \"  ,    headers =  \"  )  . append ( this . headers )  . append (  \"  ]  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.messaging.support.GenericMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . idGenerator ;", "}", "METHOD_END"], "methodName": ["getIdGenerator"], "fileName": "org.springframework.messaging.support.IdTimestampMessageHeaderInitializer"}, {"methodBody": ["METHOD_START", "{", "return   this . enableTimestamp ;", "}", "METHOD_END"], "methodName": ["isEnableTimestamp"], "fileName": "org.springframework.messaging.support.IdTimestampMessageHeaderInitializer"}, {"methodBody": ["METHOD_START", "{", "this . idGenerator    =    IdTimestampMessageHeaderInitializer . ID _ VALUE _ NONE _ GENERATOR ;", "}", "METHOD_END"], "methodName": ["setDisableIdGeneration"], "fileName": "org.springframework.messaging.support.IdTimestampMessageHeaderInitializer"}, {"methodBody": ["METHOD_START", "{", "this . enableTimestamp    =    enableTimestamp ;", "}", "METHOD_END"], "methodName": ["setEnableTimestamp"], "fileName": "org.springframework.messaging.support.IdTimestampMessageHeaderInitializer"}, {"methodBody": ["METHOD_START", "{", "this . idGenerator    =    idGenerator ;", "}", "METHOD_END"], "methodName": ["setIdGenerator"], "fileName": "org.springframework.messaging.support.IdTimestampMessageHeaderInitializer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . originalMessage )     !  =    null )     &  &     (  !  ( this . headerAccessor . isModified (  )  )  )  )     {", "return   this . originalMessage ;", "}", "MessageHeaders   headersToUse    =    this . headerAccessor . toMessageHeaders (  )  ;", "if    (  ( this . payload )    instanceof   Throwable )     {", "return    (  ( Message < T >  )     ( new   ErrorMessage (  (  ( Throwable )     ( this . payload )  )  ,    headersToUse )  )  )  ;", "} else    {", "return   new   GenericMessage <  >  ( this . payload ,    headersToUse )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . copyHeaders ( headersToCopy )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["copyHeaders"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . copyHeadersIfAbsent ( headersToCopy )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["copyHeadersIfAbsent"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( payload ,     \" Payload   must   not   be   null \"  )  ;", "Assert . notNull ( messageHeaders ,     \" Headers   must   not   be   null \"  )  ;", "if    ( payload   instanceof   Throwable )     {", "return    (  (  < T >  )     ( new   Error (  (  ( Throwable )     ( payload )  )  ,    messageHeaders )  )  )  ;", "} else    {", "return   new   Generic <  >  ( payload ,    messageHeaders )  ;", "}", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   MessageBuilder <  >  ( message )  ;", "}", "METHOD_END"], "methodName": ["fromMessage"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . removeHeader ( headerName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["removeHeader"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . removeHeaders ( headerPatterns )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["removeHeaders"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . setErrorChannel ( errorChannel )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setErrorChannel"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . setErrorChannelName ( errorChannelName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setErrorChannelName"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . setHeader ( headerName ,    headerValue )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHeader"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . setHeaderIfAbsent ( headerName ,    headerValue )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHeaderIfAbsent"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( accessor ,     \" MessageHeaderAccessor   must   not   be   null \"  )  ;", "this . headerAccessor    =    accessor ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHeaders"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . setReplyChannel ( replyChannel )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setReplyChannel"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "this . headerAccessor . setReplyChannelName ( replyChannelName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setReplyChannelName"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   MessageBuilder <  >  ( payload ,    new   MessageHeaderAccessor (  )  )  ;", "}", "METHOD_END"], "methodName": ["withPayload"], "fileName": "org.springframework.messaging.support.MessageBuilder"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message 1     =    MessageBuilder . withPayload (  \" test 1  \"  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Message < String >    message 2     =    MessageBuilder . withPayload (  \" test 2  \"  )  . setHeader (  \" foo \"  ,     1  2  3  )  . copyHeadersIfAbsent ( message 1  . getHeaders (  )  )  . build (  )  ;", "assertEquals (  \" test 2  \"  ,    message 2  . getPayload (  )  )  ;", "assertEquals (  1  2  3  ,    message 2  . getHeaders (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["copyHeadersIfAbsent"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message 1     =    MessageBuilder . withPayload (  \" test \"  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Message < String >    message 2     =    MessageBuilder . fromMessage ( message 1  )  . build (  )  ;", "assertEquals (  \" test \"  ,    message 2  . getPayload (  )  )  ;", "assertEquals (  \" bar \"  ,    message 2  . getHeaders (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createFromMessage"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message 1     =    MessageBuilder . withPayload (  \" test \"  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Message < String >    message 2     =    MessageBuilder . fromMessage ( message 1  )  . setHeader (  \" another \"  ,     1  )  . build (  )  ;", "assertEquals (  \" bar \"  ,    message 2  . getHeaders (  )  . get (  \" foo \"  )  )  ;", "assertNotSame ( message 1  . getHeaders (  )  . getId (  )  ,    message 2  . getHeaders (  )  . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["createIdRegenerated"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "Message <  ?  >    message    =     . createMessage (  \" foo \"  ,    headers )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" Already   immutable \"  )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar \"  )  ;", "assertSame ( accessor ,    MessageHeaderAccessor . getAccessor ( message ,    MessageHeaderAccessor . class )  )  ;", "}", "METHOD_END"], "methodName": ["testBuildMessageWithDefaultMutability"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "Message <  ?  >    message    =     . createMessage (  \" payload \"  ,    headers )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar \"  )  ;", "assertEquals (  \" bar \"  ,    headers . get (  \" foo \"  )  )  ;", "assertSame ( accessor ,    MessageHeaderAccessor . getAccessor ( message ,    MessageHeaderAccessor . class )  )  ;", "}", "METHOD_END"], "methodName": ["testBuildMessageWithMutableHeaders"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   headerAccessor    =    new   MessageHeaderAccessor (  )  ;", "headerAccessor . setIdGenerator ( new   IdGenerator (  )     {", "@ Override", "public   UUID   generateId (  )     {", "return   MessageHeaders . ID _ VALUE _ NONE ;", "}", "}  )  ;", "Message <  ?  >    message    =     . createMessage (  \" foo \"  ,    headerAccessor . getMessageHeaders (  )  )  ;", "assertNull ( message . getHeaders (  )  . getId (  )  )  ;", "assertNull ( message . getHeaders (  )  . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBuildMessageWithoutIdAndTimestamp"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   headerAccessor    =    new   MessageHeaderAccessor (  )  ;", "<  ?  >    messageBuilder    =     . withPayload (  \" payload \"  )  . setHeaders ( headerAccessor )  ;", "headerAccessor . setHeader (  \" foo \"  ,     \" bar 1  \"  )  ;", "Message <  ?  >    message 1     =    messageBuilder . build (  )  ;", "headerAccessor . setHeader (  \" foo \"  ,     \" bar 2  \"  )  ;", "Message <  ?  >    message 2     =    messageBuilder . build (  )  ;", "headerAccessor . setHeader (  \" foo \"  ,     \" bar 3  \"  )  ;", "Message <  ?  >    message 3     =    messageBuilder . build (  )  ;", "assertEquals (  \" bar 1  \"  ,    message 1  . getHeaders (  )  . get (  \" foo \"  )  )  ;", "assertEquals (  \" bar 2  \"  ,    message 2  . getHeaders (  )  . get (  \" foo \"  )  )  ;", "assertEquals (  \" bar 3  \"  ,    message 3  . getHeaders (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBuildMultipleMessages"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    original    =    MessageBuilder . withPayload (  \" foo \"  )  . setHeader (  \" bar \"  ,     4  2  )  . build (  )  ;", "Message <  ?  >    result    =    MessageBuilder . fromMessage ( original )  . build (  )  ;", "assertEquals ( original ,    result )  ;", "}", "METHOD_END"], "methodName": ["testContainsHeaderNotModifiedSameMessage"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message 1     =    MessageBuilder . withPayload (  \" test 1  \"  )  . setHeader (  \" foo \"  ,     \"  1  \"  )  . setHeader (  \" bar \"  ,     \"  2  \"  )  . build (  )  ;", "Message < String >    message 2     =    MessageBuilder . withPayload (  \" test 2  \"  )  . copyHeaders ( message 1  . getHeaders (  )  )  . setHeader (  \" foo \"  ,     \"  4  2  \"  )  . setHeaderIfAbsent (  \" bar \"  ,     \"  9  9  \"  )  . build (  )  ;", "assertEquals (  \" test 1  \"  ,    message 1  . getPayload (  )  )  ;", "assertEquals (  \" test 2  \"  ,    message 2  . getPayload (  )  )  ;", "assertEquals (  \"  1  \"  ,    message 1  . getHeaders (  )  . get (  \" foo \"  )  )  ;", "assertEquals (  \"  4  2  \"  ,    message 2  . getHeaders (  )  . get (  \" foo \"  )  )  ;", "assertEquals (  \"  2  \"  ,    message 1  . getHeaders (  )  . get (  \" bar \"  )  )  ;", "assertEquals (  \"  2  \"  ,    message 2  . getHeaders (  )  . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopiedHeaderValues"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Date   current    =    new   Date (  )  ;", "Map < String ,    Object >    originalHeaders    =    new   HashMap <  >  (  )  ;", "originalHeaders . put (  \" b \"  ,     \" xyz \"  )  ;", "originalHeaders . put (  \" c \"  ,    current )  ;", "Message <  ?  >    original    =     . withPayload (  \" foo \"  )  . setHeader (  \" a \"  ,     1  2  3  )  . copyHeaders ( originalHeaders )  . build (  )  ;", "Map < String ,    Object >    newHeaders    =    new   HashMap <  >  (  )  ;", "newHeaders . put (  \" a \"  ,     1  2  3  )  ;", "newHeaders . put (  \" b \"  ,     \" xyz \"  )  ;", "newHeaders . put (  \" c \"  ,    current )  ;", "Message <  ?  >    result    =     . fromMessage ( original )  . copyHeaders ( newHeaders )  . build (  )  ;", "assertEquals ( original ,    result )  ;", "}", "METHOD_END"], "methodName": ["testCopySameHeaderValuesNotModifiedSameMessage"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" test \"  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . setHeader (  \" count \"  ,     1  2  3  )  . build (  )  ;", "assertEquals (  \" bar \"  ,    message . getHeaders (  )  . get (  \" foo \"  ,    String . class )  )  ;", "assertEquals ( new   Integer (  1  2  3  )  ,    message . getHeaders (  )  . get (  \" count \"  ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["testHeaderValues"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "UUID   id    =    UUID . randomUUID (  )  ;", ". withPayload (  \" test \"  )  . setHeader ( MessageHeaders . ID ,    id )  ;", "}", "METHOD_END"], "methodName": ["testIdHeaderValueReadOnly"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    original    =    MessageBuilder . withPayload (  \" foo \"  )  . build (  )  ;", "Message <  ?  >    result    =    MessageBuilder . fromMessage ( original )  . build (  )  ;", "assertEquals ( original ,    result )  ;", "}", "METHOD_END"], "methodName": ["testNotModifiedSameMessage"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message < Integer >    message 1     =    MessageBuilder . withPayload (  1  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Message < Integer >    message 2     =    MessageBuilder . fromMessage ( message 1  )  . removeHeader (  \" foo \"  )  . build (  )  ;", "assertFalse ( message 2  . getHeaders (  )  . containsKey (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRemove"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    original    =    MessageBuilder . withPayload (  \" foo \"  )  . setHeader (  \" bar \"  ,     4  2  )  . build (  )  ;", "Message <  ?  >    result    =    MessageBuilder . fromMessage ( original )  . setHeader (  \" bar \"  ,     4  2  )  . build (  )  ;", "assertEquals ( original ,    result )  ;", "}", "METHOD_END"], "methodName": ["testSameHeaderValueAddedNotModifiedSameMessage"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message < Integer >    message 1     =    MessageBuilder . withPayload (  1  )  . setHeader (  \" foo \"  ,     \" bar \"  )  . build (  )  ;", "Message < Integer >    message 2     =    MessageBuilder . fromMessage ( message 1  )  . setHeader (  \" foo \"  ,    null )  . build (  )  ;", "assertFalse ( message 2  . getHeaders (  )  . containsKey (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSettingToNullRemoves"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Message < String >    message    =    MessageBuilder . withPayload (  \" foo \"  )  . build (  )  ;", "assertEquals (  \" foo \"  ,    message . getPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleMessageCreation"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "Long   timestamp    =     1  2  3  4  5 L ;", ". withPayload (  \" test \"  )  . setHeader ( MessageHeaders . TIMESTAMP ,    timestamp )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["testTimestampValueReadOnly"], "fileName": "org.springframework.messaging.support.MessageBuilderTests"}, {"methodBody": ["METHOD_START", "{", "if    ( headersToCopy    !  =    null )     {", "headersToCopy . forEach (  (    key ,    value )     -  >     {", "if    (  !  ( isReadOnly ( key )  )  )     {", "set ( key ,    value )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( headersToCopy    !  =    null )     {", "headersToCopy . forEach (  (    key ,    value )     -  >     {", "if    (  !  ( isReadOnly ( key )  )  )     {", "setIfAbsent ( key ,    value )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyHeadersIfAbsent"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   MessageHeaderAccessor ( message )  ;", "}", "METHOD_END"], "methodName": ["createAccessor"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   MessageHeaderAccessor . getAccessor ( message . getHeaders (  )  ,    requiredType )  ;", "}", "METHOD_END"], "methodName": ["getAccessor"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( messageHeaders   instanceof   MessageHeaderAccessor . MutableMessageHeaders )     {", "MessageHeaderAccessor . MutableMessageHeaders   mutableHeaders    =     (  ( MessageHeaderAccessor . MutableMessageHeaders )     ( messageHeaders )  )  ;", "MessageHeaderAccessor   headerAccessor    =    mutableHeaders . getAccessor (  )  ;", "if    (  ( requiredType    =  =    null )     |  |     ( requiredType . isInstance ( headerAccessor )  )  )     {", "return    (  ( T )     ( headerAccessor )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAccessor"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "MimeType   contentType    =    getContentType (  )  ;", "Charset   charset    =     ( contentType    !  =    null )     ?    contentType . getCharset (  )     :    null ;", "return   charset    !  =    null    ?    charset    :     . DEFAULT _ CHARSET ;", "}", "METHOD_END"], "methodName": ["getCharset"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    getHeader ( MessageHeaders . CONTENT _ TYPE )  ;", "if    ( value    =  =    null )     {", "return   null ;", "}", "return   value   instanceof   MimeType    ?     (  ( MimeType )     ( value )  )     :    MimeType . valueOf ( value . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getContentType"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  \" headers =  \"     +     ( this . headers . toString (  )  )  )     +     ( getDetailedPayloadLogMessage ( payload )  )  ;", "}", "METHOD_END"], "methodName": ["getDetailedLogMessage"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( payload   instanceof   String )     {", "return    \"    payload =  \"     +    payload ;", "} else", "if    ( payload   instanceof   byte [  ]  )     {", "byte [  ]    bytes    =     (  ( byte [  ]  )     ( payload )  )  ;", "if    ( isReadableContentType (  )  )     {", "return    \"    payload =  \"     +     ( new   String ( bytes ,    getCharset (  )  )  )  ;", "} else    {", "return    (  \"    payload = byte [  \"     +     ( bytes . length )  )     +     \"  ]  \"  ;", "}", "} else    {", "return    \"    payload =  \"     +    payload ;", "}", "}", "METHOD_END"], "methodName": ["getDetailedPayloadLogMessage"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getHeader ( MessageHeaders . ERROR _ CHANNEL )  ;", "}", "METHOD_END"], "methodName": ["getErrorChannel"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . headers . get ( headerName )  ;", "}", "METHOD_END"], "methodName": ["getHeader"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    getHeader ( MessageHeaders . ID )  ;", "if    ( value    =  =    null )     {", "return   null ;", "}", "return   value   instanceof   UUID    ?     (  ( UUID )     ( value )  )     :    UUID . fromString ( value . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "List < String >    matchingHeaderNames    =    new   ArrayList <  >  (  )  ;", "if    ( headers    !  =    null )     {", "for    ( String   key    :    headers . keySet (  )  )     {", "if    ( PatternMatchUtils . simpleMatch ( pattern ,    key )  )     {", "matchingHeaderNames . add ( key )  ;", "}", "}", "}", "return   matchingHeaderNames ;", "}", "METHOD_END"], "methodName": ["getMatchingHeaderNames"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . leaveMutable )  )     {", "setImmutable (  )  ;", "}", "return   this . hs ;", "}", "METHOD_END"], "methodName": ["getMessageHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( message . getHeaders (  )  )    instanceof   MessageHeaderAccessor . MutableMessageHeaders )     {", "MessageHeaderAccessor . MutableMessageHeaders   mutableHeaders    =     (  ( MessageHeaderAccessor . MutableMessageHeaders )     ( message . getHeaders (  )  )  )  ;", "MessageHeaderAccessor   accessor    =    mutableHeaders . getAccessor (  )  ;", "return   accessor . isMutable (  )     ?    accessor    :    accessor . createAccessor ( message )  ;", "}", "return   new   MessageHeaderAccessor ( message )  ;", "}", "METHOD_END"], "methodName": ["getMutableAccessor"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getHeader ( MessageHeaders . REPLY _ CHANNEL )  ;", "}", "METHOD_END"], "methodName": ["getReplyChannel"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  \" headers =  \"     +     ( this . headers . toString (  )  )  )     +     ( getShortPayloadLogMessage ( payload )  )  ;", "}", "METHOD_END"], "methodName": ["getShortLogMessage"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( payload   instanceof   String )     {", "String   payloadText    =     (  ( String )     ( payload )  )  ;", "return    ( payloadText . length (  )  )     <     8  0     ?     \"    payload =  \"     +    payloadText    :     (  \"    payload =  \"     +     ( payloadText . substring (  0  ,     8  0  )  )  )     +     \"  .  .  .  ( truncated )  \"  ;", "} else", "if    ( payload   instanceof   byte [  ]  )     {", "byte [  ]    bytes    =     (  ( byte [  ]  )     ( payload )  )  ;", "if    ( isReadableContentType (  )  )     {", "return    ( bytes . length )     <     8  0     ?     \"    payload =  \"     +     ( new   String ( bytes ,    getCharset (  )  )  )     :     (  \"    payload =  \"     +     ( new   String ( copyOf ( bytes ,     8  0  )  ,    getCharset (  )  )  )  )     +     \"  .  .  .  ( truncated )  \"  ;", "} else    {", "return    (  \"    payload = byte [  \"     +     ( bytes . length )  )     +     \"  ]  \"  ;", "}", "} else    {", "String   payloadText    =    payload . toString (  )  ;", "return    ( payloadText . length (  )  )     <     8  0     ?     \"    payload =  \"     +    payloadText    :     \"    payload =  \"     +     ( util . ObjectUtils . identityToString ( payload )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getShortPayloadLogMessage"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    getHeader ( MessageHeaders . TIMESTAMP )  ;", "if    ( value    =  =    null )     {", "return   null ;", "}", "return   value   instanceof   Long    ?     (  ( Long )     ( value )  )     :    Long . parseLong ( value . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTimestamp"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . modified ;", "}", "METHOD_END"], "methodName": ["isModified"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . headers . isMutable (  )  ;", "}", "METHOD_END"], "methodName": ["isMutable"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    ( MessageHeaders . ID . equals ( headerName )  )     |  |     ( MessageHeaders . TIMESTAMP . equals ( headerName )  )  ;", "}", "METHOD_END"], "methodName": ["isReadOnly"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "MimeType   contentType    =    getContentType (  )  ;", "for    ( MimeType   mimeType    :     . READABLE _ MIME _ TYPES )     {", "if    ( mimeType . includes ( contentType )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isReadableContentType"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( StringUtils . hasLength ( headerName )  )     &  &     (  !  ( isReadOnly ( headerName )  )  )  )     {", "set ( headerName ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["removeHeader"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "List < String >    headersToRemove    =    new   ArrayList <  >  (  )  ;", "for    ( String   pattern    :    headerPatterns )     {", "if    ( StringUtils . hasLength ( pattern )  )     {", "if    ( pattern . contains (  \"  *  \"  )  )     {", "headersToRemove . addAll ( getMatchingHeaderNames ( pattern ,    this . headers )  )  ;", "} else    {", "headersToRemove . add ( pattern )  ;", "}", "}", "}", "for    ( String   headerToRemove    :    headersToRemove )     {", "remov ( headerToRemove )  ;", "}", "}", "METHOD_END"], "methodName": ["removeHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( MessageHeaders . CONTENT _ TYPE ,    contentType )  ;", "}", "METHOD_END"], "methodName": ["setContentType"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "this . enableTimestamp    =    enableTimestamp ;", "}", "METHOD_END"], "methodName": ["setEnableTimestamp"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( MessageHeaders . ERROR _ CHANNEL ,    errorChannel )  ;", "}", "METHOD_END"], "methodName": ["setErrorChannel"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( MessageHeaders . ERROR _ CHANNEL ,    errorChannelName )  ;", "}", "METHOD_END"], "methodName": ["setErrorChannelName"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( isReadOnly ( name )  )     {", "throw   new   IllegalArgumentException (  (  (  \"  '  \"     +    name )     +     \"  '    header   is   read - only \"  )  )  ;", "}", "verifyType ( name ,    value )  ;", "if    ( value    !  =    null )     {", "if    (  !  ( ObjectUtils . nullSafeEquals ( value ,    get ( name )  )  )  )     {", "this . modified    =    true ;", "this . headers . getRaws (  )  . put ( name ,    value )  ;", "}", "} else    {", "if    ( this . headers . containsKey ( name )  )     {", "this . modified    =    true ;", "this . headers . getRaws (  )  . remove ( name )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setHeader"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getHeader ( name )  )     =  =    null )     {", "setHeader ( name ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["setHeaderIfAbsent"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "this . idGenerator    =    idGenerator ;", "}", "METHOD_END"], "methodName": ["setIdGenerator"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "this . headers . setImmutable (  )  ;", "}", "METHOD_END"], "methodName": ["setImmutable"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( this . headers . isMutable (  )  ,     \" Already   immutable \"  )  ;", "this . leaveMutable    =    leaveMutable ;", "}", "METHOD_END"], "methodName": ["setLeaveMutable"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "this . modified    =    modified ;", "}", "METHOD_END"], "methodName": ["setModified"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( MessageHeaders . REPLY _ CHANNEL ,    replyChannel )  ;", "}", "METHOD_END"], "methodName": ["setReplyChannel"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "setHeader ( MessageHeaders . REPLY _ CHANNEL ,    replyChannelName )  ;", "}", "METHOD_END"], "methodName": ["setReplyChannelName"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   HashMap <  >  ( this . headers )  ;", "}", "METHOD_END"], "methodName": ["toMap"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   MessageHeaders ( this . headers )  ;", "}", "METHOD_END"], "methodName": ["toMessageHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( headerName    !  =    null )     &  &     ( headerValue    !  =    null )  )     {", "if    (  ( s . ERROR _ CHANNEL . equals ( headerName )  )     |  |     ( s . REPLY _ CHANNEL . endsWith ( headerName )  )  )     {", "if    (  !  (  ( headerValue   instanceof   MessageChannel )     |  |     ( headerValue   instanceof   String )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \"  '  \"     +    headerName )     +     \"  '    header   value   must   be   a   MessageChannel   or   String \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["verifyType"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map 1     =    new   HashMap <  >  (  )  ;", "map 1  . put (  \" foo \"  ,     \" bar \"  )  ;", "GenericMessage < String >    message    =    new   GenericMessage <  >  (  \" payload \"  ,    map 1  )  ;", "accessor    =    new    ( message )  ;", "Map < String ,    Object >    map 2     =    new   HashMap <  >  (  )  ;", "map 2  . put (  \" foo \"  ,     \" BAR \"  )  ;", "map 2  . put (  \" bar \"  ,     \" baz \"  )  ;", "accessor . copyHeaders ( map 2  )  ;", "MessageHeaders   actual    =    accessor . getMessageHeaders (  )  ;", "assertEquals (  3  ,    actual . size (  )  )  ;", "assertEquals (  \" BAR \"  ,    actual . get (  \" foo \"  )  )  ;", "assertEquals (  \" baz \"  ,    actual . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["copyHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   headers    =    new   MessageHeaderAccessor (  )  ;", "headers . copyHeaders ( null )  ;", "headers . copyHeadersIfAbsent ( null )  ;", "assertEquals (  1  ,    headers . getMessageHeaders (  )  . size (  )  )  ;", "assertEquals ( Collections . singleton (  \" id \"  )  ,    headers . getMessageHeaders (  )  . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["copyHeadersFromNullMap"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map 1     =    new   HashMap <  >  (  )  ;", "map 1  . put (  \" foo \"  ,     \" bar \"  )  ;", "GenericMessage < String >    message    =    new   GenericMessage <  >  (  \" payload \"  ,    map 1  )  ;", "accessor    =    new    ( message )  ;", "Map < String ,    Object >    map 2     =    new   HashMap <  >  (  )  ;", "map 2  . put (  \" foo \"  ,     \" BAR \"  )  ;", "map 2  . put (  \" bar \"  ,     \" baz \"  )  ;", "accessor . copyHeadersIfAbsent ( map 2  )  ;", "MessageHeaders   actual    =    accessor . getMessageHeaders (  )  ;", "assertEquals (  3  ,    actual . size (  )  )  ;", "assertEquals (  \" bar \"  ,    actual . get (  \" foo \"  )  )  ;", "assertEquals (  \" baz \"  ,    actual . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["copyHeadersIfAbsent"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "map . put (  \" bar \"  ,     \" baz \"  )  ;", "GenericMessage < String >    message    =    new   GenericMessage <  >  (  \" payload \"  ,    map )  ;", "accessor    =    new    ( message )  ;", "MessageHeaders   actual    =    accessor . getMessageHeaders (  )  ;", "assertEquals (  3  ,    actual . size (  )  )  ;", "assertEquals (  \" bar \"  ,    actual . get (  \" foo \"  )  )  ;", "assertEquals (  \" baz \"  ,    actual . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["existingHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "map . put (  \" bar \"  ,     \" baz \"  )  ;", "GenericMessage < String >    message    =    new   GenericMessage <  >  (  \" payload \"  ,    map )  ;", "Thread . sleep (  5  0  )  ;", "accessor    =    new    ( message )  ;", "accessor . setHeader (  \" foo \"  ,     \" BAR \"  )  ;", "MessageHeaders   actual    =    accessor . getMessageHeaders (  )  ;", "assertEquals (  3  ,    actual . size (  )  )  ;", "assertNotEquals ( message . getHeaders (  )  . getId (  )  ,    actual . getId (  )  )  ;", "assertEquals (  \" BAR \"  ,    actual . get (  \" foo \"  )  )  ;", "assertEquals (  \" baz \"  ,    actual . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["existingHeadersModification"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   expected    =    new   MessageHeaderAccessor (  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \" payload \"  ,    expected . getMessageHeaders (  )  )  ;", "assertSame ( expected ,    MessageHeaderAccessor . getAccessor ( message ,    MessageHeaderAccessor . class )  )  ;", "}", "METHOD_END"], "methodName": ["getAccessor"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setContentType ( TEXT _ PLAIN )  ;", "String   expected    =     \" headers =  { contentType = text / plain }    payload = p \"  ;", "assertEquals ( expected ,    accessor . getDetailedLogMessage (  \" p \"  )  )  ;", "assertEquals ( expected ,    accessor . getDetailedLogMessage (  \" p \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "assertEquals ( expected ,    accessor . getDetailedLogMessage ( new   Object (  )     {", "@ Override", "public   String   toString (  )     {", "return    \" p \"  ;", "}", "}  )  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     8  0  ;    i +  +  )     {", "sb . append (  \" a \"  )  ;", "}", "final   String   payload    =     ( sb . toString (  )  )     +     \"     >     8  0  \"  ;", "String   actual    =    accessor . getDetailedLogMessage ( payload )  ;", "assertEquals (  (  (  \" headers =  { contentType = text / plain }    payload =  \"     +    sb )     +     \"     >     8  0  \"  )  ,    actual )  ;", "actual    =    accessor . getDetailedLogMessage ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  (  (  \" headers =  { contentType = text / plain }    payload =  \"     +    sb )     +     \"     >     8  0  \"  )  ,    actual )  ;", "actual    =    accessor . getDetailedLogMessage ( new   Object (  )     {", "@ Override", "public   String   toString (  )     {", "return   payload ;", "}", "}  )  ;", "assertEquals (  (  (  \" headers =  { contentType = text / plain }    payload =  \"     +    sb )     +     \"     >     8  0  \"  )  ,    actual )  ;", "}", "METHOD_END"], "methodName": ["getDetailedLogMessagePayload"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    MessageBuilder . withPayload (  \" payload \"  )  . build (  )  ;", "actual    =     . getMutableAccessor ( message )  ;", "assertNotNull ( actual )  ;", "assertTrue ( actual . isMutable (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMutableAccessorNewInstance"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessorTests . TestMessageHeaderAccessor   expected    =    new   MessageHeaderAccessorTests . TestMessageHeaderAccessor (  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \" payload \"  ,    expected . getMessageHeaders (  )  )  ;", "MessageHeaderAccessor   actual    =    MessageHeaderAccessor . getMutableAccessor ( message )  ;", "assertNotNull ( actual )  ;", "assertTrue ( actual . isMutable (  )  )  ;", "assertEquals ( MessageHeaderAccessorTests . TestMessageHeaderAccessor . class ,    actual . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMutableAccessorNewInstanceMatchingType"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessorTests . TestMessageHeaderAccessor   expected    =    new   MessageHeaderAccessorTests . TestMessageHeaderAccessor (  )  ;", "expected . setLeaveMutable ( true )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \" payload \"  ,    expected . getMessageHeaders (  )  )  ;", "MessageHeaderAccessor   actual    =    MessageHeaderAccessor . getMutableAccessor ( message )  ;", "assertNotNull ( actual )  ;", "assertTrue ( actual . isMutable (  )  )  ;", "assertSame ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["getMutableAccessorSameInstance"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setContentType ( TEXT _ PLAIN )  ;", "String   expected    =     \" headers =  { contentType = text / plain }    payload = p \"  ;", "assertEquals ( expected ,    accessor . getShortLogMessage (  \" p \"  )  )  ;", "assertEquals ( expected ,    accessor . getShortLogMessage (  \" p \"  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "assertEquals ( expected ,    accessor . getShortLogMessage ( new   Object (  )     {", "@ Override", "public   String   toString (  )     {", "return    \" p \"  ;", "}", "}  )  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     8  0  ;    i +  +  )     {", "sb . append (  \" a \"  )  ;", "}", "final   String   payload    =     ( sb . toString (  )  )     +     \"     >     8  0  \"  ;", "String   actual    =    accessor . getShortLogMessage ( payload )  ;", "assertEquals (  (  (  \" headers =  { contentType = text / plain }    payload =  \"     +    sb )     +     \"  .  .  .  ( truncated )  \"  )  ,    actual )  ;", "actual    =    accessor . getShortLogMessage ( payload . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "assertEquals (  (  (  \" headers =  { contentType = text / plain }    payload =  \"     +    sb )     +     \"  .  .  .  ( truncated )  \"  )  ,    actual )  ;", "actual    =    accessor . getShortLogMessage ( new   Object (  )     {", "@ Override", "public   String   toString (  )     {", "return   payload ;", "}", "}  )  ;", "assertThat ( actual ,    startsWith (  (  (  \" headers =  { contentType = text / plain }    payload =  \"     +     ( getClass (  )  . getName (  )  )  )     +     \"  $  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getShortLogMessagePayload"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "final   UUID   id    =    new   UUID (  0 L ,     2  3 L )  ;", "accessor    =    new    (  )  ;", "accessor . setIdGenerator (  (  )     -  >    id )  ;", "assertSame ( id ,    accessor . getMessageHeaders (  )  . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["idGeneratorCustom"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "assertNotNull ( accessor . getMessageHeaders (  )  . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["idGeneratorDefaultBehavior"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setIdGenerator (  (  )     -  >    MessageHeaders . ID _ VALUE _ NONE )  ;", "accessor . setEnableTimestamp ( false )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "assertNull ( headers . getId (  )  )  ;", "assertNull ( headers . getTimestamp (  )  )  ;", "final   UUID   id    =    new   UUID (  0 L ,     2  3 L )  ;", "accessor . setIdGenerator (  (  )     -  >    id )  ;", "accessor . setEnableTimestamp ( true )  ;", "accessor . setImmutable (  )  ;", "assertSame ( id ,    accessor . getMessageHeaders (  )  . getId (  )  )  ;", "assertNotNull ( headers . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["idTimestampWithMutableHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \" payload \"  ,    headers )  ;", "accessor . setHeader (  \" foo \"  ,     \" baz \"  )  ;", "assertEquals (  \" baz \"  ,    headers . get (  \" foo \"  )  )  ;", "assertSame ( accessor ,    MessageHeaderAccessor . getAccessor ( message ,    MessageHeaderAccessor . class )  )  ;", "}", "METHOD_END"], "methodName": ["leaveMutable"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar \"  )  ;", "MessageHeaders   headers    =    accessor . getMessageHeaders (  )  ;", "Message <  ?  >    message    =    MessageBuilder . createMessage (  \" payload \"  ,    headers )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" Already   immutable \"  )  ;", "accessor . setLeaveMutable ( true )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" Already   immutable \"  )  ;", "accessor . setHeader (  \" foo \"  ,     \" baz \"  )  ;", "assertEquals (  \" bar \"  ,    headers . get (  \" foo \"  )  )  ;", "assertSame ( accessor ,    MessageHeaderAccessor . getAccessor ( message ,    MessageHeaderAccessor . class )  )  ;", "}", "METHOD_END"], "methodName": ["leaveMutableDefaultBehavior"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "assertEquals (  0  ,    accessor . toMap (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["newEmptyHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "map . put (  \" bar \"  ,     \" baz \"  )  ;", "GenericMessage < String >    message    =    new   GenericMessage <  >  (  \" payload \"  ,    map )  ;", "accessor    =    new    ( message )  ;", "accessor . removeHeaders (  \" fo *  \"  )  ;", "MessageHeaders   actual    =    accessor . getMessageHeaders (  )  ;", "assertEquals (  2  ,    actual . size (  )  )  ;", "assertNull ( actual . get (  \" foo \"  )  )  ;", "assertEquals (  \" baz \"  ,    actual . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["removeHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    headers    =    new   HashMap <  >  (  )  ;", "headers . put (  \" foo \"  ,     \" bar \"  )  ;", "Message < String >    message    =    new   GenericMessage <  >  (  \" test \"  ,    headers )  ;", "mutableAccessor    =     . getMutableAccessor ( message )  ;", "mutableAccessor . setContentType ( TEXT _ PLAIN )  ;", "message    =    new   GenericMessage <  >  ( message . getPayload (  )  ,    mutableAccessor . getMessageHeaders (  )  )  ;", "Message <  ?  >    output    =     (  ( Message <  ?  >  )     ( SerializationTestUtils . serializeAndDeserialize ( message )  )  )  ;", "assertEquals (  \" test \"  ,    output . getPayload (  )  )  ;", "assertEquals (  \" bar \"  ,    output . getHeaders (  )  . get (  \" foo \"  )  )  ;", "assertNotNull ( output . getHeaders (  )  . get ( MessageHeaders . CONTENT _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["serializeMutableHeaders"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    new   GenericMessage <  >  (  \" payload \"  ,    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  ;", "accessor    =    new    ( message )  ;", "accessor . removeHeader (  \" foo \"  )  ;", "Map < String ,    Object >    headers    =    accessor . toMap (  )  ;", "assertFalse ( headers . containsKey (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveHeader"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Message <  ?  >    message    =    new   GenericMessage <  >  (  \" payload \"  ,    Collections . singletonMap (  \" foo \"  ,    null )  )  ;", "accessor    =    new    ( message )  ;", "accessor . removeHeader (  \" foo \"  )  ;", "Map < String ,    Object >    headers    =    accessor . toMap (  )  ;", "assertFalse ( headers . containsKey (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveHeaderEvenIfNull"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "assertNull ( accessor . getMessageHeaders (  )  . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["timestampDefaultBehavior"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setEnableTimestamp ( true )  ;", "assertNotNull ( accessor . getMessageHeaders (  )  . getTimestamp (  )  )  ;", "}", "METHOD_END"], "methodName": ["timestampEnabled"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MessageHeaderAccessor   accessor    =    new   MessageHeaderAccessor (  )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar 1  \"  )  ;", "Map < String ,    Object >    map 1     =    accessor . toMap (  )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar 2  \"  )  ;", "Map < String ,    Object >    map 2     =    accessor . toMap (  )  ;", "accessor . setHeader (  \" foo \"  ,     \" bar 3  \"  )  ;", "Map < String ,    Object >    map 3     =    accessor . toMap (  )  ;", "assertEquals (  1  ,    map 1  . size (  )  )  ;", "assertEquals (  1  ,    map 2  . size (  )  )  ;", "assertEquals (  1  ,    map 3  . size (  )  )  ;", "assertEquals (  \" bar 1  \"  ,    map 1  . get (  \" foo \"  )  )  ;", "assertEquals (  \" bar 2  \"  ,    map 2  . get (  \" foo \"  )  )  ;", "assertEquals (  \" bar 3  \"  ,    map 3  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["toMap"], "fileName": "org.springframework.messaging.support.MessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( isMutable (  )  ,     \" Already   immutable \"  )  ;", "if    ( value    =  =    null )     {", "return ;", "}", "Map < String ,    List < String >  >    nativeHeaders    =    getNativeHeaders (  )  ;", "if    ( nativeHeaders    =  =    null )     {", "nativeHeaders    =    new   LinkedMultiValueMap (  4  )  ;", "setHeader (  . NATIVE _ HEADERS ,    nativeHeaders )  ;", "}", "List < String >    values    =    nativeHeaders . computeIfAbsent ( name ,     (    k )     -  >    new   LinkedList <  >  (  )  )  ;", "values . add ( value )  ;", "setModified ( true )  ;", "}", "METHOD_END"], "methodName": ["addNativeHeader"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( headers    =  =    null )     {", "return ;", "}", "headers . forEach (  (    key ,    values )     -  >    values . forEach (  (    value )     -  >    addNativ ( key ,    value )  )  )  ;", "}", "METHOD_END"], "methodName": ["addNativeHeaders"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =    getNativeHeaders (  )  ;", "return    ( map    !  =    null )     &  &     ( map . containsKey ( headerName )  )  ;", "}", "METHOD_END"], "methodName": ["containsNativeHeader"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =    getNativeHeaders (  )  ;", "if    ( map    !  =    null )     {", "List < String >    values    =    map . get ( headerName )  ;", "if    ( values    !  =    null )     {", "return   values . get (  0  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getFirstNativeHeader"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =     (  ( Map < String ,    List < String >  >  )     ( headers . get ( NativeMessageHeaderAccessor . NATIVE _ HEADERS )  )  )  ;", "if    ( map    !  =    null )     {", "List < String >    values    =    map . get ( headerName )  ;", "if    ( values    !  =    null )     {", "return   values . get (  0  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getFirstNativeHeader"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =    getNativeHeaders (  )  ;", "return   map    !  =    null    ?    map . get ( headerName )     :    null ;", "}", "METHOD_END"], "methodName": ["getNativeHeader"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Map < String ,    List < String >  >  )     ( getHeader ( NativeMessageHeaderAccessor . NATIVE _ HEADERS )  )  )  ;", "}", "METHOD_END"], "methodName": ["getNativeHeaders"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( isMutable (  )  ,     \" Already   immutable \"  )  ;", "Map < String ,    List < String >  >    nativs    =    getNativs (  )  ;", "if    ( nativs    =  =    null )     {", "return   null ;", "}", "return   nativs . remove ( name )  ;", "}", "METHOD_END"], "methodName": ["removeNativeHeader"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( isMutable (  )  ,     \" Already   immutable \"  )  ;", "Map < String ,    List < String >  >    map    =    getNativeHeaders (  )  ;", "if    ( value    =  =    null )     {", "if    (  ( map    !  =    null )     &  &     (  ( map . get ( name )  )     !  =    null )  )     {", "setModified ( true )  ;", "map . remove ( name )  ;", "}", "return ;", "}", "if    ( map    =  =    null )     {", "map    =    new   LinkedMultiValueMap (  4  )  ;", "setHeader (  . NATIVE _ HEADERS ,    map )  ;", "}", "List < String >    values    =    new   LinkedList <  >  (  )  ;", "values . add ( value )  ;", "if    (  !  ( ObjectUtils . nullSafeEquals ( values ,    getHeader ( name )  )  )  )     {", "setModified ( true )  ;", "map . put ( name ,    values )  ;", "}", "}", "METHOD_END"], "methodName": ["setNativeHeader"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =    getNativeHeaders (  )  ;", "return   map    !  =    null    ?    new   util . LinkedMultiValueMap ( map )     :    Collections . emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["toNativeHeaderMap"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessor"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    nativeHeaders    =    new   LinkedMultiValueMap (  )  ;", "nativeHeaders . add (  \" foo \"  ,     \" bar \"  )  ;", "headers    =    new    ( nativeHeaders )  ;", "headers . addNativeHeader (  \" foo \"  ,     \" baz \"  )  ;", "assertEquals ( Arrays . asList (  \" bar \"  ,     \" baz \"  )  ,    headers . getNativeHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addNativeHeader"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NativeMessageHeaderAccessor   headerAccessor    =    new   NativeMessageHeaderAccessor (  )  ;", "headerAccessor . addNativeHeader (  \" foo \"  ,     \" bar \"  )  ;", "headerAccessor . setImmutable (  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" Already   immutable \"  )  ;", "headerAccessor . addNativeHeader (  \" foo \"  ,     \" baz \"  )  ;", "}", "METHOD_END"], "methodName": ["addNativeHeaderImmutable"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NativeMessageHeaderAccessor   headerAccessor    =    new   NativeMessageHeaderAccessor (  )  ;", "headerAccessor . addNativeHeader (  \" foo \"  ,     \" bar \"  )  ;", "assertEquals ( Arrays . asList (  \" bar \"  )  ,    headerAccessor . getNativeHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addNativeHeaderLazyInit"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NativeMessageHeaderAccessor   headerAccessor    =    new   NativeMessageHeaderAccessor (  )  ;", "headerAccessor . addNativeHeader (  \" foo \"  ,    null )  ;", "assertNull ( headerAccessor . getNativeHeader (  \" foo \"  )  )  ;", "assertNull ( headerAccessor . getMessageHeaders (  )  . get ( NativeMessageHeaderAccessor . NATIVE _ HEADERS )  )  ;", "}", "METHOD_END"], "methodName": ["addNativeHeaderLazyInitNullValue"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    nativeHeaders    =    new   LinkedMultiValueMap (  )  ;", "nativeHeaders . add (  \" foo \"  ,     \" bar \"  )  ;", "headers    =    new    ( nativeHeaders )  ;", "headers . addNativeHeader (  \" foo \"  ,    null )  ;", "assertEquals ( Arrays . asList (  \" bar \"  )  ,    headers . getNativeHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addNativeHeaderNullValue"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    inputNativeHeaders    =    new   LinkedMultiValueMap (  )  ;", "inputNativeHeaders . add (  \" foo \"  ,     \" bar \"  )  ;", "inputNativeHeaders . add (  \" bar \"  ,     \" baz \"  )  ;", "Map < String ,    Object >    inputHeaders    =    new   HashMap <  >  (  )  ;", "inputHeaders . put (  \" a \"  ,     \" b \"  )  ;", "inputHeaders . put (  . NATIVE _ HEADERS ,    inputNativeHeaders )  ;", "GenericMessage < String >    message    =    new   GenericMessage <  >  (  \" p \"  ,    inputHeaders )  ;", "headerAccessor    =    new    ( message )  ;", "Map < String ,    Object >    actual    =    headerAccessor . toMap (  )  ;", "assertEquals (  2  ,    actual . size (  )  )  ;", "assertEquals (  \" b \"  ,    actual . get (  \" a \"  )  )  ;", "assertNotNull ( actual . get (  . NATIVE _ HEADERS )  )  ;", "assertEquals ( inputNativeHeaders ,    actual . get (  . NATIVE _ HEADERS )  )  ;", "assertNotSame ( inputNativeHeaders ,    actual . get (  . NATIVE _ HEADERS )  )  ;", "}", "METHOD_END"], "methodName": ["createFromMessage"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    inputNativeHeaders    =    new   LinkedMultiValueMap (  )  ;", "inputNativeHeaders . add (  \" foo \"  ,     \" bar \"  )  ;", "inputNativeHeaders . add (  \" bar \"  ,     \" baz \"  )  ;", "Map < String ,    Object >    nativeHeaders    =    new   HashMap <  >  (  )  ;", "nativeHeaders . put (  \" a \"  ,     \" b \"  )  ;", "nativeHeaders . put (  . NATIVE _ HEADERS ,    inputNativeHeaders )  ;", "GenericMessage < String >    message    =    new   GenericMessage <  >  (  \" p \"  ,    nativeHeaders )  ;", "headerAccessor    =    new    ( message )  ;", "headerAccessor . setHeader (  \" a \"  ,     \" B \"  )  ;", "headerAccessor . setNativeHeader (  \" foo \"  ,     \" BAR \"  )  ;", "Map < String ,    Object >    actual    =    headerAccessor . toMap (  )  ;", "assertEquals (  2  ,    actual . size (  )  )  ;", "assertEquals (  \" B \"  ,    actual . get (  \" a \"  )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    List < String >  >    actualNativeHeaders    =     (  ( Map < String ,    List < String >  >  )     ( actual . get (  . NATIVE _ HEADERS )  )  )  ;", "assertNotNull ( actualNativeHeaders )  ;", "assertEquals ( Arrays . asList (  \" BAR \"  )  ,    actualNativeHeaders . get (  \" foo \"  )  )  ;", "assertEquals ( Arrays . asList (  \" baz \"  )  ,    actualNativeHeaders . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createFromMessageAndModify"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NativeMessageHeaderAccessor   headerAccessor    =    new   NativeMessageHeaderAccessor (  (  ( Message <  ?  >  )     ( null )  )  )  ;", "Map < String ,    Object >    actual    =    headerAccessor . toMap (  )  ;", "assertEquals (  0  ,    actual . size (  )  )  ;", "Map < String ,    List < String >  >    actualNativeHeaders    =    headerAccessor . toNativeHeaderMap (  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    actualNativeHeaders )  ;", "}", "METHOD_END"], "methodName": ["createFromMessageNull"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    inputNativeHeaders    =    new   LinkedMultiValueMap (  )  ;", "inputNativeHeaders . add (  \" foo \"  ,     \" bar \"  )  ;", "inputNativeHeaders . add (  \" bar \"  ,     \" baz \"  )  ;", "headerAccessor    =    new    ( inputNativeHeaders )  ;", "Map < String ,    Object >    actual    =    headerAccessor . toMap (  )  ;", "assertEquals ( actual . toString (  )  ,     1  ,    actual . size (  )  )  ;", "assertNotNull ( actual . get (  . NATIVE _ HEADERS )  )  ;", "assertEquals ( inputNativeHeaders ,    actual . get (  . NATIVE _ HEADERS )  )  ;", "assertNotSame ( inputNativeHeaders ,    actual . get (  . NATIVE _ HEADERS )  )  ;", "}", "METHOD_END"], "methodName": ["createFromNativeHeaderMap"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NativeMessageHeaderAccessor   headerAccessor    =    new   NativeMessageHeaderAccessor (  )  ;", "headerAccessor . addNativeHeader (  \" foo \"  ,     \" bar \"  )  ;", "headerAccessor . setImmutable (  )  ;", "headerAccessor . setImmutable (  )  ;", "}", "METHOD_END"], "methodName": ["setImmutableIdempotent"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    nativeHeaders    =    new   LinkedMultiValueMap (  )  ;", "nativeHeaders . add (  \" foo \"  ,     \" bar \"  )  ;", "headers    =    new    ( nativeHeaders )  ;", "headers . setNativeHeader (  \" foo \"  ,     \" baz \"  )  ;", "assertEquals ( Arrays . asList (  \" baz \"  )  ,    headers . getNativeHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setNativeHeader"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NativeMessageHeaderAccessor   headerAccessor    =    new   NativeMessageHeaderAccessor (  )  ;", "headerAccessor . setNativeHeader (  \" foo \"  ,     \" bar \"  )  ;", "headerAccessor . setImmutable (  )  ;", "this . thrown . expect ( IllegalStateException . class )  ;", "this . thrown . expectMessage (  \" Already   immutable \"  )  ;", "headerAccessor . setNativeHeader (  \" foo \"  ,     \" baz \"  )  ;", "}", "METHOD_END"], "methodName": ["setNativeHeaderImmutable"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NativeMessageHeaderAccessor   headerAccessor    =    new   NativeMessageHeaderAccessor (  )  ;", "headerAccessor . setNativeHeader (  \" foo \"  ,     \" baz \"  )  ;", "assertEquals ( Arrays . asList (  \" baz \"  )  ,    headerAccessor . getNativeHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setNativeHeaderLazyInit"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NativeMessageHeaderAccessor   headerAccessor    =    new   NativeMessageHeaderAccessor (  )  ;", "headerAccessor . setNativeHeader (  \" foo \"  ,    null )  ;", "assertNull ( headerAccessor . getNativeHeader (  \" foo \"  )  )  ;", "assertNull ( headerAccessor . getMessageHeaders (  )  . get ( NativeMessageHeaderAccessor . NATIVE _ HEADERS )  )  ;", "}", "METHOD_END"], "methodName": ["setNativeHeaderLazyInitNullValue"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MultiValueMap < String ,    String >    nativeHeaders    =    new   LinkedMultiValueMap (  )  ;", "nativeHeaders . add (  \" foo \"  ,     \" bar \"  )  ;", "headers    =    new    ( nativeHeaders )  ;", "headers . setNativeHeader (  \" foo \"  ,    null )  ;", "assertNull ( headers . getNativeHeader (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setNativeHeaderNullValue"], "fileName": "org.springframework.messaging.support.NativeMessageHeaderAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IllegalStateException   ex    =    new   IllegalStateException (  \" Shutting   down .  \"  )  ;", "handler . afterConnectFailure ( ex )  ;", "return   new   MonoToListenableFutureAdapter ( Mono . error ( ex )  )  ;", "}", "METHOD_END"], "methodName": ["handleShuttingDownConnectFailure"], "fileName": "org.springframework.messaging.tcp.reactor.ReactorNettyTcpClient"}, {"methodBody": ["METHOD_START", "{", "return    (    flux )     -  >    flux . scan (  1  ,     (    count ,    element )     -  >    count +  +  )  . flatMap (  (    attempt )     -  >    Optional . ofNullable ( reconnectStrategy . getTimeToNextAttempt ( attempt )  )  . map (  (    time )     -  >    Mono . delay ( Duration . ofMillis ( time )  ,    this . scheduler )  )  . orElse ( Mono . empty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["reconnectFunction"], "fileName": "org.springframework.messaging.tcp.reactor.ReactorNettyTcpClient"}, {"methodBody": ["METHOD_START", "{", "return   Mono . fromRunnable (  (  )     -  >     {", "this . scheduler . dispose (  )  ;", "for    ( int   i    =     0  ;    i    <     2  0  ;    i +  +  )     {", "if    ( this . scheduler . isDisposed (  )  )     {", "bk ;", "}", "try    {", "Thd . sleep (  1  0  0  )  ;", "}    catch    (    ex )     {", "bk ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["stopScheduler"], "fileName": "org.springframework.messaging.tcp.reactor.ReactorNettyTcpClient"}, {"methodBody": ["METHOD_START", "{", "return    (    o )     -  >     {", "if    (  !  ( connectMono . isTerminated (  )  )  )     {", "if    ( o   instanceof   Throwable )     {", "connectMono . onError (  (  ( Throwable )     ( o )  )  )  ;", "} else    {", "connectMono . onComplete (  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["updateConnectMono"], "fileName": "org.springframework.messaging.tcp.reactor.ReactorNettyTcpClient"}]