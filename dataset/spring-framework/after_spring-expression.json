[{"methodBody": ["METHOD_START", "{", "return   this . expressionString ;", "}", "METHOD_END"], "methodName": ["getExpressionString"], "fileName": "org.springframework.expression.ExpressionException"}, {"methodBody": ["METHOD_START", "{", "return   this . position ;", "}", "METHOD_END"], "methodName": ["getPosition"], "fileName": "org.springframework.expression.ExpressionException"}, {"methodBody": ["METHOD_START", "{", "return   super . getMessage (  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleMessage"], "fileName": "org.springframework.expression.ExpressionException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . expressionString )     !  =    null )     {", "StringBuilder   output    =    new   StringBuilder (  )  ;", "output . append (  \" Expression    [  \"  )  ;", "output . append ( this . expressionString )  ;", "output . append (  \"  ]  \"  )  ;", "if    (  ( this . position )     >  =     0  )     {", "output . append (  \"     @  \"  )  ;", "output . append ( this . position )  ;", "}", "output . append (  \"  :     \"  )  ;", "output . append ( getSimpleMessage (  )  )  ;", "return   output . toString (  )  ;", "} else    {", "return   getSimpleMessage (  )  ;", "}", "}", "METHOD_END"], "methodName": ["toDetailedString"], "fileName": "org.springframework.expression.ExpressionException"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . typeDescriptor )     =  =    null )     &  &     (  ( this . value )     !  =    null )  )     {", "this . typeDescriptor    =    TypeDescriptor . forObject ( this . value )  ;", "}", "return   this . typeDescriptor ;", "}", "METHOD_END"], "methodName": ["getTypeDescriptor"], "fileName": "org.springframework.expression.TypedValue"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.expression.TypedValue"}, {"methodBody": ["METHOD_START", "{", "return   this . expressions ;", "}", "METHOD_END"], "methodName": ["getExpressions"], "fileName": "org.springframework.expression.common.CompositeStringExpression"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    typedValue . getValue (  )  ;", "if    ( targetType    =  =    null )     {", "return    (  ( T )     ( value )  )  ;", "}", "if    ( context    !  =    null )     {", "return    (  ( T )     ( context . getTypeConverter (  )  . convertValue ( value ,    typedValue . getTypeDescriptor (  )  ,    TypeDescriptor . valueOf ( targetType )  )  )  )  ;", "}", "if    ( Class . isAssignableValue ( targetType ,    value )  )     {", "return    (  ( T )     ( value )  )  ;", "}", "throw   new   EvaluationException (  (  (  (  (  \" Cannot   convert   value    '  \"     +    value )     +     \"  '    to   type    '  \"  )     +     ( targetType . getName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertTypedValue"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    typeConverter . convertValue ( typedValue . getValue (  )  ,    typedValue . getTypeDescriptor (  )  ,    TypeDescriptor . valueOf ( targetType )  )  ;", "if    ( result    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" Null   conver   result   for   value    [  \"     +     ( typedValue . getValue (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return    (  ( T )     ( result )  )  ;", "}", "METHOD_END"], "methodName": ["convertValue"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ExpressionUtils . convertValue ( typeConverter ,    typedValue ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["toBoolean"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ExpressionUtils . convertValue ( typeConverter ,    typedValue ,    Byte . class )  ;", "}", "METHOD_END"], "methodName": ["toByte"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ExpressionUtils . convertValue ( typeConverter ,    typedValue ,    Character . class )  ;", "}", "METHOD_END"], "methodName": ["toChar"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ExpressionUtils . convertValue ( typeConverter ,    typedValue ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["toDouble"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ExpressionUtils . convertValue ( typeConverter ,    typedValue ,    Float . class )  ;", "}", "METHOD_END"], "methodName": ["toFloat"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ExpressionUtils . convertValue ( typeConverter ,    typedValue ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["toInt"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ExpressionUtils . convertValue ( typeConverter ,    typedValue ,    Long . class )  ;", "}", "METHOD_END"], "methodName": ["toLong"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "return   ExpressionUtils . convertValue ( typeConverter ,    typedValue ,    Short . class )  ;", "}", "METHOD_END"], "methodName": ["toShort"], "fileName": "org.springframework.expression.common.ExpressionUtils"}, {"methodBody": ["METHOD_START", "{", "int   suffixPosition    =     0  ;", "for    ( int   i    =     0  ;     ( i    <     ( suffix . length (  )  )  )     &  &     ( pos    <     ( String . length (  )  )  )  ;    i +  +  )     {", "if    (  ( String . charAt (  ( pos +  +  )  )  )     !  =     ( suffix . charAt (  ( suffixPosition +  +  )  )  )  )     {", "return   false ;", "}", "}", "if    ( suffixPosition    !  =     ( suffix . length (  )  )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isSuffixHere"], "fileName": "org.springframework.expression.common.TemplateAwareExpressionParser"}, {"methodBody": ["METHOD_START", "{", "List < Expression >    expressions    =    new   LinkedList <  >  (  )  ;", "String   prefix    =    context . getrefix (  )  ;", "String   suffix    =    context . getExpressionSuffix (  )  ;", "int   startIdx    =     0  ;", "while    ( startIdx    <     ( expressionString . length (  )  )  )     {", "int   prefixIndex    =    expressionString . indexOf ( prefix ,    startIdx )  ;", "if    ( prefixIndex    >  =    startIdx )     {", "if    ( prefixIndex    >    startIdx )     {", "expressions . add ( new   LiteralExpression ( expressionString . substring ( startIdx ,    prefixIndex )  )  )  ;", "}", "int   afterPrefixIndex    =    prefixIndex    +     ( prefix . length (  )  )  ;", "int   suffixIndex    =    skipToCorrectEndSuffix ( suffix ,    expressionString ,    afterPrefixIndex )  ;", "if    ( suffixIndex    =  =     (  -  1  )  )     {", "throw   new   ParseException ( expressionString ,    prefixIndex ,     (  (  (  (  (  \" No   ending   suffix    '  \"     +    suffix )     +     \"  '    for   expression   starting   at   character    \"  )     +    prefixIndex )     +     \"  :     \"  )     +     ( expressionString . substring ( prefixIndex )  )  )  )  ;", "}", "if    ( suffixIndex    =  =    afterPrefixIndex )     {", "throw   new   ParseException ( expressionString ,    prefixIndex ,     (  (  (  (  \" No   expression   defined   within   delimiter    '  \"     +    prefix )     +    suffix )     +     \"  '    at   character    \"  )     +    prefixIndex )  )  ;", "}", "String   expr    =    expressionString . substring (  ( prefixIndex    +     ( prefix . length (  )  )  )  ,    suffixIndex )  ;", "expr    =    expr . trim (  )  ;", "if    ( expr . isEmpty (  )  )     {", "throw   new   ParseException ( expressionString ,    prefixIndex ,     (  (  (  (  \" No   expression   defined   within   delimiter    '  \"     +    prefix )     +    suffix )     +     \"  '    at   character    \"  )     +    prefixIndex )  )  ;", "}", "expressions . add ( doParseExpression ( expr ,    context )  )  ;", "startIdx    =    suffixIndex    +     ( suffix . length (  )  )  ;", "} else    {", "expressions . add ( new   LiteralExpression ( expressionString . substring ( startIdx )  )  )  ;", "startIdx    =    expressionString . length (  )  ;", "}", "}", "return   expressions . toArray ( new   Expression [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["parseExpressions"], "fileName": "org.springframework.expression.common.TemplateAwareExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( expressionString . isEmpty (  )  )     {", "return   new   LiteralExpression (  \"  \"  )  ;", "}", "Expression [  ]    expressions    =    parss ( expressionString ,    context )  ;", "if    (  ( expressions . length )     =  =     1  )     {", "return   expressions [  0  ]  ;", "} else    {", "return   new   CompositeStringExpression ( expressionString ,    expressions )  ;", "}", "}", "METHOD_END"], "methodName": ["parseTemplate"], "fileName": "org.springframework.expression.common.TemplateAwareExpressionParser"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    afterPrefixIndex ;", "int   maxlen    =    expressionString . length (  )  ;", "int   nextSuffix    =    expressionString . indexOf ( suffix ,    afterPrefixIndex )  ;", "if    ( nextSuffix    =  =     (  -  1  )  )     {", "return    -  1  ;", "}", "Deque <  . Bracket >    stack    =    new   ArrayDeque <  >  (  )  ;", "while    ( pos    <    maxlen )     {", "if    (  ( isSuffixHere ( expressionString ,    pos ,    suffix )  )     &  &     ( stack . isEmpty (  )  )  )     {", "break ;", "}", "char   ch    =    expressionString . charAt ( pos )  ;", "switch    ( ch )     {", "case    '  {  '     :", "case    '  [  '     :", "case    '  (  '     :", "stack . push ( new    . Bracket ( ch ,    pos )  )  ;", "break ;", "case    '  }  '     :", "case    '  ]  '     :", "case    '  )  '     :", "if    ( stack . isEmpty (  )  )     {", "throw   new   ParseException ( expressionString ,    pos ,     (  (  (  (  (  (  \" Found   closing    '  \"     +    ch )     +     \"  '    at   position    \"  )     +    pos )     +     \"    without   an   opening    '  \"  )     +     (  . Bracket . theOpenBracketFor ( ch )  )  )     +     \"  '  \"  )  )  ;", "}", ". Bracket   p    =    stack . pop (  )  ;", "if    (  !  ( p . compatibleWithCloseBracket ( ch )  )  )     {", "throw   new   ParseException ( expressionString ,    pos ,     (  (  (  (  (  (  (  \" Found   closing    '  \"     +    ch )     +     \"  '    at   position    \"  )     +    pos )     +     \"    but   most   recent   opening   is    '  \"  )     +     ( p . bracket )  )     +     \"  '    at   position    \"  )     +     ( p . pos )  )  )  ;", "}", "break ;", "case    '  \\  '  '     :", "case    '  \"  '     :", "int   endLiteral    =    expressionString . indexOf ( ch ,     ( pos    +     1  )  )  ;", "if    ( endLiteral    =  =     (  -  1  )  )     {", "throw   new   ParseException ( expressionString ,    pos ,     (  \" Found   non   terminating   string   literal   starting   at   position    \"     +    pos )  )  ;", "}", "pos    =    endLiteral ;", "break ;", "}", "pos +  +  ;", "}", "if    (  !  ( stack . isEmpty (  )  )  )     {", ". Bracket   p    =    stack . pop (  )  ;", "throw   new   ParseException ( expressionString ,    p . pos ,     (  (  (  (  (  \" Missing   closing    '  \"     +     (  . Bracket . theCloseBracketFor ( p . bracket )  )  )     +     \"  '    for    '  \"  )     +     ( p . bracket )  )     +     \"  '    at   position    \"  )     +     ( p . pos )  )  )  ;", "}", "if    (  !  ( isSuffixHere ( expressionString ,    pos ,    suffix )  )  )     {", "return    -  1  ;", "}", "return   pos ;", "}", "METHOD_END"], "methodName": ["skipToCorrectEndSuffix"], "fileName": "org.springframework.expression.common.TemplateAwareExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Expression   expr    =    parser . parseExpression ( expression )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "if    (  . DEBUG )     {", "SpelUtilities . printAbstractSyntaxTree ( System . out ,    expr )  ;", "}", "Object   value    =    expr . getValue ( context )  ;", "if    ( value    =  =    null )     {", "if    ( expectedValue    =  =    null )     {", "return ;", "}", "assertNull (  (  (  \" Expression   returned   null   value ,    but   expected    '  \"     +    expectedValue )     +     \"  '  \"  )  ,    expectedValue )  ;", "}", "Class <  ?  >    resultType    =    value . getClass (  )  ;", "assertEquals (  (  (  (  (  \" Type   of   the   actual   result   was   not   as   expected .       Expected    '  \"     +    expectedResultType )     +     \"  '    but   result   was   of   type    '  \"  )     +    resultType )     +     \"  '  \"  )  ,    expectedResultType ,    resultType )  ;", "if    ( expectedValue   instanceof   String )     {", "assertEquals (  (  (  \" Did   not   get   expected   value   for   expression    '  \"     +    expression )     +     \"  '  .  \"  )  ,    expectedValue ,     . stringValueOf ( value )  )  ;", "} else    {", "assertEquals (  (  (  \" Did   not   get   expected   value   for   expression    '  \"     +    expression )     +     \"  '  .  \"  )  ,    expectedValue ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluate"], "fileName": "org.springframework.expression.spel.AbstractExpressionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expr    =    parser . parseExpression ( expression )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "if    (  . DEBUG )     {", "SpelUtilities . printAbstractSyntaxTree ( System . out ,    expr )  ;", "}", "Object   value    =    expr . getValue ( context )  ;", "if    ( value    =  =    null )     {", "if    ( expectedValue    =  =    null )     {", "return ;", "}", "assertNull (  (  (  \" Expression   returned   null   value ,    but   expected    '  \"     +    expectedValue )     +     \"  '  \"  )  ,    expectedValue )  ;", "}", "Class <  ?    extends   Object >    resultType    =    value . getClass (  )  ;", "if    ( expectedValue   instanceof   String )     {", "assertEquals (  (  (  \" Did   not   get   expected   value   for   expression    '  \"     +    expression )     +     \"  '  .  \"  )  ,    expectedValue ,     . stringValueOf ( value )  )  ;", "} else    {", "assertEquals (  (  (  \" Did   not   get   expected   value   for   expression    '  \"     +    expression )     +     \"  '  .  \"  )  ,    expectedValue ,    value )  ;", "}", "assertTrue (  (  (  (  (  \" Type   of   the   result   was   not   as   expected .       Expected    '  \"     +    expectedClassOfResult )     +     \"  '    but   result   was   of   type    '  \"  )     +    resultType )     +     \"  '  \"  )  ,    expectedClassOfResult . equals ( resultType )  )  ;", "boolean   isWritable    =    expr . isWritable ( context )  ;", "if    ( isWritable    !  =    shouldBeWritable )     {", "if    ( shouldBeWritable )", "fail (  \" Expected   the   expression   to   be   writable   but   it   is   not \"  )  ;", "else", "fail (  \" Expected   the   expression   to   be   readonly   but   it   is   not \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluate"], "fileName": "org.springframework.expression.spel.AbstractExpressionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expr    =    parser . parseExpression ( expression )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "if    (  . DEBUG )     {", "SpelUtilities . printAbstractSyntaxTree ( System . out ,    expr )  ;", "}", "Object   value    =    expr . getValue ( context ,    expectedResultType )  ;", "if    ( value    =  =    null )     {", "if    ( expectedValue    =  =    null )     {", "return ;", "}", "assertNull (  (  (  \" Expression   returned   null   value ,    but   expected    '  \"     +    expectedValue )     +     \"  '  \"  )  ,    expectedValue )  ;", "}", "Class <  ?  >    resultType    =    value . getClass (  )  ;", "assertEquals (  (  (  (  (  \" Type   of   the   actual   result   was   not   as   expected .       Expected    '  \"     +    expectedResultType )     +     \"  '    but   result   was   of   type    '  \"  )     +    resultType )     +     \"  '  \"  )  ,    expectedResultType ,    resultType )  ;", "assertEquals (  (  (  \" Did   not   get   expected   value   for   expression    '  \"     +    expression )     +     \"  '  .  \"  )  ,    expectedValue ,    value )  ;", "}", "METHOD_END"], "methodName": ["evaluateAndAskForReturnType"], "fileName": "org.springframework.expression.spel.AbstractExpressionTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Expression   expr    =    parser . parseExpression (  )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for    \"  )  ;", "}", "if    ( expectedReturnType    !  =    null )     {", "expr . getValue ( context ,    expectedReturnType )  ;", "} else    {", "expr . getValue ( context )  ;", "}", "fail (  (  \" Should   have   failed   with   message    \"     +    expectedMessage )  )  ;", "}    catch    ( EvaluationException   ee )     {", "SpelEvaluationException   ex    =     (  ( SpelEvaluationException )     ( ee )  )  ;", "if    (  ( ex . getMessageCode (  )  )     !  =    expectedMessage )     {", "assertEquals (  \" Failed   to   get   expected   message \"  ,    expectedMessage ,    ex . getMessageCode (  )  )  ;", "}", "if    (  ( otherProperties    !  =    null )     &  &     (  ( otherProperties . length )     !  =     0  )  )     {", "int   pos    =     (  ( Integer )     ( otherProperties [  0  ]  )  )  . intValue (  )  ;", "assertEquals (  \" Did   not   get   correct   position   reported   in   error    \"  ,    pos ,    ex . getPosition (  )  )  ;", "if    (  ( otherProperties . length )     >     1  )     {", "Object [  ]    inserts    =    ex . getInserts (  )  ;", "if    ( inserts    =  =    null )     {", "inserts    =    new   Object [  0  ]  ;", "}", "if    (  ( inserts . length )     <     (  ( otherProperties . length )     -     1  )  )     {", "fail (  (  (  (  (  \" Cannot   check    \"     +     (  ( otherProperties . length )     -     1  )  )     +     \"    properties   of   the   exception ,    it   only   has    \"  )     +     ( inserts . length )  )     +     \"    inserts \"  )  )  ;", "}", "for    ( int   i    =     1  ;    i    <     ( otherProperties . length )  ;    i +  +  )     {", "if    (  ( otherProperties [ i ]  )     =  =    null )     {", "if    (  ( inserts [  ( i    -     1  )  ]  )     !  =    null )     {", "fail (  (  (  \" Insert   does   not   match ,    expected    ' null '    but   insert   value   was    '  \"     +     ( inserts [  ( i    -     1  )  ]  )  )     +     \"  '  \"  )  )  ;", "}", "} else", "if    (  ( inserts [  ( i    -     1  )  ]  )     =  =    null )     {", "if    (  ( otherProperties [ i ]  )     !  =    null )     {", "fail (  (  (  \" Insert   does   not   match ,    expected    '  \"     +     ( otherProperties [ i ]  )  )     +     \"  '    but   insert   value   was    ' null '  \"  )  )  ;", "}", "} else", "if    (  !  ( inserts [  ( i    -     1  )  ]  . equals ( otherProperties [ i ]  )  )  )     {", "fail (  (  (  (  (  \" Insert   does   not   match ,    expected    '  \"     +     ( otherProperties [ i ]  )  )     +     \"  '    but   insert   value   was    '  \"  )     +     ( inserts [  ( i    -     1  )  ]  )  )     +     \"  '  \"  )  )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["evaluateAndCheckError"], "fileName": "org.springframework.expression.spel.AbstractExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError ( expression ,    null ,    expectedMessage ,    otherProperties )  ;", "}", "METHOD_END"], "methodName": ["evaluateAndCheckError"], "fileName": "org.springframework.expression.spel.AbstractExpressionTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Expression   expr    =    parser . parseExpression (  )  ;", "SpelUtilities . printAbstractSyntaxTree ( System . out ,    expr )  ;", "fail (  \" Parsing   should   have   failed !  \"  )  ;", "}    catch    ( ParseException   pe )     {", "SpelParseException   ex    =     (  ( SpelParseException )     ( pe )  )  ;", "if    (  ( ex . getMessageCode (  )  )     !  =    expectedMessage )     {", "assertEquals (  \" Failed   to   get   expected   message \"  ,    expectedMessage ,    ex . getMessageCode (  )  )  ;", "}", "if    (  ( otherProperties    !  =    null )     &  &     (  ( otherProperties . length )     !  =     0  )  )     {", "int   pos    =     (  ( Integer )     ( otherProperties [  0  ]  )  )  . intValue (  )  ;", "assertEquals (  \" Did   not   get   correct   position   reported   in   error    \"  ,    pos ,    ex . getPosition (  )  )  ;", "if    (  ( otherProperties . length )     >     1  )     {", "Object [  ]    inserts    =    ex . getInserts (  )  ;", "if    ( inserts    =  =    null )     {", "inserts    =    new   Object [  0  ]  ;", "}", "if    (  ( inserts . length )     <     (  ( otherProperties . length )     -     1  )  )     {", "fail (  (  (  (  (  \" Cannot   check    \"     +     (  ( otherProperties . length )     -     1  )  )     +     \"    properties   of   the   exception ,    it   only   has    \"  )     +     ( inserts . length )  )     +     \"    inserts \"  )  )  ;", "}", "for    ( int   i    =     1  ;    i    <     ( otherProperties . length )  ;    i +  +  )     {", "if    (  !  ( inserts [  ( i    -     1  )  ]  . equals ( otherProperties [ i ]  )  )  )     {", "fail (  (  (  (  (  \" Insert   does   not   match ,    expected    '  \"     +     ( otherProperties [ i ]  )  )     +     \"  '    but   insert   value   was    '  \"  )     +     ( inserts [  ( i    -     1  )  ]  )  )     +     \"  '  \"  )  )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseAndCheckError"], "fileName": "org.springframework.expression.spel.AbstractExpressionTests"}, {"methodBody": ["METHOD_START", "{", "return   AbstractExpressionTests . stringValueOf ( value ,    false )  ;", "}", "METHOD_END"], "methodName": ["stringValueOf"], "fileName": "org.springframework.expression.spel.AbstractExpressionTests"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return    \" null \"  ;", "}", "if    ( value . getClass (  )  . isArray (  )  )     {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "if    ( value . getClass (  )  . getComponentType (  )  . isPrimitive (  )  )     {", "Class <  ?  >    primitiveType    =    value . getClass (  )  . getComponentType (  )  ;", "if    ( primitiveType    =  =     ( Integer . TYPE )  )     {", "int [  ]    l    =     (  ( int [  ]  )     ( value )  )  ;", "sb . append (  \" int [  \"  )  . append ( l . length )  . append (  \"  ]  {  \"  )  ;", "for    ( int   j    =     0  ;    j    <     ( l . length )  ;    j +  +  )     {", "if    ( j    >     0  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "sb . append (  . stringValueOf ( l [ j ]  )  )  ;", "}", "sb . append (  \"  }  \"  )  ;", "} else", "if    ( primitiveType    =  =     ( Long . TYPE )  )     {", "long [  ]    l    =     (  ( long [  ]  )     ( value )  )  ;", "sb . append (  \" long [  \"  )  . append ( l . length )  . append (  \"  ]  {  \"  )  ;", "for    ( int   j    =     0  ;    j    <     ( l . length )  ;    j +  +  )     {", "if    ( j    >     0  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "sb . append (  . stringValueOf ( l [ j ]  )  )  ;", "}", "sb . append (  \"  }  \"  )  ;", "} else    {", "throw   new   RuntimeException (  (  (  \" Please   implement   support   for   type    \"     +     ( primitiveType . getName (  )  )  )     +     \"    in   ExpressionTestCase . stringValueOf (  )  \"  )  )  ;", "}", "} else", "if    ( value . getClass (  )  . getComponentType (  )  . isArray (  )  )     {", "List < Object >    l    =    asList (  (  ( Object [  ]  )     ( value )  )  )  ;", "if    (  ! isNested )     {", "sb . append ( value . getClass (  )  . getComponentType (  )  . getName (  )  )  ;", "}", "sb . append (  \"  [  \"  )  . append ( l . size (  )  )  . append (  \"  ]  {  \"  )  ;", "int   i    =     0  ;", "for    ( Object   object    :    l )     {", "if    ( i    >     0  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "i +  +  ;", "sb . append (  . stringValueOf ( object ,    true )  )  ;", "}", "sb . append (  \"  }  \"  )  ;", "} else    {", "List < Object >    l    =    asList (  (  ( Object [  ]  )     ( value )  )  )  ;", "if    (  ! isNested )     {", "sb . append ( value . getClass (  )  . getComponentType (  )  . getName (  )  )  ;", "}", "sb . append (  \"  [  \"  )  . append ( l . size (  )  )  . append (  \"  ]  {  \"  )  ;", "int   i    =     0  ;", "for    ( Object   object    :    l )     {", "if    ( i    >     0  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "i +  +  ;", "sb . append (  . stringValueOf ( object )  )  ;", "}", "sb . append (  \"  }  \"  )  ;", "}", "return   sb . toString (  )  ;", "} else    {", "return   value . toString (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stringValueOf"], "fileName": "org.springframework.expression.spel.AbstractExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String [  3  ]  \"  ,     \" String [  3  ]  { null , null , null }  \"  ,    String [  ]  . class )  ;", "}", "METHOD_END"], "methodName": ["basicArray"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" new   String [  ]  \"  ,    SpelMessage . MISSING _ ARRAY _ DIMENSION )  ;", "}", "METHOD_END"], "methodName": ["constructorInvocation03"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" new   Integer [  3  ]  {  '  3  '  ,  ' ghi '  ,  '  5  '  }  \"  ,    SpelMessage . INCORRECT _ ELEMENT _ TYPE _ FOR _ ARRAY ,     4  )  ;", "}", "METHOD_END"], "methodName": ["constructorInvocation04"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String [  ]  {  1  ,  2  ,  3  }  [  0  ]  \"  ,     \"  1  \"  ,    String . class )  ;", "evaluate (  \" new   int [  ]  {  '  1  2  3  '  }  [  0  ]  \"  ,     1  2  3  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["conversion"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" new   char [  7  ]  {  ' a '  ,  ' c '  ,  ' d '  ,  ' e '  }  \"  ,    SpelMessage . INITIALIZER _ LENGTH _ INCORRECT )  ;", "evaluateAndCheckError (  \" new   char [  3  ]  {  ' a '  ,  ' c '  ,  ' d '  ,  ' e '  }  \"  ,    SpelMessage . INITIALIZER _ LENGTH _ INCORRECT )  ;", "evaluateAndCheckError (  \" new   char [  2  ]  {  ' hello '  ,  ' world '  }  \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR )  ;", "evaluateAndCheckError (  \" new   St (  ' a '  ,  ' c '  ,  ' d '  )  \"  ,    SpelMessage . CONSTRUCTOR _ INVOCATION _ PROBLEM )  ;", "}", "METHOD_END"], "methodName": ["errorCases"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   e    =    parser . parseExpression (  )  ;", "Object   o    =    e . getValue (  )  ;", "assertNotNull ( o )  ;", "assertTrue ( o . getClass (  )  . isArray (  )  )  ;", "StringBuilder   s    =    new   StringBuilder (  )  ;", "s . append (  '  [  '  )  ;", "if    ( o   instanceof   int [  ]  )     {", "int [  ]    array    =     (  ( int [  ]  )     ( o )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "s . append (  '  ,  '  )  ;", "}", "s . append ( array [ i ]  )  ;", "}", "} else", "if    ( o   instanceof   boolean [  ]  )     {", "boolean [  ]    array    =     (  ( boolean [  ]  )     ( o )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "s . append (  '  ,  '  )  ;", "}", "s . append ( array [ i ]  )  ;", "}", "} else", "if    ( o   instanceof   char [  ]  )     {", "char [  ]    array    =     (  ( char [  ]  )     ( o )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "s . append (  '  ,  '  )  ;", "}", "s . append ( array [ i ]  )  ;", "}", "} else", "if    ( o   instanceof   long [  ]  )     {", "long [  ]    array    =     (  ( long [  ]  )     ( o )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "s . append (  '  ,  '  )  ;", "}", "s . append ( array [ i ]  )  ;", "}", "} else", "if    ( o   instanceof   short [  ]  )     {", "short [  ]    array    =     (  ( short [  ]  )     ( o )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "s . append (  '  ,  '  )  ;", "}", "s . append ( array [ i ]  )  ;", "}", "} else", "if    ( o   instanceof   double [  ]  )     {", "double [  ]    array    =     (  ( double [  ]  )     ( o )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "s . append (  '  ,  '  )  ;", "}", "s . append ( array [ i ]  )  ;", "}", "} else", "if    ( o   instanceof   float [  ]  )     {", "float [  ]    array    =     (  ( float [  ]  )     ( o )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "s . append (  '  ,  '  )  ;", "}", "s . append ( array [ i ]  )  ;", "}", "} else", "if    ( o   instanceof   byte [  ]  )     {", "byte [  ]    array    =     (  ( byte [  ]  )     ( o )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "s . append (  '  ,  '  )  ;", "}", "s . append ( array [ i ]  )  ;", "}", "} else    {", "fail (  (  \" Not   supported    \"     +     ( o . getClass (  )  )  )  )  ;", "}", "s . append (  '  ]  '  )  ;", "assertEquals ( expectedToString ,    s . toString (  )  )  ;", "return   s . toString (  )  ;", "}", "METHOD_END"], "methodName": ["evaluateArrayBuildingExpression"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String [  2  ]  [  2  ]  \"  ,     \"  [ LString ;  [  2  ]  {  [  2  ]  { null , null }  ,  [  2  ]  { null , null }  }  \"  ,    String [  ]  [  ]  . class )  ;", "evaluate (  \" new   String [  3  ]  [  2  ]  [  1  ]  \"  ,     \"  [  [ LString ;  [  3  ]  {  [  2  ]  {  [  1  ]  { null }  ,  [  1  ]  { null }  }  ,  [  2  ]  {  [  1  ]  { null }  ,  [  1  ]  { null }  }  ,  [  2  ]  {  [  1  ]  { null }  ,  [  1  ]  { null }  }  }  \"  ,    String [  ]  [  ]  [  ]  . class )  ;", "}", "METHOD_END"], "methodName": ["multiDimensionalArray"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" new   int [  ]  [  ]  {  {  1  ,  2  }  ,  {  3  ,  4  }  }  \"  ,    SpelMessage . MULTIDIM _ ARRAY _ INITIALIZER _ NOT _ SUPPORTED )  ;", "evaluateAndCheckError (  \" new   int [  3  ]  [  ]  \"  ,    SpelMessage . MISSING _ ARRAY _ DIMENSION )  ;", "evaluateAndCheckError (  \" new   int [  ]  \"  ,    SpelMessage . MISSING _ ARRAY _ DIMENSION )  ;", "evaluateAndCheckError (  \" new   St [  ]  \"  ,    SpelMessage . MISSING _ ARRAY _ DIMENSION )  ;", "evaluateAndCheckError (  \" new   int [  ]  [  1  ]  \"  ,    SpelMessage . MISSING _ ARRAY _ DIMENSION )  ;", "}", "METHOD_END"], "methodName": ["multidimensionalArrays"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluateArrayBuildingExpression (  \" new   int [  ]  {  1  ,  2  ,  3  ,  4  }  \"  ,     \"  [  1  ,  2  ,  3  ,  4  ]  \"  )  ;", "evaluateArrayBuildingExpression (  \" new   boolean [  ]  { true , false , true }  \"  ,     \"  [ true , false , true ]  \"  )  ;", "evaluateArrayBuildingExpression (  \" new   char [  ]  {  ' a '  ,  ' b '  ,  ' c '  }  \"  ,     \"  [ a , b , c ]  \"  )  ;", "evaluateArrayBuildingExpression (  \" new   long [  ]  {  1  ,  2  ,  3  ,  4  ,  5  }  \"  ,     \"  [  1  ,  2  ,  3  ,  4  ,  5  ]  \"  )  ;", "evaluateArrayBuildingExpression (  \" new   short [  ]  {  2  ,  3  ,  4  ,  5  ,  6  }  \"  ,     \"  [  2  ,  3  ,  4  ,  5  ,  6  ]  \"  )  ;", "evaluateArrayBuildingExpression (  \" new   double [  ]  {  1 d ,  2 d ,  3 d ,  4 d }  \"  ,     \"  [  1  .  0  ,  2  .  0  ,  3  .  0  ,  4  .  0  ]  \"  )  ;", "evaluateArrayBuildingExpression (  \" new   float [  ]  {  1 f ,  2 f ,  3 f ,  4 f }  \"  ,     \"  [  1  .  0  ,  2  .  0  ,  3  .  0  ,  4  .  0  ]  \"  )  ;", "evaluateArrayBuildingExpression (  \" new   byte [  ]  {  1  ,  2  ,  3  ,  4  }  \"  ,     \"  [  1  ,  2  ,  3  ,  4  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["primitiveTypeArrayConstructors"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   int [  ]  {  1  ,  2  ,  3  ,  4  }  [  0  ]  \"  ,     1  ,    Integer . class )  ;", "evaluate (  \" new   boolean [  ]  { true , false , true }  [  0  ]  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   char [  ]  {  ' a '  ,  ' b '  ,  ' c '  }  [  0  ]  \"  ,     ' a '  ,    Character . class )  ;", "evaluate (  \" new   long [  ]  {  1  ,  2  ,  3  ,  4  ,  5  }  [  0  ]  \"  ,     1 L ,    Long . class )  ;", "evaluate (  \" new   short [  ]  {  2  ,  3  ,  4  ,  5  ,  6  }  [  0  ]  \"  ,     (  ( short )     (  2  )  )  ,    Short . class )  ;", "evaluate (  \" new   double [  ]  {  1 d ,  2 d ,  3 d ,  4 d }  [  0  ]  \"  ,     (  ( double )     (  1  )  )  ,    Double . class )  ;", "evaluate (  \" new   float [  ]  {  1 f ,  2 f ,  3 f ,  4 f }  [  0  ]  \"  ,     (  ( float )     (  1  )  )  ,    Float . class )  ;", "evaluate (  \" new   byte [  ]  {  1  ,  2  ,  3  ,  4  }  [  0  ]  \"  ,     (  ( byte )     (  1  )  )  ,    Byte . class )  ;", "evaluate (  \" new   St ( new   char [  ]  {  ' h '  ,  ' e '  ,  ' l '  ,  ' l '  ,  ' o '  }  )  \"  ,     \" hello \"  ,    St . class )  ;", "}", "METHOD_END"], "methodName": ["primitiveTypeArrayConstructorsElements"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluateArrayBuildingExpression (  \" new   int [  ]  {  1  ,  2  ,  3  }  \"  ,     \"  [  1  ,  2  ,  3  ]  \"  )  ;", "evaluateArrayBuildingExpression (  \" new   int [  ]  {  }  \"  ,     \"  [  ]  \"  )  ;", "evaluate (  \" new   int [  ]  {  }  . length \"  ,     \"  0  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["simpleArrayWithInitializer"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String [  ]  {  ' a '  ,  ' b '  ,  ' c '  ,  ' d '  }  [  1  ]  \"  ,     \" b \"  ,    String . class )  ;", "evaluateAndCheckError (  \" new   String [  ]  {  ' a '  ,  ' b '  ,  ' c '  ,  ' d '  }  . size (  )  \"  ,    SpelMessage . METHOD _ NOT _ FOUND ,     3  0  ,     \" size (  )  \"  ,     \" String [  ]  \"  )  ;", "evaluate (  \" new   String [  ]  {  ' a '  ,  ' b '  ,  ' c '  ,  ' d '  }  . length \"  ,     4  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["typeArrayConstructors"], "fileName": "org.springframework.expression.spel.ArrayConstructorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" false   and   false \"  ,    Boolean . FALSE ,    Boolean . class )  ;", "evaluate (  \" false   and   true \"  ,    Boolean . FALSE ,    Boolean . class )  ;", "evaluate (  \" true   and   false \"  ,    Boolean . FALSE ,    Boolean . class )  ;", "evaluate (  \" true   and   true \"  ,    Boolean . TRUE ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testAnd"], "fileName": "org.springframework.expression.spel.BooleanExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  1  .  0    or   false \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     0  )  ;", "evaluateAndCheckError (  \" false   or    3  9  .  4  \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     9  )  ;", "evaluateAndCheckError (  \" true   and    ' hello '  \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     9  )  ;", "evaluateAndCheckError (  \"     ' hello '    and    ' goodbye '  \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     1  )  ;", "evaluateAndCheckError (  \"  !  3  5  .  2  \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     1  )  ;", "evaluateAndCheckError (  \"  !     ' foob '  \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     2  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanErrors01"], "fileName": "org.springframework.expression.spel.BooleanExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" false \"  ,    Boolean . FALSE ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testBooleanFalse"], "fileName": "org.springframework.expression.spel.BooleanExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" true \"  ,    Boolean . TRUE ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testBooleanTrue"], "fileName": "org.springframework.expression.spel.BooleanExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" false   and   false   or   true \"  ,    Boolean . TRUE ,    Boolean . class )  ;", "evaluate (  \" true   and   false   or   true \"  ,    Boolean . TRUE ,    Boolean . class )  ;", "evaluate (  \" true   and   false   or   false \"  ,    Boolean . FALSE ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testCombinations01"], "fileName": "org.springframework.expression.spel.BooleanExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" null   or   true \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     0  ,     \" null \"  ,     \" boolean \"  )  ;", "evaluateAndCheckError (  \" null   and   true \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     0  ,     \" null \"  ,     \" boolean \"  )  ;", "evaluateAndCheckError (  \"  ! null \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     1  ,     \" null \"  ,     \" boolean \"  )  ;", "evaluateAndCheckError (  \" null    ?     ' foo '     :     ' bar '  \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR ,     0  ,     \" null \"  ,     \" boolean \"  )  ;", "GenericConversionService   conversionService    =    new   GenericConversionService (  )     {", "@ Override", "protected   Object   convertNullSource ( TypeDescriptor   sourceType ,    TypeDescriptor   targetType )     {", "return    ( targetType . getType (  )  )     =  =     (  . class )     ?    false    :    null ;", "}", "}  ;", "context . setTypeConverter ( new   StandardTypeConverter ( conversionService )  )  ;", "evaluate (  \" null   or   true \"  ,     . TRUE ,     . class ,    false )  ;", "evaluate (  \" null   and   true \"  ,     . FALSE ,     . class ,    false )  ;", "evaluate (  \"  ! null \"  ,     . TRUE ,     . class ,    false )  ;", "evaluate (  \" null    ?     ' foo '     :     ' bar '  \"  ,     \" bar \"  ,    String . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["testConvertAndHandleNull"], "fileName": "org.springframework.expression.spel.BooleanExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ! false \"  ,    Boolean . TRUE ,    Boolean . class )  ;", "evaluate (  \"  ! true \"  ,    Boolean . FALSE ,    Boolean . class )  ;", "evaluate (  \" not   false \"  ,    Boolean . TRUE ,    Boolean . class )  ;", "evaluate (  \" NoT   true \"  ,    Boolean . FALSE ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testNot"], "fileName": "org.springframework.expression.spel.BooleanExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" false   or   false \"  ,    Boolean . FALSE ,    Boolean . class )  ;", "evaluate (  \" false   or   true \"  ,    Boolean . TRUE ,    Boolean . class )  ;", "evaluate (  \" true   or   false \"  ,    Boolean . TRUE ,    Boolean . class )  ;", "evaluate (  \" true   or   true \"  ,    Boolean . TRUE ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testOr"], "fileName": "org.springframework.expression.spel.BooleanExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" true   and   true \"  ,    Boolean . TRUE ,    Boolean . class ,    false )  ;", "evaluate (  \" true   or   true \"  ,    Boolean . TRUE ,    Boolean . class ,    false )  ;", "evaluate (  \"  ! false \"  ,    Boolean . TRUE ,    Boolean . class ,    false )  ;", "}", "METHOD_END"], "methodName": ["testWritability"], "fileName": "org.springframework.expression.spel.BooleanExpressionTests"}, {"methodBody": ["METHOD_START", "{", "this . context . setVariable (  \" var \"  ,    var )  ;", "assertEquals ( expected ,    getValue ( this . context )  )  ;", "}", "METHOD_END"], "methodName": ["assertMethodExecution"], "fileName": "org.springframework.expression.spel.CachedMethodExecutorTests"}, {"methodBody": ["METHOD_START", "{", "this . context    =    new   StandardEvaluationContext ( new   CachedMethodExecutorTests . RootObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.expression.spel.CachedMethodExecutorTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    this . parser . parseExpression (  \" echo (  # var )  \"  )  ;", "assertion ( expression ,     4  2  ,     \" int :     4  2  \"  )  ;", "assertion ( expression ,     4  2  ,     \" int :     4  2  \"  )  ;", "assertion ( expression ,     \" Deep   Thought \"  ,     \" String :    Deep   Thought \"  )  ;", "assertion ( expression ,     4  2  ,     \" int :     4  2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCachedExecutionForParameters"], "fileName": "org.springframework.expression.spel.CachedMethodExecutorTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    this . parser . parseExpression (  \"  # var . echo (  4  2  )  \"  )  ;", "assertMethodExecution ( expression ,    new    . RootObject (  )  ,     \" int :     4  2  \"  )  ;", "assertMethodExecution ( expression ,    new    . RootObject (  )  ,     \" int :     4  2  \"  )  ;", "assertMethodExecution ( expression ,    new    . BaseObject (  )  ,     \" String :     4  2  \"  )  ;", "assertMethodExecution ( expression ,    new    . RootObject (  )  ,     \" int :     4  2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCachedExecutionForTarget"], "fileName": "org.springframework.expression.spel.CachedMethodExecutorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( desc 1  . equals ( desc 2  )  )     {", "return   true ;", "}", "if    (  ( desc 1  . length (  )  )     =  =     1  )     {", "if    ( desc 1  . equals (  \" Z \"  )  )     {", "return   desc 2  . equals (  \" Ljava / lang / Boolean \"  )  ;", "} else", "if    ( desc 1  . equals (  \" D \"  )  )     {", "return   desc 2  . equals (  \" Ljava / lang / Double \"  )  ;", "} else", "if    ( desc 1  . equals (  \" F \"  )  )     {", "return   desc 2  . equals (  \" Ljava / lang / at \"  )  ;", "} else", "if    ( desc 1  . equals (  \" I \"  )  )     {", "return   desc 2  . equals (  \" Ljava / lang / Integer \"  )  ;", "} else", "if    ( desc 1  . equals (  \" J \"  )  )     {", "return   desc 2  . equals (  \" Ljava / lang / Long \"  )  ;", "}", "} else", "if    (  ( desc 2  . length (  )  )     =  =     1  )     {", "if    ( desc 2  . equals (  \" Z \"  )  )     {", "return   desc 1  . equals (  \" Ljava / lang / Boolean \"  )  ;", "} else", "if    ( desc 2  . equals (  \" D \"  )  )     {", "return   desc 1  . equals (  \" Ljava / lang / Double \"  )  ;", "} else", "if    ( desc 2  . equals (  \" F \"  )  )     {", "return   desc 1  . equals (  \" Ljava / lang / at \"  )  ;", "} else", "if    ( desc 2  . equals (  \" I \"  )  )     {", "return   desc 1  . equals (  \" Ljava / lang / Integer \"  )  ;", "} else", "if    ( desc 2  . equals (  \" J \"  )  )     {", "return   desc 1  . equals (  \" Ljava / lang / Long \"  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["areBoxingCompatible"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "switch    ( arraytype . charAt (  0  )  )     {", "case    ' I '     :", "return   T _ INT ;", "case    ' J '     :", "return   T _ LONG ;", "case    ' F '     :", "return   T _ FLOAT ;", "case    ' D '     :", "return   T _ DOUBLE ;", "case    ' B '     :", "return   T _ BYTE ;", "case    ' C '     :", "return   T _ CHAR ;", "case    ' S '     :", "return   T _ SHORT ;", "case    ' Z '     :", "return   T _ BOOLEAN ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Unected   arraytype    \"     +     ( arraytype . charAt (  0  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["arrayCodeFor"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    params    =    ctor . getParameterTypes (  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \"  (  \"  )  ;", "for    ( Class <  ?  >    param    :    params )     {", "sb . append (  . toJvmDescriptor ( param )  )  ;", "}", "sb . append (  \"  ) V \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createSignatureDescriptor"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    params    =    method . getParameterTypes (  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \"  (  \"  )  ;", "for    ( Class <  ?  >    param    :    params )     {", "sb . append (  . toJvmDescriptor ( param )  )  ;", "}", "sb . append (  \"  )  \"  )  ;", "sb . append (  . toJvmDescriptor ( method . getReturnType (  )  )  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createSignatureDescriptor"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "this . compilationScopes . push ( new   ArrayList <  >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["enterCompilationScope"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "this . compilationScopes . pop (  )  ;", "}", "METHOD_END"], "methodName": ["exitCompilationScope"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . fieldAdders )     !  =    null )     {", "for    (  . FieldAdder   fieldAdder    :    this . fieldAdders )     {", "fieldAdder . generateField ( this . classWriter ,    this )  ;", "}", "}", "if    (  ( this . clinitAdders )     !  =    null )     {", "MethodVisitor   mv    =    this . classWriter . visitMethod (  (  ( ACC _ PUBLIC )     |     ( ACC _ STATIC )  )  ,     \"  < clinit >  \"  ,     \"  (  ) V \"  ,    null ,    null )  ;", "mv . visitCode (  )  ;", "this . nextFreeVariableId    =     0  ;", "for    (  . ClinitAdder   clinitAdder    :    this . clinitAdders )     {", "clinitAdder . generateCode ( mv ,    this )  ;", "}", "mv . visitInsn ( RETURN )  ;", "mv . visitMaxs (  0  ,     0  )  ;", "mv . visitEnd (  )  ;", "}", "}", "METHOD_END"], "methodName": ["finish"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "return   this . className ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    ( CodeFlow . isPrimitive ( stackDescriptor )  )     {", "char   stackTop    =    stackDescriptor . charAt (  0  )  ;", "if    (  (  (  ( stackTop    =  =     ' I '  )     |  |     ( stackTop    =  =     ' B '  )  )     |  |     ( stackTop    =  =     ' S '  )  )     |  |     ( stackTop    =  =     ' C '  )  )     {", "if    ( targetDescriptor    =  =     ' D '  )     {", "mv . visitInsn ( I 2 D )  ;", "} else", "if    ( targetDescriptor    =  =     ' F '  )     {", "mv . visitInsn ( I 2 F )  ;", "} else", "if    ( targetDescriptor    =  =     ' J '  )     {", "mv . visitInsn ( I 2 L )  ;", "} else", "if    ( targetDescriptor    =  =     ' I '  )     {", "} else    {", "throw   new   IllegalStateException (  (  (  (  \" cannot   get   from    \"     +    stackTop )     +     \"    to    \"  )     +    targetDescriptor )  )  ;", "}", "} else", "if    ( stackTop    =  =     ' J '  )     {", "if    ( targetDescriptor    =  =     ' D '  )     {", "mv . visitInsn ( L 2 D )  ;", "} else", "if    ( targetDescriptor    =  =     ' F '  )     {", "mv . visitInsn ( L 2 F )  ;", "} else", "if    ( targetDescriptor    =  =     ' J '  )     {", "} else", "if    ( targetDescriptor    =  =     ' I '  )     {", "mv . visitInsn ( L 2 I )  ;", "} else    {", "throw   new   IllegalStateException (  (  (  (  \" cannot   get   from    \"     +    stackTop )     +     \"    to    \"  )     +    targetDescriptor )  )  ;", "}", "} else", "if    ( stackTop    =  =     ' F '  )     {", "if    ( targetDescriptor    =  =     ' D '  )     {", "mv . visitInsn ( F 2 D )  ;", "} else", "if    ( targetDescriptor    =  =     ' F '  )     {", "} else", "if    ( targetDescriptor    =  =     ' J '  )     {", "mv . visitInsn ( F 2 L )  ;", "} else", "if    ( targetDescriptor    =  =     ' I '  )     {", "mv . visitInsn ( F 2 I )  ;", "} else    {", "throw   new   IllegalStateException (  (  (  (  \" cannot   get   from    \"     +    stackTop )     +     \"    to    \"  )     +    targetDescriptor )  )  ;", "}", "} else", "if    ( stackTop    =  =     ' D '  )     {", "if    ( targetDescriptor    =  =     ' D '  )     {", "} else", "if    ( targetDescriptor    =  =     ' F '  )     {", "mv . visitInsn ( D 2 F )  ;", "} else", "if    ( targetDescriptor    =  =     ' J '  )     {", "mv . visitInsn ( D 2 L )  ;", "} else", "if    ( targetDescriptor    =  =     ' I '  )     {", "mv . visitInsn ( D 2 I )  ;", "} else    {", "throw   new   IllegalStateException (  (  (  (  \" cannot   get   from    \"     +    stackDescriptor )     +     \"    to    \"  )     +    targetDescriptor )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["insertAnyNecessaryTypeConversionBytecodes"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    (  ( arrayElementType . length (  )  )     =  =     1  )     {", "switch    ( arrayElementType . charAt (  0  )  )     {", "case    ' I '     :", "mv . visitInsn ( IASTORE )  ;", "break ;", "case    ' J '     :", "mv . visitInsn ( LASTORE )  ;", "break ;", "case    ' F '     :", "mv . visitInsn ( FASTORE )  ;", "break ;", "case    ' D '     :", "mv . visitInsn ( DASTORE )  ;", "break ;", "case    ' B '     :", "mv . visitInsn ( BASTORE )  ;", "break ;", "case    ' C '     :", "mv . visitInsn ( CASTORE )  ;", "break ;", "case    ' S '     :", "mv . visitInsn ( SASTORE )  ;", "break ;", "case    ' Z '     :", "mv . visitInsn ( BASTORE )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Unected   arraytype    \"     +     ( arrayElementType . charAt (  0  )  )  )  )  ;", "}", "} else    {", "mv . visitInsn ( AASTORE )  ;", "}", "}", "METHOD_END"], "methodName": ["insertArrayStore"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "switch    ( ch )     {", "case    ' Z '     :", "mv . visitMethodInsn ( INVOKESTATIC ,     \" java / lang / Boolean \"  ,     \" valueOf \"  ,     \"  ( Z ) Ljava / lang / Boolean ;  \"  ,    false )  ;", "break ;", "case    ' B '     :", "mv . visitMethodInsn ( INVOKESTATIC ,     \" java / lang / Byte \"  ,     \" valueOf \"  ,     \"  ( B ) Ljava / lang / Byte ;  \"  ,    false )  ;", "break ;", "case    ' C '     :", "mv . visitMethodInsn ( INVOKESTATIC ,     \" java / lang / Character \"  ,     \" valueOf \"  ,     \"  ( C ) Ljava / lang / Character ;  \"  ,    false )  ;", "break ;", "case    ' D '     :", "mv . visitMethodInsn ( INVOKESTATIC ,     \" java / lang / Double \"  ,     \" valueOf \"  ,     \"  ( D ) Ljava / lang / Double ;  \"  ,    false )  ;", "break ;", "case    ' F '     :", "mv . visitMethodInsn ( INVOKESTATIC ,     \" java / lang / at \"  ,     \" valueOf \"  ,     \"  ( F ) Ljava / lang / at ;  \"  ,    false )  ;", "break ;", "case    ' I '     :", "mv . visitMethodInsn ( INVOKESTATIC ,     \" java / lang / Integer \"  ,     \" valueOf \"  ,     \"  ( I ) Ljava / lang / Integer ;  \"  ,    false )  ;", "break ;", "case    ' J '     :", "mv . visitMethodInsn ( INVOKESTATIC ,     \" java / lang / Long \"  ,     \" valueOf \"  ,     \"  ( J ) Ljava / lang / Long ;  \"  ,    false )  ;", "break ;", "case    ' S '     :", "mv . visitMethodInsn ( INVOKESTATIC ,     \" java / lang / Short \"  ,     \" valueOf \"  ,     \"  ( S ) Ljava / lang / Short ;  \"  ,    false )  ;", "break ;", "case    ' L '     :", "case    ' V '     :", "case    '  [  '     :", "break ;", "default    :", "throw   new   IllegalArgumentException (  (  (  \" Boxing   should   not   be   attempted   for   descriptor    '  \"     +    ch )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["insertBoxIfNecessary"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    (  ( descriptor    !  =    null )     &  &     (  ( descriptor . length (  )  )     =  =     1  )  )     {", ". insertBoxIfNecessary ( mv ,    descriptor . charAt (  0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["insertBoxIfNecessary"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    (  ( descriptor    !  =    null )     &  &     (  ( descriptor . length (  )  )     !  =     1  )  )     {", "if    (  ( descriptor . charAt (  0  )  )     =  =     '  [  '  )     {", "if    (  . isPrimitiveArray ( descriptor )  )     {", "mv . visitTypeInsn ( CHECKCAST ,    descriptor )  ;", "} else    {", "mv . visitTypeInsn ( CHECKCAST ,     ( descriptor    +     \"  ;  \"  )  )  ;", "}", "} else    {", "if    (  !  ( descriptor . equals (  \" Ljava / lang / Object \"  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,    descriptor . substring (  1  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["insertCheckCast"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "CodeFlow . insertOptimalLoad ( mv ,    size )  ;", "if    (  ( arraytype . length (  )  )     =  =     1  )     {", "mv . visitIntInsn ( NEWARRAY ,    CodeFlow . arrayCodeFor ( arraytype )  )  ;", "} else    {", "if    (  ( arraytype . charAt (  0  )  )     =  =     '  [  '  )     {", "if    ( CodeFlow . isReferenceTypeArray ( arraytype )  )     {", "mv . visitTypeInsn ( ANEWARRAY ,     ( arraytype    +     \"  ;  \"  )  )  ;", "} else    {", "mv . visitTypeInsn ( ANEWARRAY ,    arraytype )  ;", "}", "} else    {", "mv . visitTypeInsn ( ANEWARRAY ,    arraytype . substring (  1  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["insertNewArrayCode"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CodeFlow . isPrimitive ( stackDescriptor )  )  )     {", "CodeFlow . insertUnboxNumberInsns ( mv ,    targetDescriptor ,    stackDescriptor )  ;", "} else    {", "CodeFlow . insertAnyNecessaryTypeConversionBytecodes ( mv ,    targetDescriptor ,    stackDescriptor )  ;", "}", "}", "METHOD_END"], "methodName": ["insertNumericUnboxOrPrimitiveTypeCoercion"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    ( value    <     6  )     {", "mv . vitInsn (  (  ( ICONST _  0  )     +    value )  )  ;", "} else", "if    ( value    <     ( Byte . MAX _ VALUE )  )     {", "mv . vitIntInsn ( BIPUSH ,    value )  ;", "} else", "if    ( value    <     ( Short . MAX _ VALUE )  )     {", "mv . vitIntInsn ( SIPUSH ,    value )  ;", "} else    {", "mv . vitLdcInsn ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["insertOptimalLoad"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    ( stackDescriptor    =  =    null )     {", "return ;", "}", "switch    ( ch )     {", "case    ' Z '     :", "if    (  !  ( stackDescriptor . equals (  \" Ljava / lang / Boolean \"  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Boolean \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Boolean \"  ,     \" booleanValue \"  ,     \"  (  ) Z \"  ,    false )  ;", "break ;", "case    ' B '     :", "if    (  !  ( stackDescriptor . equals (  \" Ljava / lang / Byte \"  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Byte \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Byte \"  ,     \" byteValue \"  ,     \"  (  ) B \"  ,    false )  ;", "break ;", "case    ' C '     :", "if    (  !  ( stackDescriptor . equals (  \" Ljava / lang / Character \"  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Character \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Character \"  ,     \" charValue \"  ,     \"  (  ) C \"  ,    false )  ;", "break ;", "case    ' D '     :", "if    (  !  ( stackDescriptor . equals (  \" Ljava / lang / Double \"  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Double \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Double \"  ,     \" doubleValue \"  ,     \"  (  ) D \"  ,    false )  ;", "break ;", "case    ' F '     :", "if    (  !  ( stackDescriptor . equals (  \" Ljava / lang / at \"  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / at \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / at \"  ,     \" floatValue \"  ,     \"  (  ) F \"  ,    false )  ;", "break ;", "case    ' I '     :", "if    (  !  ( stackDescriptor . equals (  \" Ljava / lang / Integer \"  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Integer \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Integer \"  ,     \" intValue \"  ,     \"  (  ) I \"  ,    false )  ;", "break ;", "case    ' J '     :", "if    (  !  ( stackDescriptor . equals (  \" Ljava / lang / Long \"  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Long \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Long \"  ,     \" longValue \"  ,     \"  (  ) J \"  ,    false )  ;", "break ;", "case    ' S '     :", "if    (  !  ( stackDescriptor . equals (  \" Ljava / lang / Short \"  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Short \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Short \"  ,     \" shortValue \"  ,     \"  (  ) S \"  ,    false )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  (  (  \" Unboxing   should   not   be   attempted   for   descriptor    '  \"     +    ch )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["insertUnboxInsns"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    ( stackDescriptor    =  =    null )     {", "return ;", "}", "switch    ( targetDescriptor )     {", "case    ' D '     :", "if    ( stackDescriptor . equals (  \" Ljava / lang / Object \"  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Number \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Number \"  ,     \" doubleValue \"  ,     \"  (  ) D \"  ,    false )  ;", "break ;", "case    ' F '     :", "if    ( stackDescriptor . equals (  \" Ljava / lang / Object \"  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Number \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Number \"  ,     \" floatValue \"  ,     \"  (  ) F \"  ,    false )  ;", "break ;", "case    ' J '     :", "if    ( stackDescriptor . equals (  \" Ljava / lang / Object \"  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Number \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Number \"  ,     \" longValue \"  ,     \"  (  ) J \"  ,    false )  ;", "break ;", "case    ' I '     :", "if    ( stackDescriptor . equals (  \" Ljava / lang / Object \"  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / Number \"  )  ;", "}", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Number \"  ,     \" intValue \"  ,     \"  (  ) I \"  ,    false )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  (  (  \" Unbox   should   not   be   attempted   for   descriptor    '  \"     +    targetDescriptor )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["insertUnboxNumberInsns"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "return    ( descriptor    !  =    null )     &  &     (  ( descriptor . equals (  \" Z \"  )  )     |  |     ( descriptor . equals (  \" Ljava / lang / Boolean \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isBooleanCompatible"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "return    (  ( number   instanceof   Integer )     |  |     ( number   instanceof   Short )  )     |  |     ( number   instanceof   Byte )  ;", "}", "METHOD_END"], "methodName": ["isIntegerForNumericOp"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "return    ( descriptor    !  =    null )     &  &     (  ( descriptor . length (  )  )     =  =     1  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitive"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    ( descriptor    =  =    null )     {", "return   false ;", "}", "boolean   mitive    =    true ;", "for    ( int   i    =     0  ,    max    =    descriptor . length (  )  ;    i    <    max ;    i +  +  )     {", "char   ch    =    descriptor . charAt ( i )  ;", "if    ( ch    =  =     '  [  '  )     {", "continue ;", "}", "mitive    =    ch    !  =     ' L '  ;", "break ;", "}", "return   mitive ;", "}", "METHOD_END"], "methodName": ["isPrimitiveArray"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    ( descriptor    =  =    null )     {", "return   false ;", "}", "if    (  ( descriptor . length (  )  )     =  =     1  )     {", "return    \" DFIJ \"  . contains ( descriptor )  ;", "}", "if    ( descriptor . startsWith (  \" Ljava / lang /  \"  )  )     {", "St   name    =    descriptor . subst (  \" Ljava / lang /  \"  . length (  )  )  ;", "if    (  (  (  ( name . equals (  \" Double \"  )  )     |  |     ( name . equals (  \" Float \"  )  )  )     |  |     ( name . equals (  \" Integer \"  )  )  )     |  |     ( name . equals (  \" Long \"  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrUnboxableSupportedNumber"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    ( descriptor    =  =    null )     {", "return   false ;", "}", "if    (  . isPrimitiveOrUnboxableSupportedNumber ( descriptor )  )     {", "return   true ;", "}", "return    (  \" Z \"  . equals ( descriptor )  )     |  |     ( descriptor . equals (  \" Ljava / lang / Boolean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveOrUnboxableSupportedNumberOrBoolean"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "int   length    =    arraytype . length (  )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "char   ch    =    arraytype . charAt ( i )  ;", "if    ( ch    =  =     '  [  '  )", "continue ;", "return   ch    =  =     ' L '  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isReferenceTypeArray"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . lastElement ( this . compilationScopes . peek (  )  )  ;", "}", "METHOD_END"], "methodName": ["lastDescriptor"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "mv . visitVarInsn ( ALOAD ,     2  )  ;", "}", "METHOD_END"], "methodName": ["loadEvaluationContext"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "mv . visitVarInsn ( ALOAD ,     1  )  ;", "}", "METHOD_END"], "methodName": ["loadTarget"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "return    ( this . nextFieldId )  +  +  ;", "}", "METHOD_END"], "methodName": ["nextFieldId"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "return    ( this . nextFreeVariableId )  +  +  ;", "}", "METHOD_END"], "methodName": ["nextFreeVariableId"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    ( descriptor    !  =    null )     {", "this . compilatScopes . element (  )  . add ( descriptor )  ;", "}", "}", "METHOD_END"], "methodName": ["pushDescriptor"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . clinitAdders )     =  =    null )     {", "this . clinitAdders    =    new   ArrayList <  >  (  )  ;", "}", "this . clinitAdders . add ( clinitAdder )  ;", "}", "METHOD_END"], "methodName": ["registerNewClinit"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . fieldAdders )     =  =    null )     {", "this . fieldAdders    =    new   ArrayList <  >  (  )  ;", "}", "this . fieldAdders . add ( fieldAdder )  ;", "}", "METHOD_END"], "methodName": ["registerNewField"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "switch    ( primitiveDescriptor . charAt (  0  )  )     {", "case    ' I '     :", "return    \" Ljava / lang / Integer \"  ;", "case    ' J '     :", "return    \" Ljava / lang / Long \"  ;", "case    ' F '     :", "return    \" Ljava / lang / Float \"  ;", "case    ' D '     :", "return    \" Ljava / lang / Double \"  ;", "case    ' B '     :", "return    \" Ljava / lang / Byte \"  ;", "case    ' C '     :", "return    \" Ljava / lang / Character \"  ;", "case    ' S '     :", "return    \" Ljava / lang / Short \"  ;", "case    ' Z '     :", "return    \" Ljava / lang / Boolean \"  ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Unexpected   non   primitive   descriptor    \"     +    primitiveDescriptor )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toBoxedDescriptor"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "String   name    =    type . getName (  )  ;", "if    ( type . isPrimitive (  )  )     {", "switch    ( name . length (  )  )     {", "case    3     :", "return    \" I \"  ;", "case    4     :", "if    ( name . equals (  \" byte \"  )  )     {", "return    \" B \"  ;", "} else", "if    ( name . equals (  \" char \"  )  )     {", "return    \" C \"  ;", "} else", "if    ( name . equals (  \" long \"  )  )     {", "return    \" J \"  ;", "} else", "if    ( name . equals (  \" void \"  )  )     {", "return    \" V \"  ;", "}", "break ;", "case    5     :", "if    ( name . equals (  \" float \"  )  )     {", "return    \" F \"  ;", "} else", "if    ( name . equals (  \" short \"  )  )     {", "return    \" S \"  ;", "}", "break ;", "case    6     :", "if    ( name . equals (  \" double \"  )  )     {", "return    \" D \"  ;", "}", "break ;", "case    7     :", "if    ( name . equals (  \" boolean \"  )  )     {", "return    \" Z \"  ;", "}", "break ;", "}", "} else    {", "if    (  ( name . charAt (  0  )  )     !  =     '  [  '  )     {", "return    \" L \"     +     ( type . getName (  )  . replace (  '  .  '  ,     '  /  '  )  )  ;", "} else    {", "if    ( name . endsWith (  \"  ;  \"  )  )     {", "return   name . substring (  0  ,     (  ( name . length (  )  )     -     1  )  )  . replace (  '  .  '  ,     '  /  '  )  ;", "} else    {", "return   name ;", "}", "}", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["toDescriptor"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return    \" Ljava / lang / Object \"  ;", "} else    {", "return    . toDescriptor ( value . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toDescriptorFromObject"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "int   typesCount    =    types . length ;", "String [  ]    descriptors    =    new   String [ typesCount ]  ;", "for    ( int   p    =     0  ;    p    <    typesCount ;    p +  +  )     {", "descriptors [ p ]     =     . toDescriptor ( types [ p ]  )  ;", "}", "return   descriptors ;", "}", "METHOD_END"], "methodName": ["toDescriptors"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "if    ( clazz . isArray (  )  )     {", "while    ( clazz . isArray (  )  )     {", "sb . append (  \"  [  \"  )  ;", "clazz    =    clazz . getComponentType (  )  ;", "}", "}", "if    ( clazz . isPrimitive (  )  )     {", "if    ( clazz    =  =     ( Boolean . TYPE )  )     {", "sb . append (  ' Z '  )  ;", "} else", "if    ( clazz    =  =     ( Byte . TYPE )  )     {", "sb . append (  ' B '  )  ;", "} else", "if    ( clazz    =  =     ( Character . TYPE )  )     {", "sb . append (  ' C '  )  ;", "} else", "if    ( clazz    =  =     ( Double . TYPE )  )     {", "sb . append (  ' D '  )  ;", "} else", "if    ( clazz    =  =     ( Float . TYPE )  )     {", "sb . append (  ' F '  )  ;", "} else", "if    ( clazz    =  =     ( Integer . TYPE )  )     {", "sb . append (  ' I '  )  ;", "} else", "if    ( clazz    =  =     ( Long . TYPE )  )     {", "sb . append (  ' J '  )  ;", "} else", "if    ( clazz    =  =     ( Short . TYPE )  )     {", "sb . append (  ' S '  )  ;", "} else", "if    ( clazz    =  =     ( Void . TYPE )  )     {", "sb . append (  ' V '  )  ;", "}", "} else    {", "sb . append (  \" L \"  )  ;", "sb . append ( clazz . getName (  )  . replace (  '  .  '  ,     '  /  '  )  )  ;", "sb . append (  \"  ;  \"  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toJvmDescriptor"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "return   CodeFlow . toDescriptors ( ctor . getParameterTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["toParamDescriptors"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "return   CodeFlow . toDescriptors ( method . getParameterTypes (  )  )  ;", "}", "METHOD_END"], "methodName": ["toParamDescriptors"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    (  ( descriptor . length (  )  )     =  =     1  )     {", "return   descriptor . charAt (  0  )  ;", "} else", "if    ( descriptor . equals (  \" Ljava / lang / Boolean \"  )  )     {", "return    ' Z '  ;", "} else", "if    ( descriptor . equals (  \" Ljava / lang / Byte \"  )  )     {", "return    ' B '  ;", "} else", "if    ( descriptor . equals (  \" Ljava / lang / Character \"  )  )     {", "return    ' C '  ;", "} else", "if    ( descriptor . equals (  \" Ljava / lang / Double \"  )  )     {", "return    ' D '  ;", "} else", "if    ( descriptor . equals (  \" Ljava / lang / at \"  )  )     {", "return    ' F '  ;", "} else", "if    ( descriptor . equals (  \" Ljava / lang / Integer \"  )  )     {", "return    ' I '  ;", "} else", "if    ( descriptor . equals (  \" Ljava / lang / Long \"  )  )     {", "return    ' J '  ;", "} else", "if    ( descriptor . equals (  \" Ljava / lang / Short \"  )  )     {", "return    ' S '  ;", "} else    {", "throw   new   IllegalStateException (  (  (  \" No   primitive   for    '  \"     +    descriptor )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toPrimitiveTargetDesc"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "if    (  \" Ljava / lang / Boolean \"  . equals ( lastDescriptor (  )  )  )     {", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / Boolean \"  ,     \" booleanValue \"  ,     \"  (  ) Z \"  ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["unboxBooleanIfNecessary"], "fileName": "org.springframework.expression.spel.CodeFlow"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "List < ConstructorResolver >    constructorResolvers    =    ctx . getConstructorResolvers (  )  ;", "assertEquals (  1  ,    constructorResolvers . size (  )  )  ;", "ConstructorResolver   dummy    =    new    . DummyConstructorResolver (  )  ;", "ctx . addConstructorResolver ( dummy )  ;", "assertEquals (  2  ,    ctx . getConstructorResolvers (  )  . size (  )  )  ;", "List < ConstructorResolver >    copy    =    new   ArrayList <  >  (  )  ;", "copy . addAll ( ctx . getConstructorResolvers (  )  )  ;", "assertTrue ( ctx . removeConstructorResolver ( dummy )  )  ;", "assertFalse ( ctx . removeConstructorResolver ( dummy )  )  ;", "assertEquals (  1  ,    ctx . getConstructorResolvers (  )  . size (  )  )  ;", "ctx . setConstructorResolvers ( copy )  ;", "assertEquals (  2  ,    ctx . getConstructorResolvers (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddingConstructorResolvers"], "fileName": "org.springframework.expression.spel.ConstructorInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String (  3  .  0 d )  \"  ,     \"  3  .  0  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testArgumentConversion01"], "fileName": "org.springframework.expression.spel.ConstructorInvocationTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \" new    $ Tester (  # bar )  . i \"  )  ;", "StandardEvaluationContext   eContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "eContext . setRootObject ( new   ConstructorInvocationTests . Tester (  )  )  ;", "eContext . setVariable (  \" bar \"  ,     3  )  ;", "Object   o    =    expr . getValue ( eContext )  ;", "assertEquals (  3  ,    o )  ;", "assertEquals (  1  ,    parser . parseExpression (  \" counter \"  )  . getValue ( eContext )  )  ;", "eContext . setVariable (  \" bar \"  ,    new   PlaceOfBirth (  \" London \"  )  )  ;", "o    =    expr . getValue ( eContext )  ;", "assertEquals (  0  ,    o )  ;", "eContext . setVariable (  \" bar \"  ,     3  )  ;", "o    =    expr . getValue ( eContext )  ;", "assertEquals (  3  ,    o )  ;", "assertEquals (  2  ,    parser . parseExpression (  \" counter \"  )  . getValue ( eContext )  )  ;", "eContext . setVariable (  \" bar \"  ,     4  )  ;", "try    {", "o    =    expr . getValue ( eContext )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( Exception   e )     {", "int   idx    =    e . getMessage (  )  . indexOf (  \" Tester \"  )  ;", "if    ( idx    =  =     (  -  1  )  )     {", "fail (  (  \" Expected   reference   to   Tester   in    :  \"     +     ( e . getMessage (  )  )  )  )  ;", "}", "}", "assertEquals (  3  ,    parser . parseExpression (  \" counter \"  )  . getValue ( eContext )  )  ;", "eContext . setVariable (  \" bar \"  ,     1  )  ;", "try    {", "o    =    expr . getValue ( eContext )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( Exception   e )     {", "if    ( e   instanceof   SpelEvaluationException )     {", "e . printStackTrace (  )  ;", "fail (  \" Should   not   have   been   wrapped \"  )  ;", "}", "}", "assertEquals (  4  ,    parser . parseExpression (  \" counter \"  )  . getValue ( eContext )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorThrowingException_SPR6760"], "fileName": "org.springframework.expression.spel.ConstructorInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" new   FooBar (  )  \"  ,    SpelMessage . CONSTRUCTOR _ INVOCATION _ PROBLEM )  ;", "}", "METHOD_END"], "methodName": ["testNonExistentType"], "fileName": "org.springframework.expression.spel.ConstructorInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String (  ' hello   world '  )  \"  ,     \" hello   world \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testTypeConstructors"], "fileName": "org.springframework.expression.spel.ConstructorInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   Fruit (  ' a '  ,  ' b '  ,  ' c '  )  . stringscount (  )  \"  ,     3  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  ' a '  )  . stringscount (  )  \"  ,     1  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  )  . stringscount (  )  \"  ,     0  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  1  ,  2  ,  3  )  . stringscount (  )  \"  ,     3  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  1  )  . stringscount (  )  \"  ,     1  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  1  ,  ' a '  ,  3  .  0 d )  . stringscount (  )  \"  ,     3  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testVarargsInvocation01"], "fileName": "org.springframework.expression.spel.ConstructorInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   Fruit (  5  ,  ' a '  ,  ' b '  ,  ' c '  )  . stringscount (  )  \"  ,     8  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  2  ,  ' a '  )  . stringscount (  )  \"  ,     3  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  4  )  . stringscount (  )  \"  ,     4  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  8  ,  2  ,  3  )  . stringscount (  )  \"  ,     1  0  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  9  )  . stringscount (  )  \"  ,     9  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  2  ,  ' a '  ,  3  .  0 d )  . stringscount (  )  \"  ,     4  ,    Integer . class )  ;", "evaluate (  \" new   Fruit (  8  , stringArrayOfThreeItems )  . stringscount (  )  \"  ,     1  1  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testVarargsInvocation02"], "fileName": "org.springframework.expression.spel.ConstructorInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   Double (  3  )  \"  ,     3  .  0  ,    Double . class )  ;", "evaluate (  \" new   Long (  3  )  \"  ,     3 L ,    Long . class )  ;", "}", "METHOD_END"], "methodName": ["testWidening01"], "fileName": "org.springframework.expression.spel.ConstructorInvocationTests"}, {"methodBody": ["METHOD_START", "{", "TypeComparator   comparator    =    new   StandardTypeComparator (  )  ;", "assertTrue ( comparator . canCompare ( null ,     1  )  )  ;", "assertTrue ( comparator . canCompare (  1  ,    null )  )  ;", "assertTrue ( comparator . canCompare (  2  ,     1  )  )  ;", "assertTrue ( comparator . canCompare (  \" abc \"  ,     \" def \"  )  )  ;", "assertTrue ( comparator . canCompare (  \" abc \"  ,     3  )  )  ;", "assertFalse ( comparator . canCompare ( String . class ,     3  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanCompare"], "fileName": "org.springframework.expression.spel.DefaultComparatorUnitTests"}, {"methodBody": ["METHOD_START", "{", "TypeComparator   comparator    =    new   StandardTypeComparator (  )  ;", "BigDecimal   bdOne    =    new   BigDecimal (  \"  1  \"  )  ;", "BigDecimal   bdTwo    =    new   BigDecimal (  \"  2  \"  )  ;", "assertTrue (  (  ( comparator . compare ( bdOne ,    bdTwo )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare ( bdOne ,    new   BigDecimal (  \"  1  \"  )  )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare ( bdTwo ,    bdOne )  )     >     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  ,    bdTwo )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  ,    bdOne )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2  ,    bdOne )  )     >     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  .  0  ,    bdTwo )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  .  0  ,    bdOne )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2  .  0  ,    bdOne )  )     >     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  .  0 F ,    bdTwo )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  .  0 F ,    bdOne )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2  .  0 F ,    bdOne )  )     >     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1 L ,    bdTwo )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1 L ,    bdOne )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2 L ,    bdOne )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonPrimitiveNumbers"], "fileName": "org.springframework.expression.spel.DefaultComparatorUnitTests"}, {"methodBody": ["METHOD_START", "{", "TypeComparator   comparator    =    new   StandardTypeComparator (  )  ;", "assertTrue (  (  ( comparator . compare ( null ,     \" abc \"  )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare ( null ,    null )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  \" abc \"  ,    null )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testNulls"], "fileName": "org.springframework.expression.spel.DefaultComparatorUnitTests"}, {"methodBody": ["METHOD_START", "{", "TypeComparator   comparator    =    new   StandardTypeComparator (  )  ;", "assertTrue (  (  ( comparator . compare (  \" a \"  ,     \" a \"  )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  \" a \"  ,     \" b \"  )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  \" b \"  ,     \" a \"  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testObjects"], "fileName": "org.springframework.expression.spel.DefaultComparatorUnitTests"}, {"methodBody": ["METHOD_START", "{", "TypeComparator   comparator    =    new   StandardTypeComparator (  )  ;", "assertTrue (  (  ( comparator . compare (  1  ,     2  )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  ,     1  )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2  ,     1  )  )     >     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  .  0  ,     2  )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  .  0  ,     1  )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2  .  0  ,     1  )  )     >     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  .  0 F ,     2  )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  .  0 F ,     1  )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2  .  0 F ,     1  )  )     >     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1 L ,     2  )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1 L ,     1  )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2 L ,     1  )  )     >     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  ,     2 L )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1  ,     1 L )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2  ,     1 L )  )     >     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1 L ,     2 L )  )     <     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  1 L ,     1 L )  )     =  =     0  )  )  ;", "assertTrue (  (  ( comparator . compare (  2 L ,     1 L )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrimitives"], "fileName": "org.springframework.expression.spel.DefaultComparatorUnitTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   e    =    parser . parseExpression (  \" null \"  )  ;", "assertNull ( e . getValue (  )  )  ;", "e    =    parser . parseExpression (  \" NULL \"  )  ;", "assertNull ( e . getValue (  )  )  ;", "e    =    parser . parseExpression (  \" NuLl \"  )  ;", "assertNull ( e . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["caseInsensitiveNullLiterals"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . Spr 9  7  5  1    instance    =    new   EvaluationTests . Spr 9  7  5  1  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( instance )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e    =    parser . parseExpression (  \" listOfStrings [  +  + index 3  ]  =  ' def '  \"  )  ;", "e . getValue ( ctx )  ;", "assertEquals (  2  ,    instance . listOfStrings . size (  )  )  ;", "assertEquals (  \" def \"  ,    instance . listOfStrings . get (  1  )  )  ;", "ctx    =    new   StandardEvaluationContext ( instance )  ;", "parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "e    =    parser . parseExpression (  \" listOfStrings [  0  ]  \"  )  ;", "String   value    =    e . getValue ( ctx ,    String . class )  ;", "assertEquals (  \" abc \"  ,    value )  ;", "e    =    parser . parseExpression (  \" listOfStrings [  1  ]  \"  )  ;", "value    =    e . getValue ( ctx ,    String . class )  ;", "assertEquals (  \" def \"  ,    value )  ;", "e    =    parser . parseExpression (  \" listOfStrings [  2  ]  \"  )  ;", "value    =    e . getValue ( ctx ,    String . class )  ;", "assertEquals (  \"  \"  ,    value )  ;", "ctx    =    new   StandardEvaluationContext ( instance )  ;", "parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( false ,    false )  )  ;", "e    =    parser . parseExpression (  \" listOfStrings [  3  ]  \"  )  ;", "try    {", "e . getValue ( ctx ,    String . class )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . COLLECTION _ INDEX _ OUT _ OF _ BOUNDS ,    see . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["collectionGrowingViaIndexer"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   PlaceOfBirth ( inventions [  0  ]  . toString (  )  )  . city \"  ,     \" Telephone   repeater \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["ctorCallWithRootReferenceThroughParameter"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "List < MethodResolver >    customResolvers    =    new   ArrayList <  >  (  )  ;", "customResolvers . add ( new    . CustomMethodResolver (  )  )  ;", "context . setMethodResolvers ( customResolvers )  ;", "MethodFilter   filter    =    new    . CustomMethodFilter (  )  ;", "try    {", "context . registerMethodFilter ( String . class ,    filter )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( IllegalStateException   ise )     {", "assertEquals (  \" Method   filter   cannot   be   set   as   the   reflective   method   resolver   is   not   in   use \"  ,    ise . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["customMethodFilter"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "Integer   i    =     4  2  ;", "StandardContext   ctx    =    new   StandardContext ( i )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e    =    parser . parseExpression (  \"  # this -  -  \"  )  ;", "assertEquals (  4  2  ,    i . intValue (  )  )  ;", "try    {", "e . getValue ( ctx ,    Integer . class )  ;", "fail (  )  ;", "}    catch    ( SpelException   see )     {", "assertEquals ( SpelMessage . NOT _ ASSIGNABLE ,    see . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["decrement01root"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . Spr 9  7  5  1    helper    =    new   EvaluationTests . Spr 9  7  5  1  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( helper )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e ;", "e    =    parser . parseExpression (  \" bd -  -  \"  )  ;", "assertTrue ( new   BigDecimal (  \"  2  \"  )  . equals ( helper . bd )  )  ;", "BigDecimal   return _ bd    =    e . getValue ( ctx ,    BigDecimal . class )  ;", "assertTrue ( new   BigDecimal (  \"  2  \"  )  . equals ( return _ bd )  )  ;", "assertTrue ( new   BigDecimal (  \"  1  \"  )  . equals ( helper . bd )  )  ;", "e    =    parser . parseExpression (  \" ddd -  -  \"  )  ;", "assertEquals (  2  .  0  ,    helper . ddd ,     0  .  0  )  ;", "double   return _ ddd    =    e . getValue ( ctx ,    Double . TYPE )  ;", "assertEquals (  2  .  0  ,    return _ ddd ,     0  .  0  )  ;", "assertEquals (  1  .  0  ,    helper . ddd ,     0  .  0  )  ;", "e    =    parser . parseExpression (  \" fff -  -  \"  )  ;", "assertEquals (  3  .  0 F ,    helper . fff ,     0  .  0  )  ;", "float   return _ fff    =    e . getValue ( ctx ,    Float . TYPE )  ;", "assertEquals (  3  .  0 F ,    return _ fff ,     0  .  0  )  ;", "assertEquals (  2  .  0 F ,    helper . fff ,     0  .  0  )  ;", "e    =    parser . parseExpression (  \" lll -  -  \"  )  ;", "assertEquals (  6  6  6  6  6 L ,    helper . lll )  ;", "long   return _ lll    =    e . getValue ( ctx ,    Long . TYPE )  ;", "assertEquals (  6  6  6  6  6 L ,    return _ lll )  ;", "assertEquals (  6  6  6  6  5 L ,    helper . lll )  ;", "e    =    parser . parseExpression (  \" iii -  -  \"  )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "int   return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    return _ iii )  ;", "assertEquals (  4  1  ,    helper . iii )  ;", "return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  1  ,    return _ iii )  ;", "assertEquals (  4  0  ,    helper . iii )  ;", "e    =    parser . parseExpression (  \" sss -  -  \"  )  ;", "assertEquals (  1  5  ,    helper . sss )  ;", "short   return _ sss    =    e . getValue ( ctx ,    Short . TYPE )  ;", "assertEquals (  1  5  ,    return _ sss )  ;", "assertEquals (  1  4  ,    helper . sss )  ;", "}", "METHOD_END"], "methodName": ["decrement02postfix"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . Spr 9  7  5  1    helper    =    new   EvaluationTests . Spr 9  7  5  1  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( helper )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e ;", "e    =    parser . parseExpression (  \"  -  - bd \"  )  ;", "assertTrue ( new   BigDecimal (  \"  2  \"  )  . equals ( helper . bd )  )  ;", "BigDecimal   return _ bd    =    e . getValue ( ctx ,    BigDecimal . class )  ;", "assertTrue ( new   BigDecimal (  \"  1  \"  )  . equals ( return _ bd )  )  ;", "assertTrue ( new   BigDecimal (  \"  1  \"  )  . equals ( helper . bd )  )  ;", "e    =    parser . parseExpression (  \"  -  - ddd \"  )  ;", "assertEquals (  2  .  0  ,    helper . ddd ,     0  .  0  )  ;", "double   return _ ddd    =    e . getValue ( ctx ,    Double . TYPE )  ;", "assertEquals (  1  .  0  ,    return _ ddd ,     0  .  0  )  ;", "assertEquals (  1  .  0  ,    helper . ddd ,     0  .  0  )  ;", "e    =    parser . parseExpression (  \"  -  - fff \"  )  ;", "assertEquals (  3  .  0 F ,    helper . fff ,     0  .  0  )  ;", "float   return _ fff    =    e . getValue ( ctx ,    Float . TYPE )  ;", "assertEquals (  2  .  0 F ,    return _ fff ,     0  .  0  )  ;", "assertEquals (  2  .  0 F ,    helper . fff ,     0  .  0  )  ;", "e    =    parser . parseExpression (  \"  -  - lll \"  )  ;", "assertEquals (  6  6  6  6  6 L ,    helper . lll )  ;", "long   return _ lll    =    e . getValue ( ctx ,    Long . TYPE )  ;", "assertEquals (  6  6  6  6  5 L ,    return _ lll )  ;", "assertEquals (  6  6  6  6  5 L ,    helper . lll )  ;", "e    =    parser . parseExpression (  \"  -  - iii \"  )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "int   return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  1  ,    return _ iii )  ;", "assertEquals (  4  1  ,    helper . iii )  ;", "return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  0  ,    return _ iii )  ;", "assertEquals (  4  0  ,    helper . iii )  ;", "e    =    parser . parseExpression (  \"  -  - sss \"  )  ;", "assertEquals (  1  5  ,    helper . sss )  ;", "int   return _ sss    =     (  ( Integer )     ( e . getValue ( ctx )  )  )  ;", "assertEquals (  1  4  ,    return _ sss )  ;", "assertEquals (  1  4  ,    helper . sss )  ;", "}", "METHOD_END"], "methodName": ["decrement02prefix"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . Spr 9  7  5  1    helper    =    new   EvaluationTests . Spr 9  7  5  1  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( helper )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e ;", "e    =    parser . parseExpression (  \" m (  )  -  -  \"  )  ;", "try    {", "e . getValue ( ctx ,    Double . TYPE )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . OPERAND _ NOT _ DECREMENTABLE ,    see . getMessageCode (  )  )  ;", "}", "e    =    parser . parseExpression (  \"  -  - m (  )  \"  )  ;", "try    {", "e . getValue ( ctx ,    Double . TYPE )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . OPERAND _ NOT _ DECREMENTABLE ,    see . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["decrement03"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "Integer   i    =     4  2  ;", "StandardContext   ctx    =    new   StandardContext ( i )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "try    {", "Expression   e    =    parser . parseExpression (  \"  -  -  1  \"  )  ;", "e . getValue ( ctx ,    Integer . class )  ;", "fail (  )  ;", "}    catch    ( SpelException   see )     {", "assertEquals ( SpelMessage . NOT _ ASSIGNABLE ,    see . getMessageCode (  )  )  ;", "}", "try    {", "Expression   e    =    parser . parseExpression (  \"  1  -  -  \"  )  ;", "e . getValue ( ctx ,    Integer . class )  ;", "fail (  )  ;", "}    catch    ( SpelException   see )     {", "assertEquals ( SpelMessage . NOT _ ASSIGNABLE ,    see . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["decrement04"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Expression   e    =    parser . parseExpression ( String )  ;", "SpelUtilities . printAbstractSyntaxTree ( System . out ,    e )  ;", "e . getValue ( eContext )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( messageCode ,    see . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["expectFail"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "expectFail ( parser ,    eContext ,    expressionString ,    SpelMessage . NOT _ ASSIGNABLE )  ;", "}", "METHOD_END"], "methodName": ["expectFailNotAssignable"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "expectFail ( parser ,    eContext ,    expressionString ,    SpelMessage . OPERAND _ NOT _ DECREMENTABLE )  ;", "}", "METHOD_END"], "methodName": ["expectFailNotDecrementable"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "expectFail ( parser ,    eContext ,    expressionString ,    SpelMessage . OPERAND _ NOT _ INCREMENTABLE )  ;", "}", "METHOD_END"], "methodName": ["expectFailNotIncrementable"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "expectFail ( parser ,    eContext ,    expressionString ,    SpelMessage . SETVALUE _ NOT _ SUPPORTED )  ;", "}", "METHOD_END"], "methodName": ["expectFailSetValueNotSupported"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # reverseInt ( inventions . length ,    inventions . length ,    inventions . length )  \"  ,     \" int [  3  ]  {  9  ,  9  ,  9  }  \"  ,    int [  ]  . class )  ;", "}", "METHOD_END"], "methodName": ["fnCallWithRootReferenceThroughParameter"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . Spr 9  7  5  1    helper    =    new   EvaluationTests . Spr 9  7  5  1  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( helper )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e ;", "e    =    parser . parseExpression (  \" intArray [  # root . index 1  +  +  ]  +  +  \"  )  ;", "e . getValue ( ctx ,    Integer . class )  ;", "assertEquals (  3  ,    helper . index 1  )  ;", "assertEquals (  4  ,    helper . intArray [  2  ]  )  ;", "e    =    parser . parseExpression (  \" intArray [  # root . index 1  +  +  ]  -  -  \"  )  ;", "assertEquals (  4  ,    e . getValue ( ctx ,    Integer . class )  . intValue (  )  )  ;", "assertEquals (  4  ,    helper . index 1  )  ;", "assertEquals (  3  ,    helper . intArray [  3  ]  )  ;", "e    =    parser . parseExpression (  \" intArray [  -  -  # root . index 1  ]  +  +  \"  )  ;", "assertEquals (  3  ,    e . getValue ( ctx ,    Integer . class )  . intValue (  )  )  ;", "assertEquals (  3  ,    helper . index 1  )  ;", "assertEquals (  4  ,    helper . intArray [  3  ]  )  ;", "}", "METHOD_END"], "methodName": ["incdecTogether"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "Integer   i    =     4  2  ;", "StandardContext   ctx    =    new   StandardContext ( i )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e    =    parser . parseExpression (  \"  # this +  +  \"  )  ;", "assertEquals (  4  2  ,    i . intValue (  )  )  ;", "try    {", "e . getValue ( ctx ,    Integer . class )  ;", "fail (  )  ;", "}    catch    ( SpelException   see )     {", "assertEquals ( SpelMessage . NOT _ ASSIGNABLE ,    see . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["increment01root"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . Spr 9  7  5  1    helper    =    new   EvaluationTests . Spr 9  7  5  1  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( helper )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e ;", "e    =    parser . parseExpression (  \" bd +  +  \"  )  ;", "assertTrue ( new   BigDecimal (  \"  2  \"  )  . equals ( helper . bd )  )  ;", "BigDecimal   return _ bd    =    e . getValue ( ctx ,    BigDecimal . class )  ;", "assertTrue ( new   BigDecimal (  \"  2  \"  )  . equals ( return _ bd )  )  ;", "assertTrue ( new   BigDecimal (  \"  3  \"  )  . equals ( helper . bd )  )  ;", "e    =    parser . parseExpression (  \" ddd +  +  \"  )  ;", "assertEquals (  2  .  0  ,    helper . ddd ,     0  .  0  )  ;", "double   return _ ddd    =    e . getValue ( ctx ,    Double . TYPE )  ;", "assertEquals (  2  .  0  ,    return _ ddd ,     0  .  0  )  ;", "assertEquals (  3  .  0  ,    helper . ddd ,     0  .  0  )  ;", "e    =    parser . parseExpression (  \" fff +  +  \"  )  ;", "assertEquals (  3  .  0 F ,    helper . fff ,     0  .  0  )  ;", "float   return _ fff    =    e . getValue ( ctx ,    Float . TYPE )  ;", "assertEquals (  3  .  0 F ,    return _ fff ,     0  .  0  )  ;", "assertEquals (  4  .  0 F ,    helper . fff ,     0  .  0  )  ;", "e    =    parser . parseExpression (  \" lll +  +  \"  )  ;", "assertEquals (  6  6  6  6  6 L ,    helper . lll )  ;", "long   return _ lll    =    e . getValue ( ctx ,    Long . TYPE )  ;", "assertEquals (  6  6  6  6  6 L ,    return _ lll )  ;", "assertEquals (  6  6  6  6  7 L ,    helper . lll )  ;", "e    =    parser . parseExpression (  \" iii +  +  \"  )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "int   return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    return _ iii )  ;", "assertEquals (  4  3  ,    helper . iii )  ;", "return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  3  ,    return _ iii )  ;", "assertEquals (  4  4  ,    helper . iii )  ;", "e    =    parser . parseExpression (  \" sss +  +  \"  )  ;", "assertEquals (  1  5  ,    helper . sss )  ;", "short   return _ sss    =    e . getValue ( ctx ,    Short . TYPE )  ;", "assertEquals (  1  5  ,    return _ sss )  ;", "assertEquals (  1  6  ,    helper . sss )  ;", "}", "METHOD_END"], "methodName": ["increment02postfix"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . Spr 9  7  5  1    helper    =    new   EvaluationTests . Spr 9  7  5  1  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( helper )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e ;", "e    =    parser . parseExpression (  \"  +  + bd \"  )  ;", "assertTrue ( new   BigDecimal (  \"  2  \"  )  . equals ( helper . bd )  )  ;", "BigDecimal   return _ bd    =    e . getValue ( ctx ,    BigDecimal . class )  ;", "assertTrue ( new   BigDecimal (  \"  3  \"  )  . equals ( return _ bd )  )  ;", "assertTrue ( new   BigDecimal (  \"  3  \"  )  . equals ( helper . bd )  )  ;", "e    =    parser . parseExpression (  \"  +  + ddd \"  )  ;", "assertEquals (  2  .  0  ,    helper . ddd ,     0  .  0  )  ;", "double   return _ ddd    =    e . getValue ( ctx ,    Double . TYPE )  ;", "assertEquals (  3  .  0  ,    return _ ddd ,     0  .  0  )  ;", "assertEquals (  3  .  0  ,    helper . ddd ,     0  .  0  )  ;", "e    =    parser . parseExpression (  \"  +  + fff \"  )  ;", "assertEquals (  3  .  0 F ,    helper . fff ,     0  .  0  )  ;", "float   return _ fff    =    e . getValue ( ctx ,    Float . TYPE )  ;", "assertEquals (  4  .  0 F ,    return _ fff ,     0  .  0  )  ;", "assertEquals (  4  .  0 F ,    helper . fff ,     0  .  0  )  ;", "e    =    parser . parseExpression (  \"  +  + lll \"  )  ;", "assertEquals (  6  6  6  6  6 L ,    helper . lll )  ;", "long   return _ lll    =    e . getValue ( ctx ,    Long . TYPE )  ;", "assertEquals (  6  6  6  6  7 L ,    return _ lll )  ;", "assertEquals (  6  6  6  6  7 L ,    helper . lll )  ;", "e    =    parser . parseExpression (  \"  +  + iii \"  )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "int   return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  3  ,    return _ iii )  ;", "assertEquals (  4  3  ,    helper . iii )  ;", "return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  4  ,    return _ iii )  ;", "assertEquals (  4  4  ,    helper . iii )  ;", "e    =    parser . parseExpression (  \"  +  + sss \"  )  ;", "assertEquals (  1  5  ,    helper . sss )  ;", "int   return _ sss    =     (  ( Integer )     ( e . getValue ( ctx )  )  )  ;", "assertEquals (  1  6  ,    return _ sss )  ;", "assertEquals (  1  6  ,    helper . sss )  ;", "}", "METHOD_END"], "methodName": ["increment02prefix"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . Spr 9  7  5  1    helper    =    new   EvaluationTests . Spr 9  7  5  1  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( helper )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e ;", "e    =    parser . parseExpression (  \" m (  )  +  +  \"  )  ;", "try    {", "e . getValue ( ctx ,    Double . TYPE )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . OPERAND _ NOT _ INCREMENTABLE ,    see . getMessageCode (  )  )  ;", "}", "e    =    parser . parseExpression (  \"  +  + m (  )  \"  )  ;", "try    {", "e . getValue ( ctx ,    Double . TYPE )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . OPERAND _ NOT _ INCREMENTABLE ,    see . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["increment03"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "Integer   i    =     4  2  ;", "StandardContext   ctx    =    new   StandardContext ( i )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "try    {", "Expression   e    =    parser . parseExpression (  \"  +  +  1  \"  )  ;", "e . getValue ( ctx ,    Integer . class )  ;", "fail (  )  ;", "}    catch    ( SpelException   see )     {", "assertEquals ( SpelMessage . NOT _ ASSIGNABLE ,    see . getMessageCode (  )  )  ;", "}", "try    {", "Expression   e    =    parser . parseExpression (  \"  1  +  +  \"  )  ;", "e . getValue ( ctx ,    Integer . class )  ;", "fail (  )  ;", "}    catch    ( SpelException   see )     {", "assertEquals ( SpelMessage . NOT _ ASSIGNABLE ,    see . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["increment04"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . Spr 9  7  5  1    helper    =    new   EvaluationTests . Spr 9  7  5  1  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( helper )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e ;", "expectFailNotAssignable ( parser ,    ctx ,     \" true +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  - false \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \" true = false \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  1  2  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  1  2  2  2  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  1  2  =  1  6  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  1  .  0 d +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  3  .  4 d \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  1  .  0 d =  3  .  2 d \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \" null +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  - null \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \" null = null \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \" null =  1  2  3  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ( true    &  &    false )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  ( false   AND   true )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ( true    &  &    false )  =  ( false    &  &    true )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  /  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  /  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  /  2  )  =  (  3  /  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  =  =  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  =  =  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  =  =  2  )  =  (  3  =  =  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  >  =  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  >  =  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  >  =  2  )  =  (  3  >  =  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  >  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  >  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  >  2  )  =  (  3  >  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  <  =  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  <  =  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  <  =  2  )  =  (  3  <  =  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  <  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  <  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  <  2  )  =  (  3  <  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  -  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  -  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  -  2  )  =  (  3  -  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  %  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  %  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  %  2  )  =  (  3  %  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  *  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  *  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  *  2  )  =  (  3  *  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  !  =  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  !  =  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  !  =  2  )  =  (  3  !  =  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ( true    |  |    false )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  ( false   OR   true )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ( true    |  |    false )  =  ( false   OR   true )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3  +  4  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  2  +  5  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  +  2  )  =  (  3  +  4  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  1  .  0 d +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  2  .  0 d \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  .  0 d )  =  (  3  .  0 d )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  1  .  0 f +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  2  .  0 f \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  1  .  0 f )  =  (  3  .  0 f )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ' abc '  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  ' def '  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ' abc '  =  ' def '  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ( true ? true : false )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  ( true ? true : false )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ( true ? true : false )  =  ( true ? true : false )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \" T ( String )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  - T ( Integer )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \" T ( String )  = T ( Integer )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  3    between    {  1  ,  5  }  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  3    between    {  1  ,  5  }  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  3    between    {  1  ,  5  }  )  =  (  3    between    {  1  ,  5  }  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ( type   instanceof   T ( String )  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  ( type   instanceof   T ( String )  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ( type   instanceof   T ( String )  )  =  ( type   instanceof   T ( String )  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ( true ?  : false )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  ( true ?  : false )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ( true ?  : false )  =  ( true ?  : false )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ( iii +  +  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  +  + iii )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ( iii +  +  )  =  (  +  + iii )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ( iii -  -  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  -  - iii )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ( iii -  -  )  =  (  -  - iii )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  ! true )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  ! false )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  ! true )  =  (  ! false )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ( iii ^  2  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  ( iii ^  2  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ( iii ^  2  )  =  ( iii ^  3  )  \"  )  ;", "e    =    parser . parseExpression (  \" iii = iii +  +  \"  )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "int   return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "assertEquals (  4  2  ,    return _ iii )  ;", "e    =    parser . parseExpression (  \" iii +  +  \"  )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    return _ iii )  ;", "assertEquals (  4  3  ,    helper . iii )  ;", "e    =    parser . parseExpression (  \"  -  - iii \"  )  ;", "assertEquals (  4  3  ,    helper . iii )  ;", "return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    return _ iii )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "e    =    parser . parseExpression (  \" iii =  9  9  \"  )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "return _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  9  9  ,    return _ iii )  ;", "assertEquals (  9  9  ,    helper . iii )  ;", "e    =    parser . parseExpression (  \" foo . iii +  +  \"  )  ;", "assertEquals (  9  9  ,    helper . foo . iii )  ;", "int   return _ foo _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  9  9  ,    return _ foo _ iii )  ;", "assertEquals (  1  0  0  ,    helper . foo . iii )  ;", "e    =    parser . parseExpression (  \"  -  - foo . iii \"  )  ;", "assertEquals (  1  0  0  ,    helper . foo . iii )  ;", "return _ foo _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  9  9  ,    return _ foo _ iii )  ;", "assertEquals (  9  9  ,    helper . foo . iii )  ;", "e    =    parser . parseExpression (  \" foo . iii =  9  9  9  \"  )  ;", "assertEquals (  9  9  ,    helper . foo . iii )  ;", "return _ foo _ iii    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  9  9  9  ,    return _ foo _ iii )  ;", "assertEquals (  9  9  9  ,    helper . foo . iii )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  ( new   String (  ' abc '  )  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  ( new   String (  ' abc '  )  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  ( new   String (  ' abc '  )  )  =  ( new   String (  ' abc '  )  )  \"  )  ;", "expectFailNotIncrementable ( parser ,    ctx ,     \" m (  )  +  +  \"  )  ;", "expectFailNotDecrementable ( parser ,    ctx ,     \"  -  - m (  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \" m (  )  = m (  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  ' abc '    matches    '  ^ a .  .  '  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  ' abc '    matches    '  ^ a .  .  '  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  ' abc '    matches    '  ^ a .  .  '  )  =  (  ' abc '    matches    '  ^ a .  .  '  )  \"  )  ;", "ctx . registerFunction (  \" isEven \"  ,    EvaluationTests . Spr 9  7  5  1  . class . getDeclaredMethod (  \" isEven \"  ,    Integer . TYPE )  )  ;", "expectFailNotIncrementable ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  .  ?  [  # isEven (  # this )  ]  )  +  +  \"  )  ;", "expectFailNotDecrementable ( parser ,    ctx ,     \"  -  -  (  {  1  ,  2  ,  3  }  .  ?  [  # isEven (  # this )  ]  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  .  ?  [  # isEven (  # this )  ]  )  =  (  {  1  ,  2  ,  3  }  .  ?  [  # isEven (  # this )  ]  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  .  ^  [  # isEven (  # this )  ]  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  {  1  ,  2  ,  3  }  .  ^  [  # isEven (  # this )  ]  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  .  ^  [  # isEven (  # this )  ]  )  =  (  {  1  ,  2  ,  3  }  .  ^  [  # isEven (  # this )  ]  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  .  $  [  # isEven (  # this )  ]  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  {  1  ,  2  ,  3  }  .  $  [  # isEven (  # this )  ]  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  .  $  [  # isEven (  # this )  ]  )  =  (  {  1  ,  2  ,  3  }  .  $  [  # isEven (  # this )  ]  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  # isEven (  3  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  # isEven (  4  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  # isEven (  3  )  =  # isEven (  5  )  \"  )  ;", "ctx . setVariable (  \" wibble \"  ,     \" hello   world \"  )  ;", "expectFailNotIncrementable ( parser ,    ctx ,     \"  # wibble +  +  \"  )  ;", "expectFailNotDecrementable ( parser ,    ctx ,     \"  -  -  # wibble \"  )  ;", "e    =    parser . parseExpression (  \"  # wibble =  # wibble +  # wibble \"  )  ;", "String   s    =    e . getValue ( ctx ,    String . class )  ;", "assertEquals (  \" hello   worldhello   world \"  ,    s )  ;", "assertEquals (  \" hello   worldhello   world \"  ,    ctx . lookupVariable (  \" wibble \"  )  )  ;", "ctx . setVariable (  \" wobble \"  ,     3  )  ;", "e    =    parser . parseExpression (  \"  # wobble +  +  \"  )  ;", "assertEquals (  3  ,     (  ( Integer )     ( ctx . lookupVariable (  \" wobble \"  )  )  )  . intValue (  )  )  ;", "int   r    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  3  ,    r )  ;", "assertEquals (  4  ,     (  ( Integer )     ( ctx . lookupVariable (  \" wobble \"  )  )  )  . intValue (  )  )  ;", "e    =    parser . parseExpression (  \"  -  -  # wobble \"  )  ;", "assertEquals (  4  ,     (  ( Integer )     ( ctx . lookupVariable (  \" wobble \"  )  )  )  . intValue (  )  )  ;", "r    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  3  ,    r )  ;", "assertEquals (  3  ,     (  ( Integer )     ( ctx . lookupVariable (  \" wobble \"  )  )  )  . intValue (  )  )  ;", "e    =    parser . parseExpression (  \"  # wobble =  3  4  \"  )  ;", "assertEquals (  3  ,     (  ( Integer )     ( ctx . lookupVariable (  \" wobble \"  )  )  )  . intValue (  )  )  ;", "r    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  3  4  ,    r )  ;", "assertEquals (  3  4  ,     (  ( Integer )     ( ctx . lookupVariable (  \" wobble \"  )  )  )  . intValue (  )  )  ;", "expectFailNotIncrementable ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  .  !  [  # isEven (  # this )  ]  )  +  +  \"  )  ;", "expectFailNotDecrementable ( parser ,    ctx ,     \"  -  -  (  {  1  ,  2  ,  3  }  .  !  [  # isEven (  # this )  ]  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  .  !  [  # isEven (  # this )  ]  )  =  (  {  1  ,  2  ,  3  }  .  !  [  # isEven (  # this )  ]  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  {  1  ,  2  ,  3  }  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  {  1  ,  2  ,  3  }  )  =  (  {  1  ,  2  ,  3  }  )  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  (  {  ' a '  :  1  ,  ' b '  :  2  ,  ' c '  :  3  }  )  +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  (  {  ' a '  :  1  ,  ' b '  :  2  ,  ' c '  :  3  }  )  \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  (  {  ' a '  :  1  ,  ' b '  :  2  ,  ' c '  :  3  }  )  =  (  {  ' a '  :  1  ,  ' b '  :  2  ,  ' c '  :  3  }  )  \"  )  ;", "ctx . setBeanResolver ( new   EvaluationTests . MyBeanResolver (  )  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  @ foo +  +  \"  )  ;", "expectFailNotAssignable ( parser ,    ctx ,     \"  -  -  @ foo \"  )  ;", "expectFailSetValueNotSupported ( parser ,    ctx ,     \"  @ foo =  @ bar \"  )  ;", "helper . iii    =     4  2  ;", "e    =    parser . parseExpression (  \" iii +  +  \"  )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "r    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    r )  ;", "assertEquals (  4  3  ,    helper . iii )  ;", "e    =    parser . parseExpression (  \"  -  - iii \"  )  ;", "assertEquals (  4  3  ,    helper . iii )  ;", "r    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    r )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "e    =    parser . parseExpression (  \" iii =  1  0  0  \"  )  ;", "assertEquals (  4  2  ,    helper . iii )  ;", "r    =    e . getValue ( ctx ,    Integer . TYPE )  ;", "assertEquals (  1  0  0  ,    r )  ;", "assertEquals (  1  0  0  ,    helper . iii )  ;", "}", "METHOD_END"], "methodName": ["incrementAllNodeTypes"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "TestPerson   person    =    new   TestPerson (  )  ;", "Context   context    =    new   StandardContext ( person )  ;", "SpelParserConfiguration   config    =    new   SpelParserConfiguration ( true ,    true )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( config )  ;", "Expression   e    =    parser . parseExpression (  \" name \"  )  ;", "e . setValue ( context ,     \" Oleg \"  )  ;", "assertEquals (  \" Oleg \"  ,    person . getName (  )  )  ;", "e    =    parser . parseExpression (  \" address . street \"  )  ;", "e . setValue ( context ,     \"  1  2  3    High   St \"  )  ;", "assertEquals (  \"  1  2  3    High   St \"  ,    person . getAddress (  )  . getStreet (  )  )  ;", "e    =    parser . parseExpression (  \" address . crossStreets [  0  ]  \"  )  ;", "e . setValue ( context ,     \" Blah \"  )  ;", "assertEquals (  \" Blah \"  ,    person . getAddress (  )  . getCrossStreets (  )  . get (  0  )  )  ;", "e    =    parser . parseExpression (  \" address . crossStreets [  3  ]  \"  )  ;", "e . setValue ( context ,     \" Wibble \"  )  ;", "assertEquals (  \" Blah \"  ,    person . getAddress (  )  . getCrossStreets (  )  . get (  0  )  )  ;", "assertEquals (  \" Wibble \"  ,    person . getAddress (  )  . getCrossStreets (  )  . get (  3  )  )  ;", "}", "METHOD_END"], "methodName": ["initializingCollectionElementsOnWrite"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . TestClass   instance    =    new   EvaluationTests . TestClass (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( instance )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true ,     3  )  )  ;", "Expression   e    =    parser . parseExpression (  \" foo [  2  ]  \"  )  ;", "e . setValue ( ctx ,     \"  2  \"  )  ;", "assertThat ( instance . getFoo (  )  . size (  )  ,    equalTo (  3  )  )  ;", "e    =    parser . parseExpression (  \" foo [  3  ]  \"  )  ;", "try    {", "e . setValue ( ctx ,     \"  3  \"  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . UNABLE _ TO _ GROW _ COLLECTION ,    see . getMessageCode (  )  )  ;", "assertThat ( instance . getFoo (  )  . size (  )  ,    equalTo (  3  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["limitCollectionGrowing"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" placeOfBirth . doubleIt ( inventions . length )  \"  ,     1  8  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["methodCallWithRootReferenceThroughParameter"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" placeOfBirth . doubleIt (  # reverseInt ( inventions . length ,  2  ,  3  )  [  2  ]  )  \"  ,     1  8  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["methodCallWithRootReferenceThroughParameterThatIsAFunctionCall"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   e    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # a    <     # b \"  )  )  )  ;", "Context   ctx    =    new   StandardContext (  )  ;", "ctx . setVariable (  \" a \"  ,     (  ( short )     (  3  )  )  )  ;", "ctx . setVariable (  \" b \"  ,     (  ( short )     (  6  )  )  )  ;", "assertTrue ( e . getValue ( ctx ,    Boolean . class )  )  ;", "ctx . setVariable (  \" b \"  ,     (  ( byte )     (  6  )  )  )  ;", "assertTrue ( e . getValue ( ctx ,    Boolean . class )  )  ;", "ctx . setVariable (  \" a \"  ,     (  ( byte )     (  9  )  )  )  ;", "ctx . setVariable (  \" b \"  ,     (  ( byte )     (  6  )  )  )  ;", "assertFalse ( e . getValue ( ctx ,    Boolean . class )  )  ;", "ctx . setVariable (  \" a \"  ,     1  0 L )  ;", "ctx . setVariable (  \" b \"  ,     (  ( short )     (  3  0  )  )  )  ;", "assertTrue ( e . getValue ( ctx ,    Boolean . class )  )  ;", "ctx . setVariable (  \" a \"  ,     (  ( byte )     (  3  )  )  )  ;", "ctx . setVariable (  \" b \"  ,     (  ( short )     (  3  0  )  )  )  ;", "assertTrue ( e . getValue ( ctx ,    Boolean . class )  )  ;", "ctx . setVariable (  \" a \"  ,     (  ( byte )     (  3  )  )  )  ;", "ctx . setVariable (  \" b \"  ,     3  0 L )  ;", "assertTrue ( e . getValue ( ctx ,    Boolean . class )  )  ;", "ctx . setVariable (  \" a \"  ,     (  ( byte )     (  3  )  )  )  ;", "ctx . setVariable (  \" b \"  ,     3  0  .  0 F )  ;", "assertTrue ( e . getValue ( ctx ,    Boolean . class )  )  ;", "ctx . setVariable (  \" a \"  ,    new   BigInteger (  \"  1  0  \"  )  )  ;", "ctx . setVariable (  \" b \"  ,    new   BigInteger (  \"  2  0  \"  )  )  ;", "assertTrue ( e . getValue ( ctx ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["operatorVariants"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "int   twentyFour    =    parser . parseExpression (  \"  2  .  0     *     3 e 0     *     4  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  2  4  ,    twentyFour )  ;", "double   one    =    parser . parseExpression (  \"  8  .  0     /     5 e 0     %     2  \"  )  . getValue ( Double . class )  ;", "assertEquals (  1  .  6  ,    one ,     0  .  0  )  ;", "int   o    =    parser . parseExpression (  \"  8  .  0     /     5 e 0     %     2  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  1  ,    o )  ;", "int   sixteen    =    parser . parseExpression (  \"  -  2     ^     4  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  1  6  ,    sixteen )  ;", "int   minusFortyFive    =    parser . parseExpression (  \"  1  +  2  -  3  *  8  ^  2  /  2  /  2  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  (  -  4  5  )  ,    minusFortyFive )  ;", "}", "METHOD_END"], "methodName": ["testAdvancedNumerics"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "parser . parseExpression (  \" null   and   true \"  )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["testAndWithNullValueOnLeft"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "parser . parseExpression (  \" true   and   null \"  )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["testAndWithNullValueOnRight"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # var 1  =  ' value 1  '  \"  ,     \" value 1  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testAssignmentToVariables01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "boolean   trueValue    =    parser . parseExpression (  \" T ( Date )     =  =    Birthdate . Class \"  )  . getValue ( context ,    Boolean . class )  ;", "assertTrue ( trueValue )  ;", "}", "METHOD_END"], "methodName": ["testComparison"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String (  ' hello '  )  \"  ,     \" hello \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInvocation01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String (  ' foobar '  )  \"  ,     \" foobar \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInvocation05"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   e    =     (  ( SpelExpression )     ( parser . parseExpression (  \" new   String (  ' wibble '  )  \"  )  )  )  ;", "String   newString    =    e . getValue ( String . class )  ;", "assertEquals (  \" wibble \"  ,    newString )  ;", "newString    =    e . getValue ( String . class )  ;", "assertEquals (  \" wibble \"  ,    newString )  ;", "assertFalse ( e . isWritable ( new   StandardContext (  )  )  )  ;", "assertEquals (  \" new   String (  ' wibble '  )  \"  ,    e . toStringAST (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInvocation06"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   e    =    parser . parseExpression (  \" list [  0  ]  \"  )  ;", ". TestClass   testClass    =    new    . TestClass (  )  ;", "Object   o    =    e . getValue ( new   StandardEvaluationContext ( testClass )  )  ;", "assertEquals (  \"  \"  ,    o )  ;", "o    =    parser . parseExpression (  \" list [  3  ]  \"  )  . getValue ( new   StandardEvaluationContext ( testClass )  )  ;", "assertEquals (  \"  \"  ,    o )  ;", "assertEquals (  4  ,    testClass . list . size (  )  )  ;", "try    {", "o    =    parser . parseExpression (  \" list 2  [  3  ]  \"  )  . getValue ( new   StandardEvaluationContext ( testClass )  )  ;", "fail (  )  ;", "}    catch    ( EvaluationException   ee )     {", "ee . printStackTrace (  )  ;", "}", "o    =    parser . parseExpression (  \" foo [  3  ]  \"  )  . getValue ( new   StandardEvaluationContext ( testClass )  )  ;", "assertEquals (  \"  \"  ,    o )  ;", "assertEquals (  4  ,    testClass . getFoo (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCreateListsOnAttemptToIndexNull01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . TestClass   testClass    =    new   EvaluationTests . TestClass (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( testClass )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Object   o    =    parser . parseExpression (  \" map [  ' a '  ]  \"  )  . getValue ( ctx )  ;", "assertNull ( o )  ;", "o    =    parser . parseExpression (  \" map \"  )  . getValue ( ctx )  ;", "assertNotNull ( o )  ;", "o    =    parser . parseExpression (  \" map 2  [  ' a '  ]  \"  )  . getValue ( ctx )  ;", "}", "METHOD_END"], "methodName": ["testCreateMapsOnAttemptToIndexNull01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationTests . TestClass   testClass    =    new   EvaluationTests . TestClass (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext ( testClass )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Object   o    =    parser . parseExpression (  \" wibble . bar \"  )  . getValue ( ctx )  ;", "assertEquals (  \" hello \"  ,    o )  ;", "o    =    parser . parseExpression (  \" wibble \"  )  . getValue ( ctx )  ;", "assertNotNull ( o )  ;", "o    =    parser . parseExpression (  \" wibble 2  . bar \"  )  . getValue ( ctx )  ;", "}", "METHOD_END"], "methodName": ["testCreateObjectsOnAttemptToReferenceNull"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' Andy '  ?  :  ' Dave '  \"  ,     \" Andy \"  ,    String . class )  ;", "evaluate (  \" null ?  :  ' Dave '  \"  ,     \" Dave \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testElvis01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # reverseInt (  1  ,  2  ,  3  )  \"  ,     \" int [  3  ]  {  3  ,  2  ,  1  }  \"  ,    int [  ]  . class )  ;", "}", "METHOD_END"], "methodName": ["testFunctionAccess01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # reverseString (  ' hello '  )  \"  ,     \" olleh \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testFunctionAccess02"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' christian '  [  8  ]  \"  ,     \" n \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testIndexer03"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" new   Inventor (  )  . inventions [  1  ]  \"  ,    SpelMessage . CANNOT _ INDEX _ INTO _ NULL _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testIndexerError"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "String   pattern    =     \"  ^  (  ?  =  [ a - z 0  -  9  -  ]  {  1  ,  4  7  }  )  (  [ a - z 0  -  9  ]  +  [  -  ]  {  0  ,  1  }  )  {  1  ,  4  7  }  [ a - z 0  -  9  ]  {  1  }  $  \"  ;", "String       =     (  \"  \\  ' abcde - fghijklmn - o 4  2 pasdfasdfasdf . qrstuvwxyz 1  0 x . xx . yyy . zasdfasfd \\  '    matches    \\  '  \"     +    pattern )     +     \"  \\  '  \"  ;", "Expression   expr    =    parser . parseExpression (  )  ;", "try    {", "expr . getValue (  )  ;", "fail (  \" Should   have   exceeded   threshold \"  )  ;", "}    catch    ( EvaluationException   ee )     {", "SpelEvaluationException   see    =     (  ( SpelEvaluationException )     ( ee )  )  ;", "assertEquals ( SpelMessage . FLAWED _ PATTERN ,    see . getMessageCode (  )  )  ;", "assertTrue (  (  ( see . getCause (  )  )    instanceof   IllegalStateException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMatchesWithPatternAccessThreshold"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" echo (  1  2  )  \"  ,     \"  1  2  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testMethods01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" echo ( name )  \"  ,     \" Nikola   Tesla \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testMethods02"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" true   and    5  >  3  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testMixingOperators01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndAskForReturnType (  \"  3  *  4  +  5  \"  ,     1  7  ,    Integer . class )  ;", "evaluateAndAskForReturnType (  \"  3  *  4  +  5  \"  ,     1  7 L ,    Long . class )  ;", "evaluateAndAskForReturnType (  \"  6  5  \"  ,     ' A '  ,    Character . class )  ;", "evaluateAndAskForReturnType (  \"  3  *  4  +  5  \"  ,     (  ( short )     (  1  7  )  )  ,    Short . class )  ;", "evaluateAndAskForReturnType (  \"  3  *  4  +  5  \"  ,     \"  1  7  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testNumbers01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "parser . parseExpression (  \" null   or   false \"  )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["testOrWithNullValueOnLeft"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "parser . parseExpression (  \" false   or   null \"  )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["testOrWithNullValueOnRight"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" placeOfBirth . city \"  ,     \" SmilJan \"  ,    String . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["testPropertiesNested01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" placeOfBirth . doubleIt (  1  2  )  \"  ,     \"  2  4  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testPropertiesNested02"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   SpelEParser (  )  . parseRaw (  \" placeOfBirth .  2  3  \"  )  ;", "fail (  )  ;", "}    catch    ( SpelParseException   spe )     {", "assertEquals ( SpelMessage . UNEXPECTED _ DATA _ AFTER _ DOT ,    spe . getMessageCode (  )  )  ;", "assertEquals (  \"  2  3  \"  ,    spe . getInserts (  )  [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPropertiesNested03"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" name \"  ,     \" Nikola   Tesla \"  ,    String . class ,    false )  ;", "evaluateAndCheckError (  \" madeup \"  ,    SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ READABLE ,     0  ,     \" madeup \"  ,     \" testresources . Inventor \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyField01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  _ name \"  ,     \" Nikola   Tesla \"  ,    String . class )  ;", "evaluate (  \"  _ name _  \"  ,     \" Nikola   Tesla \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testPropertyField02_SPR7100"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     >  =     6  \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorGE01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     >  =     3  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorGE02"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     >     6  \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorGT01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     <  =     6  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorLE01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     <     6  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorLT01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' xyz '    instanceof   T ( int )  \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsInstanceof01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" null   instanceof   T ( String )  \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsInstanceof04"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" null   instanceof   T ( Integer )  \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsInstanceof05"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  ' A '    instanceof   null \"  ,    SpelMessage . INSTANCEOF _ OPERATOR _ NEEDS _ CLASS _ OPERAND ,     1  5  ,     \" null \"  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsInstanceof06"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  \\  '  5  .  0  0  6  7  \\  '    matches    \\  '  ^  -  ?  \\  \\ d +  (  \\  \\  .  \\  \\ d {  2  }  )  ?  $  \\  '  \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsMatches01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  \\  '  5  .  0  0  \\  '    matches    \\  '  ^  -  ?  \\  \\ d +  (  \\  \\  .  \\  \\ d {  2  }  )  ?  $  \\  '  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsMatches02"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" null   matches    '  ^  .  *  $  '  \"  ,    SpelMessage . INVALID _ FIRST _ OPERAND _ FOR _ MATCHES _ OPERATOR ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsMatches03"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  ' abc '    matches   null \"  ,    SpelMessage . INVALID _ SECOND _ OPERAND _ FOR _ MATCHES _ OPERATOR ,     1  4  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsMatches04"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  2  7    matches    '  ^  .  *  2  .  *  $  '  \"  ,    true ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsMatches05"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "try    {", "assertFalse ( parser . parseExpression (  \" T ( List )  !  = null \"  )  . getValue ( context ,    Boolean . class )  )  ;", "fail (  \" should   have   failed   to   find   List \"  )  ;", "}    catch    ( EvaluationException   ee )     {", "}", "(  ( StandardTypeLocator )     ( context . getTypeLocator (  )  )  )  . registerImport (  \" util \"  )  ;", "assertTrue ( parser . parseExpression (  \" T ( List )  !  = null \"  )  . getValue ( context ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testResolvingList"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    stringClass    =    parser . parseExpression (  \" T ( String )  \"  )  . getValue ( Class . class )  ;", "assertEquals ( String . class ,    stringClass )  ;", "}", "METHOD_END"], "methodName": ["testResolvingString"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   SpelEParser (  )  . parseE (  \" placeOfBirth . foo .  \"  )  ;", "fail (  \" Should   have   failed   to   parse \"  )  ;", "}    catch    ( SpelParseException   ex )     {", "assertEquals ( SpelMessage . OOD ,    ex . getMessageCode (  )  )  ;", "assertEquals (  1  6  ,    ex . getPosition (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRogueTrailingDotCausesNPE_SPR6866"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" null ?  . null ?  . null \"  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testSafeNavigation"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" T ( Color )  . green . getRGB (  )  !  =  0  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testStaticRef02"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndAskForReturnType (  \" getPlaceOfBirth (  )  . getCity (  )  \"  ,     \" SmilJan \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testStringType"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  2  >  4  ?  1  :  2  \"  ,     2  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testTernaryOperator01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' abc '  =  =  ' abc '  ?  1  :  2  \"  ,     1  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testTernaryOperator02"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  ' hello '  ?  1  :  2  \"  ,    SpelMessage . TYPE _ CONVERSION _ ERROR )  ;", "}", "METHOD_END"], "methodName": ["testTernaryOperator03"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "Expression   e    =    parser . parseExpression (  \"  1  >  2  ?  3  :  4  \"  )  ;", "assertFalse ( e . isWritable ( context )  )  ;", "}", "METHOD_END"], "methodName": ["testTernaryOperator04"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  1  >  2  ?  # var =  4  :  # var =  5  \"  ,     5  ,    Integer . class )  ;", "evaluate (  \"  3  ?  :  # var =  5  \"  ,     3  ,    Integer . class )  ;", "evaluate (  \" null ?  :  # var =  5  \"  ,     5  ,    Integer . class )  ;", "evaluate (  \"  2  >  4  ?  (  3  >  2  ? true : false )  :  (  5  <  3  ? true : false )  \"  ,    false ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testTernaryOperator05"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "parser . parseExpression (  \" null    ?     0     :     1  \"  )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["testTernaryOperatorWithNullValue"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" T ( String )  \"  ,     \" class   String \"  ,    Class . class )  ;", "}", "METHOD_END"], "methodName": ["testTypeReferences01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" T ( String )  \"  ,     \" class   String \"  ,    Class . class )  ;", "}", "METHOD_END"], "methodName": ["testTypeReferences02"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   e    =     (  ( SpelExpression )     ( parser . parseExpression (  \" T ( String )  \"  )  )  )  ;", "assertFalse ( e . isWritable ( new   StandardContext (  )  )  )  ;", "assertEquals (  \" T ( String )  \"  ,    e . toStringAST (  )  )  ;", "assertEquals ( String . class ,    e . getValue ( Class . class )  )  ;", "assertEquals (  \" T ( String )  \"  ,    e . toStringAST (  )  )  ;", "assertEquals ( String . class ,    e . getValue ( Class . class )  )  ;", "}", "METHOD_END"], "methodName": ["testTypeReferencesAndQualifiedIdentifierCaching"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" T ( int )  \"  ,     \" int \"  ,    Class . class )  ;", "evaluate (  \" T ( byte )  \"  ,     \" byte \"  ,    Class . class )  ;", "evaluate (  \" T ( char )  \"  ,     \" char \"  ,    Class . class )  ;", "evaluate (  \" T ( boolean )  \"  ,     \" boolean \"  ,    Class . class )  ;", "evaluate (  \" T ( long )  \"  ,     \" long \"  ,    Class . class )  ;", "evaluate (  \" T ( short )  \"  ,     \" short \"  ,    Class . class )  ;", "evaluate (  \" T ( double )  \"  ,     \" double \"  ,    Class . class )  ;", "evaluate (  \" T ( float )  \"  ,     \" float \"  ,    Class . class )  ;", "}", "METHOD_END"], "methodName": ["testTypeReferencesPrimitive"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  -  5  \"  ,     \"  -  5  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testUnaryMinus01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ! true \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testUnaryNot01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ! false \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testUnaryNot02"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "parser . parseExpression (  \"  ! null \"  )  . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["testUnaryNotWithNullValue"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  +  5  \"  ,     \"  5  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testUnaryPlus01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # answer \"  ,     \"  4  2  \"  ,    Integer . class ,    true )  ;", "}", "METHOD_END"], "methodName": ["testVariableAccess01"], "fileName": "org.springframework.expression.spel.EvaluationTests"}, {"methodBody": ["METHOD_START", "{", "return   s    +    s ;", "}", "METHOD_END"], "methodName": ["repeat"], "fileName": "org.springframework.expression.spel.ExpressionLanguageScenarioTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . addPropertyAccessor ( new    . FruitColourAccessor (  )  )  ;", "Expression   expr    =    parser . parseRaw (  \" orange \"  )  ;", "Object   value    =    expr . getValue ( ctx )  ;", "assertEquals ( Color . orange ,    value )  ;", "try    {", "expr . setValue ( ctx ,    Color . blue )  ;", "fail (  \" Should   not   be   allowed   to   set   oranges   to   be   blue    !  \"  )  ;", "}    catch    ( SpelEvaluationException   ee )     {", "assertEquals ( SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ WRITABLE _ ON _ NULL ,    ee . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testScenario_AddingYourOwnPropertyResolvers_1"], "fileName": "org.springframework.expression.spel.ExpressionLanguageScenarioTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . addPropertyAccessor ( new    . VegetableColourAccessor (  )  )  ;", "Expression   expr    =    parser . parseRaw (  \" pea \"  )  ;", "Object   value    =    expr . getValue ( ctx )  ;", "assertEquals ( Color . green ,    value )  ;", "try    {", "expr . setValue ( ctx ,    Color . blue )  ;", "fail (  \" Should   not   be   allowed   to   set   peas   to   be   blue    !  \"  )  ;", "}    catch    ( SpelEvaluationException   ee )     {", "assertEquals ( SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ WRITABLE _ ON _ NULL ,    ee . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testScenario_AddingYourOwnPropertyResolvers_2"], "fileName": "org.springframework.expression.spel.ExpressionLanguageScenarioTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setVariable (  \" favouriteColour \"  ,     \" blue \"  )  ;", "List < Integer >    primes    =    new   ArrayList <  >  (  )  ;", "primes . addAll ( Arrays . asList (  2  ,     3  ,     5  ,     7  ,     1  1  ,     1  3  ,     1  7  )  )  ;", "ctx . setVariable (  \" primes \"  ,    primes )  ;", "Expression   expr    =    parser . parseRaw (  \"  # favouriteColour \"  )  ;", "Object   value    =    expr . getValue ( ctx )  ;", "assertEquals (  \" blue \"  ,    value )  ;", "expr    =    parser . parseRaw (  \"  # primes . get (  1  )  \"  )  ;", "value    =    expr . getValue ( ctx )  ;", "assertEquals (  3  ,    value )  ;", "expr    =    parser . parseRaw (  \"  # primes .  ?  [  # this >  1  0  ]  \"  )  ;", "value    =    expr . getValue ( ctx )  ;", "assertEquals (  \"  [  1  1  ,     1  3  ,     1  7  ]  \"  ,    value . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testScenario_DefiningVariablesThatWillBeAccessibleInExpressions"], "fileName": "org.springframework.expression.spel.ExpressionLanguageScenarioTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . registerFunction (  \" repeat \"  ,     . class . getDeclaredMethod (  \" repeat \"  ,    String . class )  )  ;", "Expression   expr    =    parser . parseRaw (  \"  # repeat (  ' hello '  )  \"  )  ;", "Object   value    =    expr . getValue ( ctx )  ;", "assertEquals (  \" hellohello \"  ,    value )  ;", "}    catch    ( EvaluationException   ee )     {", "ee . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( ee . getMessage (  )  )  )  )  ;", "}    catch    ( ParseException   pe )     {", "pe . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( pe . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testScenario_RegisteringJavaMethodsAsFunctionsAndCallingThem"], "fileName": "org.springframework.expression.spel.ExpressionLanguageScenarioTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", ". TestClass   tc    =    new    . TestClass (  )  ;", "tc . setProperty (  4  2  )  ;", "tc . str    =     \" wibble \"  ;", "ctx . setRootObject ( tc )  ;", "Expression   expr    =    parser . parseRaw (  \" str \"  )  ;", "Object   value    =    expr . getValue ( ctx )  ;", "assertEquals (  \" wibble \"  ,    value )  ;", "expr    =    parser . parseRaw (  \" str \"  )  ;", "expr . setValue ( ctx ,     \" wobble \"  )  ;", "expr    =    parser . parseRaw (  \" str \"  )  ;", "value    =    expr . getValue ( ctx )  ;", "assertEquals (  \" wobble \"  ,    value )  ;", "expr    =    parser . parseRaw (  \" str =  ' wabble '  \"  )  ;", "value    =    expr . getValue ( ctx )  ;", "expr    =    parser . parseRaw (  \" str \"  )  ;", "value    =    expr . getValue ( ctx )  ;", "assertEquals (  \" wabble \"  ,    value )  ;", "expr    =    parser . parseRaw (  \" property \"  )  ;", "value    =    expr . getValue ( ctx )  ;", "assertEquals (  4  2  ,    value )  ;", "expr    =    parser . parseRaw (  \" property =  4  \"  )  ;", "value    =    expr . getValue ( ctx )  ;", "expr    =    parser . parseRaw (  \" property \"  )  ;", "value    =    expr . getValue ( ctx )  ;", "assertEquals (  4  ,    value )  ;", "}", "METHOD_END"], "methodName": ["testScenario_UsingADifferentRootContextObject"], "fileName": "org.springframework.expression.spel.ExpressionLanguageScenarioTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "SpelParser   parser    =    new   SpelParser (  )  ;", "expr    =    parser . parseRaw (  \" new   String (  ' hello   world '  )  \"  )  ;", "Object   value    =    expr . getValue (  )  ;", "value    =    expr . getValue (  )  ;", "assertEquals (  \" hello   world \"  ,    value )  ;", "assertEquals ( String . class ,    value . getClass (  )  )  ;", "}    catch    ( EvaluationException   ee )     {", "ee . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( ee . getMessage (  )  )  )  )  ;", "}    catch    ( ParseException   pe )     {", "pe . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( pe . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testScenario_UsingStandardInfrastructure"], "fileName": "org.springframework.expression.spel.ExpressionLanguageScenarioTests"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    this . relatedContext . getTypeConverter (  )  . convertValue ( value ,    TypeDescriptor . forObject ( value )  ,    targetTypeDescriptor )  ;", "if    ( result    =  =    null )     {", "throw   new   IllegalException (  (  (  \" Null   conversion   result   for   value    [  \"     +    value )     +     \"  ]  \"  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["convertValue"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "Object   val    =    value . getValue (  )  ;", "return   this . reldContext . getTypeConverter (  )  . convertValue ( val ,    TypeDescriptor . forObject ( val )  ,    targetTypeDescriptor )  ;", "}", "METHOD_END"], "methodName": ["convertValue"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "initVariableScopes (  )  . push ( new   ExpressionState . VariableScope ( Collections . emptyMap (  )  )  )  ;", "initScopeRootObjects (  )  . push ( getActiveContextObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["enterScope"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "initVariableScopes (  )  . push ( new   ExpressionState . VariableScope ( name ,    value )  )  ;", "initScopeRootObjects (  )  . push ( getActiveContextObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["enterScope"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "initVariableScopes (  )  . push ( new   ExpressionState . VariableScope ( argMap )  )  ;", "initScopeRootObjects (  )  . push ( getActiveContextObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["enterScope"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "initVariableScopes (  )  . pop (  )  ;", "initScopeRootObjects (  )  . pop (  )  ;", "}", "METHOD_END"], "methodName": ["exitScope"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "return   this . relatedContext . getTypeLocator (  )  . findType ( type )  ;", "}", "METHOD_END"], "methodName": ["findType"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( this . contextObjects )  )     {", "return   this . rootObject ;", "}", "return   this . contextObjects . element (  )  ;", "}", "METHOD_END"], "methodName": ["getActiveContextObject"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "return   this . configuration ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "return   this . relatedContext ;", "}", "METHOD_END"], "methodName": ["getEvaluationContext"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "return   this . relatedContext . getPropertyAccessors (  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyAccessors"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "return   this . rootObject ;", "}", "METHOD_END"], "methodName": ["getRootContextObject"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . isEmpty ( this . scopeRootObjects )  )     {", "return   this . rootObject ;", "}", "return   this . scopeRootObjects . element (  )  ;", "}", "METHOD_END"], "methodName": ["getScopeRootContextObject"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "return   this . relatedContext . getTypeComparator (  )  ;", "}", "METHOD_END"], "methodName": ["getTypeComparator"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "return   this . relatedContext . getTypeConverter (  )  ;", "}", "METHOD_END"], "methodName": ["getTypeConverter"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scopeRootObjects )     =  =    null )     {", "this . scopeRootObjects    =    new   ArrayDeque <  >  (  )  ;", "}", "return   this . scopeRootObjects ;", "}", "METHOD_END"], "methodName": ["initScopeRootObjects"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . variableScopes )     =  =    null )     {", "this . variableScopes    =    new   LinkedList <  >  (  )  ;", "this . variableScopes . add ( new    . VariableScope (  )  )  ;", "}", "return   this . variableScopes ;", "}", "METHOD_END"], "methodName": ["initVariableScopes"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "for    ( ExpressionState . VariableScope   scope    :    initVariableScopes (  )  )     {", "if    ( scope . definesVariable ( name )  )     {", "return   scope . lookupVariable ( name )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["lookupLocalVariable"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    this . relatedContext . lookupVariable ( name )  ;", "return   value    !  =    null    ?    new   TypedValue ( value )     :    TypedValue . NULL ;", "}", "METHOD_END"], "methodName": ["lookupVariable"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "OperatorOverloader   overloader    =    this . relatedContext . getOperatorOverloader (  )  ;", "if    ( overloader . overridesOperation ( op ,    left ,    right )  )     {", "Object   returnValue    =    overloader . operate ( op ,    left ,    right )  ;", "return   new   TypedValue ( returnValue )  ;", "} else    {", "St   leftType    =     ( left    =  =    null )     ?     \" null \"     :    left . getClass (  )  . getName (  )  ;", "St   rightType    =     ( right    =  =    null )     ?     \" null \"     :    right . getClass (  )  . getName (  )  ;", "throw   new   SpelEvaluationException ( SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES ,    op ,    leftType ,    rightType )  ;", "}", "}", "METHOD_END"], "methodName": ["operate"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . contextObjects )     =  =    null )     {", "this . contextObjects    =    new   ArrayDeque <  >  (  )  ;", "}", "try    {", "this . contextObjects . pop (  )  ;", "}    catch    ( NoSuchElementException   ex )     {", "throw   new   IllegalException (  \" Cannot   pop   active   context   object :    stack   is   empty \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["popActiveContextObject"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . contextObjects )     =  =    null )     {", "this . contextObjects    =    new   ArrayDeque <  >  (  )  ;", "}", "this . contextObjects . push ( obj )  ;", "}", "METHOD_END"], "methodName": ["pushActiveContextObject"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "initVariableScopes (  )  . element (  )  . setVariable ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setLocalVariable"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "this . relatedContext . setVariable ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["setVariable"], "fileName": "org.springframework.expression.spel.ExpressionState"}, {"methodBody": ["METHOD_START", "{", "return   TestScenarioCreator . getTestEvaluationContext (  )  ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "state    =    new    ( context )  ;", "return   state ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "assertEquals ( state . getRootContextObject (  )  . getValue (  )  ,    state . getActiveContextObject (  )  . getValue (  )  )  ;", "try    {", "state . popActiveContextObject (  )  ;", "fail (  \" stack   should   be   empty .  .  .  \"  )  ;", "}    catch    ( IllegalStateException   ese )     {", "}", "state . pushActiveContextObject ( new   TypedValue (  3  4  )  )  ;", "assertEquals (  3  4  ,    state . getActiveContextObject (  )  . getValue (  )  )  ;", "state . pushActiveContextObject ( new   TypedValue (  \" hello \"  )  )  ;", "assertEquals (  \" hello \"  ,    state . getActiveContextObject (  )  . getValue (  )  )  ;", "state . popActiveContextObject (  )  ;", "assertEquals (  3  4  ,    state . getActiveContextObject (  )  . getValue (  )  )  ;", "state . popActiveContextObject (  )  ;", "assertEquals ( state . getRootContextObject (  )  . getValue (  )  ,    state . getActiveContextObject (  )  . getValue (  )  )  ;", "state    =    new   ExpressionState ( new   StandardEvaluationContext (  )  )  ;", "assertEquals ( TypedValue . NULL ,    state . getActiveContextObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testActiveContextObject"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "assertEquals ( state . getEvaluationContext (  )  . getTypeComparator (  )  ,    state . getTypeComparator (  )  )  ;", "}", "METHOD_END"], "methodName": ["testComparator"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "state    =    new    ( context )  ;", "assertEquals ( context ,    state . getEvaluationContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstruction"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "assertEquals ( null ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "state . setLocalVariable (  \" foo \"  ,     1  2  )  ;", "assertEquals (  1  2  ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "state . enterScope ( null )  ;", "assertEquals (  1  2  ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "state . setLocalVariable (  \" foo \"  ,     \" abc \"  )  ;", "assertEquals (  \" abc \"  ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "state . exitScope (  )  ;", "assertEquals (  1  2  ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLocalVariableNestedScopes"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "Object   value    =    state . lookupLocalVariable (  \" foo \"  )  ;", "assertNull ( value )  ;", "state . setLocalVariable (  \" foo \"  ,     3  4  )  ;", "value    =    state . lookupLocalVariable (  \" foo \"  )  ;", "assertEquals (  3  4  ,    value )  ;", "state . setLocalVariable (  \" foo \"  ,    null )  ;", "value    =    state . lookupLocalVariable (  \" foo \"  )  ;", "assertEquals ( null ,    value )  ;", "}", "METHOD_END"], "methodName": ["testLocalVariables"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "TypedValue   typedValue    =    state . lookupVariable (  \" foo \"  )  ;", "assertEquals ( TypedValue . NULL ,    typedValue )  ;", "state . setLocalVariable (  \" foo \"  ,     3  4  )  ;", "typedValue    =    state . lookupVariable (  \" foo \"  )  ;", "assertEquals ( TypedValue . NULL ,    typedValue )  ;", "state . setVariable (  \" goo \"  ,     \" hello \"  )  ;", "assertNull ( state . lookupLocalVariable (  \" goo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoVariableInteference"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "try    {", "state . operate ( Operation . ADD ,     1  ,     2  )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( EvaluationException   ee )     {", "SpelEvaluationException   sEx    =     (  ( SpelEvaluationException )     ( ee )  )  ;", "assertEquals ( SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES ,    sEx . getMessageCode (  )  )  ;", "}", "try    {", "state . operate ( Operation . ADD ,    null ,    null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( EvaluationException   ee )     {", "SpelEvaluationException   sEx    =     (  ( SpelEvaluationException )     ( ee )  )  ;", "assertEquals ( SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES ,    sEx . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testOperators"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "assertNull ( state . lookupLocalVariable (  \" foo \"  )  )  ;", "state . enterScope (  \" foo \"  ,     3  4  )  ;", "assertEquals (  3  4  ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "state . enterScope ( null )  ;", "state . setLocalVariable (  \" foo \"  ,     1  2  )  ;", "assertEquals (  1  2  ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "state . exitScope (  )  ;", "assertEquals (  3  4  ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "state . exitScope (  )  ;", "assertNull ( state . lookupLocalVariable (  \" goo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPopulatedNestedScopes"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "assertNull ( state . lookupLocalVariable (  \" foo \"  )  )  ;", "assertNull ( state . lookupLocalVariable (  \" goo \"  )  )  ;", "Map < String ,    Object >    m    =    new   HashMap <  >  (  )  ;", "m . put (  \" foo \"  ,     3  4  )  ;", "m . put (  \" goo \"  ,     \" abc \"  )  ;", "state . enterScope ( m )  ;", "assertEquals (  3  4  ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "assertEquals (  \" abc \"  ,    state . lookupLocalVariable (  \" goo \"  )  )  ;", "state . enterScope ( null )  ;", "state . setLocalVariable (  \" foo \"  ,     1  2  )  ;", "assertEquals (  1  2  ,    state . lookupLocalVariable (  \" foo \"  )  )  ;", "assertEquals (  \" abc \"  ,    state . lookupLocalVariable (  \" goo \"  )  )  ;", "state . exitScope (  )  ;", "state . exitScope (  )  ;", "assertNull ( state . lookupLocalVariable (  \" foo \"  )  )  ;", "assertNull ( state . lookupLocalVariable (  \" goo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPopulatedNestedScopesMap"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "assertEquals ( state . getEvaluationContext (  )  . getPropertyAccessors (  )  ,    state . getPropertyAccessors (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyAccessors"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "assertEquals ( Inventor . class ,    state . getRootContextObject (  )  . getValue (  )  . getClass (  )  )  ;", "(  ( StandardEvaluationContext )     ( state . getEvaluationContext (  )  )  )  . setRootObject ( null )  ;", "assertEquals ( Inventor . class ,    state . getRootContextObject (  )  . getValue (  )  . getClass (  )  )  ;", "state    =    new   ExpressionState ( new   StandardEvaluationContext (  )  )  ;", "assertEquals ( TypedValue . NULL ,    state . getRootContextObject (  )  )  ;", "(  ( StandardEvaluationContext )     ( state . getEvaluationContext (  )  )  )  . setRootObject ( null )  ;", "assertEquals ( null ,    state . getRootContextObject (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRootContextObject"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   ctx    =    getContext (  )  ;", "state    =    new    ( ctx ,    new   TypedValue (  \" i   am   a   string \"  )  )  ;", "TypedValue   stateRoot    =    state . getRootContextObject (  )  ;", "assertEquals ( String . class ,    stateRoot . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \" i   am   a   string \"  ,    stateRoot . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRootObjectConstructor"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "String   s    =     (  ( String )     ( state . convertValue (  3  4  ,    TypeDescriptor . valueOf ( String . class )  )  )  )  ;", "assertEquals (  \"  3  4  \"  ,    s )  ;", "s    =     (  ( String )     ( state . convertValue ( new   TypedValue (  3  4  )  ,    TypeDescriptor . valueOf ( String . class )  )  )  )  ;", "assertEquals (  \"  3  4  \"  ,    s )  ;", "}", "METHOD_END"], "methodName": ["testTypeConversion"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "assertNotNull ( state . getEvaluationContext (  )  . getTypeLocator (  )  )  ;", "assertEquals ( Integer . class ,    state . findType (  \" Integer \"  )  )  ;", "try    {", "state . findType (  \" someMadeUpName \"  )  ;", "fail (  \" Should   have   failed   to   find   it \"  )  ;", "}    catch    ( EvaluationException   ee )     {", "SpelEvaluationException   sEx    =     (  ( SpelEvaluationException )     ( ee )  )  ;", "assertEquals ( SpelMessage . TYPE _ NOT _ FOUND ,    sEx . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTypeLocator"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   state    =    getState (  )  ;", "TypedValue   typedValue    =    state . lookupVariable (  \" foo \"  )  ;", "assertEquals ( TypedValue . NULL ,    typedValue )  ;", "state . setVariable (  \" foo \"  ,     3  4  )  ;", "typedValue    =    state . lookupVariable (  \" foo \"  )  ;", "assertEquals (  3  4  ,    typedValue . getValue (  )  )  ;", "assertEquals ( Integer . class ,    typedValue . getTypeDescriptor (  )  . getType (  )  )  ;", "state . setVariable (  \" foo \"  ,     \" abc \"  )  ;", "typedValue    =    state . lookupVariable (  \" foo \"  )  ;", "assertEquals (  \" abc \"  ,    typedValue . getValue (  )  )  ;", "assertEquals ( String . class ,    typedValue . getTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testVariables"], "fileName": "org.springframework.expression.spel.ExpressionStateTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionWithConversionTests . typeDescriptorForListOfString    =    new   TypeDescriptor ( ExpressionWithConversionTests . class . getDeclaredField (  \" listOfString \"  )  )  ;", "ExpressionWithConversionTests . typeDescriptorForListOfInteger    =    new   TypeDescriptor ( ExpressionWithConversionTests . class . getDeclaredField (  \" listOfInteger \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.expression.spel.ExpressionWithConversionTests"}, {"methodBody": ["METHOD_START", "{", "class   TestTarget    {", "@ SuppressWarnings (  \" unused \"  )", "public   int   sum ( Collection < Integer >    numbers )     {", "int   total    =     0  ;", "for    ( int   i    :    numbers )     {", "total    +  =    i ;", "}", "return   total ;", "}", "}", "StandardEvaluationContext   evaluationContext    =    new   StandardEvaluationContext (  )  ;", "TypeDescriptor   collectionType    =    new   TypeDescriptor ( new   MethodParameter ( TestTarget . class . getDeclaredMethod (  \" sum \"  ,    Collection . class )  ,     0  )  )  ;", "assertTrue ( evaluationContext . getTypeConverter (  )  . canConvert ( TypeDescriptor . valueOf ( String . class )  ,    collectionType )  )  ;", "assertEquals (  \"  [  1  ,     2  ,     3  ,     4  ]  \"  ,    evaluationContext . getTypeConverter (  )  . convertValue (  \"  1  ,  2  ,  3  ,  4  \"  ,    TypeDescriptor . valueOf ( String . class )  ,    collectionType )  . toString (  )  )  ;", "evaluationContext . setVariable (  \" target \"  ,    new   TestTarget (  )  )  ;", "int   result    =     (  ( Integer )     ( parser . parse (  \"  # target . sum (  # root )  \"  )  . getValue ( evaluationContext ,     \"  1  ,  2  ,  3  ,  4  \"  )  )  )  ;", "assertEquals (  (  \" Wrong   result :     \"     +    result )  ,     1  0  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testCoercionToCollectionOfPrimitive"], "fileName": "org.springframework.expression.spel.ExpressionWithConversionTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionWithConversionTests . TypeConvertorUsingConversionService   tcs    =    new   ExpressionWithConversionTests . TypeConvertorUsingConversionService (  )  ;", "Class <  ?  >    clazz    =    ExpressionWithConversionTests . typeDescriptorForListOfString . getElementTypeDescriptor (  )  . getType (  )  ;", "assertEquals ( String . class ,    clazz )  ;", "List <  ?  >    l    =     (  ( List <  ?  >  )     ( tcs . convertValue ( ExpressionWithConversionTests . listOfInteger ,    TypeDescriptor . forObject ( ExpressionWithConversionTests . listOfInteger )  ,    ExpressionWithConversionTests . typeDescriptorForListOfString )  )  )  ;", "assertNotNull ( l )  ;", "clazz    =    ExpressionWithConversionTests . typeDescriptorForListOfInteger . getElementTypeDescriptor (  )  . getType (  )  ;", "assertEquals ( Integer . class ,    clazz )  ;", "l    =     (  ( List <  ?  >  )     ( tcs . convertValue ( ExpressionWithConversionTests . listOfString ,    TypeDescriptor . forObject ( ExpressionWithConversionTests . listOfString )  ,    ExpressionWithConversionTests . typeDescriptorForListOfString )  )  )  ;", "assertNotNull ( l )  ;", "}", "METHOD_END"], "methodName": ["testConversionsAvailable"], "fileName": "org.springframework.expression.spel.ExpressionWithConversionTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionWithConversionTests . Foo   root    =    new   ExpressionWithConversionTests . Foo (  \" bar \"  )  ;", "Collection < String >    foos    =    Collections . singletonList (  \" baz \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( root )  ;", "Expression   expression    =    parser . parseExpression (  \" foos \"  )  ;", "expression . setValue ( context ,    foos )  ;", "ExpressionWithConversionTests . Foo   baz    =    root . getFoos (  )  . iterator (  )  . next (  )  ;", "assertEquals (  \" baz \"  ,    baz . value )  ;", "expression    =    parser . parseExpression (  \" setFoos (  # foos )  \"  )  ;", "context . setVariable (  \" foos \"  ,    foos )  ;", "expression . getValue ( context )  ;", "baz    =    root . getFoos (  )  . iterator (  )  . next (  )  ;", "assertEquals (  \" baz \"  ,    baz . value )  ;", "expression    =    parser . parseExpression (  \" setFoos ( getFoosAsStrings (  )  )  \"  )  ;", "expression . getValue ( context )  ;", "baz    =    root . getFoos (  )  . iterator (  )  . next (  )  ;", "assertEquals (  \" baz \"  ,    baz . value )  ;", "expression    =    parser . parseExpression (  \" setFoos ( getFoosAsObjects (  )  )  \"  )  ;", "expression . getValue ( context )  ;", "baz    =    root . getFoos (  )  . iterator (  )  . next (  )  ;", "assertEquals (  \" baz \"  ,    baz . value )  ;", "}", "METHOD_END"], "methodName": ["testConvert"], "fileName": "org.springframework.expression.spel.ExpressionWithConversionTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "Expression   e    =    parser . parseExpression (  \" listOfInteger . size (  )  \"  )  ;", "assertEquals (  0  ,    e . getValue ( context ,    Integer . class )  . intValue (  )  )  ;", "context . setTypeConverter ( new    . TypeConvertorUsingConversionService (  )  )  ;", "parser . parseExpression (  \" listOfInteger \"  )  . setValue ( context ,     . listOfString )  ;", "assertEquals (  3  ,    e . getValue ( context ,    Integer . class )  . intValue (  )  )  ;", "Class <  ?  >    clazz    =    parser . parseExpression (  \" listOfInteger [  1  ]  . getClass (  )  \"  )  . getValue ( context ,    Class . class )  ;", "assertEquals ( Integer . class ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["testSetParameterizedList"], "fileName": "org.springframework.expression.spel.ExpressionWithConversionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" listOfNumbersUpToTen .  !  [  # this <  5  ?  ' y '  :  ' n '  ]  \"  ,     \"  [ y ,    y ,    y ,    y ,    n ,    n ,    n ,    n ,    n ,    n ]  \"  ,    ArrayList . class )  ;", "}", "METHOD_END"], "methodName": ["testProjection01"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" mapOfNumbersUpToTen .  !  [ key >  5  ? value : null ]  \"  ,     \"  [ null ,    null ,    null ,    null ,    null ,    six ,    seven ,    eight ,    nine ,    ten ]  \"  ,    ArrayList . class )  ;", "}", "METHOD_END"], "methodName": ["testProjection02"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  ' abc '  .  !  [ true ]  \"  ,    SpelMessage . PROJECTION _ NOT _ SUPPORTED _ ON _ TYPE )  ;", "evaluateAndCheckError (  \" null .  !  [ true ]  \"  ,    SpelMessage . PROJECTION _ NOT _ SUPPORTED _ ON _ TYPE )  ;", "evaluate (  \" null ?  .  !  [ true ]  \"  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testProjection05"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  ' abc '  .  !  [ true ]  \"  )  )  )  ;", "assertEquals (  \"  ' abc '  .  !  [ true ]  \"  ,    expr . toStringAST (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProjection06"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  1    between   listOneFive \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsBetween01"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  1    between   T ( String )  \"  ,    SpelMessage . BETWEEN _ RIGHT _ OPERAND _ MUST _ BE _ TWO _ ELEMENT _ LIST ,     1  0  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsBetweenErrors01"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  1    between   listOfNumbersUpToTen \"  ,    SpelMessage . BETWEEN _ RIGHT _ OPERAND _ MUST _ BE _ TWO _ ELEMENT _ LIST ,     1  0  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsBetweenErrors03"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" testMap . keySet (  )  .  ?  [  # this   matches    '  .  * o .  *  '  ]  \"  ,     \"  [ monday ]  \"  ,    ArrayList . class )  ;", "evaluate (  \" testMap . keySet (  )  .  ?  [  # this   matches    '  .  * r .  *  '  ]  . contains (  ' saturday '  )  \"  ,     \" true \"  ,    Boolean . class )  ;", "evaluate (  \" testMap . keySet (  )  .  ?  [  # this   matches    '  .  * r .  *  '  ]  . size (  )  \"  ,     \"  3  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testSelection02"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" mapOfNumbersUpToTen .  ?  [ key >  5  ]  . size (  )  \"  ,     \"  5  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testSelection03"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" mapOfNumbersUpToTen .  ?  [  ' hello '  ]  . size (  )  \"  ,    SpelMessage . RESULT _ OF _ SELECTION _ CRITERIA _ IS _ NOT _ BOOLEAN )  ;", "}", "METHOD_END"], "methodName": ["testSelection04"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" mapOfNumbersUpToTen .  ?  [ key >  1  1  ]  . size (  )  \"  ,     \"  0  \"  ,    Integer . class )  ;", "evaluate (  \" mapOfNumbersUpToTen .  ^  [ key >  1  1  ]  \"  ,    null ,    null )  ;", "evaluate (  \" mapOfNumbersUpToTen .  $  [ key >  1  1  ]  \"  ,    null ,    null )  ;", "evaluate (  \" null ?  .  $  [ key >  1  1  ]  \"  ,    null ,    null )  ;", "evaluateAndCheckError (  \" null .  ?  [ key >  1  1  ]  \"  ,    SpelMage . INVALID _ TYPE _ FOR _ SELECTION )  ;", "evaluateAndCheckError (  \"  ' abc '  .  ?  [ key >  1  1  ]  \"  ,    SpelMage . INVALID _ TYPE _ FOR _ SELECTION )  ;", "}", "METHOD_END"], "methodName": ["testSelection05"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  ' abc '  .  ^  [ true ]  \"  )  )  )  ;", "assertEquals (  \"  ' abc '  .  ^  [ true ]  \"  ,    expr . toStringAST (  )  )  ;", "expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  ' abc '  .  ?  [ true ]  \"  )  )  )  ;", "assertEquals (  \"  ' abc '  .  ?  [ true ]  \"  ,    expr . toStringAST (  )  )  ;", "expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  ' abc '  .  $  [ true ]  \"  )  )  )  ;", "assertEquals (  \"  ' abc '  .  $  [ true ]  \"  ,    expr . toStringAST (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSelectionAST"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" listOfNumbersUpToTen .  ?  [  ' nonboolean '  ]  \"  ,    SpelMessage . RESULT _ OF _ SELECTION _ CRITERIA _ IS _ NOT _ BOOLEAN )  ;", "}", "METHOD_END"], "methodName": ["testSelectionError_NonBooleanSelectionCriteria"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" listOfNumbersUpToTen .  ^  [  # isEven (  # this )     =  =     ' y '  ]  \"  ,     \"  2  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testSelectionFirst01"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" mapOfNumbersUpToTen .  ^  [ key >  5  ]  . size (  )  \"  ,     \"  1  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testSelectionFirst02"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" listOfNumbersUpToTen .  $  [  # isEven (  # this )     =  =     ' y '  ]  \"  ,     \"  1  0  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testSelectionLast01"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" mapOfNumbersUpToTen .  $  [ key >  5  ]  \"  ,     \"  {  1  0  = ten }  \"  ,    HashMap . class )  ;", "evaluate (  \" mapOfNumbersUpToTen .  $  [ key >  5  ]  . size (  )  \"  ,     \"  1  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testSelectionLast02"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   HashSet (  )  . addAll (  {  ' a '  ,  ' b '  ,  ' c '  }  )  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testSetConstruction01"], "fileName": "org.springframework.expression.spel.InProgressTests"}, {"methodBody": ["METHOD_START", "{", "listOfScalarNotGeneric    =    new   ArrayList (  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression    =    parser . parseExpression (  \" listOfScalarNotGeneric \"  )  ;", "assertEquals (  \" ArrayList <  ?  >  \"  ,    getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals (  \"  \"  ,    getValue ( this ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["emptyList"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    property    =    new   String [  ]  {     \" bar \"     }  ;", "this . property    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" property \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   String [  ]  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" property [  0  ]  \"  )  ;", "assertEquals (  \" bar \"  ,    expression . getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["indexIntoGenericPropertyContainingArray"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    property    =    new   ArrayList <  >  (  )  ;", "this . property    =    property ;", "SpelParserConfiguration   configuration    =    new   SpelParserConfiguration ( true ,    true )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( configuration )  ;", "Expression   expression    =    parser . parseExpression (  \" property \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   ArrayList <  ?  >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" property [  0  ]  \"  )  ;", "try    {", "assertEquals (  \" bar \"  ,    expression . getValue ( this )  )  ;", "}    catch    ( EvaluationException   ex )     {", "assertTrue ( ex . getMessage (  )  . startsWith (  \" EL 1  0  5  3 E \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["indexIntoGenericPropertyContainingGrowingList"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    property 2     =    new   ArrayList <  >  (  )  ;", "this . property 2     =    property 2  ;", "SpelParserConfiguration   configuration    =    new   SpelParserConfiguration ( true ,    true )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( configuration )  ;", "Expression    =    parser . parseExpression (  \" property 2  \"  )  ;", "assertEquals (  \" ArrayList <  ?  >  \"  ,    getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property 2  ,    getValue ( this )  )  ;", "=    parser . parseExpression (  \" property 2  [  0  ]  \"  )  ;", "try    {", "assertEquals (  \" bar \"  ,    getValue ( this )  )  ;", "}    catch    ( EvaluationException   ex )     {", "assertTrue ( ex . getMessage (  )  . startsWith (  \" EL 1  0  5  3 E \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["indexIntoGenericPropertyContainingGrowingList2"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    property    =    new   ArrayList <  >  (  )  ;", "property . add (  \" bar \"  )  ;", "this . property    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" property \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   ArrayList <  ?  >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" property [  0  ]  \"  )  ;", "assertEquals (  \" bar \"  ,    expression . getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["indexIntoGenericPropertyContainingList"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    property    =    new   HashMap <  >  (  )  ;", "property . put (  \" foo \"  ,     \" bar \"  )  ;", "this . property    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" property \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   HashMap <  ?  ,     ?  >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "assertEquals ( property ,    expression . getValue ( this ,    Map . class )  )  ;", "expression    =    parser . parseExpression (  \" property [  ' foo '  ]  \"  )  ;", "assertEquals (  \" bar \"  ,    expression . getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["indexIntoGenericPropertyContainingMap"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Map < String ,    String >  >    property    =    new   HashMap <  >  (  )  ;", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" foo \"  ,     \" bar \"  )  ;", "property . put (  \" property \"  ,    map )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . addPropertyAccessor ( new    . MapAccessor (  )  )  ;", "context . setRootObject ( property )  ;", "Expression   expression    =    parser . parseExpression (  \" property \"  )  ;", "assertEquals (  \" HashMap <  ?  ,     ?  >  \"  ,    expression . getValueTypeDescriptor ( context )  . toString (  )  )  ;", "assertEquals ( map ,    expression . getValue ( context )  )  ;", "assertEquals ( map ,    expression . getValue ( context ,    Map . class )  )  ;", "expression    =    parser . parseExpression (  \" property [  ' foo '  ]  \"  )  ;", "assertEquals (  \" bar \"  ,    expression . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["indexIntoGenericPropertyContainingMapObject"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "SpelParserConfiguration   configuration    =    new   SpelParserConfiguration ( true ,    true )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( configuration )  ;", "Expression   expression    =    parser . parseExpression (  \" property \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   Object \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" property [  0  ]  \"  )  ;", "try    {", "assertEquals (  \" bar \"  ,    expression . getValue ( this )  )  ;", "}    catch    ( EvaluationException   ex )     {", "assertTrue ( ex . getMessage (  )  . startsWith (  \" EL 1  0  2  7 E \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["indexIntoGenericPropertyContainingNullList"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    property    =    new   ArrayList <  >  (  )  ;", "property . add (  3  )  ;", "this . parameterizedList    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression    =    parser . parseExpression (  \" parameterizedList \"  )  ;", "assertEquals (  \" ArrayList < Integer >  \"  ,    getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    getValue ( this )  )  ;", "=    parser . parseExpression (  \" parameterizedList [  0  ]  \"  )  ;", "assertEquals (  3  ,    getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["indexIntoPropertyContainingList"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "List < List < Integer >  >    property    =    new   ArrayList <  >  (  )  ;", "property . add ( Arrays . asList (  3  )  )  ;", "this . parameterizedListOfList    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression    =    parser . parseExpression (  \" parameterizedListOfList [  0  ]  \"  )  ;", "assertEquals (  \" Arrays $ ArrayList < Integer >  \"  ,    getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property . get (  0  )  ,    getValue ( this )  )  ;", "=    parser . parseExpression (  \" parameterizedListOfList [  0  ]  [  0  ]  \"  )  ;", "assertEquals (  3  ,    getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["indexIntoPropertyContainingListOfList"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "listNotGeneric    =    new   ArrayList (  2  )  ;", "listNotGeneric . add (  5  )  ;", "listNotGeneric . add (  6  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" listNotGeneric \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   ArrayList <  ?  >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals (  \"  5  ,  6  \"  ,    expression . getValue ( this ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["resolveCollectionElementType"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" listNotGeneric \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   List <  ?  >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveCollectionElementTypeNull"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "mapNotGeneric    =    new   HashMap (  )  ;", "mapNotGeneric . put (  \" baseAmount \"  ,     3  .  1  1  )  ;", "mapNotGeneric . put (  \" bonusAmount \"  ,     7  .  1  7  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" mapNotGeneric \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   HashMap <  ?  ,     ?  >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveMapKeyValueTypes"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    property    =    new   ArrayList <  >  (  )  ;", "property . add (  3  )  ;", "this . property    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" property \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   ArrayList <  ?  >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" property [  0  ]  \"  )  ;", "assertEquals (  3  ,    expression . getValue ( this )  )  ;", "expression . setValue ( this ,     \"  4  \"  )  ;", "assertEquals (  \"  4  \"  ,    expression . getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["setGenericPropertyContainingList"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    property    =    new   ArrayList <  >  (  )  ;", "this . property    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    true )  )  ;", "Expression   expression    =    parser . parseExpression (  \" property \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   ArrayList <  ?  >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" property [  0  ]  \"  )  ;", "try    {", "expression . setValue ( this ,     \"  4  \"  )  ;", "}    catch    ( EvaluationException   ex )     {", "assertTrue ( ex . getMessage (  )  . startsWith (  \" EL 1  0  5  3 E \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setGenericPropertyContainingListAutogrow"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    property    =    new   HashMap <  >  (  )  ;", "property . put (  \" foo \"  ,     \" bar \"  )  ;", "this . property    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" property \"  )  ;", "assertEquals (  \"  @  $ FieldAnnotation   HashMap <  ?  ,     ?  >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" property [  ' foo '  ]  \"  )  ;", "assertEquals (  \" bar \"  ,    expression . getValue ( this )  )  ;", "expression . setValue ( this ,     \" baz \"  )  ;", "assertEquals (  \" baz \"  ,    expression . getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["setGenericPropertyContainingMap"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    property    =    new   ArrayList <  >  (  )  ;", "property . add (  3  )  ;", "this . parameterizedList    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" parameterizedList \"  )  ;", "assertEquals (  \" ArrayList < Integer >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" parameterizedList [  0  ]  \"  )  ;", "assertEquals (  3  ,    expression . getValue ( this )  )  ;", "etValue ( this ,     \"  4  \"  )  ;", "assertEquals (  4  ,    expression . getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyContainingList"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "Map < Integer ,    Integer >    property    =    new   HashMap <  >  (  )  ;", "property . put (  9  ,     3  )  ;", "this . parameterizedMap    =    property ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" parameterizedMap \"  )  ;", "assertEquals (  \" HashMap < Integer ,    Integer >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" parameterizedMap [  '  9  '  ]  \"  )  ;", "assertEquals (  3  ,    expression . getValue ( this )  )  ;", "etValue ( this ,     \"  3  7  \"  )  ;", "assertEquals (  3  7  ,    expression . getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyContainingMap"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( true ,    false )  )  ;", "Expression   expression    =    parser . parseExpression (  \" parameterizedMap \"  )  ;", "assertEquals (  \" Map < Integer ,    Integer >  \"  ,    expression . getValueTypeDescriptor ( this )  . toString (  )  )  ;", "assertEquals ( property ,    expression . getValue ( this )  )  ;", "expression    =    parser . parseExpression (  \" parameterizedMap [  '  9  '  ]  \"  )  ;", "assertEquals ( null ,    expression . getValue ( this )  )  ;", "etValue ( this ,     \"  3  7  \"  )  ;", "assertEquals (  3  7  ,    expression . getValue ( this )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyContainingMapAutoGrow"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "listOfScalarNotGeneric    =    new   ArrayList (  1  )  ;", "listOfScalarNotGeneric . add (  \"  5  \"  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression    =    parser . parseExpression (  \" listOfScalarNotGeneric [  0  ]  \"  )  ;", "assertEquals ( new   Integer (  5  )  ,    getValue ( this ,    Integer . class )  )  ;", "}", "METHOD_END"], "methodName": ["testListOfScalar"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "listOfMapsNotGeneric    =    new   ArrayList (  )  ;", "Map   map    =    new   HashMap (  )  ;", "map . put (  \" fruit \"  ,     \" apple \"  )  ;", "listOfMapsNotGeneric . add ( map )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression    =    parser . parseExpression (  \" listOfMapsNotGeneric [  0  ]  [  ' fruit '  ]  \"  )  ;", "assertEquals (  \" apple \"  ,    getValue ( this ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testListsOfMap"], "fileName": "org.springframework.expression.spel.IndexingTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression    =     (  ( SpelExpression )     ( parser . parseExpression ( ext )  )  )  ;", "SpelNode   node    =    getAST (  )  ;", "assertTrue (  ( node   instanceof   InlineList )  )  ;", "InlineList   inlineList    =     (  ( InlineList )     ( node )  )  ;", "if    ( expectedToBeConstant )     {", "assertTrue ( inlineList . isConstant (  )  )  ;", "} else    {", "assertFalse ( inlineList . isConstant (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkConstantList"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "checkConstantList (  \"  {  1  ,  2  ,  3  ,  4  ,  5  }  \"  ,    true )  ;", "checkConstantList (  \"  {  ' abc '  }  \"  ,    true )  ;", "checkConstantList (  \"  {  }  \"  ,    true )  ;", "checkConstantList (  \"  {  # a ,  2  ,  3  }  \"  ,    false )  ;", "checkConstantList (  \"  {  1  ,  2  , Integer . valueOf (  4  )  }  \"  ,    false )  ;", "checkConstantList (  \"  {  1  ,  2  ,  {  # a }  }  \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testConstantRepresentation1"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  {  1  ,  2  ,  3  }  ,  {  4  ,  5  ,  6  }  }  \"  ,     \"  [  [  1  ,     2  ,     3  ]  ,     [  4  ,     5  ,     6  ]  ]  \"  ,    unmodifiableClass )  ;", "evaluate (  \"  {  {  1  ,  '  2  '  ,  3  }  ,  {  4  ,  {  ' a '  ,  ' b '  }  ,  5  ,  6  }  }  \"  ,     \"  [  [  1  ,     2  ,     3  ]  ,     [  4  ,     [ a ,    b ]  ,     5  ,     6  ]  ]  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineListAndNesting"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  1  ,  2  ,  3  ,  4  ,  5  ,  6  }  .  !  [  # this >  3  ]  \"  ,     \"  [ false ,    false ,    false ,    true ,    true ,    true ]  \"  ,    ArrayList . class )  ;", "evaluate (  \"  {  1  ,  2  ,  3  ,  4  ,  5  ,  6  }  .  ?  [  # this >  3  ]  \"  ,     \"  [  4  ,     5  ,     6  ]  \"  ,    ArrayList . class )  ;", "evaluate (  \"  {  1  ,  2  ,  3  ,  4  ,  5  ,  6  ,  7  ,  8  ,  9  ,  1  0  }  .  ?  [  # isEven (  # this )     =  =     ' y '  ]  \"  ,     \"  [  2  ,     4  ,     6  ,     8  ,     1  0  ]  \"  ,    ArrayList . class )  ;", "}", "METHOD_END"], "methodName": ["testInlineListAndProjectionSelection"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  1  ,     2  ,     3  ,     4  ,     5  }  \"  ,     \"  [  1  ,     2  ,     3  ,     4  ,     5  ]  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineListCreation01"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  ' abc '  ,     ' xyz '  }  \"  ,     \"  [ abc ,    xyz ]  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineListCreation02"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  }  \"  ,     \"  [  ]  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineListCreation03"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  ' abc '  =  =  ' xyz '  }  \"  ,     \"  [ false ]  \"  ,    ArrayList . class )  ;", "}", "METHOD_END"], "methodName": ["testInlineListCreation04"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3    between    {  1  ,  5  }  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testInlineListCreation05"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  8    between    {  1  ,  5  }  \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testInlineListCreation06"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "parseAndCheckError (  \"  {  ' abc '  \"  ,    SpelMessage . OOD )  ;", "}", "METHOD_END"], "methodName": ["testInlineListError"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  1  ,     2  ,     3  ,     4  ,     5  }  [  0  ]  =  6  \"  ,     \"  [  1  ,     2  ,     3  ,     4  ,     5  ]  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineListWriting"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  2    between    {  3  2  ,     4  2  }  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsBetween01"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' efg '    between    {  ' abc '  ,     ' xyz '  }  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsBetween02"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  4  2    between    {  3  2  ,     4  2  }  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsBetween03"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   BigDecimal (  '  1  '  )    between    { new   BigDecimal (  '  1  '  )  , new   BigDecimal (  '  5  '  )  }  \"  ,     \" true \"  ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    between    { new   BigDecimal (  '  1  '  )  , new   BigDecimal (  '  5  '  )  }  \"  ,     \" true \"  ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    between    { new   BigDecimal (  '  1  '  )  , new   BigDecimal (  '  5  '  )  }  \"  ,     \" true \"  ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  8  '  )    between    { new   BigDecimal (  '  1  '  )  , new   BigDecimal (  '  5  '  )  }  \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsBetween04"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  ' abc '    between    {  5  ,  7  }  \"  ,    SpelMessage . NOT _ COMPARABLE ,     6  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsBetweenErrors02"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  1  ,     2  ,     3  ,     4  ,     5  }    instanceof   T ( List )  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsIs02"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   HashSet (  )  . addAll (  {  ' a '  ,  ' b '  ,  ' c '  }  )  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testSetConstruction01"], "fileName": "org.springframework.expression.spel.ListTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( value   instanceof   String )  )     {", "fail (  (  (  (  (  \" Result   was   not   a   string ,    it   was   of   type    \"     +     ( value . getClass (  )  )  )     +     \"        ( value =  \"  )     +    value )     +     \"  )  \"  )  )  ;", "}", "if    (  !  (  (  ( String )     ( value )  )  . equals ( expectedString )  )  )     {", "fail (  (  (  (  (  \" Did   not   get   expected   result .       Should   have   been    '  \"     +    expectedString )     +     \"  '    but   was    '  \"  )     +    value )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkString"], "fileName": "org.springframework.expression.spel.LiteralExpressionTests"}, {"methodBody": ["METHOD_START", "{", "LiteralExpression   lEx    =    new   LiteralExpression (  \" somevalue \"  )  ;", "checkString (  \" somevalue \"  ,    lEx . getValue (  )  )  ;", "checkString (  \" somevalue \"  ,    lEx . getValue ( String . class )  )  ;", "EvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "checkString (  \" somevalue \"  ,    lEx . getValue ( ctx )  )  ;", "checkString (  \" somevalue \"  ,    lEx . getValue ( ctx ,    String . class )  )  ;", "checkString (  \" somevalue \"  ,    lEx . getValue ( new    . Rooty (  )  )  )  ;", "checkString (  \" somevalue \"  ,    lEx . getValue ( new    . Rooty (  )  ,    String . class )  )  ;", "checkString (  \" somevalue \"  ,    lEx . getValue ( ctx ,    new    . Rooty (  )  )  )  ;", "checkString (  \" somevalue \"  ,    lEx . getValue ( ctx ,    new    . Rooty (  )  ,    String . class )  )  ;", "assertEquals (  \" somevalue \"  ,    lEx . getExpressionString (  )  )  ;", "assertFalse ( lEx . isWritable ( new   StandardEvaluationContext (  )  )  )  ;", "assertFalse ( lEx . isWritable ( new    . Rooty (  )  )  )  ;", "assertFalse ( lEx . isWritable ( new   StandardEvaluationContext (  )  ,    new    . Rooty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetValue"], "fileName": "org.springframework.expression.spel.LiteralExpressionTests"}, {"methodBody": ["METHOD_START", "{", "LiteralExpression   lEx    =    new   LiteralExpression (  \" somevalue \"  )  ;", "assertEquals ( String . class ,    lEx . getValueType (  )  )  ;", "assertEquals ( String . class ,    lEx . getValueType ( new   StandardEvaluationContext (  )  )  )  ;", "assertEquals ( String . class ,    lEx . getValueType ( new    . Rooty (  )  )  )  ;", "assertEquals ( String . class ,    lEx . getValueType ( new   StandardEvaluationContext (  )  ,    new    . Rooty (  )  )  )  ;", "assertEquals ( String . class ,    lEx . getValueTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( String . class ,    lEx . getValueTypeDescriptor ( new   StandardEvaluationContext (  )  )  . getType (  )  )  ;", "assertEquals ( String . class ,    lEx . getValueTypeDescriptor ( new    . Rooty (  )  )  . getType (  )  )  ;", "assertEquals ( String . class ,    lEx . getValueTypeDescriptor ( new   StandardEvaluationContext (  )  ,    new    . Rooty (  )  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetValueType"], "fileName": "org.springframework.expression.spel.LiteralExpressionTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "LiteralExpression   lEx    =    new   LiteralExpression (  \" somevalue \"  )  ;", "lEx . setValue ( new   StandardEvaluationContext (  )  ,     \" flibble \"  )  ;", "fail (  \" Should   have   got   an   exception   that   the   value   cannot   be   set \"  )  ;", "}    catch    ( EvaluationException   ee )     {", "assertEquals (  \" somevalue \"  ,    ee . getExpressionString (  )  )  ;", "}", "try    {", "LiteralExpression   lEx    =    new   LiteralExpression (  \" somevalue \"  )  ;", "lEx . setValue ( new    . Rooty (  )  ,     \" flibble \"  )  ;", "fail (  \" Should   have   got   an   exception   that   the   value   cannot   be   set \"  )  ;", "}    catch    ( EvaluationException   ee )     {", "assertEquals (  \" somevalue \"  ,    ee . getExpressionString (  )  )  ;", "}", "try    {", "LiteralExpression   lEx    =    new   LiteralExpression (  \" somevalue \"  )  ;", "lEx . setValue ( new   StandardEvaluationContext (  )  ,    new    . Rooty (  )  ,     \" flibble \"  )  ;", "fail (  \" Should   have   got   an   exception   that   the   value   cannot   be   set \"  )  ;", "}    catch    ( EvaluationException   ee )     {", "assertEquals (  \" somevalue \"  ,    ee . getExpressionString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSetValue"], "fileName": "org.springframework.expression.spel.LiteralExpressionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   Integer (  3  7  )  . byteValue (  )  \"  ,     (  ( byte )     (  3  7  )  )  ,    Byte . class )  ;", "evaluateAndAskForReturnType (  \" new   Integer (  3  7  )  \"  ,     (  ( byte )     (  3  7  )  )  ,    Byte . class )  ;", "}", "METHOD_END"], "methodName": ["testConversions"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  0 x 7 FFFF \"  ,     \"  5  2  4  2  8  7  \"  ,    Integer . class )  ;", "evaluate (  \"  0 x 7 FFFFL \"  ,     5  2  4  2  8  7 L ,    Long . class )  ;", "evaluate (  \"  0 X 7 FFFF \"  ,     \"  5  2  4  2  8  7  \"  ,    Integer . class )  ;", "evaluate (  \"  0 X 7 FFFFl \"  ,     5  2  4  2  8  7 L ,    Long . class )  ;", "}", "METHOD_END"], "methodName": ["testHexIntLiteral01"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" false \"  ,     \" false \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralBoolean01"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" true \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralBoolean02"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  1  \"  ,     \"  1  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralInteger01"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  1  4  1  5  \"  ,     \"  1  4  1  5  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralInteger02"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" null \"  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testLiteralNull01"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  1  .  2  5  \"  ,     1  .  2  5  ,    Double . class )  ;", "evaluate (  \"  2  .  9  9  \"  ,     2  .  9  9  ,    Double . class )  ;", "evaluate (  \"  -  3  .  1  4  1  \"  ,     (  -  3  .  1  4  1  )  ,    Double . class )  ;", "evaluate (  \"  1  .  2  5 d \"  ,     1  .  2  5  ,    Double . class )  ;", "evaluate (  \"  2  .  9  9 d \"  ,     2  .  9  9  ,    Double . class )  ;", "evaluate (  \"  -  3  .  1  4  1 d \"  ,     (  -  3  .  1  4  1  )  ,    Double . class )  ;", "evaluate (  \"  1  .  2  5 D \"  ,     1  .  2  5  ,    Double . class )  ;", "evaluate (  \"  2  .  9  9 D \"  ,     2  .  9  9  ,    Double . class )  ;", "evaluate (  \"  -  3  .  1  4  1 D \"  ,     (  -  3  .  1  4  1  )  ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralReal01_CreatingDoubles"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  1  .  2  5 f \"  ,     1  .  2  5 F ,    Float . class )  ;", "evaluate (  \"  2  .  5 f \"  ,     2  .  5 F ,    Float . class )  ;", "evaluate (  \"  -  3  .  5 f \"  ,     (  -  3  .  5 F )  ,    Float . class )  ;", "evaluate (  \"  1  .  2  5 F \"  ,     1  .  2  5 F ,    Float . class )  ;", "evaluate (  \"  2  .  5 F \"  ,     2  .  5 F ,    Float . class )  ;", "evaluate (  \"  -  3  .  5 F \"  ,     (  -  3  .  5 F )  ,    Float . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralReal02_CreatingFloats"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  6  .  0  2  2  1  4  1  5 E +  2  3  \"  ,     \"  6  .  0  2  2  1  4  1  5 E 2  3  \"  ,    Double . class )  ;", "evaluate (  \"  6  .  0  2  2  1  4  1  5 e +  2  3  \"  ,     \"  6  .  0  2  2  1  4  1  5 E 2  3  \"  ,    Double . class )  ;", "evaluate (  \"  6  .  0  2  2  1  4  1  5 E +  2  3 d \"  ,     \"  6  .  0  2  2  1  4  1  5 E 2  3  \"  ,    Double . class )  ;", "evaluate (  \"  6  .  0  2  2  1  4  1  5 e +  2  3 D \"  ,     \"  6  .  0  2  2  1  4  1  5 E 2  3  \"  ,    Double . class )  ;", "evaluate (  \"  6 E 2 f \"  ,     6  0  0  .  0 F ,    Float . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralReal03_UsingExponents"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "parseAndCheckError (  \"  6  .  1 e 2  3 e 2  2  \"  ,    SpelMessage . MORE _ INPUT ,     6  ,     \" e 2  2  \"  )  ;", "parseAndCheckError (  \"  6  .  1 f 2  3 e 2  2  \"  ,    SpelMessage . MORE _ INPUT ,     4  ,     \"  2  3 e 2  2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralReal04_BadExpressions"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' Hello   World '  \"  ,     \" Hello   World \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralString01"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' joe   bloggs '  \"  ,     \" joe   bloggs \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralString02"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' hello '  \"  ,     \" hello \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralString03"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' Tony '  ' s   Pizza '  \"  ,     \" Tony ' s   Pizza \"  ,    String . class )  ;", "evaluate (  \"  \\  ' Tony \\  \\ r \\  '  \\  ' s   Pizza \\  '  \"  ,     \" Tony \\  \\ r \\  ' s   Pizza \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralString04"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  \\  \" Hello   World \\  \"  \"  ,     \" Hello   World \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralString05"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  \\  \" Hello    \\  '    World \\  \"  \"  ,     \" Hello    '    World \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testLiteralString06"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  0 x 2  0     *     2 L \"  ,     6  4 L ,    Long . class )  ;", "evaluateAndAskForReturnType (  \"  0 x 2  0     *     2 L \"  ,     6  4  ,    Integer . class )  ;", "evaluateAndCheckError (  \"  0 x 1  2  2  0     *     0 xffffffffL \"  ,    Integer . class ,    SpelMage . TYPE _ CONVERSION _ ERROR ,     0  )  ;", "}", "METHOD_END"], "methodName": ["testLongIntInteractions01"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  0 xCAFEBABEL \"  ,     3  4  0  5  6  9  1  5  8  2 L ,    Long . class )  ;", "}", "METHOD_END"], "methodName": ["testLongIntLiteral01"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  3  7  \"  )  )  )  ;", "assertFalse ( expr . isWritable ( new   StandardEvaluationContext (  )  )  )  ;", "expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  3  7 L \"  )  )  )  ;", "assertFalse ( expr . isWritable ( new   StandardEvaluationContext (  )  )  )  ;", "expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \" true \"  )  )  )  ;", "assertFalse ( expr . isWritable ( new   StandardEvaluationContext (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNotWritable"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  -  1  \"  ,     (  -  1  )  ,    Integer . class )  ;", "evaluate (  \"  -  0 xa \"  ,     (  -  1  0  )  ,    Integer . class )  ;", "evaluate (  \"  -  1 L \"  ,     (  -  1 L )  ,    Long . class )  ;", "evaluate (  \"  -  0 x 2  0 l \"  ,     (  -  3  2 L )  ,    Long . class )  ;", "}", "METHOD_END"], "methodName": ["testSignedIntLiterals"], "fileName": "org.springframework.expression.spel.LiteralTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "ctx . addPropertyAccessor ( new    . MapAccessor (  )  )  ;", "Expression   expr    =    parser . parseExpression (  \" testMap . monday \"  )  ;", "Object   value    =    expr . getValue ( ctx ,    String . class )  ;", "assertEquals (  \" montag \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["testCustomMapAccessor"], "fileName": "org.springframework.expression.spel.MapAccessTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    props 1     =    new   HashMap <  >  (  )  ;", "props 1  . put (  \" key 1  \"  ,     \" value 1  \"  )  ;", "props 1  . put (  \" key 2  \"  ,     \" value 2  \"  )  ;", "props 1  . put (  \" key 3  \"  ,     \" value 3  \"  )  ;", "Object   bean    =    new    . TestBean (  \" name 1  \"  ,    new    . TestBean (  \" name 2  \"  ,    null ,     \" Description    2  \"  ,     1  5  ,    props 1  )  ,     \" description    1  \"  ,     6  ,    props 1  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \" testBean . properties [  ' key 2  '  ]  \"  )  ;", "assertEquals (  \" value 2  \"  ,    expr . getValue ( bean )  )  ;", "}", "METHOD_END"], "methodName": ["testGetValue"], "fileName": "org.springframework.expression.spel.MapAccessTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" key \"  ,     \" value \"  )  ;", "EParser   spelEParser    =    new   SpelEParser (  )  ;", "E   expr    =    spelEParser . parseE (  \"  # root [  ' key '  ]  \"  )  ;", "assertEquals (  \" value \"  ,    expr . getValue ( map )  )  ;", "}", "METHOD_END"], "methodName": ["testGetValueFromRootMap"], "fileName": "org.springframework.expression.spel.MapAccessTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" key \"  ,     \" value \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( map )  ;", "EParser   spelEParser    =    new   SpelEParser (  )  ;", "E   expr    =    spelEParser . parseE (  \"  # root [  ' key '  ]  \"  )  ;", "StopWatch   s    =    new   StopWatch (  )  ;", "s . start (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  ;    i +  +  )     {", "expr . getValue ( context )  ;", "}", "s . stop (  )  ;", "assertThat ( s . getTotalTimeMillis (  )  ,    lessThan (  2  0  0 L )  )  ;", "}", "METHOD_END"], "methodName": ["testGetValuePerformance"], "fileName": "org.springframework.expression.spel.MapAccessTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" testMap [  ' monday '  ]  \"  ,     \" montag \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testMapAccessThroughIndexer"], "fileName": "org.springframework.expression.spel.MapAccessTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" testMap . get (  ' monday '  )  \"  ,     \" montag \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testSimpleMapAccess01"], "fileName": "org.springframework.expression.spel.MapAccessTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "ctx . setVariable (  \" day \"  ,     \" saturday \"  )  ;", "Expression   expr    =    parser . parseExpression (  \" testMap [  # day ]  \"  )  ;", "Object   value    =    expr . getValue ( ctx ,    String . class )  ;", "assertEquals (  \" samstag \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["testVariableMapAccess"], "fileName": "org.springframework.expression.spel.MapAccessTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression    =     (  ( SpelExpression )     ( parser . parseExpression ( ext )  )  )  ;", "SpelNode   node    =    getAST (  )  ;", "assertTrue (  ( node   instanceof   InlineMap )  )  ;", "InlineMap   inlineMap    =     (  ( InlineMap )     ( node )  )  ;", "if    ( expectedToBeConstant )     {", "assertTrue ( inlineMap . isConstant (  )  )  ;", "} else    {", "assertFalse ( inlineMap . isConstant (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkConstantMap"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "checkConstantMap (  \"  { f :  {  ' a '  ,  ' b '  ,  ' c '  }  }  \"  ,    true )  ;", "checkConstantMap (  \"  {  ' a '  :  1  ,  ' b '  :  2  ,  ' c '  :  3  ,  ' d '  :  4  ,  ' e '  :  5  }  \"  ,    true )  ;", "checkConstantMap (  \"  { aaa :  ' abc '  }  \"  ,    true )  ;", "checkConstantMap (  \"  {  :  }  \"  ,    true )  ;", "checkConstantMap (  \"  { a :  # a , b :  2  , c :  3  }  \"  ,    false )  ;", "checkConstantMap (  \"  { a :  1  , b :  2  , c : Integer . valueOf (  4  )  }  \"  ,    false )  ;", "checkConstantMap (  \"  { a :  1  , b :  2  , c :  {  # a }  }  \"  ,    false )  ;", "checkConstantMap (  \"  {  # root . name : true }  \"  ,    false )  ;", "checkConstantMap (  \"  { a :  1  , b :  2  , c :  { d : true , e : false }  }  \"  ,    true )  ;", "checkConstantMap (  \"  { a :  1  , b :  2  , c :  { d :  {  1  ,  2  ,  3  }  , e :  {  4  ,  5  ,  6  }  , f :  {  ' a '  ,  ' b '  ,  ' c '  }  }  }  \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testConstantRepresentation1"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  { a :  { a :  1  , b :  2  , c :  3  }  , b :  { d :  4  , e :  5  , f :  6  }  }  \"  ,     \"  { a =  { a =  1  ,    b =  2  ,    c =  3  }  ,    b =  { d =  4  ,    e =  5  ,    f =  6  }  }  \"  ,    unmodifiableClass )  ;", "evaluate (  \"  { a :  { x :  1  , y :  '  2  '  , z :  3  }  , b :  { u :  4  , v :  {  ' a '  ,  ' b '  }  , w :  5  , x :  6  }  }  \"  ,     \"  { a =  { x =  1  ,    y =  2  ,    z =  3  }  ,    b =  { u =  4  ,    v =  [ a ,    b ]  ,    w =  5  ,    x =  6  }  }  \"  ,    unmodifiableClass )  ;", "evaluate (  \"  { a :  {  1  ,  2  ,  3  }  , b :  {  4  ,  5  ,  6  }  }  \"  ,     \"  { a =  [  1  ,     2  ,     3  ]  ,    b =  [  4  ,     5  ,     6  ]  }  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapAndNesting"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  { a :  1  , b :  2  , c :  3  , d :  4  , e :  5  , f :  6  }  .  !  [ value >  3  ]  \"  ,     \"  [ false ,    false ,    false ,    true ,    true ,    true ]  \"  ,    ArrayList . class )  ;", "evaluate (  \"  { a :  1  , b :  2  , c :  3  , d :  4  , e :  5  , f :  6  }  .  ?  [ value >  3  ]  \"  ,     \"  { d =  4  ,    e =  5  ,    f =  6  }  \"  ,    Hash . class )  ;", "evaluate (  \"  { a :  1  , b :  2  , c :  3  , d :  4  , e :  5  , f :  6  , g :  7  , h :  8  , i :  9  , j :  1  0  }  .  ?  [ value %  2  =  =  0  ]  \"  ,     \"  { b =  2  ,    d =  4  ,    f =  6  ,    h =  8  ,    j =  1  0  }  \"  ,    Hash . class )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapAndProjectionSelection"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  ' a '  :  1  ,     ' b '  :  2  ,     ' c '  :  3  ,     ' d '  :  4  ,     ' e '  :  5  }  \"  ,     \"  { a =  1  ,    b =  2  ,    c =  3  ,    d =  4  ,    e =  5  }  \"  ,    unmodifiableClass )  ;", "evaluate (  \"  {  ' a '  :  1  }  \"  ,     \"  { a =  1  }  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapCreation01"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  ' abc '  :  ' def '  ,     ' uvw '  :  ' xyz '  }  \"  ,     \"  { abc = def ,    uvw = xyz }  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapCreation02"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  :  }  \"  ,     \"  {  }  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapCreation03"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  ' key '  :  ' abc '  =  =  ' xyz '  }  \"  ,     \"  { key = false }  \"  ,    LinkedHashMap . class )  ;", "evaluate (  \"  { key :  ' abc '  =  =  ' xyz '  }  \"  ,     \"  { key = false }  \"  ,    LinkedHashMap . class )  ;", "evaluate (  \"  { key :  ' abc '  =  =  ' xyz '  , key 2  : true }  [ key ]  \"  ,     \" false \"  ,    Boolean . class )  ;", "evaluate (  \"  { key :  ' abc '  =  =  ' xyz '  , key 2  : true }  . get (  ' key 2  '  )  \"  ,     \" true \"  ,    Boolean . class )  ;", "evaluate (  \"  { key :  ' abc '  =  =  ' xyz '  , key 2  : true }  [  ' key 2  '  ]  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapCreation04"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "parseAndCheckError (  \"  { key :  ' abc '  \"  ,    SpelMessage . OOD )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapError"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  {  # root . name : true }  \"  ,     \"  { Nikola   Tesla = true }  \"  ,    LinkedHashMap . class )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapWithFunkyKeys"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  { a :  1  ,    b :  2  ,    c :  3  ,    d :  4  ,    e :  5  }  [ a ]  =  6  \"  ,     \"  [ a :  1  , b :     2  , c :     3  , d :     4  , e :     5  ]  \"  ,    unmodifiableClass )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapWriting"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression    =    null ;", "Object   o    =    null ;", "=     (  ( SpelExpression )     ( parser . parseExpression (  \" foo [ T ]  \"  )  )  )  ;", "o    =    getValue ( new   MapTests . MapHolder (  )  )  ;", "assertEquals (  \" TV \"  ,    o )  ;", "=     (  ( SpelExpression )     ( parser . parseExpression (  \" foo [ t ]  \"  )  )  )  ;", "o    =    getValue ( new   MapTests . MapHolder (  )  )  ;", "assertEquals (  \" tv \"  ,    o )  ;", "=     (  ( SpelExpression )     ( parser . parseExpression (  \" foo [ NEW ]  \"  )  )  )  ;", "o    =    getValue ( new   MapTests . MapHolder (  )  )  ;", "assertEquals (  \" VALUE \"  ,    o )  ;", "=     (  ( SpelExpression )     ( parser . parseExpression (  \" foo [ new ]  \"  )  )  )  ;", "o    =    getValue ( new   MapTests . MapHolder (  )  )  ;", "assertEquals (  \" value \"  ,    o )  ;", "=     (  ( SpelExpression )     ( parser . parseExpression (  \" foo [  ' abc . def '  ]  \"  )  )  )  ;", "o    =    getValue ( new   MapTests . MapHolder (  )  )  ;", "assertEquals (  \" value \"  ,    o )  ;", "=     (  ( SpelExpression )     ( parser . parseExpression (  \" foo [ foo [ NEW ]  ]  \"  )  )  )  ;", "o    =    getValue ( new   MapTests . MapHolder (  )  )  ;", "assertEquals (  \"  3  7  \"  ,    o )  ;", "=     (  ( SpelExpression )     ( parser . parseExpression (  \" foo [ foo [ new ]  ]  \"  )  )  )  ;", "o    =    getValue ( new   MapTests . MapHolder (  )  )  ;", "assertEquals (  \"  3  8  \"  ,    o )  ;", "=     (  ( SpelExpression )     ( parser . parseExpression (  \" foo [ foo [ foo [ T ]  ]  ]  \"  )  )  )  ;", "o    =    getValue ( new   MapTests . MapHolder (  )  )  ;", "assertEquals (  \" value \"  ,    o )  ;", "}", "METHOD_END"], "methodName": ["testMapKeysThatAreAlsoSpELKeywords"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  { a :  1  ,    b :  2  ,    c :  3  ,    d :  4  ,    e :  5  }    instanceof   T ( Map )  \"  ,     \" true \"  ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsIs02"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   HashMap (  )  . putAll (  { a :  ' a '  , b :  ' b '  , c :  ' c '  }  )  \"  ,    null ,    Object . class )  ;", "}", "METHOD_END"], "methodName": ["testSetConstruction01"], "fileName": "org.springframework.expression.spel.MapTests"}, {"methodBody": ["METHOD_START", "{", "final   MethodInvocationTests . BytesService   service    =    new   MethodInvocationTests . BytesService (  )  ;", "byte [  ]    bytes    =    new   byte [  1  0  0  ]  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( bytes )  ;", "context . setBeanResolver ( new   BeanResolver (  )     {", "@ Override", "public   Object   resolve ( EvaluationContext   context ,    String   beanName )    throws   AccessException    {", "if    (  \" service \"  . equals ( beanName )  )     {", "return   service ;", "}", "return   null ;", "}", "}  )  ;", "Expression   expression    =    parser . parseExpression (  \"  @ service . handleBytes (  # root )  \"  )  ;", "byte [  ]    outBytes    =    expression . getValue ( context ,    byte [  ]  . class )  ;", "assertSame ( bytes ,    outBytes )  ;", "}", "METHOD_END"], "methodName": ["invokeMethodWithoutConversion"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "List < MethodResolver >    methodResolvers    =    ctx . getMethodResolvers (  )  ;", "assertEquals (  1  ,    methodResolvers . size (  )  )  ;", "MethodResolver   dummy    =    new    . DummyMethodResolver (  )  ;", "ctx . addMethodResolver ( dummy )  ;", "assertEquals (  2  ,    ctx . getMethodResolvers (  )  . size (  )  )  ;", "List < MethodResolver >    copy    =    new   ArrayList <  >  (  )  ;", "copy . addAll ( ctx . getMethodResolvers (  )  )  ;", "assertTrue ( ctx . removeMethodResolver ( dummy )  )  ;", "assertFalse ( ctx . removeMethodResolver ( dummy )  )  ;", "assertEquals (  1  ,    ctx . getMethodResolvers (  )  . size (  )  )  ;", "ctx . setMethodResolvers ( copy )  ;", "assertEquals (  2  ,    ctx . getMethodResolvers (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddingMethodResolvers"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String (  ' hello    2  .  0    to   you '  )  . startsWith (  7  .  0 d )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   String (  '  7  .  0    foobar '  )  . startsWith (  7  .  0 d )  \"  ,    true ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testArgumentConversion01"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" null . toString (  )  \"  ,    SpelMessage . METHOD _ CALL _ ON _ NULL _ OBJECT _ NOT _ ALLOWED )  ;", "}", "METHOD_END"], "methodName": ["testInvocationOnNullContextObject"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setRootObject ( new    . TestObject (  )  )  ;", ". LocalFilter   filter    =    new    . LocalFilter (  )  ;", "context . registerMethodFilter (  . TestObject . class ,    filter )  ;", "SpelExpression   expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \" doit (  1  )  \"  )  )  )  ;", "String   result    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \"  1  \"  ,    result )  ;", "assertTrue ( filter . filterCalled )  ;", "filter . removeIfNotAnnotated    =    true ;", "filter . filterCalled    =    false ;", "expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \" doit (  1  )  \"  )  )  )  ;", "result    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" double    1  .  0  \"  ,    result )  ;", "assertTrue ( filter . filterCalled )  ;", "filter . filterCalled    =    false ;", "context . setRootObject ( new   String (  \" abc \"  )  )  ;", "expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \" charAt (  0  )  \"  )  )  )  ;", "result    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" a \"  ,    result )  ;", "assertFalse ( filter . filterCalled )  ;", "filter . filterCalled    =    false ;", "context . registerMethodFilter (  . TestObject . class ,    null )  ;", "context . setRootObject ( new    . TestObject (  )  )  ;", "expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \" doit (  1  )  \"  )  )  )  ;", "result    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \"  1  \"  ,    result )  ;", "assertFalse ( filter . filterCalled )  ;", "}", "METHOD_END"], "methodName": ["testMethodFiltering_SPR6764"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "Expression    =    parser . parseExpression (  \" getName (  )  \"  )  ;", "Object   value    =    getValue ( new   StandardEvaluationContext ( String . class )  )  ;", "assertEquals (  \" String \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["testMethodOfClass"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \" throwException (  # bar )  \"  )  ;", "StandardEvaluationContext   eContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "eContext . setVariable (  \" bar \"  ,     3  )  ;", "Object   o    =    expr . getValue ( eContext )  ;", "assertEquals (  3  ,    o )  ;", "assertEquals (  1  ,    parser . parseExpression (  \" counter \"  )  . getValue ( eContext )  )  ;", "eContext . setVariable (  \" bar \"  ,    new   PlaceOfBirth (  \" London \"  )  )  ;", "o    =    expr . getValue ( eContext )  ;", "assertEquals (  \" London \"  ,    o )  ;", "eContext . setVariable (  \" bar \"  ,     3  )  ;", "o    =    expr . getValue ( eContext )  ;", "assertEquals (  3  ,    o )  ;", "assertEquals (  2  ,    parser . parseExpression (  \" counter \"  )  . getValue ( eContext )  )  ;", "eContext . setVariable (  \" bar \"  ,     1  )  ;", "try    {", "o    =    expr . getValue ( eContext )  ;", "fail (  )  ;", "}    catch    ( Exception   ex )     {", "if    ( ex   instanceof   SpelEvaluationException )     {", "fail (  (  \" Should   not   be   a   SpelEvaluationException :     \"     +    ex )  )  ;", "}", "}", "assertEquals (  3  ,    parser . parseExpression (  \" counter \"  )  . getValue ( eContext )  )  ;", "eContext . setVariable (  \" bar \"  ,     4  )  ;", "try    {", "o    =    expr . getValue ( eContext )  ;", "fail (  )  ;", "}    catch    ( Exception   ex )     {", "if    (  !  ( ex   instanceof   ExpressionargetException )  )     {", "fail (  (  \" Should   have   been   wrapped :     \"     +    ex )  )  ;", "}", "}", "assertEquals (  4  ,    parser . parseExpression (  \" counter \"  )  . getValue ( eContext )  )  ;", "}", "METHOD_END"], "methodName": ["testMethodThrowingException_SPR6760"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \" throwException (  # bar )  \"  )  ;", "context . setVariable (  \" bar \"  ,     2  )  ;", "try    {", "expr . getValue ( context )  ;", "fail (  )  ;", "}    catch    ( Exception   ex )     {", "if    ( ex   instanceof   SpelEvaluationException )     {", "fail (  (  \" Should   not   be   a   SpelEvaluationException :     \"     +    ex )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testMethodThrowingException_SPR6941"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \" throwException (  # bar )  \"  )  ;", "context . setVariable (  \" bar \"  ,     4  )  ;", "try    {", "expr . getValue ( context )  ;", "fail (  )  ;", "}    catch    ( ExpressionInvocationTargetException   ex )     {", "Throwable   cause    =    ex . getCause (  )  ;", "assertEquals (  \" testresources . Inventor $ TestException \"  ,    cause . getClass (  )  . getName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMethodThrowingException_SPR6941_2"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" name . madeup (  )  \"  ,    SpelMessage . METHOD _ NOT _ FOUND ,     5  )  ;", "}", "METHOD_END"], "methodName": ["testNonExistentMethods"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" getPlaceOfBirth (  )  . getCity (  )  \"  ,     \" SmilJan \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testSimpleAccess01"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String (  ' hello '  )  . charAt (  2  )  \"  ,     ' l '  ,    Character . class )  ;", "evaluate (  \" new   String (  ' hello '  )  . charAt (  2  )  . equals (  ' l '  . charAt (  0  )  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' HELLO '  . toLowerCase (  )  \"  ,     \" hello \"  ,    String . class )  ;", "evaluate (  \"  '          abcba    '  . trim (  )  \"  ,     \" abcba \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testStringClass"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" aVarargsMethod (  )  \"  ,     0  ,    Integer . class )  ;", "evaluate (  \" aVarargsMethod (  1  ,  2  ,  3  )  \"  ,     3  ,    Integer . class )  ;", "evaluate (  \" aVarargsMethod (  1  )  \"  ,     1  ,    Integer . class )  ;", "evaluate (  \" aVarargsMethod (  1  ,  ' a '  ,  3  .  0 d )  \"  ,     3  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testVarargsInvocation01"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" aVarargsMethod 2  (  5  ,  ' a '  ,  ' b '  ,  ' c '  )  \"  ,     8  ,    Integer . class )  ;", "evaluate (  \" aVarargsMethod 2  (  2  ,  ' a '  )  \"  ,     3  ,    Integer . class )  ;", "evaluate (  \" aVarargsMethod 2  (  4  )  \"  ,     4  ,    Integer . class )  ;", "evaluate (  \" aVarargsMethod 2  (  8  ,  2  ,  3  )  \"  ,     1  0  ,    Integer . class )  ;", "evaluate (  \" aVarargsMethod 2  (  9  )  \"  ,     9  ,    Integer . class )  ;", "evaluate (  \" aVarargsMethod 2  (  2  ,  ' a '  ,  3  .  0 d )  \"  ,     4  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testVarargsInvocation02"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   Double (  3  .  0 d )  . compareTo (  8  )  \"  ,     (  -  1  )  ,    Integer . class )  ;", "evaluate (  \" new   Double (  3  .  0 d )  . compareTo (  3  )  \"  ,     0  ,    Integer . class )  ;", "evaluate (  \" new   Double (  3  .  0 d )  . compareTo (  2  )  \"  ,     1  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testWidening01"], "fileName": "org.springframework.expression.spel.MethodInvocationTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  ' abc '  - true \"  ,    SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES )  ;", "StandardEvaluationContext   eContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "eContext . setOperatorOverloader ( new    . StringAndBooleanAddition (  )  )  ;", "SpelExpression   expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  ' abc '  + true \"  )  )  )  ;", "assertEquals (  \" abctrue \"  ,    expr . getValue ( eContext )  )  ;", "expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  ' abc '  - true \"  )  )  )  ;", "assertEquals (  \" abc \"  ,    expr . getValue ( eContext )  )  ;", "expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  ' abc '  + null \"  )  )  )  ;", "assertEquals (  \" abcnull \"  ,    expr . getValue ( eContext )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleOperations"], "fileName": "org.springframework.expression.spel.OperatorOverloaderTests"}, {"methodBody": ["METHOD_START", "{", "if    ( node   instanceof   Operator )     {", "return    (  ( Operator )     ( node )  )  ;", "}", "int   childCount    =    node . getChildCount (  )  ;", "for    ( int   i    =     0  ;    i    <    childCount ;    i +  +  )     {", "Operator   possible    =    findOperator ( node . getChild ( i )  )  ;", "if    ( possible    !  =    null )     {", "return   possible ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findOperator"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "SpelNode   node    =    expr . getAST (  )  ;", "return   find ( node )  ;", "}", "METHOD_END"], "methodName": ["getOperatorNode"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     +    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  8  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3     -    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  -  2  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3     *    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  1  5  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3     /    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  1  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  5     %    new   BigDecimal (  '  3  '  )  \"  ,    new   BigDecimal (  \"  2  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     %     3  \"  ,    new   BigDecimal (  \"  2  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     ^     3  \"  ,    new   BigDecimal (  \"  1  2  5  \"  )  ,    BigDecimal . class )  ;", "}", "METHOD_END"], "methodName": ["testBigDecimals"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     +    new   BigInteger (  '  5  '  )  \"  ,    new   BigInteger (  \"  8  \"  )  ,    BigInteger . class )  ;", "evaluate (  \"  3     -    new   BigInteger (  '  5  '  )  \"  ,    new   BigInteger (  \"  -  2  \"  )  ,    BigInteger . class )  ;", "evaluate (  \"  3     *    new   BigInteger (  '  5  '  )  \"  ,    new   BigInteger (  \"  1  5  \"  )  ,    BigInteger . class )  ;", "evaluate (  \"  3     /    new   BigInteger (  '  5  '  )  \"  ,    new   BigInteger (  \"  0  \"  )  ,    BigInteger . class )  ;", "evaluate (  \"  5     %    new   BigInteger (  '  3  '  )  \"  ,    new   BigInteger (  \"  2  \"  )  ,    BigInteger . class )  ;", "evaluate (  \" new   BigInteger (  '  5  '  )     %     3  \"  ,    new   BigInteger (  \"  2  \"  )  ,    BigInteger . class )  ;", "evaluate (  \" new   BigInteger (  '  5  '  )     ^     3  \"  ,    new   BigInteger (  \"  1  2  5  \"  )  ,    BigInteger . class )  ;", "}", "METHOD_END"], "methodName": ["testBigIntegers"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  .  0 f    /     5  .  0 f \"  ,     0  .  6 F ,    Float . class )  ;", "evaluate (  \"  4 L /  2 L \"  ,     2 L ,    Long . class )  ;", "evaluate (  \"  3  .  0 f   div    5  .  0 f \"  ,     0  .  6 F ,    Float . class )  ;", "evaluate (  \"  4 L   DIV    2 L \"  ,     2 L ,    Long . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     /     5  \"  ,    new   BigDecimal (  \"  1  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  .  0  '  )     /     5  \"  ,    new   BigDecimal (  \"  0  .  6  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  .  0  0  '  )     /     5  \"  ,    new   BigDecimal (  \"  0  .  6  0  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  .  0  0  '  )     /    new   BigDecimal (  '  5  .  0  0  0  0  '  )  \"  ,    new   BigDecimal (  \"  0  .  6  0  0  0  \"  )  ,    BigDecimal . class )  ;", "evaluateAndCheckError (  \"  ' abc '  /  ' def '  \"  ,    SpelMage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES )  ;", "}", "METHOD_END"], "methodName": ["testDivide"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  .  0 d    =  =     5  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    =  =     3  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    !  =     5  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    !  =     3  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    +     5  .  0 d \"  ,     8  .  0  ,    Double . class )  ;", "evaluate (  \"  3  .  0 d    -     5  .  0 d \"  ,     (  -  2  .  0  )  ,    Double . class )  ;", "evaluate (  \"  3  .  0 d    *     5  .  0 d \"  ,     1  5  .  0  ,    Double . class )  ;", "evaluate (  \"  3  .  0 d    /     5  .  0 d \"  ,     0  .  6  ,    Double . class )  ;", "evaluate (  \"  6  .  0 d    %     3  .  5 d \"  ,     2  .  5  ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["testDoubles"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     =  =     5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5     =  =     3  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  6     =  =     6  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f    =  =     5  .  0 f \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f    =  =     3  .  0 f \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     =  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     =  =    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     =  =    new   BigDecimal (  '  3  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3     =  =    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     =  =     5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L    =  =    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    =  =    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L    =  =    new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    =  =    new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    =  =    new   BigDecimal (  '  3  .  0  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f    =  =     3  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  1  0     =  =     '  1  0  '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     =  =     ' abc '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     =  =    new   StringBuilder (  ' abc '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     =  =     ' def '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     =  =    null \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new    $ SubComparable (  )     =  =    new    $ OtherSubComparable (  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3    eq    5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5    eQ    3  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  6    Eq    6  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f   eq    5  .  0 f \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f   EQ    3  .  0 f \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    eq   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    eq   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    eq   new   BigDecimal (  '  3  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3    eq   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    eq    5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L   eq   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   eq   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L   eq   new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   eq   new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   eq   new   BigDecimal (  '  3  .  0  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f   eq    3  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  1  0    eq    '  1  0  '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    eq    ' abc '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    eq   new   StringBuilder (  ' abc '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    eq    ' def '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    eq   null \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new    $ SubComparable (  )    eq   new    $ OtherSubComparable (  )  \"  ,    true ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testEqual"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     >     5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5     >     3  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    >     5 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5 L    >     3 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    >     5  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d    >     3  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     >    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     >    new   BigDecimal (  '  3  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3     >    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     >     5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L    >    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    >    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L    >    new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    >    new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    >    new   BigDecimal (  '  3  .  0  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     >     ' def '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     >    new   StBuilder (  ' def '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' def '     >     ' abc '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3    gt    5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5    gt    3  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L   gt    5 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5 L   gt    3 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   gt    5  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d   gT    3  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    gt   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    gt   new   BigDecimal (  '  3  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3    gt   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    gt    5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L   gt   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   gt   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L   gt   new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   gt   new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   gt   new   BigDecimal (  '  3  .  0  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    Gt    ' def '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    gt   new   StBuilder (  ' def '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' def '    GT    ' abc '  \"  ,    true ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testGreaterThan"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     >  =     5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5     >  =     3  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  6     >  =     6  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    >  =     5 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5 L    >  =     3 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5 L    >  =     5 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    >  =     5  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d    >  =     3  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d    >  =     5  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     >  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     >  =    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     >  =    new   BigDecimal (  '  3  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3     >  =    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     >  =     5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L    >  =    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    >  =    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L    >  =    new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    >  =    new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    >  =    new   BigDecimal (  '  3  .  0  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     >  =     ' def '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' def '     >  =     ' abc '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     >  =     ' abc '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3    GE    5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5    gE    3  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  6    Ge    6  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L   ge    5 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5 L   ge    3 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5 L   ge    5 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   ge    5  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d   ge    3  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d   ge    5  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    ge   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    ge   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    ge   new   BigDecimal (  '  3  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3    ge   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    ge    5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L   ge   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   ge   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L   ge   new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   ge   new   BigDecimal (  '  3  .  1  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   ge   new   BigDecimal (  '  3  .  0  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    ge    ' def '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' def '    ge    ' abc '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    ge    ' abc '  \"  ,    true ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testGreaterThanOrEqual"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  2     +     4  \"  ,     \"  6  \"  ,    Integer . class )  ;", "evaluate (  \"  5     -     4  \"  ,     \"  1  \"  ,    Integer . class )  ;", "evaluate (  \"  3     *     5  \"  ,     1  5  ,    Integer . class )  ;", "evaluate (  \"  3  .  2 d    *     5  \"  ,     1  6  .  0  ,    Double . class )  ;", "evaluate (  \"  3     *     5 f \"  ,     1  5  .  0 F ,    Float . class )  ;", "evaluate (  \"  3     /     1  \"  ,     3  ,    Integer . class )  ;", "evaluate (  \"  3     %     2  \"  ,     1  ,    Integer . class )  ;", "evaluate (  \"  3    mod    2  \"  ,     1  ,    Integer . class )  ;", "evaluate (  \"  3    mOd    2  \"  ,     1  ,    Integer . class )  ;", "evaluate (  \"  3    Mod    2  \"  ,     1  ,    Integer . class )  ;", "evaluate (  \"  3    MOD    2  \"  ,     1  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testIntegerArithmetic"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  \"  ,     3  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testIntegerLiteral"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  5     <     5  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3     <     5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5     <     3  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L    <     5 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5 L    <     3 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    <     5  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d    <     3  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     <    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     <    new   BigDecimal (  '  3  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3     <    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     <     5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    <    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    <    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    <    new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    <    new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    <    new   BigDecimal (  '  3  .  0  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     <     ' def '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     <    new   StBuilder (  ' def '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' def '     <     ' abc '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3    lt    5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5    lt    3  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L   lt    5 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5 L   lt    3 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   lT    5  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d   Lt    3  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    lt   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    lt   new   BigDecimal (  '  3  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3    lt   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    lt    5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L   lt   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   lt   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L   lt   new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   lt   new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   lt   new   BigDecimal (  '  3  .  0  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    LT    ' def '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    lt   new   StBuilder (  ' def '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' def '    lt    ' abc '  \"  ,    false ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testLessThan"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     <  =     5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5     <  =     3  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  6     <  =     6  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    <  =     5 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5 L    <  =     3 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5 L    <  =     5 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    <  =     5  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d    <  =     3  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d    <  =     5  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     <  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     <  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     <  =    new   BigDecimal (  '  3  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3     <  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     <  =     5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    <  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    <  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    <  =    new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    <  =    new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    <  =    new   BigDecimal (  '  3  .  0  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     <  =     ' def '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' def '     <  =     ' abc '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     <  =     ' abc '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3    le    5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5    le    3  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  6    Le    6  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L   lE    5 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5 L   LE    3 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5 L   le    5 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   LE    5  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d   lE    3  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  5  .  0 d   Le    5  .  0 d \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    le   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    le   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    le   new   BigDecimal (  '  3  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3    le   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    le    5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L   le   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   le   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L   le   new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   le   new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   le   new   BigDecimal (  '  3  .  0  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    Le    ' def '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' def '    LE    ' abc '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    le    ' abc '  \"  ,    true ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testLessThanOrEqual"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3 L    =  =     4 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L    =  =     3 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    !  =     4 L \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    !  =     3 L \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3 L    *     5  0 L \"  ,     1  5  0 L ,    Long . class )  ;", "evaluate (  \"  3 L    +     5  0 L \"  ,     5  3 L ,    Long . class )  ;", "evaluate (  \"  3 L    -     5  0 L \"  ,     (  -  4  7 L )  ,    Long . class )  ;", "}", "METHOD_END"], "methodName": ["testLongs"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' hello '     +     '     '     +     ' world '  \"  ,     \" hello   world \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorAdd02"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndAskForReturnType (  \"  8  /  4  \"  ,    new   Float (  2  .  0  )  ,    Float . class )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorDivide04_ConvertToFloat"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndAskForReturnType (  \"  8  /  4  \"  ,    new   Double (  2  .  0  )  ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorDivide_ConvertToDouble"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  1  +  2  +  3  \"  ,     6  ,    Integer . class )  ;", "evaluate (  \"  2  *  3  *  4  \"  ,     2  4  ,    Integer . class )  ;", "evaluate (  \"  1  2  -  1  -  2  \"  ,     9  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorsInChains"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' c '     -     2  \"  ,     \" a \"  ,    String . class )  ;", "evaluate (  \"  3  .  0 f    -     5  .  0 f \"  ,     (  -  2  .  0 F )  ,    Float . class )  ;", "evaluateAndCheckError (  \"  ' ab '     -     2  \"  ,    SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES )  ;", "evaluateAndCheckError (  \"  2  -  ' ab '  \"  ,    SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES )  ;", "SpelE   expr    =     (  ( SpelE )     ( parser . parseE (  \"  -  3  \"  )  )  )  ;", "assertEquals (  \"  -  3  \"  ,    expr . toStringAST (  )  )  ;", "expr    =     (  ( SpelE )     ( parser . parseE (  \"  2  -  3  \"  )  )  )  ;", "assertEquals (  \"  (  2     -     3  )  \"  ,    expr . toStringAST (  )  )  ;", "evaluate (  \"  -  5 d \"  ,     (  -  5  .  0  )  ,    Double . class )  ;", "evaluate (  \"  -  5 L \"  ,     (  -  5 L )  ,    Long . class )  ;", "evaluate (  \"  -  5  \"  ,     (  -  5  )  ,    Integer . class )  ;", "evaluate (  \"  - new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  -  5  \"  )  ,    BigDecimal . class )  ;", "evaluateAndCheckError (  \"  -  ' abc '  \"  ,    SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES )  ;", "}", "METHOD_END"], "methodName": ["testMinus"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     *    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  1  5  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3 L    *    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  1  5  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3  .  0 d    *    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  1  5  .  0  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3     +    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  8  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3 L    +    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  8  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3  .  0 d    +    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  8  .  0  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3     -    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  -  2  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3 L    -    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  -  2  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3  .  0 d    -    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  -  2  .  0  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3     /    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  1  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3     /    new   BigDecimal (  '  5  .  0  '  )  \"  ,    new   BigDecimal (  \"  0  .  6  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3     /    new   BigDecimal (  '  5  .  0  0  '  )  \"  ,    new   BigDecimal (  \"  0  .  6  0  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3 L    /    new   BigDecimal (  '  5  .  0  '  )  \"  ,    new   BigDecimal (  \"  0  .  6  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3  .  0 d    /    new   BigDecimal (  '  5  .  0  '  )  \"  ,    new   BigDecimal (  \"  0  .  6  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  5     %    new   BigDecimal (  '  3  '  )  \"  ,    new   BigDecimal (  \"  2  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3     %    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  3  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3 L    %    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  3  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  3  .  0 d    %    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  3  .  0  \"  )  ,    BigDecimal . class )  ;", "}", "METHOD_END"], "methodName": ["testMixedOperandsBigDecimal"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  .  0 d    +     5  \"  ,     8  .  0  ,    Double . class )  ;", "evaluate (  \"  3  .  0 D    -     5  \"  ,     (  -  2  .  0  )  ,    Double . class )  ;", "evaluate (  \"  3  .  0 f    *     5  \"  ,     1  5  .  0 F ,    Float . class )  ;", "evaluate (  \"  6  .  0 f    /     2  \"  ,     3  .  0 F ,    Float . class )  ;", "evaluate (  \"  6  .  0 f    /     4  \"  ,     1  .  5 F ,    Float . class )  ;", "evaluate (  \"  5  .  0 D    %     3  \"  ,     2  .  0  ,    Double . class )  ;", "evaluate (  \"  5  .  5 D    %     3  \"  ,     2  .  5  ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["testMixedOperands_DoublesAndInts"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  .  0 d    +     5  .  0 f \"  ,     8  .  0  ,    Double . class )  ;", "evaluate (  \"  3  .  0 D    -     5  .  0 f \"  ,     (  -  2  .  0  )  ,    Double . class )  ;", "evaluate (  \"  3  .  0 f    *     5  .  0 d \"  ,     1  5  .  0  ,    Double . class )  ;", "evaluate (  \"  3  .  0 f    /     5  .  0 D \"  ,     0  .  6  ,    Double . class )  ;", "evaluate (  \"  5  .  0 D    %     3 f \"  ,     2  .  0  ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["testMixedOperands_FloatsAndDoubles"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  %  2  \"  ,     1  ,    Integer . class )  ;", "evaluate (  \"  3 L %  2 L \"  ,     1 L ,    Long . class )  ;", "evaluate (  \"  3  .  0 f %  2  .  0 f \"  ,     1  .  0 F ,    Float . class )  ;", "evaluate (  \"  5  .  0 d    %     3  .  1 d \"  ,     1  .  9  ,    Double . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     %    new   BigDecimal (  '  3  '  )  \"  ,    new   BigDecimal (  \"  2  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     %     3  \"  ,    new   BigDecimal (  \"  2  \"  )  ,    BigDecimal . class )  ;", "evaluateAndCheckError (  \"  ' abc '  %  ' def '  \"  ,    SpelMage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES )  ;", "}", "METHOD_END"], "methodName": ["testModulus"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  .  0 d    *     5  .  0 d \"  ,     1  5  .  0  ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["testMultiplyDoubleDoubleGivesDouble"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' a '     *     5  \"  ,     \" aaaaa \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testMultiplyStringInt"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3     !  =     5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5     !  =     3  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  6     !  =     6  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f    !  =     5  .  0 f \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f    !  =     3  .  0 f \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     !  =    new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     !  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     !  =    new   BigDecimal (  '  3  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3     !  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )     !  =     5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    !  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    !  =    new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L    !  =    new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    !  =    new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d    !  =    new   BigDecimal (  '  3  .  0  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f    !  =     3  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  1  0     !  =     '  1  0  '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     !  =     ' abc '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     !  =    new   StringBuilder (  ' abc '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     !  =     ' def '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     !  =    null \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new    $ SubComparable (  )     !  =    new    $ OtherSubComparable (  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3    ne    5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  5    nE    3  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  6    Ne    6  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f   NE    5  .  0 f \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f   ne    3  .  0 f \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    ne   new   BigDecimal (  '  5  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    ne   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )    ne   new   BigDecimal (  '  3  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3    ne   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new   BigDecimal (  '  3  '  )    ne    5  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L   ne   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   ne   new   BigDecimal (  '  5  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3 L   ne   new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   ne   new   BigDecimal (  '  3  .  1  '  )  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 d   ne   new   BigDecimal (  '  3  .  0  '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  3  .  0 f   ne    3  .  0 d \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  1  0    ne    '  1  0  '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    ne    ' abc '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    ne   new   StringBuilder (  ' abc '  )  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    ne    ' def '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '    ne   null \"  ,    true ,    Boolean . class )  ;", "evaluate (  \" new    $ SubComparable (  )    ne   new    $ OtherSubComparable (  )  \"  ,    false ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testNotEqual"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "Operator   node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  1  =  =  3  \"  )  )  )  )  ;", "assertEquals (  \"  =  =  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  1  !  =  3  \"  )  )  )  )  ;", "assertEquals (  \"  !  =  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3  /  3  \"  )  )  )  )  ;", "assertEquals (  \"  /  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3  +  3  \"  )  )  )  )  ;", "assertEquals (  \"  +  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3  -  3  \"  )  )  )  )  ;", "assertEquals (  \"  -  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3  <  4  \"  )  )  )  )  ;", "assertEquals (  \"  <  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3  <  =  4  \"  )  )  )  )  ;", "assertEquals (  \"  <  =  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3  *  4  \"  )  )  )  )  ;", "assertEquals (  \"  *  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3  %  4  \"  )  )  )  )  ;", "assertEquals (  \"  %  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3  >  =  4  \"  )  )  )  )  ;", "assertEquals (  \"  >  =  \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3    between    4  \"  )  )  )  )  ;", "assertEquals (  \" between \"  ,    node . getOperatorName (  )  )  ;", "node    =    getOperatorNode (  (  ( SpelExpression )     ( parser . parseExpression (  \"  3     ^     4  \"  )  )  )  )  ;", "assertEquals (  \"  ^  \"  ,    node . getOperatorName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOperatorNames"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \"  ' a '     *     '  2  '  \"  ,    SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES )  ;", "evaluateAndCheckError (  \"  ' a '     ^     '  2  '  \"  ,    SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES )  ;", "}", "METHOD_END"], "methodName": ["testOperatorOverloading"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  7     +     2  \"  ,     \"  9  \"  ,    Integer . class )  ;", "evaluate (  \"  3  .  0 f    +     5  .  0 f \"  ,     8  .  0 F ,    Float . class )  ;", "evaluate (  \"  3  .  0 d    +     5  .  0 d \"  ,     8  .  0  ,    Double . class )  ;", "evaluate (  \"  3     +    new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  8  \"  )  ,    BigDecimal . class )  ;", "evaluate (  \"  ' ab '     +     2  \"  ,     \" ab 2  \"  ,    String . class )  ;", "evaluate (  \"  2     +     ' a '  \"  ,     \"  2 a \"  ,    String . class )  ;", "evaluate (  \"  ' ab '     +    null \"  ,     \" abnull \"  ,    String . class )  ;", "evaluate (  \" null    +     ' ab '  \"  ,     \" nullab \"  ,    String . class )  ;", "SpelE   expr    =     (  ( SpelE )     ( parser . parseE (  \"  +  3  \"  )  )  )  ;", "assertEquals (  \"  +  3  \"  ,    expr . toStringAST (  )  )  ;", "expr    =     (  ( SpelE )     ( parser . parseE (  \"  2  +  3  \"  )  )  )  ;", "assertEquals (  \"  (  2     +     3  )  \"  ,    expr . toStringAST (  )  )  ;", "evaluate (  \"  +  5 d \"  ,     5  .  0  ,    Double . class )  ;", "evaluate (  \"  +  5 L \"  ,     5 L ,    Long . class )  ;", "evaluate (  \"  +  5  \"  ,     5  ,    Integer . class )  ;", "evaluate (  \"  + new   BigDecimal (  '  5  '  )  \"  ,    new   BigDecimal (  \"  5  \"  )  ,    BigDecimal . class )  ;", "evaluateAndCheckError (  \"  +  ' abc '  \"  ,    SpelMessage . OPERATOR _ NOT _ SUPPORTED _ BETWEEN _ TYPES )  ;", "evaluate (  \"  ' abc '  +  ' def '  \"  ,     \" abcdef \"  ,    String . class )  ;", "evaluate (  \"  5     +    new   Integer (  '  3  7  '  )  \"  ,     4  2  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testPlus"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  ^  2  \"  ,     9  ,    Integer . class )  ;", "evaluate (  \"  3  .  0 d ^  2  .  0 d \"  ,     9  .  0  ,    Double . class )  ;", "evaluate (  \"  3 L ^  2 L \"  ,     9 L ,    Long . class )  ;", "evaluate (  \"  (  2  ^  3  2  )  ^  2  \"  ,     9  2  2  3  3  7  2  0  3  6  8  5  4  7  7  5  8  0  7 L ,    Long . class )  ;", "evaluate (  \" new   BigDecimal (  '  5  '  )     ^     3  \"  ,    new   BigDecimal (  \"  1  2  5  \"  )  ,    BigDecimal . class )  ;", "}", "METHOD_END"], "methodName": ["testPower"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  3  .  5  \"  ,     3  .  5  ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["testRealLiteral"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' abc '     =  =     ' abc '  \"  ,    true ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     =  =     ' def '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     !  =     ' abc '  \"  ,    false ,    Boolean . class )  ;", "evaluate (  \"  ' abc '     !  =     ' def '  \"  ,    true ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testStrings"], "fileName": "org.springframework.expression.spel.OperatorTests"}, {"methodBody": ["METHOD_START", "{", "parseAndCheckError (  \"  0 xCAFEBABE \"  ,    SpelMessage . NOT _ AN _ INTEGER )  ;", "evaluate (  \"  0 xCAFEBABEL \"  ,     3  4  0  5  6  9  1  5  8  2 L ,    Long . class )  ;", "parseAndCheckError (  \"  0 xCAFEBABECAFEBABEL \"  ,    SpelMessage . NOT _ A _ LONG )  ;", "}", "METHOD_END"], "methodName": ["testBrokenExpression01"], "fileName": "org.springframework.expression.spel.ParserErrorMessagesTests"}, {"methodBody": ["METHOD_START", "{", "parseAndCheckError (  \"  0 xB 0 BG \"  ,    SpelMessage . MORE _ INPUT ,     5  ,     \" G \"  )  ;", "}", "METHOD_END"], "methodName": ["testBrokenExpression02"], "fileName": "org.springframework.expression.spel.ParserErrorMessagesTests"}, {"methodBody": ["METHOD_START", "{", "parseAndCheckError (  \" true   or    \"  ,    SpelMessage . RIGHT _ OPERAND _ PROBLEM ,     5  )  ;", "}", "METHOD_END"], "methodName": ["testBrokenExpression04"], "fileName": "org.springframework.expression.spel.ParserErrorMessagesTests"}, {"methodBody": ["METHOD_START", "{", "parseAndCheckError (  \"  1     +     \"  ,    SpelMessage . RIGHT _ OPERAND _ PROBLEM ,     2  )  ;", "}", "METHOD_END"], "methodName": ["testBrokenExpression05"], "fileName": "org.springframework.expression.spel.ParserErrorMessagesTests"}, {"methodBody": ["METHOD_START", "{", "parseAndCheckError (  \" null   instanceof   T (  ' a '  )  \"  ,    SpelMessage . NOT _ EXPECTED _ TOKEN ,     1  8  ,     \" qualified   ID \"  ,     \" literal _ string \"  )  ;", "}", "METHOD_END"], "methodName": ["testBrokenExpression07"], "fileName": "org.springframework.expression.spel.ParserErrorMessagesTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck ( expression ,    expression )  ;", "}", "METHOD_END"], "methodName": ["parseCheck"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "SpelExpression   e    =    parser . parseRaw (  )  ;", "if    (  ( e    !  =    null )     &  &     (  !  ( e . toStringAST (  )  . equals ( expectedStringFormOfAST )  )  )  )     {", "SpelUtilities . printAbstractSyntaxTree ( System . err ,    e )  ;", "}", "if    ( e    =  =    null )     {", "fail (  \" Parsed   exception   was   null \"  )  ;", "}", "assertEquals (  \" String   form   of   AST   does   not   match   expected   output \"  ,    expectedStringFormOfAST ,    e . toStringAST (  )  )  ;", "}    catch    ( ParseException   ee )     {", "ee . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( ee . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseCheck"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  # var 1  =  ' value 1  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAssignmentToVariables01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" false   or   true   and   false \"  ,     \"  ( false   or    ( true   and   false )  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanOperatorsMix01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" false   or   false \"  ,     \"  ( false   or   false )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanOperatorsOr01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" false   or   true \"  ,     \"  ( false   or   true )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanOperatorsOr02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" true   or   false \"  ,     \"  ( true   or   false )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanOperatorsOr03"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" true   or   false \"  ,     \"  ( true   or   false )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanOperatorsOr04"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" new   String (  ' hello '  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testConstructors01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  3  ?  :  1  \"  ,     \"  3     ?  :     1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testElvis"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  # fn (  1  ,  2  ,  3  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testFunctions01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  # fn (  ' hello '  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testFunctions02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  {  1  ,  2  ,  3  ,  4  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testInlineList1"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  {  1  ,     2  ,     3  ,     4  ,     5  }  \"  ,     \"  {  1  ,  2  ,  3  ,  4  ,  5  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testInlineListCreation01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  {  ' abc '  ,  ' xyz '  }  \"  ,     \"  {  ' abc '  ,  ' xyz '  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testInlineListCreation02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  {  ' key 1  '  :  ' Value    1  '  ,  ' today '  : DateTime . Today }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapCreation01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  {  1  :  ' January '  ,  2  :  ' February '  ,  3  :  ' March '  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testInlineMapCreation02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" false \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralBoolean01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" true \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralBoolean02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  ! true \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralBoolean03"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" date (  '  1  9  7  4  /  0  8  /  2  4  '  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralDate01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" date (  '  1  9  7  4  0  8  2  4 T 1  3  1  0  3  0  '  ,  ' yyyyMMddTHHmmss '  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralDate02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  0 x 7 FFFFFFF \"  ,     \"  2  1  4  7  4  8  3  6  4  7  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralHex01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralInteger01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  1  4  1  5  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralInteger02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  3  7 L \"  ,     \"  3  7  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralLong01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" null \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralNull01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  6  .  0  2  2  1  4  1  5 E +  2  3  \"  ,     \"  6  .  0  2  2  1  4  1  5 E 2  3  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralReal01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  ' hello '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralString01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  ' joe   bloggs '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralString02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  ' Tony '  ' s   Pizza '  \"  ,     \"  ' Tony ' s   Pizza '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralString03"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  7     %     4  \"  ,     \"  (  7     %     4  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorModulus01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  2  +  4  \"  ,     \"  (  2     +     4  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorsAdd01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  ' a '  +  ' b '  \"  ,     \"  (  ' a '     +     ' b '  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorsAdd02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  ' hello '  +  '     '  +  ' world '  \"  ,     \"  (  (  ' hello '     +     '     '  )     +     ' world '  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorsAdd03"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  8  /  4  \"  ,     \"  (  8     /     4  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorsDivide01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  7  *  4  \"  ,     \"  (  7     *     4  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorsMultiply01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  5  -  4  \"  ,     \"  (  5     -     4  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMathOperatorsSubtract01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" echo (  1  2  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMethods01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" echo ( name )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMethods02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" age . doubleItAndAdd (  1  2  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMethods03"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" true   and    5  >  3  \"  ,     \"  ( true   and    (  5     >     3  )  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testMixedOperators01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" name \"  )  ;", "}", "METHOD_END"], "methodName": ["testProperties01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" placeofbirth . CitY \"  )  ;", "}", "METHOD_END"], "methodName": ["testProperties02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" a . b . c . d . e \"  )  ;", "}", "METHOD_END"], "methodName": ["testProperties03"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  @ foo \"  )  ;", "parseCheck (  \"  @  ' foo . bar '  \"  )  ;", "parseCheck (  \"  @  \\  \" foo . bar . goo \\  \"  \"  ,     \"  @  ' foo . bar . goo '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testReferences01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  @  $  $ foo \"  )  ;", "}", "METHOD_END"], "methodName": ["testReferences03"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  3  >  =  6  \"  ,     \"  (  3     >  =     6  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsGE01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  3  >  =  3  \"  ,     \"  (  3     >  =     3  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsGE02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  3  >  6  \"  ,     \"  (  3     >     6  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsGT01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  ' xyz '    instanceof   int \"  ,     \"  (  ' xyz '    instanceof   int )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsIs01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  3  <  =  6  \"  ,     \"  (  3     <  =     6  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsLE01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  3  <  6  \"  ,     \"  (  3     <     6  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsLT01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  \\  '  5  .  0  0  6  7  \\  '    matches    \\  '  ^  -  ?  \\  \\ d +  (  \\  \\  .  \\  \\ d {  2  }  )  ?  $  \\  '  \"  ,     \"  (  \\  '  5  .  0  0  6  7  \\  '    matches    \\  '  ^  -  ?  \\  \\ d +  (  \\  \\  .  \\  \\ d {  2  }  )  ?  $  \\  '  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsMatches01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  \\  '  5  .  0  0  \\  '    matches    \\  '  ^  -  ?  \\  \\ d +  (  \\  \\  .  \\  \\ d {  2  }  )  ?  $  \\  '  \"  ,     \"  (  \\  '  5  .  0  0  \\  '    matches    \\  '  ^  -  ?  \\  \\ d +  (  \\  \\  .  \\  \\ d {  2  }  )  ?  $  \\  '  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRelOperatorsMatches02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  1  >  2  ?  3  :  4  \"  ,     \"  (  1     >     2  )     ?     3     :     4  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTernaryOperator01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" T ( String )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTypeReferences01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \" T ( String )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTypeReferences02"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "parseCheck (  \"  # foo \"  )  ;", "}", "METHOD_END"], "methodName": ["testVariables01"], "fileName": "org.springframework.expression.spel.ParsingTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "long   starttime    =     0  ;", "long   endtime    =     0  ;", "for    ( int   i    =     0  ;    i    <     (  . ITERATIONS )  ;    i +  +  )     {", "Expression   expr    =     . parser . parseExpression (  \" getPlaceOfBirth (  )  . getCity (  )  \"  )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "expr . getValue (  . eContext )  ;", "}", "starttime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     (  . ITERATIONS )  ;    i +  +  )     {", "Expression   expr    =     . parser . parseExpression (  \" getPlaceOfBirth (  )  . getCity (  )  \"  )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "expr . getValue (  . eContext )  ;", "}", "endtime    =    System . currentTimeMillis (  )  ;", "long   freshParseTime    =    endtime    -    starttime ;", "if    (  . DEBUG )     {", "System . out . println (  (  (  \" MethodExpression :    Time   for   parsing   and   evaluation   x    1  0  0  0  0  :     \"     +    freshParseTime )     +     \" ms \"  )  )  ;", "}", "Expression   expr    =     . parser . parseExpression (  \" getPlaceOfBirth (  )  . getCity (  )  \"  )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "starttime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     (  . ITERATIONS )  ;    i +  +  )     {", "expr . getValue (  . eContext )  ;", "}", "endtime    =    System . currentTimeMillis (  )  ;", "long   reuseTime    =    endtime    -    starttime ;", "if    (  . DEBUG )     {", "System . out . println (  (  (  \" MethodExpression :    Time   for   just   evaluation   x    1  0  0  0  0  :     \"     +    reuseTime )     +     \" ms \"  )  )  ;", "}", "if    ( reuseTime    >    freshParseTime )     {", "System . out . println (  (  (  \" Fresh   parse   every   time ,    ITERATIONS   iterations    =     \"     +    freshParseTime )     +     \" ms \"  )  )  ;", "System . out . println (  (  (  \" Reuse   SpelExpression ,    ITERATIONS   iterations    =     \"     +    reuseTime )     +     \" ms \"  )  )  ;", "fail (  \" Should   have   been   quicker   to   reuse !  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformanceOfMethodAccess"], "fileName": "org.springframework.expression.spel.PerformanceTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "long   starttime    =     0  ;", "long   endtime    =     0  ;", "for    ( int   i    =     0  ;    i    <     (  . ITERATIONS )  ;    i +  +  )     {", "Expression   expr    =     . parser . parseExpression (  \" placeOfBirth . city \"  )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "expr . getValue (  . eContext )  ;", "}", "starttime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     (  . ITERATIONS )  ;    i +  +  )     {", "Expression   expr    =     . parser . parseExpression (  \" placeOfBirth . city \"  )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "expr . getValue (  . eContext )  ;", "}", "endtime    =    System . currentTimeMillis (  )  ;", "long   freshParseTime    =    endtime    -    starttime ;", "if    (  . DEBUG )     {", "System . out . println (  (  (  \" PropertyAccess :    Time   for   parsing   and   evaluation   x    1  0  0  0  0  :     \"     +    freshParseTime )     +     \" ms \"  )  )  ;", "}", "Expression   expr    =     . parser . parseExpression (  \" placeOfBirth . city \"  )  ;", "if    ( expr    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "starttime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     (  . ITERATIONS )  ;    i +  +  )     {", "expr . getValue (  . eContext )  ;", "}", "endtime    =    System . currentTimeMillis (  )  ;", "long   reuseTime    =    endtime    -    starttime ;", "if    (  . DEBUG )     {", "System . out . println (  (  (  \" PropertyAccess :    Time   for   just   evaluation   x    1  0  0  0  0  :     \"     +    reuseTime )     +     \" ms \"  )  )  ;", "}", "if    ( reuseTime    >    freshParseTime )     {", "System . out . println (  (  (  \" Fresh   parse   every   time ,    ITERATIONS   iterations    =     \"     +    freshParseTime )     +     \" ms \"  )  )  ;", "System . out . println (  (  (  \" Reuse   SpelExpression ,    ITERATIONS   iterations    =     \"     +    reuseTime )     +     \" ms \"  )  )  ;", "fail (  \" Should   have   been   quicker   to   reuse !  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformanceOfPropertyAccess"], "fileName": "org.springframework.expression.spel.PerformanceTests"}, {"methodBody": ["METHOD_START", "{", "if    ( ex   instanceof   SpelEvaluationException )     {", "SpelMessage   sm    =     (  ( SpelEvaluationException )     ( ex )  )  . getMessageCode (  )  ;", "assertEquals (  \" Expected   exception   type   did   not   occur \"  ,    expectedMessage ,    sm )  ;", "} else    {", "fail (  (  \" Should   be   a   SpelException    \"     +    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkException"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    SimpleEvaluationContext . forReadOnlyDataBinding (  )  . build (  )  ;", "parser . parseE (  \"  ' a '  . class . name \"  )  . getValue ( context )  ;", "}", "METHOD_END"], "methodName": ["noGetClassAccess"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    SimpleEvaluationContext . forReadOnlyDataBinding (  )  . withInstanceMethods (  )  . build (  )  ;", "Person   target    =    new   Person (  \" p 1  \"  )  ;", "assertEquals (  \"  1  \"  ,    parser . parseE (  \" name . substring (  1  )  \"  )  . getValue ( context ,    target )  )  ;", "}", "METHOD_END"], "methodName": ["propertyAccessWithInstanceMethodResolver"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "Person   target    =    new   Person (  \" p 1  \"  )  ;", "EvaluationContext   context    =    SimpleEvaluationContext . forReadOnlyDataBinding (  )  . withInstanceMethods (  )  . withTypedRootObject ( target ,    TypeDescriptor . valueOf ( Object . class )  )  . build (  )  ;", "assertEquals (  \"  1  \"  ,    parser . parseE (  \" name . substring (  1  )  \"  )  . getValue ( context ,    target )  )  ;", "assertSame ( target ,    context . getRootObject (  )  . getValue (  )  )  ;", "assertSame ( Object . class ,    context . getRootObject (  )  . getTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyAccessWithInstanceMethodResolverAndTypedRootObject"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    SimpleEvaluationContext . forReadOnlyDataBinding (  )  . build (  )  ;", "Person   target    =    new   Person (  \" p 1  \"  )  ;", "try    {", "parser . parseE (  \" name . substring (  1  )  \"  )  . getValue ( context ,    target )  ;", "fail (  \" Should   have   thrown   SpelEvaluationException \"  )  ;", "}    catch    ( SpelEvaluationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["propertyAccessWithoutMethodResolver"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    SimpleEvaluationContext . forReadOnlyDataBinding (  )  . build (  )  ;", "E   expr    =    parser . parseE (  \" name \"  )  ;", "Person   target    =    new   Person (  \" p 1  \"  )  ;", "assertEquals (  \" p 1  \"  ,    expr . getValue ( context ,    target )  )  ;", "target . setName (  \" p 2  \"  )  ;", "assertEquals (  \" p 2  \"  ,    expr . getValue ( context ,    target )  )  ;", "try    {", "parser . parseE (  \" name =  ' p 3  '  \"  )  . getValue ( context ,    target )  ;", "fail (  \" Should   have   thrown   SpelEvaluationException \"  )  ;", "}    catch    ( SpelEvaluationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["propertyReadOnly"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    SimpleEvaluationContext . forReadWriteDataBinding (  )  . build (  )  ;", "E   expr    =    parser . parseE (  \" name \"  )  ;", "Person   target    =    new   Person (  \" p 1  \"  )  ;", "assertEquals (  \" p 1  \"  ,    expr . getValue ( context ,    target )  )  ;", "target . setName (  \" p 2  \"  )  ;", "assertEquals (  \" p 2  \"  ,    expr . getValue ( context ,    target )  )  ;", "parser . parseE (  \" name =  ' p 3  '  \"  )  . getValue ( context ,    target )  ;", "assertEquals (  \" p 3  \"  ,    target . getName (  )  )  ;", "assertEquals (  \" p 3  \"  ,    expr . getValue ( context ,    target )  )  ;", "expr . setValue ( context ,    target ,     \" p 4  \"  )  ;", "assertEquals (  \" p 4  \"  ,    target . getName (  )  )  ;", "assertEquals (  \" p 4  \"  ,    expr . getValue ( context ,    target )  )  ;", "}", "METHOD_END"], "methodName": ["propertyReadWrite"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "Person   target    =    new   Person (  \" p 1  \"  )  ;", "EvaluationContext   context    =    SimpleEvaluationContext . forReadWriteDataBinding (  )  . withRootObject ( target )  . build (  )  ;", "assertSame ( target ,    context . getRootObject (  )  . getValue (  )  )  ;", "E   expr    =    parser . parseE (  \" name \"  )  ;", "assertEquals (  \" p 1  \"  ,    expr . getValue ( context ,    target )  )  ;", "target . setName (  \" p 2  \"  )  ;", "assertEquals (  \" p 2  \"  ,    expr . getValue ( context ,    target )  )  ;", "parser . parseE (  \" name =  ' p 3  '  \"  )  . getValue ( context ,    target )  ;", "assertEquals (  \" p 3  \"  ,    target . getName (  )  )  ;", "assertEquals (  \" p 3  \"  ,    expr . getValue ( context ,    target )  )  ;", "expr . setValue ( context ,    target ,     \" p 4  \"  )  ;", "assertEquals (  \" p 4  \"  ,    target . getName (  )  )  ;", "assertEquals (  \" p 4  \"  ,    expr . getValue ( context ,    target )  )  ;", "}", "METHOD_END"], "methodName": ["propertyReadWriteWithRootObject"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" name \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . addPropertyAccessor ( new    . ConfigurablePropertyAccessor ( Collections . singletonMap (  \" name \"  ,     \" Ollie \"  )  )  )  ;", "assertEquals (  \" Ollie \"  ,    expression . getValue ( context )  )  ;", "context    =    new   StandardEvaluationContext (  )  ;", "context . addPropertyAccessor ( new    . ConfigurablePropertyAccessor ( Collections . singletonMap (  \" name \"  ,     \" Jens \"  )  )  )  ;", "assertEquals (  \" Jens \"  ,    expression . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["shouldAlwaysUsePropertyAccessorFromEvaluationContext"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( String . class . getName (  )  ,    parser . parseExpression (  \"  ' a '  . class . name \"  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["standardGetClassAccess"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \" madeup \"  )  )  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( null )  ;", "try    {", "expr . getValue ( context )  ;", "fail (  \" Should   have   failed    -    default   property   resolver   cannot   resolve   on   null \"  )  ;", "}    catch    ( Exception   ex )     {", "checkException ( ex ,    SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ READABLE _ ON _ NULL )  ;", "}", "assertFalse ( expr . isWritable ( context )  )  ;", "try    {", "expr . setValue ( context ,     \" abc \"  )  ;", "fail (  \" Should   have   failed    -    default   property   resolver   cannot   resolve   on   null \"  )  ;", "}    catch    ( Exception   ex )     {", "checkException ( ex ,    SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ WRITABLE _ ON _ NULL )  ;", "}", "}", "METHOD_END"], "methodName": ["testAccessingOnNullObject"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "Expression    =    parser . parseExpression (  \" name \"  )  ;", "Object   value    =    getValue ( new   StandardEvaluationContext ( String . class )  )  ;", "assertEquals (  \" String \"  ,    value )  ;", "}", "METHOD_END"], "methodName": ["testAccessingPropertyOfClass"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "List < PropertyAccessor >    propertyAccessors    =    ctx . getPropertyAccessors (  )  ;", "assertEquals (  1  ,    propertyAccessors . size (  )  )  ;", ". StringyPropertyAccessor   spa    =    new    . StringyPropertyAccessor (  )  ;", "ctx . addPropertyAccessor ( spa )  ;", "assertEquals (  2  ,    ctx . getPropertyAccessors (  )  . size (  )  )  ;", "List < PropertyAccessor >    copy    =    new   ArrayList <  >  (  )  ;", "copy . addAll ( ctx . getPropertyAccessors (  )  )  ;", "assertTrue ( ctx . removePropertyAccessor ( spa )  )  ;", "assertFalse ( ctx . removePropertyAccessor ( spa )  )  ;", "assertEquals (  1  ,    ctx . getPropertyAccessors (  )  . size (  )  )  ;", "ctx . setPropertyAccessors ( copy )  ;", "assertEquals (  2  ,    ctx . getPropertyAccessors (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAddingRemovingAccessors"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . addPropertyAccessor ( new    . StringyPropertyAccessor (  )  )  ;", "Expression   expr    =    parser . parseRaw (  \" new   String (  ' hello '  )  . flibbles \"  )  ;", "Integer   i    =    expr . getValue ( ctx ,    Integer . class )  ;", "assertEquals (  7  ,     (  ( int )     ( i )  )  )  ;", "expr    =    parser . parseRaw (  \" new   String (  ' hello '  )  . CASE _ INSENSITIVE _ ORDER \"  )  ;", "Object   o    =    expr . getValue ( ctx )  ;", "assertNotNull ( o )  ;", "expr    =    parser . parseRaw (  \" new   String (  ' hello '  )  . flibbles \"  )  ;", "expr . setValue ( ctx ,     9  9  )  ;", "i    =    expr . getValue ( ctx ,    Integer . class )  ;", "assertEquals (  9  9  ,     (  ( int )     ( i )  )  )  ;", "try    {", "expr . setValue ( ctx ,     \" not   allowed \"  )  ;", "fail (  \" Should   not   have   been   allowed \"  )  ;", "}    catch    ( EvaluationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testAddingSpecificPropertyAccessor"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "evaluateAndCheckError (  \" madeup \"  ,    SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ READABLE ,     0  )  ;", "evaluateAndCheckError (  \" name . foobar \"  ,    SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ READABLE ,     5  )  ;", "}", "METHOD_END"], "methodName": ["testNonExistentPropertiesAndMethods"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" name \"  ,     \" Nikola   Tesla \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testSimpleAccess01"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" placeOfBirth . city \"  ,     \" SmilJan \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testSimpleAccess02"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" stringArrayOfThreeItems . length \"  ,     \"  3  \"  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testSimpleAccess03"], "fileName": "org.springframework.expression.spel.PropertyAccessTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "Expression   expr    =    parser . parseRaw (  \" hasAnyRole (  ' MANAGER '  ,  ' TELLER '  )  \"  )  ;", "ctx . setRootObject ( new    . Person (  \" Ben \"  )  )  ;", "Boolean   value    =    expr . getValue ( ctx ,    Boolean . class )  ;", "assertFalse ( value )  ;", "ctx . setRootObject ( new    . Manager (  \" Luke \"  )  )  ;", "value    =    expr . getValue ( ctx ,    Boolean . class )  ;", "assertTrue ( value )  ;", "}    catch    ( EvaluationException   ee )     {", "ee . printStackTrace (  )  ;", "fail (  (  \" Unexpected   SpelException :     \"     +     ( ee . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testScenario01_Roles"], "fileName": "org.springframework.expression.spel.ScenariosForSpringSecurity"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . addPropertyAccessor ( new    . SecurityPrincipalAccessor (  )  )  ;", "Expression   expr    =    parser . parseRaw (  \" name    =  =    principal . name \"  )  ;", "ctx . setRootObject ( new    . Person (  \" Andy \"  )  )  ;", "Boolean   value    =    expr . getValue ( ctx ,    Boolean . class )  ;", "assertTrue ( value )  ;", "ctx . setRootObject ( new    . Person (  \" Christian \"  )  )  ;", "value    =    expr . getValue ( ctx ,    Boolean . class )  ;", "assertFalse ( value )  ;", "expr    =    parser . parseRaw (  \" p . name    =  =    principal . name \"  )  ;", ". PersonAccessor   pAccessor    =    new    . PersonAccessor (  )  ;", "ctx . addPropertyAccessor ( pAccessor )  ;", "ctx . setRootObject ( null )  ;", "pAccessor . setPerson ( new    . Person (  \" Andy \"  )  )  ;", "value    =    expr . getValue ( ctx ,    Boolean . class )  ;", "assertTrue ( value )  ;", "pAccessor . setPerson ( new    . Person (  \" Christian \"  )  )  ;", "value    =    expr . getValue ( ctx ,    Boolean . class )  ;", "assertFalse ( value )  ;", "}", "METHOD_END"], "methodName": ["testScenario02_ComparingNames"], "fileName": "org.springframework.expression.spel.ScenariosForSpringSecurity"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "Expression   expr    =    parser . parseRaw (  \"  ( hasRole (  ' SUPERVISOR '  )    or    (  # a    <        1  .  0  4  2  )  )    and   hasIpAddress (  '  1  0  .  1  0  .  0  .  0  /  1  6  '  )  \"  )  ;", "Boolean   value    =    null ;", "ctx . setVariable (  \" a \"  ,     1  .  0  )  ;", "ctx . setRootObject ( new    . Supervisor (  \" Ben \"  )  )  ;", "value    =    expr . getValue ( ctx ,    Boolean . class )  ;", "assertTrue ( value )  ;", "ctx . setRootObject ( new    . Manager (  \" Luke \"  )  )  ;", "ctx . setVariable (  \" a \"  ,     1  .  0  4  3  )  ;", "value    =    expr . getValue ( ctx ,    Boolean . class )  ;", "assertFalse ( value )  ;", "}", "METHOD_END"], "methodName": ["testScenario03_Arithmetic"], "fileName": "org.springframework.expression.spel.ScenariosForSpringSecurity"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setRootObject ( new    . Supervisor (  \" Ben \"  )  )  ;", "ctx . addMethodResolver ( new    . MyMethodResolver (  )  )  ;", "Expression   expr    =    parser . parseRaw (  \"  ( hasRole (  3  )    or    (  # a    <        1  .  0  4  2  )  )    and   hasIpAddress (  '  1  0  .  1  0  .  0  .  0  /  1  6  '  )  \"  )  ;", "Boolean   value    =    null ;", "ctx . setVariable (  \" a \"  ,     1  .  0  )  ;", "value    =    expr . getValue ( ctx ,    Boolean . class )  ;", "assertTrue ( value )  ;", "}", "METHOD_END"], "methodName": ["testScenario04_ControllingWhichMethodsRun"], "fileName": "org.springframework.expression.spel.ScenariosForSpringSecurity"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \"  # testArray .  !  [ wrapper . value ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" testArray \"  ,     . IntegerTestBean . createArray (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue ( value . getClass (  )  . isArray (  )  )  ;", "TypedValue   typedValue    =    new   TypedValue ( value )  ;", "assertEquals ( Number . class ,    typedValue . getTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "Number [  ]    array    =     (  ( Number [  ]  )     ( value )  )  ;", "assertEquals (  3  ,    array . length )  ;", "assertEquals ( new   Integer (  5  )  ,    array [  0  ]  )  ;", "assertEquals (  5  .  9 F ,    array [  1  ]  )  ;", "assertEquals ( new   Integer (  7  )  ,    array [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["projectionWithArray"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \"  # testList .  !  [ wrapper . value ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" testList \"  ,     . IntegerTestBean . createIterable (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   List )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "assertEquals (  3  ,    list . size (  )  )  ;", "assertEquals (  5  ,    list . get (  0  )  )  ;", "assertEquals (  6  ,    list . get (  1  )  )  ;", "assertEquals (  7  ,    list . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["projectionWithIterable"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \"  # testList .  !  [ wrapper . value ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" testList \"  ,     . IntegerTestBean . createList (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   List )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "assertEquals (  3  ,    list . size (  )  )  ;", "assertEquals (  5  ,    list . get (  0  )  )  ;", "assertEquals (  6  ,    list . get (  1  )  )  ;", "assertEquals (  7  ,    list . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["projectionWithList"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \"  # testList .  !  [ wrapper . value ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" testList \"  ,     . IntegerTestBean . createSet (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   List )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "assertEquals (  3  ,    list . size (  )  )  ;", "assertEquals (  5  ,    list . get (  0  )  )  ;", "assertEquals (  6  ,    list . get (  1  )  )  ;", "assertEquals (  7  ,    list . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["projectionWithSet"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  ^  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . ArrayTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   Integer )  )  ;", "assertEquals (  0  ,    value )  ;", "}", "METHOD_END"], "methodName": ["selectFirstItemInArray"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  ^  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . ListTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   Integer )  )  ;", "assertEquals (  0  ,    value )  ;", "}", "METHOD_END"], "methodName": ["selectFirstItemInList"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    new   StandardEvaluationContext ( new   SelectionAndProjectionTests . MapTestBean (  )  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   exp    =    parser . parseExpression (  \" colors .  ^  [ key . startsWith (  ' b '  )  ]  \"  )  ;", "Map < String ,    String >    colorsMap    =     (  ( Map < String ,    String >  )     ( exp . getValue ( context )  )  )  ;", "assertEquals (  1  ,    colorsMap . size (  )  )  ;", "assertEquals (  \" beige \"  ,    colorsMap . keySet (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["selectFirstItemInMap"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" ints .  ^  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . ArrayTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   Integer )  )  ;", "assertEquals (  0  ,    value )  ;", "}", "METHOD_END"], "methodName": ["selectFirstItemInPrimitiveArray"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  ^  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . SetTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   Integer )  )  ;", "assertEquals (  0  ,    value )  ;", "}", "METHOD_END"], "methodName": ["selectFirstItemInSet"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  $  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . ArrayTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   Integer )  )  ;", "assertEquals (  4  ,    value )  ;", "}", "METHOD_END"], "methodName": ["selectLastItemInArray"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  $  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . ListTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   Integer )  )  ;", "assertEquals (  4  ,    value )  ;", "}", "METHOD_END"], "methodName": ["selectLastItemInList"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    new   StandardEvaluationContext ( new   SelectionAndProjectionTests . MapTestBean (  )  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   exp    =    parser . parseExpression (  \" colors .  $  [ key . startsWith (  ' b '  )  ]  \"  )  ;", "Map < String ,    String >    colorsMap    =     (  ( Map < String ,    String >  )     ( exp . getValue ( context )  )  )  ;", "assertEquals (  1  ,    colorsMap . size (  )  )  ;", "assertEquals (  \" brown \"  ,    colorsMap . keySet (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["selectLastItemInMap"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" ints .  $  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . ArrayTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   Integer )  )  ;", "assertEquals (  4  ,    value )  ;", "}", "METHOD_END"], "methodName": ["selectLastItemInPrimitiveArray"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  $  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . SetTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   Integer )  )  ;", "assertEquals (  4  ,    value )  ;", "}", "METHOD_END"], "methodName": ["selectLastItemInSet"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  ?  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . ArrayTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue ( value . getClass (  )  . isArray (  )  )  ;", "TypedValue   typedValue    =    new   TypedValue ( value )  ;", "assertEquals ( Integer . class ,    typedValue . getTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "Integer [  ]    array    =     (  ( Integer [  ]  )     ( value )  )  ;", "assertEquals (  5  ,    array . length )  ;", "assertEquals ( new   Integer (  0  )  ,    array [  0  ]  )  ;", "assertEquals ( new   Integer (  1  )  ,    array [  1  ]  )  ;", "assertEquals ( new   Integer (  2  )  ,    array [  2  ]  )  ;", "assertEquals ( new   Integer (  3  )  ,    array [  3  ]  )  ;", "assertEquals ( new   Integer (  4  )  ,    array [  4  ]  )  ;", "}", "METHOD_END"], "methodName": ["selectionWithArray"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  ?  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . IterableTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   List )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "assertEquals (  5  ,    list . size (  )  )  ;", "assertEquals (  0  ,    list . get (  0  )  )  ;", "assertEquals (  1  ,    list . get (  1  )  )  ;", "assertEquals (  2  ,    list . get (  2  )  )  ;", "assertEquals (  3  ,    list . get (  3  )  )  ;", "assertEquals (  4  ,    list . get (  4  )  )  ;", "}", "METHOD_END"], "methodName": ["selectionWithIterable"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  ?  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . ListTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   List )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "assertEquals (  5  ,    list . size (  )  )  ;", "assertEquals (  0  ,    list . get (  0  )  )  ;", "assertEquals (  1  ,    list . get (  1  )  )  ;", "assertEquals (  2  ,    list . get (  2  )  )  ;", "assertEquals (  3  ,    list . get (  3  )  )  ;", "assertEquals (  4  ,    list . get (  4  )  )  ;", "}", "METHOD_END"], "methodName": ["selectionWithList"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    new   StandardEvaluationContext ( new   SelectionAndProjectionTests . MapTestBean (  )  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   exp    =    parser . parseExpression (  \" colors .  ?  [ key . startsWith (  ' b '  )  ]  \"  )  ;", "Map < String ,    String >    colorsMap    =     (  ( Map < String ,    String >  )     ( exp . getValue ( context )  )  )  ;", "assertEquals (  3  ,    colorsMap . size (  )  )  ;", "assertTrue ( colorsMap . containsKey (  \" beige \"  )  )  ;", "assertTrue ( colorsMap . containsKey (  \" blue \"  )  )  ;", "assertTrue ( colorsMap . containsKey (  \" brown \"  )  )  ;", "}", "METHOD_END"], "methodName": ["selectionWithMap"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" ints .  ?  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . ArrayTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue ( value . getClass (  )  . isArray (  )  )  ;", "TypedValue   typedValue    =    new   TypedValue ( value )  ;", "assertEquals ( Integer . class ,    typedValue . getTypeDescriptor (  )  . getElementTypeDescriptor (  )  . getType (  )  )  ;", "Integer [  ]    array    =     (  ( Integer [  ]  )     ( value )  )  ;", "assertEquals (  5  ,    array . length )  ;", "assertEquals ( new   Integer (  0  )  ,    array [  0  ]  )  ;", "assertEquals ( new   Integer (  1  )  ,    array [  1  ]  )  ;", "assertEquals ( new   Integer (  2  )  ,    array [  2  ]  )  ;", "assertEquals ( new   Integer (  3  )  ,    array [  3  ]  )  ;", "assertEquals ( new   Integer (  4  )  ,    array [  4  ]  )  ;", "}", "METHOD_END"], "methodName": ["selectionWithPrimitiveArray"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    new   SpelExpressionParser (  )  . parseRaw (  \" integers .  ?  [  # this <  5  ]  \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( new    . SetTestBean (  )  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertTrue (  ( value   instanceof   List )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "assertEquals (  5  ,    list . size (  )  )  ;", "assertEquals (  0  ,    list . get (  0  )  )  ;", "assertEquals (  1  ,    list . get (  1  )  )  ;", "assertEquals (  2  ,    list . get (  2  )  )  ;", "assertEquals (  3  ,    list . get (  3  )  )  ;", "assertEquals (  4  ,    list . get (  4  )  )  ;", "}", "METHOD_END"], "methodName": ["selectionWithSet"], "fileName": "org.springframework.expression.spel.SelectionAndProjectionTests"}, {"methodBody": ["METHOD_START", "{", "return   parser . parseExpression ( expressionString )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Expression   e    =    parser . parseExpression ( expression )  ;", "if    ( e    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "if    (  . DEBUG )     {", "SpelUtilities . printAbstractSyntaxTree ( System . out ,    e )  ;", "}", "StandardEvaluationContext   lContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "assertTrue (  \" Expression   is   not   writeable   but   should   be \"  ,    e . isWritable ( lContext )  )  ;", "e . setValue ( lContext ,    value )  ;", "assertEquals (  \" Retrieved   value   was   not   equal   to   set   value \"  ,    value ,    e . getValue ( lContext ,    value . getClass (  )  )  )  ;", "}    catch    ( EvaluationException   ee )     {", "ee . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( ee . getMessage (  )  )  )  )  ;", "}    catch    ( ParseException   pe )     {", "pe . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( pe . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Expression   e    =    parser . parseExpression ( expression )  ;", "if    ( e    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "if    (  . DEBUG )     {", "SpelUtilities . printAbstractSyntaxTree ( System . out ,    e )  ;", "}", "StandardEvaluationContext   lContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "assertTrue (  \" Expression   is   not   writeable   but   should   be \"  ,    e . isWritable ( lContext )  )  ;", "e . setValue ( lContext ,    value )  ;", "Object   a    =    expectedValue ;", "Object   b    =    e . getValue ( lContext )  ;", "if    (  !  ( a . equals ( b )  )  )     {", "fail (  (  (  (  (  (  (  (  \" Not   the   same :     [  \"     +    a )     +     \"  ]    type =  \"  )     +     ( a . getClass (  )  )  )     +     \"        [  \"  )     +    b )     +     \"  ]    type =  \"  )     +     ( b . getClass (  )  )  )  )  ;", "}", "}    catch    ( EvaluationException   ee )     {", "ee . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( ee . getMessage (  )  )  )  )  ;", "}    catch    ( ParseException   pe )     {", "pe . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( pe . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Expression   e    =    parser . parseExpression ( expression )  ;", "if    ( e    =  =    null )     {", "fail (  \" Parser   returned   null   for   expression \"  )  ;", "}", "if    (  . DEBUG )     {", "SpelUtilities . printAbstractSyntaxTree ( System . out ,    e )  ;", "}", "StandardEvaluationContext   lContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "e . setValue ( lContext ,    value )  ;", "fail (  \" expected   an   error \"  )  ;", "}    catch    ( ParseException   pe )     {", "pe . printStackTrace (  )  ;", "fail (  (  \" Unexpected   Exception :     \"     +     ( pe . getMessage (  )  )  )  )  ;", "}    catch    ( EvaluationException   ee )     {", "}", "}", "METHOD_END"], "methodName": ["setValueExpectError"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   eContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "E   e    =    parse (  \" publicName =  ' Andy '  \"  )  ;", "assertFalse ( e . isWritable ( eContext )  )  ;", "assertEquals (  \" Andy \"  ,    e . getValue ( eContext )  )  ;", "}", "METHOD_END"], "methodName": ["testAssign"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValueExpectError (  \"  3  =  4  \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testErrorCase"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValueExpectError (  \"  ' hello '  [  3  ]  \"  ,     ' p '  )  ;", "}", "METHOD_END"], "methodName": ["testIndexingIntoUnsupportedType"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "Expression   e    =    null ;", "StandardEvaluationContext   lContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "e    =    parser . parseExpression (  \" arrayContainer . wibble \"  )  ;", "assertFalse (  \" Should   not   be   writable !  \"  ,    e . isWritable ( lContext )  )  ;", "e    =    parser . parseExpression (  \" arrayContainer . wibble . foo \"  )  ;", "try    {", "assertFalse (  \" Should   not   be   writable !  \"  ,    e . isWritable ( lContext )  )  ;", "fail (  \" Should   have   had   an   error   because   wibble   does   not   really   exist \"  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "}", "e    =    parser . parseExpression (  \"  # madeup 1  \"  )  ;", "assertTrue (  \" Should   be   writable !  \"  ,    e . isWritable ( lContext )  )  ;", "e    =    parser . parseExpression (  \"  # madeup 2  . bar \"  )  ;", "assertFalse (  \" Should   not   be   writable !  \"  ,    e . isWritable ( lContext )  )  ;", "e    =    parser . parseExpression (  \" arrayContainer . wibble [  9  9  ]  \"  )  ;", "try    {", "assertFalse (  \" Should   not   be   writable !  \"  ,    e . isWritable ( lContext )  )  ;", "fail (  \" Should   have   had   an   error   because   wibble   does   not   really   exist \"  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "}", "e    =    parser . parseExpression (  \" arrayContainer . ints [  ' abc '  ]  \"  )  ;", "try    {", "assertFalse (  \" Should   not   be   writable !  \"  ,    e . isWritable ( lContext )  )  ;", "fail (  \" Should   have   had   an   error   because   wibble   does   not   really   exist \"  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "}", "}", "METHOD_END"], "methodName": ["testIsWritableForInvalidExpressions_SPR10610"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValueExpectError (  \" placesLived [  2  3  ]  \"  ,     \" Wien \"  )  ;", "setValueExpectError (  \" placesLivedList [  2  3  ]  \"  ,     \" Wien \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetArrayElementInvalidIndex"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" placesLived [  0  ]  . city \"  ,     \" Wien \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetArrayElementNestedValue"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" inventions [  0  ]  \"  ,     \" Just   the   telephone \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetArrayElementValue"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" arrayContainer . ints [  1  ]  \"  ,     3  )  ;", "setValue (  \" arrayContainer . floats [  1  ]  \"  ,     3  .  0 F )  ;", "setValue (  \" arrayContainer . booleans [  1  ]  \"  ,    false )  ;", "setValue (  \" arrayContainer . doubles [  1  ]  \"  ,     3  .  4  )  ;", "setValue (  \" arrayContainer . shorts [  1  ]  \"  ,     (  ( short )     (  3  )  )  )  ;", "setValue (  \" arrayContainer . longs [  1  ]  \"  ,     3 L )  ;", "setValue (  \" arrayContainer . bytes [  1  ]  \"  ,     (  ( byte )     (  3  )  )  )  ;", "setValue (  \" arrayContainer . chars [  1  ]  \"  ,     (  ( char )     (  3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetArrayElementValueAllPrimitiveTypes"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValueExpectError (  \" arrayContainer . ints [  1  ]  \"  ,     \" wibble \"  )  ;", "setValueExpectError (  \" arrayContainer . floats [  1  ]  \"  ,     \" dribble \"  )  ;", "setValueExpectError (  \" arrayContainer . booleans [  1  ]  \"  ,     \" nein \"  )  ;", "setValueExpectError (  \" arrayContainer . bytes [  1  ]  \"  ,     \" NaB \"  )  ;", "setValueExpectError (  \" arrayContainer . chars [  1  ]  \"  ,     \" NaC \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetArrayElementValueAllPrimitiveTypesErrors"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValueExpectError (  \" new   Inventor (  )  . inventions [  1  ]  \"  ,    SpelMessage . CANNOT _ INDEX _ INTO _ NULL _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testSetElementOfNull"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" placesLivedList [  0  ]  \"  ,     \" Wien \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetGenericListElementValueTypeCoersion"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" booleanList [  0  ]  \"  ,     \" true \"  ,    Boolean . TRUE )  ;", "}", "METHOD_END"], "methodName": ["testSetGenericListElementValueTypeCoersionOK"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   eContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "E   e    =    parse (  \" mapOfStringToBoolean [  4  2  ]  \"  )  ;", "assertNull ( e . getValue ( eContext )  )  ;", "e . setValue ( eContext ,     \" true \"  )  ;", "Set <  ?  >    ks    =    parse (  \" mapOfStringToBoolean . keySet (  )  \"  )  . getValue ( eContext ,    Set . class )  ;", "for    ( Object   o    :    ks )     {", "assertEquals ( String . class ,    o . getClass (  )  )  ;", "}", "Collection <  ?  >    vs    =    parse (  \" mapOfStringToBoolean . values (  )  \"  )  . getValue ( eContext ,    Collection . class )  ;", "for    ( Object   o    :    vs )     {", "assertEquals ( Boolean . class ,    o . getClass (  )  )  ;", "}", "Object   o    =    e . getValue ( eContext )  ;", "assertEquals ( Boolean . TRUE ,    o )  ;", "}", "METHOD_END"], "methodName": ["testSetGenericMapElementRequiresCoercion"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" placesLived [  0  ]  . city \"  ,     \" Wien \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetListElementNestedValue"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" placesLivedList [  0  ]  \"  ,    new   PlaceOfBirth (  \" Wien \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetListElementValue"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" testMap [  ' montag '  ]  \"  ,     \" lundi \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetMapElements"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" placeOfBirth . city \"  ,     \" Wien \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetNestedProperty"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" wonNobelPrize \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testSetProperty"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" publicBoolean \"  ,     \" true \"  ,    Boolean . TRUE )  ;", "}", "METHOD_END"], "methodName": ["testSetPropertyTypeCoersion"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "setValue (  \" SomeProperty \"  ,     \" true \"  ,    Boolean . TRUE )  ;", "}", "METHOD_END"], "methodName": ["testSetPropertyTypeCoersionThroughSetter"], "fileName": "org.springframework.expression.spel.SetValueTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( SpelCompiler . compile ( expression )  )  ;", "}", "METHOD_END"], "methodName": ["assertCanCompile"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( SpelCompiler . compile ( expression )  )  ;", "}", "METHOD_END"], "methodName": ["assertCantCompile"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   o    =    getValue (  )  ;", "fail (  (  \" Calling   getValue   on   the   should   have   failed   but   returned    \"     +    o )  )  ;", "}    catch    ( Exception   ex )     {", "}", "}", "METHOD_END"], "methodName": ["assertGetValueFail"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "Field   field    =    SpelEclass . getDeclaredField (  \" compiledAst \"  )  ;", "field . setAccessible ( true )  ;", "Object   object    =    field . get ( e ;", "assertNotNull ( object )  ;", "}    catch    ( Exception   ex )     {", "fail ( ex . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertIsCompiled"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parser . parseExpression (  \" true \"  )  ;", "boolean   resultI    =    getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( true ,    resultI )  ;", "assertTrue ( SpelCompiler . compile (  )  ;", "boolean   resultC    =    getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( true ,    resultC )  ;", "=    parser . parseExpression (  \" false \"  )  ;", "resultI    =    getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( false ,    resultI )  ;", "assertTrue ( SpelCompiler . compile (  )  ;", "resultC    =    getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( false ,    resultC )  ;", "}", "METHOD_END"], "methodName": ["booleanLiteral"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expr    =    parse ( expression )  ;", "assertEquals ( expectedResult ,    expr . getValue ( p )  )  ;", "assertCanCompile ( expr )  ;", "assertEquals ( expectedResult ,    expr . getValue ( p )  )  ;", "}", "METHOD_END"], "methodName": ["checkCalc"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expr    =    parse ( expression )  ;", "assertEquals ( expectedResult ,    expr . getValue ( p )  )  ;", "assertCanCompile ( expr )  ;", "assertEquals ( expectedResult ,    expr . getValue ( p )  )  ;", "}", "METHOD_END"], "methodName": ["checkCalc"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expr    =    parse ( expression )  ;", "assertEquals ( expectedResult ,    expr . getValue ( p )  )  ;", "assertCanCompile ( expr )  ;", "assertEquals ( expectedResult ,    expr . getValue ( p )  )  ;", "}", "METHOD_END"], "methodName": ["checkCalc"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expr    =    parse ( expression )  ;", "assertEquals ( expectedResult ,    expr . getValue ( p )  )  ;", "assertCanCompile ( expr )  ;", "assertEquals ( expectedResult ,    expr . getValue ( p )  )  ;", "}", "METHOD_END"], "methodName": ["checkCalc"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( SpelCompilerMode . OFF ,    getClass (  )  . getClassLoader (  )  )  )  ;", "SpelExpression   expression    =    parser . parseRaw (  \"  # it ?  . equals (  3  )  \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   Object [  ]  {     1     }  )  ;", "context . setVariable (  \" it \"  ,     3  )  ;", "etEvaluationContext ( context )  ;", "assertTrue ( expression . getValue ( Boolean . class )  )  ;", "context . setVariable (  \" it \"  ,    null )  ;", "assertNull ( expression . getValue ( Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" it \"  ,     3  )  ;", "assertTrue ( expression . getValue ( Boolean . class )  )  ;", "context . setVariable (  \" it \"  ,    null )  ;", "assertNull ( expression . getValue ( Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["compilationOfBasicNullSafeMethodReference"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    null ;", "expression    =    parser . parseExpression (  \"  # doFormat (  ' hey    % s '  ,     ' there '  )  \"  )  ;", "context    =    new   StandardEvaluationContext (  )  ;", "context . registerFunction (  \" doFormat \"  ,     . DelegatingStringFormat . class . getDeclaredMethod (  \" format \"  ,    String . class ,    Object [  ]  . class )  )  ;", "(  ( SpelExpression )     ( expression )  )  . setEvaluationContext ( context )  ;", "assertEquals (  \" hey   there \"  ,    expression . getValue ( String . class )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" hey   there \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  \"  # doFormat (  [  0  ]  ,     ' there '  )  \"  )  ;", "context    =    new   StandardEvaluationContext ( new   Object [  ]  {     \" hey    % s \"     }  )  ;", "context . registerFunction (  \" doFormat \"  ,     . DelegatingStringFormat . class . getDeclaredMethod (  \" format \"  ,    String . class ,    Object [  ]  . class )  )  ;", "(  ( SpelExpression )     ( expression )  )  . setEvaluationContext ( context )  ;", "assertEquals (  \" hey   there \"  ,    expression . getValue ( String . class )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" hey   there \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  \"  # doFormat (  [  0  ]  ,     # arg )  \"  )  ;", "context    =    new   StandardEvaluationContext ( new   Object [  ]  {     \" hey    % s \"     }  )  ;", "context . registerFunction (  \" doFormat \"  ,     . DelegatingStringFormat . class . getDeclaredMethod (  \" format \"  ,    String . class ,    Object [  ]  . class )  )  ;", "context . setVariable (  \" arg \"  ,     \" there \"  )  ;", "(  ( SpelExpression )     ( expression )  )  . setEvaluationContext ( context )  ;", "assertEquals (  \" hey   there \"  ,    expression . getValue ( String . class )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" hey   there \"  ,    expression . getValue ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["compiledExpressionShouldWorkWhenUsingCustomFunctionWithVarargs"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \" payload !  =  2  \"  )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper (  4  )  ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper (  2  )  ,    Boolean . class )  )  ;", "expression    =    parser . parseExpression (  \"  2  !  = payload \"  )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper (  4  )  ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper (  2  )  ,    Boolean . class )  )  ;", "expression    =    parser . parseExpression (  \" payload !  =  6 L \"  )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper (  4 L )  ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper (  6 L )  ,    Boolean . class )  )  ;", "expression    =    parser . parseExpression (  \" payload =  =  2  \"  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper (  4  )  ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper (  2  )  ,    Boolean . class )  )  ;", "expression    =    parser . parseExpression (  \"  2  =  = payload \"  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper (  4  )  ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper (  2  )  ,    Boolean . class )  )  ;", "expression    =    parser . parseExpression (  \" payload =  =  6 L \"  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper (  4 L )  ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper (  6 L )  ,    Boolean . class )  )  ;", "expression    =    parser . parseExpression (  \"  2  =  = payload \"  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper (  4  )  ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper (  2  )  ,    Boolean . class )  )  ;", "expression    =    parser . parseExpression (  \" payload /  2  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  3  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  6  )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0  / payload \"  )  ;", "assertEquals (  2  5  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  0  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  1  0  )  )  )  ;", "expression    =    parser . parseExpression (  \" payload +  2  \"  )  ;", "assertEquals (  6  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  8  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  6  )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0  + payload \"  )  ;", "assertEquals (  1  0  4  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  1  0  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  1  0  )  )  )  ;", "expression    =    parser . parseExpression (  \" payload -  2  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  4  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  6  )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0  - payload \"  )  ;", "assertEquals (  9  6  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  9  0  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  1  0  )  )  )  ;", "expression    =    parser . parseExpression (  \" payload *  2  \"  )  ;", "assertEquals (  8  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  2  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  6  )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0  * payload \"  )  ;", "assertEquals (  4  0  0  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  0  0  0  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  1  0  )  )  )  ;", "expression    =    parser . parseExpression (  \" payload /  2 L \"  )  ;", "assertEquals (  2 L ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4 L )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  3 L ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  6 L )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0 L / payload \"  )  ;", "assertEquals (  2  5 L ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4 L )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  0 L ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  1  0 L )  )  )  ;", "expression    =    parser . parseExpression (  \" payload /  2 f \"  )  ;", "assertEquals (  2  .  0 F ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  .  0 F )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  3  .  0 F ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  6  .  0 F )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0 f / payload \"  )  ;", "assertEquals (  2  5  .  0 F ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  .  0 F )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  0  .  0 F ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  1  0  .  0 F )  )  )  ;", "expression    =    parser . parseExpression (  \" payload /  2 d \"  )  ;", "assertEquals (  2  .  0  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  .  0  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  3  .  0  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  6  .  0  )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0 d / payload \"  )  ;", "assertEquals (  2  5  .  0  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  4  .  0  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  0  .  0  ,    expression . getValue ( new    . GenericMessageTestHelper <  >  (  1  0  .  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compilerWithGenerics_12040"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \" payload /  2  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  3  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  6  )  )  )  ;", "expression    =    parser . parseExpression (  \"  9  / payload \"  )  ;", "assertEquals (  1  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  9  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  3  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  3  )  )  )  ;", "expression    =    parser . parseExpression (  \" payload +  2  \"  )  ;", "assertEquals (  6  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  8  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  6  )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0  + payload \"  )  ;", "assertEquals (  1  0  4  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  1  0  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  1  0  )  )  )  ;", "expression    =    parser . parseExpression (  \" payload -  2  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  4  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  6  )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0  - payload \"  )  ;", "assertEquals (  9  6  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  9  0  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  1  0  )  )  )  ;", "expression    =    parser . parseExpression (  \" payload *  2  \"  )  ;", "assertEquals (  8  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  2  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  6  )  )  )  ;", "expression    =    parser . parseExpression (  \"  1  0  0  * payload \"  )  ;", "assertEquals (  4  0  0  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  4  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  0  0  0  ,    expression . getValue ( new    . GenericMessageTestHelper 2  <  >  (  1  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["compilerWithGenerics_12040_2"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \" payload    >  =     2  \"  )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper 2  (  4  )  ,    Boolean . TYPE )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper 2  (  1  )  ,    Boolean . TYPE )  )  ;", "expression    =    parser . parseExpression (  \"  2     >  =    payload \"  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper 2  (  5  )  ,    Boolean . TYPE )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper 2  (  1  )  ,    Boolean . TYPE )  )  ;", "expression    =    parser . parseExpression (  \" payload    >     2  \"  )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper 2  (  4  )  ,    Boolean . TYPE )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper 2  (  1  )  ,    Boolean . TYPE )  )  ;", "expression    =    parser . parseExpression (  \"  2     >    payload \"  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper 2  (  5  )  ,    Boolean . TYPE )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper 2  (  1  )  ,    Boolean . TYPE )  )  ;", "expression    =    parser . parseExpression (  \" payload    <  =  2  \"  )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper 2  (  1  )  ,    Boolean . TYPE )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper 2  (  6  )  ,    Boolean . TYPE )  )  ;", "expression    =    parser . parseExpression (  \"  2     <  =    payload \"  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper 2  (  1  )  ,    Boolean . TYPE )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper 2  (  6  )  ,    Boolean . TYPE )  )  ;", "expression    =    parser . parseExpression (  \" payload    <     2  \"  )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper 2  (  1  )  ,    Boolean . TYPE )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper 2  (  6  )  ,    Boolean . TYPE )  )  ;", "expression    =    parser . parseExpression (  \"  2     <    payload \"  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper 2  (  1  )  ,    Boolean . TYPE )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper 2  (  6  )  ,    Boolean . TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["compilerWithGenerics_12040_3"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . Payload   payload    =    new   SpelCompilationCoverageTests . Payload (  )  ;", "expression    =    parser . parseExpression (  \" DR [  0  ]  \"  )  ;", "assertEquals (  \" instanceof   Two \"  ,    expression . getValue ( payload )  . toString (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" instanceof   Two \"  ,    expression . getValue ( payload )  . toString (  )  )  ;", "ast    =    getAst (  )  ;", "assertEquals (  \" L $ Two \"  ,    ast . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \" holder . three \"  )  ;", "assertEquals (  \"  $ Three \"  ,    expression . getValue ( payload )  . getClass (  )  . getName (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  $ Three \"  ,    expression . getValue ( payload )  . getClass (  )  . getName (  )  )  ;", "ast    =    getAst (  )  ;", "assertEquals (  \" L $ Three \"  ,    ast . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \" DR [  0  ]  \"  )  ;", "assertEquals (  \"  $ Two \"  ,    expression . getValue ( payload )  . getClass (  )  . getName (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  $ Two \"  ,    expression . getValue ( payload )  . getClass (  )  . getName (  )  )  ;", "assertEquals (  \" L $ Two \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \" DR [  0  ]  . three \"  )  ;", "assertEquals (  \"  $ Three \"  ,    expression . getValue ( payload )  . getClass (  )  . getName (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  $ Three \"  ,    expression . getValue ( payload )  . getClass (  )  . getName (  )  )  ;", "ast    =    getAst (  )  ;", "assertEquals (  \" L $ Three \"  ,    ast . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \" DR [  0  ]  . three . four \"  )  ;", "assertEquals (  0  .  0  4  ,    expression . getValue ( payload )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  0  .  0  4  ,    expression . getValue ( payload )  )  ;", "assertEquals (  \" D \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["compoundExpression"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "return   a    +    b ;", "}", "METHOD_END"], "methodName": ["concat"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \" new   String (  '  1  2  3  '  )  \"  )  ;", "assertEquals (  \"  1  2  3  \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  1  2  3  \"  ,    expression . getValue (  )  )  ;", "String   testclass 8     =     \"  $ TestClass 8  \"  ;", "expression    =    parser . parseExpression (  (  (  \" new    \"     +    testclass 8  )     +     \"  (  4  2  ,  '  1  2  3  '  ,  4  .  0 d , true )  \"  )  )  ;", "assertEquals ( testclass 8  ,    expression . getValue (  )  . getClass (  )  . getName (  )  )  ;", "assertCanCompile ( expression )  ;", "Object   o    =    expression . getValue (  )  ;", "assertEquals ( testclass 8  ,    o . getClass (  )  . getName (  )  )  ;", "SpelCompilationCoverageTests . TestClass 8    tc 8     =     (  ( SpelCompilationCoverageTests . TestClass 8  )     ( o )  )  ;", "assertEquals (  4  2  ,    tc 8  . i )  ;", "assertEquals (  \"  1  2  3  \"  ,    tc 8  . s )  ;", "assertEquals (  4  .  0  ,    tc 8  . d ,     0  .  5  )  ;", "assertEquals ( true ,    tc 8  . z )  ;", "expression    =    parser . parseExpression (  (  (  \" new    \"     +    testclass 8  )     +     \"  (  )  \"  )  )  ;", "assertEquals ( testclass 8  ,    expression . getValue (  )  . getClass (  )  . getName (  )  )  ;", "assertCanCompile ( expression )  ;", "o    =    expression . getValue (  )  ;", "assertEquals ( testclass 8  ,    o . getClass (  )  . getName (  )  )  ;", "expression    =    parser . parseExpression (  (  (  \" new    \"     +    testclass 8  )     +     \"  (  4  2  )  \"  )  )  ;", "assertEquals ( testclass 8  ,    expression . getValue (  )  . getClass (  )  . getName (  )  )  ;", "assertCanCompile ( expression )  ;", "o    =    expression . getValue (  )  ;", "assertEquals ( testclass 8  ,    o . getClass (  )  . getName (  )  )  ;", "tc 8     =     (  ( SpelCompilationCoverageTests . TestClass 8  )     ( o )  )  ;", "assertEquals (  4  2  ,    tc 8  . i )  ;", "String   testclass 9     =     \"  $ TestClass 9  \"  ;", "expression    =    parser . parseExpression (  (  (  \" new    \"     +    testclass 9  )     +     \"  (  4  2  )  \"  )  )  ;", "assertEquals ( testclass 9  ,    expression . getValue (  )  . getClass (  )  . getName (  )  )  ;", "assertCantCompile ( expression )  ;", "}", "METHOD_END"], "methodName": ["constructorReference"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "String   type    =    getClass (  )  . getName (  )  ;", "String   prefix    =     (  \" new    \"     +    type )     +     \"  . Obj \"  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  (  [  0  ]  )  \"  )  )  ;", "assertEquals (  \" test \"  ,     (  (  . Obj )     ( expression . getValue ( new   Object [  ]  {     \" test \"     }  )  )  )  . param 1  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" test \"  ,     (  (  . Obj )     ( expression . getValue ( new   Object [  ]  {     \" test \"     }  )  )  )  . param 1  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  2  (  ' foo '  ,  ' bar '  )  . output \"  )  )  ;", "assertEquals (  \" foobar \"  ,    expression . getValue ( String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" foobar \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  2  (  ' foo '  )  . output \"  )  )  ;", "assertEquals (  \" foo \"  ,    expression . getValue ( String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" foo \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  2  (  )  . output \"  )  )  ;", "assertEquals (  \"  \"  ,    expression . getValue ( String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  3  (  1  ,  2  ,  3  )  . output \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    expression . getValue ( String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  1  2  3  \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  3  (  1  )  . output \"  )  )  ;", "assertEquals (  \"  1  \"  ,    expression . getValue ( String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  1  \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  3  (  )  . output \"  )  )  ;", "assertEquals (  \"  \"  ,    expression . getValue ( String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  3  (  ' abc '  ,  5  .  0 f ,  1  ,  2  ,  3  )  . output \"  )  )  ;", "assertEquals (  \" abc :  5  .  0  :  1  2  3  \"  ,    expression . getValue ( String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" abc :  5  .  0  :  1  2  3  \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  3  (  ' abc '  ,  5  .  0 f ,  1  )  . output \"  )  )  ;", "assertEquals (  \" abc :  5  .  0  :  1  \"  ,    expression . getValue ( String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" abc :  5  .  0  :  1  \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  3  (  ' abc '  ,  5  .  0 f )  . output \"  )  )  ;", "assertEquals (  \" abc :  5  .  0  :  \"  ,    expression . getValue ( String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" abc :  5  .  0  :  \"  ,    expression . getValue ( String . class )  )  ;", "expression    =    parser . parseExpression (  ( prefix    +     \"  4  (  # root )  . output \"  )  )  ;", "assertEquals (  \"  1  2  3  \"  ,    expression . getValue ( new   int [  ]  {     1  ,     2  ,     3     }  ,    String . class )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  1  2  3  \"  ,    expression . getValue ( new   int [  ]  {     1  ,     2  ,     3     }  ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["constructorReference_SPR12326"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \" T ( Locale )  . ENGLISH \"  )  ;", "assertEquals (  \" en \"  ,    expression . getValue (  )  . toString (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" en \"  ,    expression . getValue (  )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # userId . toString (  )  . toLowerCase ( T ( Locale )  . ENGLISH )  \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" userId \"  ,     \" RoDnEy \"  )  ;", "assertEquals (  \" rodney \"  ,    expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" rodney \"  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \" T ( String )  . name \"  )  ;", "assertEquals (  \" String \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" String \"  ,    expression . getValue (  )  )  ;", "context    =    new   StandardEvaluationContext ( String . class )  ;", "expression    =    parser . parseExpression (  \" name \"  )  ;", "assertEquals (  \" String \"  ,    expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" String \"  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \" T ( String )  . getName (  )  \"  )  ;", "assertEquals (  \" String \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" String \"  ,    expression . getValue (  )  )  ;", "String   shclass    =     . StaticsHelper . class . getName (  )  ;", "expression    =    parser . parseExpression (  \" T ( String )  . valueOf ( T ( String )  . name . valueOf (  1  )  )  \"  )  ;", "assertEquals (  \"  1  \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  1  \"  ,    expression . getValue (  )  )  ;", "expression    =    parser . parseExpression (  (  (  \" T ( String )  . valueOf ( T (  \"     +    shclass )     +     \"  )  . methoda (  )  . methoda (  )  . methodb (  )  )  \"  )  )  ;", "assertEquals (  \" mb \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" mb \"  ,    expression . getValue (  )  )  ;", "expression    =    parser . parseExpression (  (  (  \" T ( String )  . valueOf ( T (  \"     +    shclass )     +     \"  )  . fielda . fielda . fieldb )  \"  )  )  ;", "assertEquals (  \" fb \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" fb \"  ,    expression . getValue (  )  )  ;", "expression    =    parser . parseExpression (  (  (  \" T ( String )  . valueOf ( T (  \"     +    shclass )     +     \"  )  . propertya . propertya . propertyb )  \"  )  )  ;", "assertEquals (  \" pb \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" pb \"  ,    expression . getValue (  )  )  ;", "expression    =    parser . parseExpression (  (  (  \" T ( String )  . valueOf ( T (  \"     +    shclass )     +     \"  )  . fielda . methoda (  )  . propertya . fieldb )  \"  )  )  ;", "assertEquals (  \" fb \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" fb \"  ,    expression . getValue (  )  )  ;", "expression    =    parser . parseExpression (  \" T ( String )  . valueOf ( fielda . fieldb )  \"  )  ;", "assertEquals (  \" fb \"  ,    expression . getValue (  . StaticsHelper . sh )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" fb \"  ,    expression . getValue (  . StaticsHelper . sh )  )  ;", "expression    =    parser . parseExpression (  \" T ( String )  . valueOf ( propertya . propertyb )  \"  )  ;", "assertEquals (  \" pb \"  ,    expression . getValue (  . StaticsHelper . sh )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" pb \"  ,    expression . getValue (  . StaticsHelper . sh )  )  ;", "expression    =    parser . parseExpression (  \" T ( String )  . valueOf ( methoda (  )  . methodb (  )  )  \"  )  ;", "assertEquals (  \" mb \"  ,    expression . getValue (  . StaticsHelper . sh )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" mb \"  ,    expression . getValue (  . StaticsHelper . sh )  )  ;", "}", "METHOD_END"], "methodName": ["constructorReference_SPR13781"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression    =    parser . parseExpression (  \"  ' a '  ?  :  ' b '  \"  )  ;", "String   resultI    =    getValue ( String . class )  ;", "assertCanCompile (  ;", "String   resultC    =    getValue ( String . class )  ;", "assertEquals (  \" a \"  ,    resultI )  ;", "assertEquals (  \" a \"  ,    resultC )  ;", "=    parser . parseExpression (  \" null ?  :  ' a '  \"  )  ;", "resultI    =    getValue ( String . class )  ;", "assertCanCompile (  ;", "resultC    =    getValue ( String . class )  ;", "assertEquals (  \" a \"  ,    resultI )  ;", "assertEquals (  \" a \"  ,    resultC )  ;", "String   s    =     \" abc \"  ;", "=    parser . parseExpression (  \"  # root ?  :  ' b '  \"  )  ;", "assertCantCompile (  ;", "resultI    =    getValue ( s ,    String . class )  ;", "assertEquals (  \" abc \"  ,    resultI )  ;", "assertCanCompile (  ;", "}", "METHOD_END"], "methodName": ["elvis"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelParserConfiguration   configuration    =    new   SpelParserConfiguration ( SpelCompilerMode . IMMEDIATE ,    null )  ;", "Expression   exp ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \" bar (  )  \"  )  ;", "assertEquals (  \" BAR \"  ,    exp . getValue ( new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" BAR \"  ,    exp . getValue ( new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \" bar (  ' baz '  )  \"  )  ;", "assertEquals (  \" BAZ \"  ,    exp . getValue ( new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" BAZ \"  ,    exp . getValue ( new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" map \"  ,    Collections . singletonMap (  \" foo \"  ,     \" qux \"  )  )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \" bar (  # map [  ' foo '  ]  )  \"  )  ;", "assertEquals (  \" QUX \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" QUX \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \" bar (  # map [  ' foo '  ]     ?  :     ' qux '  )  \"  )  ;", "assertEquals (  \" QUX \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" QUX \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  3  ?  :  ' foo '  \"  )  ;", "assertEquals (  \"  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  3 L ?  :  ' foo '  \"  )  ;", "assertEquals (  \"  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  '  '  ?  :  4 L \"  )  ;", "assertEquals (  \"  4  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  4  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \" null ?  :  4 L \"  )  ;", "assertEquals (  \"  4  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  4  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  # x ?  :  ' foo '  \"  )  ;", "context . setVariable (  \" x \"  ,     5  0  )  ;", "assertEquals (  \"  5  0  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  5  0  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  # x ?  :  ' foo '  \"  )  ;", "context . setVariable (  \" x \"  ,    null )  ;", "assertEquals (  \" foo \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" foo \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  # x ?  :  ' foo '  \"  )  ;", "context . setVariable (  \" x \"  ,    new   int [  ]  {     1  ,     2  ,     3     }  )  ;", "assertEquals (  \"  1  ,  2  ,  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  1  ,  2  ,  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "}", "METHOD_END"], "methodName": ["elvisOperator_SPR15192"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . TestClass 5    tc    =    new   SpelCompilationCoverageTests . TestClass 5  (  )  ;", "int [  ]    is    =    new   int [  ]  {     1  ,     2  ,     3     }  ;", "String [  ]    strings    =    new   String [  ]  {     \" a \"  ,     \" b \"  ,     \" c \"     }  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( is )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  ,    expression . getValue ( is )  )  ;", "try    {", "assertEquals (  2  ,    expression . getValue ( strings )  )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertTrue (  (  ( see . getCause (  )  )    instanceof   ClassCastException )  )  ;", "}", "SpelCompiler . revertToInterpreted ( expression )  ;", "assertEquals (  \" b \"  ,    expression . getValue ( strings )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" b \"  ,    expression . getValue ( strings )  )  ;", "tc . field    =     \" foo \"  ;", "expression    =    parser . parseExpression (  \" seven ( field )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" foo \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "tc . field    =     \" bar \"  ;", "expression . getValue ( tc )  ;", "tc . obj    =     \" foo \"  ;", "expression    =    parser . parseExpression (  \" seven ( obj )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" foo \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "tc . obj    =    new   Integer (  4  2  )  ;", "try    {", "expression . getValue ( tc )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertTrue (  (  ( see . getCause (  )  )    instanceof   ClassCastException )  )  ;", "}", "expression    =    parser . parseExpression (  \"  # root . charAt (  0  )  \"  )  ;", "assertEquals (  ' a '  ,    expression . getValue (  \" abc \"  )  )  ;", "assertCanCompile ( expression )  ;", "try    {", "expression . getValue ( new   Integer (  4  2  )  )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertTrue (  (  ( see . getCause (  )  )    instanceof   ClassCastException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["errorHandling"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( SpelCompilerMode . OFF ,    getClass (  )  . getClassLoader (  )  )  )  ;", ". Person 3    person    =    new    . Person 3  (  \" foo \"  ,     1  )  ;", "SpelExpression   expression    =    parser . parseRaw (  \"  # it ?  . age ?  . equals (  [  0  ]  )  \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   Object [  ]  {     1     }  )  ;", "context . setVariable (  \" it \"  ,    person )  ;", "expression . setEvaluationContext ( context )  ;", "assertTrue ( expression . getValue ( Boolean . class )  )  ;", "assertTrue ( expression . getValue ( Boolean . class )  )  ;", "context . setVariable (  \" it \"  ,    null )  ;", "assertNull ( expression . getValue ( Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" it \"  ,    person )  ;", "assertTrue ( expression . getValue ( Boolean . class )  )  ;", "context . setVariable (  \" it \"  ,    null )  ;", "assertNull ( expression . getValue ( Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["failsWhenSettingContextForExpression_SPR12326"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \"  3  .  4 f \"  )  ;", "float   resultI    =    expression . getValue ( new    . TestClass 1  (  )  ,    Float . TYPE )  ;", "assertCanCompile ( expression )  ;", "float   resultC    =    expression . getValue ( new    . TestClass 1  (  )  ,    Float . TYPE )  ;", "assertEquals (  3  .  4 F ,    resultI ,     0  .  1 F )  ;", "assertEquals (  3  .  4 F ,    resultC ,     0  .  1 F )  ;", "assertEquals (  3  .  4 F ,    expression . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["floatLiteral"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "Method   m    =    getClass (  )  . getDeclaredMethod (  \" concat \"  ,    String . class ,    String . class )  ;", "ctx . setVariable (  \" concat \"  ,    m )  ;", "=    parser . parseExpression (  \"  # concat (  ' a '  ,  ' b '  )  \"  )  ;", "assertEquals (  \" ab \"  ,    getValue ( ctx )  )  ;", "assertCanCompile (  ;", "assertEquals (  \" ab \"  ,    getValue ( ctx )  )  ;", "=    parser . parseExpression (  \"  # concat (  # concat (  ' a '  ,  ' b '  )  ,  ' c '  )  . charAt (  1  )  \"  )  ;", "assertEquals (  ' b '  ,    getValue ( ctx )  )  ;", "assertCanCompile (  ;", "assertEquals (  ' b '  ,    getValue ( ctx )  )  ;", "=    parser . parseExpression (  \"  # concat (  # a ,  # b )  \"  )  ;", "ctx . setVariable (  \" a \"  ,     \" foo \"  )  ;", "ctx . setVariable (  \" b \"  ,     \" bar \"  )  ;", "assertEquals (  \" foobar \"  ,    getValue ( ctx )  )  ;", "assertCanCompile (  ;", "assertEquals (  \" foobar \"  ,    getValue ( ctx )  )  ;", "ctx . setVariable (  \" b \"  ,     \" boo \"  )  ;", "assertEquals (  \" fooboo \"  ,    getValue ( ctx )  )  ;", "m    =    Math . class . getDeclaredMethod (  \" pow \"  ,    Double . TYPE ,    Double . TYPE )  ;", "ctx . setVariable (  \" kapow \"  ,    m )  ;", "=    parser . parseExpression (  \"  # kapow (  2  .  0 d ,  2  .  0 d )  \"  )  ;", "assertEquals (  \"  4  .  0  \"  ,    getValue ( ctx )  . toString (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  \"  4  .  0  \"  ,    getValue ( ctx )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["functionReference"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   Object [  ]  {     \"  1  \"     }  )  ;", "context . registerFunction (  \" negate \"  ,     . SomeCompareMethod 2  . class . getDeclaredMethod (  \" negate \"  ,    Integer . TYPE )  )  ;", "context . setVariable (  \" arg \"  ,     \"  2  \"  )  ;", "int [  ]    ints    =    new   int [  ]  {     1  ,     2  ,     3     }  ;", "context . setVariable (  \" ints \"  ,    ints )  ;", "expression    =    parser . parseExpression (  \"  # negate (  # ints .  ?  [  # this <  2  ]  [  0  ]  )  \"  )  ;", "assertEquals (  \"  -  1  \"  ,    expression . getValue ( context ,    Integer . class )  . toString (  )  )  ;", "assertFalse (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "}", "METHOD_END"], "methodName": ["functionReferenceNonCompilableArguments_SPR12359"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "Method   m    =    getClass (  )  . getDeclaredMethod (  \" join \"  ,    String [  ]  . class )  ;", "ctx . setVariable (  \" join \"  ,    m )  ;", "=    parser . parseExpression (  \"  # join (  ' a '  ,  ' b '  ,  ' c '  )  \"  )  ;", "assertEquals (  \" abc \"  ,    getValue ( ctx )  )  ;", "assertCanCompile (  ;", "assertEquals (  \" abc \"  ,    getValue ( ctx )  )  ;", "}", "METHOD_END"], "methodName": ["functionReferenceVarargs"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . registerFunction (  \" append \"  ,     . SomeCompareMethod 2  . class . getDeclaredMethod (  \" append \"  ,    String [  ]  . class )  )  ;", "context . registerFunction (  \" append 2  \"  ,     . SomeCompareMethod 2  . class . getDeclaredMethod (  \" append 2  \"  ,    Object [  ]  . class )  )  ;", "context . registerFunction (  \" append 3  \"  ,     . SomeCompareMethod 2  . class . getDeclaredMethod (  \" append 3  \"  ,    String [  ]  . class )  )  ;", "context . registerFunction (  \" append 4  \"  ,     . SomeCompareMethod 2  . class . getDeclaredMethod (  \" append 4  \"  ,    String . class ,    String [  ]  . class )  )  ;", "context . registerFunction (  \" appendChar \"  ,     . SomeCompareMethod 2  . class . getDeclaredMethod (  \" appendChar \"  ,    char [  ]  . class )  )  ;", "context . registerFunction (  \" sum \"  ,     . SomeCompareMethod 2  . class . getDeclaredMethod (  \" sum \"  ,    int [  ]  . class )  )  ;", "context . registerFunction (  \" sumDouble \"  ,     . SomeCompareMethod 2  . class . getDeclaredMethod (  \" sumDouble \"  ,    double [  ]  . class )  )  ;", "context . registerFunction (  \" sumFloat \"  ,     . SomeCompareMethod 2  . class . getDeclaredMethod (  \" sumFloat \"  ,    float [  ]  . class )  )  ;", "context . setVariable (  \" stringArray \"  ,    new   String [  ]  {     \" x \"  ,     \" y \"  ,     \" z \"     }  )  ;", "context . setVariable (  \" intArray \"  ,    new   int [  ]  {     5  ,     6  ,     9     }  )  ;", "context . setVariable (  \" doubleArray \"  ,    new   double [  ]  {     5  .  0  ,     6  .  0  ,     9  .  0     }  )  ;", "context . setVariable (  \" floatArray \"  ,    new   float [  ]  {     5  .  0 F ,     6  .  0 F ,     9  .  0 F    }  )  ;", "expression    =    parser . parseExpression (  \"  # append (  ' a '  ,  ' b '  ,  ' c '  )  \"  )  ;", "assertEquals (  \" abc \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" abc \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append (  ' a '  )  \"  )  ;", "assertEquals (  \" a \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" a \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append (  )  \"  )  ;", "assertEquals (  \"  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append (  # stringArray )  \"  )  ;", "assertEquals (  \" xyz \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" xyz \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \" append (  # stringArray )  \"  )  ;", "assertEquals (  \" xyz \"  ,    expression . getValue ( context ,    new    . SomeCompareMethod 2  (  )  )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" xyz \"  ,    expression . getValue ( context ,    new    . SomeCompareMethod 2  (  )  )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append 2  (  ' a '  ,  ' b '  ,  ' c '  )  \"  )  ;", "assertEquals (  \" abc \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" abc \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \" append 2  (  ' a '  ,  ' b '  )  \"  )  ;", "assertEquals (  \" ab \"  ,    expression . getValue ( context ,    new    . SomeCompareMethod 2  (  )  )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" ab \"  ,    expression . getValue ( context ,    new    . SomeCompareMethod 2  (  )  )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append 2  (  ' a '  ,  ' b '  )  \"  )  ;", "assertEquals (  \" ab \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" ab \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append 2  (  )  \"  )  ;", "assertEquals (  \"  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append 3  (  # stringArray )  \"  )  ;", "assertEquals (  \" xyz \"  ,    expression . getValue ( context ,    new    . SomeCompareMethod 2  (  )  )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" xyz \"  ,    expression . getValue ( context ,    new    . SomeCompareMethod 2  (  )  )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # sum (  1  ,  2  ,  3  )  \"  )  ;", "assertEquals (  6  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  6  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sum (  2  )  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sum (  )  \"  )  ;", "assertEquals (  0  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  0  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sum (  # intArray )  \"  )  ;", "assertEquals (  2  0  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  0  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sumDouble (  1  .  0 d ,  2  .  0 d ,  3  .  0 d )  \"  )  ;", "assertEquals (  6  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  6  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sumDouble (  2  .  0 d )  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sumDouble (  )  \"  )  ;", "assertEquals (  0  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  0  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sumDouble (  # doubleArray )  \"  )  ;", "assertEquals (  2  0  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  0  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sumFloat (  1  .  0 f ,  2  .  0 f ,  3  .  0 f )  \"  )  ;", "assertEquals (  6  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  6  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sumFloat (  2  .  0 f )  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sumFloat (  )  \"  )  ;", "assertEquals (  0  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  0  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # sumFloat (  # floatArray )  \"  )  ;", "assertEquals (  2  0  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  0  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # appendChar (  ' abc '  . charAt (  0  )  ,  ' abc '  . charAt (  1  )  )  \"  )  ;", "assertEquals (  \" ab \"  ,    expression . getValue ( context )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" ab \"  ,    expression . getValue ( context )  )  ;", "expression    =    parser . parseExpression (  \"  # append 4  (  ' a '  ,  ' b '  ,  ' c '  )  \"  )  ;", "assertEquals (  \" a :  : bc \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" a :  : bc \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append 4  (  ' a '  ,  ' b '  )  \"  )  ;", "assertEquals (  \" a :  : b \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" a :  : b \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append 4  (  ' a '  )  \"  )  ;", "assertEquals (  \" a :  :  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" a :  :  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "expression    =    parser . parseExpression (  \"  # append 4  (  ' a '  ,  # stringArray )  \"  )  ;", "assertEquals (  \" a :  : xyz \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "assertTrue (  (  ( SpelNodeImpl )     (  (  ( SpelExpression )     ( expression )  )  . getAST (  )  )  )  . isCompilable (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" a :  : xyz \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["functionReferenceVarargs_SPR12359"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   Object [  ]  {     \"  1  \"     }  )  ;", "context . registerFunction (  \" doCompare \"  ,     . SomeCompareMethod . class . getDeclaredMethod (  \" compare \"  ,    Object . class ,    Object . class )  )  ;", "context . setVariable (  \" arg \"  ,     \"  2  \"  )  ;", "expression    =    parser . parseExpression (  \"  # doCompare (  [  0  ]  ,  # arg )  \"  )  ;", "assertEquals (  \"  -  1  \"  ,    expression . getValue ( context ,    Integer . class )  . toString (  )  )  ;", "assertCantCompile ( expression )  ;", "context    =    new   StandardEvaluationContext ( new   Object [  ]  {     \"  1  \"     }  )  ;", "context . registerFunction (  \" doCompare \"  ,     . SomeCompareMethod . class . getDeclaredMethod (  \" compare 2  \"  ,    Object . class ,    Object . class )  )  ;", "context . setVariable (  \" arg \"  ,     \"  2  \"  )  ;", "expression    =    parser . parseExpression (  \"  # doCompare (  [  0  ]  ,  # arg )  \"  )  ;", "assertEquals (  \"  -  1  \"  ,    expression . getValue ( context ,    Integer . class )  . toString (  )  )  ;", "assertCantCompile ( expression )  ;", "}", "METHOD_END"], "methodName": ["functionReferenceVisibility_SPR12359"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   spelExpression    =     (  ( SpelExpression )     ( expression )  )  ;", "SpelNode   ast    =    spelExpression . getAST (  )  ;", "return    (  ( SpelNodeImpl )     ( ast )  )  ;", "}", "METHOD_END"], "methodName": ["getAst"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    sss    =    new   String [  ]  {     \" a \"  ,     \" b \"  ,     \" c \"     }  ;", "Number [  ]    ns    =    new   Number [  ]  {     2  ,     8  ,     9     }  ;", "int [  ]    is    =    new   int [  ]  {     8  ,     9  ,     1  0     }  ;", "double [  ]    ds    =    new   double [  ]  {     3  .  0  ,     4  .  0  ,     5  .  0     }  ;", "long [  ]    ls    =    new   long [  ]  {     2 L ,     3 L ,     4 L    }  ;", "short [  ]    ss    =    new   short [  ]  {     (  ( short )     (  3  3  )  )  ,     (  ( short )     (  4  4  )  )  ,     (  ( short )     (  5  5  )  )     }  ;", "float [  ]    fs    =    new   float [  ]  {     6  .  0 F ,     7  .  0 F ,     8  .  0 F    }  ;", "byte [  ]    bs    =    new   byte [  ]  {     (  ( byte )     (  2  )  )  ,     (  ( byte )     (  3  )  )  ,     (  ( byte )     (  4  )  )     }  ;", "char [  ]    cs    =    new   char [  ]  {     ' a '  ,     ' b '  ,     ' c '     }  ;", "expression    =    parser . parseExpression (  \"  [  0  ]  \"  )  ;", "assertEquals (  \" a \"  ,    expression . getValue ( sss )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" a \"  ,    expression . getValue ( sss )  )  ;", "assertEquals (  \" Ljava / lang / String \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  8  ,    expression . getValue ( ns )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  8  ,    expression . getValue ( ns )  )  ;", "assertEquals (  \" Ljava / lang / Number \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  2  ]  \"  )  ;", "assertEquals (  1  0  ,    expression . getValue ( is )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  0  ,    expression . getValue ( is )  )  ;", "assertEquals (  \" I \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  4  .  0  ,    expression . getValue ( ds )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  4  .  0  ,    expression . getValue ( ds )  )  ;", "assertEquals (  \" D \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  0  ]  \"  )  ;", "assertEquals (  2 L ,    expression . getValue ( ls )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2 L ,    expression . getValue ( ls )  )  ;", "assertEquals (  \" J \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  2  ]  \"  )  ;", "assertEquals (  (  ( short )     (  5  5  )  )  ,    expression . getValue ( ss )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  (  ( short )     (  5  5  )  )  ,    expression . getValue ( ss )  )  ;", "assertEquals (  \" S \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  0  ]  \"  )  ;", "assertEquals (  6  .  0 F ,    expression . getValue ( fs )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  6  .  0 F ,    expression . getValue ( fs )  )  ;", "assertEquals (  \" F \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  2  ]  \"  )  ;", "assertEquals (  (  ( byte )     (  4  )  )  ,    expression . getValue ( bs )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  (  ( byte )     (  4  )  )  ,    expression . getValue ( bs )  )  ;", "assertEquals (  \" B \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  ' b '  ,    expression . getValue ( cs )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  ' b '  ,    expression . getValue ( cs )  )  ;", "assertEquals (  \" C \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "List < String >    strings    =    new   ArrayList <  >  (  )  ;", "strings . add (  \" aaa \"  )  ;", "strings . add (  \" bbb \"  )  ;", "strings . add (  \" ccc \"  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  \" bbb \"  ,    expression . getValue ( strings )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" bbb \"  ,    expression . getValue ( strings )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "List < Integer >    ints    =    new   ArrayList <  >  (  )  ;", "ints . add (  1  2  3  )  ;", "ints . add (  4  5  6  )  ;", "ints . add (  7  8  9  )  ;", "expression    =    parser . parseExpression (  \"  [  2  ]  \"  )  ;", "assertEquals (  7  8  9  ,    expression . getValue ( ints )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  7  8  9  ,    expression . getValue ( ints )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "Map < String ,    Integer >    map 1     =    new   HashMap <  >  (  )  ;", "map 1  . put (  \" aaa \"  ,     1  1  1  )  ;", "map 1  . put (  \" bbb \"  ,     2  2  2  )  ;", "map 1  . put (  \" ccc \"  ,     3  3  3  )  ;", "expression    =    parser . parseExpression (  \"  [  ' aaa '  ]  \"  )  ;", "assertEquals (  1  1  1  ,    expression . getValue ( map 1  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  1  1  ,    expression . getValue ( map 1  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", ". TestClass 6    tc    =    new    . TestClass 6  (  )  ;", "expression    =    parser . parseExpression (  \"  [  ' orange '  ]  \"  )  ;", "assertEquals (  \" value 1  \"  ,    expression . getValue ( tc )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" value 1  \"  ,    expression . getValue ( tc )  )  ;", "assertEquals (  \" Ljava / lang / String \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  ' peach '  ]  \"  )  ;", "assertEquals (  3  4 L ,    expression . getValue ( tc )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  3  4 L ,    expression . getValue ( tc )  )  ;", "assertEquals (  \" J \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  ' banana '  ]  \"  )  ;", "assertEquals (  \" value 3  \"  ,    expression . getValue ( tc )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" value 3  \"  ,    expression . getValue ( tc )  )  ;", "assertEquals (  \" Ljava / lang / String \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "List < String [  ]  >    listOfStringArrays    =    new   ArrayList <  >  (  )  ;", "listOfStringArrays . add ( new   String [  ]  {     \" a \"  ,     \" b \"  ,     \" c \"     }  )  ;", "listOfStringArrays . add ( new   String [  ]  {     \" d \"  ,     \" e \"  ,     \" f \"     }  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  \" d   e   f \"  ,    stringify ( expression . getValue ( listOfStringArrays )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" d   e   f \"  ,    stringify ( expression . getValue ( listOfStringArrays )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  [  0  ]  \"  )  ;", "assertEquals (  \" d \"  ,    stringify ( expression . getValue ( listOfStringArrays )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" d \"  ,    stringify ( expression . getValue ( listOfStringArrays )  )  )  ;", "assertEquals (  \" Ljava / lang / String \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "List < Integer [  ]  >    listOfIntegerArrays    =    new   ArrayList <  >  (  )  ;", "listOfIntegerArrays . add ( new   Integer [  ]  {     1  ,     2  ,     3     }  )  ;", "listOfIntegerArrays . add ( new   Integer [  ]  {     4  ,     5  ,     6     }  )  ;", "expression    =    parser . parseExpression (  \"  [  0  ]  \"  )  ;", "assertEquals (  \"  1     2     3  \"  ,    stringify ( expression . getValue ( listOfIntegerArrays )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  1     2     3  \"  ,    stringify ( expression . getValue ( listOfIntegerArrays )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  0  ]  [  1  ]  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( listOfIntegerArrays )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  ,    expression . getValue ( listOfIntegerArrays )  )  ;", "assertEquals (  \" Ljava / lang / Integer \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "List < String >  [  ]    stringArrayOfLists    =    new   ArrayList [  2  ]  ;", "stringArrayOfLists [  0  ]     =    new   ArrayList <  >  (  )  ;", "stringArrayOfLists [  0  ]  . add (  \" a \"  )  ;", "stringArrayOfLists [  0  ]  . add (  \" b \"  )  ;", "stringArrayOfLists [  0  ]  . add (  \" c \"  )  ;", "stringArrayOfLists [  1  ]     =    new   ArrayList <  >  (  )  ;", "stringArrayOfLists [  1  ]  . add (  \" d \"  )  ;", "stringArrayOfLists [  1  ]  . add (  \" e \"  )  ;", "stringArrayOfLists [  1  ]  . add (  \" f \"  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  \" d   e   f \"  ,    stringify ( expression . getValue ( stringArrayOfLists )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" d   e   f \"  ,    stringify ( expression . getValue ( stringArrayOfLists )  )  )  ;", "assertEquals (  \" Ljava / util / ArrayList \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  [  2  ]  \"  )  ;", "assertEquals (  \" f \"  ,    stringify ( expression . getValue ( stringArrayOfLists )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" f \"  ,    stringify ( expression . getValue ( stringArrayOfLists )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "String [  ]  [  ]    referenceTypeArrayOfArrays    =    new   String [  ]  [  ]  {    new   String [  ]  {     \" a \"  ,     \" b \"  ,     \" c \"     }  ,    new   String [  ]  {     \" d \"  ,     \" e \"  ,     \" f \"     }     }  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  \" d   e   f \"  ,    stringify ( expression . getValue ( referenceTypeArrayOfArrays )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  [ Ljava / lang / String \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "assertEquals (  \" d   e   f \"  ,    stringify ( expression . getValue ( referenceTypeArrayOfArrays )  )  )  ;", "assertEquals (  \"  [ Ljava / lang / String \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  [  2  ]  \"  )  ;", "assertEquals (  \" f \"  ,    stringify ( expression . getValue ( referenceTypeArrayOfArrays )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" f \"  ,    stringify ( expression . getValue ( referenceTypeArrayOfArrays )  )  )  ;", "assertEquals (  \" Ljava / lang / String \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "int [  ]  [  ]    primitiveTypeArrayOfArrays    =    new   int [  ]  [  ]  {    new   int [  ]  {     1  ,     2  ,     3     }  ,    new   int [  ]  {     4  ,     5  ,     6     }     }  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  \"  4     5     6  \"  ,    stringify ( expression . getValue ( primitiveTypeArrayOfArrays )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  4     5     6  \"  ,    stringify ( expression . getValue ( primitiveTypeArrayOfArrays )  )  )  ;", "assertEquals (  \"  [ I \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  [  2  ]  \"  )  ;", "assertEquals (  \"  6  \"  ,    stringify ( expression . getValue ( primitiveTypeArrayOfArrays )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  6  \"  ,    stringify ( expression . getValue ( primitiveTypeArrayOfArrays )  )  )  ;", "assertEquals (  \" I \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "List < List < String >  >    listOfListOfStrings    =    new   ArrayList <  >  (  )  ;", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  \" a \"  )  ;", "list . add (  \" b \"  )  ;", "list . add (  \" c \"  )  ;", "listOfListOfStrings . add ( list )  ;", "list    =    new   ArrayList <  >  (  )  ;", "list . add (  \" d \"  )  ;", "list . add (  \" e \"  )  ;", "list . add (  \" f \"  )  ;", "listOfListOfStrings . add ( list )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  \"  )  ;", "assertEquals (  \" d   e   f \"  ,    stringify ( expression . getValue ( listOfListOfStrings )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "assertEquals (  \" d   e   f \"  ,    stringify ( expression . getValue ( listOfListOfStrings )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  1  ]  [  2  ]  \"  )  ;", "assertEquals (  \" f \"  ,    stringify ( expression . getValue ( listOfListOfStrings )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" f \"  ,    stringify ( expression . getValue ( listOfListOfStrings )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "Map < String ,    List < String >  >    mapToLists    =    new   HashMap <  >  (  )  ;", "list    =    new   ArrayList <  >  (  )  ;", "list . add (  \" a \"  )  ;", "list . add (  \" b \"  )  ;", "list . add (  \" c \"  )  ;", "mapToLists . put (  \" foo \"  ,    list )  ;", "expression    =    parser . parseExpression (  \"  [  ' foo '  ]  \"  )  ;", "assertEquals (  \" a   b   c \"  ,    stringify ( expression . getValue ( mapToLists )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "assertEquals (  \" a   b   c \"  ,    stringify ( expression . getValue ( mapToLists )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  ' foo '  ]  [  2  ]  \"  )  ;", "assertEquals (  \" c \"  ,    stringify ( expression . getValue ( mapToLists )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" c \"  ,    stringify ( expression . getValue ( mapToLists )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "Map < String ,    int [  ]  >    mapToIntArray    =    new   HashMap <  >  (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . addPropertyAccessor ( new    . CompilableMapAccessor (  )  )  ;", "mapToIntArray . put (  \" foo \"  ,    new   int [  ]  {     1  ,     2  ,     3     }  )  ;", "expression    =    parser . parseExpression (  \"  [  ' foo '  ]  \"  )  ;", "assertEquals (  \"  1     2     3  \"  ,    stringify ( expression . getValue ( mapToIntArray )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "assertEquals (  \"  1     2     3  \"  ,    stringify ( expression . getValue ( mapToIntArray )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  ' foo '  ]  [  1  ]  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( mapToIntArray )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  ,    expression . getValue ( mapToIntArray )  )  ;", "expression    =    parser . parseExpression (  \" foo \"  )  ;", "assertEquals (  \"  1     2     3  \"  ,    stringify ( expression . getValue ( ctx ,    mapToIntArray )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  1     2     3  \"  ,    stringify ( expression . getValue ( ctx ,    mapToIntArray )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \" foo [  1  ]  \"  )  ;", "assertEquals (  2  ,    expression . getValue ( ctx ,    mapToIntArray )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  ,    expression . getValue ( ctx ,    mapToIntArray )  )  ;", "expression    =    parser . parseExpression (  \"  [  ' foo '  ]  [  2  ]  \"  )  ;", "assertEquals (  \"  3  \"  ,    stringify ( expression . getValue ( ctx ,    mapToIntArray )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  3  \"  ,    stringify ( expression . getValue ( ctx ,    mapToIntArray )  )  )  ;", "assertEquals (  \" I \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "Map < String ,    String >  [  ]    mapArray    =    new   Map [  1  ]  ;", "mapArray [  0  ]     =    new   HashMap <  >  (  )  ;", "mapArray [  0  ]  . put (  \" key \"  ,     \" value 1  \"  )  ;", "expression    =    parser . parseExpression (  \"  [  0  ]  \"  )  ;", "assertEquals (  \"  { key = value 1  }  \"  ,    stringify ( expression . getValue ( mapArray )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" Ljava / util / Map \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "assertEquals (  \"  { key = value 1  }  \"  ,    stringify ( expression . getValue ( mapArray )  )  )  ;", "assertEquals (  \" Ljava / util / Map \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "expression    =    parser . parseExpression (  \"  [  0  ]  [  ' key '  ]  \"  )  ;", "assertEquals (  \" value 1  \"  ,    stringify ( expression . getValue ( mapArray )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" value 1  \"  ,    stringify ( expression . getValue ( mapArray )  )  )  ;", "assertEquals (  \" Ljava / lang / Object \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["indexer"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelParserConfiguration   spc    =    new   SpelParserConfiguration ( SpelCompilerMode . IMMEDIATE ,    getClass (  )  . getClassLoader (  )  )  ;", "SpelExpressionParser   sep    =    new   SpelExpressionParser ( spc )  ;", "expression    =    sep . parseExpression (  \" headers [ command ]  \"  )  ;", ". MyMessage   root    =    new    . MyMessage (  )  ;", "assertEquals (  \" wibble \"  ,    expression . getValue ( root )  )  ;", "assertEquals (  \" wibble \"  ,    expression . getValue ( root )  )  ;", "assertCanCompile ( expression )  ;", "expression    =    sep . parseExpression (  \" headers [ getKey (  )  ]  \"  )  ;", "assertEquals (  \" wobble \"  ,    expression . getValue ( root )  )  ;", "assertEquals (  \" wobble \"  ,    expression . getValue ( root )  )  ;", "expression    =    sep . parseExpression (  \" list [ getKey 2  (  )  ]  \"  )  ;", "assertEquals (  \" wobble \"  ,    expression . getValue ( root )  )  ;", "assertEquals (  \" wobble \"  ,    expression . getValue ( root )  )  ;", "expression    =    sep . parseExpression (  \" ia [ getKey 2  (  )  ]  \"  )  ;", "assertEquals (  3  ,    expression . getValue ( root )  )  ;", "assertEquals (  3  ,    expression . getValue ( root )  )  ;", "}", "METHOD_END"], "methodName": ["indexerMapAccessor_12045"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parser . parseExpression (  \"  ' abcde '  . substring (  {  1  ,  3  ,  4  }  [  0  ]  )  \"  )  ;", "Object   o    =    getValue (  )  ;", "assertEquals (  \" bcde \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bcde \"  ,    o )  ;", "=    parser . parseExpression (  \"  {  ' abc '  ,  ' def '  }  \"  )  ;", "List <  ?  >    l    =     (  ( List )     ( getValue (  )  )  )  ;", "assertEquals (  \"  [ abc ,    def ]  \"  ,    l . toString (  )  )  ;", "assertCanCompile (  ;", "l    =     (  ( List )     ( getValue (  )  )  )  ;", "assertEquals (  \"  [ abc ,    def ]  \"  ,    l . toString (  )  )  ;", "=    parser . parseExpression (  \"  {  ' abc '  ,  ' def '  }  [  0  ]  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" abc \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" abc \"  ,    o )  ;", "=    parser . parseExpression (  \"  {  ' abcde '  ,  ' ijklm '  }  [  0  ]  . substring (  {  1  ,  3  ,  4  }  [  0  ]  )  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bcde \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bcde \"  ,    o )  ;", "=    parser . parseExpression (  \"  {  ' abcde '  ,  ' ijklm '  }  [  0  ]  . substring (  {  1  ,  3  ,  4  }  [  0  ]  ,  {  1  ,  3  ,  4  }  [  1  ]  )  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bc \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bc \"  ,    o )  ;", "}", "METHOD_END"], "methodName": ["inlineList"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \"  4  2  \"  )  ;", "int   resultI    =    expression . getValue ( new    . TestClass 1  (  )  ,    Integer . TYPE )  ;", "assertCanCompile ( expression )  ;", "int   resultC    =    expression . getValue ( new    . TestClass 1  (  )  ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    resultI )  ;", "assertEquals (  4  2  ,    resultC )  ;", "expression    =    parser . parseExpression (  \" T ( Integer )  . valueOf (  4  2  )  \"  )  ;", "expression . getValue ( Integer . class )  ;", "assertCanCompile ( expression )  ;", "assertEquals ( new   Integer (  4  2  )  ,    expression . getValue ( Integer . class )  )  ;", "expression    =    parser . parseExpression (  \"  0  \"  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  0  ,    expression . getValue (  )  )  ;", "expression    =    parser . parseExpression (  \"  2  \"  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  ,    expression . getValue (  )  )  ;", "expression    =    parser . parseExpression (  \"  7  \"  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  7  ,    expression . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["intLiteral"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   buf    =    new   StringBuilder (  )  ;", "for    ( String   string    :    strings )     {", "buf . append ( string )  ;", "}", "return   buf . toString (  )  ;", "}", "METHOD_END"], "methodName": ["join"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \"  9  9 L \"  )  ;", "long   resultI    =    expression . getValue ( new    . TestClass 1  (  )  ,    Long . TYPE )  ;", "assertCanCompile ( expression )  ;", "long   resultC    =    expression . getValue ( new    . TestClass 1  (  )  ,    Long . TYPE )  ;", "assertEquals (  9  9 L ,    resultI )  ;", "assertEquals (  9  9 L ,    resultC )  ;", "}", "METHOD_END"], "methodName": ["longLiteral"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . TestClass 5    tc    =    new   SpelCompilationCoverageTests . TestClass 5  (  )  ;", "expression    =    parser . parseExpression (  \" one (  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  1  ,    tc . i )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" two (  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  1  ,    SpelCompilationCoverageTests . TestClass 5  .  _ i )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" three (  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "assertEquals (  \" hello \"  ,    expression . getValue ( tc )  )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" four (  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "assertEquals (  3  2  7  7  7  0  0 L ,    expression . getValue ( tc )  )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" five (  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "assertEquals (  \" hello \"  ,    expression . getValue ( tc )  )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" six (  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "assertEquals (  3  2  7  7  7  0  0 L ,    expression . getValue ( tc )  )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" seven (  \\  \" foo \\  \"  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" foo \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" eight (  \\  \" bar \\  \"  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" bar \"  ,    SpelCompilationCoverageTests . TestClass 5  .  _ s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" nine (  2  3  1  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  2  3  1  ,    tc . i )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" ten (  1  1  1  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  1  1  1  ,    SpelCompilationCoverageTests . TestClass 5  .  _ i )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" seven (  1  2  3  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  2  3  \"  ,    tc . s )  ;", "assertCantCompile ( expression )  ;", "Expression   expression    =    parser . parseExpression (  \"  ' abcd '  . substring ( index 1  , index 2  )  \"  )  ;", "String   resultI    =    expression . getValue ( new   SpelCompilationCoverageTests . TestClass 1  (  )  ,    String . class )  ;", "assertCanCompile ( expression )  ;", "String   resultC    =    expression . getValue ( new   SpelCompilationCoverageTests . TestClass 1  (  )  ,    String . class )  ;", "assertEquals (  \" bc \"  ,    resultI )  ;", "assertEquals (  \" bc \"  ,    resultC )  ;", "expression    =    parser . parseExpression (  \" takeNumber (  1  2  3  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  2  3  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "assertCanCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  2  3  \"  ,    tc . s )  ;", "expression    =    parser . parseExpression (  \" takeNumber ( T ( Integer )  . valueOf (  4  2  )  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  4  2  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "assertCanCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  4  2  \"  ,    tc . s )  ;", "expression    =    parser . parseExpression (  \" takeString ( T ( Integer )  . valueOf (  4  2  )  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  4  2  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "assertCantCompile ( expression )  ;", "}", "METHOD_END"], "methodName": ["methodReference"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \"  1  . toString (  )  \"  )  ;", "assertEquals (  \"  1  \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \"  1  \"  ,    expression . getValue (  )  )  ;", "expression    =    parser . parseExpression (  \"  # it ?  . age . equals (  [  0  ]  )  \"  )  ;", ". Person   person    =    new    . Person (  1  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   Object [  ]  {    person . getAge (  )     }  )  ;", "context . setVariable (  \" it \"  ,    person )  ;", "assertTrue ( expression . getValue ( context ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( context ,    Boolean . class )  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( SpelCompilerMode . IMMEDIATE ,    getClass (  )  . getClassLoader (  )  )  )  ;", "SpelExpression   ex    =    parser . parseRaw (  \"  # it ?  . age . equals (  [  0  ]  )  \"  )  ;", "context    =    new   StandardEvaluationContext ( new   Object [  ]  {    person . getAge (  )     }  )  ;", "context . setVariable (  \" it \"  ,    person )  ;", "assertTrue ( ex . getValue ( context ,    Boolean . class )  )  ;", "assertTrue ( ex . getValue ( context ,    Boolean . class )  )  ;", "PersonInOtherPackage   person 2     =    new   PersonInOtherPackage (  1  )  ;", "ex    =    parser . parseRaw (  \"  # it ?  . age . equals (  [  0  ]  )  \"  )  ;", "context    =    new   StandardEvaluationContext ( new   Object [  ]  {    person 2  . getAge (  )     }  )  ;", "context . setVariable (  \" it \"  ,    person 2  )  ;", "assertTrue ( ex . getValue ( context ,    Boolean . class )  )  ;", "assertTrue ( ex . getValue ( context ,    Boolean . class )  )  ;", "ex    =    parser . parseRaw (  \"  # it ?  . age . equals (  [  0  ]  )  \"  )  ;", "context    =    new   StandardEvaluationContext ( new   Object [  ]  {    person 2  . getAge (  )     }  )  ;", "context . setVariable (  \" it \"  ,    person 2  )  ;", "assertTrue (  (  ( Boolean )     ( ex . getValue ( context )  )  )  )  ;", "assertTrue (  (  ( Boolean )     ( ex . getValue ( context )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["methodReferenceMissingCastAndRootObjectAccessing_SPR12326"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . TestClass 1  0    tc    =    new   SpelCompilationCoverageTests . TestClass 1  0  (  )  ;", "expression    =    parser . parseExpression (  \" concat (  ' test '  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  :  : test \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  :  : test \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" concat (  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" concat 2  (  ' test '  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  :  : test \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  :  : test \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" concat 2  (  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "}", "METHOD_END"], "methodName": ["methodReferenceReflectiveMethodSelectionWithVarargs"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . TestClass 5    tc    =    new   SpelCompilationCoverageTests . TestClass 5  (  )  ;", "expression    =    parser . parseExpression (  \" eleven (  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" eleven (  ' aaa '  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" eleven ( stringArray )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaabbbccc \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaabbbccc \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" eleven (  ' aaa '  ,  ' bbb '  ,  ' ccc '  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaabbbccc \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaabbbccc \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" sixteen (  ' aaa '  ,  ' bbb '  ,  ' ccc '  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaabbbccc \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaabbbccc \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" twelve (  1  ,  2  ,  3  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  6  ,    tc . i )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  6  ,    tc . i )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" twelve (  1  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  1  ,    tc . i )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  1  ,    tc . i )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" thirteen (  ' aaa '  ,  ' bbb '  ,  ' ccc '  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa :  : bbbccc \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa :  : bbbccc \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" thirteen (  ' aaa '  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa :  :  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa :  :  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" fourteen (  ' aaa '  , stringArray , stringArray )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa :  :  { aaabbbccc }  { aaabbbccc }  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa :  :  { aaabbbccc }  { aaabbbccc }  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" fifteen (  ' aaa '  , intArray , intArray )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa :  :  {  1  1  2  2  3  3  }  {  1  1  2  2  3  3  }  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" aaa :  :  {  1  1  2  2  3  3  }  {  1  1  2  2  3  3  }  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayz ( true , true , false )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" truetruefalse \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" truetruefalse \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayz ( true )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" true \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" true \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrays ( s 1  , s 2  , s 3  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  2  3  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  2  3  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrays ( s 1  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayd (  1  .  0 d ,  2  .  0 d ,  3  .  0 d )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  .  0  2  .  0  3  .  0  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  .  0  2  .  0  3  .  0  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayd (  1  .  0 d )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  .  0  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  .  0  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayj ( l 1  , l 2  , l 3  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  2  3  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  2  3  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayj ( l 1  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayc ( c 1  , c 2  , c 3  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" abc \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" abc \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayc ( c 1  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" a \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \" a \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayb ( b 1  , b 2  , b 3  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  6  5  6  6  6  7  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  6  5  6  6  6  7  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayb ( b 1  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  6  5  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  6  5  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayf ( f 1  , f 2  , f 3  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  .  0  2  .  0  3  .  0  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  .  0  2  .  0  3  .  0  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "expression    =    parser . parseExpression (  \" arrayf ( f 1  )  \"  )  ;", "assertCantCompile ( expression )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  .  0  \"  ,    tc . s )  ;", "assertCanCompile ( expression )  ;", "tc . reset (  )  ;", "expression . getValue ( tc )  ;", "assertEquals (  \"  1  .  0  \"  ,    tc . s )  ;", "tc . reset (  )  ;", "}", "METHOD_END"], "methodName": ["methodReferenceVarargs"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    parser . parseExpression (  \"  ' abcd '  . substring (  1  ,  3  )  \"  )  ;", "String   resultI    =    expression . getValue ( new    . TestClass 1  (  )  ,    String . class )  ;", "assertCanCompile ( expression )  ;", "String   resultC    =    expression . getValue ( new    . TestClass 1  (  )  ,    String . class )  ;", "assertEquals (  \" bc \"  ,    resultI )  ;", "assertEquals (  \" bc \"  ,    resultC )  ;", "}", "METHOD_END"], "methodName": ["methodReference_literalArguments_int"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression    =    parser . parseExpression (  \" toString (  )  \"  )  ;", "String   resultI    =    getValue (  4  2  ,    String . class )  ;", "assertCanCompile (  ;", "String   resultC    =    getValue (  4  2  ,    String . class )  ;", "assertEquals (  \"  4  2  \"  ,    resultI )  ;", "assertEquals (  \"  4  2  \"  ,    resultC )  ;", "}", "METHOD_END"], "methodName": ["methodReference_simpleInstanceMethodNoArg"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parser . parseExpression (  \" intValue (  )  \"  )  ;", "int   resultI    =    getValue ( new   Integer (  4  2  )  ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    resultI )  ;", "assertCanCompile (  ;", "int   resultC    =    getValue ( new   Integer (  4  2  )  ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    resultC )  ;", "}", "METHOD_END"], "methodName": ["methodReference_simpleInstanceMethodNoArgReturnPrimitive"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression    =    parser . parseExpression (  \" indexOf (  ' b '  )  \"  )  ;", "int   resultI    =    getValue (  \" abc \"  ,    Integer . TYPE )  ;", "assertCanCompile (  ;", "int   resultC    =    getValue (  \" abc \"  ,    Integer . TYPE )  ;", "assertEquals (  1  ,    resultI )  ;", "assertEquals (  1  ,    resultC )  ;", "}", "METHOD_END"], "methodName": ["methodReference_simpleInstanceMethodOneArgReturnPrimitive1"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parser . parseExpression (  \" charAt (  2  )  \"  )  ;", "char   resultI    =    getValue (  \" abc \"  ,    Character . TYPE )  ;", "assertEquals (  ' c '  ,    resultI )  ;", "assertCanCompile (  ;", "char   resultC    =    getValue (  \" abc \"  ,    Character . TYPE )  ;", "assertEquals (  ' c '  ,    resultC )  ;", "}", "METHOD_END"], "methodName": ["methodReference_simpleInstanceMethodOneArgReturnPrimitive2"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    parser . parseExpression (  \" T ( Integer )  . valueOf (  4  2  )  \"  )  ;", "int   resultI    =    expression . getValue ( new    . TestClass 1  (  )  ,    Integer . TYPE )  ;", "assertCanCompile ( expression )  ;", "int   resultC    =    expression . getValue ( new    . TestClass 1  (  )  ,    Integer . TYPE )  ;", "assertEquals (  4  2  ,    resultI )  ;", "assertEquals (  4  2  ,    resultC )  ;", "}", "METHOD_END"], "methodName": ["methodReference_staticMethod"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    m    =    new   HashMap <  >  (  )  ;", "m . put (  \" andy \"  ,     \"  7  7  8  \"  )  ;", "=    parse (  \"  [  ' andy '  ]  =  = null ?  1  :  2  \"  )  ;", "assertEquals (  2  ,    getValue ( m )  )  ;", "assertCanCompile (  ;", "assertEquals (  2  ,    getValue ( m )  )  ;", "m . remove (  \" andy \"  )  ;", "assertEquals (  1  ,    getValue ( m )  )  ;", "}", "METHOD_END"], "methodName": ["mixingItUp_indexerOpEqTernary"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . Payload   payload    =    new   SpelCompilationCoverageTests . Payload (  )  ;", "expression    =    parser . parseExpression (  \" DR [  0  ]  . three \"  )  ;", "Object   v    =    expression . getValue ( payload )  ;", "assertEquals (  \" Lorg / springframework / expression / spel / SpelCompilationCoverageTests $ Three \"  ,    getAst (  )  . getExitDescriptor (  )  )  ;", "Expression   expression    =    parser . parseExpression (  \" DR [  0  ]  . three . four   lt    0  .  1 d ?  # root : null \"  )  ;", "v    =    expression . getValue ( payload )  ;", "SpelExpression   sExpr    =     (  ( SpelExpression )     ( expression )  )  ;", "Ternary   ternary    =     (  ( Ternary )     ( sExpr . getAST (  )  )  )  ;", "OpLT   oplt    =     (  ( OpLT )     ( ternary . getChild (  0  )  )  )  ;", "CompoundExpression   cExpr    =     (  ( CompoundExpression )     ( oplt . getLeftOperand (  )  )  )  ;", "String   cExprExitDescriptor    =    cExpr . getExitDescriptor (  )  ;", "assertEquals (  \" D \"  ,    cExprExitDescriptor )  ;", "assertEquals (  \" Z \"  ,    oplt . getExitDescriptor (  )  )  ;", "assertCanCompile ( expression )  ;", "Object   vc    =    expression . getValue ( payload )  ;", "assertEquals ( payload ,    v )  ;", "assertEquals ( payload ,    vc )  ;", "payload . DR [  0  ]  . three . four    =     0  .  1  3  ;", "vc    =    expression . getValue ( payload )  ;", "assertNull ( vc )  ;", "}", "METHOD_END"], "methodName": ["mixingItUp_propertyAccessIndexerOpLtTernaryRootNull"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    null ;", "=    parser . parseExpression (  \"  {  {  1  ,  2  ,  3  }  ,  {  4  ,  5  ,  6  }  ,  {  7  ,  8  ,  9  }  }  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \"  [  [  1  ,     2  ,     3  ]  ,     [  4  ,     5  ,     6  ]  ,     [  7  ,     8  ,     9  ]  ]  \"  ,    o . toString (  )  )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \"  [  [  1  ,     2  ,     3  ]  ,     [  4  ,     5  ,     6  ]  ,     [  7  ,     8  ,     9  ]  ]  \"  ,    o . toString (  )  )  ;", "=    parser . parseExpression (  \"  {  {  1  ,  2  ,  3  }  ,  {  4  ,  5  ,  6  }  ,  {  7  ,  8  ,  9  }  }  . toString (  )  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \"  [  [  1  ,     2  ,     3  ]  ,     [  4  ,     5  ,     6  ]  ,     [  7  ,     8  ,     9  ]  ]  \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \"  [  [  1  ,     2  ,     3  ]  ,     [  4  ,     5  ,     6  ]  ,     [  7  ,     8  ,     9  ]  ]  \"  ,    o )  ;", "=    parser . parseExpression (  \"  {  {  1  ,  2  ,  3  }  ,  {  4  ,  5  ,  6  }  ,  {  7  ,  8  ,  9  }  }  [  1  ]  [  0  ]  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  4  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  4  ,    o )  ;", "=    parser . parseExpression (  \"  {  {  1  ,  2  ,  3  }  ,  ' abc '  ,  {  7  ,  8  ,  9  }  }  [  1  ]  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" abc \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" abc \"  ,    o )  ;", "=    parser . parseExpression (  \"  ' abcde '  . substring (  {  {  1  ,  3  }  ,  1  ,  3  ,  4  }  [  0  ]  [  1  ]  )  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" de \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" de \"  ,    o )  ;", "=    parser . parseExpression (  \"  ' abcde '  . substring (  {  {  1  ,  3  }  ,  1  ,  3  ,  4  }  [  1  ]  )  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bcde \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bcde \"  ,    o )  ;", "=    parser . parseExpression (  \"  {  ' abc '  ,  {  ' def '  ,  ' ghi '  }  }  \"  )  ;", "List <  ?  >    l    =     (  ( List )     ( getValue (  )  )  )  ;", "assertEquals (  \"  [ abc ,     [ def ,    ghi ]  ]  \"  ,    l . toString (  )  )  ;", "assertCanCompile (  ;", "l    =     (  ( List )     ( getValue (  )  )  )  ;", "assertEquals (  \"  [ abc ,     [ def ,    ghi ]  ]  \"  ,    l . toString (  )  )  ;", "=    parser . parseExpression (  \"  {  ' abcde '  ,  {  ' ijklm '  ,  ' nopqr '  }  }  [  0  ]  . substring (  {  1  ,  3  ,  4  }  [  0  ]  )  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bcde \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bcde \"  ,    o )  ;", "=    parser . parseExpression (  \"  {  ' abcde '  ,  {  ' ijklm '  ,  ' nopqr '  }  }  [  1  ]  [  0  ]  . substring (  {  1  ,  3  ,  4  }  [  0  ]  )  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" jklm \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" jklm \"  ,    o )  ;", "=    parser . parseExpression (  \"  {  ' abcde '  ,  {  ' ijklm '  ,  ' nopqr '  }  }  [  1  ]  [  1  ]  . substring (  {  1  ,  3  ,  4  }  [  0  ]  ,  {  1  ,  3  ,  4  }  [  1  ]  )  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" op \"  ,    o )  ;", "assertCanCompile (  ;", "o    =    getValue (  )  ;", "assertEquals (  \" op \"  ,    o )  ;", "}", "METHOD_END"], "methodName": ["nestedInlineLists"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \" null \"  )  ;", "Object   resultI    =    expression . getValue ( new    . TestClass 1  (  )  ,    Object . class )  ;", "assertCanCompile ( expression )  ;", "Object   resultC    =    expression . getValue ( new    . TestClass 1  (  )  ,    Object . class )  ;", "assertEquals ( null ,    resultI )  ;", "assertEquals ( null ,    resultC )  ;", "assertEquals ( null ,    resultC )  ;", "}", "METHOD_END"], "methodName": ["nullLiteral"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . FooObjectHolder   foh    =    new   SpelCompilationCoverageTests . FooObjectHolder (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setRootObject ( foh )  ;", "SpelExpression   expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \" foo ?  . object \"  )  )  )  ;", "assertEquals (  \" hello \"  ,    expression . getValue ( context )  )  ;", "foh . foo    =    null ;", "assertNull ( expression . getValue ( context )  )  ;", "foh . foo    =    new   SpelCompilationCoverageTests . FooObject (  )  ;", "assertEquals (  \" hello \"  ,    expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" hello \"  ,    expression . getValue ( context )  )  ;", "foh . foo    =    null ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . propertya \"  )  )  )  ;", "context . setVariable (  \" var \"  ,    SpelCompilationCoverageTests . StaticsHelper . class )  ;", "assertEquals (  \" sh \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,    SpelCompilationCoverageTests . StaticsHelper . class )  ;", "assertEquals (  \" sh \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . a \"  )  )  )  ;", "context . setVariable (  \" var \"  ,    new   SpelCompilationCoverageTests . TestClass 4  (  )  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue ( context )  )  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,    new   SpelCompilationCoverageTests . TestClass 4  (  )  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue ( context )  )  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . four \"  )  )  )  ;", "context . setVariable (  \" var \"  ,    new   SpelCompilationCoverageTests . Three (  )  )  ;", "assertEquals (  \"  0  .  0  4  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,    new   SpelCompilationCoverageTests . Three (  )  )  ;", "assertEquals (  \"  0  .  0  4  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["nullsafeFieldPropertyDereferencing_SPR16489"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . FooObjectHolder   foh    =    new   SpelCompilationCoverageTests . FooObjectHolder (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setRootObject ( foh )  ;", "SpelExpression   expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \" getFoo (  )  ?  . getObject (  )  \"  )  )  )  ;", "assertEquals (  \" hello \"  ,    expression . getValue ( context )  )  ;", "foh . foo    =    null ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "foh . foo    =    new   SpelCompilationCoverageTests . FooObject (  )  ;", "assertEquals (  \" hello \"  ,    expression . getValue ( context )  )  ;", "foh . foo    =    null ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . methoda (  )  \"  )  )  )  ;", "context . setVariable (  \" var \"  ,    SpelCompilationCoverageTests . StaticsHelper . class )  ;", "assertEquals (  \" sh \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,    SpelCompilationCoverageTests . StaticsHelper . class )  ;", "assertEquals (  \" sh \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . intValue (  )  \"  )  )  )  ;", "context . setVariable (  \" var \"  ,     4  )  ;", "assertEquals (  \"  4  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,     4  )  ;", "assertEquals (  \"  4  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . booleanValue (  )  \"  )  )  )  ;", "context . setVariable (  \" var \"  ,    false )  ;", "assertEquals (  \" false \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,    false )  ;", "assertEquals (  \" false \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . booleanValue (  )  \"  )  )  )  ;", "context . setVariable (  \" var \"  ,    true )  ;", "assertEquals (  \" true \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,    true )  ;", "assertEquals (  \" true \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . longValue (  )  \"  )  )  )  ;", "context . setVariable (  \" var \"  ,     5 L )  ;", "assertEquals (  \"  5  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,     5 L )  ;", "assertEquals (  \"  5  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . floatValue (  )  \"  )  )  )  ;", "context . setVariable (  \" var \"  ,     3  .  0 F )  ;", "assertEquals (  \"  3  .  0  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,     3  .  0 F )  ;", "assertEquals (  \"  3  .  0  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "expression    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  # var ?  . shortValue (  )  \"  )  )  )  ;", "context . setVariable (  \" var \"  ,     (  ( short )     (  8  )  )  )  ;", "assertEquals (  \"  8  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "assertCanCompile ( expression )  ;", "context . setVariable (  \" var \"  ,     (  ( short )     (  8  )  )  )  ;", "assertEquals (  \"  8  \"  ,    expression . getValue ( context )  . toString (  )  )  ;", "context . setVariable (  \" var \"  ,    null )  ;", "assertNull ( expression . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["nullsafeMethodChaining_SPR16489"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    parser . parseExpression (  \" false   and   false \"  )  ;", "boolean   resultI    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "SpelCompiler . compile ( expression )  ;", "boolean   resultC    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( false ,    resultI )  ;", "assertEquals ( false ,    resultC )  ;", "expression    =    parser . parseExpression (  \" false   and   true \"  )  ;", "resultI    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "SpelCompiler . compile ( expression )  ;", "resultC    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( false ,    resultI )  ;", "assertEquals ( false ,    resultC )  ;", "expression    =    parser . parseExpression (  \" true   and   false \"  )  ;", "resultI    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "SpelCompiler . compile ( expression )  ;", "resultC    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( false ,    resultI )  ;", "assertEquals ( false ,    resultC )  ;", "expression    =    parser . parseExpression (  \" true   and   true \"  )  ;", "resultI    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "SpelCompiler . compile ( expression )  ;", "resultC    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( true ,    resultI )  ;", "assertEquals ( true ,    resultC )  ;", ". TestClass 4    tc    =    new    . TestClass 4  (  )  ;", "expression    =    parser . parseExpression (  \" getfalse (  )    and   gettrue (  )  \"  )  ;", "resultI    =    expression . getValue ( tc ,    Boolean . TYPE )  ;", "assertCantCompile ( expression )  ;", "expression    =    parser . parseExpression (  \" getA (  )    and   getB (  )  \"  )  ;", "tc . a    =    false ;", "tc . b    =    false ;", "resultI    =    expression . getValue ( tc ,    Boolean . TYPE )  ;", "assertCantCompile ( expression )  ;", "tc . a    =    true ;", "tc . b    =    false ;", "resultI    =    expression . getValue ( tc ,    Boolean . TYPE )  ;", "assertCanCompile ( expression )  ;", "assertFalse ( resultI )  ;", "tc . a    =    true ;", "tc . b    =    true ;", "resultI    =    expression . getValue ( tc ,    Boolean . TYPE )  ;", "assertTrue ( resultI )  ;", "boolean   b    =    true ;", "expression    =    parse (  \"  # root   and    # root \"  )  ;", "Object   resultI 2     =    expression . getValue ( b )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( resultI 2  )  )  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( b )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["opAnd"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  2  /  2  \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  1  ,    getValue (  )  )  ;", "=    parse (  \"  2 L /  2 L \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  1 L ,    getValue (  )  )  ;", "=    parse (  \"  2  .  0 f /  2  .  0 f \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  1  .  0 F ,    getValue (  )  )  ;", "=    parse (  \"  3  .  0 d /  4  .  0 d \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  0  .  7  5  ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  6  .  0 f )  /  2  \"  )  ;", "assertEquals (  3  .  0 F ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  3  .  0 F ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  8  .  0 f )  / T ( Float )  . valueOf (  2  .  0 f )  \"  )  ;", "assertEquals (  4  .  0 F ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  4  .  0 F ,    getValue (  )  )  ;", "=    parse (  \"  1  2 L / T ( Long )  . valueOf (  4 L )  \"  )  ;", "assertEquals (  3 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  3 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  4  4 L )  /  1  1  \"  )  ;", "assertEquals (  4 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  4 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  4 L )  / T ( Long )  . valueOf (  2 L )  \"  )  ;", "assertEquals (  2 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  2 L ,    getValue (  )  )  ;", "=    parse (  \"  8 L / T ( Long )  . valueOf (  2 L )  \"  )  ;", "assertEquals (  4 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  4 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  8  .  0 f )  /  - T ( Float )  . valueOf (  4  .  0 f )  \"  )  ;", "assertEquals (  (  -  2  .  0 F )  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  2  .  0 F )  ,    getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["opDivide"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . PayloadX   p    =    new   SpelCompilationCoverageTests . PayloadX (  )  ;", "checkCalc ( p ,     \" payload . valueSB /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI /  6  0 D \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI / payload . valueDB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB /  6  0 F \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD /  6  0 F \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI /  6  0 F \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB / payload . valueFB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD / payload . valueFB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI / payload . valueFB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB /  6  0 L \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueBB /  6  0 L \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueFB /  6  0 L \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB /  6  0 L \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB /  6  0 L \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueIB /  6  0 L \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueS /  6  0 L \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueB /  6  0 L \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueF /  6  0 L \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD /  6  0 L \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ /  6  0 L \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueI /  6  0 L \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueSB / payload . valueJB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueBB / payload . valueJB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueFB / payload . valueJB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB / payload . valueJB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB / payload . valueJB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueIB / payload . valueJB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueS / payload . valueJB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueB / payload . valueJB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueF / payload . valueJB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD / payload . valueJB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ / payload . valueJB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueI / payload . valueJB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueSB /  6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueBB /  6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueFB /  6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB /  6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB /  6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueIB /  6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueS /  6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueB /  6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueF /  6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD /  6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ /  6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueI /  6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueSB / payload . valueIB 6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueBB / payload . valueIB 6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueFB / payload . valueIB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB / payload . valueIB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB / payload . valueIB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueIB / payload . valueIB 6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueS / payload . valueIB 6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueB / payload . valueIB 6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueF / payload . valueIB 6  0  \"  ,     2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD / payload . valueIB 6  0  \"  ,     2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ / payload . valueIB 6  0  \"  ,     2 L )  ;", "checkCalc ( p ,     \" payload . valueI / payload . valueIB 6  0  \"  ,     2  )  ;", "checkCalc ( p ,     \" payload . valueSB / payload . valueS \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueBB / payload . valueS \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueFB / payload . valueS \"  ,     1  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB / payload . valueS \"  ,     1  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB / payload . valueS \"  ,     1 L )  ;", "checkCalc ( p ,     \" payload . valueIB / payload . valueS \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueS / payload . valueS \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueB / payload . valueS \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueF / payload . valueS \"  ,     1  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD / payload . valueS \"  ,     1  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ / payload . valueS \"  ,     1 L )  ;", "checkCalc ( p ,     \" payload . valueI / payload . valueS \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueSB / payload . valueSB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueBB / payload . valueSB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueFB / payload . valueSB \"  ,     1  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB / payload . valueSB \"  ,     1  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB / payload . valueSB \"  ,     1 L )  ;", "checkCalc ( p ,     \" payload . valueIB / payload . valueSB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueS / payload . valueSB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueB / payload . valueSB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueF / payload . valueSB \"  ,     1  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD / payload . valueSB \"  ,     1  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ / payload . valueSB \"  ,     1 L )  ;", "checkCalc ( p ,     \" payload . valueI / payload . valueSB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueSB / payload . valueB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueBB / payload . valueB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueFB / payload . valueB \"  ,     1  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB / payload . valueB \"  ,     1  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB / payload . valueB \"  ,     1 L )  ;", "checkCalc ( p ,     \" payload . valueIB / payload . valueB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueS / payload . valueB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueB / payload . valueB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueF / payload . valueB \"  ,     1  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD / payload . valueB \"  ,     1  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ / payload . valueB \"  ,     1 L )  ;", "checkCalc ( p ,     \" payload . valueI / payload . valueB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueSB / payload . valueBB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueBB / payload . valueBB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueFB / payload . valueBB \"  ,     1  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB / payload . valueBB \"  ,     1  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB / payload . valueBB \"  ,     1 L )  ;", "checkCalc ( p ,     \" payload . valueIB / payload . valueBB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueS / payload . valueBB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueB / payload . valueBB \"  ,     1  )  ;", "checkCalc ( p ,     \" payload . valueF / payload . valueBB \"  ,     1  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD / payload . valueBB \"  ,     1  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ / payload . valueBB \"  ,     1 L )  ;", "checkCalc ( p ,     \" payload . valueI / payload . valueBB \"  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["opDivide_mixedNumberTypes"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "String   tvar    =     \"  3  5  \"  ;", "expression    =    parse (  \"  # root    =  =     3  5  \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue ( tvar )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue ( tvar )  )  )  )  ;", "expression    =    parse (  \"  3  5     =  =     # root \"  )  ;", "expression . getValue ( tvar )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue ( tvar )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue ( tvar )  )  )  )  ;", ". TestClass 7    tc 7     =    new    . TestClass 7  (  )  ;", "expression    =    parse (  \" property    =  =     ' UK '  \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( tc 7  )  )  )  )  ;", ". TestClass 7  . property    =    null ;", "assertFalse (  (  ( Boolean )     ( expression . getValue ( tc 7  )  )  )  )  ;", "assertCanCompile ( expression )  ;", ". TestClass 7  . reset (  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( tc 7  )  )  )  )  ;", ". TestClass 7  . property    =     \" UK \"  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( tc 7  )  )  )  )  ;", ". TestClass 7  . reset (  )  ;", ". TestClass 7  . property    =    null ;", "assertFalse (  (  ( Boolean )     ( expression . getValue ( tc 7  )  )  )  )  ;", "expression    =    parse (  \" property    =  =    null \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( tc 7  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( tc 7  )  )  )  )  ;", "expression    =    parse (  \"  3  .  0 d    =  =     4  .  0 d \"  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  3  4  4  6  .  0 d    =  =     3  4  4  6  .  0 d \"  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  3     =  =     1  \"  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  3     =  =     3  \"  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  3  .  0 f    =  =     1  .  0 f \"  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  2  .  0 f    =  =     2  .  0 f \"  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  3  0 L    =  =     3  0 L \"  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  1  5 L    =  =     2  0 L \"  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  1     =  =     3  .  0 d \"  )  ;", "assertCantCompile ( expression )  ;", "Double   d    =     3  .  0  ;", "expression    =    parse (  \"  # root =  =  3  .  0 d \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( d )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( d )  )  )  )  ;", "Integer   i    =     3  ;", "expression    =    parse (  \"  # root =  =  3  \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( i )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( i )  )  )  )  ;", "Float   f    =     3  .  0 F ;", "expression    =    parse (  \"  # root =  =  3  .  0 f \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( f )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( f )  )  )  )  ;", "long   l    =     3  0  0 L ;", "expression    =    parse (  \"  # root =  =  3  0  0 l \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( l )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( l )  )  )  )  ;", "boolean   b    =    true ;", "expression    =    parse (  \"  # root =  = true \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( b )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue ( b )  )  )  )  ;", "expression    =    parse (  \" T ( Integer )  . valueOf (  3  )     =  =     4  \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" T ( Integer )  . valueOf (  3  )     =  =    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  5     =  =    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" T ( Float )  . valueOf (  3  .  0 f )     =  =     4  .  0 f \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" T ( Float )  . valueOf (  3  .  0 f )     =  =    T ( Float )  . valueOf (  3  .  0 f )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  5  .  0 f    =  =    T ( Float )  . valueOf (  3  .  0 f )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" T ( Long )  . valueOf (  3 L )     =  =     4 L \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" T ( Long )  . valueOf (  3 L )     =  =    T ( Long )  . valueOf (  3 L )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  5 L    =  =    T ( Long )  . valueOf (  3 L )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" T ( Double )  . valueOf (  3  .  0 d )     =  =     4  .  0 d \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" T ( Double )  . valueOf (  3  .  0 d )     =  =    T ( Double )  . valueOf (  3  .  0 d )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \"  5  .  0 d    =  =    T ( Double )  . valueOf (  3  .  0 d )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" false    =  =    true \"  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" T ( Boolean )  . valueOf (  ' true '  )     =  =    T ( Boolean )  . valueOf (  ' true '  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" T ( Boolean )  . valueOf (  ' true '  )     =  =    true \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "expression    =    parse (  \" false    =  =    T ( Boolean )  . valueOf (  ' false '  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue (  (  ( Boolean )     ( expression . getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["opEq"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \"  # aa =  =  # bb \"  )  ;", "StandardEvaluationContext   sec    =    new   StandardEvaluationContext (  )  ;", ". Apple   aa    =    new    . Apple (  1  )  ;", ". Apple   bb    =    new    . Apple (  2  )  ;", "sec . setVariable (  \" aa \"  ,    aa )  ;", "sec . setVariable (  \" bb \"  ,    bb )  ;", "boolean   b    =    expression . getValue ( sec ,    Boolean . class )  ;", "assertEquals ( bb ,    aa . gotComparedTo )  ;", "assertFalse ( b )  ;", "bb . setValue (  1  )  ;", "b    =    expression . getValue ( sec ,    Boolean . class )  ;", "assertEquals ( bb ,    aa . gotComparedTo )  ;", "assertTrue ( b )  ;", "assertCanCompile ( expression )  ;", "aa    =    new    . Apple (  9  9  )  ;", "bb    =    new    . Apple (  1  0  0  )  ;", "sec . setVariable (  \" aa \"  ,    aa )  ;", "sec . setVariable (  \" bb \"  ,    bb )  ;", "b    =    expression . getValue ( sec ,    Boolean . class )  ;", "assertFalse ( b )  ;", "assertEquals ( bb ,    aa . gotComparedTo )  ;", "bb . setValue (  9  9  )  ;", "b    =    expression . getValue ( sec ,    Boolean . class )  ;", "assertTrue ( b )  ;", "assertEquals ( bb ,    aa . gotComparedTo )  ;", "List < String >    ls    =    new   ArrayList < String >  (  )  ;", "ls . add ( new   String (  \" foo \"  )  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( ls )  ;", "expression    =    parse (  \" get (  0  )     =  =     ' foo '  \"  )  ;", "assertTrue ( expression . getValue ( context ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( context ,    Boolean . class )  )  ;", "ls . remove (  0  )  ;", "ls . add (  \" goo \"  )  ;", "assertFalse ( expression . getValue ( context ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["opEq_SPR14863"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  3  .  0 d    >  =     4  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  4  4  6  .  0 d    >  =     1  1  2  3  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  4  4  6  .  0 d    >  =     3  4  4  6  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3     >  =     1  \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  2     >  =     4  \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3     >  =     3  \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  .  0 f    >  =     1  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1  .  0 f    >  =     5  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  .  0 f    >  =     3  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  4  0 L    >  =     3  0 L \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1  5 L    >  =     2  0 L \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  0 L    >  =     3  0 L \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1     >  =     3  .  0 d \"  )  ;", "assertCantCompile (  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     >  =     4  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     >  =    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  5     >  =    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["opGe"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  3  .  0 d    >     4  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  4  4  6  .  0 d    >     1  1  2  3  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3     >     1  \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  2     >     4  \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  .  0 f    >     1  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1  .  0 f    >     5  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  0 L    >     3  0 L \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1  5 L    >     2  0 L \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1     >     3  .  0 d \"  )  ;", "assertCantCompile (  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     >     4  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     >    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  5     >    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["opGt"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  3  .  0 d    <  =     4  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  4  4  6  .  0 d    <  =     1  1  2  3  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  4  4  6  .  0 d    <  =     3  4  4  6  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3     <  =     1  \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  2     <  =     4  \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3     <  =     3  \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  .  0 f    <  =     1  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1  .  0 f    <  =     5  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  2  .  0 f    <  =     2  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  0 L    <  =     3  0 L \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1  5 L    <  =     2  0 L \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1     <  =     3  .  0 d \"  )  ;", "assertCantCompile (  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     <  =     4  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     <  =    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  5     <  =    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["opLe"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  3  .  0 d    <     4  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  4  4  6  .  0 d    <     1  1  2  3  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3     <     1  \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  2     <     4  \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  .  0 f    <     1  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1  .  0 f    <     5  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  0 L    <     3  0 L \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1  5 L    <     2  0 L \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1     <     3  .  0 d \"  )  ;", "assertCantCompile (  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     <     4  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     <    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  5     <    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["opLt"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  2  -  2  \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  0  ,    getValue (  )  )  ;", "=    parse (  \"  4 L -  2 L \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  2 L ,    getValue (  )  )  ;", "=    parse (  \"  4  .  0 f -  2  .  0 f \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  2  .  0 F ,    getValue (  )  )  ;", "=    parse (  \"  3  .  0 d -  4  .  0 d \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  1  .  0  )  ,    getValue (  )  )  ;", "=    parse (  \"  -  1  \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  1  )  ,    getValue (  )  )  ;", "=    parse (  \"  -  1 L \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  1 L )  ,    getValue (  )  )  ;", "=    parse (  \"  -  1  .  5 f \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  1  .  5 F )  ,    getValue (  )  )  ;", "=    parse (  \"  -  2  .  5 d \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  2  .  5  )  ,    getValue (  )  )  ;", "=    parse (  \" T ( Integer )  . valueOf (  2  )  -  6  \"  )  ;", "assertEquals (  (  -  4  )  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  4  )  ,    getValue (  )  )  ;", "=    parse (  \" T ( Integer )  . valueOf (  1  )  - T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertEquals (  (  -  2  )  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  2  )  ,    getValue (  )  )  ;", "=    parse (  \"  4  - T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertEquals (  1  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  1  ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  2  .  0 f )  -  6  \"  )  ;", "assertEquals (  (  -  4  .  0 F )  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  4  .  0 F )  ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  8  .  0 f )  - T ( Float )  . valueOf (  3  .  0 f )  \"  )  ;", "assertEquals (  5  .  0 F ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  5  .  0 F ,    getValue (  )  )  ;", "=    parse (  \"  1  1 L - T ( Long )  . valueOf (  4 L )  \"  )  ;", "assertEquals (  7 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  7 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  9 L )  -  6  \"  )  ;", "assertEquals (  3 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  3 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  4 L )  - T ( Long )  . valueOf (  3 L )  \"  )  ;", "assertEquals (  1 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  1 L ,    getValue (  )  )  ;", "=    parse (  \"  8 L - T ( Long )  . valueOf (  2 L )  \"  )  ;", "assertEquals (  6 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  6 L ,    getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["opMinus"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . PayloadX   p    =    new   SpelCompilationCoverageTests . PayloadX (  )  ;", "checkCalc ( p ,     \" payload . valueSB -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI -  6  0 D \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI - payload . valueDB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB -  6  0 F \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD -  6  0 F \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI -  6  0 F \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB - payload . valueFB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD - payload . valueFB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI - payload . valueFB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB -  6  0 L \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueBB -  6  0 L \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueFB -  6  0 L \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB -  6  0 L \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB -  6  0 L \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB -  6  0 L \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueS -  6  0 L \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueB -  6  0 L \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueF -  6  0 L \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD -  6  0 L \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ -  6  0 L \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueI -  6  0 L \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueSB - payload . valueJB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueBB - payload . valueJB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueFB - payload . valueJB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB - payload . valueJB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB - payload . valueJB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB - payload . valueJB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueS - payload . valueJB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueB - payload . valueJB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueF - payload . valueJB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD - payload . valueJB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ - payload . valueJB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueI - payload . valueJB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueSB -  6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueBB -  6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueFB -  6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB -  6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB -  6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB -  6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueS -  6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueB -  6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueF -  6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD -  6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ -  6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueI -  6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueSB - payload . valueIB 6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueBB - payload . valueIB 6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueFB - payload . valueIB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB - payload . valueIB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB - payload . valueIB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB - payload . valueIB 6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueS - payload . valueIB 6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueB - payload . valueIB 6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueF - payload . valueIB 6  0  \"  ,     6  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD - payload . valueIB 6  0  \"  ,     6  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ - payload . valueIB 6  0  \"  ,     6  0 L )  ;", "checkCalc ( p ,     \" payload . valueI - payload . valueIB 6  0  \"  ,     6  0  )  ;", "checkCalc ( p ,     \" payload . valueSB - payload . valueS 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB - payload . valueS 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB - payload . valueS 2  0  \"  ,     1  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB - payload . valueS 2  0  \"  ,     1  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB - payload . valueS 2  0  \"  ,     1  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB - payload . valueS 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS - payload . valueS 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB - payload . valueS 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF - payload . valueS 2  0  \"  ,     1  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD - payload . valueS 2  0  \"  ,     1  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ - payload . valueS 2  0  \"  ,     1  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI - payload . valueS 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueSB - payload . valueSB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB - payload . valueSB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB - payload . valueSB 2  0  \"  ,     1  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB - payload . valueSB 2  0  \"  ,     1  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB - payload . valueSB 2  0  \"  ,     1  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB - payload . valueSB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS - payload . valueSB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB - payload . valueSB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF - payload . valueSB 2  0  \"  ,     1  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD - payload . valueSB 2  0  \"  ,     1  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ - payload . valueSB 2  0  \"  ,     1  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI - payload . valueSB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueSB - payload . valueB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB - payload . valueB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB - payload . valueB 2  0  \"  ,     1  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB - payload . valueB 2  0  \"  ,     1  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB - payload . valueB 2  0  \"  ,     1  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB - payload . valueB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS - payload . valueB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB - payload . valueB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF - payload . valueB 2  0  \"  ,     1  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD - payload . valueB 2  0  \"  ,     1  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ - payload . valueB 2  0  \"  ,     1  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI - payload . valueB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueSB - payload . valueBB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB - payload . valueBB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB - payload . valueBB 2  0  \"  ,     1  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB - payload . valueBB 2  0  \"  ,     1  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB - payload . valueBB 2  0  \"  ,     1  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB - payload . valueBB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS - payload . valueBB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB - payload . valueBB 2  0  \"  ,     1  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF - payload . valueBB 2  0  \"  ,     1  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD - payload . valueBB 2  0  \"  ,     1  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ - payload . valueBB 2  0  \"  ,     1  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI - payload . valueBB 2  0  \"  ,     1  0  0  )  ;", "}", "METHOD_END"], "methodName": ["opMinus_mixedNumberTypes"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parse (  \"  2  %  2  \"  )  ;", "assertEquals (  0  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  0  ,    expression . getValue (  )  )  ;", "expression    =    parse (  \" payload %  2  =  =  0  \"  )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper (  4  )  ,    Boolean . TYPE )  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper (  5  )  ,    Boolean . TYPE )  )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( expression . getValue ( new    . GenericMessageTestHelper (  4  )  ,    Boolean . TYPE )  )  ;", "assertFalse ( expression . getValue ( new    . GenericMessageTestHelper (  5  )  ,    Boolean . TYPE )  )  ;", "expression    =    parse (  \"  8  %  3  \"  )  ;", "assertEquals (  2  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  ,    expression . getValue (  )  )  ;", "expression    =    parse (  \"  1  7 L %  5 L \"  )  ;", "assertEquals (  2 L ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2 L ,    expression . getValue (  )  )  ;", "expression    =    parse (  \"  3  .  0 f %  2  .  0 f \"  )  ;", "assertEquals (  1  .  0 F ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  .  0 F ,    expression . getValue (  )  )  ;", "expression    =    parse (  \"  3  .  0 d %  4  .  0 d \"  )  ;", "assertEquals (  3  .  0  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  3  .  0  ,    expression . getValue (  )  )  ;", "expression    =    parse (  \" T ( Float )  . valueOf (  6  .  0 f )  %  2  \"  )  ;", "assertEquals (  0  .  0 F ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  0  .  0 F ,    expression . getValue (  )  )  ;", "expression    =    parse (  \" T ( Float )  . valueOf (  6  .  0 f )  %  4  \"  )  ;", "assertEquals (  2  .  0 F ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  .  0 F ,    expression . getValue (  )  )  ;", "expression    =    parse (  \" T ( Float )  . valueOf (  8  .  0 f )  % T ( Float )  . valueOf (  3  .  0 f )  \"  )  ;", "assertEquals (  2  .  0 F ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  2  .  0 F ,    expression . getValue (  )  )  ;", "expression    =    parse (  \"  1  3 L % T ( Long )  . valueOf (  4 L )  \"  )  ;", "assertEquals (  1 L ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1 L ,    expression . getValue (  )  )  ;", "expression    =    parse (  \" T ( Long )  . valueOf (  4  4 L )  %  1  2  \"  )  ;", "assertEquals (  8 L ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  8 L ,    expression . getValue (  )  )  ;", "expression    =    parse (  \" T ( Long )  . valueOf (  9 L )  % T ( Long )  . valueOf (  2 L )  \"  )  ;", "assertEquals (  1 L ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1 L ,    expression . getValue (  )  )  ;", "expression    =    parse (  \"  7 L % T ( Long )  . valueOf (  2 L )  \"  )  ;", "assertEquals (  1 L ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1 L ,    expression . getValue (  )  )  ;", "expression    =    parse (  \" T ( Float )  . valueOf (  9  .  0 f )  %  - T ( Float )  . valueOf (  4  .  0 f )  \"  )  ;", "assertEquals (  1  .  0 F ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  1  .  0 F ,    expression . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["opModulus_12041"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . PayloadX   p    =    new   SpelCompilationCoverageTests . PayloadX (  )  ;", "checkCalc ( p ,     \" payload . valueSB %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI %  5  8 D \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI % payload . valueDB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB %  5  8 F \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD %  5  8 F \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI %  5  8 F \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB % payload . valueFB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD % payload . valueFB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI % payload . valueFB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB %  5  8 L \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueBB %  5  8 L \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueFB %  5  8 L \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB %  5  8 L \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB %  5  8 L \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueIB %  5  8 L \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueS %  5  8 L \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueB %  5  8 L \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueF %  5  8 L \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD %  5  8 L \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ %  5  8 L \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueI %  5  8 L \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueSB % payload . valueJB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueBB % payload . valueJB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueFB % payload . valueJB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB % payload . valueJB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB % payload . valueJB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueIB % payload . valueJB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueS % payload . valueJB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueB % payload . valueJB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueF % payload . valueJB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD % payload . valueJB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ % payload . valueJB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueI % payload . valueJB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueSB %  5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueBB %  5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueFB %  5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB %  5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB %  5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueIB %  5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueS %  5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueB %  5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueF %  5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD %  5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ %  5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueI %  5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueSB % payload . valueIB 5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueBB % payload . valueIB 5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueFB % payload . valueIB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB % payload . valueIB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB % payload . valueIB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueIB % payload . valueIB 5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueS % payload . valueIB 5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueB % payload . valueIB 5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueF % payload . valueIB 5  8  \"  ,     4  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD % payload . valueIB 5  8  \"  ,     4  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ % payload . valueIB 5  8  \"  ,     4 L )  ;", "checkCalc ( p ,     \" payload . valueI % payload . valueIB 5  8  \"  ,     4  )  ;", "checkCalc ( p ,     \" payload . valueSB % payload . valueS 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueBB % payload . valueS 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueFB % payload . valueS 1  8  \"  ,     1  2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB % payload . valueS 1  8  \"  ,     1  2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB % payload . valueS 1  8  \"  ,     1  2 L )  ;", "checkCalc ( p ,     \" payload . valueIB % payload . valueS 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueS % payload . valueS 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueB % payload . valueS 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueF % payload . valueS 1  8  \"  ,     1  2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD % payload . valueS 1  8  \"  ,     1  2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ % payload . valueS 1  8  \"  ,     1  2 L )  ;", "checkCalc ( p ,     \" payload . valueI % payload . valueS 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueSB % payload . valueSB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueBB % payload . valueSB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueFB % payload . valueSB 1  8  \"  ,     1  2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB % payload . valueSB 1  8  \"  ,     1  2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB % payload . valueSB 1  8  \"  ,     1  2 L )  ;", "checkCalc ( p ,     \" payload . valueIB % payload . valueSB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueS % payload . valueSB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueB % payload . valueSB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueF % payload . valueSB 1  8  \"  ,     1  2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD % payload . valueSB 1  8  \"  ,     1  2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ % payload . valueSB 1  8  \"  ,     1  2 L )  ;", "checkCalc ( p ,     \" payload . valueI % payload . valueSB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueSB % payload . valueB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueBB % payload . valueB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueFB % payload . valueB 1  8  \"  ,     1  2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB % payload . valueB 1  8  \"  ,     1  2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB % payload . valueB 1  8  \"  ,     1  2 L )  ;", "checkCalc ( p ,     \" payload . valueIB % payload . valueB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueS % payload . valueB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueB % payload . valueB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueF % payload . valueB 1  8  \"  ,     1  2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD % payload . valueB 1  8  \"  ,     1  2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ % payload . valueB 1  8  \"  ,     1  2 L )  ;", "checkCalc ( p ,     \" payload . valueI % payload . valueB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueSB % payload . valueBB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueBB % payload . valueBB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueFB % payload . valueBB 1  8  \"  ,     1  2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB % payload . valueBB 1  8  \"  ,     1  2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB % payload . valueBB 1  8  \"  ,     1  2 L )  ;", "checkCalc ( p ,     \" payload . valueIB % payload . valueBB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueS % payload . valueBB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueB % payload . valueBB 1  8  \"  ,     1  2  )  ;", "checkCalc ( p ,     \" payload . valueF % payload . valueBB 1  8  \"  ,     1  2  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD % payload . valueBB 1  8  \"  ,     1  2  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ % payload . valueBB 1  8  \"  ,     1  2 L )  ;", "checkCalc ( p ,     \" payload . valueI % payload . valueBB 1  8  \"  ,     1  2  )  ;", "}", "METHOD_END"], "methodName": ["opModulus_mixedNumberTypes"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  2  *  2  \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  4  ,    getValue (  )  )  ;", "=    parse (  \"  2 L *  2 L \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  4 L ,    getValue (  )  )  ;", "=    parse (  \"  2  .  0 f *  2  .  0 f \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  4  .  0 F ,    getValue (  )  )  ;", "=    parse (  \"  3  .  0 d *  4  .  0 d \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  1  2  .  0  ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  2  .  0 f )  *  6  \"  )  ;", "assertEquals (  1  2  .  0 F ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  1  2  .  0 F ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  8  .  0 f )  * T ( Float )  . valueOf (  3  .  0 f )  \"  )  ;", "assertEquals (  2  4  .  0 F ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  2  4  .  0 F ,    getValue (  )  )  ;", "=    parse (  \"  1  1 L * T ( Long )  . valueOf (  4 L )  \"  )  ;", "assertEquals (  4  4 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  4  4 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  9 L )  *  6  \"  )  ;", "assertEquals (  5  4 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  5  4 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  4 L )  * T ( Long )  . valueOf (  3 L )  \"  )  ;", "assertEquals (  1  2 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  1  2 L ,    getValue (  )  )  ;", "=    parse (  \"  8 L * T ( Long )  . valueOf (  2 L )  \"  )  ;", "assertEquals (  1  6 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  1  6 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  8  .  0 f )  *  - T ( Float )  . valueOf (  3  .  0 f )  \"  )  ;", "assertEquals (  (  -  2  4  .  0 F )  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  (  -  2  4  .  0 F )  ,    getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["opMultiply"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . PayloadX   p    =    new   SpelCompilationCoverageTests . PayloadX (  )  ;", "checkCalc ( p ,     \" payload . valueSB *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI *  6  0 D \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI * payload . valueDB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB *  6  0 F \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD *  6  0 F \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI *  6  0 F \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI * payload . valueFB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB *  6  0 L \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueBB *  6  0 L \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueFB *  6  0 L \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB *  6  0 L \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB *  6  0 L \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB *  6  0 L \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueS *  6  0 L \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueB *  6  0 L \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueF *  6  0 L \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD *  6  0 L \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ *  6  0 L \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI *  6  0 L \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueSB * payload . valueJB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueBB * payload . valueJB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueFB * payload . valueJB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB * payload . valueJB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB * payload . valueJB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB * payload . valueJB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueS * payload . valueJB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueB * payload . valueJB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueF * payload . valueJB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD * payload . valueJB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ * payload . valueJB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI * payload . valueJB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueSB *  6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB *  6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB *  6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB *  6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB *  6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB *  6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS *  6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB *  6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF *  6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD *  6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ *  6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI *  6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueSB * payload . valueIB 6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB * payload . valueIB 6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB * payload . valueIB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB * payload . valueIB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB * payload . valueIB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB * payload . valueIB 6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS * payload . valueIB 6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB * payload . valueIB 6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF * payload . valueIB 6  0  \"  ,     7  2  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD * payload . valueIB 6  0  \"  ,     7  2  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ * payload . valueIB 6  0  \"  ,     7  2  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI * payload . valueIB 6  0  \"  ,     7  2  0  0  )  ;", "checkCalc ( p ,     \" payload . valueSB * payload . valueS 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB * payload . valueS 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB * payload . valueS 2  0  \"  ,     2  4  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB * payload . valueS 2  0  \"  ,     2  4  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB * payload . valueS 2  0  \"  ,     2  4  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB * payload . valueS 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS * payload . valueS 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB * payload . valueS 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF * payload . valueS 2  0  \"  ,     2  4  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD * payload . valueS 2  0  \"  ,     2  4  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ * payload . valueS 2  0  \"  ,     2  4  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI * payload . valueS 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueSB * payload . valueSB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB * payload . valueSB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB * payload . valueSB 2  0  \"  ,     2  4  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB * payload . valueSB 2  0  \"  ,     2  4  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB * payload . valueSB 2  0  \"  ,     2  4  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB * payload . valueSB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS * payload . valueSB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB * payload . valueSB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF * payload . valueSB 2  0  \"  ,     2  4  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD * payload . valueSB 2  0  \"  ,     2  4  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ * payload . valueSB 2  0  \"  ,     2  4  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI * payload . valueSB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueSB * payload . valueB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB * payload . valueB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB * payload . valueB 2  0  \"  ,     2  4  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB * payload . valueB 2  0  \"  ,     2  4  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB * payload . valueB 2  0  \"  ,     2  4  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB * payload . valueB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS * payload . valueB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB * payload . valueB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF * payload . valueB 2  0  \"  ,     2  4  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD * payload . valueB 2  0  \"  ,     2  4  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ * payload . valueB 2  0  \"  ,     2  4  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI * payload . valueB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueSB * payload . valueBB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueBB * payload . valueBB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueFB * payload . valueBB 2  0  \"  ,     2  4  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB * payload . valueBB 2  0  \"  ,     2  4  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB * payload . valueBB 2  0  \"  ,     2  4  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB * payload . valueBB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueS * payload . valueBB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueB * payload . valueBB 2  0  \"  ,     2  4  0  0  )  ;", "checkCalc ( p ,     \" payload . valueF * payload . valueBB 2  0  \"  ,     2  4  0  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD * payload . valueBB 2  0  \"  ,     2  4  0  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ * payload . valueBB 2  0  \"  ,     2  4  0  0 L )  ;", "checkCalc ( p ,     \" payload . valueI * payload . valueBB 2  0  \"  ,     2  4  0  0  )  ;", "}", "METHOD_END"], "methodName": ["opMultiply_mixedNumberTypes"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  3  .  0 d    !  =     4  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  4  4  6  .  0 d    !  =     3  4  4  6  .  0 d \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3     !  =     1  \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3     !  =     3  \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  .  0 f    !  =     1  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  2  .  0 f    !  =     2  .  0 f \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  3  0 L    !  =     3  0 L \"  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1  5 L    !  =     2  0 L \"  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  1     !  =     3  .  0 d \"  )  ;", "assertCantCompile (  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     !  =     4  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Integer )  . valueOf (  3  )     !  =    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  5     !  =    T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  3  .  0 f )     !  =     4  .  0 f \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  3  .  0 f )     !  =    T ( Float )  . valueOf (  3  .  0 f )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  5  .  0 f    !  =    T ( Float )  . valueOf (  3  .  0 f )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  3 L )     !  =     4 L \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  3 L )     !  =    T ( Long )  . valueOf (  3 L )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  5 L    !  =    T ( Long )  . valueOf (  3 L )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Double )  . valueOf (  3  .  0 d )     =  =     4  .  0 d \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Double )  . valueOf (  3  .  0 d )     =  =    T ( Double )  . valueOf (  3  .  0 d )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \"  5  .  0 d    =  =    T ( Double )  . valueOf (  3  .  0 d )  \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" false    =  =    true \"  )  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertFalse (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Boolean )  . valueOf (  ' true '  )     =  =    T ( Boolean )  . valueOf (  ' true '  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" T ( Boolean )  . valueOf (  ' true '  )     =  =    true \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "=    parse (  \" false    =  =    T ( Boolean )  . valueOf (  ' false '  )  \"  )  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "assertCanCompile (  ;", "assertTrue (  (  ( Boolean )     ( getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["opNe"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelParserConfiguration   configuration    =    new   SpelParserConfiguration ( SpelCompilerMode . MIXED ,    ClassLoader . getSystemClassLoader (  )  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser ( configuration )  ;", "Expression   expression    =    parser . parseExpression (  \" data [  ' my - key '  ]     !  =     ' my - value '  \"  )  ;", "Map < String ,    String >    data    =    new   HashMap <  >  (  )  ;", "data . put (  \" my - key \"  ,    new   String (  \" my - value \"  )  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new    . MyContext ( data )  )  ;", "assertFalse ( expression . getValue ( context ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "(  ( SpelExpression )     ( expression )  )  . compileExpression (  )  ;", "assertFalse ( expression . getValue ( context ,    Boolean . class )  )  ;", "List < String >    ls    =    new   ArrayList < String >  (  )  ;", "ls . add ( new   String (  \" foo \"  )  )  ;", "context    =    new   StandardEvaluationContext ( ls )  ;", "expression    =    parse (  \" get (  0  )     !  =     ' foo '  \"  )  ;", "assertFalse ( expression . getValue ( context ,    Boolean . class )  )  ;", "assertCanCompile ( expression )  ;", "assertFalse ( expression . getValue ( context ,    Boolean . class )  )  ;", "ls . remove (  0  )  ;", "ls . add (  \" goo \"  )  ;", "assertTrue ( expression . getValue ( context ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["opNe_SPR14863"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    parser . parseExpression (  \" false   or   false \"  )  ;", "boolean   resultI    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "SpelCompiler . compile ( expression )  ;", "boolean   resultC    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( false ,    resultI )  ;", "assertEquals ( false ,    resultC )  ;", "expression    =    parser . parseExpression (  \" false   or   true \"  )  ;", "resultI    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertCanCompile ( expression )  ;", "resultC    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( true ,    resultI )  ;", "assertEquals ( true ,    resultC )  ;", "expression    =    parser . parseExpression (  \" true   or   false \"  )  ;", "resultI    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertCanCompile ( expression )  ;", "resultC    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( true ,    resultI )  ;", "assertEquals ( true ,    resultC )  ;", "expression    =    parser . parseExpression (  \" true   or   true \"  )  ;", "resultI    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertCanCompile ( expression )  ;", "resultC    =    expression . getValue (  1  ,    Boolean . TYPE )  ;", "assertEquals ( true ,    resultI )  ;", "assertEquals ( true ,    resultC )  ;", ". TestClass 4    tc    =    new    . TestClass 4  (  )  ;", "expression    =    parser . parseExpression (  \" getfalse (  )    or   gettrue (  )  \"  )  ;", "resultI    =    expression . getValue ( tc ,    Boolean . TYPE )  ;", "assertCanCompile ( expression )  ;", "resultC    =    expression . getValue ( tc ,    Boolean . TYPE )  ;", "assertEquals ( true ,    resultI )  ;", "assertEquals ( true ,    resultC )  ;", "expression    =    parser . parseExpression (  \" gettrue (  )    or   getfalse (  )  \"  )  ;", "resultI    =    expression . getValue ( tc ,    Boolean . TYPE )  ;", "assertCantCompile ( expression )  ;", "expression    =    parser . parseExpression (  \" getA (  )    or   getB (  )  \"  )  ;", "tc . a    =    true ;", "tc . b    =    true ;", "resultI    =    expression . getValue ( tc ,    Boolean . TYPE )  ;", "assertCantCompile ( expression )  ;", "tc . a    =    false ;", "tc . b    =    true ;", "resultI    =    expression . getValue ( tc ,    Boolean . TYPE )  ;", "assertCanCompile ( expression )  ;", "assertTrue ( resultI )  ;", "boolean   b    =    false ;", "expression    =    parse (  \"  # root   or    # root \"  )  ;", "Object   resultI 2     =    expression . getValue ( b )  ;", "assertCanCompile ( expression )  ;", "assertFalse (  (  ( Boolean )     ( resultI 2  )  )  )  ;", "assertFalse (  (  ( Boolean )     ( expression . getValue ( b )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["opOr"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  2  +  2  \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  4  ,    getValue (  )  )  ;", "=    parse (  \"  2 L +  2 L \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  4 L ,    getValue (  )  )  ;", "=    parse (  \"  2  .  0 f +  2  .  0 f \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  4  .  0 F ,    getValue (  )  )  ;", "=    parse (  \"  3  .  0 d +  4  .  0 d \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  7  .  0  ,    getValue (  )  )  ;", "=    parse (  \"  +  1  \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  1  ,    getValue (  )  )  ;", "=    parse (  \"  +  1 L \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  1 L ,    getValue (  )  )  ;", "=    parse (  \"  +  1  .  5 f \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  1  .  5 F ,    getValue (  )  )  ;", "=    parse (  \"  +  2  .  5 d \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  2  .  5  ,    getValue (  )  )  ;", "=    parse (  \"  + T ( Double )  . valueOf (  2  .  5 d )  \"  )  ;", "getValue (  )  ;", "assertCanCompile (  ;", "assertEquals (  2  .  5  ,    getValue (  )  )  ;", "=    parse (  \" T ( Integer )  . valueOf (  2  )  +  6  \"  )  ;", "assertEquals (  8  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  8  ,    getValue (  )  )  ;", "=    parse (  \" T ( Integer )  . valueOf (  1  )  + T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertEquals (  4  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  4  ,    getValue (  )  )  ;", "=    parse (  \"  1  + T ( Integer )  . valueOf (  3  )  \"  )  ;", "assertEquals (  4  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  4  ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  2  .  0 f )  +  6  \"  )  ;", "assertEquals (  8  .  0 F ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  8  .  0 F ,    getValue (  )  )  ;", "=    parse (  \" T ( Float )  . valueOf (  2  .  0 f )  + T ( Float )  . valueOf (  3  .  0 f )  \"  )  ;", "assertEquals (  5  .  0 F ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  5  .  0 F ,    getValue (  )  )  ;", "=    parse (  \"  3 L + T ( Long )  . valueOf (  4 L )  \"  )  ;", "assertEquals (  7 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  7 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  2 L )  +  6  \"  )  ;", "assertEquals (  8 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  8 L ,    getValue (  )  )  ;", "=    parse (  \" T ( Long )  . valueOf (  2 L )  + T ( Long )  . valueOf (  3 L )  \"  )  ;", "assertEquals (  5 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  5 L ,    getValue (  )  )  ;", "=    parse (  \"  1 L + T ( Long )  . valueOf (  2 L )  \"  )  ;", "assertEquals (  3 L ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  3 L ,    getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["opPlus"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parse (  \"  ' hello '     +     ' world '  \"  )  ;", "assertEquals (  \" helloworld \"  ,    expression . getValue (  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" helloworld \"  ,    expression . getValue (  )  )  ;", "expression    =    parse (  \"  ' hello '     +    getWorld (  )  \"  )  ;", "assertEquals (  \" helloworld \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" helloworld \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "expression    =    parse (  \" getWorld (  )     +     ' hello '  \"  )  ;", "assertEquals (  \" worldhello \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" worldhello \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "expression    =    parse (  \"  ' hello '     +    getWorld (  )     +     '    spring '  \"  )  ;", "assertEquals (  \" helloworld   spring \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" helloworld   spring \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "expression    =    parse (  \"  ' hello '     +     3     +     '    spring '  \"  )  ;", "assertEquals (  \" hello 3    spring \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "assertCantCompile ( expression )  ;", "expression    =    parse (  \" object    +     ' a '  \"  )  ;", "assertEquals (  \" objecta \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" objecta \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "expression    =    parse (  \"  ' a '  + object \"  )  ;", "assertEquals (  \" aobject \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" aobject \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "expression    =    parse (  \"  ' a '  + object +  ' a '  \"  )  ;", "assertEquals (  \" aobjecta \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" aobjecta \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "expression    =    parse (  \" object +  ' a '  + object \"  )  ;", "assertEquals (  \" objectaobject \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" objectaobject \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "expression    =    parse (  \" object + object \"  )  ;", "assertEquals (  \" objectobject \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" objectobject \"  ,    expression . getValue ( new    . Greeter (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["opPlusString"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . PayloadX   p    =    new   SpelCompilationCoverageTests . PayloadX (  )  ;", "checkCalc ( p ,     \" payload . valueSB +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI +  6  0 D \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueBB + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueFB + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueDB + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueIB + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueS + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueB + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueF + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueD + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueI + payload . valueDB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueSB +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB +  6  0 F \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD +  6  0 F \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI +  6  0 F \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueBB + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueFB + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB + payload . valueFB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueIB + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueS + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueB + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueF + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD + payload . valueFB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueI + payload . valueFB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueSB +  6  0 L \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueBB +  6  0 L \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueFB +  6  0 L \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB +  6  0 L \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB +  6  0 L \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB +  6  0 L \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueS +  6  0 L \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueB +  6  0 L \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueF +  6  0 L \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD +  6  0 L \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ +  6  0 L \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueI +  6  0 L \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueSB + payload . valueJB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueBB + payload . valueJB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueFB + payload . valueJB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB + payload . valueJB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB + payload . valueJB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB + payload . valueJB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueS + payload . valueJB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueB + payload . valueJB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueF + payload . valueJB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD + payload . valueJB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ + payload . valueJB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueI + payload . valueJB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueSB +  6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueBB +  6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueFB +  6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB +  6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB +  6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB +  6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueS +  6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueB +  6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueF +  6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD +  6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ +  6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueI +  6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueSB + payload . valueIB 6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueBB + payload . valueIB 6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueFB + payload . valueIB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB + payload . valueIB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB + payload . valueIB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB + payload . valueIB 6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueS + payload . valueIB 6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueB + payload . valueIB 6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueF + payload . valueIB 6  0  \"  ,     1  8  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD + payload . valueIB 6  0  \"  ,     1  8  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ + payload . valueIB 6  0  \"  ,     1  8  0 L )  ;", "checkCalc ( p ,     \" payload . valueI + payload . valueIB 6  0  \"  ,     1  8  0  )  ;", "checkCalc ( p ,     \" payload . valueSB + payload . valueS \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueBB + payload . valueS \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueFB + payload . valueS \"  ,     2  4  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB + payload . valueS \"  ,     2  4  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB + payload . valueS \"  ,     2  4  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB + payload . valueS \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueS + payload . valueS \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueB + payload . valueS \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueF + payload . valueS \"  ,     2  4  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD + payload . valueS \"  ,     2  4  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ + payload . valueS \"  ,     2  4  0 L )  ;", "checkCalc ( p ,     \" payload . valueI + payload . valueS \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueSB + payload . valueSB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueBB + payload . valueSB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueFB + payload . valueSB \"  ,     2  4  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB + payload . valueSB \"  ,     2  4  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB + payload . valueSB \"  ,     2  4  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB + payload . valueSB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueS + payload . valueSB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueB + payload . valueSB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueF + payload . valueSB \"  ,     2  4  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD + payload . valueSB \"  ,     2  4  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ + payload . valueSB \"  ,     2  4  0 L )  ;", "checkCalc ( p ,     \" payload . valueI + payload . valueSB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueSB + payload . valueB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueBB + payload . valueB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueFB + payload . valueB \"  ,     2  4  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB + payload . valueB \"  ,     2  4  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB + payload . valueB \"  ,     2  4  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB + payload . valueB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueS + payload . valueB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueB + payload . valueB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueF + payload . valueB \"  ,     2  4  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD + payload . valueB \"  ,     2  4  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ + payload . valueB \"  ,     2  4  0 L )  ;", "checkCalc ( p ,     \" payload . valueI + payload . valueB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueSB + payload . valueBB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueBB + payload . valueBB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueFB + payload . valueBB \"  ,     2  4  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueDB + payload . valueBB \"  ,     2  4  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJB + payload . valueBB \"  ,     2  4  0 L )  ;", "checkCalc ( p ,     \" payload . valueIB + payload . valueBB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueS + payload . valueBB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueB + payload . valueBB \"  ,     2  4  0  )  ;", "checkCalc ( p ,     \" payload . valueF + payload . valueBB \"  ,     2  4  0  .  0 F )  ;", "checkCalc ( p ,     \" payload . valueD + payload . valueBB \"  ,     2  4  0  .  0  )  ;", "checkCalc ( p ,     \" payload . valueJ + payload . valueBB \"  ,     2  4  0 L )  ;", "checkCalc ( p ,     \" payload . valueI + payload . valueBB \"  ,     2  4  0  )  ;", "}", "METHOD_END"], "methodName": ["opPlus_mixedNumberTypes"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  ' xyz '    instanceof   T ( String )  \"  )  ;", "assertEquals ( true ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( true ,    getValue (  )  )  ;", "=    parse (  \"  ' xyz '    instanceof   T ( Integer )  \"  )  ;", "assertEquals ( false ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( false ,    getValue (  )  )  ;", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "=    parse (  \"  # root   instanceof   T ( List )  \"  )  ;", "assertEquals ( true ,    getValue ( list )  )  ;", "assertCanCompile (  ;", "assertEquals ( true ,    getValue ( list )  )  ;", "List < String >  [  ]    arrayOfLists    =    new   List [  ]  {    new   ArrayList < String >  (  )     }  ;", "=    parse (  \"  # root   instanceof   T ( List [  ]  )  \"  )  ;", "assertEquals ( true ,    getValue ( arrayOfLists )  )  ;", "assertCanCompile (  ;", "assertEquals ( true ,    getValue ( arrayOfLists )  )  ;", "int [  ]    intArray    =    new   int [  ]  {     1  ,     2  ,     3     }  ;", "=    parse (  \"  # root   instanceof   T ( int [  ]  )  \"  )  ;", "assertEquals ( true ,    getValue ( intArray )  )  ;", "assertCanCompile (  ;", "assertEquals ( true ,    getValue ( intArray )  )  ;", "String   root    =    null ;", "=    parse (  \"  # root   instanceof   T ( Integer )  \"  )  ;", "assertEquals ( false ,    getValue ( root )  )  ;", "assertCanCompile (  ;", "assertEquals ( false ,    getValue ( root )  )  ;", "=    parse (  \"  # root   instanceof   T ( Object )  \"  )  ;", "assertEquals ( false ,    getValue ( root )  )  ;", "assertCanCompile (  ;", "assertEquals ( false ,    getValue ( root )  )  ;", "root    =     \" howdy !  \"  ;", "=    parse (  \"  # root   instanceof   T ( Object )  \"  )  ;", "assertEquals ( true ,    getValue ( root )  )  ;", "assertCanCompile (  ;", "assertEquals ( true ,    getValue ( root )  )  ;", "}", "METHOD_END"], "methodName": ["operatorInstanceOf"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  3    instanceof   T ( Integer )  \"  )  ;", "assertEquals ( true ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( true ,    getValue (  )  )  ;", "=    parse (  \"  3    instanceof   T ( String )  \"  )  ;", "assertEquals ( false ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( false ,    getValue (  )  )  ;", "=    parse (  \"  3  .  0 d   instanceof   T ( Integer )  \"  )  ;", "assertEquals ( false ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( false ,    getValue (  )  )  ;", "=    parse (  \"  3  .  0 d   instanceof   T ( Double )  \"  )  ;", "assertEquals ( true ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( true ,    getValue (  )  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setVariable (  \" foo \"  ,    String . class )  ;", "=    parse (  \"  3    instanceof    # foo \"  )  ;", "assertEquals ( false ,    getValue ( ctx )  )  ;", "assertCantCompile (  ;", "=    parse (  \"  3    instanceof   T ( int )  \"  )  ;", "assertEquals ( false ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( false ,    getValue (  )  )  ;", "=    parse (  \"  3    instanceof   T ( long )  \"  )  ;", "assertEquals ( false ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( false ,    getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["operatorInstanceOf_SPR14250"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \"  ! true \"  )  ;", "assertEquals ( false ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( false ,    getValue (  )  )  ;", "=    parse (  \"  ! false \"  )  ;", "assertEquals ( true ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( true ,    getValue (  )  )  ;", "boolean   b    =    true ;", "=    parse (  \"  !  # root \"  )  ;", "assertEquals ( false ,    getValue ( b )  )  ;", "assertCanCompile (  ;", "assertEquals ( false ,    getValue ( b )  )  ;", "b    =    false ;", "=    parse (  \"  !  # root \"  )  ;", "assertEquals ( true ,    getValue ( b )  )  ;", "assertCanCompile (  ;", "assertEquals ( true ,    getValue ( b )  )  ;", "}", "METHOD_END"], "methodName": ["operatorNot"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "return   parser . parseExpression ( expression )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \" object    +     '    world '  \"  )  ;", "Object   v    =    expression . getValue ( new    . FooObject (  )  )  ;", "assertEquals (  \" hello   world \"  ,    v )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" hello   world \"  ,    v )  ;", "expression    =    parser . parseExpression (  \" object    +     '    world '  \"  )  ;", "v    =    expression . getValue ( new    . FooString (  )  )  ;", "assertEquals (  \" hello   world \"  ,    v )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" hello   world \"  ,    v )  ;", "}", "METHOD_END"], "methodName": ["plusNeedingCheckcast_SPR12426"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . TestClass 6    tc    =    new   SpelCompilationCoverageTests . TestClass 6  (  )  ;", "expression    =    parser . parseExpression (  \" orange \"  )  ;", "assertCantCompile ( expression )  ;", "assertEquals (  \" value 1  \"  ,    expression . getValue ( tc )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" value 1  \"  ,    expression . getValue ( tc )  )  ;", "expression    =    parser . parseExpression (  \" apple \"  )  ;", "assertCantCompile ( expression )  ;", "assertEquals (  \" value 2  \"  ,    expression . getValue ( tc )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" value 2  \"  ,    expression . getValue ( tc )  )  ;", "expression    =    parser . parseExpression (  \" banana \"  )  ;", "assertCantCompile ( expression )  ;", "assertEquals (  \" value 3  \"  ,    expression . getValue ( tc )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" value 3  \"  ,    expression . getValue ( tc )  )  ;", "expression    =    parser . parseExpression (  \" plum \"  )  ;", "assertCantCompile ( expression )  ;", "assertEquals (  \" value 4  \"  ,    expression . getValue ( tc )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" value 4  \"  ,    expression . getValue ( tc )  )  ;", "}", "METHOD_END"], "methodName": ["propertyReference"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setVariable (  \" httpServletRequest \"  ,     . HttpServlet 3 RequestFactory . getOne (  )  )  ;", "expression    =    parser . parseExpression (  \"  # httpServletRequest . servletPath \"  )  ;", "assertEquals (  \" wibble \"  ,    expression . getValue ( ctx )  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" wibble \"  ,    expression . getValue ( ctx )  )  ;", "}", "METHOD_END"], "methodName": ["propertyReferenceVisibility"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \"  3  .  4 d \"  )  ;", "double   resultI    =    expression . getValue ( new    . TestClass 1  (  )  ,    Double . TYPE )  ;", "assertCanCompile ( expression )  ;", "double   resultC    =    expression . getValue ( new    . TestClass 1  (  )  ,    Double . TYPE )  ;", "assertEquals (  3  .  4  ,    resultI ,     0  .  1  )  ;", "assertEquals (  3  .  4  ,    resultC ,     0  .  1  )  ;", "assertEquals (  3  .  4  ,    expression . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["realLiteral"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Field   f    =    SpelExpression . class . getDeclaredField (  \" compiledAst \"  )  ;", "Set < Object >    classloadersUsed    =    new   HashSet <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  5  0  0  ;    i +  +  )     {", "=    parser . parseExpression (  \"  4     +     5  \"  )  ;", "assertEquals (  9  ,     (  ( int )     ( getValue ( Integer . class )  )  )  )  ;", "assertCanCompile (  ;", "f . setAccessible ( true )  ;", "CompiledExpression   cEx    =     (  ( CompiledExpression )     ( f . get (  )  )  ;", "classloadersUsed . add ( cEx . getClass (  )  . getClassLoader (  )  )  ;", "assertEquals (  9  ,     (  ( int )     ( getValue ( Integer . class )  )  )  )  ;", "}", "assertTrue (  (  ( classloadersUsed . size (  )  )     >     1  )  )  ;", "}", "METHOD_END"], "methodName": ["repeatedCompilation"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \"  ' abcde '  \"  )  ;", "assertEquals (  \" abcde \"  ,    expression . getValue ( new    . TestClass 1  (  )  ,    String . class )  )  ;", "assertCanCompile ( expression )  ;", "String   resultC    =    expression . getValue ( new    . TestClass 1  (  )  ,    String . class )  ;", "assertEquals (  \" abcde \"  ,    resultC )  ;", "assertEquals (  \" abcde \"  ,    expression . getValue ( String . class )  )  ;", "assertEquals (  \" abcde \"  ,    expression . getValue (  )  )  ;", "assertEquals (  \" abcde \"  ,    expression . getValue ( new   StandardEvaluationContext (  )  )  )  ;", "expression    =    parser . parseExpression (  \"  \\  \" abcde \\  \"  \"  )  ;", "assertCanCompile ( expression )  ;", "assertEquals (  \" abcde \"  ,    expression . getValue ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["stringLiteral"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   s    =    new   StringBuilder (  )  ;", "if    ( object   instanceof   List )     {", "List <  ?  >    ls    =     (  ( List <  ?  >  )     ( object )  )  ;", "for    ( Object   l    :    ls )     {", "s . append ( l )  ;", "s . append (  \"     \"  )  ;", "}", "} else", "if    ( object   instanceof   Object [  ]  )     {", "Object [  ]    os    =     (  ( Object [  ]  )     ( object )  )  ;", "for    ( Object   o    :    os )     {", "s . append ( o )  ;", "s . append (  \"     \"  )  ;", "}", "} else", "if    ( object   instanceof   int [  ]  )     {", "int [  ]    is    =     (  ( int [  ]  )     ( object )  )  ;", "for    ( int   i    :    is )     {", "s . append ( i )  ;", "s . append (  \"     \"  )  ;", "}", "} else    {", "s . append ( object . toString (  )  )  ;", "}", "return   s . toString (  )  . trim (  )  ;", "}", "METHOD_END"], "methodName": ["stringify"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "Expression    =    parser . parseExpression (  \" true ?  ' a '  :  ' b '  \"  )  ;", "String   resultI    =    getValue ( String . class )  ;", "assertCanCompile (  ;", "String   resultC    =    getValue ( String . class )  ;", "assertEquals (  \" a \"  ,    resultI )  ;", "assertEquals (  \" a \"  ,    resultC )  ;", "=    parser . parseExpression (  \" false ?  ' a '  :  ' b '  \"  )  ;", "resultI    =    getValue ( String . class )  ;", "assertCanCompile (  ;", "resultC    =    getValue ( String . class )  ;", "assertEquals (  \" b \"  ,    resultI )  ;", "assertEquals (  \" b \"  ,    resultC )  ;", "=    parser . parseExpression (  \" false ?  1  :  ' b '  \"  )  ;", "assertCanCompile (  ;", "assertEquals (  \" b \"  ,    getValue (  )  )  ;", "boolean   root    =    true ;", "=    parser . parseExpression (  \"  (  # root   and   true )  ? T ( Integer )  . valueOf (  1  )  : T ( Long )  . valueOf (  3 L )  \"  )  ;", "assertEquals (  1  ,    getValue ( root )  )  ;", "assertCantCompile (  ;", "root    =    false ;", "assertEquals (  3 L ,    getValue ( root )  )  ;", "assertCanCompile (  ;", "assertEquals (  3 L ,    getValue ( root )  )  ;", "root    =    true ;", "assertEquals (  1  ,    getValue ( root )  )  ;", "}", "METHOD_END"], "methodName": ["ternary"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelParserConfiguration   configuration    =    new   SpelParserConfiguration ( SpelCompilerMode . IMMEDIATE ,    null )  ;", "Expression   exp ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" map \"  ,    Collections . singletonMap (  \" foo \"  ,     \" qux \"  )  )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \" bar (  # map [  ' foo '  ]     !  =    null    ?     # map [  ' foo '  ]     :     ' qux '  )  \"  )  ;", "assertEquals (  \" QUX \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" QUX \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  3  =  =  3  ?  3  :  ' foo '  \"  )  ;", "assertEquals (  \"  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  3  !  =  3  ?  3  :  ' foo '  \"  )  ;", "assertEquals (  \" foo \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" foo \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  3  =  =  3  ?  3 L :  ' foo '  \"  )  ;", "assertEquals (  \"  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  3  !  =  3  ?  3 L :  ' foo '  \"  )  ;", "assertEquals (  \" foo \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" foo \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  '  '  =  =  '  '  ?  ' abc '  :  4 L \"  )  ;", "assertEquals (  \" abc \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" abc \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  3  =  =  3  ? null :  4 L \"  )  ;", "assertEquals ( null ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals ( null ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  # x =  =  # x ?  5  0  :  ' foo '  \"  )  ;", "context . setVariable (  \" x \"  ,     5  0  )  ;", "assertEquals (  \"  5  0  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  5  0  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  # x !  =  # x ?  5  0  :  ' foo '  \"  )  ;", "context . setVariable (  \" x \"  ,    null )  ;", "assertEquals (  \" foo \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \" foo \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "exp    =    new   SpelExpressionParser ( configuration )  . parseExpression (  \"  # x =  =  # x ?  '  1  ,  2  ,  3  '  :  ' foo '  \"  )  ;", "context . setVariable (  \" x \"  ,    new   int [  ]  {     1  ,     2  ,     3     }  )  ;", "assertEquals (  \"  1  ,  2  ,  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertCanCompile ( exp )  ;", "assertEquals (  \"  1  ,  2  ,  3  \"  ,    exp . getValue ( context ,    new    . Foo (  )  ,    String . class )  )  ;", "assertIsCompiled ( exp )  ;", "}", "METHOD_END"], "methodName": ["ternaryOperator_SPR15192"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parser . parseExpression (  \" T ( Boolean )  . TRUE ?  ' abc '  :  ' def '  \"  )  ;", "assertEquals (  \" abc \"  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  \" abc \"  ,    getValue (  )  )  ;", "=    parser . parseExpression (  \" T ( Boolean )  . FALSE ?  ' abc '  :  ' def '  \"  )  ;", "assertEquals (  \" def \"  ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals (  \" def \"  ,    getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["ternaryWithBooleanReturn"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "=    parse (  \" T ( String )  \"  )  ;", "assertEquals ( String . class ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( String . class ,    getValue (  )  )  ;", "=    parse (  \" T ( IOException )  \"  )  ;", "assertEquals ( IOException . class ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( IOException . class ,    getValue (  )  )  ;", "=    parse (  \" T ( IOException [  ]  )  \"  )  ;", "assertEquals ( IOException [  ]  . class ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( IOException [  ]  . class ,    getValue (  )  )  ;", "=    parse (  \" T ( int [  ]  [  ]  )  \"  )  ;", "assertEquals ( int [  ]  [  ]  . class ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( int [  ]  [  ]  . class ,    getValue (  )  )  ;", "=    parse (  \" T ( int )  \"  )  ;", "assertEquals ( Integer . TYPE ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( Integer . TYPE ,    getValue (  )  )  ;", "=    parse (  \" T ( byte )  \"  )  ;", "assertEquals ( Byte . TYPE ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( Byte . TYPE ,    getValue (  )  )  ;", "=    parse (  \" T ( char )  \"  )  ;", "assertEquals ( Character . TYPE ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( Character . TYPE ,    getValue (  )  )  ;", "=    parse (  \" T ( short )  \"  )  ;", "assertEquals ( Short . TYPE ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( Short . TYPE ,    getValue (  )  )  ;", "=    parse (  \" T ( long )  \"  )  ;", "assertEquals ( Long . TYPE ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( Long . TYPE ,    getValue (  )  )  ;", "=    parse (  \" T ( float )  \"  )  ;", "assertEquals ( Float . TYPE ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( Float . TYPE ,    getValue (  )  )  ;", "=    parse (  \" T ( double )  \"  )  ;", "assertEquals ( Double . TYPE ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( Double . TYPE ,    getValue (  )  )  ;", "=    parse (  \" T ( boolean )  \"  )  ;", "assertEquals ( Boolean . TYPE ,    getValue (  )  )  ;", "assertCanCompile (  ;", "assertEquals ( Boolean . TYPE ,    getValue (  )  )  ;", "=    parse (  \" T ( Missing )  \"  )  ;", "assertGetValueFail (  ;", "assertCantCompile (  ;", "}", "METHOD_END"], "methodName": ["typeReference"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" hello \"  ;", "Expression    =    parser . parseExpression (  \"  # root \"  )  ;", "String   resultI    =    getValue ( s ,    String . class )  ;", "assertCanCompile (  ;", "String   resultC    =    getValue ( s ,    String . class )  ;", "assertEquals ( s ,    resultI )  ;", "assertEquals ( s ,    resultC )  ;", "=    parser . parseExpression (  \"  # root \"  )  ;", "int   i    =     (  ( Integer )     ( getValue (  4  2  )  )  )  ;", "assertEquals (  4  2  ,    i )  ;", "assertCanCompile (  ;", "i    =     (  ( Integer )     ( getValue (  4  2  )  )  )  ;", "assertEquals (  4  2  ,    i )  ;", "}", "METHOD_END"], "methodName": ["variableReference_root"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setVariable (  \" target \"  ,     \" abc \"  )  ;", "=    parser . parseExpression (  \"  # target \"  )  ;", "assertEquals (  \" abc \"  ,    getValue ( ctx )  )  ;", "assertCanCompile (  ;", "assertEquals (  \" abc \"  ,    getValue ( ctx )  )  ;", "ctx . setVariable (  \" target \"  ,     \"  1  2  3  \"  )  ;", "assertEquals (  \"  1  2  3  \"  ,    getValue ( ctx )  )  ;", "ctx . setVariable (  \" target \"  ,     4  2  )  ;", "try    {", "assertEquals (  4  2  ,    getValue ( ctx )  )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertTrue (  (  ( see . getCause (  )  )    instanceof   ClassCastException )  )  ;", "}", "ctx . setVariable (  \" target \"  ,     \" abc \"  )  ;", "=    parser . parseExpression (  \"  # target . charAt (  0  )  \"  )  ;", "assertEquals (  ' a '  ,    getValue ( ctx )  )  ;", "assertCanCompile (  ;", "assertEquals (  ' a '  ,    getValue ( ctx )  )  ;", "ctx . setVariable (  \" target \"  ,     \"  1  \"  )  ;", "assertEquals (  '  1  '  ,    getValue ( ctx )  )  ;", "ctx . setVariable (  \" target \"  ,     4  2  )  ;", "try    {", "assertEquals (  '  4  '  ,    getValue ( ctx )  )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertTrue (  (  ( see . getCause (  )  )    instanceof   ClassCastException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["variableReference_userDefined"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationCoverageTests . Payload 2 Holder   holder    =    new   SpelCompilationCoverageTests . Payload 2 Holder (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . addPropertyAccessor ( new   SpelCompilationCoverageTests . MyAccessor (  )  )  ;", "expression    =    parser . parseExpression (  \" payload 2  . var 1  \"  )  ;", "Object   v    =    expression . getValue ( ctx ,    holder )  ;", "assertEquals (  \" abc \"  ,    v )  ;", "assertCanCompile ( expression )  ;", "v    =    expression . getValue ( ctx ,    holder )  ;", "assertEquals (  \" abc \"  ,    v )  ;", "}", "METHOD_END"], "methodName": ["variantGetter"], "fileName": "org.springframework.expression.spel.SpelCompilationCoverageTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( SpelCompiler . compile ( expression )  )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationPerformanceTests . NumberHolder   nh    =    new   SpelCompilationPerformanceTests . NumberHolder (  )  ;", "expression    =    parser . parseExpression (  \"  ( T ( Integer )  . valueOf ( payload )  . doubleValue (  )  )  /  1  8 D \"  )  ;", "Object   o    =    expression . getValue ( nh )  ;", "assertEquals (  2  .  0  ,    o )  ;", "System . out . println (  \" Performance   check   for   SpEL   expression :     '  ( T ( Integer )  . valueOf ( payload )  . doubleValue (  )  )  /  1  8 D '  \"  )  ;", "long   stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "compile ( expression )  ;", "System . out . println (  \" Now   compiled :  \"  )  ;", "o    =    expression . getValue ( nh )  ;", "assertEquals (  2  .  0  ,    o )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "expression    =    parser . parseExpression (  \" payload /  1  8 D \"  )  ;", "o    =    expression . getValue ( nh )  ;", "assertEquals (  2  .  0  ,    o )  ;", "System . out . println (  \" Performance   check   for   SpEL   expression :     ' payload /  1  8 D '  \"  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "compile ( expression )  ;", "System . out . println (  \" Now   compiled :  \"  )  ;", "o    =    expression . getValue ( nh )  ;", "assertEquals (  2  .  0  ,    o )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( nh )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "}", "METHOD_END"], "methodName": ["compilingMathematicalExpressionsWithDifferentOperandTypes"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "long   interpretedTotal    =     0  ;", "long   compiledTotal    =     0  ;", "long   stime ;", "long   etime ;", "String   interpretedResult    =    null ;", "String   compiledResult    =    null ;", ". HW   testdata    =    new    . HW (  )  ;", "Expression   expression    =    parser . parseExpression (  \" hello (  )  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( count )  ;    i +  +  )     {", "interpretedResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "log (  \" timing   interpreted :     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "interpretedResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   interpretedSpeed    =    etime    -    stime ;", "interpretedTotal    +  =    interpretedSpeed ;", "log (  ( interpretedSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "compile ( expression )  ;", "log (  \" timing   compiled :     \"  )  ;", "expression . getValue ( testdata ,    String . class )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "compiledResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   compiledSpeed    =    etime    -    stime ;", "compiledTotal    +  =    compiledSpeed ;", "log (  ( compiledSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "assertEquals ( interpretedResult ,    compiledResult )  ;", "reportPerformance (  \" method   reference \"  ,    interpretedTotal ,    compiledTotal )  ;", "if    ( compiledTotal    >  =    interpretedTotal )     {", "fail (  \" Compiled   version   is   slower   than   interpreted !  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["compilingMethodReference"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "long   interpretedTotal    =     0  ;", "long   compiledTotal    =     0  ;", "long   stime ;", "long   etime ;", "String   interpretedResult    =    null ;", "String   compiledResult    =    null ;", ". TestClass 2    testdata    =    new    . TestClass 2  (  )  ;", "Expression   expression    =    parser . parseExpression (  \" foo . bay (  )  . boo \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( count )  ;    i +  +  )     {", "expression . getValue ( testdata ,    String . class )  ;", "}", "log (  \" timing   interpreted :     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "interpretedResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   interpretedSpeed    =    etime    -    stime ;", "interpretedTotal    +  =    interpretedSpeed ;", "log (  ( interpretedSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "compile ( expression )  ;", "log (  \" timing   compiled :     \"  )  ;", "expression . getValue ( testdata ,    String . class )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "compiledResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   compiledSpeed    =    etime    -    stime ;", "compiledTotal    +  =    compiledSpeed ;", "log (  ( compiledSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "assertEquals ( interpretedResult ,    compiledResult )  ;", "reportPerformance (  \" nested   reference    ( mixed   field / method )  \"  ,    interpretedTotal ,    compiledTotal )  ;", "}", "METHOD_END"], "methodName": ["compilingNestedMixedFieldPropertyReferenceMethodReference"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "long   interpretedTotal    =     0  ;", "long   compiledTotal    =     0  ;", "long   stime ;", "long   etime ;", "String   interpretedResult    =    null ;", "String   compiledResult    =    null ;", ". TestClass 2    testdata    =    new    . TestClass 2  (  )  ;", "Expression   expression    =    parser . parseExpression (  \" name \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( count )  ;    i +  +  )     {", "expression . getValue ( testdata ,    String . class )  ;", "}", "log (  \" timing   interpreted :     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "interpretedResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   interpretedSpeed    =    etime    -    stime ;", "interpretedTotal    +  =    interpretedSpeed ;", "log (  ( interpretedSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "compile ( expression )  ;", "log (  \" timing   compiled :     \"  )  ;", "expression . getValue ( testdata ,    String . class )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "compiledResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   compiledSpeed    =    etime    -    stime ;", "compiledTotal    +  =    compiledSpeed ;", "log (  ( compiledSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "assertEquals ( interpretedResult ,    compiledResult )  ;", "reportPerformance (  \" property   reference    ( field )  \"  ,    interpretedTotal ,    compiledTotal )  ;", "}", "METHOD_END"], "methodName": ["compilingPropertyReferenceField"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "long   interpretedTotal    =     0  ;", "long   compiledTotal    =     0  ;", "long   stime ;", "long   etime ;", "String   interpretedResult    =    null ;", "String   compiledResult    =    null ;", ". TestClass 2    testdata    =    new    . TestClass 2  (  )  ;", "Expression   expression    =    parser . parseExpression (  \" name 2  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( count )  ;    i +  +  )     {", "expression . getValue ( testdata ,    String . class )  ;", "}", "log (  \" timing   interpreted :     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "interpretedResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   interpretedSpeed    =    etime    -    stime ;", "interpretedTotal    +  =    interpretedSpeed ;", "log (  ( interpretedSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "compile ( expression )  ;", "log (  \" timing   compiled :     \"  )  ;", "expression . getValue ( testdata ,    String . class )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "compiledResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   compiledSpeed    =    etime    -    stime ;", "compiledTotal    +  =    compiledSpeed ;", "log (  ( compiledSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "assertEquals ( interpretedResult ,    compiledResult )  ;", "reportPerformance (  \" property   reference    ( getter )  \"  ,    interpretedTotal ,    compiledTotal )  ;", "if    ( compiledTotal    >  =    interpretedTotal )     {", "fail (  \" Compiled   version   is   slower   than   interpreted !  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["compilingPropertyReferenceGetter"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "long   interpretedTotal    =     0  ;", "long   compiledTotal    =     0  ;", "long   stime ;", "long   etime ;", "String   interpretedResult    =    null ;", "String   compiledResult    =    null ;", ". TestClass 2    testdata    =    new    . TestClass 2  (  )  ;", "Expression   expression    =    parser . parseExpression (  \" foo . bar . boo \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( count )  ;    i +  +  )     {", "expression . getValue ( testdata ,    String . class )  ;", "}", "log (  \" timing   interpreted :     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "interpretedResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   interpretedSpeed    =    etime    -    stime ;", "interpretedTotal    +  =    interpretedSpeed ;", "log (  ( interpretedSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "compile ( expression )  ;", "log (  \" timing   compiled :     \"  )  ;", "expression . getValue ( testdata ,    String . class )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "compiledResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   compiledSpeed    =    etime    -    stime ;", "compiledTotal    +  =    compiledSpeed ;", "log (  ( compiledSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "assertEquals ( interpretedResult ,    compiledResult )  ;", "reportPerformance (  \" property   reference    ( nested   field )  \"  ,    interpretedTotal ,    compiledTotal )  ;", "}", "METHOD_END"], "methodName": ["compilingPropertyReferenceNestedField"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "long   interpretedTotal    =     0  ;", "long   compiledTotal    =     0  ;", "long   stime ;", "long   etime ;", "String   interpretedResult    =    null ;", "String   compiledResult    =    null ;", ". TestClass 2    testdata    =    new    . TestClass 2  (  )  ;", "Expression   expression    =    parser . parseExpression (  \" foo . baz . boo \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( count )  ;    i +  +  )     {", "expression . getValue ( testdata ,    String . class )  ;", "}", "log (  \" timing   interpreted :     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "interpretedResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   interpretedSpeed    =    etime    -    stime ;", "interpretedTotal    +  =    interpretedSpeed ;", "log (  ( interpretedSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "compile ( expression )  ;", "log (  \" timing   compiled :     \"  )  ;", "expression . getValue ( testdata ,    String . class )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "compiledResult    =    expression . getValue ( testdata ,    String . class )  ;", "}", "etime    =    System . currentTimeMillis (  )  ;", "long   compiledSpeed    =    etime    -    stime ;", "compiledTotal    +  =    compiledSpeed ;", "log (  ( compiledSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "assertEquals ( interpretedResult ,    compiledResult )  ;", "reportPerformance (  \" nested   property   reference    ( mixed   field / getter )  \"  ,    interpretedTotal ,    compiledTotal )  ;", "}", "METHOD_END"], "methodName": ["compilingPropertyReferenceNestedMixedFieldGetter"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "SpelCompilationPerformanceTests . Payload   payload    =    new   SpelCompilationPerformanceTests . Payload (  )  ;", "Expression   expression    =    parser . parseExpression (  \" DR [  0  ]  . DRFixedSection . duration   lt    0  .  1  \"  )  ;", "boolean   b    =    false ;", "long   iTotal    =     0  ;", "long   cTotal    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( count )  ;    i +  +  )     {", "b    =    expression . getValue ( payload ,    Boolean . TYPE )  ;", "}", "log (  \" timing   interpreted :     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "long   stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "b    =    expression . getValue ( payload ,    Boolean . TYPE )  ;", "}", "long   etime    =    System . currentTimeMillis (  )  ;", "long   interpretedSpeed    =    etime    -    stime ;", "iTotal    +  =    interpretedSpeed ;", "log (  ( interpretedSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "compile ( expression )  ;", "boolean   bc    =    false ;", "expression . getValue ( payload ,    Boolean . TYPE )  ;", "log (  \" timing   compiled :     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( iterations )  ;    i +  +  )     {", "long   stime    =    System . currentTimeMillis (  )  ;", "for    ( int   j    =     0  ;    j    <     ( count )  ;    j +  +  )     {", "bc    =    expression . getValue ( payload ,    Boolean . TYPE )  ;", "}", "long   etime    =    System . currentTimeMillis (  )  ;", "long   compiledSpeed    =    etime    -    stime ;", "cTotal    +  =    compiledSpeed ;", "log (  ( compiledSpeed    +     \" ms    \"  )  )  ;", "}", "logln (  )  ;", "reportPerformance (  \" complex   expression \"  ,    iTotal ,    cTotal )  ;", "assertFalse ( b )  ;", "assertEquals ( b ,    bc )  ;", "payload . DR [  0  ]  . DRFixedSection . duration    =     0  .  0  4  ;", "bc    =    expression . getValue ( payload ,    Boolean . TYPE )  ;", "assertTrue ( bc )  ;", "}", "METHOD_END"], "methodName": ["complexExpressionPerformance"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "=    parser . parseExpression (  \"  {  ' abcde '  ,  ' ijklm '  }  [  0  ]  . substring (  {  1  ,  3  ,  4  }  [  0  ]  ,  {  1  ,  3  ,  4  }  [  1  ]  )  \"  )  ;", "Object   o    =    getValue (  )  ;", "assertEquals (  \" bc \"  ,    o )  ;", "System . out . println (  \" Performance   check   for   SpEL       '  {  ' abcde '  ,  ' ijklm '  }  [  0  ]  . substring (  {  1  ,  3  ,  4  }  [  0  ]  ,  {  1  ,  3  ,  4  }  [  1  ]  )  '  \"  )  ;", "long   stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "compile (  ;", "System . out . println (  \" Now   compiled :  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" bc \"  ,    o )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "}", "METHOD_END"], "methodName": ["inlineLists"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "=    parser . parseExpression (  \"  {  ' abcde '  ,  {  ' ijklm '  ,  ' nopqr '  }  }  [  1  ]  [  0  ]  . substring (  {  1  ,  3  ,  4  }  [  0  ]  ,  {  1  ,  3  ,  4  }  [  1  ]  )  \"  )  ;", "Object   o    =    getValue (  )  ;", "assertEquals (  \" jk \"  ,    o )  ;", "System . out . println (  \" Performance   check   for   SpEL       '  {  ' abcde '  ,  ' ijklm '  }  [  0  ]  . substring (  {  1  ,  3  ,  4  }  [  0  ]  ,  {  1  ,  3  ,  4  }  [  1  ]  )  '  \"  )  ;", "long   stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "compile (  ;", "System . out . println (  \" Now   compiled :  \"  )  ;", "o    =    getValue (  )  ;", "assertEquals (  \" jk \"  ,    o )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    getValue (  )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "}", "METHOD_END"], "methodName": ["inlineNestedLists"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "if    ( SpelCompilationPerformanceTests . noisyTests )     {", "System . out . print ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["log"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "if    ( SpelCompilationPerformanceTests . noisyTests )     {", "if    (  ( message . length )     >     0  )     {", "System . out . println ( message [  0  ]  )  ;", "} else    {", "System . out . println (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["logln"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "double   averageInterpreted    =    interpretedTotal    /     ( iterations )  ;", "double   averageed    =    compiledTotal    /     ( iterations )  ;", "double   ratio    =     ( averageed    /    averageInterpreted )     *     1  0  0  .  0  ;", "logln (  (  (  (  (  (  (  (  (  (  (  \"  >  >  \"     +    title )     +     \"  :    average   for    \"  )     +     ( count )  )     +     \"  :    compiled =  \"  )     +    averageed )     +     \" ms   interpreted =  \"  )     +    averageInterpreted )     +     \" ms :    compiled   takes    \"  )     +     (  ( int )     ( ratio )  )  )     +     \"  %    of   the   interpreted   time \"  )  )  ;", "if    ( averageed    >    averageInterpreted )     {", "fail (  (  (  (  (  \" ed   version   took   longer   than   interpreted !    edSpeed =  ~  \"     +    averageed )     +     \" ms   InterpretedSpeed =  \"  )     +    averageInterpreted )     +     \" ms \"  )  )  ;", "}", "logln (  )  ;", "}", "METHOD_END"], "methodName": ["reportPerformance"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "expression    =    parser . parseExpression (  \"  ' hello '     +    getWorld (  )     +     '    spring '  \"  )  ;", ". Greeter   g    =    new    . Greeter (  )  ;", "Object   o    =    expression . getValue ( g )  ;", "assertEquals (  \" helloworld   spring \"  ,    o )  ;", "System . out . println (  \" Performance   check   for   SpEL   expression :     ' hello '     +    getWorld (  )     +     '    spring '  \"  )  ;", "long   stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( g )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( g )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( g )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "compile ( expression )  ;", "System . out . println (  \" Now   compiled :  \"  )  ;", "o    =    expression . getValue ( g )  ;", "assertEquals (  \" helloworld   spring \"  ,    o )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( g )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( g )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "stime    =    System . currentTimeMillis (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  0  ;    i +  +  )     {", "o    =    expression . getValue ( g )  ;", "}", "System . out . println (  (  (  \" One   million   iterations :     \"     +     (  ( System . currentTimeMillis (  )  )     -    stime )  )     +     \" ms \"  )  )  ;", "}", "METHOD_END"], "methodName": ["stringConcatenation"], "fileName": "org.springframework.expression.spel.SpelCompilationPerformanceTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' Hello   World '  . bytes . length \"  ,     1  1  ,    Integer . class )  ;", "}", "METHOD_END"], "methodName": ["testArrayLengthAccess"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "Inventor   inventor    =    new   Inventor (  )  ;", "StandardEvaluationContext   inventorContext    =    new   StandardEvaluationContext (  )  ;", "inventorContext . setRootObject ( inventor )  ;", "parser . parseE (  \" foo \"  )  . setValue ( inventorContext ,     \" Alexander   Seovic 2  \"  )  ;", "assertEquals (  \" Alexander   Seovic 2  \"  ,    parser . parseE (  \" foo \"  )  . getValue ( inventorContext ,    String . class )  )  ;", "String   aleks    =    parser . parseE (  \" foo    =     ' Alexandar   Seovic '  \"  )  . getValue ( inventorContext ,    String . class )  ;", "assertEquals (  \" Alexandar   Seovic \"  ,    parser . parseE (  \" foo \"  )  . getValue ( inventorContext ,    String . class )  )  ;", "assertEquals (  \" Alexandar   Seovic \"  ,    aleks )  ;", "}", "METHOD_END"], "methodName": ["testAssignment"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" new   String (  ' Hello   World '  . bytes )  \"  ,     \" Hello   World \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testBeanPropertyAccess"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   societyContext    =    new   StandardEvaluationContext (  )  ;", "societyContext . setRootObject ( new   SpelDocumentationTests . IEEE (  )  )  ;", "Inventor   einstein    =    parser . parseExpression (  \" new   testresources . Inventor (  ' Albert   Einstein '  , new   Date (  )  ,     ' German '  )  \"  )  . getValue ( Inventor . class )  ;", "assertEquals (  \" Albert   Einstein \"  ,    einstein . getName (  )  )  ;", "parser . parseExpression (  \" Members 2  . add ( new   testresources . Inventor (  ' Albert   Einstein '  ,     ' German '  )  )  \"  )  . getValue ( societyContext )  ;", "}", "METHOD_END"], "methodName": ["testConstructors"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   societyContext    =    new   StandardEvaluationContext (  )  ;", "societyContext . setRootObject ( new    . IEEE (  )  )  ;", "Inventor   pupin    =    parser . parseExpression (  \" officers [  ' president '  ]  \"  )  . getValue ( societyContext ,    Inventor . class )  ;", "assertNotNull ( pupin )  ;", "String   city    =    parser . parseExpression (  \" officers [  ' president '  ]  . PlaceOfBirth . city \"  )  . getValue ( societyContext ,    String . class )  ;", "assertNotNull ( city )  ;", "Inventor   i    =    parser . parseExpression (  \" officers [  ' advisors '  ]  [  0  ]  \"  )  . getValue ( societyContext ,    Inventor . class )  ;", "assertEquals (  \" Nikola   Tesla \"  ,    i . getName (  )  )  ;", "parser . parseExpression (  \" officers [  ' advisors '  ]  [  0  ]  . PlaceOfBirth . Country \"  )  . setValue ( societyContext ,     \" Croatia \"  )  ;", "Inventor   i 2     =    parser . parseExpression (  \" reverse [  0  ]  [  ' advisors '  ]  [  0  ]  \"  )  . getValue ( societyContext ,    Inventor . class )  ;", "assertEquals (  \" Nikola   Tesla \"  ,    i 2  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDictionaryAccess"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setRootObject (  . tesla )  ;", "Expression   exp    =    parser . parseExpression (  \" name    =  =     ' Nikola   Tesla '  \"  )  ;", "boolean   isEqual    =    exp . getValue ( context ,    Boolean . class )  ;", "assertTrue ( isEqual )  ;", "}", "METHOD_END"], "methodName": ["testEqualityCheck"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . registerFunction (  \" reverseString \"  ,     . StringUtils . class . getDeclaredMethod (  \" reverseString \"  ,    String . class )  )  ;", "String   helloWorldReversed    =    parser . parseExpression (  \"  # reverseString (  ' hello   world '  )  \"  )  . getValue ( context ,    String . class )  ;", "assertEquals (  \" dlrow   olleh \"  ,    helloWorldReversed )  ;", "}", "METHOD_END"], "methodName": ["testFunctions"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "String   helloWorld    =     (  ( String )     ( parser . parseExpression (  \"  ' Hello   World '  \"  )  . getValue (  )  )  )  ;", "assertEquals (  \" Hello   World \"  ,    helloWorld )  ;", "double   avogadrosNumber    =     (  ( Double )     ( parser . parseExpression (  \"  6  .  0  2  2  1  4  1  5 E +  2  3  \"  )  . getValue (  )  )  )  ;", "assertEquals (  6  .  0  2  2  1  4  1  5 E 2  3  ,    avogadrosNumber ,     0  )  ;", "int   maxValue    =     (  ( Integer )     ( parser . parseExpression (  \"  0 x 7 FFFFFFF \"  )  . getValue (  )  )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,    maxValue )  ;", "boolean   trueValue    =     (  ( Boolean )     ( parser . parseExpression (  \" true \"  )  . getValue (  )  )  )  ;", "assertTrue ( trueValue )  ;", "Object   nullValue    =    parser . parseExpression (  \" null \"  )  . getValue (  )  ;", "assertNull ( nullValue )  ;", "}", "METHOD_END"], "methodName": ["testLiterals"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   societyContext    =    new   StandardEvaluationContext (  )  ;", "societyContext . setRootObject ( new    . IEEE (  )  )  ;", "boolean   falseValue    =    parser . parseExpression (  \" true   and   false \"  )  . getValue ( Boolean . class )  ;", "assertFalse ( falseValue )  ;", "String   expression    =     \" isMember (  ' Nikola   Tesla '  )    and   isMember (  ' Mihajlo   Pupin '  )  \"  ;", "boolean   trueValue    =    parser . parseExpression ( expression )  . getValue ( societyContext ,    Boolean . class )  ;", "trueValue    =    parser . parseExpression (  \" true   or   false \"  )  . getValue ( Boolean . class )  ;", "assertTrue ( trueValue )  ;", "expression    =     \" isMember (  ' Nikola   Tesla '  )    or   isMember (  ' Albert   Einstien '  )  \"  ;", "trueValue    =    parser . parseExpression ( expression )  . getValue ( societyContext ,    Boolean . class )  ;", "assertTrue ( trueValue )  ;", "falseValue    =    parser . parseExpression (  \"  ! true \"  )  . getValue ( Boolean . class )  ;", "assertFalse ( falseValue )  ;", "expression    =     \" isMember (  ' Nikola   Tesla '  )    and    ! isMember (  ' Mihajlo   Pupin '  )  \"  ;", "falseValue    =    parser . parseExpression ( expression )  . getValue ( societyContext ,    Boolean . class )  ;", "assertFalse ( falseValue )  ;", "}", "METHOD_END"], "methodName": ["testLogicalOperators"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ' Hello   World '  . concat (  '  !  '  )  \"  ,     \" Hello   World !  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testMethodInvocation"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "String   c    =    parser . parseExpression (  \"  ' abc '  . substring (  1  ,     3  )  \"  )  . getValue ( String . class )  ;", "assertEquals (  \" bc \"  ,    c )  ;", "StandardEvaluationContext   societyContext    =    new   StandardEvaluationContext (  )  ;", "societyContext . setRootObject ( new    . IEEE (  )  )  ;", "boolean   isMember    =    parser . parseExpression (  \" isMember (  ' Mihajlo   Pupin '  )  \"  )  . getValue ( societyContext ,    Boolean . class )  ;", "assertTrue ( isMember )  ;", "}", "METHOD_END"], "methodName": ["testMethodInvocation2"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "int   two    =    parser . parseExpression (  \"  1     +     1  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  2  ,    two )  ;", "String   testString    =    parser . parseExpression (  \"  ' test '     +     '     '     +     ' string '  \"  )  . getValue ( String . class )  ;", "assertEquals (  \" test   string \"  ,    testString )  ;", "int   four    =    parser . parseExpression (  \"  1     -     -  3  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  4  ,    four )  ;", "double   d    =    parser . parseExpression (  \"  1  0  0  0  .  0  0     -     1 e 4  \"  )  . getValue ( Double . class )  ;", "assertEquals (  (  -  9  0  0  0  .  0  )  ,    d ,     0  )  ;", "int   six    =    parser . parseExpression (  \"  -  2     *     -  3  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  6  ,    six )  ;", "double   twentyFour    =    parser . parseExpression (  \"  2  .  0     *     3 e 0     *     4  \"  )  . getValue ( Double . class )  ;", "assertEquals (  2  4  .  0  ,    twentyFour ,     0  )  ;", "int   minusTwo    =    parser . parseExpression (  \"  6     /     -  3  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  (  -  2  )  ,    minusTwo )  ;", "double   one    =    parser . parseExpression (  \"  8  .  0     /     4 e 0     /     2  \"  )  . getValue ( Double . class )  ;", "assertEquals (  1  .  0  ,    one ,     0  )  ;", "int   three    =    parser . parseExpression (  \"  7     %     4  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  3  ,    three )  ;", "int   oneInt    =    parser . parseExpression (  \"  8     /     5     %     2  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  1  ,    oneInt )  ;", "int   minusTwentyOne    =    parser . parseExpression (  \"  1  +  2  -  3  *  8  \"  )  . getValue ( Integer . class )  ;", "assertEquals (  (  -  2  1  )  ,    minusTwentyOne )  ;", "}", "METHOD_END"], "methodName": ["testNumericalOperators"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "boolean   falseValue    =    parser . parseExpression (  \"  ' xyz '    instanceof   T ( int )  \"  )  . getValue ( Boolean . class )  ;", "assertFalse ( falseValue )  ;", "boolean   trueValue    =    parser . parseExpression (  \"  \\  '  5  .  0  0  \\  '    matches    \\  '  ^  -  ?  \\  \\ d +  (  \\  \\  .  \\  \\ d {  2  }  )  ?  $  \\  '  \"  )  . getValue ( Boolean . class )  ;", "assertTrue ( trueValue )  ;", "falseValue    =    parser . parseExpression (  \"  \\  '  5  .  0  0  6  7  \\  '    matches    \\  '  ^  -  ?  \\  \\ d +  (  \\  \\  .  \\  \\ d {  2  }  )  ?  $  \\  '  \"  )  . getValue ( Boolean . class )  ;", "assertFalse ( falseValue )  ;", "}", "METHOD_END"], "methodName": ["testOtherOperators"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "int   year    =     (  ( Integer )     ( parser . parseE (  \" Birthdate . Year    +     1  9  0  0  \"  )  . getValue ( context )  )  )  ;", "assertEquals (  1  8  5  6  ,    year )  ;", "String   city    =     (  ( String )     ( parser . parseE (  \" placeOfBirth . City \"  )  . getValue ( context )  )  )  ;", "assertEquals (  \" SmilJan \"  ,    city )  ;", "}", "METHOD_END"], "methodName": ["testPropertyAccess"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   teslaContext    =    TestScenarioCreator . getTestEvaluationContext (  )  ;", "String   invention    =    parser . parseExpression (  \" inventions [  3  ]  \"  )  . getValue ( teslaContext ,    String . class )  ;", "assertEquals (  \" Induction   motor \"  ,    invention )  ;", "StandardEvaluationContext   societyContext    =    new   StandardEvaluationContext (  )  ;", ". IEEE   ieee    =    new    . IEEE (  )  ;", "ieee . Members [  0  ]     =     . tesla ;", "societyContext . setRootObject ( ieee )  ;", "String   name    =    parser . parseExpression (  \" Members [  0  ]  . Name \"  )  . getValue ( societyContext ,    String . class )  ;", "assertEquals (  \" Nikola   Tesla \"  ,    name )  ;", "invention    =    parser . parseExpression (  \" Members [  0  ]  . Inventions [  6  ]  \"  )  . getValue ( societyContext ,    String . class )  ;", "assertEquals (  \" Wireless   communication \"  ,    invention )  ;", "}", "METHOD_END"], "methodName": ["testPropertyNavigation"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    parser . parseExpression (  \"  2     =  =     2  \"  )  . getValue ( Boolean . class )  ;", "assertTrue ( result )  ;", "result    =    parser . parseExpression (  \"  2     <     -  5  .  0  \"  )  . getValue ( Boolean . class )  ;", "assertFalse ( result )  ;", "result    =    parser . parseExpression (  \"  ' black '     <     ' block '  \"  )  . getValue ( Boolean . class )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["testRelationalOperators"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "GregorianCalendar   c    =    new   GregorianCalendar (  )  ;", "c . set (  1  8  5  6  ,     7  ,     9  )  ;", "Inventor   tesla    =    new   Inventor (  \" Nikola   Tesla \"  ,    c . getTime (  )  ,     \" Serbian \"  )  ;", "EParser   parser    =    new   SpelEParser (  )  ;", "E   exp    =    parser . parseE (  \" name \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setRootObject ( tesla )  ;", "String   name    =     (  ( String )     ( exp . getValue ( context )  )  )  ;", "assertEquals (  \" Nikola   Tesla \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["testRootObject"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   societyContext    =    new   StandardEvaluationContext (  )  ;", "societyContext . setRootObject ( new    . IEEE (  )  )  ;", "List < Inventor >    list    =     (  ( List < Inventor >  )     ( parser . parseExpression (  \" Members 2  .  ?  [ nationality    =  =     ' Serbian '  ]  \"  )  . getValue ( societyContext )  )  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals (  \" Nikola   Tesla \"  ,    list . get (  0  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSelection"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    primes    =    new   ArrayList <  >  (  )  ;", "primes . addAll ( Arrays . asList (  2  ,     3  ,     5  ,     7  ,     1  1  ,     1  3  ,     1  7  )  )  ;", "EParser   parser    =    new   SpelEParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" primes \"  ,    primes )  ;", "List < Integer >    primesGreaterThanTen    =     (  ( List < Integer >  )     ( parser . parseE (  \"  # primes .  ?  [  # this >  1  0  ]  \"  )  . getValue ( context )  )  )  ;", "assertEquals (  \"  [  1  1  ,     1  3  ,     1  7  ]  \"  ,    primesGreaterThanTen . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpecialVariables"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "String   randomPhrase    =    parser . parseExpression (  \" random   number   is    $  { T ( Math )  . random (  )  }  \"  ,    new   SpelDocumentationTests . TemplatedParserContext (  )  )  . getValue ( String . class )  ;", "assertTrue ( randomPhrase . startsWith (  \" random   number \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testTemplating"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "String   falseString    =    parser . parseExpression (  \" false    ?     ' trueExp '     :     ' falseExp '  \"  )  . getValue ( String . class )  ;", "assertEquals (  \" falseExp \"  ,    falseString )  ;", "StandardEvaluationContext   societyContext    =    new   StandardEvaluationContext (  )  ;", "societyContext . setRootObject ( new    . IEEE (  )  )  ;", "parser . parseExpression (  \" Name \"  )  . setValue ( societyContext ,     \" IEEE \"  )  ;", "societyContext . setVariable (  \" queryName \"  ,     \" Nikola   Tesla \"  )  ;", "String   expression    =     \" isMember (  # queryName )  ?     # queryName    +     '    is   a   member   of   the    '     \"     +     \"  +    Name    +     '    Society '     :     # queryName    +     '    is   not   a   member   of   the    '     +    Name    +     '    Society '  \"  ;", "String   queryResultString    =    parser . parseExpression ( expression )  . getValue ( societyContext ,    String . class )  ;", "assertEquals (  \" Nikola   Tesla   is   a   member   of   the   IEEE   Society \"  ,    queryResultString )  ;", "}", "METHOD_END"], "methodName": ["testTernary"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    dateClass    =    parser . parseExpression (  \" T ( Date )  \"  )  . getValue ( Class . class )  ;", "assertEquals ( Date . class ,    dateClass )  ;", "boolean   trueValue    =    parser . parseExpression (  \" T ( RoundingMode )  . CEILING    <    T ( RoundingMode )  . FLOOR \"  )  . getValue ( Boolean . class )  ;", "assertTrue ( trueValue )  ;", "}", "METHOD_END"], "methodName": ["testTypes"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "Inventor   tesla    =    new   Inventor (  \" Nikola   Tesla \"  ,     \" Serbian \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" newName \"  ,     \" Mike   Tesla \"  )  ;", "context . setRootObject ( tesla )  ;", "parser . parseE (  \" foo    =     # newName \"  )  . getValue ( context )  ;", "assertEquals (  \" Mike   Tesla \"  ,    tesla . getFoo (  )  )  ;", "}", "METHOD_END"], "methodName": ["testVariables"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  ( T ( Math )  . random (  )     *     1  0  0  .  0     )  >  0  \"  ,    true ,    Boolean . class )  ;", "}", "METHOD_END"], "methodName": ["testXMLBasedConfig"], "fileName": "org.springframework.expression.spel.SpelDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "return   this . inserts ;", "}", "METHOD_END"], "methodName": ["getInserts"], "fileName": "org.springframework.expression.spel.SpelEvaluationException"}, {"methodBody": ["METHOD_START", "{", "return   this . message ;", "}", "METHOD_END"], "methodName": ["getMessageCode"], "fileName": "org.springframework.expression.spel.SpelEvaluationException"}, {"methodBody": ["METHOD_START", "{", "this . position    =    position ;", "}", "METHOD_END"], "methodName": ["setPosition"], "fileName": "org.springframework.expression.spel.SpelEvaluationException"}, {"methodBody": ["METHOD_START", "{", "Earser   parser    =    new   SpelEarser (  )  ;", "EspelE =    parser . parseE \"  # anArray [  0  ]    eq    1  \"  )  ;", "spelEgetValue (  )  ;", "}", "METHOD_END"], "methodName": ["spelExpressionArrayIndexAccessNullVariables"], "fileName": "org.springframework.expression.spel.SpelExceptionTests"}, {"methodBody": ["METHOD_START", "{", "Earser   parser    =    new   SpelEarser (  )  ;", "EspelE =    parser . parseE \"  # anArray [  0  ]    eq    1  \"  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setVariables ( new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" anArray \"  ,    new   int [  ]  {     1  ,     2  ,     3     }  )  ;", "}", "}  )  ;", "boolean   result    =    spelEgetValue ( ctx ,    Boolean . class )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["spelExpressionArrayWithVariables"], "fileName": "org.springframework.expression.spel.SpelExceptionTests"}, {"methodBody": ["METHOD_START", "{", "Earser   parser    =    new   SpelEarser (  )  ;", "EspelE =    parser . parseE \"  # aList [  0  ]    eq    ' one '  \"  )  ;", "spelEgetValue (  )  ;", "}", "METHOD_END"], "methodName": ["spelExpressionListIndexAccessNullVariables"], "fileName": "org.springframework.expression.spel.SpelExceptionTests"}, {"methodBody": ["METHOD_START", "{", "Earser   parser    =    new   SpelEarser (  )  ;", "EspelE =    parser . parseE \"  # aList [  0  ]    eq    ' one '  \"  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setVariables ( new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" aList \"  ,    new   ArrayList < String >  (  )     {", "{", "add (  \" one \"  )  ;", "add (  \" two \"  )  ;", "add (  \" three \"  )  ;", "}", "}  )  ;", "}", "}  )  ;", "boolean   result    =    spelEgetValue ( ctx ,    Boolean . class )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["spelExpressionListIndexAccessWithVariables"], "fileName": "org.springframework.expression.spel.SpelExceptionTests"}, {"methodBody": ["METHOD_START", "{", "Earser   parser    =    new   SpelEarser (  )  ;", "EspelE =    parser . parseE \"  # aList . contains (  ' one '  )  \"  )  ;", "spelEgetValue (  )  ;", "}", "METHOD_END"], "methodName": ["spelExpressionListNullVariables"], "fileName": "org.springframework.expression.spel.SpelExceptionTests"}, {"methodBody": ["METHOD_START", "{", "Earser   parser    =    new   SpelEarser (  )  ;", "EspelE =    parser . parseE \"  # aList . contains (  ' one '  )  \"  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setVariables ( new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" aList \"  ,    new   ArrayList < String >  (  )     {", "{", "add (  \" one \"  )  ;", "add (  \" two \"  )  ;", "add (  \" three \"  )  ;", "}", "}  )  ;", "}", "}  )  ;", "boolean   result    =    spelEgetValue ( ctx ,    Boolean . class )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["spelExpressionListWithVariables"], "fileName": "org.springframework.expression.spel.SpelExceptionTests"}, {"methodBody": ["METHOD_START", "{", "Earser   parser    =    new   SpelEarser (  )  ;", "EspelE =    parser . parseE \"  # aMap [  ' one '  ]    eq    1  \"  )  ;", "spelEgetValue (  )  ;", "}", "METHOD_END"], "methodName": ["spelExpressionMapIndexAccessNullVariables"], "fileName": "org.springframework.expression.spel.SpelExceptionTests"}, {"methodBody": ["METHOD_START", "{", "Earser   parser    =    new   SpelEarser (  )  ;", "EspelE =    parser . parseE \"  # aMap . containsKey (  ' one '  )  \"  )  ;", "spelEgetValue (  )  ;", "}", "METHOD_END"], "methodName": ["spelExpressionMapNullVariables"], "fileName": "org.springframework.expression.spel.SpelExceptionTests"}, {"methodBody": ["METHOD_START", "{", "Earser   parser    =    new   SpelEarser (  )  ;", "EspelE =    parser . parseE \"  # aMap [  ' one '  ]    eq    1  \"  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setVariables ( new   HashMap < String ,    Object >  (  )     {", "{", "put (  \" aMap \"  ,    new   HashMap < String ,    Integer >  (  )     {", "{", "put (  \" one \"  ,     1  )  ;", "put (  \" two \"  ,     2  )  ;", "put (  \" three \"  ,     3  )  ;", "}", "}  )  ;", "}", "}  )  ;", "boolean   result    =    spelEgetValue ( ctx ,    Boolean . class )  ;", "assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["spelExpressionMapWithVariables"], "fileName": "org.springframework.expression.spel.SpelExceptionTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   formattedMessage    =    new   StringBuilder (  )  ;", "formattedMessage . append (  \" EL \"  )  . append ( this . code )  ;", "switch    ( this . kind )     {", "case   ERROR    :", "formattedMessage . append (  \" E \"  )  ;", "break ;", "}", "formattedMessage . append (  \"  :     \"  )  ;", "formattedMessage . append ( MessageFormat . format ( this . message ,    inserts )  )  ;", "return   formattedMessage . toString (  )  ;", "}", "METHOD_END"], "methodName": ["formatMessage"], "fileName": "org.springframework.expression.spel.SpelMessage"}, {"methodBody": ["METHOD_START", "{", "return   this . inserts ;", "}", "METHOD_END"], "methodName": ["getInserts"], "fileName": "org.springframework.expression.spel.SpelParseException"}, {"methodBody": ["METHOD_START", "{", "return   this . message ;", "}", "METHOD_END"], "methodName": ["getMessageCode"], "fileName": "org.springframework.expression.spel.SpelParseException"}, {"methodBody": ["METHOD_START", "{", "return   this . compilerClassLoader ;", "}", "METHOD_END"], "methodName": ["getCompilerClassLoader"], "fileName": "org.springframework.expression.spel.SpelParserConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . compilerMode ;", "}", "METHOD_END"], "methodName": ["getCompilerMode"], "fileName": "org.springframework.expression.spel.SpelParserConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . maximumAutoGrowSize ;", "}", "METHOD_END"], "methodName": ["getMaximumAutoGrowSize"], "fileName": "org.springframework.expression.spel.SpelParserConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . autoGrowCollections ;", "}", "METHOD_END"], "methodName": ["isAutoGrowCollections"], "fileName": "org.springframework.expression.spel.SpelParserConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   this . autoGrowNullReferences ;", "}", "METHOD_END"], "methodName": ["isAutoGrowNullReferences"], "fileName": "org.springframework.expression.spel.SpelParserConfiguration"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setBeanResolver ( new    . MyBeanResolver (  )  )  ;", "Expression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @ foo \"  )  ;", "assertEquals (  \" custard \"  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  & foo \"  )  ;", "assertEquals (  \" foo   factory \"  ,    expr . getValue ( context )  )  ;", "try    {", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  &  @ foo \"  )  ;", "fail (  \" Illegal   syntax ,    error   expected \"  )  ;", "}    catch    ( SpelParseException   spe )     {", "assertEquals ( SpelMessage . INVALID _ BEAN _ REFERENCE ,    spe . getMessageCode (  )  )  ;", "assertEquals (  0  ,    spe . getPosition (  )  )  ;", "}", "try    {", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @  & foo \"  )  ;", "fail (  \" Illegal   syntax ,    error   expected \"  )  ;", "}    catch    ( SpelParseException   spe )     {", "assertEquals ( SpelMessage . INVALID _ BEAN _ REFERENCE ,    spe . getMessageCode (  )  )  ;", "assertEquals (  0  ,    spe . getPosition (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["AccessingFactoryBean_spr9511"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" joinThreeStrings (  ' a '  , null ,  ' c '  )  \"  ,     \" anullc \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["NPE_SPR5661"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ParserContext   hashes    =    TemplateExpressionParsingTests . HASH _ DELIMITED _ PARSER _ CONTEXT ;", "ParserContext   dollars    =    TemplateExpressionParsingTests . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT ;", "checkTemplateParsing (  \" abc $  {  ' def '  }    ghi \"  ,     \" abcdef   ghi \"  )  ;", "checkTemplateParsingError (  \" abc $  {     {  }  (     ' abc '  \"  ,     \" Missing   closing    '  )  '    for    '  (  '    at   position    8  \"  )  ;", "checkTemplateParsingError (  \" abc $  {     {  }  [     ' abc '  \"  ,     \" Missing   closing    '  ]  '    for    '  [  '    at   position    8  \"  )  ;", "checkTemplateParsingError (  \" abc $  {     {  }  {     ' abc '  \"  ,     \" Missing   closing    '  }  '    for    '  {  '    at   position    8  \"  )  ;", "checkTemplateParsingError (  \" abc $  {     (     ' abc '     }  \"  ,     \" Found   closing    '  }  '    at   position    1  4    but   most   recent   opening   is    '  (  '    at   position    6  \"  )  ;", "checkTemplateParsingError (  \" abc $  {     '  .  .  .     }  \"  ,     \" Found   non   terminating   string   literal   starting   at   position    6  \"  )  ;", "checkTemplateParsingError (  \" abc $  {     \\  \"  .  .  .     }  \"  ,     \" Found   non   terminating   string   literal   starting   at   position    6  \"  )  ;", "checkTemplateParsingError (  \" abc $  {     )     }  \"  ,     \" Found   closing    '  )  '    at   position    6    without   an   opening    '  (  '  \"  )  ;", "checkTemplateParsingError (  \" abc $  {     ]     }  \"  ,     \" Found   closing    '  ]  '    at   position    6    without   an   opening    '  [  '  \"  )  ;", "checkTemplateParsingError (  \" abc $  {     }     }  \"  ,     \" No   expression   defined   within   delimiter    '  $  {  }  '    at   character    3  \"  )  ;", "checkTemplateParsingError (  \" abc $  [     }     ]  \"  ,     . DOLLARSQUARE _ TEMPLATE _ PARSER _ CONTEXT ,     \" Found   closing    '  }  '    at   position    6    without   an   opening    '  {  '  \"  )  ;", "checkTemplateParsing (  \" abc    $  {  \\  \" def \\  '  \\  ' g } hi \\  \"  }    jkl \"  ,     \" abc   def ' g } hi   jkl \"  )  ;", "checkTemplateParsing (  \" abc    $  {  ' def '  ' g } hi '  }    jkl \"  ,     \" abc   def ' g } hi   jkl \"  )  ;", "checkTemplateParsing (  \"  }  \"  ,     \"  }  \"  )  ;", "checkTemplateParsing (  \"  $  {  ' hello '  }    world \"  ,     \" hello   world \"  )  ;", "checkTemplateParsing (  \" Hello    $  {  '  }  '  }  ]  \"  ,     \" Hello    }  ]  \"  )  ;", "checkTemplateParsing (  \" Hello    $  {  '  }  '  }  \"  ,     \" Hello    }  \"  )  ;", "checkTemplateParsingError (  \" Hello    $  {     (     \"  ,     \" No   ending   suffix    '  }  '    for   expression   starting   at   character    6  :     $  {     (     \"  )  ;", "checkTemplateParsingError (  \" Hello    $  {     (     }  \"  ,     \" Found   closing    '  }  '    at   position    1  1    but   most   recent   opening   is    '  (  '    at   position    9  \"  )  ;", "checkTemplateParsing (  \"  #  {  ' Unable   to   render   embedded   object :    File    (  {  # this    =  =     2  }  '  }  \"  ,    hashes ,     \" Unable   to   render   embedded   object :    File    (  {  # this    =  =     2  }  \"  )  ;", "checkTemplateParsing (  \" This   is   the   last   odd   number   in   the   list :     $  { listOfNumbersUpToTen .  $  [  # this %  2  =  =  1  ]  }  \"  ,    dollars ,     \" This   is   the   last   odd   number   in   the   list :     9  \"  )  ;", "checkTemplateParsing (  \" Hello    $  {  ' here   is   a   curly   bracket    }  '  }  \"  ,    dollars ,     \" Hello   here   is   a   curly   bracket    }  \"  )  ;", "checkTemplateParsing (  \" He $  {  '  $  {  '  } llo    $  {  ' here   is   a   curly   bracket    }  '  }  }  \"  ,    dollars ,     \" He $  { llo   here   is   a   curly   bracket    }  }  \"  )  ;", "checkTemplateParsing (  \" Hello    $  {  '  (  )  (  )  (  )  }  {  }  {  }  {  ]  [  ]  {  }  {  ]  [  }  [  ]  [  ]  [  }  {  (  )  (  )  '  }    World \"  ,    dollars ,     \" Hello    (  )  (  )  (  )  }  {  }  {  }  {  ]  [  ]  {  }  {  ]  [  }  [  ]  [  ]  [  }  {  (  )  (  )    World \"  )  ;", "checkTemplateParsing (  \" Hello    $  {  ' inner   literal   that '  ' s   got    {  [  (  ]  )  ]  } an   escaped   quote   in   it '  }    World \"  ,     \" Hello   inner   literal   that ' s   got    {  [  (  ]  )  ]  } an   escaped   quote   in   it   World \"  )  ;", "checkTemplateParsingError (  \" Hello    $  {  \"  ,     \" No   ending   suffix    '  }  '    for   expression   starting   at   character    6  :     $  {  \"  )  ;", "}", "METHOD_END"], "methodName": ["NPE_SPR5673"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   evaluationContext    =    new   StandardEvaluationContext ( new    . BooleanHolder (  )  )  ;", "Object   value    =    parser . parseExpression (  \" primitiveProperty \"  )  . getValue ( evaluationContext )  ;", "assertNotNull ( value )  ;", "}", "METHOD_END"], "methodName": ["SPR10091_primitiveTestValue"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   evaluationContext    =    new   StandardEvaluationContext ( new    . BooleanHolder (  )  )  ;", "Class <  ?  >    valueType    =    parser . parseExpression (  \" primitiveProperty \"  )  . getValueType ( evaluationContext )  ;", "assertNotNull ( valueType )  ;", "}", "METHOD_END"], "methodName": ["SPR10091_primitiveTestValueType"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   evaluationContext    =    new   StandardEvaluationContext ( new    . BooleanHolder (  )  )  ;", "Object   value    =    parser . parseExpression (  \" simpleProperty \"  )  . getValue ( evaluationContext )  ;", "assertNotNull ( value )  ;", "}", "METHOD_END"], "methodName": ["SPR10091_simpleTestValue"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   evaluationContext    =    new   StandardEvaluationContext ( new    . BooleanHolder (  )  )  ;", "Class <  ?  >    valueType    =    parser . parseExpression (  \" simpleProperty \"  )  . getValueType ( evaluationContext )  ;", "assertNotNull ( valueType )  ;", "}", "METHOD_END"], "methodName": ["SPR10091_simpleTestValueType"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "String   fromInterface    =    parser . parseExpression (  (  (  \" T (  \"     +     (  . StaticFinalImpl 1  . class . getName (  )  )  )     +     \"  )  . VALUE \"  )  )  . getValue ( context ,    String . class )  ;", "assertThat ( fromInterface ,    is (  \" interfaceValue \"  )  )  ;", "String   fromClass    =    parser . parseExpression (  (  (  \" T (  \"     +     (  . StaticFinalImpl 2  . class . getName (  )  )  )     +     \"  )  . VALUE \"  )  )  . getValue ( context ,    String . class )  ;", "assertThat ( fromClass ,    is (  \" interfaceValue \"  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR10125"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "doTestSpr 1  0  1  4  6  (  \"  / foo \"  ,     \" EL 1  0  7  0 E :    Problem   parsing   left   operand \"  )  ;", "doTestSpr 1  0  1  4  6  (  \"  * foo \"  ,     \" EL 1  0  7  0 E :    Problem   parsing   left   operand \"  )  ;", "doTestSpr 1  0  1  4  6  (  \"  % foo \"  ,     \" EL 1  0  7  0 E :    Problem   parsing   left   operand \"  )  ;", "doTestSpr 1  0  1  4  6  (  \"  < foo \"  ,     \" EL 1  0  7  0 E :    Problem   parsing   left   operand \"  )  ;", "doTestSpr 1  0  1  4  6  (  \"  > foo \"  ,     \" EL 1  0  7  0 E :    Problem   parsing   left   operand \"  )  ;", "doTestSpr 1  0  1  4  6  (  \"  &  & foo \"  ,     \" EL 1  0  7  0 E :    Problem   parsing   left   operand \"  )  ;", "doTestSpr 1  0  1  4  6  (  \"  |  | foo \"  ,     \" EL 1  0  7  0 E :    Problem   parsing   left   operand \"  )  ;", "doTestSpr 1  0  1  4  6  (  \"  & foo \"  ,     \" EL 1  0  6  9 E :    missing   expected   character    '  &  '  \"  )  ;", "doTestSpr 1  0  1  4  6  (  \"  | foo \"  ,     \" EL 1  0  6  9 E :    missing   expected   character    '  |  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["SPR10146_malformedExpressions"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ReflectivePropertyAccessor   accessor    =    new   ReflectivePropertyAccessor (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Object   target    =    new    . OnlyBridgeMethod (  )  ;", "TypedValue   value    =    accessor . read ( context ,    target ,     \" property \"  )  ;", "assertEquals ( Integer . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR10162_onlyBridgeMethod"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" bridgeExample \"  ,    new   D (  )  )  ;", "EparseE =    parser . parseE \"  # bridgeExample . bridgeMethod (  )  \"  )  ;", "parseEgetValue ( context )  ;", "}", "METHOD_END"], "methodName": ["SPR10210"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( SpelParseException . class )  ;", "thrown . expectMessage (  \" EL 1  0  7  1 E :    A   required   selection      has   not   been   specified \"  )  ;", "Expression   exp    =    parser . parseExpression (  \"  $  [  ]  \"  )  ;", "exp . getValue ( Arrays . asList (  \" foo \"  ,     \" bar \"  ,     \" baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR10328"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "List   list 1     =    new   ArrayList (  )  ;", "list 1  . add (  \" a \"  )  ;", "list 1  . add (  \" b \"  )  ;", "list 1  . add (  \" x \"  )  ;", "List   list 2     =    new   ArrayList (  )  ;", "list 2  . add (  \" c \"  )  ;", "list 2  . add (  \" x \"  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" list 1  \"  ,    list 1  )  ;", "context . setVariable (  \" list 2  \"  ,    list 2  )  ;", "E   ex    =    parser . parseE (  \"  # list 1  .  ?  [  # list 2  . contains (  # this )  ]  \"  )  ;", "Object   result    =    ex . getValue ( context )  ;", "assertEquals (  \"  [ x ]  \"  ,    result . toString (  )  )  ;", "ex    =    parser . parseE (  \"  # list 1  .  ?  [  # list 2  . contains ( toString (  )  )  ]  \"  )  ;", "result    =    ex . getValue ( context )  ;", "assertEquals (  \"  [ x ]  \"  ,    result . toString (  )  )  ;", "List   list 3     =    new   ArrayList (  )  ;", "list 3  . add (  1  )  ;", "list 3  . add (  2  )  ;", "list 3  . add (  3  )  ;", "list 3  . add (  4  )  ;", "context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" list 3  \"  ,    list 3  )  ;", "ex    =    parser . parseE (  \"  # list 3  .  ?  [  # this    >     2  ]  \"  )  ;", "result    =    ex . getValue ( context )  ;", "assertEquals (  \"  [  3  ,     4  ]  \"  ,    result . toString (  )  )  ;", "ex    =    parser . parseE (  \"  # list 3  .  ?  [  # this    >  =    T ( Math )  . abs ( T ( Math )  . abs (  # this )  )  ]  \"  )  ;", "result    =    ex . getValue ( context )  ;", "assertEquals (  \"  [  1  ,     2  ,     3  ,     4  ]  \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR10417"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Map   map 1     =    new   HashMap (  )  ;", "map 1  . put (  \" A \"  ,     6  5  )  ;", "map 1  . put (  \" B \"  ,     6  6  )  ;", "map 1  . put (  \" X \"  ,     6  6  )  ;", "Map   map 2     =    new   HashMap (  )  ;", "map 2  . put (  \" X \"  ,     6  6  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" map 1  \"  ,    map 1  )  ;", "context . setVariable (  \" map 2  \"  ,    map 2  )  ;", "E   ex    =    parser . parseE (  \"  # map 1  .  ?  [  # map 2  . containsKey (  # this . getKey (  )  )  ]  \"  )  ;", "Object   result    =    ex . getValue ( context )  ;", "assertEquals (  \"  { X =  6  6  }  \"  ,    result . toString (  )  )  ;", "ex    =    parser . parseE (  \"  # map 1  .  ?  [  # map 2  . containsKey ( key )  ]  \"  )  ;", "result    =    ex . getValue ( context )  ;", "assertEquals (  \"  { X =  6  6  }  \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR10417_maps"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelParserConfiguration   configuration    =    new   SpelParserConfiguration ( false ,    false )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( configuration )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression   spel    =    parser . parseExpression (  \"  # enumType . values (  )  \"  )  ;", "context . setVariable (  \" enumType \"  ,     . ABC . class )  ;", "Object   result    =    spel . getValue ( context )  ;", "assertNotNull ( result )  ;", "assertTrue ( result . getClass (  )  . isArray (  )  )  ;", "assertEquals (  . ABC . A ,    Array . get ( result ,     0  )  )  ;", "assertEquals (  . ABC . B ,    Array . get ( result ,     1  )  )  ;", "assertEquals (  . ABC . C ,    Array . get ( result ,     2  )  )  ;", "context . setVariable (  \" enumType \"  ,     . XYZ . class )  ;", "result    =    spel . getValue ( context )  ;", "assertNotNull ( result )  ;", "assertTrue ( result . getClass (  )  . isArray (  )  )  ;", "assertEquals (  . XYZ . X ,    Array . get ( result ,     0  )  )  ;", "assertEquals (  . XYZ . Y ,    Array . get ( result ,     1  )  )  ;", "assertEquals (  . XYZ . Z ,    Array . get ( result ,     2  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR10452"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", ". Spr 1  0  4  8  6    rootObject    =    new    . Spr 1  0  4  8  6  (  )  ;", "Expression   classNameExpression    =    parser . parseExpression (  \" class . name \"  )  ;", "Expression   nameExpression    =    parser . parseExpression (  \" name \"  )  ;", "assertThat ( classNameExpression . getValue ( context ,    rootObject )  ,    equalTo (  (  ( Object )     (  . Spr 1  0  4  8  6  . class . getName (  )  )  )  )  )  ;", "assertThat ( nameExpression . getValue ( context ,    rootObject )  ,    equalTo (  (  ( Object )     (  \" name \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR10486"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", ". Spr 1  1  1  4  2    rootObject    =    new    . Spr 1  1  1  4  2  (  )  ;", "Expression   expression    =    parser . parseExpression (  \" something \"  )  ;", "thrown . expect ( SpelEvaluationException . class )  ;", "thrown . expectMessage (  \"  ' something '    cannot   be   found \"  )  ;", "expression . getValue ( context ,    rootObject )  ;", "}", "METHOD_END"], "methodName": ["SPR11142"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Collection < String >    coll    =    new   LinkedHashSet <  >  (  )  ;", "coll . add (  \" one \"  )  ;", "coll . add (  \" two \"  )  ;", "coll    =    Collections . unmodifiableCollection ( coll )  ;", "SpelEParser   parser    =    new   SpelEParser (  )  ;", "E   expr    =    parser . parseE (  \" new   ArrayList (  # root )  \"  )  ;", "Object   value    =    expr . getValue ( coll )  ;", "assertTrue (  ( value   instanceof   ArrayList )  )  ;", "@ SuppressWarnings (  \" rawtypes \"  )", "ArrayList   list    =     (  ( ArrayList )     ( value )  )  ;", "assertEquals (  \" one \"  ,    list . get (  0  )  )  ;", "assertEquals (  \" two \"  ,    list . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR11348"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setBeanResolver ( new    . Spr 1  1  4  4  5 Class (  )  )  ;", "Expression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @ bean . echo (  @ bean . parameter (  )  )  \"  )  ;", "assertEquals (  1  ,    expr . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["SPR11445_beanReference"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . Spr 1  1  4  4  5 Class (  )  )  ;", "Expression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" echo ( parameter (  )  )  \"  )  ;", "assertEquals (  1  ,    expr . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["SPR11445_simple"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Expression   exp    =    new   SpelExpressionParser (  )  . parseExpression (  \" T ( Arrays )  . asList (  ' a '  ,  ' b '  )  \"  )  ;", "List < String >    list    =     (  ( List < String >  )     ( exp . getValue (  )  )  )  ;", "assertThat ( list . size (  )  ,    is (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR11494"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   sec    =    new   StandardEvaluationContext (  )  ;", "sec . addPropertyAccessor ( new   SpelReproTests . MapAccessor (  )  )  ;", "Expression   exp    =    new   SpelExpressionParser (  )  . parseExpression (  \" T (  $ MapWithConstant )  . X \"  )  ;", "assertEquals (  1  ,    exp . getValue ( sec )  )  ;", "}", "METHOD_END"], "methodName": ["SPR11609"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression 1     =    parser . parseExpression (  \" list .  ?  [    value >  2     ]  . size (  )  !  =  0  \"  )  ;", "assertTrue ( expression 1  . getValue ( new    . BeanClass ( new    . ListOf (  1  .  1  )  ,    new    . ListOf (  2  .  2  )  )  ,    Boolean . class )  )  ;", "Expression   expression 2     =    parser . parseExpression (  \" list .  ?  [    T ( Math )  . abs ( value )     >     2     ]  . size (  )  !  =  0  \"  )  ;", "assertTrue ( expression 2  . getValue ( new    . BeanClass ( new    . ListOf (  1  .  1  )  ,    new    . ListOf (  (  -  2  .  2  )  )  )  ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["SPR12035"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \"  # root . getClass (  )  . getName (  )  \"  )  ;", "assertEquals (  . UnnamedUser . class . getName (  )  ,    expression . getValue ( new    . UnnamedUser (  )  )  )  ;", "assertEquals (  . NamedUser . class . getName (  )  ,    expression . getValue ( new    . NamedUser (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR12502"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression    =    parser . parseExpression (  \" T ( Arrays )  . asList (  '  '  )  \"  )  ;", "Object   value    =    getValue (  )  ;", "assertTrue (  ( value   instanceof   List )  )  ;", "assertTrue (  (  ( List )     ( value )  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR12522"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   sec    =    new   StandardEvaluationContext (  )  ;", "sec . setVariable (  \" iterable \"  ,    Collections . emptyList (  )  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" T (  . FooLists )  . newArrayList (  # iterable )  \"  )  ;", "assertTrue (  (  ( expression . getValue ( sec )  )    instanceof   ArrayList )  )  ;", "}", "METHOD_END"], "methodName": ["SPR12803"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expression    =    parser . parseExpression (  \" T (  . DistanceEnforcer )  . from (  # no )  \"  )  ;", "StandardEvaluationContext   sec    =    new   StandardEvaluationContext (  )  ;", "sec . setVariable (  \" no \"  ,    new   Integer (  1  )  )  ;", "assertTrue ( expression . getValue ( sec )  . toString (  )  . startsWith (  \" Integer \"  )  )  ;", "sec    =    new   StandardEvaluationContext (  )  ;", "sec . setVariable (  \" no \"  ,    new   Float (  1  .  0  )  )  ;", "assertTrue ( expression . getValue ( sec )  . toString (  )  . startsWith (  \" Number \"  )  )  ;", "sec    =    new   StandardEvaluationContext (  )  ;", "sec . setVariable (  \" no \"  ,     \"  1  .  0  \"  )  ;", "assertTrue ( expression . getValue ( sec )  . toString (  )  . startsWith (  \" Object \"  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR12808"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "List < Map < String ,    Object >  >    myPayload    =    new   ArrayList <  >  (  )  ;", "Map < String ,    Object >    v 1     =    new   HashMap <  >  (  )  ;", "Map < String ,    Object >    v 2     =    new   HashMap <  >  (  )  ;", "v 1  . put (  \" test 1  1  \"  ,     \" test 1  1  \"  )  ;", "v 1  . put (  \" test 1  2  \"  ,     \" test 1  2  \"  )  ;", "v 2  . put (  \" test 2  1  \"  ,     \" test 2  1  \"  )  ;", "v 2  . put (  \" test 2  2  \"  ,     \" test 2  2  \"  )  ;", "myPayload . add ( v 1  )  ;", "myPayload . add ( v 2  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext ( myPayload )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "String   ex    =     \"  # root .  !  [ T ( util . StringUtils )  . collectionToCommaDelimitedString (  # this . values (  )  )  ]  \"  ;", "List   res    =    parser . parseExpression ( ex )  . getValue ( context ,    List . class )  ;", "assertEquals (  \"  [ test 1  2  , test 1  1  ,    test 2  2  , test 2  1  ]  \"  ,    res . toString (  )  )  ;", "res    =    parser . parseExpression (  \"  # root .  !  [  # this . values (  )  ]  \"  )  . getValue ( context ,    List . class )  ;", "assertEquals (  \"  [  [ test 1  2  ,    test 1  1  ]  ,     [ test 2  2  ,    test 2  1  ]  ]  \"  ,    res . toString (  )  )  ;", "res    =    parser . parseExpression (  \"  # root .  !  [ values (  )  ]  \"  )  . getValue ( context ,    List . class )  ;", "assertEquals (  \"  [  [ test 1  2  ,    test 1  1  ]  ,     [ test 2  2  ,    test 2  1  ]  ]  \"  ,    res . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR13055"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "EParser   parser    =    new   SpelEParser (  )  ;", "E   ex    =    parser . parseE (  \"  {  ' a '  :  ' y '  ,  ' b '  :  ' n '  }  .  !  [ value =  =  ' y '  ? key : null ]  \"  )  ;", "assertEquals (  \"  [ a ,    null ]  \"  ,    ex . getValue ( context )  . toString (  )  )  ;", "ex    =    parser . parseE (  \"  {  2  :  4  ,  3  :  6  }  .  !  [ T ( Math )  . abs (  # this . key )     +     5  ]  \"  )  ;", "assertEquals (  \"  [  7  ,     8  ]  \"  ,    ex . getValue ( context )  . toString (  )  )  ;", "ex    =    parser . parseE (  \"  {  2  :  4  ,  3  :  6  }  .  !  [ T ( Math )  . abs (  # this . value )     +     5  ]  \"  )  ;", "assertEquals (  \"  [  9  ,     1  1  ]  \"  ,    ex . getValue ( context )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR13055_maps"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" encoding \"  ,     \" UTF -  8  \"  )  ;", "E   ex    =    parser . parseE (  \" T ( Charset )  . forName (  # encoding )  \"  )  ;", "Object   result    =    ex . getValue ( context )  ;", "assertEquals ( StandardCharsets . UTF _  8  ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR13918"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" str \"  ,     \" a \\ u 0  0  0  0 b \"  )  ;", "E   ex    =    parser . parseE (  \"  # str ?  . split (  \\  '  \\ u 0  0  0  0  \\  '  )  \"  )  ;", "Object   result    =    ex . getValue ( context )  ;", "assertTrue ( ObjectUtils . nullSafeEquals ( result ,    new   String [  ]  {     \" a \"  ,     \" b \"     }  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR16032"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "parser . parseExpression (  \" simpleProperty \"  )  . setValue ( new    . BooleanHolder (  )  ,    null )  ;", "try    {", "parser . parseExpression (  \" primitiveProperty \"  )  . setValue ( new    . BooleanHolder (  )  ,    null )  ;", "fail (  \" Should   have   thrown   EvaluationException \"  )  ;", "}    catch    ( EvaluationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["SPR16123"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    m    =    new   HashMap <  >  (  )  ;", "m . put (  \" foo \"  ,     \" bar \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( m )  ;", "context . addPropertyAccessor ( new    . MapAccessor (  )  )  ;", "Expression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  [  ' foo '  ]  \"  )  ;", "assertEquals (  \" bar \"  ,    expr . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["SPR5804"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . TestProperties (  )  )  ;", "String   name    =    null ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" jdbcProperties [  ' username '  ]  \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" Dave \"  ,    name )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" jdbcProperties [ username ]  \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" Dave \"  ,    name )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" jdbcProperties . username \"  )  ;", "context . addPropertyAccessor ( new   SpelReproTests . MapAccessor (  )  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" Dave \"  ,    name )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" jdbcProperties [ foo . bar ]  \"  )  ;", "context . addPropertyAccessor ( new   SpelReproTests . MapAccessor (  )  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" Dave 2  \"  ,    name )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" jdbcProperties [  ' foo . bar '  ]  \"  )  ;", "context . addPropertyAccessor ( new   SpelReproTests . MapAccessor (  )  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" Elephant \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["SPR5847"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . Spr 5  8  9  9 Class (  )  )  ;", "Expression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" tryToInvokeWithNull (  1  2  )  \"  )  ;", "assertEquals (  1  2  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" tryToInvokeWithNull ( null )  \"  )  ;", "assertEquals ( null ,    expr . getValue ( context )  )  ;", "try    {", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" tryToInvokeWithNull 2  ( null )  \"  )  ;", "expr . getValue (  )  ;", "fail (  \" Should   have   failed   to   find   a   method   to   which   it   could   pass   null \"  )  ;", "}    catch    ( EvaluationException   see )     {", "}", "context . setTypeLocator ( new   SpelReproTests . MyTypeLocator (  )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" tryToInvokeWithNull 3  ( null ,  ' a '  ,  ' b '  )  \"  )  ;", "assertEquals (  \" ab \"  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" tryToInvokeWithNull 3  (  1  2  ,  ' a '  , null ,  ' c '  )  \"  )  ;", "assertEquals (  \" anullc \"  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" new   Spr 5  8  9  9 Class (  )  . toString (  )  \"  )  ;", "assertEquals (  \" instance \"  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" new   Spr 5  8  9  9 Class ( null )  . toString (  )  \"  )  ;", "assertEquals (  \" instance \"  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" new   Spr 5  8  9  9 Class ( null ,  ' a '  ,  ' b '  )  . toString (  )  \"  )  ;", "assertEquals (  \" instance \"  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" new   Spr 5  8  9  9 Class ( null ,  ' a '  ,    null ,     ' b '  )  . toString (  )  \"  )  ;", "assertEquals (  \" instance \"  ,    expr . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["SPR5899"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . Spr 5  8  9  9 Class (  )  )  ;", "Expression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" T ( Map $ Entry )  \"  )  ;", "assertEquals ( Map . Entry . class ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" T (  $ Outer $ Inner )  . run (  )  \"  )  ;", "assertEquals (  1  2  ,    expr . getValue ( context )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" new    $ Outer $ Inner (  )  . run 2  (  )  \"  )  ;", "assertEquals (  1  3  ,    expr . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["SPR5905_InnerTypeReferences"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelReproTests . TestClass 2    one    =    new   SpelReproTests . TestClass 2  (  \" abc \"  )  ;", "SpelReproTests . TestClass 2    two    =    new   SpelReproTests . TestClass 2  (  \" abc \"  )  ;", "Map < String ,    SpelReproTests . TestClass 2  >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" one \"  ,    one )  ;", "map . put (  \" two \"  ,    two )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \"  [  ' one '  ]     =  =     [  ' two '  ]  \"  )  ;", "assertTrue ( expr . getValue ( map ,    Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["SPR9194"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedNumber    =     1  0  .  2  1 F    +     1  0  .  2  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    +     1  0  .  2  \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_addFloatWithDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedNumber    =     1  0  .  2  1 F    +     1  0  .  2 F ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    +     1  0  .  2 f \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_addFloatWithFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedNumber    =     (  -  1  0  .  2  1 F )     /     (  -  1  0  .  2  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    /     -  1  0  .  2  \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatDivideByDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedNumber    =     (  -  1  0  .  2  1 F )     /     (  -  1  0  .  2 F )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    /     -  1  0  .  2 f \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatDivideByFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedResult    =     1  0  .  2  1  5 F    =  =     1  0  .  2  1  0  9  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1  5 f    =  =     1  0  .  2  1  0  9  \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatEqDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedResult    =     (  -  1  0  .  2  1 F )     =  =     (  -  1  0  .  2  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    =  =     -  1  0  .  2  \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatEqDoubleUnaryMinus"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedResult    =     1  0  .  2  1  5 F    =  =     1  0  .  2  1  0  9 F ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1  5 f    =  =     1  0  .  2  1  0  9 f \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatEqFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedResult    =     (  -  1  0  .  2  1 F )     =  =     (  -  1  0  .  2 F )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    =  =     -  1  0  .  2 f \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatEqFloatUnaryMinus"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedResult    =    Math . abs (  (  -  1  0  .  2 F )  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", ". SPR 9  4  8  6  _ FunctionsClass   testObject    =    new    . SPR 9  4  8  6  _ FunctionsClass (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression   expression    =    parser . parseExpression (  \" abs (  -  1  0  .  2 f )  \"  )  ;", "Number   result    =    expression . getValue ( context ,    testObject ,    Number . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatFunctionResolver"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedResult    =     (  -  1  0  .  2  1 F )     >     (  -  1  0  .  2  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    >     -  1  0  .  2  \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatGreaterThanDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedResult    =     (  -  1  0  .  2  1 F )     >  =     (  -  1  0  .  2  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    >  =     -  1  0  .  2  \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatGreaterThanEqualDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedNumber    =     (  -  1  0  .  2  1 F )     >     (  -  1  0  .  2 F )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    >     -  1  0  .  2 f \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatGreaterThanFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedNumber    =     (  -  1  0  .  2  1 F )     >  =     (  -  1  0  .  2 F )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    >  =     -  1  0  .  2 f \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatGreaterThanOrEqualFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedNumber    =     (  -  1  0  .  2  1 F )     <     (  -  1  0  .  2  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    <     -  1  0  .  2  \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatLessThanDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedNumber    =     (  -  1  0  .  2  1 F )     <     (  -  1  0  .  2 F )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    <     -  1  0  .  2 f \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatLessThanFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedNumber    =     (  -  1  0  .  2  1 F )     <  =     (  -  1  0  .  2  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    <  =     -  1  0  .  2  \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatLessThanOrEqualDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedNumber    =     (  -  1  0  .  2  1 F )     <  =     (  -  1  0  .  2  2 F )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  -  1  0  .  2  1 f    <  =     -  1  0  .  2  2 f \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatLessThanOrEqualFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedResult    =     1  0  .  2  1 F    %     1  0  .  2  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    %     1  0  .  2  \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatModulusDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedResult    =     1  0  .  2  1 F    %     1  0  .  2 F ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    %     1  0  .  2 f \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatModulusFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedResult    =     1  0  .  2  1  5 F    !  =     1  0  .  2  1  0  9  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1  5 f    !  =     1  0  .  2  1  0  9  \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatNotEqDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Boolean   expectedResult    =     1  0  .  2  1  5 F    !  =     1  0  .  2  1  0  9 F ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1  5 f    !  =     1  0  .  2  1  0  9 f \"  )  ;", "Boolean   result    =    getValue ( context ,    null ,    Boolean . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatNotEqFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedResult    =    Math . pow (  1  0  .  2  1 F ,     1  0  .  2  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    ^     1  0  .  2  \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatPowerDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedResult    =    Math . pow (  1  0  .  2  1 F ,     (  -  1  0  .  2 F )  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    ^     -  1  0  .  2 f \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedResult ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_floatPowerFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedNumber    =     1  0  .  2  1 F    *     1  0  .  2  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    *     1  0  .  2  \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_multiplyFloatWithDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedNumber    =     1  0  .  2  1 F    *     1  0  .  2 F ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    *     1  0  .  2 f \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_multiplyFloatWithFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedNumber    =     1  0  .  2  1 F    -     1  0  .  2  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    -     1  0  .  2  \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_subtractFloatWithDouble"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Number   expectedNumber    =     1  0  .  2  1 F    -     1  0  .  2 F ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    parser . parseExpression (  \"  1  0  .  2  1 f    -     1  0  .  2 f \"  )  ;", "Number   result    =    getValue ( context ,    null ,    Number . class )  ;", "assertEquals ( expectedNumber ,    result )  ;", "}", "METHOD_END"], "methodName": ["SPR9486_subtractFloatWithFloat"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelParserConfiguration   configuration    =    new   SpelParserConfiguration ( false ,    false )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser ( configuration )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression   spel    =    parser . parseExpression (  \"  # enumType . values (  )  \"  )  ;", "context . setVariable (  \" enumType \"  ,     . ABC . class )  ;", "Object   result    =    spel . getValue ( context )  ;", "assertNotNull ( result )  ;", "assertTrue ( result . getClass (  )  . isArray (  )  )  ;", "assertEquals (  . ABC . A ,    Array . get ( result ,     0  )  )  ;", "assertEquals (  . ABC . B ,    Array . get ( result ,     1  )  )  ;", "assertEquals (  . ABC . C ,    Array . get ( result ,     2  )  )  ;", "context . addMethodResolver ( new   MethodResolver (  )     {", "@ Override", "public   MethodExecutor   resolve ( EvaluationContext   context ,    Object   targetObject ,    String   name ,    List < TypeDescriptor >    argumentTypes )    throws   AccessException    {", "return   new   MethodExecutor (  )     {", "@ Override", "public   TypedValue   execute ( EvaluationContext   context ,    Object   target ,    Object .  .  .    arguments )    throws   AccessException    {", "try    {", "Method   method    =     . XYZ . class . getMethod (  \" values \"  )  ;", "Object   value    =    method . invoke ( target ,    arguments )  ;", "return   new   TypedValue ( value ,    new   TypeDescriptor ( new   MethodParameter ( method ,     (  -  1  )  )  )  . narrow ( value )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   AccessException ( ex . getMessage (  )  ,    ex )  ;", "}", "}", "}  ;", "}", "}  )  ;", "result    =    spel . getValue ( context )  ;", "assertNotNull ( result )  ;", "assertTrue ( result . getClass (  )  . isArray (  )  )  ;", "assertEquals (  . XYZ . X ,    Array . get ( result ,     0  )  )  ;", "assertEquals (  . XYZ . Y ,    Array . get ( result ,     1  )  )  ;", "assertEquals (  . XYZ . Z ,    Array . get ( result ,     2  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR9495"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelReproTests . Item   item    =    new   SpelReproTests . Item (  )  ;", "item . setName (  \" parent \"  )  ;", "SpelReproTests . Item   item 1     =    new   SpelReproTests . Item (  )  ;", "item 1  . setName (  \" child 1  \"  )  ;", "SpelReproTests . Item   item 2     =    new   SpelReproTests . Item (  )  ;", "item 2  . setName (  \" child 2  \"  )  ;", "item . add ( item 1  )  ;", "item . add ( item 2  )  ;", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "EvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression   exp    =    parser . parseExpression (  \"  # item [  0  ]  . name \"  )  ;", "context . setVariable (  \" item \"  ,    item )  ;", "assertEquals (  \" child 1  \"  ,    exp . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["SPR9735"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ReflectivePropertyAccessor   accessor    =    new   ReflectivePropertyAccessor (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Object   target    =    new    . GenericImplementation (  )  ;", "TypedValue   value    =    accessor . read ( context ,    target ,     \" property \"  )  ;", "assertEquals ( Integer . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["SPR9994_bridgeMethods"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" printDouble ( T ( BigDecimal )  . valueOf (  1  4  .  3  5  )  )  \"  ,     \"  1  4  .  3  5  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["SWF1086"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "Expression    =    null ;", "Object   result    =    null ;", "=    parser . parseExpression (  \" new   Long [  0  ]  . class \"  )  ;", "result    =    getValue ( context ,     \"  \"  )  ;", "assertEquals (  \" Equal   assertion   failed :     \"  ,     \" class    [ LLong ;  \"  ,    result . toString (  )  )  ;", "=    parser . parseExpression (  \" T ( Long [  ]  )  \"  )  ;", "result    =    getValue ( context ,     \"  \"  )  ;", "assertEquals (  \" Equal   assertion   failed :     \"  ,     \" class    [ LLong ;  \"  ,    result . toString (  )  )  ;", "=    parser . parseExpression (  \" T ( String [  ]  [  ]  [  ]  )  \"  )  ;", "result    =    getValue ( context ,     \"  \"  )  ;", "assertEquals (  \" Equal   assertion   failed :     \"  ,     \" class    [  [  [ LString ;  \"  ,    result . toString (  )  )  ;", "assertEquals (  \" T ( String [  ]  [  ]  [  ]  )  \"  ,     (  ( SpelExpression )     (  )  . toStringAST (  )  )  ;", "=    parser . parseExpression (  \" new   int [  0  ]  . class \"  )  ;", "result    =    getValue ( context ,     \"  \"  )  ;", "assertEquals (  \" Equal   assertion   failed :     \"  ,     \" class    [ I \"  ,    result . toString (  )  )  ;", "=    parser . parseExpression (  \" T ( int [  ]  [  ]  )  \"  )  ;", "result    =    getValue ( context ,     \"  \"  )  ;", "assertEquals (  \" class    [  [ I \"  ,    result . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["array"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . XX (  )  )  ;", "Expression   expr    =    null ;", "try    {", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @ foo \"  )  ;", "assertEquals (  \" custard \"  ,    expr . getValue ( context ,    String . class )  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . NO _ BEAN _ RESOLVER _ REGISTERED ,    see . getMessageCode (  )  )  ;", "assertEquals (  \" foo \"  ,    see . getInserts (  )  [  0  ]  )  ;", "}", "context . setBeanResolver ( new   SpelReproTests . MyBeanResolver (  )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @ foo \"  )  ;", "assertEquals (  \" custard \"  ,    expr . getValue ( context ,    String . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @ bar \"  )  ;", "assertEquals ( null ,    expr . getValue ( context ,    String . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @ goo \"  )  ;", "try    {", "assertEquals ( null ,    expr . getValue ( context ,    String . class )  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . EXCEPTION _ DURING _ BEAN _ RESOLUTION ,    see . getMessageCode (  )  )  ;", "assertEquals (  \" goo \"  ,    see . getInserts (  )  [  0  ]  )  ;", "assertTrue (  (  ( see . getCause (  )  )    instanceof   AccessException )  )  ;", "assertTrue ( see . getCause (  )  . getMessage (  )  . startsWith (  \" DONT \"  )  )  ;", "}", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @  ' foo . bar '  \"  )  ;", "assertEquals (  \" trouble \"  ,    expr . getValue ( context ,    String . class )  )  ;", "try    {", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  @  3  7  8  \"  )  ;", "assertEquals (  \" trouble \"  ,    expr . getValue ( context ,    String . class )  )  ;", "}    catch    ( SpelParseException   spe )     {", "assertEquals ( SpelMessage . INVALID _ BEAN _ REFERENCE ,    spe . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["beanResolution"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "checkTemplateParsing ( expression ,    TemplateExpressionParsingTests . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT ,    expectedValue )  ;", "}", "METHOD_END"], "methodName": ["checkTemplateParsing"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  ,    context )  ;", "assertEquals ( expectedValue ,    expr . getValue ( TestScenarioCreator . getTestEvaluationContext (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkTemplateParsing"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "checkTemplateParsingError ( expression ,    TemplateExpressionParsingTests . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT ,    expectedMessage )  ;", "}", "METHOD_END"], "methodName": ["checkTemplateParsingError"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "try    {", "parser . parseExpression (  ,    context )  ;", "fail (  (  \" Should   have   failed   with   message :     \"     +    expectedMessage )  )  ;", "}    catch    ( Exception   ex )     {", "String   message    =    ex . getMessage (  )  ;", "if    ( ex   instanceof   ExpressionException )     {", "message    =     (  ( ExpressionException )     ( ex )  )  . getSimpleMessage (  )  ;", "}", "if    (  !  ( message . equals ( expectedMessage )  )  )     {", "ex . printStackTrace (  )  ;", "}", "assertThat ( expectedMessage ,    equalTo ( message )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkTemplateParsingError"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   ConversionPriority 1     {", "public   int   getX ( Number   i )     {", "return    2  0  ;", "}", "public   int   getX ( int   i )     {", "return    1  0  ;", "}", "}", "@ SuppressWarnings (  \" unused \"  )", "class   ConversionPriority 2     {", "public   int   getX ( int   i )     {", "return    1  0  ;", "}", "public   int   getX ( Number   i )     {", "return    2  0  ;", "}", "}", "final   Integer   INTEGER    =    Integer . valueOf (  7  )  ;", "EvaluationContext   emptyEvalContext    =    new   StandardEvaluationContext (  )  ;", "List < TypeDescriptor >    args    =    new   ArrayList <  >  (  )  ;", "args . add ( TypeDescriptor . forObject ( new   Integer (  4  2  )  )  )  ;", "ConversionPriority 1    target    =    new   ConversionPriority 1  (  )  ;", "MethodExecutor   me    =    new   ReflectiveMethodResolver ( true )  . resolve ( emptyEvalContext ,    target ,     \" getX \"  ,    args )  ;", "final   int   actual    =     (  ( Integer )     ( me . execute ( emptyEvalContext ,    target ,    new   Integer (  4  2  )  )  . getValue (  )  )  )  ;", "final   int   compiler    =    target . getX ( INTEGER )  ;", "assertEquals ( compiler ,    actual )  ;", "ConversionPriority 2    target 2     =    new   ConversionPriority 2  (  )  ;", "MethodExecutor   me 2     =    new   ReflectiveMethodResolver ( true )  . resolve ( emptyEvalContext ,    target 2  ,     \" getX \"  ,    args )  ;", "int   actual 2     =     (  ( Integer )     ( me 2  . execute ( emptyEvalContext ,    target 2  ,    new   Integer (  4  2  )  )  . getValue (  )  )  )  ;", "int   compiler 2     =    target 2  . getX ( INTEGER )  ;", "assertEquals ( compiler 2  ,    actual 2  )  ;", "}", "METHOD_END"], "methodName": ["conversionPriority_SPR8224"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "List < MethodResolver >    methodResolvers    =    new   ArrayList <  >  (  )  ;", "methodResolvers . add ( new   ReflectiveMethodResolver (  )     {", "@ Override", "protected   Method [  ]    getMethods ( Class <  ?  >    type )     {", "try    {", "return   new   Method [  ]  {    Integer . class . getDeclaredMethod (  \" parseInt \"  ,    String . class ,    Integer . TYPE )     }  ;", "}    catch    ( NoSuchMethodException   ex )     {", "return   new   Method [  0  ]  ;", "}", "}", "}  )  ;", "context . setMethodResolvers ( methodResolvers )  ;", "Expression    =    parser . parseExpression (  \" parseInt (  '  - FF '  ,     1  6  )  \"  )  ;", "Integer   result    =    getValue ( context ,     \"  \"  ,    Integer . class )  ;", "assertEquals (  (  -  2  5  5  )  ,    result . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["customStaticFunctions_SPR9038"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "thrown . expect ( SpelParseException . class )  ;", "thrown . expectMessage ( expectedMessage )  ;", "new   SpelExpressionParser (  )  . parseExpression (  )  ;", "}", "METHOD_END"], "methodName": ["doTestSpr10146"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelReproTests . Holder   h    =    new   SpelReproTests . Holder (  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( h )  ;", "context . addPropertyAccessor ( new   SpelReproTests . MapAccessor (  )  )  ;", "h . map . put (  \"  $ foo \"  ,     \" wibble \"  )  ;", "h . map . put (  \" foo $ bar \"  ,     \" wobble \"  )  ;", "h . map . put (  \" foobar $  $  \"  ,     \" wabble \"  )  ;", "h . map . put (  \"  $  \"  ,     \" wubble \"  )  ;", "h . map . put (  \"  $  $  \"  ,     \" webble \"  )  ;", "h . map . put (  \"  $  _  $  \"  ,     \" tribble \"  )  ;", "String   name    =    null ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" map .  $ foo \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" wibble \"  ,    name )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" map . foo $ bar \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" wobble \"  ,    name )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" map . foobar $  $  \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" wabble \"  ,    name )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" map .  $  \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" wubble \"  ,    name )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" map .  $  $  \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" webble \"  ,    name )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" map .  $  _  $  \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" tribble \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["dollarPrefixedIdentifier_SPR7100"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . XX (  )  )  ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" m [  '  $ foo '  ]  \"  )  ;", "context . setVariable (  \" file _ name \"  ,     \"  $ foo \"  )  ;", "assertEquals (  \" wibble \"  ,    expr . getValue ( context ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["dollars"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . XX (  )  )  ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" m [  $ foo ]  \"  )  ;", "context . setVariable (  \" file _ name \"  ,     \"  $ foo \"  )  ;", "assertEquals (  \" wibble \"  ,    expr . getValue ( context ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["dollars2"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" printDoubles ( getDoublesAsStringList (  )  )  \"  ,     \"  {  1  4  .  3  5  ,     1  5  .  4  5  }  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["doubleArrayCoercion"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \" printDouble (  1  4  .  3  5  )  \"  ,     \"  1  4  .  3  5  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["doubleCoercion"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . XX (  )  )  ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  (  ?  :  ' default '  )  \"  )  ;", "assertEquals (  \" default \"  ,    expr . getValue (  )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  ?  :  ' default '  \"  )  ;", "assertEquals (  \" default \"  ,    expr . getValue (  )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  ?  :  \"  )  ;", "assertEquals ( null ,    expr . getValue (  )  )  ;", "try    {", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  (  ?  ' abc '  :  ' default '  )  \"  )  ;", "expr . getValue ( context )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . TYPE _ CONVERSION _ ERROR ,    see . getMessageCode (  )  )  ;", "}", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  ( false ?  ' abc '  : null )  \"  )  ;", "assertEquals ( null ,    expr . getValue (  )  )  ;", "try    {", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  (  =  ' default '  )  \"  )  ;", "expr . getValue ( context )  ;", "fail (  )  ;", "}    catch    ( SpelEvaluationException   see )     {", "assertEquals ( SpelMessage . SETVALUE _ NOT _ SUPPORTED ,    see . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["elvis_SPR7209_1"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  ?  :  ' default '  \"  )  ;", "assertEquals (  \" default \"  ,    expr . getValue (  )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  \\  \"  \\  \"  ?  :  \\  ' default \\  '  \"  )  ;", "assertEquals (  \" default \"  ,    expr . getValue (  )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  '  '  ?  :  ' default '  \"  )  ;", "assertEquals (  \" default \"  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["elvis_SPR7209_2"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "List < SpelReproTests . D >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new   SpelReproTests . D (  \" aaa \"  )  )  ;", "list . add ( new   SpelReproTests . D (  \" bbb \"  )  )  ;", "list . add ( new   SpelReproTests . D ( null )  )  ;", "list . add ( new   SpelReproTests . D (  \" ccc \"  )  )  ;", "list . add ( new   SpelReproTests . D ( null )  )  ;", "list . add ( new   SpelReproTests . D (  \" zzz \"  )  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( list )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "String   el 1     =     \"  # root .  ?  [ a    <     ' hhh '  ]  \"  ;", "SpelExpression   exp    =    parser . parseRaw ( el 1  )  ;", "Object   value    =    exp . getValue ( context )  ;", "assertEquals (  \"  [ D ( aaa )  ,    D ( bbb )  ,    D ( null )  ,    D ( ccc )  ,    D ( null )  ]  \"  ,    value . toString (  )  )  ;", "String   el 2     =     \"  # root .  ?  [ a    >     ' hhh '  ]  \"  ;", "SpelExpression   exp 2     =    parser . parseRaw ( el 2  )  ;", "Object   value 2     =    exp 2  . getValue ( context )  ;", "assertEquals (  \"  [ D ( zzz )  ]  \"  ,    value 2  . toString (  )  )  ;", "String   el 3     =     \"  # root .  ?  [ a !  = null ]  .  ?  [ a    <     ' hhh '  ]  \"  ;", "SpelExpression   exp 3     =    parser . parseRaw ( el 3  )  ;", "Object   value 3     =    exp 3  . getValue ( context )  ;", "assertEquals (  \"  [ D ( aaa )  ,    D ( bbb )  ,    D ( ccc )  ]  \"  ,    value 3  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["greaterThanWithNulls_SPR7840"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . Goo (  )  )  ;", "String   name    =    null ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" instance [ bar ]  \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" hello \"  ,    name )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" hello \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["indexingAsAPropertyAccess_SPR6968_1"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . Goo (  )  )  ;", "context . setVariable (  \" bar \"  ,     \" key \"  )  ;", "String   name    =    null ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" instance [  # bar ]  \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" hello \"  ,    name )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" hello \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["indexingAsAPropertyAccess_SPR6968_2"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . Goo (  )  )  ;", "context . setVariable (  \" bar \"  ,     \" wibble \"  )  ;", "String   name    =    null ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" instance [  # bar ]  \"  )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" wobble \"  ,    name )  ;", "name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" wobble \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["indexingAsAPropertyAccess_SPR6968_3"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelReproTests . Goo   g    =    SpelReproTests . Goo . instance ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( g )  ;", "context . setVariable (  \" bar \"  ,     \" wibble \"  )  ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" instance [  # bar ]  =  ' world '  \"  )  ;", "expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" world \"  ,    g . wibble )  ;", "expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" world \"  ,    g . wibble )  ;", "}", "METHOD_END"], "methodName": ["indexingAsAPropertyAccess_SPR6968_4"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelReproTests . Goo   g    =    SpelReproTests . Goo . instance ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( g )  ;", "Expression   expr    =    null ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" instance [ bar ]  =  ' world '  \"  )  ;", "expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" world \"  ,    g . value )  ;", "expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" world \"  ,    g . value )  ;", "}", "METHOD_END"], "methodName": ["indexingAsAPropertyAccess_SPR6968_5"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   LinkedHashMap <  >  (  )  ;", "map . put (  \" uri \"  ,     \" http :  \"  )  ;", "Map < String ,    String >    nameMap    =    new   LinkedHashMap <  >  (  )  ;", "nameMap . put (  \" givenName \"  ,     \" Arthur \"  )  ;", "map . put (  \" value \"  ,    nameMap )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( map )  ;", "EParser   parser    =    new   SpelEParser (  )  ;", "String   el 1     =     \"  # root [  ' value '  ]  . get (  ' givenName '  )  \"  ;", "E   exp    =    parser . parseE ( el 1  )  ;", "Object   evaluated    =    exp . getValue ( context )  ;", "assertEquals (  \" Arthur \"  ,    evaluated )  ;", "String   el 2     =     \"  # root [  ' value '  ]  [  ' givenName '  ]  \"  ;", "exp    =    parser . parseE ( el 2  )  ;", "evaluated    =    exp . getValue ( context )  ;", "assertEquals (  \" Arthur \"  ,    evaluated )  ;", "}", "METHOD_END"], "methodName": ["mapOfMap_SPR7244"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . Foo (  )  )  ;", "Expression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" resource . resource . server \"  )  ;", "String   name    =    expr . getValue ( context ,    String . class )  ;", "assertEquals (  \" abc \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["nestedProperties_SPR6923"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . C (  )  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "String   el 1     =     \" ls .  !  [  # this . equals (  ' abc '  )  ]  \"  ;", "SpelExpression   exp    =    parser . parseRaw ( el 1  )  ;", "List <  ?  >    value    =     (  ( List <  ?  >  )     ( exp . getValue ( context )  )  )  ;", "assertEquals ( Boolean . class ,    value . get (  0  )  . getClass (  )  )  ;", "TypeDescriptor   evaluated    =    exp . getValueTypeDescriptor ( context )  ;", "assertEquals ( null ,    evaluated . getElementTypeDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["projectionTypeDescriptors_1"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . C (  )  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "String   el 1     =     \" as .  !  [  # this . equals (  ' abc '  )  ]  \"  ;", "SpelExpression   exp    =    parser . parseRaw ( el 1  )  ;", "Object [  ]    value    =     (  ( Object [  ]  )     ( exp . getValue ( context )  )  )  ;", "assertEquals ( Boolean . class ,    value [  0  ]  . getClass (  )  )  ;", "TypeDescriptor   evaluated    =    exp . getValueTypeDescriptor ( context )  ;", "assertEquals ( Boolean . class ,    evaluated . getElementTypeDescriptor (  )  . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["projectionTypeDescriptors_2"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   SpelReproTests . C (  )  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "String   el 1     =     \" ms .  !  [ key . equals (  ' abc '  )  ]  \"  ;", "SpelExpression   exp    =    parser . parseRaw ( el 1  )  ;", "List <  ?  >    value    =     (  ( List <  ?  >  )     ( exp . getValue ( context )  )  )  ;", "assertEquals ( Boolean . class ,    value . get (  0  )  . getClass (  )  )  ;", "TypeDescriptor   evaluated    =    exp . getValueTypeDescriptor ( context )  ;", "assertEquals ( null ,    evaluated . getElementTypeDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["projectionTypeDescriptors_3"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "PropertyAccessor   accessor    =    new   ReflectivePropertyAccessor (  )  ;", "EvaluationContext   context    =    ScenarioCreator . getEvaluationContext (  )  ;", "assertFalse ( accessor . canRead ( context ,    null ,     \" abc \"  )  )  ;", "assertFalse ( accessor . canWrite ( context ,    null ,     \" abc \"  )  )  ;", "try    {", "accessor . read ( context ,    null ,     \" abc \"  )  ;", "fail (  \" Should   have   failed   with   an   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "try    {", "accessor . write ( context ,    null ,     \" abc \"  ,     \" foo \"  )  ;", "fail (  \" Should   have   failed   with   an   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["propertyAccessOnNullTarget_SPR5663"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionParser   expressionParser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   evaluationContext    =    new   StandardEvaluationContext ( new    . ContextObject (  )  )  ;", "evaluationContext . addPropertyAccessor ( new    . TestPropertyAccessor (  \" firstContext \"  )  )  ;", "evaluationContext . addPropertyAccessor ( new    . TestPropertyAccessor (  \" secondContext \"  )  )  ;", "evaluationContext . addPropertyAccessor ( new    . TestPropertyAccessor (  \" thirdContext \"  )  )  ;", "evaluationContext . addPropertyAccessor ( new    . TestPropertyAccessor (  \" fourthContext \"  )  )  ;", "assertEquals (  \" first \"  ,    expressionParser . parseExpression (  \" shouldBeFirst \"  )  . getValue ( evaluationContext )  )  ;", "assertEquals (  \" second \"  ,    expressionParser . parseExpression (  \" shouldBeSecond \"  )  . getValue ( evaluationContext )  )  ;", "assertEquals (  \" third \"  ,    expressionParser . parseExpression (  \" shouldBeThird \"  )  . getValue ( evaluationContext )  )  ;", "assertEquals (  \" fourth \"  ,    expressionParser . parseExpression (  \" shouldBeFourth \"  )  . getValue ( evaluationContext )  )  ;", "}", "METHOD_END"], "methodName": ["propertyAccessorOrder_SPR8211"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression   expression    =    parser . parseRaw (  \" T ( testresources . le . div . mod . reserved . Reserver )  . CONST \"  )  ;", "Object   value    =    expression . getValue ( context )  ;", "assertEquals ( value ,    Reserver . CONST )  ;", "}", "METHOD_END"], "methodName": ["reservedWordProperties_SPR9862"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   Reserver    {", "public   Reserver   getReserver (  )     {", "return   this ;", "}", "public   String   NE    =     \" abc \"  ;", "public   String   ne    =     \" def \"  ;", "public   int   DIV    =     1  ;", "public   int   div    =     3  ;", "public   Map < String ,    String >    m    =    new   HashMap <  >  (  )  ;", "Reserver (  )     {", "m . put (  \" NE \"  ,     \" xyz \"  )  ;", "}", "}", "StandardEvaluationContext   context    =    new   StandardEvaluationContext ( new   Reserver (  )  )  ;", "SpelEParser   parser    =    new   SpelEParser (  )  ;", "String   ex    =     \" getReserver (  )  . NE \"  ;", "SpelE   exp    =    parser . parseRaw ( ex )  ;", "String   value    =     (  ( String )     ( exp . getValue ( context )  )  )  ;", "assertEquals (  \" abc \"  ,    value )  ;", "ex    =     \" getReserver (  )  . ne \"  ;", "exp    =    parser . parseRaw ( ex )  ;", "value    =     (  ( String )     ( exp . getValue ( context )  )  )  ;", "assertEquals (  \" def \"  ,    value )  ;", "ex    =     \" getReserver (  )  . m [ NE ]  \"  ;", "exp    =    parser . parseRaw ( ex )  ;", "value    =     (  ( String )     ( exp . getValue ( context )  )  )  ;", "assertEquals (  \" xyz \"  ,    value )  ;", "ex    =     \" getReserver (  )  . DIV \"  ;", "exp    =    parser . parseRaw ( ex )  ;", "assertEquals (  1  ,    exp . getValue ( context )  )  ;", "ex    =     \" getReserver (  )  . div \"  ;", "exp    =    parser . parseRaw ( ex )  ;", "assertEquals (  3  ,    exp . getValue ( context )  )  ;", "exp    =    parser . parseRaw (  \" NE \"  )  ;", "assertEquals (  \" abc \"  ,    exp . getValue ( context )  )  ;", "}", "METHOD_END"], "methodName": ["reservedWords_SPR8228"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   expressionParser    =    new   SpelExpressionParser ( new   SpelParserConfiguration ( SpelCompilerMode . IMMEDIATE ,    null )  )  ;", "Expression   expression    =    expressionParser . parseExpression (  \"  # target . process (  # root )  \"  )  ;", ". VarargsReceiver   receiver    =    new    . VarargsReceiver (  )  ;", ". VarargsInterface   proxy    =     (  (  . VarargsInterface )     ( Proxy . newProxyInstance ( getClass (  )  . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {     . VarargsInterface . class    }  ,     (    proxy 1  ,    method ,    args )     -  >    method . invoke ( receiver ,    args )  )  )  )  ;", "StandardEvaluationContext   evaluationContext    =    new   StandardEvaluationContext (  )  ;", "evaluationContext . setVariable (  \" target \"  ,    proxy )  ;", "String   result    =    expression . getValue ( evaluationContext ,     \" foo \"  ,    String . class )  ;", "result    =    expression . getValue ( evaluationContext ,     \" foo \"  ,    String . class )  ;", "assertEquals (  \" OK \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testCompiledExpressionForProxy_SPR16191"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \" process (  ' a '  ,     ' b '  )  \"  )  ;", ". VarargsReceiver   receiver    =    new    . VarargsReceiver (  )  ;", ". VarargsInterface   proxy    =     (  (  . VarargsInterface )     ( Proxy . newProxyInstance ( getClass (  )  . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {     . VarargsInterface . class    }  ,     (    proxy 1  ,    method ,    args )     -  >    method . invoke ( receiver ,    args )  )  )  )  ;", "assertEquals (  \" OK \"  ,    expr . getValue ( new   StandardEvaluationContext ( receiver )  )  )  ;", "assertEquals (  \" OK \"  ,    expr . getValue ( new   StandardEvaluationContext ( proxy )  )  )  ;", "}", "METHOD_END"], "methodName": ["varargsAgainstProxy_SPR16122"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   emptyEvalContext    =    new   StandardEvaluationContext (  )  ;", "List < TypeDescriptor >    args    =    new   ArrayList <  >  (  )  ;", "args . add ( TypeDescriptor . forObject (  3  4 L )  )  ;", ". ReflectionUtil < Integer >    ru    =    new    . ReflectionUtil <  >  (  )  ;", "MethodExecutor   me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" methodToCall \"  ,    args )  ;", "args . set (  0  ,    TypeDescriptor . forObject (  2  3  )  )  ;", "me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" foo \"  ,    args )  ;", "me . execute ( emptyEvalContext ,    ru ,     4  5  )  ;", "args . set (  0  ,    TypeDescriptor . forObject (  2  3  .  0 F )  )  ;", "me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" foo \"  ,    args )  ;", "me . execute ( emptyEvalContext ,    ru ,     4  5  .  0 F )  ;", "args . set (  0  ,    TypeDescriptor . forObject (  2  3  .  0  )  )  ;", "me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" foo \"  ,    args )  ;", "me . execute ( emptyEvalContext ,    ru ,     2  3  .  0  )  ;", "args . set (  0  ,    TypeDescriptor . forObject (  (  ( short )     (  2  3  )  )  )  )  ;", "me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" foo \"  ,    args )  ;", "me . execute ( emptyEvalContext ,    ru ,     (  ( short )     (  2  3  )  )  )  ;", "args . set (  0  ,    TypeDescriptor . forObject (  2  3 L )  )  ;", "me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" foo \"  ,    args )  ;", "me . execute ( emptyEvalContext ,    ru ,     2  3 L )  ;", "args . set (  0  ,    TypeDescriptor . forObject (  (  ( char )     (  6  5  )  )  )  )  ;", "me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" foo \"  ,    args )  ;", "me . execute ( emptyEvalContext ,    ru ,     (  ( char )     (  6  5  )  )  )  ;", "args . set (  0  ,    TypeDescriptor . forObject (  (  ( byte )     (  2  3  )  )  )  )  ;", "me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" foo \"  ,    args )  ;", "me . execute ( emptyEvalContext ,    ru ,     (  ( byte )     (  2  3  )  )  )  ;", "args . set (  0  ,    TypeDescriptor . forObject ( true )  )  ;", "me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" foo \"  ,    args )  ;", "me . execute ( emptyEvalContext ,    ru ,    true )  ;", "args . set (  0  ,    TypeDescriptor . forObject (  1  2  )  )  ;", "args . add ( TypeDescriptor . forObject (  2  3  .  0 F )  )  ;", "me    =    new   ReflectiveMethodResolver (  )  . resolve ( emptyEvalContext ,    ru ,     \" bar \"  ,    args )  ;", "me . execute ( emptyEvalContext ,    ru ,     1  2  ,     2  3  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["varargsAndPrimitives_SPR8174"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "class   WideningPrimitiveConversion    {", "public   int   getX ( long   i )     {", "return    1  0  ;", "}", "}", "final   Integer   INTEGER _ VALUE    =    Integer . valueOf (  7  )  ;", "WideningPrimitiveConversion   target    =    new   WideningPrimitiveConversion (  )  ;", "EvaluationContext   emptyEvalContext    =    new   StandardEvaluationContext (  )  ;", "List < TypeDescriptor >    args    =    new   ArrayList <  >  (  )  ;", "args . add ( TypeDescriptor . forObject ( INTEGER _ VALUE )  )  ;", "MethodExecutor   me    =    new   ReflectiveMethodResolver ( true )  . resolve ( emptyEvalContext ,    target ,     \" getX \"  ,    args )  ;", "final   int   actual    =     (  ( Integer )     ( me . execute ( emptyEvalContext ,    target ,    INTEGER _ VALUE )  . getValue (  )  )  )  ;", "final   int   compiler    =    target . getX ( INTEGER _ VALUE )  ;", "assertEquals ( compiler ,    actual )  ;", "}", "METHOD_END"], "methodName": ["wideningPrimitiveConversion_SPR8224"], "fileName": "org.springframework.expression.spel.SpelReproTests"}, {"methodBody": ["METHOD_START", "{", "if    ( t    !  =    null )     {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append ( indent )  . append ( t . getClass (  )  . getSimpleName (  )  )  ;", "sb . append (  \"       value :  \"  )  . append ( t . toStringAST (  )  )  ;", "sb . append (  (  ( t . getChildCount (  )  )     <     2     ?     \"  \"     :     \"        # children :  \"     +     ( t . getChildCount (  )  )  )  )  ;", "out . println ( sb . toString (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( t . getChildCount (  )  )  ;    i +  +  )     {", ". printAST ( out ,    t . getChild ( i )  ,     ( indent    +     \"        \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["printAST"], "fileName": "org.springframework.expression.spel.SpelUtilities"}, {"methodBody": ["METHOD_START", "{", "printStream . println (  (  (  \"  =  =  =  >    Expression    '  \"     +     ( expression . getExpressionString (  )  )  )     +     \"  '     -    AST   start \"  )  )  ;", ". printAST ( printStream ,     (  ( SpelExpression )     ( expression )  )  . getAST (  )  ,     \"  \"  )  ;", "printStream . println (  (  (  \"  =  =  =  >    Expression    '  \"     +     ( expression . getExpressionString (  )  )  )     +     \"  '     -    AST   end \"  )  )  ;", "}", "METHOD_END"], "methodName": ["printAbstractSyntaxTree"], "fileName": "org.springframework.expression.spel.SpelUtilities"}, {"methodBody": ["METHOD_START", "{", "StandardTypeLocator   locator    =    new   StandardTypeLocator (  )  ;", "assertEquals ( Integer . class ,    locator . findType (  \" Integer \"  )  )  ;", "assertEquals ( String . class ,    locator . findType (  \" String \"  )  )  ;", "List < String >    prefixes    =    locator . getImportPrefixes (  )  ;", "assertEquals (  1  ,    prefixes . size (  )  )  ;", "assertTrue ( prefixes . contains (  \" lang \"  )  )  ;", "assertFalse ( prefixes . contains (  \" util \"  )  )  ;", "assertEquals ( Boolean . class ,    locator . findType (  \" Boolean \"  )  )  ;", "try    {", "locator . findType (  \" URL \"  )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( EvaluationException   ee )     {", "SpelEvaluationException   sEx    =     (  ( SpelEvaluationException )     ( ee )  )  ;", "assertEquals ( SpelMessage . TYPE _ NOT _ FOUND ,    sEx . getMessageCode (  )  )  ;", "}", "locator . registerImport (  \" net \"  )  ;", "assertEquals ( URL . class ,    locator . findType (  \" URL \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testImports"], "fileName": "org.springframework.expression.spel.StandardTypeLocatorTests"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( value   instanceof   String )  )     {", "fail (  (  (  (  (  \" Result   was   not   a   string ,    it   was   of   type    \"     +     ( value . getClass (  )  )  )     +     \"        ( value =  \"  )     +    value )     +     \"  )  \"  )  )  ;", "}", "if    (  !  ( value . equals ( expectedString )  )  )     {", "fail (  (  (  (  (  \" Did   not   get   expected   result .       Should   have   been    '  \"     +    expectedString )     +     \"  '    but   was    '  \"  )     +    value )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkString"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "Expression   ex    =    parser . parseExpression (  \" hello    $  {  3  +  4  }    world \"  ,    TemplateExpressionParsingTests . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "String   s    =    ex . getValue ( TestScenarioCreator . getTestEvaluationContext (  )  ,    String . class )  ;", "assertEquals (  \" hello    7    world \"  ,    s )  ;", "ex    =    parser . parseExpression (  \" hello    $  {  3  +  4  }    wo $  {  '  $  {  '  } rld \"  ,    TemplateExpressionParsingTests . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "s    =    ex . getValue ( TestScenarioCreator . getTestEvaluationContext (  )  ,    String . class )  ;", "assertEquals (  \" hello    7    wo $  { rld \"  ,    s )  ;", "ex    =    parser . parseExpression (  \" hello    $  {  3  +  4  }    wo } rld \"  ,    TemplateExpressionParsingTests . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "s    =    ex . getValue ( TestScenarioCreator . getTestEvaluationContext (  )  ,    String . class )  ;", "assertEquals (  \" hello    7    wo } rld \"  ,    s )  ;", "}", "METHOD_END"], "methodName": ["testClashingWithSuffixes"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   ex    =    parser . parseExpression (  \" hello    $  {  ' world '  }  \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "checkString (  \" hello   world \"  ,    ex . getValue (  )  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue ( String . class )  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue (  (  ( Object )     ( null )  )  ,    String . class )  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue ( new    . Rooty (  )  )  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue ( new    . Rooty (  )  ,    String . class )  )  ;", "EvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue ( ctx )  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue ( ctx ,    String . class )  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue ( ctx ,    null ,    String . class )  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue ( ctx ,    new    . Rooty (  )  )  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue ( ctx ,    new    . Rooty (  )  ,    String . class )  )  ;", "checkString (  \" hello   world \"  ,    ex . getValue ( ctx ,    new    . Rooty (  )  ,    String . class )  )  ;", "assertEquals (  \" hello    $  {  ' world '  }  \"  ,    ex . getExpressionString (  )  )  ;", "assertFalse ( ex . isWritable ( new   StandardEvaluationContext (  )  )  )  ;", "assertFalse ( ex . isWritable ( new    . Rooty (  )  )  )  ;", "assertFalse ( ex . isWritable ( new   StandardEvaluationContext (  )  ,    new    . Rooty (  )  )  )  ;", "assertEquals ( String . class ,    ex . getValueType (  )  )  ;", "assertEquals ( String . class ,    ex . getValueType ( ctx )  )  ;", "assertEquals ( String . class ,    ex . getValueTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( String . class ,    ex . getValueTypeDescriptor ( ctx )  . getType (  )  )  ;", "assertEquals ( String . class ,    ex . getValueType ( new    . Rooty (  )  )  )  ;", "assertEquals ( String . class ,    ex . getValueType ( ctx ,    new    . Rooty (  )  )  )  ;", "assertEquals ( String . class ,    ex . getValueTypeDescriptor ( new    . Rooty (  )  )  . getType (  )  )  ;", "assertEquals ( String . class ,    ex . getValueTypeDescriptor ( ctx ,    new    . Rooty (  )  )  . getType (  )  )  ;", "try    {", "ex . setValue ( ctx ,    null )  ;", "fail (  )  ;", "}    catch    ( EvaluationException   ee )     {", "}", "try    {", "ex . setValue (  (  ( Object )     ( null )  )  ,    null )  ;", "fail (  )  ;", "}    catch    ( EvaluationException   ee )     {", "}", "try    {", "ex . setValue ( ctx ,    null ,    null )  ;", "fail (  )  ;", "}    catch    ( EvaluationException   ee )     {", "}", "}", "METHOD_END"], "methodName": ["testCompositeStringExpression"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "parser . parseExpression (  \" hello    $  {  ' world '  \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( ParseException   pe )     {", "assertEquals (  \" No   ending   suffix    '  }  '    for   expression   starting   at   character    6  :     $  {  ' world '  \"  ,    pe . getSimpleMessage (  )  )  ;", "assertEquals (  \" hello    $  {  ' world '  \"  ,    pe . getExpressionString (  )  )  ;", "}", "try    {", "parser . parseExpression (  \" hello    $  {  ' wibble '  $  {  ' world '  }  \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( ParseException   pe )     {", "assertEquals (  \" No   ending   suffix    '  }  '    for   expression   starting   at   character    6  :     $  {  ' wibble '  $  {  ' world '  }  \"  ,    pe . getSimpleMessage (  )  )  ;", "}", "try    {", "parser . parseExpression (  \" hello    $  {  }    world \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( ParseException   pe )     {", "assertEquals (  \" No   expression   defined   within   delimiter    '  $  {  }  '    at   character    6  \"  ,    pe . getSimpleMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testErrorCases"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   ex    =    parser . parseExpression (  \" hello    $  { listOfNumbersUpToTen .  $  [  # this <  5  ]  }    world \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "String   s    =    ex . getValue ( TestScenarioCreator . getTestEvaluationContext (  )  ,    String . class )  ;", "assertEquals (  \" hello    4    world \"  ,    s )  ;", "ex    =    parser . parseExpression (  \" hello    $  { listOfNumbersUpToTen .  $  [  # root . listOfNumbersUpToTen .  $  [  # this %  2  =  =  1  ]  =  =  3  ]  }    world \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "assertEquals ( CompositeStringExpression . class ,    ex . getClass (  )  )  ;", "CompositeStringExpression   cse    =     (  ( CompositeStringExpression )     ( ex )  )  ;", "Expression [  ]    exprs    =    cse . getExpressions (  )  ;", "assertEquals (  3  ,    exprs . length )  ;", "assertEquals (  \" listOfNumbersUpToTen .  $  [  # root . listOfNumbersUpToTen .  $  [  # this %  2  =  =  1  ]  =  =  3  ]  \"  ,    exprs [  1  ]  . getExpressionString (  )  )  ;", "s    =    ex . getValue ( TestScenarioCreator . getTestEvaluationContext (  )  ,    String . class )  ;", "assertEquals (  \" hello      world \"  ,    s )  ;", "ex    =    parser . parseExpression (  \" hello    $  { listOfNumbersUpToTen .  $  [  # this <  5  ]  }     $  { listOfNumbersUpToTen .  $  [  # this >  5  ]  }    world \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "s    =    ex . getValue ( TestScenarioCreator . getTestEvaluationContext (  )  ,    String . class )  ;", "assertEquals (  \" hello    4     1  0    world \"  ,    s )  ;", "try    {", "ex    =    parser . parseExpression (  \" hello    $  { listOfNumbersUpToTen .  $  [  # this <  5  ]  }     $  { listOfNumbersUpToTen .  $  [  # this >  5  ]    world \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( ParseException   pe )     {", "assertEquals (  \" No   ending   suffix    '  }  '    for   expression   starting   at   character    4  1  :     $  { listOfNumbersUpToTen .  $  [  # this >  5  ]    world \"  ,    pe . getSimpleMessage (  )  )  ;", "}", "try    {", "ex    =    parser . parseExpression (  \" hello    $  { listOfNumbersUpToTen .  $  [  # root . listOfNumbersUpToTen .  $  [  # this %  2  =  =  1  =  =  3  ]  }    world \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( ParseException   pe )     {", "assertEquals (  \" Found   closing    '  }  '    at   position    7  4    but   most   recent   opening   is    '  [  '    at   position    3  0  \"  ,    pe . getSimpleMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNestedExpressions"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "Expression   expr    =    parser . parseExpression (  \"  1  +  2  +  3  \"  )  ;", "assertEquals (  6  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParsingNormalExpressionThroughTemplateParser"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \" hello    $  {  ' world '  }  \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "Object   o    =    expr . getValue (  )  ;", "assertEquals (  \" hello   world \"  ,    o . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParsingSimpleTemplateExpression01"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \" hello    $  {  ' to '  }    you \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "Object   o    =    expr . getValue (  )  ;", "assertEquals (  \" hello   to   you \"  ,    o . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParsingSimpleTemplateExpression02"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \" The   quick    $  {  ' brown '  }    fox   jumped   over   the    $  {  ' lazy '  }    dog \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "Object   o    =    expr . getValue (  )  ;", "assertEquals (  \" The   quick   brown   fox   jumped   over   the   lazy   dog \"  ,    o . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParsingSimpleTemplateExpression03"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "Expression   expr    =    parser . parseExpression (  \"  $  {  ' hello '  }    world \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "Object   o    =    expr . getValue (  )  ;", "assertEquals (  \" hello   world \"  ,    o . toString (  )  )  ;", "expr    =    parser . parseExpression (  \"  \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "o    =    expr . getValue (  )  ;", "assertEquals (  \"  \"  ,    o . toString (  )  )  ;", "expr    =    parser . parseExpression (  \" abc \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "o    =    expr . getValue (  )  ;", "assertEquals (  \" abc \"  ,    o . toString (  )  )  ;", "expr    =    parser . parseExpression (  \" abc \"  ,     . DEFAULT _ TEMPLATE _ PARSER _ CONTEXT )  ;", "o    =    expr . getValue (  (  ( Object )     ( null )  )  )  ;", "assertEquals (  \" abc \"  ,    o . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParsingSimpleTemplateExpression04"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "TemplateParserContext   tpc    =    new   TemplateParserContext (  \" abc \"  ,     \" def \"  )  ;", "assertEquals (  \" abc \"  ,    tpc . getrefix (  )  )  ;", "assertEquals (  \" def \"  ,    tpc . getExpressionSuffix (  )  )  ;", "assertTrue ( tpc . isTemplate (  )  )  ;", "tpc    =    new   TemplateParserContext (  )  ;", "assertEquals (  \"  #  {  \"  ,    tpc . getrefix (  )  )  ;", "assertEquals (  \"  }  \"  ,    tpc . getExpressionSuffix (  )  )  ;", "assertTrue ( tpc . isTemplate (  )  )  ;", "ParserContext   pc    =    ParserContext . TEMPLATE _ EXPRESSION ;", "assertEquals (  \"  #  {  \"  ,    pc . getrefix (  )  )  ;", "assertEquals (  \"  }  \"  ,    pc . getExpressionSuffix (  )  )  ;", "assertTrue ( pc . isTemplate (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTemplateParserContext"], "fileName": "org.springframework.expression.spel.TemplateExpressionParsingTests"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   testContext    =    new   StandardEvaluationContext (  )  ;", ". setupRootContextObject ( testContext )  ;", ". populateVariables ( testContext )  ;", ". populateFunctions ( testContext )  ;", "return   testContext ;", "}", "METHOD_END"], "methodName": ["getTestEvaluationContext"], "fileName": "org.springframework.expression.spel.TestScenarioCreator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( i    %     2  )     =  =     0  )     {", "turn    \" y \"  ;", "}", "turn    \" n \"  ;", "}", "METHOD_END"], "methodName": ["isEven"], "fileName": "org.springframework.expression.spel.TestScenarioCreator"}, {"methodBody": ["METHOD_START", "{", "try    {", "testContext . registerFunction (  \" isEven \"  ,     . class . getDeclaredMethod (  \" isEven \"  ,    Integer . TYPE )  )  ;", "testContext . registerFunction (  \" reverseInt \"  ,     . class . getDeclaredMethod (  \" reverseInt \"  ,    Integer . TYPE ,    Integer . TYPE ,    Integer . TYPE )  )  ;", "testContext . registerFunction (  \" reverseString \"  ,     . class . getDeclaredMethod (  \" reverseString \"  ,    String . class )  )  ;", "testContext . registerFunction (  \" varargsFunctionReverseStringsAndMerge \"  ,     . class . getDeclaredMethod (  \" varargsFunctionReverseStringsAndMerge \"  ,    String [  ]  . class )  )  ;", "testContext . registerFunction (  \" varargsFunctionReverseStringsAndMerge 2  \"  ,     . class . getDeclaredMethod (  \" varargsFunctionReverseStringsAndMerge 2  \"  ,    Integer . TYPE ,    String [  ]  . class )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["populateFunctions"], "fileName": "org.springframework.expression.spel.TestScenarioCreator"}, {"methodBody": ["METHOD_START", "{", "testContext . setVariable (  \" answer \"  ,     4  2  )  ;", "}", "METHOD_END"], "methodName": ["populateVariables"], "fileName": "org.springframework.expression.spel.TestScenarioCreator"}, {"methodBody": ["METHOD_START", "{", "return   new   int [  ]  {    k ,    j ,    i    }  ;", "}", "METHOD_END"], "methodName": ["reverseInt"], "fileName": "org.springframework.expression.spel.TestScenarioCreator"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   backwards    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( input . length (  )  )  ;    i +  +  )     {", "backwards . append ( input . charAt (  (  (  ( input . length (  )  )     -     1  )     -    i )  )  )  ;", "}", "return   backwards . toString (  )  ;", "}", "METHOD_END"], "methodName": ["reverseString"], "fileName": "org.springframework.expression.spel.TestScenarioCreator"}, {"methodBody": ["METHOD_START", "{", "GregorianCalendar   c    =    new   GregorianCalendar (  )  ;", "c . set (  1  8  5  6  ,     7  ,     9  )  ;", "Inventor   tesla    =    new   Inventor (  \" Nikola   Tesla \"  ,    c . getTime (  )  ,     \" Serbian \"  )  ;", "tesla . setPlaceOfBirth ( new   PlaceOfBirth (  \" SmilJan \"  )  )  ;", "tesla . setInventions ( new   String [  ]  {     \" Telephone   repeater \"  ,     \" Rotating   magnetic   field   principle \"  ,     \" Polyphase   alternating - current   system \"  ,     \" Induction   motor \"  ,     \" Alternating - current   power   transmi \"  ,     \" Tesla   coil   transformer \"  ,     \" Wireless   communication \"  ,     \" Radio \"  ,     \" Fluorescent   lights \"     }  )  ;", "testContext . setRootObject ( tesla )  ;", "}", "METHOD_END"], "methodName": ["setupRootContextObject"], "fileName": "org.springframework.expression.spel.TestScenarioCreator"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "if    ( strings    !  =    null )     {", "for    ( int   i    =     ( strings . length )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "sb . append ( strings [ i ]  )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["varargsFunctionReverseStringsAndMerge"], "fileName": "org.springframework.expression.spel.TestScenarioCreator"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append ( j )  ;", "if    ( strings    !  =    null )     {", "for    ( int   i    =     ( strings . length )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "sb . append ( strings [ i ]  )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["varargsFunctionReverseStringsAndMerge2"], "fileName": "org.springframework.expression.spel.TestScenarioCreator"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge (  ' a '  ,  ' b '  ,  ' c '  )  \"  ,     \" cba \"  ,    String . class )  ;", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge (  ' a '  )  \"  ,     \" a \"  ,    String . class )  ;", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge (  )  \"  ,     \"  \"  ,    String . class )  ;", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge (  ' b '  ,  2  5  )  \"  ,     \"  2  5 b \"  ,    String . class )  ;", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge (  2  5  )  \"  ,     \"  2  5  \"  ,    String . class )  ;", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge 2  (  1  ,  ' a '  ,  ' b '  ,  ' c '  )  \"  ,     \"  1 cba \"  ,    String . class )  ;", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge 2  (  2  ,  ' a '  )  \"  ,     \"  2 a \"  ,    String . class )  ;", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge 2  (  3  )  \"  ,     \"  3  \"  ,    String . class )  ;", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge 2  (  4  ,  ' b '  ,  2  5  )  \"  ,     \"  4  2  5 b \"  ,    String . class )  ;", "evaluate (  \"  # varargsFunctionReverseStringsAndMerge 2  (  5  ,  2  5  )  \"  ,     \"  5  2  5  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testCallVarargsFunction"], "fileName": "org.springframework.expression.spel.VariableAndFunctionTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "StandardEvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "ctx . setVariable (  \" notStatic \"  ,    this . getClass (  )  . getMethod (  \" nonStatic \"  )  )  ;", "try    {", "@ SuppressWarnings (  \" unused \"  )", "Object   v    =    parser . parseRaw (  \"  # notStatic (  )  \"  )  . getValue ( ctx )  ;", "fail (  \" Should   have   failed   with   exception    -    cannot   call   non   static   method   that   way \"  )  ;", "}    catch    ( SpelEvaluationException   se )     {", "if    (  ( se . getMessageCode (  )  )     !  =     ( SpelMessage . FUNCTION _ MUST _ BE _ STATIC )  )     {", "se . printStackTrace (  )  ;", "fail (  (  \" Should   have   failed   a   message   about   the   function   needing   to   be   static ,    not :     \"     +     ( se . getMessageCode (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testCallingIllegalFunctions"], "fileName": "org.springframework.expression.spel.VariableAndFunctionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # reverseInt (  1  ,  2  ,  3  )  \"  ,     \" int [  3  ]  {  3  ,  2  ,  1  }  \"  ,    int [  ]  . class )  ;", "evaluate (  \"  # reverseInt (  '  1  '  ,  2  ,  3  )  \"  ,     \" int [  3  ]  {  3  ,  2  ,  1  }  \"  ,    int [  ]  . class )  ;", "evaluatCheckError (  \"  # reverseInt (  1  )  \"  ,    SpelMessage . INCORRECT _ NUMBER _ OF _ ARGUMENTS _ TO _ FUNCTION ,     0  ,     1  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testFunctionAccess01"], "fileName": "org.springframework.expression.spel.VariableAndFunctionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # reverseString (  ' hello '  )  \"  ,     \" olleh \"  ,    String . class )  ;", "evaluate (  \"  # reverseString (  3  7  )  \"  ,     \"  7  3  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testFunctionAccess02"], "fileName": "org.springframework.expression.spel.VariableAndFunctionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # answer \"  ,     \"  4  2  \"  ,    Integer . class ,    AbstractExpressionTests . SHOULD _ BE _ WRITABLE )  ;", "evaluate (  \"  # answer    /     2  \"  ,     2  1  ,    Integer . class ,    AbstractExpressionTests . SHOULD _ NOT _ BE _ WRITABLE )  ;", "}", "METHOD_END"], "methodName": ["testVariableAccess01"], "fileName": "org.springframework.expression.spel.VariableAndFunctionTests"}, {"methodBody": ["METHOD_START", "{", "evaluate (  \"  # this . getName (  )  \"  ,     \" Nikola   Tesla \"  ,    String . class )  ;", "evaluate (  \"  # root . getName (  )  \"  ,     \" Nikola   Tesla \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["testVariableAccess_WellKnownVariables"], "fileName": "org.springframework.expression.spel.VariableAndFunctionTests"}, {"methodBody": ["METHOD_START", "{", "List < PropertyAccessor >    specificAccessors    =    new   ArrayList <  >  (  )  ;", "List < PropertyAccessor >    generalAccessors    =    new   ArrayList <  >  (  )  ;", "for    ( PropertyAccessor   resolver    :    propertyAccessors )     {", "Class <  ?  >  [  ]    targets    =    resolver . getSpecificTargetClasses (  )  ;", "if    ( targets    =  =    null )     {", "generalAccessors . add ( resolver )  ;", "} else    {", "if    ( targetType    !  =    null )     {", "int   pos    =     0  ;", "for    ( Class <  ?  >    clazz    :    targets )     {", "if    ( clazz    =  =    targetType )     {", "specificAccessors . add (  ( pos +  +  )  ,    resolver )  ;", "} else", "if    ( clazz . isAssignableFrom ( targetType )  )     {", "generalAccessors . add ( resolver )  ;", "}", "}", "}", "}", "}", "List < PropertyAccessor >    resolvers    =    new   LinkedList <  >  (  )  ;", "resolvers . addAll ( specificAccessors )  ;", "resolvers . addAll ( generalAccessors )  ;", "return   resolvers ;", "}", "METHOD_END"], "methodName": ["getPropertyAccessorsToTry"], "fileName": "org.springframework.expression.spel.ast.AstUtils"}, {"methodBody": ["METHOD_START", "{", "Object   intendedArrayType    =    getChild (  0  )  . getValue ( state )  ;", "if    (  !  ( intendedArrayType   instanceof   String )  )     {", "throw   new   SpelEvaluationException ( getChild (  0  )  . getStartPosition (  )  ,    SpelMessage . TYPE _ NAME _ EXPECTED _ FOR _ ARRAY _ CONSTRUCTION ,    FormatHelper . formatClassNameForMessage (  ( intendedArrayType    !  =    null    ?    intendedArrayType . getClass (  )     :    null )  )  )  ;", "}", "String   type    =     (  ( String )     ( intendedArrayType )  )  ;", "Class <  ?  >    componentType ;", "TypeCode   arrayTypeCode    =    TypeCode . forName ( type )  ;", "if    ( arrayTypeCode    =  =     ( TypeCode . OBJECT )  )     {", "componentType    =    state . findType ( type )  ;", "} else    {", "componentType    =    arrayTypeCode . getType (  )  ;", "}", "Object   newArray ;", "if    (  !  ( hasInitializer (  )  )  )     {", "if    (  ( this . dimensions )     !  =    null )     {", "for    ( SpelNodeImpl   dimension    :    this . dimensions )     {", "if    ( dimension    =  =    null )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . MISSING _ ARRAY _ DIMENSION )  ;", "}", "}", "}", "TypeConverter   typeConverter    =    state . getEvaluationContext (  )  . getTypeConverter (  )  ;", "if    (  ( this . dimensions . length )     =  =     1  )     {", "TypedValue   o    =    this . dimensions [  0  ]  . getTypedValue ( state )  ;", "int   arraySize    =    EUtils . toInt ( typeConverter ,    o )  ;", "newArray    =    Array . newInstance ( componentType ,    arraySize )  ;", "} else    {", "int [  ]    dims    =    new   int [ this . dimensions . length ]  ;", "for    ( int   d    =     0  ;    d    <     ( this . dimensions . length )  ;    d +  +  )     {", "TypedValue   o    =    this . dimensions [ d ]  . getTypedValue ( state )  ;", "dims [ d ]     =    EUtils . toInt ( typeConverter ,    o )  ;", "}", "newArray    =    Array . newInstance ( componentType ,    dims )  ;", "}", "} else    {", "if    (  (  ( this . dimensions )     =  =    null )     |  |     (  ( this . dimensions . length )     >     1  )  )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . MULTIDIM _ ARRAY _ INITIALIZER _ NOT _ SUPPORTED )  ;", "}", "TypeConverter   typeConverter    =    state . getEvaluationContext (  )  . getTypeConverter (  )  ;", "InlineList   initializer    =     (  ( InlineList )     ( getChild (  1  )  )  )  ;", "if    (  ( this . dimensions [  0  ]  )     !  =    null )     {", "TypedValue   dValue    =    this . dimensions [  0  ]  . getTypedValue ( state )  ;", "int   i    =    EUtils . toInt ( typeConverter ,    dValue )  ;", "if    ( i    !  =     ( initializer . getChildCount (  )  )  )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . INITIALIZER _ LENGTH _ INCORRECT )  ;", "}", "}", "int   arraySize    =    initializer . getChildCount (  )  ;", "newArray    =    Array . newInstance ( componentType ,    arraySize )  ;", "if    ( arrayTypeCode    =  =     ( TypeCode . OBJECT )  )     {", "populateReferenceTypeArray ( state ,    newArray ,    typeConverter ,    initializer ,    componentType )  ;", "} else", "if    ( arrayTypeCode    =  =     ( TypeCode . BOOLEAN )  )     {", "populateBooleanArray ( state ,    newArray ,    typeConverter ,    initializer )  ;", "} else", "if    ( arrayTypeCode    =  =     ( TypeCode . BYTE )  )     {", "populateByteArray ( state ,    newArray ,    typeConverter ,    initializer )  ;", "} else", "if    ( arrayTypeCode    =  =     ( TypeCode . CHAR )  )     {", "populateCharArray ( state ,    newArray ,    typeConverter ,    initializer )  ;", "} else", "if    ( arrayTypeCode    =  =     ( TypeCode . DOUBLE )  )     {", "populateDoubleArray ( state ,    newArray ,    typeConverter ,    initializer )  ;", "} else", "if    ( arrayTypeCode    =  =     ( TypeCode . FLOAT )  )     {", "populateFloatArray ( state ,    newArray ,    typeConverter ,    initializer )  ;", "} else", "if    ( arrayTypeCode    =  =     ( TypeCode . INT )  )     {", "populateIntArray ( state ,    newArray ,    typeConverter ,    initializer )  ;", "} else", "if    ( arrayTypeCode    =  =     ( TypeCode . LONG )  )     {", "populateLongArray ( state ,    newArray ,    typeConverter ,    initializer )  ;", "} else", "if    ( arrayTypeCode    =  =     ( TypeCode . SHORT )  )     {", "populateShortArray ( state ,    newArray ,    typeConverter ,    initializer )  ;", "} else    {", "throw   new   IllegalStateException ( arrayTypeCode . name (  )  )  ;", "}", "}", "return   new   TypedValue ( newArray )  ;", "}", "METHOD_END"], "methodName": ["createArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    arguments    =    new   Object [  ( getChildCount (  )  )     -     1  ]  ;", "List < TypeDescriptor >    argumentTypes    =    new   ArrayList <  >  (  (  ( getChildCount (  )  )     -     1  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( arguments . length )  ;    i +  +  )     {", "TypedValue   childValue    =    this . children [  ( i    +     1  )  ]  . getValueInternal ( state )  ;", "Object   value    =    childValue . getValue (  )  ;", "arguments [ i ]     =    value ;", "argumentTypes . add ( TypeDescriptor . forObject ( value )  )  ;", "}", "Executor   executorToUse    =    this . cachedExecutor ;", "if    ( executorToUse    !  =    null )     {", "try    {", "return   executorToUse . execute ( state . getEvaluationContext (  )  ,    arguments )  ;", "}    catch    ( AccessException   ex )     {", "if    (  ( ex . getCause (  )  )    instanceof   InvocationTargetException )     {", "Throwable   rootCause    =    ex . getCause (  )  . getCause (  )  ;", "if    ( rootCause   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( rootCause )  )  ;", "} else    {", "String   typeName    =     (  ( String )     ( this . children [  0  ]  . getValueInternal ( state )  . getValue (  )  )  )  ;", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    rootCause ,    SpelMessage . CONSTRUCTOR _ INVOCATION _ PROBLEM ,    typeName ,    FormatHelper . formatMethodForMessage (  \"  \"  ,    argumentTypes )  )  ;", "}", "}", "this . cachedExecutor    =    null ;", "}", "}", "String   typeName    =     (  ( String )     ( this . children [  0  ]  . getValueInternal ( state )  . getValue (  )  )  )  ;", "Assert . state (  ( typeName    !  =    null )  ,     \" No   type   name \"  )  ;", "executorToUse    =    findExecutorFor ( typeName ,    argumentTypes ,    state )  ;", "try    {", "this . cachedExecutor    =    executorToUse ;", "if    ( executorToUse   instanceof   ReflectiveExecutor )     {", "this . exitTypeDescriptor    =    CodeFlow . toDescriptor (  (  ( ReflectiveExecutor )     ( executorToUse )  )  . get (  )  . getDeclaringClass (  )  )  ;", "}", "return   executorToUse . execute ( state . getEvaluationContext (  )  ,    arguments )  ;", "}    catch    ( AccessException   ex )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    ex ,    SpelMessage . CONSTRUCTOR _ INVOCATION _ PROBLEM ,    typeName ,    FormatHelper . formatMethodForMessage (  \"  \"  ,    argumentTypes )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createNewInstance"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "EvaluationContext   evalContext    =    state . getEvaluationContext (  )  ;", "List < solver >    ctorResolvers    =    evalContext . getsolvers (  )  ;", "for    ( solver   ctorResolver    :    ctorResolvers )     {", "try    {", "ConstructorExecutor   ce    =    ctorResolver . resolve ( state . getEvaluationContext (  )  ,    typeName ,    argumentTypes )  ;", "if    ( ce    !  =    null )     {", "return   ce ;", "}", "}    catch    ( AccessException   ex )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    ex ,    SpelMessage . CONSTRUCTOR _ INVOCATION _ PROBLEM ,    typeName ,    FormatHelper . formatMethodForMessage (  \"  \"  ,    argumentTypes )  )  ;", "}", "}", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . CONSTRUCTOR _ NOT _ FOUND ,    typeName ,    FormatHelper . formatMethodForMessage (  \"  \"  ,    argumentTypes )  )  ;", "}", "METHOD_END"], "methodName": ["findExecutorForConstructor"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "return    ( getChildCount (  )  )     >     1  ;", "}", "METHOD_END"], "methodName": ["hasInitializer"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "boolean [  ]    newBooleanArray    =     (  ( boolean [  ]  )     ( newArray )  )  ;", "for    ( int   i    =     0  ;    i    <     ( newBooleanArray . length )  ;    i +  +  )     {", "TypedValue   typedValue    =    initializer . getChild ( i )  . getTypedValue ( state )  ;", "newBooleanArray [ i ]     =    EUtils . toBoolean ( typeConverter ,    typedValue )  ;", "}", "}", "METHOD_END"], "methodName": ["populateBooleanArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    newByteArray    =     (  ( byte [  ]  )     ( newArray )  )  ;", "for    ( int   i    =     0  ;    i    <     ( newByteArray . length )  ;    i +  +  )     {", "TypedValue   typedValue    =    initializer . getChild ( i )  . getTypedValue ( state )  ;", "newByteArray [ i ]     =    EUtils . toByte ( typeConverter ,    typedValue )  ;", "}", "}", "METHOD_END"], "methodName": ["populateByteArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "char [  ]    newCharArray    =     (  ( char [  ]  )     ( newArray )  )  ;", "for    ( int   i    =     0  ;    i    <     ( newCharArray . length )  ;    i +  +  )     {", "TypedValue   typedValue    =    initializer . getChild ( i )  . getTypedValue ( state )  ;", "newCharArray [ i ]     =    EUtils . toChar ( typeConverter ,    typedValue )  ;", "}", "}", "METHOD_END"], "methodName": ["populateCharArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "double [  ]    newDoubleArray    =     (  ( double [  ]  )     ( newArray )  )  ;", "for    ( int   i    =     0  ;    i    <     ( newDoubleArray . length )  ;    i +  +  )     {", "TypedValue   typedValue    =    initializer . getChild ( i )  . getTypedValue ( state )  ;", "newDoubleArray [ i ]     =    EUtils . toDouble ( typeConverter ,    typedValue )  ;", "}", "}", "METHOD_END"], "methodName": ["populateDoubleArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "float [  ]    newFloatArray    =     (  ( float [  ]  )     ( newArray )  )  ;", "for    ( int   i    =     0  ;    i    <     ( newFloatArray . length )  ;    i +  +  )     {", "TypedValue   typedValue    =    initializer . getChild ( i )  . getTypedValue ( state )  ;", "newFloatArray [ i ]     =    EUtils . toFloat ( typeConverter ,    typedValue )  ;", "}", "}", "METHOD_END"], "methodName": ["populateFloatArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "int [  ]    newIntArray    =     (  ( int [  ]  )     ( newArray )  )  ;", "for    ( int   i    =     0  ;    i    <     ( newIntArray . length )  ;    i +  +  )     {", "TypedValue   typedValue    =    initializer . getChild ( i )  . getTypedValue ( state )  ;", "newIntArray [ i ]     =    EUtils . toInt ( typeConverter ,    typedValue )  ;", "}", "}", "METHOD_END"], "methodName": ["populateIntArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "long [  ]    newLongArray    =     (  ( long [  ]  )     ( newArray )  )  ;", "for    ( int   i    =     0  ;    i    <     ( newLongArray . length )  ;    i +  +  )     {", "TypedValue   typedValue    =    initializer . getChild ( i )  . getTypedValue ( state )  ;", "newLongArray [ i ]     =    EUtils . toLong ( typeConverter ,    typedValue )  ;", "}", "}", "METHOD_END"], "methodName": ["populateLongArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   toTypeDescriptor    =    TypeDescriptor . valueOf ( componentType )  ;", "Object [  ]    newObjectArray    =     (  ( Object [  ]  )     ( newArray )  )  ;", "for    ( int   i    =     0  ;    i    <     ( newObjectArray . length )  ;    i +  +  )     {", "SpelNode   elementNode    =    initializer . getChild ( i )  ;", "Object   arrayEntry    =    elementNode . getValue ( state )  ;", "newObjectArray [ i ]     =    typeConverter . convertValue ( arrayEntry ,    TypeDescriptor . forObject ( arrayEntry )  ,    toTypeDescriptor )  ;", "}", "}", "METHOD_END"], "methodName": ["populateReferenceTypeArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "short [  ]    newShortArray    =     (  ( short [  ]  )     ( newArray )  )  ;", "for    ( int   i    =     0  ;    i    <     ( newShortArray . length )  ;    i +  +  )     {", "TypedValue   typedValue    =    initializer . getChild ( i )  . getTypedValue ( state )  ;", "newShortArray [ i ]     =    EUtils . toShort ( typeConverter ,    typedValue )  ;", "}", "}", "METHOD_END"], "methodName": ["populateShortArray"], "fileName": "org.springframework.expression.spel.ast.ConstructorReference"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( this . exitTypeDescriptor )     =  =    null )     &  &     (  ( this . children [  0  ]  . exitTypeDescriptor )     !  =    null )  )     &  &     (  ( this . children [  1  ]  . exitTypeDescriptor )     !  =    null )  )     {", "St   conditionDescriptor    =    this . children [  0  ]  . exitTypeDescriptor ;", "St   ifNullValueDescriptor    =    this . children [  1  ]  . exitTypeDescriptor ;", "if    ( ObjectUtils . nullSafeEquals ( conditionDescriptor ,    ifNullValueDescriptor )  )     {", "this . exitTypeDescriptor    =    conditionDescriptor ;", "} else    {", "this . exitTypeDescriptor    =     \" Ljava / lang / Object \"  ;", "}", "}", "}", "METHOD_END"], "methodName": ["computeExitTypeDescriptor"], "fileName": "org.springframework.expression.spel.ast.Elvis"}, {"methodBody": ["METHOD_START", "{", "return   clazz    !  =    null    ?    ClassUtils . getQualifiedName ( clazz )     :     \" null \"  ;", "}", "METHOD_END"], "methodName": ["formatClassNameForMessage"], "fileName": "org.springframework.expression.spel.ast.FormatHelper"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( name )  ;", "sb . append (  \"  (  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( argumentTypes . size (  )  )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "TypeDescriptor   typeDescriptor    =    argumentTypes . get ( i )  ;", "if    ( typeDescriptor    !  =    null )     {", "sb . append (  . formatClassNameForMessage ( typeDescriptor . getType (  )  )  )  ;", "} else    {", "sb . append (  . formatClassNameForMessage ( null )  )  ;", "}", "}", "sb . append (  \"  )  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["formatMethodForMessage"], "fileName": "org.springframework.expression.spel.ast.FormatHelper"}, {"methodBody": ["METHOD_START", "{", "String   message    =    FormatHelper . formatMethodForMessage (  \" foo \"  ,    Arrays . asList ( TypeDescriptor . forObject (  \" a   string \"  )  ,    TypeDescriptor . forObject ( Integer . valueOf (  5  )  )  )  )  ;", "assertEquals (  \" foo ( String , Integer )  \"  ,    message )  ;", "}", "METHOD_END"], "methodName": ["formatMethodWithMultipleArgumentsForMessage"], "fileName": "org.springframework.expression.spel.ast.FormatHelperTests"}, {"methodBody": ["METHOD_START", "{", "String   message    =    FormatHelper . formatMethodForMessage (  \" foo \"  ,    Arrays . asList ( TypeDescriptor . forObject (  \" a   string \"  )  )  )  ;", "assertEquals (  \" foo ( String )  \"  ,    message )  ;", "}", "METHOD_END"], "methodName": ["formatMethodWithSingleArgumentForMessage"], "fileName": "org.springframework.expression.spel.ast.FormatHelperTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    functionArgs    =    getArguments ( state )  ;", "if    (  !  ( method . isVarArgs (  )  )  )     {", "int   declaredParamCount    =    method . getParameterCount (  )  ;", "if    ( declaredParamCount    !  =     ( functionArgs . length )  )     {", "throw   new   SpelEvaluationException ( SpelMessage . INCORRECT _ NUMBER _ OF _ ARGUMENTS _ TO _ FUNCTION ,    functionArgs . length ,    declaredParamCount )  ;", "}", "}", "if    (  !  ( Modifier . isStatic ( method . getModifiers (  )  )  )  )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . FUNCTION _ MUST _ BE _ STATIC ,    ClassUtils . getQualifiedMethodName ( method )  ,    this . name )  ;", "}", "TypeConverter   converter    =    state . getEvaluationContext (  )  . getTypeConverter (  )  ;", "boolean   argumentConversionOccurred    =    ReflectionHelper . convertAllArguments ( converter ,    functionArgs ,    method )  ;", "if    ( method . isVarArgs (  )  )     {", "functionArgs    =    ReflectionHelper . setupArgumentsForVarargsInvocation ( method . getParameterTypes (  )  ,    functionArgs )  ;", "}", "boolean   compilable    =    false ;", "try    {", "ReflectionUtils . makeAccessible ( method )  ;", "Object   result    =    method . invoke ( method . getClass (  )  ,    functionArgs )  ;", "compilable    =     ! argumentConversionOccurred ;", "return   new   TypedValue ( result ,    new   core . convert . TypeDescriptor ( new   MethodParameter ( method ,     (  -  1  )  )  )  . narrow ( result )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    ex ,    SpelMessage . EXCEPTION _ DURING _ FUNCTION _ CALL ,    this . name ,    ex . getMessage (  )  )  ;", "}    finally    {", "if    ( compilable )     {", "this . exitTypeDescriptor    =    CodeFlow . toDescriptor ( method . getReturnType (  )  )  ;", "this . method    =    method ;", "} else    {", "this . exitTypeDescriptor    =    null ;", "this . method    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["executeFunctionJLRMethod"], "fileName": "org.springframework.expression.spel.ast.FunctionReference"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    arguments    =    new   Object [ getChildCount (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( arguments . length )  ;    i +  +  )     {", "arguments [ i ]     =    this . child [ i ]  . getValueInternal ( state )  . getValue (  )  ;", "}", "return   arguments ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.springframework.expression.spel.ast.FunctionReference"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    arrayComponentType    =    ctx . getClass (  )  . getComponentType (  )  ;", "if    ( arrayComponentType    =  =     ( Boolean . TYPE )  )     {", "boolean [  ]    array    =     (  ( boolean [  ]  )     ( ctx )  )  ;", "checkAccess ( array . length ,    idx )  ;", "this . exitTypeDescriptor    =     \" Z \"  ;", "return   array [ idx ]  ;", "} else", "if    ( arrayComponentType    =  =     ( Byte . TYPE )  )     {", "byte [  ]    array    =     (  ( byte [  ]  )     ( ctx )  )  ;", "checkAccess ( array . length ,    idx )  ;", "this . exitTypeDescriptor    =     \" B \"  ;", "return   array [ idx ]  ;", "} else", "if    ( arrayComponentType    =  =     ( Character . TYPE )  )     {", "char [  ]    array    =     (  ( char [  ]  )     ( ctx )  )  ;", "checkAccess ( array . length ,    idx )  ;", "this . exitTypeDescriptor    =     \" C \"  ;", "return   array [ idx ]  ;", "} else", "if    ( arrayComponentType    =  =     ( Double . TYPE )  )     {", "double [  ]    array    =     (  ( double [  ]  )     ( ctx )  )  ;", "checkAccess ( array . length ,    idx )  ;", "this . exitTypeDescriptor    =     \" D \"  ;", "return   array [ idx ]  ;", "} else", "if    ( arrayComponentType    =  =     ( Float . TYPE )  )     {", "float [  ]    array    =     (  ( float [  ]  )     ( ctx )  )  ;", "checkAccess ( array . length ,    idx )  ;", "this . exitTypeDescriptor    =     \" F \"  ;", "return   array [ idx ]  ;", "} else", "if    ( arrayComponentType    =  =     ( Integer . TYPE )  )     {", "int [  ]    array    =     (  ( int [  ]  )     ( ctx )  )  ;", "checkAccess ( array . length ,    idx )  ;", "this . exitTypeDescriptor    =     \" I \"  ;", "return   array [ idx ]  ;", "} else", "if    ( arrayComponentType    =  =     ( Long . TYPE )  )     {", "long [  ]    array    =     (  ( long [  ]  )     ( ctx )  )  ;", "checkAccess ( array . length ,    idx )  ;", "this . exitTypeDescriptor    =     \" J \"  ;", "return   array [ idx ]  ;", "} else", "if    ( arrayComponentType    =  =     ( Short . TYPE )  )     {", "short [  ]    array    =     (  ( short [  ]  )     ( ctx )  )  ;", "checkAccess ( array . length ,    idx )  ;", "this . exitTypeDescriptor    =     \" S \"  ;", "return   array [ idx ]  ;", "} else    {", "Object [  ]    array    =     (  ( Object [  ]  )     ( ctx )  )  ;", "checkAccess ( array . length ,    idx )  ;", "Object   retValue    =    array [ idx ]  ;", "this . exitTypeDescriptor    =    CodeFlow . toDescriptor ( arrayComponentType )  ;", "return   retValue ;", "}", "}", "METHOD_END"], "methodName": ["accessArrayElement"], "fileName": "org.springframework.expression.spel.ast.Indexer"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >    arrayLength )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . ARRAY _ INDEX _ OUT _ OF _ BOUNDS ,    arrayLength ,    index )  ;", "}", "}", "METHOD_END"], "methodName": ["checkAccess"], "fileName": "org.springframework.expression.spel.ast.Indexer"}, {"methodBody": ["METHOD_START", "{", "T   result    =     (  ( T )     ( converter . convertValue ( value ,    TypeDescriptor . forObject ( value )  ,    TypeDescriptor . valueOf ( targetType )  )  )  )  ;", "if    ( result    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" Null   conver   result   for   index    [  \"     +    value )     +     \"  ]  \"  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["convertValue"], "fileName": "org.springframework.expression.spel.ast.Indexer"}, {"methodBody": ["METHOD_START", "{", "if    ( arrayComponentType    =  =     ( Boolean . TYPE )  )     {", "boolean [  ]    array    =     (  ( boolean [  ]  )     ( ctx )  )  ;", "checkAcc ( array . length ,    idx )  ;", "array [ idx ]     =    convertValue ( converter ,    newValue ,    Boolean . class )  ;", "} else", "if    ( arrayComponentType    =  =     ( Byte . TYPE )  )     {", "byte [  ]    array    =     (  ( byte [  ]  )     ( ctx )  )  ;", "checkAcc ( array . length ,    idx )  ;", "array [ idx ]     =    convertValue ( converter ,    newValue ,    Byte . class )  ;", "} else", "if    ( arrayComponentType    =  =     ( Character . TYPE )  )     {", "char [  ]    array    =     (  ( char [  ]  )     ( ctx )  )  ;", "checkAcc ( array . length ,    idx )  ;", "array [ idx ]     =    convertValue ( converter ,    newValue ,    Character . class )  ;", "} else", "if    ( arrayComponentType    =  =     ( Double . TYPE )  )     {", "double [  ]    array    =     (  ( double [  ]  )     ( ctx )  )  ;", "checkAcc ( array . length ,    idx )  ;", "array [ idx ]     =    convertValue ( converter ,    newValue ,    Double . class )  ;", "} else", "if    ( arrayComponentType    =  =     ( Float . TYPE )  )     {", "float [  ]    array    =     (  ( float [  ]  )     ( ctx )  )  ;", "checkAcc ( array . length ,    idx )  ;", "array [ idx ]     =    convertValue ( converter ,    newValue ,    Float . class )  ;", "} else", "if    ( arrayComponentType    =  =     ( Integer . TYPE )  )     {", "int [  ]    array    =     (  ( int [  ]  )     ( ctx )  )  ;", "checkAcc ( array . length ,    idx )  ;", "array [ idx ]     =    convertValue ( converter ,    newValue ,    Integer . class )  ;", "} else", "if    ( arrayComponentType    =  =     ( Long . TYPE )  )     {", "long [  ]    array    =     (  ( long [  ]  )     ( ctx )  )  ;", "checkAcc ( array . length ,    idx )  ;", "array [ idx ]     =    convertValue ( converter ,    newValue ,    Long . class )  ;", "} else", "if    ( arrayComponentType    =  =     ( Short . TYPE )  )     {", "short [  ]    array    =     (  ( short [  ]  )     ( ctx )  )  ;", "checkAcc ( array . length ,    idx )  ;", "array [ idx ]     =    convertValue ( converter ,    newValue ,    Short . class )  ;", "} else    {", "Object [  ]    array    =     (  ( Object [  ]  )     ( ctx )  )  ;", "checkAcc ( array . length ,    idx )  ;", "array [ idx ]     =    convertValue ( converter ,    newValue ,    arrayComponentType )  ;", "}", "}", "METHOD_END"], "methodName": ["setArrayElement"], "fileName": "org.springframework.expression.spel.ast.Indexer"}, {"methodBody": ["METHOD_START", "{", "boolean   isConstant    =    true ;", "for    ( int   c    =     0  ,    max    =    getChildCount (  )  ;    c    <    max ;    c +  +  )     {", "SpelNode   child    =    getChild ( c )  ;", "if    (  !  ( child   instanceof   Literal )  )     {", "if    ( child   instanceof    )     {", "inlineList    =     (  (  )     ( child )  )  ;", "if    (  !  ( inlineList . isConstant (  )  )  )     {", "isConstant    =    false ;", "}", "} else    {", "isConstant    =    false ;", "}", "}", "}", "if    ( isConstant )     {", "List < Object >    constantList    =    new   ArrayList <  >  (  )  ;", "int   childcount    =    getChildCount (  )  ;", "for    ( int   c    =     0  ;    c    <    childcount ;    c +  +  )     {", "SpelNode   child    =    getChild ( c )  ;", "if    ( child   instanceof   Literal )     {", "constantList . add (  (  ( Literal )     ( child )  )  . getLiteralValue (  )  . getValue (  )  )  ;", "} else", "if    ( child   instanceof    )     {", "constantList . add (  (  (  )     ( child )  )  . getConstantValue (  )  )  ;", "}", "}", "this . constant    =    new   TypedValue ( Collections . unmodifiableList ( constantList )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkIfConstant"], "fileName": "org.springframework.expression.spel.ast.InlineList"}, {"methodBody": ["METHOD_START", "{", "mv . visitTypeInsn ( NEW ,     \" java / util / ArrayList \"  )  ;", "mv . visitInsn ( DUP )  ;", "mv . visitMethodInsn ( INVOKESPECIAL ,     \" java / util / ArrayList \"  ,     \"  < init >  \"  ,     \"  (  ) V \"  ,    false )  ;", "if    (  ! nested )     {", "mv . visitFieldInsn ( PUTSTATIC ,    clazzname ,    constantFieldName ,     \" Ljava / util / List ;  \"  )  ;", "}", "int   childCount    =    getChildCount (  )  ;", "for    ( int   c    =     0  ;    c    <    childCount ;    c +  +  )     {", "if    (  ! nested )     {", "mv . visitFieldInsn ( GETSTATIC ,    clazzname ,    constantFieldName ,     \" Ljava / util / List ;  \"  )  ;", "} else    {", "mv . visitInsn ( DUP )  ;", "}", "if    (  ( children [ c ]  )    instanceof    )     {", "(  (  )     ( children [ c ]  )  )  . generateClinitCode ( clazzname ,    constantFieldName ,    mv ,    codeflow ,    true )  ;", "} else    {", "children [ c ]  . generateCode ( mv ,    codeflow )  ;", "String   lastDesc    =    codeflow . lastDescriptor (  )  ;", "if    ( CodeFlow . isPrimitive ( lastDesc )  )     {", "CodeFlow . insertBoxIfNecessary ( mv ,    lastDesc . charAt (  0  )  )  ;", "}", "}", "mv . visitMethodInsn ( INVOKEINTERFACE ,     \" java / util / List \"  ,     \" add \"  ,     \"  ( Ljava / lang / Object ;  ) Z \"  ,    true )  ;", "mv . visitInsn ( POP )  ;", "}", "}", "METHOD_END"], "methodName": ["generateClinitCode"], "fileName": "org.springframework.expression.spel.ast.InlineList"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . constant )     !  =    null )  ,     \" No   constant \"  )  ;", "return    (  (  < Object >  )     ( this . constant . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getConstantValue"], "fileName": "org.springframework.expression.spel.ast.InlineList"}, {"methodBody": ["METHOD_START", "{", "return    ( this . constant )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isConstant"], "fileName": "org.springframework.expression.spel.ast.InlineList"}, {"methodBody": ["METHOD_START", "{", "boolean   isConstant    =    true ;", "for    ( int   c    =     0  ,    max    =    getChildCount (  )  ;    c    <    max ;    c +  +  )     {", "SpelNode   child    =    getChild ( c )  ;", "if    (  !  ( child   instanceof   Literal )  )     {", "if    ( child   instanceof   InlineList )     {", "InlineList   inlineList    =     (  ( InlineList )     ( child )  )  ;", "if    (  !  ( inlineList . isConstant (  )  )  )     {", "isConstant    =    false ;", "break ;", "}", "} else", "if    ( child   instanceof    )     {", "inlineMap    =     (  (  )     ( child )  )  ;", "if    (  !  ( inlineMap . isConstant (  )  )  )     {", "isConstant    =    false ;", "break ;", "}", "} else", "if    (  !  (  (  ( c    %     2  )     =  =     0  )     &  &     ( child   instanceof   PropertyOrFieldReference )  )  )     {", "isConstant    =    false ;", "break ;", "}", "}", "}", "if    ( isConstant )     {", "Map < Object ,    Object >    constantMap    =    new   LinkedHashMap <  >  (  )  ;", "int   childCount    =    getChildCount (  )  ;", "for    ( int   c    =     0  ;    c    <    childCount ;    c +  +  )     {", "SpelNode   keyChild    =    getChild (  ( c +  +  )  )  ;", "SpelNode   valueChild    =    getChild ( c )  ;", "Object   key    =    null ;", "Object   value    =    null ;", "if    ( keyChild   instanceof   Literal )     {", "key    =     (  ( Literal )     ( keyChild )  )  . getLiteralValue (  )  . getValue (  )  ;", "} else", "if    ( keyChild   instanceof   PropertyOrFieldReference )     {", "key    =     (  ( PropertyOrFieldReference )     ( keyChild )  )  . getName (  )  ;", "} else    {", "return ;", "}", "if    ( valueChild   instanceof   Literal )     {", "value    =     (  ( Literal )     ( valueChild )  )  . getLiteralValue (  )  . getValue (  )  ;", "} else", "if    ( valueChild   instanceof   InlineList )     {", "value    =     (  ( InlineList )     ( valueChild )  )  . getConstantValue (  )  ;", "} else", "if    ( valueChild   instanceof    )     {", "value    =     (  (  )     ( valueChild )  )  . getConstantValue (  )  ;", "}", "constantMap . put ( key ,    value )  ;", "}", "this . constant    =    new   TypedValue ( Collections . unmodifiableMap ( constantMap )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkIfConstant"], "fileName": "org.springframework.expression.spel.ast.InlineMap"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . constant )     !  =    null )  ,     \" No   constant \"  )  ;", "return    (  (  < Object ,    Object >  )     ( this . constant . getValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getConstantValue"], "fileName": "org.springframework.expression.spel.ast.InlineMap"}, {"methodBody": ["METHOD_START", "{", "return    ( this . constant )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isConstant"], "fileName": "org.springframework.expression.spel.ast.InlineMap"}, {"methodBody": ["METHOD_START", "{", "try    {", "int   value    =    Integer . parseInt ( numberToken ,    radix )  ;", "return   new   Int ( numberToken ,    pos ,    value )  ;", "}    catch    ( NumberFormatException   ex )     {", "throw   new   InternalParseException ( new   SpelParseException (  ( pos    >  >     1  6  )  ,    ex ,    SpelMessage . NOT _ AN _ INTEGER ,    numberToken )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getIntLiteral"], "fileName": "org.springframework.expression.spel.ast.Literal"}, {"methodBody": ["METHOD_START", "{", "try    {", "long   value    =    Long . parseLong ( numberToken ,    radix )  ;", "return   new   Long ( numberToken ,    pos ,    value )  ;", "}    catch    ( NumberFormatException   ex )     {", "throw   new   InternalParseException ( new   SpelParseException (  ( pos    >  >     1  6  )  ,    ex ,    SpelMessage . NOT _ A _ LONG ,    numberToken )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getLongLiteral"], "fileName": "org.springframework.expression.spel.ast.Literal"}, {"methodBody": ["METHOD_START", "{", "return   this . originalValue ;", "}", "METHOD_END"], "methodName": ["getOriginalValue"], "fileName": "org.springframework.expression.spel.ast.Literal"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( isFloat )     {", "float   value    =    Float . parseFloat ( numberToken )  ;", "return   new   Float ( numberToken ,    pos ,    value )  ;", "} else    {", "double   value    =    Double . parseDouble ( numberToken )  ;", "return   new   Real ( numberToken ,    pos ,    value )  ;", "}", "}    catch    ( NumberFormatException   ex )     {", "throw   new   InternalParseException ( new   SpelParseException (  ( pos    >  >     1  6  )  ,    ex ,    SpelMessage . NOT _ A _ REAL ,    numberToken )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getRealLiteral"], "fileName": "org.springframework.expression.spel.ast.Literal"}, {"methodBody": ["METHOD_START", "{", "List < MethodResolver >    methodResolvers    =    evaluationContext . getMethodResolvers (  )  ;", "for    ( MethodResolver   methodResolver    :    methodResolvers )     {", "try    {", "MethodExecutor   methodExecutor    =    methodResolver . resolve ( evaluationContext ,    targetObject ,    name ,    argumentTypes )  ;", "if    ( methodExecutor    !  =    null )     {", "return   methodExecutor ;", "}", "}    catch    ( AccessException   ex )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    ex ,    SpelMessage . PROBLEM _ LOCATING _ METHOD ,    name ,    targetObject . getClass (  )  )  ;", "}", "}", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . METHOD _ NOT _ FOUND ,    FormatHelper . formatMethodForMessage ( name ,    argumentTypes )  ,    FormatHelper . formatClassNameForMessage (  ( targetObject   instanceof   Class    ?     (  ( Class <  ?  >  )     ( targetObject )  )     :    targetObject . getClass (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["findAccessorForMethod"], "fileName": "org.springframework.expression.spel.ast.MethodReference"}, {"methodBody": ["METHOD_START", "{", "List < TypeDescriptor >    descriptors    =    new   ArrayList <  >  ( arguments . length )  ;", "for    ( Object   argument    :    arguments )     {", "descriptors . add ( TypeDescriptor . forObject ( argument )  )  ;", "}", "return   Collects . unmodifiableList ( descriptors )  ;", "}", "METHOD_END"], "methodName": ["getArgumentTypes"], "fileName": "org.springframework.expression.spel.ast.MethodReference"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    arguments    =    new   Object [ getChildCount (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( arguments . length )  ;    i +  +  )     {", "try    {", "state . pushActiveContextObject ( state . getScopeRootContextObject (  )  )  ;", "arguments [ i ]     =    this . child [ i ]  . getValueInternal ( state )  . getValue (  )  ;", "}    finally    {", "state . popActiveContextObject (  )  ;", "}", "}", "return   arguments ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.springframework.expression.spel.ast.MethodReference"}, {"methodBody": ["METHOD_START", "{", "List < MethodResolver >    methodResolvers    =    evaluationContext . getMethodResolvers (  )  ;", "if    (  (  ( methodResolvers . size (  )  )     !  =     1  )     |  |     (  !  (  ( methodResolvers . get (  0  )  )    instanceof   ReflectiveMethodResolver )  )  )     {", "return   null ;", "}", ". CachedMethodExecutor   executorToCheck    =    this . cachedExecutor ;", "if    (  ( executorToCheck    !  =    null )     &  &     ( executorToCheck . isSuitable ( value ,    target ,    argumentTypes )  )  )     {", "return   executorToCheck . get (  )  ;", "}", "this . cachedExecutor    =    null ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getCachedExecutor"], "fileName": "org.springframework.expression.spel.ast.MethodReference"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.expression.spel.ast.MethodReference"}, {"methodBody": ["METHOD_START", "{", "List < TypeDescriptor >    argumentTypes    =    getArgumentTypes ( arguments )  ;", "if    ( value    =  =    null )     {", "throwIfNotNullSafe ( argumentTypes )  ;", "return   TypedValue . NULL ;", "}", "MethodExecutor   executorToUse    =    getCachedExecutor ( evaluationContext ,    value ,    targetType ,    argumentTypes )  ;", "if    ( executorToUse    !  =    null )     {", "try    {", "return   executorToUse . execute ( evaluationContext ,    value ,    arguments )  ;", "}    catch    ( AccessException   ex )     {", "throwSimpleExceptionIfPossible ( value ,    ex )  ;", "this . cachedExecutor    =    null ;", "}", "}", "executorToUse    =    findAccessorForMethod ( this . name ,    argumentTypes ,    value ,    evaluationContext )  ;", "this . cachedExecutor    =    new    . CachedMethodExecutor ( executorToUse ,     ( value   instanceof   Class    ?     (  ( Class <  ?  >  )     ( value )  )     :    null )  ,    targetType ,    argumentTypes )  ;", "try    {", "return   executorToUse . execute ( evaluationContext ,    value ,    arguments )  ;", "}    catch    ( AccessException   ex )     {", "throwSimpleExceptionIfPossible ( value ,    ex )  ;", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    ex ,    SpelMessage . EXCEPTION _ DURING _ METHOD _ INVOCATION ,    this . name ,    value . getClass (  )  . getName (  )  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getValueInternal"], "fileName": "org.springframework.expression.spel.ast.MethodReference"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . nullSafe )  )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . METHOD _ CALL _ ON _ NULL _ OBJECT _ NOT _ ALLOWED ,    FormatHelper . formatForMessage ( this . name ,    argumentTypes )  )  ;", "}", "}", "METHOD_END"], "methodName": ["throwIfNotNullSafe"], "fileName": "org.springframework.expression.spel.ast.MethodReference"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ex . getCause (  )  )    instanceof   InvocationTargetException )     {", "Throwable   rootCause    =    ex . getCause (  )  . getCause (  )  ;", "if    ( rootCause   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( rootCause )  )  ;", "}", "throw   new   EInvocationTargetException ( getStartPosition (  )  ,     (  (  (  (  \" A   problem   occurred   when   trying   to   execute   method    '  \"     +     ( this . name )  )     +     \"  '    on   object   of   type    [  \"  )     +     ( value . getClass (  )  . getName (  )  )  )     +     \"  ]  \"  )  ,    rootCause )  ;", "}", "}", "METHOD_END"], "methodName": ["throwSimpleExceptionIfPossible"], "fileName": "org.springframework.expression.spel.ast.MethodReference"}, {"methodBody": ["METHOD_START", "{", "MethodReference . CachedMethodExecutor   executorToCheck    =    this . cachedExecutor ;", "if    (  ( executorToCheck    !  =    null )     &  &     (  ( executorToCheck . get (  )  )    instanceof   ReflectiveMethodExecutor )  )     {", "Method   method    =     (  ( ReflectiveMethodExecutor )     ( executorToCheck . get (  )  )  )  . getMethod (  )  ;", "String   descriptor    =    CodeFlow . toDescriptor ( method . getReturnType (  )  )  ;", "if    (  ( this . nullSafe )     &  &     ( CodeFlow . isPrimitive ( descriptor )  )  )     {", "originalPrimitiveExitTypeDescriptor    =    descriptor ;", "this . exitTypeDescriptor    =    CodeFlow . toBoxedDescriptor ( descriptor )  ;", "} else    {", "this . exitTypeDescriptor    =    descriptor ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateExitTypeDescriptor"], "fileName": "org.springframework.expression.spel.ast.MethodReference"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "throw   new   SpelEvaluationException ( SpelMage . TYPE _ CONVERSION _ ERROR ,     \" null \"  ,     \" boolean \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValueNotNull"], "fileName": "org.springframework.expression.spel.ast.OpAnd"}, {"methodBody": ["METHOD_START", "{", "try    {", "Boolean   value    =    operand . getValue ( state ,    Boolean . class )  ;", "assertValueNotNull ( value )  ;", "return   value ;", "}    catch    ( SEvaluationException   ex )     {", "ex . setPosition ( operand . getStartPosition (  )  )  ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["getBooleanValue"], "fileName": "org.springframework.expression.spel.ast.OpAnd"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "throw   new   SpelEvaluationException ( SpelMage . TYPE _ CONVERSION _ ERROR ,     \" null \"  ,     \" boolean \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValueNotNull"], "fileName": "org.springframework.expression.spel.ast.OpOr"}, {"methodBody": ["METHOD_START", "{", "try    {", "Boolean   value    =    operand . getValue ( state ,    Boolean . class )  ;", "assertValueNotNull ( value )  ;", "return   value ;", "}    catch    ( SEvaluationException   ee )     {", "ee . setPosition ( operand . getStartPosition (  )  )  ;", "throw   ee ;", "}", "}", "METHOD_END"], "methodName": ["getBooleanValue"], "fileName": "org.springframework.expression.spel.ast.OpOr"}, {"methodBody": ["METHOD_START", "{", "TypeConverter   typeConverter    =    state . getEvaluationContext (  )  . getTypeConverter (  )  ;", "TypeDescriptor   typeDescriptor    =    TypeDescriptor . valueOf ( St . class )  ;", "if    ( typeConverter . canConvert ( value . getTypeDescriptor (  )  ,    typeDescriptor )  )     {", "return   St . valueOf ( typeConverter . convertValue ( value . getValue (  )  ,    value . getTypeDescriptor (  )  ,    typeDescriptor )  )  ;", "}", "return   St . valueOf ( value . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["convertTypedValueToString"], "fileName": "org.springframework.expression.spel.ast.OpPlus"}, {"methodBody": ["METHOD_START", "{", "if    ( operand   instanceof   OpPlus )     {", "OpPlus   plus    =     (  ( OpPlus )     ( operand )  )  ;", "walk ( mv ,    cf ,    plus . getLeftOperand (  )  )  ;", "walk ( mv ,    cf ,    plus . getRightOperand (  )  )  ;", "} else", "if    ( operand    !  =    null )     {", "cf . enterCompilationScope (  )  ;", "operand . generateCode ( mv ,    cf )  ;", "if    (  !  (  \" Ljava / lang / String \"  . equals ( cf . lastDescriptor (  )  )  )  )     {", "mv . visitTypeInsn ( CHECKCAST ,     \" java / lang / String \"  )  ;", "}", "cf . exitCompilationScope (  )  ;", "mv . visitMethodInsn ( INVOKEVIRTUAL ,     \" java / lang / StringBuilder \"  ,     \" append \"  ,     \"  ( Ljava / lang / String ;  ) Ljava / lang / StringBuilder ;  \"  ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["walk"], "fileName": "org.springframework.expression.spel.ast.OpPlus"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   expressionState    =    new   ExpressionState ( new   StandardEvaluationContext (  )  )  ;", "StringLiteral   n 1     =    new   StringLiteral (  \"  \\  \" number   is    \\  \"  \"  ,     (  -  1  )  ,     \"  \\  \" number   is    \\  \"  \"  )  ;", "LongLiteral   n 2     =    new   LongLiteral (  \"  1  2  3  \"  ,     (  -  1  )  ,     1  2  3  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    n 1  ,    n 2  )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \" number   is    1  2  3  \"  ,    value . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["test_binaryPlusWithLeftStringOperand"], "fileName": "org.springframework.expression.spel.ast.OpPlusTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   expressionState    =    new   ExpressionState ( new   StandardEvaluationContext (  )  )  ;", "{", "RealLiteral   n 1     =    new   RealLiteral (  \"  1  2  3  .  0  0  \"  ,     (  -  1  )  ,     1  2  3  .  0  )  ;", "RealLiteral   n 2     =    new   RealLiteral (  \"  4  5  6  .  0  0  \"  ,     (  -  1  )  ,     4  5  6  .  0  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    n 1  ,    n 2  )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( Double . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( Double . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Double . valueOf (  (  1  2  3  .  0     +     4  5  6  .  0  )  )  ,    value . getValue (  )  )  ;", "}", "{", "LongLiteral   n 1     =    new   LongLiteral (  \"  1  2  3  \"  ,     (  -  1  )  ,     1  2  3 L )  ;", "LongLiteral   n 2     =    new   LongLiteral (  \"  4  5  6  \"  ,     (  -  1  )  ,     4  5  6 L )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    n 1  ,    n 2  )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( Long . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( Long . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Long . valueOf (  (  1  2  3 L    +     4  5  6 L )  )  ,    value . getValue (  )  )  ;", "}", "{", "IntLiteral   n 1     =    new   IntLiteral (  \"  1  2  3  \"  ,     (  -  1  )  ,     1  2  3  )  ;", "IntLiteral   n 2     =    new   IntLiteral (  \"  4  5  6  \"  ,     (  -  1  )  ,     4  5  6  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    n 1  ,    n 2  )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( Integer . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( Integer . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( Integer . valueOf (  (  1  2  3     +     4  5  6  )  )  ,    value . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["test_binaryPlusWithNumberOperands"], "fileName": "org.springframework.expression.spel.ast.OpPlusTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   expressionState    =    new   ExpressionState ( new   StandardEvaluationContext (  )  )  ;", "LongLiteral   n 1     =    new   LongLiteral (  \"  1  2  3  \"  ,     (  -  1  )  ,     1  2  3  )  ;", "StringLiteral   n 2     =    new   StringLiteral (  \"  \\  \"    is   a   number \\  \"  \"  ,     (  -  1  )  ,     \"  \\  \"    is   a   number \\  \"  \"  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    n 1  ,    n 2  )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \"  1  2  3    is   a   number \"  ,    value . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["test_binaryPlusWithRightStringOperand"], "fileName": "org.springframework.expression.spel.ast.OpPlusTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   expressionState    =    new   ExpressionState ( new   StandardEvaluationContext (  )  )  ;", "StringLiteral   n 1     =    new   StringLiteral (  \"  \\  \" foo \\  \"  \"  ,     (  -  1  )  ,     \"  \\  \" foo \\  \"  \"  )  ;", "StringLiteral   n 2     =    new   StringLiteral (  \"  \\  \" bar \\  \"  \"  ,     (  -  1  )  ,     \"  \\  \" bar \\  \"  \"  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    n 1  ,    n 2  )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \" foobar \"  ,    value . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["test_binaryPlusWithStringOperands"], "fileName": "org.springframework.expression.spel.ast.OpPlusTests"}, {"methodBody": ["METHOD_START", "{", "final   SimpleDateFormat   format    =    new   SimpleDateFormat (  \" hh    :  -  -  :    mm    :  -  -  :    ss \"  ,    Locale . ENGLISH )  ;", "GenericConversionService   conversionService    =    new   GenericConversionService (  )  ;", "conversionService . addConverter ( new   core . convert . converter . Converter < Time ,    String >  (  )     {", "@ Override", "public   String   convert ( Time   source )     {", "return   format . format ( source )  ;", "}", "}  )  ;", "StandardEvaluationContext   evaluationContextConverter    =    new   StandardEvaluationContext (  )  ;", "evaluationContextConverter . setTypeConverter ( new   StandardTypeConverter ( conversionService )  )  ;", "ExpressionState   expressionState    =    new   ExpressionState ( evaluationContextConverter )  ;", "Time   time    =    new   Time ( new   Date (  )  . getTime (  )  )  ;", "VariableReference   var    =    new   VariableReference (  \" timeVar \"  ,     (  -  1  )  )  ;", "var . setValue ( expressionState ,    time )  ;", "StringLiteral   n 2     =    new   StringLiteral (  \"  \\  \"    is   now \\  \"  \"  ,     (  -  1  )  ,     \"  \\  \"    is   now \\  \"  \"  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    var ,    n 2  )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  (  ( format . format ( time )  )     +     \"    is   now \"  )  ,    value . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["test_binaryPlusWithTimeConverted"], "fileName": "org.springframework.expression.spel.ast.OpPlusTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   expressionState    =    new   ExpressionState ( new   StandardEvaluationContext (  )  )  ;", "Time   time    =    new   Time ( new   Date (  )  . getTime (  )  )  ;", "VariableReference   var    =    new   VariableReference (  \" timeVar \"  ,     (  -  1  )  )  ;", "var . setValue ( expressionState ,    time )  ;", "StringLiteral   n 2     =    new   StringLiteral (  \"  \\  \"    is   now \\  \"  \"  ,     (  -  1  )  ,     \"  \\  \"    is   now \\  \"  \"  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    var ,    n 2  )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( String . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  ( time    +     \"    is   now \"  )  ,    value . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["test_binaryPlusWithTime_ToString"], "fileName": "org.springframework.expression.spel.ast.OpPlusTests"}, {"methodBody": ["METHOD_START", "{", "new   OpPlus (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["test_emptyOperands"], "fileName": "org.springframework.expression.spel.ast.OpPlusTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   expressionState    =    new   ExpressionState ( new   StandardEvaluationContext (  )  )  ;", "{", "RealLiteral   realLiteral    =    new   RealLiteral (  \"  1  2  3  .  0  0  \"  ,     (  -  1  )  ,     1  2  3  .  0  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    realLiteral )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( Double . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( Double . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( realLiteral . getLiteralValue (  )  . getValue (  )  ,    value . getValue (  )  )  ;", "}", "{", "IntLiteral   intLiteral    =    new   IntLiteral (  \"  1  2  3  \"  ,     (  -  1  )  ,     1  2  3  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    intLiteral )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( Integer . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( Integer . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( intLiteral . getLiteralValue (  )  . getValue (  )  ,    value . getValue (  )  )  ;", "}", "{", "LongLiteral   longLiteral    =    new   LongLiteral (  \"  1  2  3  \"  ,     (  -  1  )  ,     1  2  3 L )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    longLiteral )  ;", "TypedValue   value    =    o . getValueInternal ( expressionState )  ;", "assertEquals ( Long . class ,    value . getTypeDescriptor (  )  . getObjectType (  )  )  ;", "assertEquals ( Long . class ,    value . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals ( longLiteral . getLiteralValue (  )  . getValue (  )  ,    value . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["test_unaryPlusWithNumberOperand"], "fileName": "org.springframework.expression.spel.ast.OpPlusTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionState   expressionState    =    new   ExpressionState ( new   StandardEvaluationContext (  )  )  ;", "StringLiteral   str    =    new   StringLiteral (  \" word \"  ,     (  -  1  )  ,     \" word \"  )  ;", "OpPlus   o    =    new   OpPlus (  (  -  1  )  ,    str )  ;", "o . getValueInternal ( expressionState )  ;", "}", "METHOD_END"], "methodName": ["test_unaryPlusWithStringLiteral"], "fileName": "org.springframework.expression.spel.ast.OpPlusTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( left   instanceof   Number )     &  &     ( right   instanceof   Number )  )     {", "Number   leftNumber    =     (  ( Number )     ( left )  )  ;", "Number   rightNumber    =     (  ( Number )     ( right )  )  ;", "if    (  ( leftNumber   instanceof   BigDecimal )     |  |     ( rightNumber   instanceof   BigDecimal )  )     {", "BigDecimal   leftBigDecimal    =    NumberUtils . convertNumberToTargetClass ( leftNumber ,    BigDecimal . class )  ;", "BigDecimal   rightBigDecimal    =    NumberUtils . convertNumberToTargetClass ( rightNumber ,    BigDecimal . class )  ;", "return    ( leftBigDecimal . compareTo ( rightBigDecimal )  )     =  =     0  ;", "} else", "if    (  ( leftNumber   instanceof   Double )     |  |     ( rightNumber   instanceof   Double )  )     {", "return    ( leftNumber . doubleValue (  )  )     =  =     ( rightNumber . doubleValue (  )  )  ;", "} else", "if    (  ( leftNumber   instanceof   Float )     |  |     ( rightNumber   instanceof   Float )  )     {", "return    ( leftNumber . floatValue (  )  )     =  =     ( rightNumber . floatValue (  )  )  ;", "} else", "if    (  ( leftNumber   instanceof   BigInteger )     |  |     ( rightNumber   instanceof   BigInteger )  )     {", "BigInteger   leftBigInteger    =    NumberUtils . convertNumberToTargetClass ( leftNumber ,    class )  ;", "BigInteger   rightBigInteger    =    NumberUtils . convertNumberToTargetClass ( rightNumber ,    class )  ;", "return    ( leftBigInteger . compareTo ( rightBigInteger )  )     =  =     0  ;", "} else", "if    (  ( leftNumber   instanceof   Long )     |  |     ( rightNumber   instanceof   Long )  )     {", "return    ( leftNumber . longValue (  )  )     =  =     ( rightNumber . longValue (  )  )  ;", "} else", "if    (  ( leftNumber   instanceof   Integer )     |  |     ( rightNumber   instanceof   Integer )  )     {", "return    ( leftNumber . intValue (  )  )     =  =     ( rightNumber . intValue (  )  )  ;", "} else", "if    (  ( leftNumber   instanceof   Short )     |  |     ( rightNumber   instanceof   Short )  )     {", "return    ( leftNumber . shortValue (  )  )     =  =     ( rightNumber . shortValue (  )  )  ;", "} else", "if    (  ( leftNumber   instanceof   Byte )     |  |     ( rightNumber   instanceof   Byte )  )     {", "return    ( leftNumber . byteValue (  )  )     =  =     ( rightNumber . byteValue (  )  )  ;", "} else    {", "return    ( leftNumber . doubleValue (  )  )     =  =     ( rightNumber . doubleValue (  )  )  ;", "}", "}", "if    (  ( left   instanceof   CharSequence )     &  &     ( right   instanceof   CharSequence )  )     {", "return   left . toString (  )  . equals ( right . toString (  )  )  ;", "}", "if    ( ObjectUtils . nullSafeEquals ( left ,    right )  )     {", "return   true ;", "}", "if    (  ( left   instanceof   Comparable )     &  &     ( right   instanceof   Comparable )  )     {", "Class <  ?  >    ancestor    =    ClassUtils . determineCommonAncestor ( left . getClass (  )  ,    right . getClass (  )  )  ;", "if    (  ( ancestor    !  =    null )     &  &     ( Comparable . class . isAssignableFrom ( ancestor )  )  )     {", "return    ( context . getTypeCompa (  )  . compare ( left ,    right )  )     =  =     0  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["equalityCheck"], "fileName": "org.springframework.expression.spel.ast.Operator"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   left    =    getLeftOperand (  )  ;", "SpelNodeImpl   right    =    getRightOperand (  )  ;", "String   leftDesc    =    left . exitTypeDescriptor ;", "String   rightDesc    =    right . exitTypeDescriptor ;", "boolean   unboxLeft    =     !  ( CodeFlow . isPrimitive ( leftDesc )  )  ;", "boolean   unboxRight    =     !  ( CodeFlow . isPrimitive ( rightDesc )  )  ;", ". DescriptorComparison   dc    =     . DescriptorComparison . checkNumericCompatibility ( leftDesc ,    rightDesc ,    this . leftActualDescriptor ,    this . rightActualDescriptor )  ;", "char   targetType    =    dc . compatibleType ;", "cf . enterCompilationScope (  )  ;", "left . generateCode ( mv ,    cf )  ;", "cf . exitCompilationScope (  )  ;", "if    ( unboxLeft )     {", "CodeFlow . insertUnboxInsns ( mv ,    targetType ,    leftDesc )  ;", "}", "cf . enterCompilationScope (  )  ;", "right . generateCode ( mv ,    cf )  ;", "cf . exitCompilationScope (  )  ;", "if    ( unboxRight )     {", "CodeFlow . insertUnboxInsns ( mv ,    targetType ,    rightDesc )  ;", "}", "Label   elseTarget    =    new   Label (  )  ;", "Label   endOfIf    =    new   Label (  )  ;", "if    ( targetType    =  =     ' D '  )     {", "mv . visitInsn ( DCMPG )  ;", "mv . visitJumpInsn ( compInstruction 1  ,    elseTarget )  ;", "} else", "if    ( targetType    =  =     ' F '  )     {", "mv . visitInsn ( FCMPG )  ;", "mv . visitJumpInsn ( compInstruction 1  ,    elseTarget )  ;", "} else", "if    ( targetType    =  =     ' J '  )     {", "mv . visitInsn ( LCMP )  ;", "mv . visitJumpInsn ( compInstruction 1  ,    elseTarget )  ;", "} else", "if    ( targetType    =  =     ' I '  )     {", "mv . visitJumpInsn ( compInstruction 2  ,    elseTarget )  ;", "} else    {", "throw   new   IllegalStateException (  (  \" Unexpected   descriptor    \"     +    leftDesc )  )  ;", "}", "mv . visitInsn ( ICONST _  1  )  ;", "mv . visitJumpInsn ( GOTO ,    endOfIf )  ;", "mv . visitLabel ( elseTarget )  ;", "mv . visitInsn ( ICONST _  0  )  ;", "mv . visitLabel ( endOfIf )  ;", "cf . pushDescriptor (  \" Z \"  )  ;", "}", "METHOD_END"], "methodName": ["generateComparisonCode"], "fileName": "org.springframework.expression.spel.ast.Operator"}, {"methodBody": ["METHOD_START", "{", "return   this . children [  0  ]  ;", "}", "METHOD_END"], "methodName": ["getLeftOperand"], "fileName": "org.springframework.expression.spel.ast.Operator"}, {"methodBody": ["METHOD_START", "{", "return   this . operatorName ;", "}", "METHOD_END"], "methodName": ["getOperatorName"], "fileName": "org.springframework.expression.spel.ast.Operator"}, {"methodBody": ["METHOD_START", "{", "return   this . children [  1  ]  ;", "}", "METHOD_END"], "methodName": ["getRightOperand"], "fileName": "org.springframework.expression.spel.ast.Operator"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   left    =    getLeftOperand (  )  ;", "SpelNodeImpl   right    =    getRightOperand (  )  ;", "if    (  (  !  ( left . isCompilable (  )  )  )     |  |     (  !  ( right . isCompilable (  )  )  )  )     {", "return   false ;", "}", "String   leftDesc    =    left . exitTypeDescriptor ;", "String   rightDesc    =    right . exitTypeDescriptor ;", ". DescriptorComparison   dc    =     . DescriptorComparison . checkNumericCompatibility ( leftDesc ,    rightDesc ,    this . leftActualDescriptor ,    this . rightActualDescriptor )  ;", "return    ( dc . areNumbers )     &  &     ( dc . areCompatible )  ;", "}", "METHOD_END"], "methodName": ["isCompilableOperatorUsingNumerics"], "fileName": "org.springframework.expression.spel.ast.Operator"}, {"methodBody": ["METHOD_START", "{", "if    ( oldType    =  =    null )     {", "return   newType ;", "}", "if    ( oldType . isAssignableFrom ( newType )  )     {", "return   oldType ;", "}", "Class <  ?  >    nextType    =    newType ;", "while    ( nextType    !  =     ( Ob . class )  )     {", "if    ( nextType . isAssignableFrom ( oldType )  )     {", "return   nextType ;", "}", "nextType    =    nextType . getSuperclass (  )  ;", "}", "for    ( Class <  ?  >    nextInterface    :    ClassUtils . getAllInterfacesForClassAsSet ( newType )  )     {", "if    ( nextInterface . isAssignableFrom ( oldType )  )     {", "return   nextInterface ;", "}", "}", "return   Ob . class ;", "}", "METHOD_END"], "methodName": ["determineCommonType"], "fileName": "org.springframework.expression.spel.ast.Projection"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.expression.spel.ast.PropertyOrFieldReference"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetType    =     ( contextObject    !  =    null )     ?    contextObject . getClass (  )     :    null ;", "List < Accessor >    specificAccessors    =    new   ArrayList <  >  (  )  ;", "List < Accessor >    generalAccessors    =    new   ArrayList <  >  (  )  ;", "for    ( Accessor   resolver    :    propertyAccessors )     {", "Class <  ?  >  [  ]    targets    =    resolver . getSpecificTargetClasses (  )  ;", "if    ( targets    =  =    null )     {", "generalAccessors . add ( resolver )  ;", "} else", "if    ( targetType    !  =    null )     {", "for    ( Class <  ?  >    clazz    :    targets )     {", "if    ( clazz    =  =    targetType )     {", "specificAccessors . add ( resolver )  ;", "break ;", "} else", "if    ( clazz . isAssignableFrom ( targetType )  )     {", "generalAccessors . add ( resolver )  ;", "}", "}", "}", "}", "List < Accessor >    resolvers    =    new   ArrayList <  >  (  )  ;", "resolvers . addAll ( specificAccessors )  ;", "generalAccessors . removeAll ( specificAccessors )  ;", "resolvers . addAll ( generalAccessors )  ;", "return   resolvers ;", "}", "METHOD_END"], "methodName": ["getPropertyAccessorsToTry"], "fileName": "org.springframework.expression.spel.ast.PropertyOrFieldReference"}, {"methodBody": ["METHOD_START", "{", "TypedValue   result    =    readProperty ( contextObject ,    evalContext ,    this . name )  ;", "if    (  (  (  ( result . getValue (  )  )     =  =    null )     &  &    isAutoGrowNullReferences )     &  &     ( nextChildIs ( Indexer . class ,    PropertyOrFieldReference . class )  )  )     {", "TypeDescriptor   resultDescriptor    =    result . getTypeDescriptor (  )  ;", "Assert . state (  ( resultDescriptor    !  =    null )  ,     \" No   result   type \"  )  ;", "if    (  ( List . class )     =  =     ( resultDescriptor . getType (  )  )  )     {", "if    ( isWritableProperty ( this . name ,    contextObject ,    evalContext )  )     {", "List <  ?  >    newList    =    new   ArrayList <  >  (  )  ;", "writeProperty ( contextObject ,    evalContext ,    this . name ,    newList )  ;", "result    =    readProperty ( contextObject ,    evalContext ,    this . name )  ;", "}", "} else", "if    (  ( class )     =  =     ( resultDescriptor . getType (  )  )  )     {", "if    ( isWritableProperty ( this . name ,    contextObject ,    evalContext )  )     {", "Map <  ?  ,     ?  >    newMap    =    new   HashMap <  >  (  )  ;", "writeProperty ( contextObject ,    evalContext ,    this . name ,    newMap )  ;", "result    =    readProperty ( contextObject ,    evalContext ,    this . name )  ;", "}", "} else    {", "try    {", "if    ( isWritableProperty ( this . name ,    contextObject ,    evalContext )  )     {", "Class <  ?  >    clazz    =    result . getTypeDescriptor (  )  . getType (  )  ;", "Object   newObject    =    accessibleConstructor ( clazz )  . newInstance (  )  ;", "writeProperty ( contextObject ,    evalContext ,    this . name ,    newObject )  ;", "result    =    readProperty ( contextObject ,    evalContext ,    this . name )  ;", "}", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    ex . getTargetException (  )  ,    SpelMessage . UNABLE _ TO _ DYNAMICALLY _ CREATE _ OBJECT ,    result . getTypeDescriptor (  )  . getType (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    ex ,    SpelMessage . UNABLE _ TO _ DYNAMICALLY _ CREATE _ OBJECT ,    result . getTypeDescriptor (  )  . getType (  )  )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getValueInternal"], "fileName": "org.springframework.expression.spel.ast.PropertyOrFieldReference"}, {"methodBody": ["METHOD_START", "{", "return   this . nullSafe ;", "}", "METHOD_END"], "methodName": ["isNullSafe"], "fileName": "org.springframework.expression.spel.ast.PropertyOrFieldReference"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    contextObject . getValue (  )  ;", "if    ( value    !  =    null )     {", "List < Accessor >    accessorsToTry    =    getAccessorsToTry ( contextObject . getValue (  )  ,    evalContext . getAccessors (  )  )  ;", "for    ( Accessor   accessor    :    accessorsToTry )     {", "try    {", "if    ( accessor . canWrite ( evalContext ,    value ,    name )  )     {", "return   true ;", "}", "}    catch    ( AccessException   ex )     {", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isWritableProperty"], "fileName": "org.springframework.expression.spel.ast.PropertyOrFieldReference"}, {"methodBody": ["METHOD_START", "{", "Object   targetObject    =    contextObject . getValue (  )  ;", "if    (  ( targetObject    =  =    null )     &  &     ( this . nullSafe )  )     {", "return   TypedValue . NULL ;", "}", "Accessor   accessorToUse    =    this . cachedReadAccessor ;", "if    ( accessorToUse    !  =    null )     {", "if    ( evalContext . getAccessors (  )  . contains ( accessorToUse )  )     {", "try    {", "return   accessorToUse . read ( evalContext ,    contextObject . getValue (  )  ,    name )  ;", "}    catch    ( Exception   ex )     {", "}", "}", "this . cachedReadAccessor    =    null ;", "}", "List < Accessor >    accessorsToTry    =    getAccessorsToTry ( contextObject . getValue (  )  ,    evalContext . getAccessors (  )  )  ;", "try    {", "for    ( Accessor   accessor    :    accessorsToTry )     {", "if    ( accessor . canRead ( evalContext ,    contextObject . getValue (  )  ,    name )  )     {", "if    ( accessor   instanceof   ReflectiveAccessor )     {", "accessor    =     (  ( ReflectiveAccessor )     ( accessor )  )  . createOptimalAccessor ( evalContext ,    contextObject . getValue (  )  ,    name )  ;", "}", "this . cachedReadAccessor    =    accessor ;", "return   accessor . read ( evalContext ,    contextObject . getValue (  )  ,    name )  ;", "}", "}", "}    catch    ( Exception   ex )     {", "throw   new   SpelEvaluationException ( ex ,    SpelMessage . EXCEPTION _ DURING _ PROPERTY _ READ ,    name ,    ex . getMessage (  )  )  ;", "}", "if    (  ( contextObject . getValue (  )  )     =  =    null )     {", "throw   new   SpelEvaluationException ( SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ READABLE _ ON _ NULL ,    name )  ;", "} else    {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ READABLE ,    name ,    FormatHelper . formatClassNameForMessage ( getObjectClass ( contextObject . getValue (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readProperty"], "fileName": "org.springframework.expression.spel.ast.PropertyOrFieldReference"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . nullSafe )     &  &     ( CodeFlow . isPrimitive ( descriptor )  )  )     {", "this . originalPrimitiveExitTypeDescriptor    =    descriptor ;", "thisitTypeDescriptor    =    CodeFlow . toBoxedDescriptor ( descriptor )  ;", "} else    {", "thisitTypeDescriptor    =    descriptor ;", "}", "}", "METHOD_END"], "methodName": ["setExitTypeDescriptor"], "fileName": "org.springframework.expression.spel.ast.PropertyOrFieldReference"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( contextObject . getValue (  )  )     =  =    null )     &  &     ( this . nullSafe )  )     {", "return ;", "}", "if    (  ( contextObject . getValue (  )  )     =  =    null )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ WRITABLE _ ON _ NULL ,    name )  ;", "}", "Accessor   accessorToUse    =    this . cachedWriteAccessor ;", "if    ( accessorToUse    !  =    null )     {", "if    ( evalContext . getAccessors (  )  . contains ( accessorToUse )  )     {", "try    {", "accessorToUse . write ( evalContext ,    contextObject . getValue (  )  ,    name ,    newValue )  ;", "return ;", "}    catch    ( Exception   ex )     {", "}", "}", "this . cachedWriteAccessor    =    null ;", "}", "List < Accessor >    accessorsToTry    =    getAccessorsToTry ( contextObject . getValue (  )  ,    evalContext . getAccessors (  )  )  ;", "try    {", "for    ( Accessor   accessor    :    accessorsToTry )     {", "if    ( accessor . canWrite ( evalContext ,    contextObject . getValue (  )  ,    name )  )     {", "this . cachedWriteAccessor    =    accessor ;", "accessor . write ( evalContext ,    contextObject . getValue (  )  ,    name ,    newValue )  ;", "return ;", "}", "}", "}    catch    ( AccessException   ex )     {", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    ex ,    SpelMessage . EXCEPTION _ DURING _ PROPERTY _ WRITE ,    name ,    ex . getMessage (  )  )  ;", "}", "throw   new   SpelEvaluationException ( getStartPosition (  )  ,    SpelMessage . PROPERTY _ OR _ FIELD _ NOT _ WRITABLE ,    name ,    FormatHelper . formatClassNameForMessage ( getObjectClass ( contextObject . getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeProperty"], "fileName": "org.springframework.expression.spel.ast.PropertyOrFieldReference"}, {"methodBody": ["METHOD_START", "{", "throw   new   IllegalStateException (  (  ( getClass (  )  . getName (  )  )     +     \"    has   no   generateCode (  .  .  )    method \"  )  )  ;", "}", "METHOD_END"], "methodName": ["generateCode"], "fileName": "org.springframework.expression.spel.ast.SpelNodeImpl"}, {"methodBody": ["METHOD_START", "{", "cf . enterCompilationScope (  )  ;", "argument . generateCode ( mv ,    cf )  ;", "St   lastDesc    =    cf . lastDescriptor (  )  ;", "Assert . state (  ( lastDesc    !  =    null )  ,     \" No   last   descriptor \"  )  ;", "boolean   primitiveOnStack    =    CodeFlow . isPrimitive ( lastDesc )  ;", "if    ( primitiveOnStack    &  &     (  ( paramDesc . charAt (  0  )  )     =  =     ' L '  )  )     {", "CodeFlow . insertBoxIfNecessary ( mv ,    lastDesc . charAt (  0  )  )  ;", "} else", "if    (  (  ( paramDesc . length (  )  )     =  =     1  )     &  &     (  ! primitiveOnStack )  )     {", "CodeFlow . insertUnboxInsns ( mv ,    paramDesc . charAt (  0  )  ,    lastDesc )  ;", "} else", "if    (  !  ( paramDesc . equals ( lastDesc )  )  )     {", "CodeFlow . insertCheckCast ( mv ,    paramDesc )  ;", "}", "cf . exitCompilationScope (  )  ;", "}", "METHOD_END"], "methodName": ["generateCodeForArgument"], "fileName": "org.springframework.expression.spel.ast.SpelNodeImpl"}, {"methodBody": ["METHOD_START", "{", "String [  ]    paramDescriptors    =    null ;", "boolean   isVarargs    =    false ;", "if    ( member   instanceof   Constructor )     {", "Constructor <  ?  >    ctor    =     (  ( Constructor <  ?  >  )     ( member )  )  ;", "paramDescriptors    =    CodeFlow . toDescriptors ( ctor . getParameterTypes (  )  )  ;", "isVarargs    =    ctor . isVarArgs (  )  ;", "} else    {", "Method   method    =     (  ( Method )     ( member )  )  ;", "paramDescriptors    =    CodeFlow . toDescriptors ( method . getParameterTypes (  )  )  ;", "isVarargs    =    method . isVarArgs (  )  ;", "}", "if    ( isVarargs )     {", "int   p    =     0  ;", "int   childCount    =    arguments . length ;", "for    ( p    =     0  ;    p    <     (  ( paramDescriptors . length )     -     1  )  ;    p +  +  )     {", ". generateCodeForArgument ( mv ,    cf ,    arguments [ p ]  ,    paramDescriptors [ p ]  )  ;", "}", "lastChild    =     ( childCount    =  =     0  )     ?    null    :    arguments [  ( childCount    -     1  )  ]  ;", "String   arrayType    =    paramDescriptors [  (  ( paramDescriptors . length )     -     1  )  ]  ;", "if    (  ( lastChild    !  =    null )     &  &     ( arrayType . equals ( lastChild . getExitDescriptor (  )  )  )  )     {", ". generateCodeForArgument ( mv ,    cf ,    lastChild ,    paramDescriptors [ p ]  )  ;", "} else    {", "arrayType    =    arrayType . substring (  1  )  ;", "CodeFlow . insertNewArrayCode ( mv ,     ( childCount    -    p )  ,    arrayType )  ;", "int   arrayindex    =     0  ;", "while    ( p    <    childCount )     {", "child    =    arguments [ p ]  ;", "mv . visitInsn ( DUP )  ;", "CodeFlow . insertOptimalLoad ( mv ,     ( arrayindex +  +  )  )  ;", ". generateCodeForArgument ( mv ,    cf ,    child ,    arrayType )  ;", "CodeFlow . insertArrayStore ( mv ,    arrayType )  ;", "p +  +  ;", "}", "}", "} else    {", "for    ( int   i    =     0  ;    i    <     ( paramDescriptors . length )  ;    i +  +  )     {", ". generateCodeForArgument ( mv ,    cf ,    arguments [ i ]  ,    paramDescriptors [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["generateCodeForArguments"], "fileName": "org.springframework.expression.spel.ast.SpelNodeImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . exitTypeDescriptor ;", "}", "METHOD_END"], "methodName": ["getExitDescriptor"], "fileName": "org.springframework.expression.spel.ast.SpelNodeImpl"}, {"methodBody": ["METHOD_START", "{", "return   ExpressionUtils . convertTypedValue ( state . getEvaluationContext (  )  ,    getValueInternal ( state )  ,    desiredReturnType )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.expression.spel.ast.SpelNodeImpl"}, {"methodBody": ["METHOD_START", "{", "throw   new   SpelEvaluationException ( this . pos ,    SpelMessage . NOT _ ASSIGNABLE ,    toStringAST (  )  )  ;", "}", "METHOD_END"], "methodName": ["getValueRef"], "fileName": "org.springframework.expression.spel.ast.SpelNodeImpl"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isCompilable"], "fileName": "org.springframework.expression.spel.ast.SpelNodeImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . parent )     !  =    null )     {", "[  ]    peers    =    this . parent . children ;", "for    ( int   i    =     0  ,    max    =    peers . length ;    i    <    max ;    i +  +  )     {", "if    (  ( this )     =  =     ( peers [ i ]  )  )     {", "if    (  ( i    +     1  )     >  =    max )     {", "return   false ;", "}", "Class <  ?  >    clazz    =    peers [  ( i    +     1  )  ]  . getClass (  )  ;", "for    ( Class <  ?  >    desiredClazz    :    clazzes )     {", "if    ( clazz . equals ( desiredClazz )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["nextChildIs"], "fileName": "org.springframework.expression.spel.ast.SpelNodeImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( this . exitTypeDescriptor )     =  =    null )     &  &     (  ( this . children [  1  ]  . exitTypeDescriptor )     !  =    null )  )     &  &     (  ( this . children [  2  ]  . exitTypeDescriptor )     !  =    null )  )     {", "St   leftDescriptor    =    this . children [  1  ]  . exitTypeDescriptor ;", "St   rightDescriptor    =    this . children [  2  ]  . exitTypeDescriptor ;", "if    ( ObjectUtils . nullSafeEquals ( leftDescriptor ,    rightDescriptor )  )     {", "this . exitTypeDescriptor    =    leftDescriptor ;", "} else    {", "this . exitTypeDescriptor    =     \" Ljava / lang / Object \"  ;", "}", "}", "}", "METHOD_END"], "methodName": ["computeExitTypeDescriptor"], "fileName": "org.springframework.expression.spel.ast.Ternary"}, {"methodBody": ["METHOD_START", "{", "TypeCode [  ]    allValues    =    TypeCode . values (  )  ;", "for    ( TypeCode   typeCode    :    allValues )     {", "if    ( clazz    =  =     ( typeCode . getType (  )  )  )     {", "return   typeCode ;", "}", "}", "return   TypeCode . OBJECT ;", "}", "METHOD_END"], "methodName": ["forClass"], "fileName": "org.springframework.expression.spel.ast.TypeCode"}, {"methodBody": ["METHOD_START", "{", "String   searchingFor    =    name . toUpperCase (  )  ;", "[  ]    tcs    =     . values (  )  ;", "for    ( int   i    =     1  ;    i    <     ( tcs . length )  ;    i +  +  )     {", "if    ( tcs [ i ]  . name (  )  . equals ( searchingFor )  )     {", "return   tcs [ i ]  ;", "}", "}", "return    . OBJECT ;", "}", "METHOD_END"], "methodName": ["forName"], "fileName": "org.springframework.expression.spel.ast.TypeCode"}, {"methodBody": ["METHOD_START", "{", "return   this . type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.springframework.expression.spel.ast.TypeCode"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . dimensions )     !  =     0  )     {", "for    ( int   i    =     0  ;    i    <     ( this . dimensions )  ;    i +  +  )     {", "Object   array    =    Array . newInstance ( clazz ,     0  )  ;", "clazz    =    array . getClass (  )  ;", "}", "}", "return   clazz ;", "}", "METHOD_END"], "methodName": ["makeArrayIfNecessary"], "fileName": "org.springframework.expression.spel.ast.TypeReference"}, {"methodBody": ["METHOD_START", "{", "if    ( operandExpression    =  =    null )     {", "throw   internalException ( token . startPos ,    SpelMessage . LEFT _ OPERAND _ PROBLEM )  ;", "}", "}", "METHOD_END"], "methodName": ["checkLeftOperand"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "checkLeftOperand ( token ,    left )  ;", "checkRightOperand ( token ,    right )  ;", "}", "METHOD_END"], "methodName": ["checkOperands"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( operandExpression    =  =    null )     {", "throw   internalException ( token . startPos ,    SpelMessage . RIGHT _ OPERAND _ PROBLEM )  ;", "}", "}", "METHOD_END"], "methodName": ["checkRightOperand"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "Assert . state (  ( t    !  =    null )  ,     \" Expected   token \"  )  ;", "int   pos    =    t . startPos ;", "Token   next ;", "do    {", "nextToken (  )  ;", "t    =    peekToken (  )  ;", "if    ( t    =  =    null )     {", "throw   internalException ( pos ,    SpelMessage . RUN _ OUT _ OF _ ARGUMENTS )  ;", "}", "if    (  ( t . kind )     !  =     ( TokenKind . RPAREN )  )     {", "accumulatedArguments . add ( eat (  )  )  ;", "}", "next    =    peekToken (  )  ;", "}    while    (  ( next    !  =    null )     &  &     (  ( next . kind )     =  =     ( TokenKind . COMMA )  )     )  ;", "if    ( next    =  =    null )     {", "throw   internalException ( pos ,    SpelMessage . RUN _ OUT _ OF _ ARGUMENTS )  ;", "}", "}", "METHOD_END"], "methodName": ["consumeArguments"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( peekToken ( TokenKind . LPAREN )  )  )     {", "throw   new   InternalParseException ( new   SpelParseException ( thisString ,    positionOf ( peekToken (  )  )  ,    SpelMessage . MISSING _ CONSTRUCTOR _ ARGS )  )  ;", "}", "consumeArguments ( accumulatedArguments )  ;", "eatToken ( TokenKind . RPAREN )  ;", "}", "METHOD_END"], "methodName": ["eatConstructorArgs"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    takeToken (  )  ;", "boolean   nullSafeNavigation    =     ( t . kind )     =  =     ( TokenKind . SAFE _ NAVI )  ;", "if    (  (  (  ( maybeEatMethodOrProperty ( nullSafeNavigation )  )     |  |     ( maybeEatFunctionOrVar (  )  )  )     |  |     ( maybeEatProjection ( nullSafeNavigation )  )  )     |  |     ( maybeEatSelection ( nullSafeNavigation )  )  )     {", "return   pop (  )  ;", "}", "if    (  ( peekToken (  )  )     =  =    null )     {", "throw   iException ( t . startPos ,    SpelMessage . OOD )  ;", "} else    {", "throw   iException ( t . startPos ,    SpelMessage . UNEXPECTED _ DATA _ AFTER _ DOT ,    toString ( peekToken (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["eatDottedNode"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   expr    =    eatLogicalOrExpression (  )  ;", "Token   t    =    peekToken (  )  ;", "if    ( t    !  =    null )     {", "if    (  ( t . kind )     =  =     ( TokenKind . ASSIGN )  )     {", "if    ( expr    =  =    null )     {", "expr    =    new   NullLiteral ( toPos (  (  ( t . startPos )     -     1  )  ,     (  ( t . endPos )     -     1  )  )  )  ;", "}", "nextToken (  )  ;", "SpelNodeImpl   assignedValue    =    eatLogicalOrExpression (  )  ;", "return   new   Assign ( toPos ( t )  ,    expr ,    assignedValue )  ;", "}", "if    (  ( t . kind )     =  =     ( TokenKind . ELVIS )  )     {", "if    ( expr    =  =    null )     {", "expr    =    new   NullLiteral ( toPos (  (  ( t . startPos )     -     1  )  ,     (  ( t . endPos )     -     2  )  )  )  ;", "}", "nextToken (  )  ;", "SpelNodeImpl   valueIfNull    =    eatExpression (  )  ;", "if    ( valueIfNull    =  =    null )     {", "valueIfNull    =    new   NullLiteral ( toPos (  (  ( t . startPos )     +     1  )  ,     (  ( t . endPos )     +     1  )  )  )  ;", "}", "return   new   Elvis ( toPos ( t )  ,    expr ,    valueIfNull )  ;", "}", "if    (  ( t . kind )     =  =     ( TokenKind . QMARK )  )     {", "if    ( expr    =  =    null )     {", "expr    =    new   NullLiteral ( toPos (  (  ( t . startPos )     -     1  )  ,     (  ( t . endPos )     -     1  )  )  )  ;", "}", "nextToken (  )  ;", "SpelNodeImpl   ifTrueExprValue    =    eatExpression (  )  ;", "eatToken ( TokenKind . COLON )  ;", "SpelNodeImpl   ifFalseExprValue    =    eatExpression (  )  ;", "return   new   Ternary ( toPos ( t )  ,    expr ,    ifTrueExprValue ,    ifFalseExprValue )  ;", "}", "}", "return   expr ;", "}", "METHOD_END"], "methodName": ["eatExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   expr    =    eatRelationalExpression (  )  ;", "while    (  ( peekIdentifierToken (  \" and \"  )  )     |  |     ( peekToken ( TokenKind . SYMBOLIC _ AND )  )  )     {", "Token   t    =    takeToken (  )  ;", "SpelNodeImpl   rhExpr    =    eatRelationalExpression (  )  ;", "checkOperands ( t ,    expr ,    rhExpr )  ;", "expr    =    new   OpAnd ( toPos ( t )  ,    expr ,    rhExpr )  ;", "}", "return   expr ;", "}", "METHOD_END"], "methodName": ["eatLogicalAndExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   expr    =    eatLogicalAndExpression (  )  ;", "while    (  ( peekIdentifierToken (  \" or \"  )  )     |  |     ( peekToken ( TokenKind . SYMBOLIC _ OR )  )  )     {", "Token   t    =    takeToken (  )  ;", "SpelNodeImpl   rhExpr    =    eatLogicalAndExpression (  )  ;", "checkOperands ( t ,    expr ,    rhExpr )  ;", "expr    =    new   OpOr ( toPos ( t )  ,    expr ,    rhExpr )  ;", "}", "return   expr ;", "}", "METHOD_END"], "methodName": ["eatLogicalOrExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "return   peekToken ( TokenKind . DOT ,    TokenKind . SAFE _ NAVI )     ?    eatDottedNode (  )     :    eatNonDottedNode (  )  ;", "}", "METHOD_END"], "methodName": ["eatNode"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( peekToken ( TokenKind . LSQUARE )  )     {", "if    ( maybeEatIndexer (  )  )     {", "return   pop (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["eatNonDottedNode"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "LinkedList < SpelNodeImpl >    qualifiedIdPieces    =    new   LinkedList <  >  (  )  ;", "Token   node    =    peekToken (  )  ;", "while    ( isValidQualifiedId ( node )  )     {", "nextToken (  )  ;", "if    (  ( node . kind )     !  =     ( TokenKind . DOT )  )     {", "qualifiedIdPieces . add ( new   Identifier ( node . stringValue (  )  ,    toPos ( node )  )  )  ;", "}", "node    =    peekToken (  )  ;", "}", "if    ( qualifiedIdPieces . isEmpty (  )  )     {", "if    ( node    =  =    null )     {", "throw   internalException ( thisString . length (  )  ,    SpelMessage . OOD )  ;", "}", "throw   internalException ( node . startPos ,    SpelMessage . NOT _ EXPECTED _ TOKEN ,     \" qualified   ID \"  ,    node . getKind (  )  . toString (  )  . toLowerCase (  )  )  ;", "}", "int   pos    =    toPos ( qualifiedIdPieces . getFirst (  )  . getStartPosition (  )  ,    qualifiedIdPieces . getLast (  )  . getEndPosition (  )  )  ;", "return   new   QualifiedIdentifier ( pos ,    qualifiedIdPieces . toArray ( new   SpelNodeImpl [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["eatPossiblyQualifiedId"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   expr    =    eatUnaryExpression (  )  ;", "if    ( peekToken ( TokenKind . POWER )  )     {", "Token   t    =    takeToken (  )  ;", "SpelNodeImpl   rhExpr    =    eatUnaryExpression (  )  ;", "checkRightOperand ( t ,    rhExpr )  ;", "return   new   OperatorPower ( toPos ( t )  ,    expr ,    rhExpr )  ;", "}", "if    (  ( expr    !  =    null )     &  &     ( peekToken ( TokenKind . INC ,    TokenKind . DEC )  )  )     {", "Token   t    =    takeToken (  )  ;", "if    (  ( t . getKind (  )  )     =  =     ( TokenKind . INC )  )     {", "return   new   OpInc ( toPos ( t )  ,    true ,    expr )  ;", "}", "return   new   OpDec ( toPos ( t )  ,    true ,    expr )  ;", "}", "return   expr ;", "}", "METHOD_END"], "methodName": ["eatPowerIncDecExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   start    =    eatStartNode (  )  ;", "List < SpelNodeImpl >    nodes    =    null ;", "SpelNodeImpl   node    =    eatNode (  )  ;", "while    ( node    !  =    null )     {", "if    ( nodes    =  =    null )     {", "nodes    =    new   ArrayList <  >  (  4  )  ;", "nodes . add ( start )  ;", "}", "nodes . add ( node )  ;", "node    =    eatNode (  )  ;", "}", "if    (  ( start    =  =    null )     |  |     ( nodes    =  =    null )  )     {", "return   start ;", "}", "return   new   Compound ( toPos ( start . getStartPosition (  )  ,    nodes . get (  (  ( nodes . size (  )  )     -     1  )  )  . getEndPosition (  )  )  ,    nodes . toArray ( new   SpelNodeImpl [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["eatPrimaryExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   expr    =    eatPowerIncDecExpression (  )  ;", "while    ( peekToken ( TokenKind . STAR ,    TokenKind . DIV ,    TokenKind . MOD )  )     {", "Token   t    =    takeToken (  )  ;", "SpelNodeImpl   rhExpr    =    eatPowerIncDecExpression (  )  ;", "checkOperands ( t ,    expr ,    rhExpr )  ;", "if    (  ( t . kind )     =  =     ( TokenKind . STAR )  )     {", "expr    =    new   OpMultiply ( toPos ( t )  ,    expr ,    rhExpr )  ;", "} else", "if    (  ( t . kind )     =  =     ( TokenKind . DIV )  )     {", "expr    =    new   ast . OpDivide ( toPos ( t )  ,    expr ,    rhExpr )  ;", "} else    {", "isTrue (  (  ( t . kind )     =  =     ( TokenKind . MOD )  )  ,     \" Mod   token   expected \"  )  ;", "expr    =    new   ast . OpModulus ( toPos ( t )  ,    expr ,    rhExpr )  ;", "}", "}", "return   expr ;", "}", "METHOD_END"], "methodName": ["eatProductExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   expr    =    eatSumExpression (  )  ;", "Token   relationalOperatorToken    =    maybeEatRelationalOperator (  )  ;", "if    ( relationalOperatorToken    !  =    null )     {", "Token   t    =    takeToken (  )  ;", "SpelNodeImpl   rhExpr    =    eatSumExpression (  )  ;", "checkOperands ( t ,    expr ,    rhExpr )  ;", "TokenKind   tk    =    relationalOperatorToken . kind ;", "if    ( relationalOperatorToken . isNumericRelationalOperator (  )  )     {", "int   pos    =    toPos ( t )  ;", "if    ( tk    =  =     ( TokenKind . GT )  )     {", "return   new   OpGT ( pos ,    expr ,    rhExpr )  ;", "}", "if    ( tk    =  =     ( TokenKind . LT )  )     {", "return   new   OpLT ( pos ,    expr ,    rhExpr )  ;", "}", "if    ( tk    =  =     ( TokenKind . LE )  )     {", "return   new   OpLE ( pos ,    expr ,    rhExpr )  ;", "}", "if    ( tk    =  =     ( TokenKind . GE )  )     {", "return   new   OpGE ( pos ,    expr ,    rhExpr )  ;", "}", "if    ( tk    =  =     ( TokenKind . EQ )  )     {", "return   new   OpEQ ( pos ,    expr ,    rhExpr )  ;", "}", "Assert . isTrue (  ( tk    =  =     ( TokenKind . NE )  )  ,     \" Not - equals   token   expected \"  )  ;", "return   new   OpNE ( pos ,    expr ,    rhExpr )  ;", "}", "if    ( tk    =  =     ( TokenKind . INSTANCEOF )  )     {", "return   new   OperatorInstanceof ( toPos ( t )  ,    expr ,    rhExpr )  ;", "}", "if    ( tk    =  =     ( TokenKind . MATCHES )  )     {", "return   new   OperatorMatches ( toPos ( t )  ,    expr ,    rhExpr )  ;", "}", "Assert . isTrue (  ( tk    =  =     ( TokenKind . BETWEEN )  )  ,     \" Between   token   expected \"  )  ;", "return   new   OperatorBetween ( toPos ( t )  ,    expr ,    rhExpr )  ;", "}", "return   expr ;", "}", "METHOD_END"], "methodName": ["eatRelationalExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( maybeEatLiteral (  )  )     {", "return   pop (  )  ;", "} else", "if    ( maybeEatParen (  )  )     {", "return   pop (  )  ;", "} else", "if    (  (  (  (  ( maybeEatTypeReference (  )  )     |  |     ( maybeEatNullReference (  )  )  )     |  |     ( maybeEatConstructorReference (  )  )  )     |  |     ( maybeEatMethodOrProperty ( false )  )  )     |  |     ( maybeEatFunctionOrVar (  )  )  )     {", "return   pop (  )  ;", "} else", "if    ( maybeEatBeanReference (  )  )     {", "return   pop (  )  ;", "} else", "if    (  (  ( maybeEatProjection ( false )  )     |  |     ( maybeEatSelection ( false )  )  )     |  |     ( maybeEatIndexer (  )  )  )     {", "return   pop (  )  ;", "} else", "if    ( maybeEatInlineListOrMap (  )  )     {", "return   pop (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["eatStartNode"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "SpelNodeImpl   expr    =    eatProductExpression (  )  ;", "while    ( peekToken ( TokenKind . PLUS ,    TokenKind . MINUS ,    TokenKind . INC )  )     {", "Token   t    =    takeToken (  )  ;", "SpelNodeImpl   rhExpr    =    eatProductExpression (  )  ;", "checkRightOperand ( t ,    rhExpr )  ;", "if    (  ( t . kind )     =  =     ( TokenKind . PLUS )  )     {", "expr    =    new   OpPlus ( toPos ( t )  ,    expr ,    rhExpr )  ;", "} else", "if    (  ( t . kind )     =  =     ( TokenKind . MINUS )  )     {", "expr    =    new   ast . OpMinus ( toPos ( t )  ,    expr ,    rhExpr )  ;", "}", "}", "return   expr ;", "}", "METHOD_END"], "methodName": ["eatSumExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    nextToken (  )  ;", "if    ( t    =  =    null )     {", "int   pos    =    thisString . length (  )  ;", "throw   internalException ( pos ,    SpelMessage . OOD )  ;", "}", "if    (  ( t . kind )     !  =    expectedKind )     {", "throw   internalException ( t . startPos ,    SpelMessage . NOT _ EXPECTED _ TOKEN ,    expectedKind . toString (  )  . toLowerCase (  )  ,    t . getKind (  )  . toString (  )  . toLowerCase (  )  )  ;", "}", "return   t ;", "}", "METHOD_END"], "methodName": ["eatToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( peekToken ( TokenKind . PLUS ,    TokenKind . MINUS ,    TokenKind . NOT )  )     {", "Token   t    =    takeToken (  )  ;", "SpelNodeImpl   expr    =    eatUnary (  )  ;", "Assert . state (  ( expr    !  =    null )  ,     \" No   node \"  )  ;", "if    (  ( t . kind )     =  =     ( TokenKind . NOT )  )     {", "return   new   OperatorNot ( toPos ( t )  ,    expr )  ;", "}", "if    (  ( t . kind )     =  =     ( TokenKind . PLUS )  )     {", "return   new   OpPlus ( toPos ( t )  ,    expr )  ;", "}", "Assert . isTrue (  (  ( t . kind )     =  =     ( TokenKind . MINUS )  )  ,     \" Minus   token   expected \"  )  ;", "return   new   OpMinus ( toPos ( t )  ,    expr )  ;", "}", "if    ( peekToken ( TokenKind . INC ,    TokenKind . DEC )  )     {", "Token   t    =    takeToken (  )  ;", "SpelNodeImpl   expr    =    eatUnary (  )  ;", "if    (  ( t . getKind (  )  )     =  =     ( TokenKind . INC )  )     {", "return   new   OpInc ( toPos ( t )  ,    false ,    expr )  ;", "}", "return   new   OpDec ( toPos ( t )  ,    false ,    expr )  ;", "}", "return   eatPrimary (  )  ;", "}", "METHOD_END"], "methodName": ["eatUnaryExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "return   new   InternalParseException ( new   SpelParseException ( this . expressionString ,    pos ,    message ,    inserts )  )  ;", "}", "METHOD_END"], "methodName": ["internalException"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( node    =  =    null )     |  |     (  ( node . kind )     =  =     ( TokenKind . LITERAL _ STRING )  )  )     {", "return   false ;", "}", "if    (  (  ( node . kind )     =  =     ( TokenKind . DOT )  )     |  |     (  ( node . kind )     =  =     ( TokenKind . IDENTIFIER )  )  )     {", "return   true ;", "}", "String   value    =    node . stringValue (  )  ;", "return    ( StringUtils . hasLength ( value )  )     &  &     (  . VALID _ QUALIFIED _ ID _ PATTERN . matcher ( value )  . matches (  )  )  ;", "}", "METHOD_END"], "methodName": ["isValidQualifiedId"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( peekToken ( TokenKind . BEAN _ REF )  )     |  |     ( peekToken ( TokenKind . FACTORY _ BEAN _ REF )  )  )     {", "Token   beanRefToken    =    takeToken (  )  ;", "Token   beanNameToken    =    null ;", "String   beanName    =    null ;", "if    ( peekToken ( TokenKind . IDENTIFIER )  )     {", "beanNameToken    =    eatToken ( TokenKind . IDENTIFIER )  ;", "beanName    =    beanNameToken . stringValue (  )  ;", "} else", "if    ( peekToken ( TokenKind . LITERAL _ STRING )  )     {", "beanNameToken    =    eatToken ( TokenKind . LITERAL _ STRING )  ;", "beanName    =    beanNameToken . stringValue (  )  ;", "beanName    =    beanName . substring (  1  ,     (  ( beanName . length (  )  )     -     1  )  )  ;", "} else    {", "throw   internalException ( beanRefToken . startPos ,    SpelMessage . INVALID _ BEAN _ REFERENCE )  ;", "}", "BeanReference   beanReference ;", "if    (  ( beanRefToken . getKind (  )  )     =  =     ( TokenKind . FACTORY _ BEAN _ REF )  )     {", "String   beanNameString    =     ( String . valueOf ( TokenKind . FACTORY _ BEAN _ REF . tokenChars )  )     +    beanName ;", "beanReference    =    new   BeanReference ( toPos ( beanRefToken . startPos ,    beanNameToken . endPos )  ,    beanNameString )  ;", "} else    {", "beanReference    =    new   BeanReference ( toPos ( beanNameToken )  ,    beanName )  ;", "}", "this . constructedNodes . push ( beanReference )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["maybeEatBeanReference"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( peekIdentifierToken (  \" new \"  )  )     {", "Token   newToken    =    takeToken (  )  ;", "if    ( peekToken ( TokenKind . RSQUARE )  )     {", "push ( new   PropertyOrFieldReference ( false ,    newToken . stringValue (  )  ,    toPos ( newToken )  )  )  ;", "return   true ;", "}", "SpelNodeImpl   possiblyQualifiedConstructorName    =    eatPossiblyQualifiedId (  )  ;", "List < SpelNodeImpl >    nodes    =    new   ArrayList <  >  (  )  ;", "nodes . add ( possiblyQualifiedConstructorName )  ;", "if    ( peekToken ( TokenKind . LSQUARE )  )     {", "List < SpelNodeImpl >    dimensions    =    new   ArrayList <  >  (  )  ;", "while    ( peekToken ( TokenKind . LSQUARE ,    true )  )     {", "if    (  !  ( peekToken ( TokenKind . RSQUARE )  )  )     {", "dimensions . add ( eat (  )  )  ;", "} else    {", "dimensions . add ( null )  ;", "}", "eatToken ( TokenKind . RSQUARE )  ;", "}", "if    ( maybeEatInlineListOrMap (  )  )     {", "nodes . add ( pop (  )  )  ;", "}", "push ( new   ConstructorReference ( toPos ( newToken )  ,    dimensions . toArray ( new   SpelNodeImpl [  0  ]  )  ,    nodes . toArray ( new   SpelNodeImpl [  0  ]  )  )  )  ;", "} else    {", "eatConstructorArgs ( nodes )  ;", "push ( new   ConstructorReference ( toPos ( newToken )  ,    nodes . toArray ( new   SpelNodeImpl [  0  ]  )  )  )  ;", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["maybeEatConstructorReference"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( peekToken ( TokenKind . HASH )  )  )     {", "return   false ;", "}", "Token   t    =    takeToken (  )  ;", "Token   functionOrVariableName    =    eatToken ( TokenKind . IDENTIFIER )  ;", "NodeImpl [  ]    args    =    maybeEatMethodArgs (  )  ;", "if    ( args    =  =    null )     {", "push ( new   VariableReference ( functionOrVariableName . stringValue (  )  ,    toPos ( t . startPos ,    functionOrVariableName . endPos )  )  )  ;", "return   true ;", "}", "push ( new   FunctionReference ( functionOrVariableName . stringValue (  )  ,    toPos ( t . startPos ,    functionOrVariableName . endPos )  ,    args )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["maybeEatFunctionOrVar"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    (  !  ( peekToken ( TokenKind . LSQUARE ,    true )  )  )     {", "return   false ;", "}", "Assert . state (  ( t    !  =    null )  ,     \" No   token \"  )  ;", "SpelNodeImpl   expr    =    eat (  )  ;", "Assert . state (  ( expr    !  =    null )  ,     \" No   node \"  )  ;", "eatToken ( TokenKind . RSQUARE )  ;", "this . constructedNodes . push ( new   Indexer ( toPos ( t )  ,    expr )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["maybeEatIndexer"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    (  !  ( peekToken ( TokenKind . LCURLY ,    true )  )  )     {", "return   false ;", "}", "Assert . state (  ( t    !  =    null )  ,     \" No   token \"  )  ;", "SpelNodeImpl   expr    =    null ;", "Token   closingCurly    =    peekToken (  )  ;", "if    ( peekToken ( TokenKind . RCURLY ,    true )  )     {", "Assert . state (  ( closingCurly    !  =    null )  ,     \" No   token \"  )  ;", "expr    =    new   InlineList ( toPos ( t . startPos ,    closingCurly . endPos )  )  ;", "} else", "if    ( peekToken ( TokenKind . COLON ,    true )  )     {", "closingCurly    =    eatToken ( TokenKind . RCURLY )  ;", "expr    =    new   ast . InlineMap ( toPos ( t . startPos ,    closingCurly . endPos )  )  ;", "} else    {", "SpelNodeImpl   firstExpression    =    eatExpression (  )  ;", "if    ( peekToken ( TokenKind . RCURLY )  )     {", "List < SpelNodeImpl >    elements    =    new   ArrayList <  >  (  )  ;", "elements . add ( firstExpression )  ;", "closingCurly    =    eatToken ( TokenKind . RCURLY )  ;", "expr    =    new   InlineList ( toPos ( t . startPos ,    closingCurly . endPos )  ,    elements . toArray ( new   SpelNodeImpl [  0  ]  )  )  ;", "} else", "if    ( peekToken ( TokenKind . COMMA ,    true )  )     {", "List < SpelNodeImpl >    elements    =    new   ArrayList <  >  (  )  ;", "elements . add ( firstExpression )  ;", "do    {", "elements . add ( eatExpression (  )  )  ;", "}    while    ( peekToken ( TokenKind . COMMA ,    true )     )  ;", "closingCurly    =    eatToken ( TokenKind . RCURLY )  ;", "expr    =    new   InlineList ( toPos ( t . startPos ,    closingCurly . endPos )  ,    elements . toArray ( new   SpelNodeImpl [  0  ]  )  )  ;", "} else", "if    ( peekToken ( TokenKind . COLON ,    true )  )     {", "List < SpelNodeImpl >    elements    =    new   ArrayList <  >  (  )  ;", "elements . add ( firstExpression )  ;", "elements . add ( eatExpression (  )  )  ;", "while    ( peekToken ( TokenKind . COMMA ,    true )  )     {", "elements . add ( eatExpression (  )  )  ;", "eatToken ( TokenKind . COLON )  ;", "elements . add ( eatExpression (  )  )  ;", "}", "closingCurly    =    eatToken ( TokenKind . RCURLY )  ;", "expr    =    new   ast . InlineMap ( toPos ( t . startPos ,    closingCurly . endPos )  ,    elements . toArray ( new   SpelNodeImpl [  0  ]  )  )  ;", "} else    {", "throw   internalException ( t . startPos ,    SpelMessage . OOD )  ;", "}", "}", "this . constructedNodes . push ( expr )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["maybeEatInlineListOrMap"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    ( t    =  =    null )     {", "return   false ;", "}", "if    (  ( t . kind )     =  =     ( TokenKind . LITERAL _ INT )  )     {", "push ( Literal . getIntLiteral ( t . stringValue (  )  ,    toPos ( t )  ,     1  0  )  )  ;", "} else", "if    (  ( t . kind )     =  =     ( TokenKind . LITERAL _ LONG )  )     {", "push ( Literal . getLongLiteral ( t . stringValue (  )  ,    toPos ( t )  ,     1  0  )  )  ;", "} else", "if    (  ( t . kind )     =  =     ( TokenKind . LITERAL _ HEXINT )  )     {", "push ( Literal . getIntLiteral ( t . stringValue (  )  ,    toPos ( t )  ,     1  6  )  )  ;", "} else", "if    (  ( t . kind )     =  =     ( TokenKind . LITERAL _ HEXLONG )  )     {", "push ( Literal . getLongLiteral ( t . stringValue (  )  ,    toPos ( t )  ,     1  6  )  )  ;", "} else", "if    (  ( t . kind )     =  =     ( TokenKind . LITERAL _ REAL )  )     {", "push ( Literal . getRealLiteral ( t . stringValue (  )  ,    toPos ( t )  ,    false )  )  ;", "} else", "if    (  ( t . kind )     =  =     ( TokenKind . LITERAL _ REAL _ FLOAT )  )     {", "push ( Literal . getRealLiteral ( t . stringValue (  )  ,    toPos ( t )  ,    true )  )  ;", "} else", "if    ( peekIdentifierToken (  \" true \"  )  )     {", "push ( new   ast . BooleanLiteral ( t . stringValue (  )  ,    toPos ( t )  ,    true )  )  ;", "} else", "if    ( peekIdentifierToken (  \" false \"  )  )     {", "push ( new   ast . BooleanLiteral ( t . stringValue (  )  ,    toPos ( t )  ,    false )  )  ;", "} else", "if    (  ( t . kind )     =  =     ( TokenKind . LITERAL _ STRING )  )     {", "push ( new   ast . StringLiteral ( t . stringValue (  )  ,    toPos ( t )  ,    t . stringValue (  )  )  )  ;", "} else    {", "return   false ;", "}", "nextToken (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["maybeEatLiteral"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( peekToken ( TokenKind . LPAREN )  )  )     {", "return   null ;", "}", "List < NodeImpl >    args    =    new   ArrayList <  >  (  )  ;", "consumeArguments ( args )  ;", "eatToken ( TokenKind . RPAREN )  ;", "return   args . toArray ( new   NodeImpl [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["maybeEatMethodArgs"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( peekToken ( TokenKind . IDENTIFIER )  )     {", "Token   methodOrPropertyName    =    takeToken (  )  ;", "NodeImpl [  ]    args    =    maybeEatMethodArgs (  )  ;", "if    ( args    =  =    null )     {", "push ( new   PropertyOrFieldReference ( nullSafeNavigation ,    methodOrPropertyName . stringValue (  )  ,    toPos ( methodOrPropertyName )  )  )  ;", "return   true ;", "}", "push ( new   MethodReference ( nullSafeNavigation ,    methodOrPropertyName . stringValue (  )  ,    toPos ( methodOrPropertyName )  ,    args )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["maybeEatMethodOrProperty"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( peekToken ( TokenKind . IDENTIFIER )  )     {", "Token   nullToken    =    peekToken (  )  ;", "Assertte (  ( nullToken    !  =    null )  ,     \" Expected   token \"  )  ;", "if    (  !  (  \" null \"  . equalsIgnoreCase ( nullToken . stringValue (  )  )  )  )     {", "return   false ;", "}", "nextToken (  )  ;", "this . constructedNodes . push ( new   NullLiteral ( toPos ( nullToken )  )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["maybeEatNullReference"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( peekToken ( TokenKind . LPAREN )  )     {", "nextToken (  )  ;", "SpelNodeImpl   expr    =    eat (  )  ;", "Assert . state (  ( expr    !  =    null )  ,     \" No   node \"  )  ;", "eatToken ( TokenKind . RPAREN )  ;", "push ( expr )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["maybeEatParenExpression"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    (  !  ( peekToken ( TokenKind . PROJECT ,    true )  )  )     {", "return   false ;", "}", "Assert . state (  ( t    !  =    null )  ,     \" No   token \"  )  ;", "SpelNodeImpl   expr    =    eat (  )  ;", "Assert . state (  ( expr    !  =    null )  ,     \" No   node \"  )  ;", "eatToken ( TokenKind . RSQUARE )  ;", "this . constructedNodes . push ( new   Projection ( nullSafeNavigation ,    toPos ( t )  ,    expr )  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["maybeEatProjection"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    ( t    =  =    null )     {", "return   null ;", "}", "if    ( t . isNumericRelationalOperator (  )  )     {", "return   t ;", "}", "if    ( t . isIdentifier (  )  )     {", "St   idSt    =    t . stValue (  )  ;", "if    ( idSt . equalsIgnoreCase (  \" instanceof \"  )  )     {", "return   t . asInstanceOfToken (  )  ;", "}", "if    ( idSt . equalsIgnoreCase (  \" matches \"  )  )     {", "return   t . asMatchesToken (  )  ;", "}", "if    ( idSt . equalsIgnoreCase (  \" between \"  )  )     {", "return   t . asBetweenToken (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["maybeEatRelationalOperator"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    (  !  ( peekSelectToken (  )  )  )     {", "return   false ;", "}", "Assert . state (  ( t    !  =    null )  ,     \" No   token \"  )  ;", "nextToken (  )  ;", "SpelNodeImpl   expr    =    eat (  )  ;", "if    ( expr    =  =    null )     {", "throw   internalException ( toPos ( t )  ,    SpelMessage . MISSING _ SELECTION _ EXPRESSION )  ;", "}", "eatToken ( TokenKind . RSQUARE )  ;", "if    (  ( t . kind )     =  =     ( TokenKind . SELECT _ FIRST )  )     {", "this . constructedNodes . push ( new   Selection ( nullSafeNavigation ,    Selection . FIRST ,    toPos ( t )  ,    expr )  )  ;", "} else", "if    (  ( t . kind )     =  =     ( TokenKind . SELECT _ LAST )  )     {", "this . constructedNodes . push ( new   Selection ( nullSafeNavigation ,    Selection . LAST ,    toPos ( t )  ,    expr )  )  ;", "} else    {", "this . constructedNodes . push ( new   Selection ( nullSafeNavigation ,    Selection . ALL ,    toPos ( t )  ,    expr )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["maybeEatSelection"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( peekToken ( TokenKind . IDENTIFIER )  )     {", "Token   typeName    =    peekToken (  )  ;", "Assertte (  ( typeName    !  =    null )  ,     \" Expected   token \"  )  ;", "if    (  !  (  \" T \"  . equals ( typeName . stringValue (  )  )  )  )     {", "return   false ;", "}", "Token   t    =    takeToken (  )  ;", "if    ( peekToken ( TokenKind . RSQUARE )  )     {", "push ( new   PropertyOrFieldReference ( false ,    t . stringValue (  )  ,    toPos ( t )  )  )  ;", "return   true ;", "}", "eatToken ( TokenKind . LPAREN )  ;", "SpelNodeImpl   node    =    eatPossiblyQualifiedId (  )  ;", "int   dims    =     0  ;", "while    ( peekToken ( TokenKind . LSQUARE ,    true )  )     {", "eatToken ( TokenKind . RSQUARE )  ;", "dims +  +  ;", "}", "eatToken ( TokenKind . RPAREN )  ;", "this . constructedNodes . push ( new   TypeReference ( toPos ( typeName )  ,    node ,    dims )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["maybeEatTypeReference"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . tokenStreamPointer )     >  =     ( this . tokenStreamLength )  )     {", "return   null ;", "}", "return   this . tokenStream . get (  (  ( this . tokenStreamPointer )  +  +  )  )  ;", "}", "METHOD_END"], "methodName": ["nextToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    ( t    =  =    null )     {", "return   false ;", "}", "return    (  ( t . kind )     =  =     ( TokenKind . IDENTIFIER )  )     &  &     ( identifierSt . equalsIgnoreCase ( t . stValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["peekIdentifierToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    ( t    =  =    null )     {", "return   false ;", "}", "return    (  (  ( t . kind )     =  =     ( TokenKind . SELECT )  )     |  |     (  ( t . kind )     =  =     ( TokenKind . SELECT _ FIRST )  )  )     |  |     (  ( t . kind )     =  =     ( TokenKind . SELECT _ LAST )  )  ;", "}", "METHOD_END"], "methodName": ["peekSelectToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . tokenStreamPointer )     >  =     ( this . tokenStreamLength )  )     {", "return   null ;", "}", "return   this . tokenStream . get ( this . tokenStreamPointer )  ;", "}", "METHOD_END"], "methodName": ["peekToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "return   peekToken ( desiredTokenKind ,    false )  ;", "}", "METHOD_END"], "methodName": ["peekToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    ( t    =  =    null )     {", "return   false ;", "}", "if    (  ( t . kind )     =  =    desiredTokenKind )     {", "if    ( consumeIfMatched )     {", "( this . tokenStreamPoi )  +  +  ;", "}", "return   true ;", "}", "if    ( desiredTokenKind    =  =     ( TokenKind . IDENTIFIER )  )     {", "if    (  (  (  ( t . kind . ordinal (  )  )     >  =     ( TokenKind . DIV . ordinal (  )  )  )     &  &     (  ( t . kind . ordinal (  )  )     <  =     ( TokenKind . NOT . ordinal (  )  )  )  )     &  &     (  ( t . data )     !  =    null )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["peekToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    ( t    =  =    null )     {", "return   false ;", "}", "return    (  ( t . kind )     =  =    poble 1  )     |  |     (  ( t . kind )     =  =    poble 2  )  ;", "}", "METHOD_END"], "methodName": ["peekToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "Token   t    =    peekToken (  )  ;", "if    ( t    =  =    null )     {", "return   false ;", "}", "return    (  (  ( t . kind )     =  =    poble 1  )     |  |     (  ( t . kind )     =  =    poble 2  )  )     |  |     (  ( t . kind )     =  =    poble 3  )  ;", "}", "METHOD_END"], "methodName": ["peekToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "return   this . constructedNodes . pop (  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( t    =  =    null )     {", "return   thisString . length (  )  ;", "}", "return   t . startPos ;", "}", "METHOD_END"], "methodName": ["positionOf"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "this . constructedNodes . push ( newNode )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . tokenStreamPointer )     >  =     ( this . tokenStreamLength )  )     {", "throw   new   IllegalStateException (  \" No   token \"  )  ;", "}", "return   this . tokenStream . get (  (  ( this . tokenStreamPointer )  +  +  )  )  ;", "}", "METHOD_END"], "methodName": ["takeToken"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "return    ( start    <  <     1  6  )     +    end ;", "}", "METHOD_END"], "methodName": ["toPos"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "return    (  ( t . startPos )     <  <     1  6  )     +     ( t . endPos )  ;", "}", "METHOD_END"], "methodName": ["toPos"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( t    =  =    null )     {", "return    \"  \"  ;", "}", "if    ( t . getKind (  )  . hasPayload (  )  )     {", "return   t . stValue (  )  ;", "}", "return   t . kind . toSt (  )  . toLowerCase (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.springframework.expression.spel.standard.InternalSpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "PropertiesConversionSpelTests . CustomMap   map    =    new   PropertiesConversionSpelTests . CustomMap (  )  ;", "map . put (  \" x \"  ,     \"  1  \"  )  ;", "map . put (  \" y \"  ,     2  )  ;", "map . put (  \" z \"  ,     \"  3  \"  )  ;", "Expression   expression    =    PropertiesConversionSpelTests . parser . parseExpression (  \" foo (  # props )  \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" props \"  ,    map )  ;", "String   result    =    expression . getValue ( context ,    new   PropertiesConversionSpelTests . TestBean (  )  ,    String . class )  ;", "assertEquals (  \"  1 null 3  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["customMapWithNonStringValue"], "fileName": "org.springframework.expression.spel.standard.PropertiesConversionSpelTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" x \"  ,     \"  1  \"  )  ;", "map . put (  \" y \"  ,     \"  2  \"  )  ;", "map . put (  \" z \"  ,     \"  3  \"  )  ;", "Expression   expression    =     . parser . parseExpression (  \" foo (  # props )  \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" props \"  ,    map )  ;", "String   result    =    expression . getValue ( context ,    new    . TestBean (  )  ,    String . class )  ;", "assertEquals (  \"  1  2  3  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["mapWithAllStringValues"], "fileName": "org.springframework.expression.spel.standard.PropertiesConversionSpelTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" x \"  ,     \"  1  \"  )  ;", "map . put (  \" y \"  ,     2  )  ;", "map . put (  \" z \"  ,     \"  3  \"  )  ;", "map . put (  \" a \"  ,    new   UUID (  1  ,     1  )  )  ;", "Expression   expression    =     . parser . parseExpression (  \" foo (  # props )  \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" props \"  ,    map )  ;", "String   result    =    expression . getValue ( context ,    new    . TestBean (  )  ,    String . class )  ;", "assertEquals (  \"  1 null 3  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["mapWithNonStringValue"], "fileName": "org.springframework.expression.spel.standard.PropertiesConversionSpelTests"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" x \"  ,     \"  1  \"  )  ;", "props . setProperty (  \" y \"  ,     \"  2  \"  )  ;", "props . setProperty (  \" z \"  ,     \"  3  \"  )  ;", "Expression   expression    =     . parser . parseExpression (  \" foo (  # props )  \"  )  ;", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "context . setVariable (  \" props \"  ,    props )  ;", "String   result    =    expression . getValue ( context ,    new    . TestBean (  )  ,    String . class )  ;", "assertEquals (  \"  1  2  3  \"  ,    result )  ;", "}", "METHOD_END"], "methodName": ["props"], "fileName": "org.springframework.expression.spel.standard.PropertiesConversionSpelTests"}, {"methodBody": ["METHOD_START", "{", "return    ( expression   instanceof   SpelExpression )     &  &     (  (  ( SpelExpression )     ( expression )  )  . compileExpression (  )  )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.springframework.expression.spel.standard.SpelCompiler"}, {"methodBody": ["METHOD_START", "{", "if    ( expression . isCompilable (  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" SpEL :    compiling    \"     +     ( expression . toStringAST (  )  )  )  )  ;", "}", "Class <  ?    extends   CompiledExpression >    clazz    =    createExpressionClass ( expression )  ;", "if    ( clazz    !  =    null )     {", "try    {", "return   ReflectionUtils . accessibleConstructor ( clazz )  . newInstance (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" Failed   to   instantiate   CompiledExpression \"  ,    ex )  ;", "}", "}", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" SpEL :    unable   to   compile    \"     +     ( expression . toStringAST (  )  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.springframework.expression.spel.standard.SpelCompiler"}, {"methodBody": ["METHOD_START", "{", "String   clazzName    =     \" spel / Ex \"     +     ( getNextSuffix (  )  )  ;", "ClassWriter   cw    =    new   SpelCompiler . ExpressionClassWriter (  )  ;", "cw . visit ( V 1  _  5  ,    ACC _ PUBLIC ,    clazzName ,    null ,     \" org /  / expression / spel / CompiledExpression \"  ,    null )  ;", "MethodVisitor   mv    =    cw . visitMethod ( ACC _ PUBLIC ,     \"  < init >  \"  ,     \"  (  ) V \"  ,    null ,    null )  ;", "mv . visitCode (  )  ;", "mv . visitVarInsn ( ALOAD ,     0  )  ;", "mv . visitMethodInsn ( INVOKESPECIAL ,     \" org /  / expression / spel / CompiledExpression \"  ,     \"  < init >  \"  ,     \"  (  ) V \"  ,    false )  ;", "mv . visitInsn ( RETURN )  ;", "mv . visitMaxs (  1  ,     1  )  ;", "mv . visitEnd (  )  ;", "mv    =    cw . visitMethod ( ACC _ PUBLIC ,     \" getValue \"  ,     \"  ( Ljava / lang / Object ; Lorg /  / expression / EvaluationContext ;  ) Ljava / lang / Object ;  \"  ,    null ,    new   String [  ]  {     \" org /  / expression / EvaluationException \"     }  )  ;", "mv . visitCode (  )  ;", "CodeFlow   cf    =    new   CodeFlow ( clazzName ,    cw )  ;", "try    {", "expressionToCompile . generateCode ( mv ,    cf )  ;", "}    catch    ( IllegalStateException   ex )     {", "if    ( SpelCompiler . logger . isDebugEnabled (  )  )     {", "SpelCompiler . logger . debug (  (  (  ( expressionToCompile . getClass (  )  . getSimpleName (  )  )     +     \"  . generateCode   opted   out   of   compilation :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "return   null ;", "}", "CodeFlow . insertBoxIfNecessary ( mv ,    cf . lastDescriptor (  )  )  ;", "if    (  \" V \"  . equals ( cf . lastDescriptor (  )  )  )     {", "mv . visitInsn ( ACONST _ NULL )  ;", "}", "mv . visitInsn ( ARETURN )  ;", "mv . visitMaxs (  0  ,     0  )  ;", "mv . visitEnd (  )  ;", "cw . visitEnd (  )  ;", "cf . finish (  )  ;", "byte [  ]    data    =    cw . toByteArray (  )  ;", "return   loadClass ( clazzName . replaceAll (  \"  /  \"  ,     \"  .  \"  )  ,    data )  ;", "}", "METHOD_END"], "methodName": ["createExpressionClass"], "fileName": "org.springframework.expression.spel.standard.SpelCompiler"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   clToUse    =     ( classLoader    !  =    null )     ?    classLoader    :    ClassUtils . getDefaultClassLoader (  )  ;", "synchronized (  . compilers )     {", "compiler    =     . compilers . get ( clToUse )  ;", "if    ( compiler    =  =    null )     {", "compiler    =    new    ( clToUse )  ;", ". compilers . put ( clToUse ,    compiler )  ;", "}", "return   compiler ;", "}", "}", "METHOD_END"], "methodName": ["getCompiler"], "fileName": "org.springframework.expression.spel.standard.SpelCompiler"}, {"methodBody": ["METHOD_START", "{", "return   this . suffixId . incrementAndGet (  )  ;", "}", "METHOD_END"], "methodName": ["getNextSuffix"], "fileName": "org.springframework.expression.spel.standard.SpelCompiler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . ccl . getClassesDefinedCount (  )  )     >     ( SpelCompiler . CLASSES _ DEFINED _ LIMIT )  )     {", "this . ccl    =    new   SpelCompiler . ChildClassLoader ( this . ccl . getParent (  )  )  ;", "}", "return    (  ( Class <  ?    extends   CompiledExpression >  )     ( this . ccl . defineClass ( name ,    bytes )  )  )  ;", "}", "METHOD_END"], "methodName": ["loadClass"], "fileName": "org.springframework.expression.spel.standard.SpelCompiler"}, {"methodBody": ["METHOD_START", "{", "if    ( expression   instanceof   SpelExpression )     {", "(  ( SpelExpression )     ( expression )  )  . revertToInterpreted (  )  ;", "}", "}", "METHOD_END"], "methodName": ["revertToInterpreted"], "fileName": "org.springframework.expression.spel.standard.SpelCompiler"}, {"methodBody": ["METHOD_START", "{", "( this . interpretedCount )  +  +  ;", "SpelCompilerMode   compilerMode    =    expressionState . getConfiguration (  )  . getCompilerMode (  )  ;", "if    ( compilerMode    !  =     ( SpelCompilerMode . OFF )  )     {", "if    ( compilerMode    =  =     ( SpelCompilerMode . IMMEDIATE )  )     {", "if    (  ( this . interpretedCount )     >     1  )     {", "compileExpression (  )  ;", "}", "} else    {", "if    (  ( this . interpretedCount )     >     (  . INTERPRETED _ COUNT _ THRESHOLD )  )     {", "compileExpression (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkCompile"], "fileName": "org.springframework.expression.spel.standard.SpelExpression"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . failedAttempts )     >     ( SpelExpression . FAILED _ ATTEMPTS _ THRESHOLD )  )     {", "return   false ;", "}", "if    (  ( this . compiledAst )     =  =    null )     {", "synchronized ( this . expression )     {", "if    (  ( this . compiledAst )     !  =    null )     {", "return   true ;", "}", "SpelCompiler   compiler    =    SpelCompiler . getCompiler ( this . configuration . getCompilerClassLoader (  )  )  ;", "this . compiledAst    =    compiler . compile ( this . ast )  ;", "if    (  ( this . compiledAst )     =  =    null )     {", "( this . failedAttempts )  +  +  ;", "}", "}", "}", "return    ( this . compiledAst )     !  =    null ;", "}", "METHOD_END"], "methodName": ["compileExpression"], "fileName": "org.springframework.expression.spel.standard.SpelExpression"}, {"methodBody": ["METHOD_START", "{", "return   this . ast ;", "}", "METHOD_END"], "methodName": ["getAST"], "fileName": "org.springframework.expression.spel.standard.SpelExpression"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . evaluationContext )     =  =    null )     {", "this . evaluationContext    =    new   SEvaluationContext (  )  ;", "}", "return   this . evaluationContext ;", "}", "METHOD_END"], "methodName": ["getEvaluationContext"], "fileName": "org.springframework.expression.spel.standard.SpelExpression"}, {"methodBody": ["METHOD_START", "{", "this . compiledAst    =    null ;", "this . intertedCount    =     0  ;", "this . failedAttempts    =     0  ;", "}", "METHOD_END"], "methodName": ["revertToInterpreted"], "fileName": "org.springframework.expression.spel.standard.SpelExpression"}, {"methodBody": ["METHOD_START", "{", "this . evaluationContext    =    evaluationContext ;", "}", "METHOD_END"], "methodName": ["setEvaluationContext"], "fileName": "org.springframework.expression.spel.standard.SpelExpression"}, {"methodBody": ["METHOD_START", "{", "return   this . ast . toStringAST (  )  ;", "}", "METHOD_END"], "methodName": ["toStringAST"], "fileName": "org.springframework.expression.spel.standard.SpelExpression"}, {"methodBody": ["METHOD_START", "{", "return   object    !  =    null    ?    new   TypedValue ( object )     :    TypedValue . NULL ;", "}", "METHOD_END"], "methodName": ["toTypedValue"], "fileName": "org.springframework.expression.spel.standard.SpelExpression"}, {"methodBody": ["METHOD_START", "{", "return   doParseExpression ( expressionString ,    null )  ;", "}", "METHOD_END"], "methodName": ["parseRaw"], "fileName": "org.springframework.expression.spel.standard.SpelExpressionParser"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression   expr    =    parser . parseRaw (  \"  2  *  3  \"  )  ;", "assertNotNull ( expr )  ;", "assertNotNull ( expr . getAST (  )  )  ;", "assertEquals (  6  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["arithmeticMultiply1"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression   expr    =    parser . parseRaw (  \"  2  +  2  \"  )  ;", "assertNotNull ( expr )  ;", "assertNotNull ( expr . getAST (  )  )  ;", "assertEquals (  4  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["arithmeticPlus1"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression   expr    =    parser . parseRaw (  \"  3  7  +  4  1  \"  )  ;", "assertEquals (  7  8  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["arithmeticPlus2"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression   expr    =    parser . parseRaw (  \"  2  *  3  +  5  \"  )  ;", "assertEquals (  1  1  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["arithmeticPrecedence1"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression   expr    =    parser . parseRaw (  \"  2  +  3  *  5  \"  )  ;", "assertEquals (  1  7  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["arithmeticPrecedence2"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  3  +  1  0  /  2  \"  )  ;", "assertEquals (  8  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["arithmeticPrecedence3"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  1  0  /  2  +  3  \"  )  ;", "assertEquals (  8  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["arithmeticPrecedence4"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  (  4  +  1  0  )  /  2  \"  )  ;", "assertEquals (  7  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["arithmeticPrecedence5"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  (  3  +  2  )  *  2  \"  )  ;", "assertEquals (  1  0  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["arithmeticPrecedence6"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" true \"  )  ;", "assertEquals ( Boolean . TRUE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" false \"  )  ;", "assertEquals ( Boolean . FALSE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" false   and   false \"  )  ;", "assertEquals ( Boolean . FALSE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" true   and    ( true   or   false )  \"  )  ;", "assertEquals ( Boolean . TRUE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" true   and   true   or   false \"  )  ;", "assertEquals ( Boolean . TRUE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  ! true \"  )  ;", "assertEquals ( Boolean . FALSE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  !  ( false   or   true )  \"  )  ;", "assertEquals ( Boolean . FALSE ,    expr . getValue ( Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["booleanOperators"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" true \"  )  ;", "assertEquals ( Boolean . TRUE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" false \"  )  ;", "assertEquals ( Boolean . FALSE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" false    &  &    false \"  )  ;", "assertEquals ( Boolean . FALSE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" true    &  &     ( true    |  |    false )  \"  )  ;", "assertEquals ( Boolean . TRUE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" true    &  &    true    |  |    false \"  )  ;", "assertEquals ( Boolean . TRUE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  ! true \"  )  ;", "assertEquals ( Boolean . FALSE ,    expr . getValue ( Boolean . class )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  !  ( false    |  |    true )  \"  )  ;", "assertEquals ( Boolean . FALSE ,    expr . getValue ( Boolean . class )  )  ;", "}", "METHOD_END"], "methodName": ["booleanOperators_symbolic_spr9614"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression   expr    =    parser . parseRaw (  )  ;", "Object   exprVal    =    expr . getValue (  )  ;", "assertEquals ( value ,    exprVal )  ;", "assertEquals ( type ,    exprVal . getClass (  )  )  ;", "}    catch    ( Exception   ex )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkNumber"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "parser . parseRaw (  )  ;", "fail (  )  ;", "}    catch    ( ParseException   ex )     {", "assertTrue (  ( ex   instanceof   SpelParseException )  )  ;", "SpelParseException   spe    =     (  ( SpelParseException )     ( ex )  )  ;", "assertEquals ( expectedMessage ,    spe . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkNumberError"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "ExpressionException   exprEx    =    new   ExpressionException (  \" test \"  )  ;", "assertEquals (  \" test \"  ,    exprEx . getSimpleMessage (  )  )  ;", "assertEquals (  \" test \"  ,    exprEx . toDetailedString (  )  )  ;", "assertEquals (  \" test \"  ,    exprEx . getMessage (  )  )  ;", "exprEx    =    new   ExpressionException (  \" wibble \"  ,     \" test \"  )  ;", "assertEquals (  \" test \"  ,    exprEx . getSimpleMessage (  )  )  ;", "assertEquals (  \" Expression    [ wibble ]  :    test \"  ,    exprEx . toDetailedString (  )  )  ;", "assertEquals (  \" Expression    [ wibble ]  :    test \"  ,    exprEx . getMessage (  )  )  ;", "exprEx    =    new   ExpressionException (  \" wibble \"  ,     3  ,     \" test \"  )  ;", "assertEquals (  \" test \"  ,    exprEx . getSimpleMessage (  )  )  ;", "assertEquals (  \" Expression    [ wibble ]     @  3  :    test \"  ,    exprEx . toDetailedString (  )  )  ;", "assertEquals (  \" Expression    [ wibble ]     @  3  :    test \"  ,    exprEx . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["exceptions"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "SpelEParser   parser    =    new   SpelEParser (  )  ;", "parser . parseRaw (  \" new   String \"  )  ;", "fail (  )  ;", "}    catch    ( ParseException   ex )     {", "assertTrue (  ( ex   instanceof   SpelParseException )  )  ;", "SpelParseException   spe    =     (  ( SpelParseException )     ( ex )  )  ;", "assertEquals ( SpelMessage . MISSING _ CONSTRUCTOR _ ARGS ,    spe . getMessageCode (  )  )  ;", "assertEquals (  1  0  ,    spe . getPosition (  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( ex . getEString (  )  )  )  ;", "}", "try    {", "SpelEParser   parser    =    new   SpelEParser (  )  ;", "parser . parseRaw (  \" new   String (  3  ,  \"  )  ;", "fail (  )  ;", "}    catch    ( ParseException   ex )     {", "assertTrue (  ( ex   instanceof   SpelParseException )  )  ;", "SpelParseException   spe    =     (  ( SpelParseException )     ( ex )  )  ;", "assertEquals ( SpelMessage . RUN _ OUT _ OF _ ARGUMENTS ,    spe . getMessageCode (  )  )  ;", "assertEquals (  1  0  ,    spe . getPosition (  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( ex . getEString (  )  )  )  ;", "}", "try    {", "SpelEParser   parser    =    new   SpelEParser (  )  ;", "parser . parseRaw (  \" new   String (  3  \"  )  ;", "fail (  )  ;", "}    catch    ( ParseException   ex )     {", "assertTrue (  ( ex   instanceof   SpelParseException )  )  ;", "SpelParseException   spe    =     (  ( SpelParseException )     ( ex )  )  ;", "assertEquals ( SpelMessage . RUN _ OUT _ OF _ ARGUMENTS ,    spe . getMessageCode (  )  )  ;", "assertEquals (  1  0  ,    spe . getPosition (  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( ex . getEString (  )  )  )  ;", "}", "try    {", "SpelEParser   parser    =    new   SpelEParser (  )  ;", "parser . parseRaw (  \" new   String (  \"  )  ;", "fail (  )  ;", "}    catch    ( ParseException   ex )     {", "assertTrue (  ( ex   instanceof   SpelParseException )  )  ;", "SpelParseException   spe    =     (  ( SpelParseException )     ( ex )  )  ;", "assertEquals ( SpelMessage . RUN _ OUT _ OF _ ARGUMENTS ,    spe . getMessageCode (  )  )  ;", "assertEquals (  1  0  ,    spe . getPosition (  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( ex . getEString (  )  )  )  ;", "}", "try    {", "SpelEParser   parser    =    new   SpelEParser (  )  ;", "parser . parseRaw (  \"  \\  \" abc \"  )  ;", "fail (  )  ;", "}    catch    ( ParseException   ex )     {", "assertTrue (  ( ex   instanceof   SpelParseException )  )  ;", "SpelParseException   spe    =     (  ( SpelParseException )     ( ex )  )  ;", "assertEquals ( SpelMessage . NON _ TERMINATING _ DOUBLE _ QUOTED _ STRING ,    spe . getMessageCode (  )  )  ;", "assertEquals (  0  ,    spe . getPosition (  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( ex . getEString (  )  )  )  ;", "}", "try    {", "SpelEParser   parser    =    new   SpelEParser (  )  ;", "parser . parseRaw (  \"  ' abc \"  )  ;", "fail (  )  ;", "}    catch    ( ParseException   ex )     {", "assertTrue (  ( ex   instanceof   SpelParseException )  )  ;", "SpelParseException   spe    =     (  ( SpelParseException )     ( ex )  )  ;", "assertEquals ( SpelMessage . NON _ TERMINATING _ QUOTED _ STRING ,    spe . getMessageCode (  )  )  ;", "assertEquals (  0  ,    spe . getPosition (  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains ( ex . getEString (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["generalExpressions"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "checkNumber (  \"  2  \"  ,     2  ,    Integer . class )  ;", "checkNumber (  \"  2  2  \"  ,     2  2  ,    Integer . class )  ;", "checkNumber (  \"  +  2  2  \"  ,     2  2  ,    Integer . class )  ;", "checkNumber (  \"  -  2  2  \"  ,     (  -  2  2  )  ,    Integer . class )  ;", "checkNumber (  \"  2 L \"  ,     2 L ,    Long . class )  ;", "checkNumber (  \"  2  2 l \"  ,     2  2 L ,    Long . class )  ;", "checkNumber (  \"  0 x 1  \"  ,     1  ,    Integer . class )  ;", "checkNumber (  \"  0 x 1 L \"  ,     1 L ,    Long . class )  ;", "checkNumber (  \"  0 xa \"  ,     1  0  ,    Integer . class )  ;", "checkNumber (  \"  0 xAL \"  ,     1  0 L ,    Long . class )  ;", "checkNumberError (  \"  0 x \"  ,    Message . NOT _ AN _ INTEGER )  ;", "checkNumberError (  \"  0 xL \"  ,    Message . NOT _ A _ LONG )  ;", "checkNumberError (  \"  .  3  2  4  \"  ,    Message . UNEXPECTED _ DATA _ AFTER _ DOT )  ;", "checkNumberError (  \"  3  .  4 L \"  ,    Message . REAL _ CANNOT _ BE _ LONG )  ;", "checkNumber (  \"  3  .  5 f \"  ,     3  .  5 F ,    Float . class )  ;", "checkNumber (  \"  1  .  2 e 3  \"  ,     1  2  0  0  .  0  ,    Double . class )  ;", "checkNumber (  \"  1  .  2 e +  3  \"  ,     1  2  0  0  .  0  ,    Double . class )  ;", "checkNumber (  \"  1  .  2 e -  3  \"  ,     0  .  0  0  1  2  ,    Double . class )  ;", "checkNumber (  \"  1  .  2 e 3  \"  ,     1  2  0  0  .  0  ,    Double . class )  ;", "checkNumber (  \"  1 e +  3  \"  ,     1  0  0  0  .  0  ,    Double . class )  ;", "}", "METHOD_END"], "methodName": ["numerics"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "checkNumber (  \"  3  .  1  4  . toString (  )  \"  ,     \"  3  .  1  4  \"  ,    String . class )  ;", "checkNumber (  \"  3  . toString (  )  \"  ,     \"  3  \"  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["parseMethodsOnNumbers"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \" true   and   true   or   false \"  )  ;", "SpelNode   rootAst    =    expr . getAST (  )  ;", "OpOr   operatorOr    =     (  ( OpOr )     ( rootAst )  )  ;", "OpAnd   operatorAnd    =     (  ( OpAnd )     ( operatorOr . getLeftOperand (  )  )  )  ;", "SpelNode   rightOrOperand    =    operatorOr . getRightOperand (  )  ;", "assertEquals (  1  7  ,    rightOrOperand . getStartPosition (  )  )  ;", "assertEquals (  2  2  ,    rightOrOperand . getEndPosition (  )  )  ;", "assertEquals (  0  ,    operatorAnd . getLeftOperand (  )  . getStartPosition (  )  )  ;", "assertEquals (  4  ,    operatorAnd . getLeftOperand (  )  . getEndPosition (  )  )  ;", "assertEquals (  9  ,    operatorAnd . getRightOperand (  )  . getStartPosition (  )  )  ;", "assertEquals (  1  3  ,    operatorAnd . getRightOperand (  )  . getEndPosition (  )  )  ;", "assertEquals (  5  ,    operatorAnd . getStartPosition (  )  )  ;", "assertEquals (  8  ,    operatorAnd . getEndPosition (  )  )  ;", "assertEquals (  1  4  ,    operatorOr . getStartPosition (  )  )  ;", "assertEquals (  1  6  ,    operatorOr . getEndPosition (  )  )  ;", "}", "METHOD_END"], "methodName": ["positionalInformation"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  ' howdy '  \"  )  ;", "assertEquals (  \" howdy \"  ,    expr . getValue (  )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  ' hello    '  '    world '  \"  )  ;", "assertEquals (  \" hello    '    world \"  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["stringLiterals"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  ' howdy '  . substring (  0  ,  2  )  \"  )  ;", "assertEquals (  \" ho \"  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["stringLiterals2"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  \\  \" double   quote :     \\  \"  \\  \"  .  \\  \"  \"  )  ;", "assertEquals (  \" double   quote :     \\  \"  .  \"  ,    expr . getValue (  )  )  ;", "expr    =    new   SpelExpressionParser (  )  . parseRaw (  \"  \\  \" hello    \\  \"  \\  \"    world \\  \"  \"  )  ;", "assertEquals (  \" hello    \\  \"    world \"  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringLiterals_DoubleQuotes_spr9620"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   SpelEParser (  )  . parseRaw (  \"  \\  \" double   quote :     \\  \\  \\  \"  \\  \\  \\  \"  .  \\  \"  \"  )  ;", "fail (  \" Should   have   failed \"  )  ;", "}    catch    ( SpelParseException   spe )     {", "assertEquals (  1  7  ,    spe . getPosition (  )  )  ;", "assertEquals ( SpelMessage . UNEXPECTED _ ESCAPE _ CHAR ,    spe . getMessageCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testStringLiterals_DoubleQuotes_spr9620_2"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression   expr    =    parser . parseRaw (  \"  2  \"  )  ;", "assertNotNull ( expr )  ;", "assertNotNull ( expr . getAST (  )  )  ;", "assertEquals (  2  ,    expr . getValue (  )  )  ;", "assertEquals ( Integer . class ,    expr . getValueType (  )  )  ;", "assertEquals (  2  ,    expr . getAST (  )  . getValue ( null )  )  ;", "}", "METHOD_END"], "methodName": ["theMostBasic"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "Token   token    =    new   Token ( TokenKind . NOT ,     0  ,     3  )  ;", "assertEquals ( TokenKind . NOT ,    token . kind )  ;", "assertEquals (  0  ,    tokenrtPos )  ;", "assertEquals (  3  ,    token . endPos )  ;", "assertEquals (  \"  [ NOT (  !  )  ]  (  0  ,  3  )  \"  ,    token . toString (  )  )  ;", "token    =    new   Token ( TokenKind . LITERAL _ STRING ,     \" abc \"  . toCharArray (  )  ,     0  ,     3  )  ;", "assertEquals ( TokenKind . LITERAL _ STRING ,    token . kind )  ;", "assertEquals (  0  ,    tokenrtPos )  ;", "assertEquals (  3  ,    token . endPos )  ;", "assertEquals (  \"  [ LITERAL _ STRING : abc ]  (  0  ,  3  )  \"  ,    token . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["token"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "TokenKind   tk    =    TokenKind . NOT ;", "assertFalse ( tk . hasPayload (  )  )  ;", "assertEquals (  \" NOT (  !  )  \"  ,    tk . toSt (  )  )  ;", "tk    =    TokenKind . MINUS ;", "assertFalse ( tk . hasPayload (  )  )  ;", "assertEquals (  \" MINUS (  -  )  \"  ,    tk . toSt (  )  )  ;", "tk    =    TokenKind . LITERAL _ STRING ;", "assertEquals (  \" LITERAL _ STRING \"  ,    tk . toSt (  )  )  ;", "assertTrue ( tk . hasPayload (  )  )  ;", "}", "METHOD_END"], "methodName": ["tokenKind"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "EvaluationContext   ctx    =    new   StandardEvaluationContext (  )  ;", "Class <  ?  >    c    =    parser . parseRaw (  \"  2  \"  )  . getValueType (  )  ;", "assertEquals ( Integer . class ,    c )  ;", "c    =    parser . parseRaw (  \"  1  2  \"  )  . getValueType ( ctx )  ;", "assertEquals ( Integer . class ,    c )  ;", "c    =    parser . parseRaw (  \" null \"  )  . getValueType (  )  ;", "assertNull ( c )  ;", "c    =    parser . parseRaw (  \" null \"  )  . getValueType ( ctx )  ;", "assertNull ( c )  ;", "Object   o    =    parser . parseRaw (  \" null \"  )  . getValue ( ctx ,    Integer . class )  ;", "assertNull ( o )  ;", "}", "METHOD_END"], "methodName": ["valueType"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpressionParser   parser    =    new   SpelExpressionParser (  )  ;", "SpelExpression   expr    =    parser . parseRaw (  \"  2                    +              3  \"  )  ;", "assertEquals (  5  ,    expr . getValue (  )  )  ;", "expr    =    parser . parseRaw (  \"  2  \t  +  \t  3  \"  )  ;", "assertEquals (  5  ,    expr . getValue (  )  )  ;", "expr    =    parser . parseRaw (  \"  2  \\ n +  \\ t 3  \"  )  ;", "assertEquals (  5  ,    expr . getValue (  )  )  ;", "expr    =    parser . parseRaw (  \"  2  \\ r \\ n +  \\ t 3  \"  )  ;", "assertEquals (  5  ,    expr . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["whitespace"], "fileName": "org.springframework.expression.spel.standard.SpelParserTests"}, {"methodBody": ["METHOD_START", "{", "return   new   Token ( TokenKind . BETWEEN ,    this . startPos ,    this . endPos )  ;", "}", "METHOD_END"], "methodName": ["asBetweenToken"], "fileName": "org.springframework.expression.spel.standard.Token"}, {"methodBody": ["METHOD_START", "{", "return   new   Token ( TokenKind . INSTANCEOF ,    this . startPos ,    this . endPos )  ;", "}", "METHOD_END"], "methodName": ["asInstanceOfToken"], "fileName": "org.springframework.expression.spel.standard.Token"}, {"methodBody": ["METHOD_START", "{", "return   new   Token ( TokenKind . MATCHES ,    this . startPos ,    this . endPos )  ;", "}", "METHOD_END"], "methodName": ["asMatchesToken"], "fileName": "org.springframework.expression.spel.standard.Token"}, {"methodBody": ["METHOD_START", "{", "return   this . kind ;", "}", "METHOD_END"], "methodName": ["getKind"], "fileName": "org.springframework.expression.spel.standard.Token"}, {"methodBody": ["METHOD_START", "{", "return    ( this . kind )     =  =     ( TokenKind . IDENTIFIER )  ;", "}", "METHOD_END"], "methodName": ["isIdentifier"], "fileName": "org.springframework.expression.spel.standard.Token"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  ( this . kind )     =  =     ( TokenKind . GT )  )     |  |     (  ( this . kind )     =  =     ( TokenKind . GE )  )  )     |  |     (  ( this . kind )     =  =     ( TokenKind . LT )  )  )     |  |     (  ( this . kind )     =  =     ( TokenKind . LE )  )  )     |  |     (  ( this . kind )     =  =     ( TokenKind . EQ )  )  )     |  |     (  ( this . kind )     =  =     ( TokenKind . NE )  )  ;", "}", "METHOD_END"], "methodName": ["isNumericRelationalOperator"], "fileName": "org.springframework.expression.spel.standard.Token"}, {"methodBody": ["METHOD_START", "{", "return    ( this . data )     !  =    null    ?    this . data    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["stringValue"], "fileName": "org.springframework.expression.spel.standard.Token"}, {"methodBody": ["METHOD_START", "{", "return   this . tokenChars . length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "org.springframework.expression.spel.standard.TokenKind"}, {"methodBody": ["METHOD_START", "{", "return   this . hasPayload ;", "}", "METHOD_END"], "methodName": ["hasPayload"], "fileName": "org.springframework.expression.spel.standard.TokenKind"}, {"methodBody": ["METHOD_START", "{", "if    ( ch    >     2  5  5  )     {", "return   false ;", "}", "return    (  (  . FLAGS [ ch ]  )     &     (  . IS _ ALPHA )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["isAlphabetic"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "char   ch    =    this . charsToProcess [ this . pos ]  ;", "return    ( ch    =  =    a )     |  |     ( ch    =  =    b )  ;", "}", "METHOD_END"], "methodName": ["isChar"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "if    ( ch    >     2  5  5  )     {", "return   false ;", "}", "return    (  (  . FLAGS [ ch ]  )     &     (  . IS _ DIGIT )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["isDigit"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "return    ( ch    =  =     ' d '  )     |  |     ( ch    =  =     ' D '  )  ;", "}", "METHOD_END"], "methodName": ["isDoubleSuffix"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "return    ( this . pos )     =  =     (  ( this . max )     -     1  )  ;", "}", "METHOD_END"], "methodName": ["isExhausted"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "return    ( ch    =  =     ' e '  )     |  |     ( ch    =  =     ' E '  )  ;", "}", "METHOD_END"], "methodName": ["isExponentChar"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "return    ( ch    =  =     ' f '  )     |  |     ( ch    =  =     ' F '  )  ;", "}", "METHOD_END"], "methodName": ["isFloatSuffix"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "if    ( ch    >     2  5  5  )     {", "return   false ;", "}", "return    (  (  . FLAGS [ ch ]  )     &     (  . IS _ HEXDIGIT )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["isHexadecimalDigit"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( isAlphabetic ( ch )  )     |  |     ( isDigit ( ch )  )  )     |  |     ( ch    =  =     '  _  '  )  )     |  |     ( ch    =  =     '  $  '  )  ;", "}", "METHOD_END"], "methodName": ["isIdentifier"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "return    ( ch    =  =     '  +  '  )     |  |     ( ch    =  =     '  -  '  )  ;", "}", "METHOD_END"], "methodName": ["isSign"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( kind . tokenChars . length )     =  =     2  )     &  &     (  ( this . charsToProcess [ this . pos ]  )     =  =     ( kind . tokenChars [  0  ]  )  )  )     &  &     (  ( this . charsToProcess [  (  ( this . pos )     +     1  )  ]  )     =  =     ( kind . tokenChars [  1  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["isTwoCharToken"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "int   start    =    this . pos ;", "boolean   terminated    =    false ;", "while    (  ! terminated )     {", "( this . pos )  +  +  ;", "char   ch    =    this . charsToProcess [ this . pos ]  ;", "if    ( ch    =  =     '  \"  '  )     {", "if    (  ( this . charsToProcess [  (  ( this . pos )     +     1  )  ]  )     =  =     '  \"  '  )     {", "( this . pos )  +  +  ;", "} else    {", "terminated    =    true ;", "}", "}", "if    ( isExhausted (  )  )     {", "raiseParseException ( start ,    SpelMessage . NON _ TERMINATING _ DOUBLE _ QUOTED _ STRING )  ;", "}", "}", "( this . pos )  +  +  ;", "this . tokens . add ( new    ( Kind . LITERAL _ STRING ,    subarray ( start ,    this . pos )  ,    start ,    this . pos )  )  ;", "}", "METHOD_END"], "methodName": ["lexDoubleQuotedStringLiteral"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "int   start    =    this . pos ;", "do    {", "( this . pos )  +  +  ;", "}    while    ( isIdentifier ( this . charsToProcess [ this . pos ]  )     )  ;", "char [  ]    subarray    =    subarray ( start ,    this . pos )  ;", "if    (  (  (  ( this . pos )     -    start )     =  =     2  )     |  |     (  (  ( this . pos )     -    start )     =  =     3  )  )     {", "String   asString    =    new   String ( subarray )  . toUpperCase (  )  ;", "int   idx    =    Arrays . binarySearch (  . ALTERNATIVE _ OPERATOR _ NAMES ,    asString )  ;", "if    ( idx    >  =     0  )     {", "pushOneCharOrTwoCharToken ( TokenKind . valueOf ( asString )  ,    start ,    subarray )  ;", "return ;", "}", "}", "this . tokens . add ( new   Token ( TokenKind . IDENTIFIER ,    subarray ,    start ,    this . pos )  )  ;", "}", "METHOD_END"], "methodName": ["lexIdentifier"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "boolean   isReal    =    false ;", "int   start    =    this . pos ;", "char   ch    =    this . charsToProcess [  (  ( this . pos )     +     1  )  ]  ;", "boolean   isHex    =     ( ch    =  =     ' x '  )     |  |     ( ch    =  =     ' X '  )  ;", "if    ( firstCharIsZero    &  &    isHex )     {", "this . pos    =     ( this . pos )     +     1  ;", "do    {", "( this . pos )  +  +  ;", "}    while    ( isHexadecimalDigit ( this . charsToProcess [ this . pos ]  )     )  ;", "if    ( isChar (  ' L '  ,     ' l '  )  )     {", "pushHexInt ( subarray (  ( start    +     2  )  ,    this . pos )  ,    true ,    start ,    this . pos )  ;", "( this . pos )  +  +  ;", "} else    {", "pushHexInt ( subarray (  ( start    +     2  )  ,    this . pos )  ,    false ,    start ,    this . pos )  ;", "}", "return ;", "}", "do    {", "( this . pos )  +  +  ;", "}    while    ( isDigit ( this . charsToProcess [ this . pos ]  )     )  ;", "ch    =    this . charsToProcess [ this . pos ]  ;", "if    ( ch    =  =     '  .  '  )     {", "isReal    =    true ;", "int   dotpos    =    this . pos ;", "do    {", "( this . pos )  +  +  ;", "}    while    ( isDigit ( this . charsToProcess [ this . pos ]  )     )  ;", "if    (  ( this . pos )     =  =     ( dotpos    +     1  )  )     {", "this . pos    =    dotpos ;", "pushInt ( subarray ( start ,    this . pos )  ,    false ,    start ,    this . pos )  ;", "return ;", "}", "}", "int   endOfNumber    =    this . pos ;", "if    ( isChar (  ' L '  ,     ' l '  )  )     {", "if    ( isReal )     {", "raiseParseException ( start ,    SpelMessage . REAL _ CANNOT _ BE _ LONG )  ;", "}", "pushInt ( subarray ( start ,    endOfNumber )  ,    true ,    start ,    endOfNumber )  ;", "( this . pos )  +  +  ;", "} else", "if    ( isExponentChar ( this . charsToProcess [ this . pos ]  )  )     {", "isReal    =    true ;", "( this . pos )  +  +  ;", "char   possibleSign    =    this . charsToProcess [ this . pos ]  ;", "if    ( isSign ( possibleSign )  )     {", "( this . pos )  +  +  ;", "}", "do    {", "( this . pos )  +  +  ;", "}    while    ( isDigit ( this . charsToProcess [ this . pos ]  )     )  ;", "boolean   isFloat    =    false ;", "if    ( isFloatSuffix ( this . charsToProcess [ this . pos ]  )  )     {", "isFloat    =    true ;", "endOfNumber    =     +  +  ( this . pos )  ;", "} else", "if    ( isDoubleSuffix ( this . charsToProcess [ this . pos ]  )  )     {", "endOfNumber    =     +  +  ( this . pos )  ;", "}", "pushReal ( subarray ( start ,    this . pos )  ,    isFloat ,    start ,    this . pos )  ;", "} else    {", "ch    =    this . charsToProcess [ this . pos ]  ;", "boolean   isFloat    =    false ;", "if    ( isFloatSuffix ( ch )  )     {", "isReal    =    true ;", "isFloat    =    true ;", "endOfNumber    =     +  +  ( this . pos )  ;", "} else", "if    ( isDoubleSuffix ( ch )  )     {", "isReal    =    true ;", "endOfNumber    =     +  +  ( this . pos )  ;", "}", "if    ( isReal )     {", "pushReal ( subarray ( start ,    endOfNumber )  ,    isFloat ,    start ,    endOfNumber )  ;", "} else    {", "pushInt ( subarray ( start ,    endOfNumber )  ,    false ,    start ,    endOfNumber )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["lexNumericLiteral"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "int   start    =    this . pos ;", "boolean   terminated    =    false ;", "while    (  ! terminated )     {", "( this . pos )  +  +  ;", "char   ch    =    this . charsToProcess [ this . pos ]  ;", "if    ( ch    =  =     '  \\  '  '  )     {", "if    (  ( this . charsToProcess [  (  ( this . pos )     +     1  )  ]  )     =  =     '  \\  '  '  )     {", "( this . pos )  +  +  ;", "} else    {", "terminated    =    true ;", "}", "}", "if    ( isExhausted (  )  )     {", "raiseParseException ( start ,    SpelMessage . NON _ TERMINATING _ QUOTED _ STRING )  ;", "}", "}", "( this . pos )  +  +  ;", "this . tokens . add ( new    ( Kind . LITERAL _ STRING ,    subarray ( start ,    this . pos )  ,    start ,    this . pos )  )  ;", "}", "METHOD_END"], "methodName": ["lexQuotedStringLiteral"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "while    (  ( this . pos )     <     ( this . max )  )     {", "char   ch    =    this . charsToProcess [ this . pos ]  ;", "if    ( isAlphabetic ( ch )  )     {", "lexIdentifier (  )  ;", "} else    {", "switch    ( ch )     {", "case    '  +  '     :", "if    ( isTwoChar ( Kind . INC )  )     {", "pushPair ( Kind . INC )  ;", "} else    {", "pushChar ( Kind . PLUS )  ;", "}", "break ;", "case    '  _  '     :", "lexIdentifier (  )  ;", "break ;", "case    '  -  '     :", "if    ( isTwoChar ( Kind . DEC )  )     {", "pushPair ( Kind . DEC )  ;", "} else    {", "pushChar ( Kind . MINUS )  ;", "}", "break ;", "case    '  :  '     :", "pushChar ( Kind . COLON )  ;", "break ;", "case    '  .  '     :", "pushChar ( Kind . DOT )  ;", "break ;", "case    '  ,  '     :", "pushChar ( Kind . COMMA )  ;", "break ;", "case    '  *  '     :", "pushChar ( Kind . STAR )  ;", "break ;", "case    '  /  '     :", "pushChar ( Kind . DIV )  ;", "break ;", "case    '  %  '     :", "pushChar ( Kind . MOD )  ;", "break ;", "case    '  (  '     :", "pushChar ( Kind . LPAREN )  ;", "break ;", "case    '  )  '     :", "pushChar ( Kind . RPAREN )  ;", "break ;", "case    '  [  '     :", "pushChar ( Kind . LSQUARE )  ;", "break ;", "case    '  #  '     :", "pushChar ( Kind . HASH )  ;", "break ;", "case    '  ]  '     :", "pushChar ( Kind . RSQUARE )  ;", "break ;", "case    '  {  '     :", "pushChar ( Kind . LCURLY )  ;", "break ;", "case    '  }  '     :", "pushChar ( Kind . RCURLY )  ;", "break ;", "case    '  @  '     :", "pushChar ( Kind . BEAN _ REF )  ;", "break ;", "case    '  ^  '     :", "if    ( isTwoChar ( Kind . SELECT _ FIRST )  )     {", "pushPair ( Kind . SELECT _ FIRST )  ;", "} else    {", "pushChar ( Kind . POWER )  ;", "}", "break ;", "case    '  !  '     :", "if    ( isTwoChar ( Kind . NE )  )     {", "pushPair ( Kind . NE )  ;", "} else", "if    ( isTwoChar ( Kind . PROJECT )  )     {", "pushPair ( Kind . PROJECT )  ;", "} else    {", "pushChar ( Kind . NOT )  ;", "}", "break ;", "case    '  =  '     :", "if    ( isTwoChar ( Kind . EQ )  )     {", "pushPair ( Kind . EQ )  ;", "} else    {", "pushChar ( Kind . ASSIGN )  ;", "}", "break ;", "case    '  &  '     :", "if    ( isTwoChar ( Kind . SYMBOLIC _ AND )  )     {", "pushPair ( Kind . SYMBOLIC _ AND )  ;", "} else    {", "pushChar ( Kind . FACTORY _ BEAN _ REF )  ;", "}", "break ;", "case    '  |  '     :", "if    (  !  ( isTwoChar ( Kind . SYMBOLIC _ OR )  )  )     {", "raiseParseException ( this . pos ,    SpelMessage . MISSING _ CHARACTER ,     \"  |  \"  )  ;", "}", "pushPair ( Kind . SYMBOLIC _ OR )  ;", "break ;", "case    '  ?  '     :", "if    ( isTwoChar ( Kind . SELECT )  )     {", "pushPair ( Kind . SELECT )  ;", "} else", "if    ( isTwoChar ( Kind . ELVIS )  )     {", "pushPair ( Kind . ELVIS )  ;", "} else", "if    ( isTwoChar ( Kind . SAFE _ NAVI )  )     {", "pushPair ( Kind . SAFE _ NAVI )  ;", "} else    {", "pushChar ( Kind . QMARK )  ;", "}", "break ;", "case    '  $  '     :", "if    ( isTwoChar ( Kind . SELECT _ LAST )  )     {", "pushPair ( Kind . SELECT _ LAST )  ;", "} else    {", "lexIdentifier (  )  ;", "}", "break ;", "case    '  >  '     :", "if    ( isTwoChar ( Kind . GE )  )     {", "pushPair ( Kind . GE )  ;", "} else    {", "pushChar ( Kind . GT )  ;", "}", "break ;", "case    '  <  '     :", "if    ( isTwoChar ( Kind . LE )  )     {", "pushPair ( Kind . LE )  ;", "} else    {", "pushChar ( Kind . LT )  ;", "}", "break ;", "case    '  0  '     :", "case    '  1  '     :", "case    '  2  '     :", "case    '  3  '     :", "case    '  4  '     :", "case    '  5  '     :", "case    '  6  '     :", "case    '  7  '     :", "case    '  8  '     :", "case    '  9  '     :", "lexNumericLiteral (  ( ch    =  =     '  0  '  )  )  ;", "break ;", "case    '     '     :", "case    '  \\ t '     :", "case    '  \\ r '     :", "case    '  \\ n '     :", "( this . pos )  +  +  ;", "break ;", "case    '  \\  '  '     :", "lexQuotedStringLiteral (  )  ;", "break ;", "case    '  \"  '     :", "lexDoubleQuotedStringLiteral (  )  ;", "break ;", "case    0     :", "( this . pos )  +  +  ;", "break ;", "case    '  \\  \\  '     :", "raiseParseException ( this . pos ,    SpelMessage . UNEXPECTED _ ESCAPE _ CHAR )  ;", "break ;", "default    :", "throw   new   IllegalStateException (  (  (  (  (  \" Cannot   handle    (  \"     +     ( Integer . valueOf ( ch )  )  )     +     \"  )     '  \"  )     +    ch )     +     \"  '  \"  )  )  ;", "}", "}", "}", "return   this . tokens ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "this . tokens . add ( new   Token ( kind ,    this . pos ,     (  ( this . pos )     +     1  )  )  )  ;", "( this . pos )  +  +  ;", "}", "METHOD_END"], "methodName": ["pushCharToken"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( data . length )     =  =     0  )     {", "if    ( isLong )     {", "raiseParseException ( start ,    SpelMessage . NOT _ A _ LONG ,    thisString . substring ( start ,     ( end    +     1  )  )  )  ;", "} else    {", "raiseParseException ( start ,    SpelMessage . NOT _ AN _ INTEGER ,    thisString . substring ( start ,    end )  )  ;", "}", "}", "if    ( isLong )     {", "this . tokens . add ( new   Token ( TokenKind . LITERAL _ HEXLONG ,    data ,    start ,    end )  )  ;", "} else    {", "this . tokens . add ( new   Token ( TokenKind . LITERAL _ HEXINT ,    data ,    start ,    end )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pushHexIntToken"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "if    ( isLong )     {", "this . tokens . add ( new    ( Kind . LITERAL _ LONG ,    data ,    start ,    end )  )  ;", "} else    {", "this . tokens . add ( new    ( Kind . LITERAL _ INT ,    data ,    start ,    end )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pushIntToken"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "this . tokens . add ( new   Token ( kind ,    data ,    pos ,     ( pos    +     ( kind . getLength (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["pushOneCharOrTwoCharToken"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "this . tokens . add ( new   Token ( kind ,    this . pos ,     (  ( this . pos )     +     2  )  )  )  ;", "this . pos    +  =     2  ;", "}", "METHOD_END"], "methodName": ["pushPairToken"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "if    ( isFloat )     {", "this . tokens . add ( new    ( Kind . LITERAL _ REAL _ FLOAT ,    data ,    start ,    end )  )  ;", "} else    {", "this . tokens . add ( new    ( Kind . LITERAL _ REAL ,    data ,    start ,    end )  )  ;", "}", "}", "METHOD_END"], "methodName": ["pushRealToken"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "throw   new   InternalParseException ( new   SpelParseException ( this . expressionString ,    start ,    msg ,    inserts )  )  ;", "}", "METHOD_END"], "methodName": ["raiseParseException"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "char [  ]    result    =    new   char [ end    -    start ]  ;", "System . arraycopy ( this . charsToProcess ,    start ,    result ,     0  ,     ( end    -    start )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["subarray"], "fileName": "org.springframework.expression.spel.standard.Tokenizer"}, {"methodBody": ["METHOD_START", "{", "return   b    ?    BooleanTypedValue . TRUE    :    BooleanTypedValue . FALSE ;", "}", "METHOD_END"], "methodName": ["forValue"], "fileName": "org.springframework.expression.spel.support.BooleanTypedValue"}, {"methodBody": ["METHOD_START", "{", "return   new   DataBindingMethodResolver (  )  ;", "}", "METHOD_END"], "methodName": ["forInstanceMethodInvocation"], "fileName": "org.springframework.expression.spel.support.DataBindingMethodResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   DataBindingPropertyAccessor ( false )  ;", "}", "METHOD_END"], "methodName": ["forReadOnlyAccess"], "fileName": "org.springframework.expression.spel.support.DataBindingPropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "return   new   DataBindingPropertyAccessor ( true )  ;", "}", "METHOD_END"], "methodName": ["forReadWriteAccess"], "fileName": "org.springframework.expression.spel.support.DataBindingPropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  ( expectedArgTypes . size (  )  )     =  =     ( suppliedArgTypes . size (  )  )  )  ,     \" Expected   argument   types   and   supplied   argument   types   should   be   arrays   of   same   length \"  )  ;", ". ArgumentsMatchKind   match    =     . ArgumentsMatchKind . EXACT ;", "for    ( int   i    =     0  ;     ( i    <     ( expectedArgTypes . size (  )  )  )     &  &     ( match    !  =    null )  ;    i +  +  )     {", "TypeDescriptor   suppliedArg    =    suppliedArgTypes . get ( i )  ;", "TypeDescriptor   expectedArg    =    expectedArgTypes . get ( i )  ;", "if    ( suppliedArg    =  =    null )     {", "if    ( expectedArg . isPrimitive (  )  )     {", "match    =    null ;", "}", "} else", "if    (  !  ( expectedArg . equals ( suppliedArg )  )  )     {", "if    ( suppliedArg . isAssignableTo ( expectedArg )  )     {", "if    ( match    !  =     (  . ArgumentsMatchKind . REQUIRES _ CONVERSION )  )     {", "match    =     . ArgumentsMatchKind . CLOSE ;", "}", "} else", "if    ( typeConverter . canConvert ( suppliedArg ,    expectedArg )  )     {", "match    =     . ArgumentsMatchKind . REQUIRES _ CONVERSION ;", "} else    {", "match    =    null ;", "}", "}", "}", "return   match    !  =    null    ?    new    . ArgumentsMatchInfo ( match )     :    null ;", "}", "METHOD_END"], "methodName": ["compareArguments"], "fileName": "org.springframework.expression.spel.support.ReflectionHelper"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  (  !  ( CollectionUtils . isEmpty ( expectedArgTypes )  )  )  ,     \" Expected   arguments   must   at   least   include   one   array    ( the   varargs   parameter )  \"  )  ;", "Assert . isTrue ( expectedArgTypes . get (  (  ( expectedArgTypes . size (  )  )     -     1  )  )  . isArray (  )  ,     \" Final   expected   argument   should   be   array   type    ( the   varargs   parameter )  \"  )  ;", ". ArgumentsMatchKind   match    =     . ArgumentsMatchKind . EXACT ;", "int   argCountUpToVarargs    =     ( expectedArgTypes . size (  )  )     -     1  ;", "for    ( int   i    =     0  ;     ( i    <    argCountUpToVarargs )     &  &     ( match    !  =    null )  ;    i +  +  )     {", "TypeDescriptor   suppliedArg    =    suppliedArgTypes . get ( i )  ;", "TypeDescriptor   expectedArg    =    expectedArgTypes . get ( i )  ;", "if    ( suppliedArg    =  =    null )     {", "if    ( expectedArg . isPrimitive (  )  )     {", "match    =    null ;", "}", "} else    {", "if    (  !  ( expectedArg . equals ( suppliedArg )  )  )     {", "if    ( suppliedArg . isAssignableTo ( expectedArg )  )     {", "if    ( match    !  =     (  . ArgumentsMatchKind . REQUIRES _ CONVERSION )  )     {", "match    =     . ArgumentsMatchKind . CLOSE ;", "}", "} else", "if    ( typeConverter . canConvert ( suppliedArg ,    expectedArg )  )     {", "match    =     . ArgumentsMatchKind . REQUIRES _ CONVERSION ;", "} else    {", "match    =    null ;", "}", "}", "}", "}", "if    ( match    =  =    null )     {", "return   null ;", "}", "if    (  (  ( suppliedArgTypes . size (  )  )     =  =     ( expectedArgTypes . size (  )  )  )     &  &     ( expectedArgTypes . get (  (  ( expectedArgTypes . size (  )  )     -     1  )  )  . equals ( suppliedArgTypes . get (  (  ( suppliedArgTypes . size (  )  )     -     1  )  )  )  )  )     {", "} else    {", "TypeDescriptor   varargsDesc    =    expectedArgTypes . get (  (  ( expectedArgTypes . size (  )  )     -     1  )  )  ;", "TypeDescriptor   elementDesc    =    varargsDesc . getElementTypeDescriptor (  )  ;", "Assert . state (  ( elementDesc    !  =    null )  ,     \" No   element   type \"  )  ;", "Class <  ?  >    varargsParamType    =    elementDesc . getType (  )  ;", "for    ( int   i    =     ( expectedArgTypes . size (  )  )     -     1  ;    i    <     ( suppliedArgTypes . size (  )  )  ;    i +  +  )     {", "TypeDescriptor   suppliedArg    =    suppliedArgTypes . get ( i )  ;", "if    ( suppliedArg    =  =    null )     {", "if    ( varargsParamType . isPrimitive (  )  )     {", "match    =    null ;", "}", "} else    {", "if    ( varargsParamType    !  =     ( suppliedArg . getType (  )  )  )     {", "if    ( ClassUtils . isAssignable ( varargsParamType ,    suppliedArg . getType (  )  )  )     {", "if    ( match    !  =     (  . ArgumentsMatchKind . REQUIRES _ CONVERSION )  )     {", "match    =     . ArgumentsMatchKind . CLOSE ;", "}", "} else", "if    ( typeConverter . canConvert ( suppliedArg ,    TypeDescriptor . valueOf ( varargsParamType )  )  )     {", "match    =     . ArgumentsMatchKind . REQUIRES _ CONVERSION ;", "} else    {", "match    =    null ;", "}", "}", "}", "}", "}", "return   match    !  =    null    ?    new    . ArgumentsMatchInfo ( match )     :    null ;", "}", "METHOD_END"], "methodName": ["compareArgumentsVarargs"], "fileName": "org.springframework.expression.spel.support.ReflectionHelper"}, {"methodBody": ["METHOD_START", "{", "Integer   varargsPosition    =     ( method . isVarArgs (  )  )     ?     ( method . getParameterCount (  )  )     -     1     :    null ;", "return    . convertArguments ( converter ,    arguments ,    method ,    varargsPosition )  ;", "}", "METHOD_END"], "methodName": ["convertAllArguments"], "fileName": "org.springframework.expression.spel.support.ReflectionHelper"}, {"methodBody": ["METHOD_START", "{", "boolean   conversionOccurred    =    false ;", "if    ( varargsPosition    =  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( arguments . length )  ;    i +  +  )     {", "TypeDescriptor   targetType    =    new   TypeDescriptor ( MethodParameter . forExecutable ( executable ,    i )  )  ;", "Object   argument    =    arguments [ i ]  ;", "arguments [ i ]     =    converter . convertValue ( argument ,    TypeDescriptor . forObject ( argument )  ,    targetType )  ;", "conversionOccurred    |  =    argument    !  =     ( arguments [ i ]  )  ;", "}", "} else    {", "for    ( int   i    =     0  ;    i    <    varargsPosition ;    i +  +  )     {", "TypeDescriptor   targetType    =    new   TypeDescriptor ( MethodParameter . forExecutable ( executable ,    i )  )  ;", "Object   argument    =    arguments [ i ]  ;", "arguments [ i ]     =    converter . convertValue ( argument ,    TypeDescriptor . forObject ( argument )  ,    targetType )  ;", "conversionOccurred    |  =    argument    !  =     ( arguments [ i ]  )  ;", "}", "MethodParameter   methodParam    =    MethodParameter . forExecutable ( executable ,    varargsPosition )  ;", "if    ( varargsPosition    =  =     (  ( arguments . length )     -     1  )  )     {", "TypeDescriptor   targetType    =    new   TypeDescriptor ( methodParam )  ;", "Object   argument    =    arguments [ varargsPosition ]  ;", "TypeDescriptor   sourceType    =    TypeDescriptor . forObject ( argument )  ;", "arguments [ varargsPosition ]     =    converter . convertValue ( argument ,    sourceType ,    targetType )  ;", "if    (  ( argument    !  =     ( arguments [ varargsPosition ]  )  )     &  &     (  !  (  . isFirstEntryInArray ( argument ,    arguments [ varargsPosition ]  )  )  )  )     {", "conversionOccurred    =    true ;", "}", "} else    {", "TypeDescriptor   targetType    =    new   TypeDescriptor ( methodParam )  . getElementTypeDescriptor (  )  ;", "Assert . state (  ( targetType    !  =    null )  ,     \" No   element   type \"  )  ;", "for    ( int   i    =    varargsPosition ;    i    <     ( arguments . length )  ;    i +  +  )     {", "Object   argument    =    arguments [ i ]  ;", "arguments [ i ]     =    converter . convertValue ( argument ,    TypeDescriptor . forObject ( argument )  ,    targetType )  ;", "conversionOccurred    |  =    argument    !  =     ( arguments [ i ]  )  ;", "}", "}", "}", "return   conversionOccurred ;", "}", "METHOD_END"], "methodName": ["convertArguments"], "fileName": "org.springframework.expression.spel.support.ReflectionHelper"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( paramTypes . size (  )  )  ;    i +  +  )     {", "TypeDescriptor   paramType    =    paramTypes . get ( i )  ;", "TypeDescriptor   argType    =     ( i    <     ( argTypes . size (  )  )  )     ?    argTypes . get ( i )     :    null ;", "if    ( argType    =  =    null )     {", "if    ( paramType . isPrimitive (  )  )     {", "return   Integer . MAX _ VALUE ;", "}", "} else    {", "Class <  ?  >    paramTypeClazz    =    paramType . getType (  )  ;", "if    (  !  ( ClassUtils . isAssignable ( paramTypeClazz ,    argType . getType (  )  )  )  )     {", "return   Integer . MAX _ VALUE ;", "}", "if    ( paramTypeClazz . isPrimitive (  )  )     {", "paramTypeClazz    =    Object . class ;", "}", "Class <  ?  >    superClass    =    argType . getType (  )  . getSuperclass (  )  ;", "while    ( superClass    !  =    null )     {", "if    ( paramTypeClazz . equals ( superClass )  )     {", "result    =    result    +     2  ;", "superClass    =    null ;", "} else", "if    ( ClassUtils . isAssignable ( paramTypeClazz ,    superClass )  )     {", "result    =    result    +     2  ;", "superClass    =    superClass . getSuperclass (  )  ;", "} else    {", "superClass    =    null ;", "}", "}", "if    ( paramTypeClazz . isInterface (  )  )     {", "result    =    result    +     1  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getTypeDifferenceWeight"], "fileName": "org.springframework.expression.spel.support.ReflectionHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( possibleArray    =  =    null )     {", "return   false ;", "}", "Class <  ?  >    type    =    possibleArray . getClass (  )  ;", "if    (  (  (  !  ( type . isArray (  )  )  )     |  |     (  ( Array . getLength ( possibleArray )  )     =  =     0  )  )     |  |     (  !  ( ClassUtils . isAssignableValue ( type . getComponentType (  )  ,    value )  )  )  )     {", "return   false ;", "}", "Object   arrayValue    =    Array . get ( possibleArray ,     0  )  ;", "return   type . getComponentType (  )  . isPrimitive (  )     ?    arrayValue . equals ( value )     :    arrayValue    =  =    value ;", "}", "METHOD_END"], "methodName": ["isFirstEntryInArray"], "fileName": "org.springframework.expression.spel.support.ReflectionHelper"}, {"methodBody": ["METHOD_START", "{", "int   parameterCount    =    requiredParameterTypes . length ;", "int   argumentCount    =    args . length ;", "if    (  ( parameterCount    !  =     ( args . length )  )     |  |     (  ( requiredParameterTypes [  ( parameterCount    -     1  )  ]  )     !  =     (  ( args [  ( argumentCount    -     1  )  ]  )     !  =    null    ?    args [  ( argumentCount    -     1  )  ]  . getClass (  )     :    null )  )  )     {", "int   arraySize    =     0  ;", "if    ( argumentCount    >  =    parameterCount )     {", "arraySize    =    argumentCount    -     ( parameterCount    -     1  )  ;", "}", "Object [  ]    newArgs    =    new   Object [ parameterCount ]  ;", "System . arraycopy ( args ,     0  ,    newArgs ,     0  ,     (  ( newArgs . length )     -     1  )  )  ;", "Class <  ?  >    componentType    =    requiredParameterTypes [  ( parameterCount    -     1  )  ]  . getComponentType (  )  ;", "Object   repackagedArgs    =    Array . newInstance ( componentType ,    arraySize )  ;", "for    ( int   i    =     0  ;    i    <    arraySize ;    i +  +  )     {", "Array . set ( repackagedArgs ,    i ,    args [  (  ( parameterCount    -     1  )     +    i )  ]  )  ;", "}", "newArgs [  (  ( newArgs . length )     -     1  )  ]     =    repackagedArgs ;", "return   newArgs ;", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["setupArgumentsForVarargsInvocation"], "fileName": "org.springframework.expression.spel.support.ReflectionHelper"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( expected ,    actual )  ;", "}", "METHOD_END"], "methodName": ["checkArgument"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( expected . length ,    args . length )  ;", "for    ( int   i    =     0  ;    i    <     ( expected . length )  ;    i +  +  )     {", "checkArgument ( expected [ i ]  ,    args [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkArguments"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionHelper . ArgumentsMatchInfo   matchInfo    =    ReflectionHelper . compareArguments ( getTypeDescriptors ( expectedTypes )  ,    getTypeDescriptors ( inputTypes )  ,    typeConverter )  ;", "if    ( expectedMatchKind    =  =    null )     {", "assertNull (  \" Did   not   expect   them   to   match   in   any   way \"  ,    matchInfo )  ;", "} else    {", "assertNotNull (  \" Should   not   be   a   null   match \"  ,    matchInfo )  ;", "}", "if    ( expectedMatchKind    =  =     ( ReflectionHelper . ArgumentsMatchKind . EXACT )  )     {", "assertTrue ( matchInfo . isExactMatch (  )  )  ;", "} else", "if    ( expectedMatchKind    =  =     ( ReflectionHelper . ArgumentsMatchKind . CLOSE )  )     {", "assertTrue ( matchInfo . isCloseMatch (  )  )  ;", "} else", "if    ( expectedMatchKind    =  =     ( ReflectionHelper . ArgumentsMatchKind . REQUIRES _ CONVERSION )  )     {", "assertTrue (  (  \" expected   to   be   a   match   requiring   conversion ,    but   was    \"     +    matchInfo )  ,    matchInfo . isMatchRequiringConversion (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkMatch"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "ReflectionHelper . ArgumentsMatchInfo   matchInfo    =    ReflectionHelper . compareArgumentsVarargs ( getTypeDescriptors ( expectedTypes )  ,    getTypeDescriptors ( inputTypes )  ,    typeConverter )  ;", "if    ( expectedMatchKind    =  =    null )     {", "assertNull (  (  \" Did   not   expect   them   to   match   in   any   way :     \"     +    matchInfo )  ,    matchInfo )  ;", "} else    {", "assertNotNull (  \" Should   not   be   a   null   match \"  ,    matchInfo )  ;", "}", "if    ( expectedMatchKind    =  =     ( ReflectionHelper . ArgumentsMatchKind . EXACT )  )     {", "assertTrue ( matchInfo . isExactMatch (  )  )  ;", "} else", "if    ( expectedMatchKind    =  =     ( ReflectionHelper . ArgumentsMatchKind . CLOSE )  )     {", "assertTrue ( matchInfo . isCloseMatch (  )  )  ;", "} else", "if    ( expectedMatchKind    =  =     ( ReflectionHelper . ArgumentsMatchKind . REQUIRES _ CONVERSION )  )     {", "assertTrue (  (  \" expected   to   be   a   match   requiring   conversion ,    but   was    \"     +    matchInfo )  ,    matchInfo . isMatchRequiringConversion (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkMatch2"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "List < TypeDescriptor >    typeDescriptors    =    new   ArrayList <  >  ( types . length )  ;", "for    ( Class <  ?  >    type    :    types )     {", "typeDescriptors . add ( TypeDescriptor . valueOf ( type )  )  ;", "}", "return   typeDescriptors ;", "}", "METHOD_END"], "methodName": ["getTypeDescriptors"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "StandardTypeConverter   tc    =    new   StandardTypeConverter (  )  ;", "Method   oneArg    =     . TestInterface . class . getMethod (  \" oneArg \"  ,    String . class )  ;", "Method   twoArg    =     . TestInterface . class . getMethod (  \" twoArg \"  ,    String . class ,    String [  ]  . class )  ;", "Object [  ]    args    =    new   Object [  ]  {     3     }  ;", "ReflectionHelper . convertArguments ( tc ,    args ,    oneArg ,    null )  ;", "checkArguments ( args ,     \"  3  \"  )  ;", "args    =    new   Object [  ]  {     3     }  ;", "ReflectionHelper . convertArguments ( tc ,    args ,    twoArg ,     1  )  ;", "checkArguments ( args ,     \"  3  \"  )  ;", "args    =    new   Object [  ]  {     3  ,     \" abc \"  ,     \" abc \"     }  ;", "ReflectionHelper . convertArguments ( tc ,    args ,    twoArg ,     1  )  ;", "checkArguments ( args ,     \"  3  \"  ,     \" abc \"  ,     \" abc \"  )  ;", "args    =    new   Object [  ]  {     3  ,    false ,     3  .  0     }  ;", "ReflectionHelper . convertArguments ( tc ,    args ,    twoArg ,     1  )  ;", "checkArguments ( args ,     \"  3  \"  ,     \" false \"  ,     \"  3  .  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testConvertArguments"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "StandardTypeConverter   tc    =    new   StandardTypeConverter (  )  ;", "Method   oneArg    =     . TestInterface . class . getMethod (  \" oneArg \"  ,    String . class )  ;", "Method   twoArg    =     . TestInterface . class . getMethod (  \" twoArg \"  ,    String . class ,    String [  ]  . class )  ;", "Object [  ]    args    =    new   Object [  ]  {     3     }  ;", "ReflectionHelper . convertAllArguments ( tc ,    args ,    oneArg )  ;", "checkArguments ( args ,     \"  3  \"  )  ;", "args    =    new   Object [  ]  {     3  ,    false ,     3  .  0 F    }  ;", "ReflectionHelper . convertAllArguments ( tc ,    args ,    twoArg )  ;", "checkArguments ( args ,     \"  3  \"  ,     \" false \"  ,     \"  3  .  0  \"  )  ;", "args    =    new   Object [  ]  {     3     }  ;", "ReflectionHelper . convertAllArguments ( tc ,    args ,    twoArg )  ;", "checkArguments ( args ,     \"  3  \"  )  ;", "args    =    new   Object [  ]  {     3  ,    null ,     3  .  0 F    }  ;", "ReflectionHelper . convertAllArguments ( tc ,    args ,    twoArg )  ;", "checkArguments ( args ,     \"  3  \"  ,    null ,     \"  3  .  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testConvertArguments2"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" String \"  ,    FormatHelper . formatClassNameForMessage ( String . class )  )  ;", "assertEquals (  \" String [  ]  \"  ,    FormatHelper . formatClassNameForMessage ( String [  ]  . class )  )  ;", "assertEquals (  \" String [  ]  [  ]  \"  ,    FormatHelper . formatClassNameForMessage ( String [  ]  [  ]  . class )  )  ;", "assertEquals (  \" int [  ]  \"  ,    FormatHelper . formatClassNameForMessage ( int [  ]  . class )  )  ;", "assertEquals (  \" int [  ]  [  ]  \"  ,    FormatHelper . formatClassNameForMessage ( int [  ]  [  ]  . class )  )  ;", "assertEquals (  \" null \"  ,    FormatHelper . formatClassNameForMessage ( null )  )  ;", "}", "METHOD_END"], "methodName": ["testFormatHelperForClassName"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "ReflectivePropertyAccessor   rpa    =    new   ReflectivePropertyAccessor (  )  ;", ". Tester   t    =    new    . Tester (  )  ;", "t . setProperty (  \" hello \"  )  ;", "EvaluationContext   ctx    =    new   StandardEvaluationContext ( t )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" property \"  )  )  ;", "assertEquals (  \" hello \"  ,    rpa . read ( ctx ,    t ,     \" property \"  )  . getValue (  )  )  ;", "assertEquals (  \" hello \"  ,    rpa . read ( ctx ,    t ,     \" property \"  )  . getValue (  )  )  ;", "PropertyAccessor   optA    =    rpa . createOptimalAccessor ( ctx ,    t ,     \" property \"  )  ;", "assertTrue ( optA . canRead ( ctx ,    t ,     \" property \"  )  )  ;", "assertFalse ( optA . canRead ( ctx ,    t ,     \" property 2  \"  )  )  ;", "try    {", "optA . canWrite ( ctx ,    t ,     \" property \"  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   uoe )     {", "}", "try    {", "optA . canWrite ( ctx ,    t ,     \" property 2  \"  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   uoe )     {", "}", "assertEquals (  \" hello \"  ,    optA . read ( ctx ,    t ,     \" property \"  )  . getValue (  )  )  ;", "assertEquals (  \" hello \"  ,    optA . read ( ctx ,    t ,     \" property \"  )  . getValue (  )  )  ;", "try    {", "optA . getSpecificTargetClasses (  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   uoe )     {", "}", "try    {", "optA . write ( ctx ,    t ,     \" property \"  ,    null )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   uoe )     {", "}", "optA    =    rpa . createOptimalAccessor ( ctx ,    t ,     \" field \"  )  ;", "assertTrue ( optA . canRead ( ctx ,    t ,     \" field \"  )  )  ;", "assertFalse ( optA . canRead ( ctx ,    t ,     \" field 2  \"  )  )  ;", "try    {", "optA . canWrite ( ctx ,    t ,     \" field \"  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   uoe )     {", "}", "try    {", "optA . canWrite ( ctx ,    t ,     \" field 2  \"  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   uoe )     {", "}", "assertEquals (  3  ,    optA . read ( ctx ,    t ,     \" field \"  )  . getValue (  )  )  ;", "assertEquals (  3  ,    optA . read ( ctx ,    t ,     \" field \"  )  . getValue (  )  )  ;", "try    {", "optA . getSpecificTargetClasses (  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   uoe )     {", "}", "try    {", "optA . write ( ctx ,    t ,     \" field \"  ,    null )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   uoe )     {", "}", "}", "METHOD_END"], "methodName": ["testOptimalReflectivePropertyAccessor"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "StandardTypeConverter   tc    =    new   StandardTypeConverter (  )  ;", "checkMatch ( new   Class <  ?  >  [  ]  {    ArrayList . class    }  ,    new   Class <  ?  >  [  ]  {    List . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . CLOSE )  ;", "checkMatch ( new   Class <  ?  >  [  ]  {     . Sub . class ,    String . class    }  ,    new   Class <  ?  >  [  ]  {     . Super . class ,    String . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . CLOSE )  ;", "checkMatch ( new   Class <  ?  >  [  ]  {    String . class ,     . Sub . class    }  ,    new   Class <  ?  >  [  ]  {    String . class ,     . Super . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . CLOSE )  ;", "}", "METHOD_END"], "methodName": ["testReflectionHelperCompareArguments_CloseMatching"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "StandardTypeConverter   tc    =    new   StandardTypeConverter (  )  ;", "checkMatch ( new   Class <  ?  >  [  ]  {    String . class    }  ,    new   Class <  ?  >  [  ]  {    String . class    }  ,    tc ,     . ArgumentsMatchKind . EXACT )  ;", "checkMatch ( new   Class <  ?  >  [  ]  {    String . class ,    Integer . class    }  ,    new   Class <  ?  >  [  ]  {    String . class ,    Integer . class    }  ,    tc ,     . ArgumentsMatchKind . EXACT )  ;", "}", "METHOD_END"], "methodName": ["testReflectionHelperCompareArguments_ExactMatching"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "StandardTypeConverter   typeConverter    =    new   StandardTypeConverter (  )  ;", "checkMatch ( new   Class <  ?  >  [  ]  {     . Super . class ,    String . class    }  ,    new   Class <  ?  >  [  ]  {     . Sub . class ,    String . class    }  ,    typeConverter ,    null )  ;", "}", "METHOD_END"], "methodName": ["testReflectionHelperCompareArguments_NotAMatch"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "StandardTypeConverter   tc    =    new   StandardTypeConverter (  )  ;", "checkMatch ( new   Class <  ?  >  [  ]  {    String . class ,    Integer . TYPE    }  ,    new   Class <  ?  >  [  ]  {    String . class ,    Integer . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . CLOSE )  ;", "checkMatch ( new   Class <  ?  >  [  ]  {    Integer . TYPE ,    String . class    }  ,    new   Class <  ?  >  [  ]  {    Integer . class ,    String . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . CLOSE )  ;", "checkMatch ( new   Class <  ?  >  [  ]  {    Integer . TYPE ,     . Sub . class    }  ,    new   Class <  ?  >  [  ]  {    Integer . class ,     . Super . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . CLOSE )  ;", "}", "METHOD_END"], "methodName": ["testReflectionHelperCompareArguments_RequiresConversionMatching"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "StandardTypeConverter   tc    =    new   StandardTypeConverter (  )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    String [  ]  . class    }  ,    new   Class <  ?  >  [  ]  {    String [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . EXACT )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    Integer . class ,    String [  ]  . class    }  ,    new   Class <  ?  >  [  ]  {    Integer . class ,    String [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . EXACT )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    String . class ,    Integer . class ,    String [  ]  . class    }  ,    new   Class <  ?  >  [  ]  {    String . class ,    Integer . class ,    String [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . EXACT )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {     . Sub . class ,    String [  ]  . class    }  ,    new   Class <  ?  >  [  ]  {     . Super . class ,    String [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . CLOSE )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    Integer . class ,    String [  ]  . class    }  ,    new   Class <  ?  >  [  ]  {    String . class ,    String [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . REQUIRES _ CONVERSION )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    Integer . class ,     . Sub . class ,    String [  ]  . class    }  ,    new   Class <  ?  >  [  ]  {    String . class ,     . Super . class ,    String [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . REQUIRES _ CONVERSION )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    String . class    }  ,    new   Class <  ?  >  [  ]  {    String [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . EXACT )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    Integer . class ,    String . class    }  ,    new   Class <  ?  >  [  ]  {    Integer . class ,    String [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . EXACT )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    String . class    }  ,    new   Class <  ?  >  [  ]  {    Integer [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . REQUIRES _ CONVERSION )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {     . Sub . class    }  ,    new   Class <  ?  >  [  ]  {     . Super [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . CLOSE )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {     . Super . class    }  ,    new   Class <  ?  >  [  ]  {     . Sub [  ]  . class    }  ,    tc ,    null )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {     . Unconvertable . class ,    String . class    }  ,    new   Class <  ?  >  [  ]  {     . Sub . class ,     . Super [  ]  . class    }  ,    tc ,    null )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    Integer . class ,    Integer . class ,    String . class    }  ,    new   Class <  ?  >  [  ]  {    String . class ,    String . class ,     . Super [  ]  . class    }  ,    tc ,    null )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {     . Unconvertable . class ,    String . class    }  ,    new   Class <  ?  >  [  ]  {     . Sub . class ,     . Super [  ]  . class    }  ,    tc ,    null )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    Integer . class ,    Integer . class ,    String . class    }  ,    new   Class <  ?  >  [  ]  {    String . class ,    String . class ,     . Super [  ]  . class    }  ,    tc ,    null )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    Integer . class ,    Integer . class ,     . Sub . class    }  ,    new   Class <  ?  >  [  ]  {    String . class ,    String . class ,     . Super [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . REQUIRES _ CONVERSION )  ;", "checkMatch 2  ( new   Class <  ?  >  [  ]  {    Integer . class ,    Integer . class ,    Integer . class    }  ,    new   Class <  ?  >  [  ]  {    Integer . class ,    String [  ]  . class    }  ,    tc ,    ReflectionHelper . ArgumentsMatchKind . REQUIRES _ CONVERSION )  ;", "}", "METHOD_END"], "methodName": ["testReflectionHelperCompareArguments_Varargs_ExactMatching"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "ReflectivePropertyAccessor   rpa    =    new   ReflectivePropertyAccessor (  )  ;", ". Tester   t    =    new    . Tester (  )  ;", "t . setProperty (  \" hello \"  )  ;", "EvaluationContext   ctx    =    new   StandardEvaluationContext ( t )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" property \"  )  )  ;", "assertEquals (  \" hello \"  ,    rpa . read ( ctx ,    t ,     \" property \"  )  . getValue (  )  )  ;", "assertEquals (  \" hello \"  ,    rpa . read ( ctx ,    t ,     \" property \"  )  . getValue (  )  )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" field \"  )  )  ;", "assertEquals (  3  ,    rpa . read ( ctx ,    t ,     \" field \"  )  . getValue (  )  )  ;", "assertEquals (  3  ,    rpa . read ( ctx ,    t ,     \" field \"  )  . getValue (  )  )  ;", "assertTrue ( rpa . canWrite ( ctx ,    t ,     \" property \"  )  )  ;", "rpa . write ( ctx ,    t ,     \" property \"  ,     \" goodbye \"  )  ;", "rpa . write ( ctx ,    t ,     \" property \"  ,     \" goodbye \"  )  ;", "assertTrue ( rpa . canWrite ( ctx ,    t ,     \" field \"  )  )  ;", "rpa . write ( ctx ,    t ,     \" field \"  ,     1  2  )  ;", "rpa . write ( ctx ,    t ,     \" field \"  ,     1  2  )  ;", "rpa . write ( ctx ,    t ,     \" field 2  \"  ,     3  )  ;", "rpa . write ( ctx ,    t ,     \" property 2  \"  ,     \" doodoo \"  )  ;", "assertEquals (  3  ,    rpa . read ( ctx ,    t ,     \" field 2  \"  )  . getValue (  )  )  ;", "assertEquals (  0  ,    rpa . read ( ctx ,    t ,     \" field 3  \"  )  . getValue (  )  )  ;", "assertEquals (  \" doodoo \"  ,    rpa . read ( ctx ,    t ,     \" property 3  \"  )  . getValue (  )  )  ;", "assertEquals (  0  ,    rpa . read ( ctx ,    t ,     \" field 3  \"  )  . getValue (  )  )  ;", "assertEquals ( false ,    rpa . read ( ctx ,    t ,     \" property 4  \"  )  . getValue (  )  )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" property 4  \"  )  )  ;", "assertEquals (  \" iD \"  ,    rpa . read ( ctx ,    t ,     \" iD \"  )  . getValue (  )  )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" iD \"  )  )  ;", "assertEquals (  \" id \"  ,    rpa . read ( ctx ,    t ,     \" id \"  )  . getValue (  )  )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" id \"  )  )  ;", "assertEquals (  \" ID \"  ,    rpa . read ( ctx ,    t ,     \" ID \"  )  . getValue (  )  )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" ID \"  )  )  ;", "assertEquals (  \" id \"  ,    rpa . read ( ctx ,    t ,     \" Id \"  )  . getValue (  )  )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" Id \"  )  )  ;", "assertEquals (  \" xyZ \"  ,    rpa . read ( ctx ,    t ,     \" xyZ \"  )  . getValue (  )  )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" xyZ \"  )  )  ;", "assertEquals (  \" xY \"  ,    rpa . read ( ctx ,    t ,     \" xY \"  )  . getValue (  )  )  ;", "assertTrue ( rpa . canRead ( ctx ,    t ,     \" xY \"  )  )  ;", "rpa . write ( ctx ,    t ,     \" pEBS \"  ,     \" Test   String \"  )  ;", "assertEquals (  \" Test   String \"  ,    rpa . read ( ctx ,    t ,     \" pEBS \"  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReflectivePropertyAccessor"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    newArray    =    ReflectionHelper . setupArgumentsForVarargsInvocation ( new   Class <  ?  >  [  ]  {    String [  ]  . class    }  ,     \" a \"  ,     \" b \"  ,     \" c \"  )  ;", "assertEquals (  1  ,    newArray . length )  ;", "Object   firstParam    =    newArray [  0  ]  ;", "assertEquals ( String . class ,    firstParam . getClass (  )  . getComponentType (  )  )  ;", "Object [  ]    firstParamArray    =     (  ( Object [  ]  )     ( firstParam )  )  ;", "assertEquals (  3  ,    firstParamArray . length )  ;", "assertEquals (  \" a \"  ,    firstParamArray [  0  ]  )  ;", "assertEquals (  \" b \"  ,    firstParamArray [  1  ]  )  ;", "assertEquals (  \" c \"  ,    firstParamArray [  2  ]  )  ;", "}", "METHOD_END"], "methodName": ["testSetupArguments"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "TypedValue   tv 1     =    new   TypedValue (  \" hello \"  )  ;", "TypedValue   tv 2     =    new   TypedValue (  \" hello \"  )  ;", "TypedValue   tv 3     =    new   TypedValue (  \" bye \"  )  ;", "assertEquals ( St . class ,    tv 1  . getTypeDescriptor (  )  . getType (  )  )  ;", "assertEquals (  \" TypedValue :     ' hello '    of    [ St ]  \"  ,    tv 1  . toSt (  )  )  ;", "assertEquals ( tv 1  ,    tv 2  )  ;", "assertEquals ( tv 2  ,    tv 1  )  ;", "assertNotEquals ( tv 1  ,    tv 3  )  ;", "assertNotEquals ( tv 2  ,    tv 3  )  ;", "assertNotEquals ( tv 3  ,    tv 1  )  ;", "assertNotEquals ( tv 3  ,    tv 2  )  ;", "assertEquals ( tv 1  . hashCode (  )  ,    tv 2  . hashCode (  )  )  ;", "assertNotEquals ( tv 1  . hashCode (  )  ,    tv 3  . hashCode (  )  )  ;", "assertNotEquals ( tv 2  . hashCode (  )  ,    tv 3  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTypedValue"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "SpelExpression   expr    =     (  ( SpelExpression )     ( parser . parseExpression (  \"  3  +  4  +  5  +  6  +  7  -  2  \"  )  )  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintStream   ps    =    new   PrintStream ( baos )  ;", "SpelUtilities . printAbstractSyntaxTree ( ps ,    expr )  ;", "ps . flush (  )  ;", "String   s    =    baos . toString (  )  ;", "assertTrue ( s . contains (  \"  =  =  =  >    Expression    '  3  +  4  +  5  +  6  +  7  -  2  '     -    AST   start \"  )  )  ;", "assertTrue ( s . contains (  \"    OpPlus      value :  (  (  (  (  3     +     4  )     +     5  )     +     6  )     +     7  )        # children :  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testUtilities"], "fileName": "org.springframework.expression.spel.support.ReflectionHelperTests"}, {"methodBody": ["METHOD_START", "{", "return   this . ctor ;", "}", "METHOD_END"], "methodName": ["getConstructor"], "fileName": "org.springframework.expression.spel.support.ReflectiveConstructorExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . argumentConversionOccurred ;", "}", "METHOD_END"], "methodName": ["didArgumentConversionOccur"], "fileName": "org.springframework.expression.spel.support.ReflectiveMethodExecutor"}, {"methodBody": ["METHOD_START", "{", "if    ( Modifier . isPublic ( clazz . getModifiers (  )  )  )     {", "try    {", "clazz . getDeclaredMethod ( method . getName (  )  ,    method . getParameterTypes (  )  )  ;", "return   clazz ;", "}    catch    ( NoSuchception   ex )     {", "}", "}", "Class <  ?  >  [  ]    ifcs    =    clazz . getInterfaces (  )  ;", "for    ( Class <  ?  >    ifc    :    ifcs )     {", "discoverPublicClass ( method ,    ifc )  ;", "}", "if    (  ( clazz . getSuperclass (  )  )     !  =    null )     {", "return   discoverPublicClass ( method ,    clazz . getSuperclass (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["discoverPublicClass"], "fileName": "org.springframework.expression.spel.support.ReflectiveMethodExecutor"}, {"methodBody": ["METHOD_START", "{", "return   this . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.springframework.expression.spel.support.ReflectiveMethodExecutor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . computedPublicDeclaringClass )  )     {", "this . publicDeclaringClass    =    discoverPublicClass ( this . m ,    this . m . getDeclaringClass (  )  )  ;", "this . computedPublicDeclaringClass    =    true ;", "}", "return   this . publicDeclaringClass ;", "}", "METHOD_END"], "methodName": ["getPublicDeclaringClass"], "fileName": "org.springframework.expression.spel.support.ReflectiveMethodExecutor"}, {"methodBody": ["METHOD_START", "{", "return   type . getMethods (  )  ;", "}", "METHOD_END"], "methodName": ["getMethods"], "fileName": "org.springframework.expression.spel.support.ReflectiveMethodResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( targetObject   instanceof   Class )     {", "Set <  >    result    =    new   LinkedHashSet <  >  (  )  ;", "[  ]    methods    =    gets ( type )  ;", "for    (    method    :    methods )     {", "if    ( Modifier . isStatic ( method . getModifiers (  )  )  )     {", "result . add ( method )  ;", "}", "}", "Collections . addAll ( result ,    gets ( Class . class )  )  ;", "return   result ;", "} else", "if    ( isProxyClass ( type )  )     {", "Set <  >    result    =    new   LinkedHashSet <  >  (  )  ;", "for    ( Class <  ?  >    ifc    :    type . getInterfaces (  )  )     {", "[  ]    methods    =    gets ( ifc )  ;", "for    (    method    :    methods )     {", "if    ( isCandidateForInvocation ( method ,    type )  )     {", "result . add ( method )  ;", "}", "}", "}", "return   result ;", "} else    {", "Set <  >    result    =    new   LinkedHashSet <  >  (  )  ;", "[  ]    methods    =    gets ( type )  ;", "for    (    method    :    methods )     {", "if    ( isCandidateForInvocation ( method ,    type )  )     {", "result . add ( method )  ;", "}", "}", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["getMethods"], "fileName": "org.springframework.expression.spel.support.ReflectiveMethodResolver"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isCandidateForInvocation"], "fileName": "org.springframework.expression.spel.support.ReflectiveMethodResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . filters )     =  =    null )     {", "this . filters    =    new   HashMap <  >  (  )  ;", "}", "if    ( filter    !  =    null )     {", "this . filters . put ( type ,    filter )  ;", "} else    {", "this . filters . remove ( type )  ;", "}", "}", "METHOD_END"], "methodName": ["registerMethodFilter"], "fileName": "org.springframework.expression.spel.support.ReflectiveMethodResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( target    =  =    null )     {", "return   this ;", "}", "Class <  ?  >    clazz    =     ( target   instanceof   Class )     ?     (  ( Class <  ?  >  )     ( target )  )     :    target . getClass (  )  ;", "if    ( clazz . isArray (  )  )     {", "return   this ;", "}", ". PropertyCacheKey   cacheKey    =    new    . PropertyCacheKey ( clazz ,    name ,     ( target   instanceof   Class )  )  ;", ". InvokerPair   invocationTarget    =    this . readerCache . get ( cacheKey )  ;", "if    (  ( invocationTarget    =  =    null )     |  |     (  ( invocationTarget . member )    instanceof   Method )  )     {", "Method   method    =     (  ( Method )     (  ( invocationTarget    !  =    null )     ?    invocationTarget . member    :    null )  )  ;", "if    ( method    =  =    null )     {", "method    =    findGetterForProperty ( name ,    clazz ,    target )  ;", "if    ( method    !  =    null )     {", "invocationTarget    =    new    . InvokerPair ( method ,    new   TypeDescriptor ( new   MethodParameter ( method ,     (  -  1  )  )  )  )  ;", "ReflectionUtils . makeAccessible ( method )  ;", "this . readerCache . put ( cacheKey ,    invocationTarget )  ;", "}", "}", "if    ( method    !  =    null )     {", "return   new    . OptimalPropertyAccessor ( invocationTarget )  ;", "}", "}", "if    (  ( invocationTarget    =  =    null )     |  |     (  ( invocationTarget . member )    instanceof   Field )  )     {", "Field   field    =     ( invocationTarget    !  =    null )     ?     (  ( Field )     ( invocationTarget . member )  )     :    null ;", "if    ( field    =  =    null )     {", "field    =    findField ( name ,    clazz ,     ( target   instanceof   Class )  )  ;", "if    ( field    !  =    null )     {", "invocationTarget    =    new    . InvokerPair ( field ,    new   TypeDescriptor ( field )  )  ;", "ReflectionUtils . makeAccessible ( field )  ;", "this . readerCache . put ( cacheKey ,    invocationTarget )  ;", "}", "}", "if    ( field    !  =    null )     {", "return   new    . OptimalPropertyAccessor ( invocationTarget )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["createOptimalAccessor"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Field [  ]    fields    =    clazz . getFields (  )  ;", "for    ( Field   field    :    fields )     {", "if    (  ( field . getN (  )  . equals ( n )  )     &  &     (  (  ! mustBeStatic )     |  |     ( Modifier . isStatic ( field . getModifiers (  )  )  )  )  )     {", "return   field ;", "}", "}", "if    (  ( clazz . getSuperclass (  )  )     !  =    null )     {", "Field   field    =    findField ( n ,    clazz . getSuperclass (  )  ,    mustBeStatic )  ;", "if    ( field    !  =    null )     {", "return   field ;", "}", "}", "for    ( Class <  ?  >    implementedInterface    :    clazz . getInterfaces (  )  )     {", "Field   field    =    findField ( n ,    implementedInterface ,    mustBeStatic )  ;", "if    ( field    !  =    null )     {", "return   field ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findField"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    findField ( name ,    clazz ,     ( target   instanceof   Class )  )  ;", "if    (  ( field    =  =    null )     &  &     ( target   instanceof   Class )  )     {", "field    =    findField ( name ,    target . getClass (  )  ,    false )  ;", "}", "return   field ;", "}", "METHOD_END"], "methodName": ["findField"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    findMethodForProperty ( getPropertyMethodSuffixes ( propertyName )  ,     \" get \"  ,    clazz ,    mustBeStatic ,     0  ,    ReflectivePropertyAccessor . ANY _ TYPES )  ;", "if    ( method    =  =    null )     {", "method    =    findMethodForProperty ( getPropertyMethodSuffixes ( propertyName )  ,     \" is \"  ,    clazz ,    mustBeStatic ,     0  ,    ReflectivePropertyAccessor . BOOLEAN _ TYPES )  ;", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["findGetterForProperty"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    findGetterForProperty ( propertyName ,    clazz ,     ( target   instanceof   Class )  )  ;", "if    (  ( method    =  =    null )     &  &     ( target   instanceof   Class )  )     {", "method    =    findGetterForProperty ( propertyName ,    target . getClass (  )  ,    false )  ;", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["findGetterForProperty"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    getSortedClassMethods ( clazz )  ;", "for    ( String   methodSuffix    :    methodSuffixes )     {", "for    ( Method   method    :    methods )     {", "if    (  (  (  (  ( isCandidateFor ( method ,    clazz )  )     &  &     ( method . getName (  )  . equals (  ( prefix    +    methodSuffix )  )  )  )     &  &     (  ( method . getParameterCount (  )  )     =  =    numberOfParams )  )     &  &     (  (  ! mustBeStatic )     |  |     ( Modifier . isStatic ( method . getModifiers (  )  )  )  )  )     &  &     (  ( requiredReturnTypes . isEmpty (  )  )     |  |     ( requiredReturnTypes . contains ( method . getReturnType (  )  )  )  )  )     {", "return   method ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findMethodForProperty"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "return   findMethodForProperty ( getPropertyMethodSuffixes ( propertyName )  ,     \" set \"  ,    clazz ,    mustBeStatic ,     1  ,    ReflectivePropertyAccessor . ANY _ TYPES )  ;", "}", "METHOD_END"], "methodName": ["findSetterForProperty"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Method   method    =    findSetterForProperty ( propertyName ,    clazz ,     ( target   instanceof   Class )  )  ;", "if    (  ( method    =  =    null )     &  &     ( target   instanceof   Class )  )     {", "method    =    findSetterForProperty ( propertyName ,    target . getClass (  )  ,    false )  ;", "}", "return   method ;", "}", "METHOD_END"], "methodName": ["findSetterForProperty"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "ReflectivePropertyAccessor . InvokerPair   lastReadInvoker    =    this . lastReadInvokerPair ;", "return   lastReadInvoker    !  =    null    ?    lastReadInvoker . member    :    null ;", "}", "METHOD_END"], "methodName": ["getLastReadInvokerPair"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( propertyName . length (  )  )     >     1  )     &  &     ( Character . isUpperCase ( propertyName . charAt (  1  )  )  )  )     {", "return   propertyName ;", "}", "return   StringUtils . capitalize ( propertyName )  ;", "}", "METHOD_END"], "methodName": ["getPropertyMethodSuffix"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "String   suffix    =    getPropertyMethodSuffix ( propertyName )  ;", "if    (  (  ( suffix . length (  )  )     >     0  )     &  &     ( Character . isUpperCase ( suffix . charAt (  0  )  )  )  )     {", "return   new   String [  ]  {    suffix    }  ;", "}", "return   new   String [  ]  {    suffix ,    StringUtils . capitalize ( suffix )     }  ;", "}", "METHOD_END"], "methodName": ["getPropertyMethodSuffixes"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    clazz . getMethods (  )  ;", "Arrays . s ( methods ,     (    o 1  ,    o 2  )     -  >     ( o 1  . isBridge (  )  )     =  =     ( o 2  . isBridge (  )  )     ?     0     :    o 1  . isBridge (  )     ?     1     :     -  1  )  ;", "return   methods ;", "}", "METHOD_END"], "methodName": ["getSortedClassMethods"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    type    =     ( target   instanceof   Class )     ?     (  ( Class <  ?  >  )     ( target )  )     :    target . getClass (  )  ;", "if    (  ( type . isArray (  )  )     &  &     ( name . equals (  \" length \"  )  )  )     {", "return   TypeDescriptor . valueOf ( Integer . TYPE )  ;", "}", ". PropertyCacheKey   cacheKey    =    new    . PropertyCacheKey ( type ,    name ,     ( target   instanceof   Class )  )  ;", "TypeDescriptor   typeDescriptor    =    this . typeDescriptorCache . get ( cacheKey )  ;", "if    ( typeDescriptor    =  =    null )     {", "try    {", "if    (  ( canRead ( context ,    target ,    name )  )     |  |     ( canWrite ( context ,    target ,    name )  )  )     {", "typeDescriptor    =    this . typeDescriptorCache . get ( cacheKey )  ;", "}", "}    catch    ( AccessException   ex )     {", "}", "}", "return   typeDescriptor ;", "}", "METHOD_END"], "methodName": ["getTypeDescriptor"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isCandidateForProperty"], "fileName": "org.springframework.expression.spel.support.ReflectivePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "for    ( PropertyAccessor   accessor    :    accessors )     {", "if    (  ( accessor . getClass (  )  )     =  =     ( ReflectivePropertyAccessor . class )  )     {", "throw   new   IllegalArgumentException (  (  \"    is   not   designed   for   use   with   a   plain    \"     +     \" ReflectivePropertyAccessor .    Consider   using   DataBindingPropertyAccessor   or   a   custom   subclass .  \"  )  )  ;", "}", "}", "return   new    . Builder ( accessors )  ;", "}", "METHOD_END"], "methodName": ["forPropertyAccessors"], "fileName": "org.springframework.expression.spel.support.SimpleEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleEvaluationContext . Builder ( DataBindingPropertyAccessor . forReadOnlyAccess (  )  )  ;", "}", "METHOD_END"], "methodName": ["forReadOnlyDataBinding"], "fileName": "org.springframework.expression.spel.support.SimpleEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleEvaluationContext . Builder ( DataBindingPropertyAccessor . forReadWriteAccess (  )  )  ;", "}", "METHOD_END"], "methodName": ["forReadWriteDataBinding"], "fileName": "org.springframework.expression.spel.support.SimpleEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext   context    =    new   StandardEvaluationContext (  )  ;", "assertNotNull ( context . getTypeComparator (  )  )  ;", "TypeComparator   tc    =    new   StandardTypeComparator (  )  ;", "context . setTypeComparator ( tc )  ;", "assertEquals ( tc ,    context . getTypeComparator (  )  )  ;", "TypeLocator   tl    =    new   StandardTypeLocator (  )  ;", "context . setTypeLocator ( tl )  ;", "assertEquals ( tl ,    context . getTypeLocator (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardEvaluationContext"], "fileName": "org.springframework.expression.spel.support.StandardComponentsTests"}, {"methodBody": ["METHOD_START", "{", "OperatorOverloader   oo    =    new   StandardOperatorOverloader (  )  ;", "assertFalse ( oo . overridesOperation ( Operation . ADD ,    null ,    null )  )  ;", "oo . operate ( Operation . ADD ,     2  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testStandardOperatorOverloader"], "fileName": "org.springframework.expression.spel.support.StandardComponentsTests"}, {"methodBody": ["METHOD_START", "{", "TypeConverter   tc    =    new   StandardTypeConverter (  )  ;", "tc . convertValue (  3  ,    TypeDescriptor . forObject (  3  )  ,    TypeDescriptor . valueOf ( Double . class )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardTypeConverter"], "fileName": "org.springframework.expression.spel.support.StandardComponentsTests"}, {"methodBody": ["METHOD_START", "{", "StandardTypeLocator   tl    =    new   StandardTypeLocator (  )  ;", "List < String >    prefixes    =    tl . getImportPrefixes (  )  ;", "assertEquals (  1  ,    prefixes . size (  )  )  ;", "tl . registerImport (  \" util \"  )  ;", "prefixes    =    tl . getImportPrefixes (  )  ;", "assertEquals (  2  ,    prefixes . size (  )  )  ;", "tl . removeImport (  \" util \"  )  ;", "prefixes    =    tl . getImportPrefixes (  )  ;", "assertEquals (  1  ,    prefixes . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardTypeLocator"], "fileName": "org.springframework.expression.spel.support.StandardComponentsTests"}, {"methodBody": ["METHOD_START", "{", "resolvers . add (  (  ( resolvers . size (  )  )     -     1  )  ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["addBeforeDefault"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext . addBeforeDefault ( initConstructorResolvers (  )  ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["addConstructorResolver"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext . addBeforeDefault ( initMethodResolvers (  )  ,    resolver )  ;", "}", "METHOD_END"], "methodName": ["addMethodResolver"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "StandardEvaluationContext . addBeforeDefault ( initPropertyAccessors (  )  ,    accessor )  ;", "}", "METHOD_END"], "methodName": ["addPropertyAccessor"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "List < ConstructorResolver >    resolvers    =    this . constructorResolvers ;", "if    ( resolvers    =  =    null )     {", "resolvers    =    new   ArrayList <  >  (  1  )  ;", "resolvers . add ( new   ReflectiveConstructorResolver (  )  )  ;", "this . constructorResolvers    =    resolvers ;", "}", "return   resolvers ;", "}", "METHOD_END"], "methodName": ["initConstructorResolvers"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "List < MethodResolver >    resolvers    =    this . methodResolvers ;", "if    ( resolvers    =  =    null )     {", "resolvers    =    new   ArrayList <  >  (  1  )  ;", "this . reflectiveMethodResolver    =    new   ReflectiveMethodResolver (  )  ;", "resolvers . add ( this . reflectiveMethodResolver )  ;", "this . methodResolvers    =    resolvers ;", "}", "return   resolvers ;", "}", "METHOD_END"], "methodName": ["initMethodResolvers"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "List < PropertyAccessor >    accessors    =    this . propertyAccessors ;", "if    ( accessors    =  =    null )     {", "accessors    =    new   ArrayList <  >  (  5  )  ;", "accessors . add ( new   ReflectivePropertyAccessor (  )  )  ;", "this . propertyAccessors    =    accessors ;", "}", "return   accessors ;", "}", "METHOD_END"], "methodName": ["initPropertyAccessors"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "this . variables . put ( name ,    method )  ;", "}", "METHOD_END"], "methodName": ["registerFunction"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "initMethodResolvers (  )  ;", "ReflectiveMethodResolver   resolver    =    this . reflectiveMethodResolver ;", "if    ( resolver    =  =    null )     {", "throw   new   IllegalStateExcep (  \" Method   filter   cannot   be   set   as   the   reflective   method   resolver   is   not   in   use \"  )  ;", "}", "resolver . registerMethodFilter ( type ,    filter )  ;", "}", "METHOD_END"], "methodName": ["registerMethodFilter"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "return   initConstructorResolvers (  )  . remove ( resolver )  ;", "}", "METHOD_END"], "methodName": ["removeConstructorResolver"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "return   initMethodResolvers (  )  . remove ( methodResolver )  ;", "}", "METHOD_END"], "methodName": ["removeMethodResolver"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "return   initPropertyAccessors (  )  . remove ( accessor )  ;", "}", "METHOD_END"], "methodName": ["removePropertyAccessor"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "this . beanResolver    =    beanResolver ;", "}", "METHOD_END"], "methodName": ["setBeanResolver"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "this . constructorResolvers    =    constructorResolvers ;", "}", "METHOD_END"], "methodName": ["setConstructorResolvers"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "this . methodResolvers    =    methodResolvers ;", "}", "METHOD_END"], "methodName": ["setMethodResolvers"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( operatorOverloader ,     \" OperatorOverloader   must   not   be   null \"  )  ;", "this . operatorOverloader    =    operatorOverloader ;", "}", "METHOD_END"], "methodName": ["setOperatorOverloader"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "this . propertyAccessors    =    propertyAccessors ;", "}", "METHOD_END"], "methodName": ["setPropertyAccessors"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "this . rootObject    =     ( rootObject    !  =    null )     ?    new   TypedValue ( rootObject )     :    TypedValue . NULL ;", "}", "METHOD_END"], "methodName": ["setRootObject"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "this . rootObject    =    new   TypedValue ( rootObject ,    typeDescriptor )  ;", "}", "METHOD_END"], "methodName": ["setRootObject"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( typeComparator ,     \" TypeComparator   must   not   be   null \"  )  ;", "this . typeComparator    =    typeComparator ;", "}", "METHOD_END"], "methodName": ["setTypeComparator"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( typeConverter ,     \" TypeConverter   must   not   be   null \"  )  ;", "this . typeConverter    =    typeConverter ;", "}", "METHOD_END"], "methodName": ["setTypeConverter"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( typeLocator ,     \" TypeLocator   must   not   be   null \"  )  ;", "this . typeLocator    =    typeLocator ;", "}", "METHOD_END"], "methodName": ["setTypeLocator"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "this . variables . putAll ( variables )  ;", "}", "METHOD_END"], "methodName": ["setVariables"], "fileName": "org.springframework.expression.spel.support.StandardEvaluationContext"}, {"methodBody": ["METHOD_START", "{", "return   x    -    y ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.springframework.expression.spel.support.StandardTypeComparator"}, {"methodBody": ["METHOD_START", "{", "return   x    <    y    ?     -  1     :    x    >    y    ?     1     :     0  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.springframework.expression.spel.support.StandardTypeComparator"}, {"methodBody": ["METHOD_START", "{", "return   x    <    y    ?     -  1     :    x    >    y    ?     1     :     0  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.springframework.expression.spel.support.StandardTypeComparator"}, {"methodBody": ["METHOD_START", "{", "return   x    -    y ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.springframework.expression.spel.support.StandardTypeComparator"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . knownPackagePrefixes )  ;", "}", "METHOD_END"], "methodName": ["getImportPrefixes"], "fileName": "org.springframework.expression.spel.support.StandardTypeLocator"}, {"methodBody": ["METHOD_START", "{", "this . knownPackagePrefixes . add ( prefix )  ;", "}", "METHOD_END"], "methodName": ["registerImport"], "fileName": "org.springframework.expression.spel.support.StandardTypeLocator"}, {"methodBody": ["METHOD_START", "{", "this . knownPackagePrefixes . remove ( prefix )  ;", "}", "METHOD_END"], "methodName": ["removeImport"], "fileName": "org.springframework.expression.spel.support.StandardTypeLocator"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.expression.spel.testdata.PersonInOtherPackage"}, {"methodBody": ["METHOD_START", "{", "this . age    =    age ;", "}", "METHOD_END"], "methodName": ["setAge"], "fileName": "org.springframework.expression.spel.testdata.PersonInOtherPackage"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.springframework.expression.spel.testresources.Company"}, {"methodBody": ["METHOD_START", "{", "return   color ;", "}", "METHOD_END"], "methodName": ["getColor"], "fileName": "org.springframework.expression.spel.testresources.Fruit"}, {"methodBody": ["METHOD_START", "{", "return   stringscount ;", "}", "METHOD_END"], "methodName": ["stringscount"], "fileName": "org.springframework.expression.spel.testresources.Fruit"}, {"methodBody": ["METHOD_START", "{", "if    ( strings    =  =    null )", "return    0  ;", "return   strings . length ;", "}", "METHOD_END"], "methodName": ["aVarargsMethod"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "if    ( strings    =  =    null )", "return   i ;", "return    ( strings . length )     +    i ;", "}", "METHOD_END"], "methodName": ["aVarargsMethod2"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   o . toString (  )  ;", "}", "METHOD_END"], "methodName": ["echo"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   birthdate ;", "}", "METHOD_END"], "methodName": ["getBirthdate"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "result . add (  \"  1  4  .  3  5  \"  )  ;", "result . add (  \"  1  5  .  4  5  \"  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getDoublesAsStringList"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   foo ;", "}", "METHOD_END"], "methodName": ["getFoo"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   inventions ;", "}", "METHOD_END"], "methodName": ["getInventions"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   nationality ;", "}", "METHOD_END"], "methodName": ["getNationality"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   placeOfBirth ;", "}", "METHOD_END"], "methodName": ["getPlaceOfBirth"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   placesLived ;", "}", "METHOD_END"], "methodName": ["getPlacesLived"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   placesLivedList ;", "}", "METHOD_END"], "methodName": ["getPlacesLivedList"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   accessedThroughGetSet ;", "}", "METHOD_END"], "methodName": ["getSomeProperty"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   wonNobelPrize ;", "}", "METHOD_END"], "methodName": ["getWonNobelPrize"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return    ( a    +    b )     +    c ;", "}", "METHOD_END"], "methodName": ["joinThreeStrings"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   d . toString (  )  ;", "}", "METHOD_END"], "methodName": ["printDouble"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   ObjectUtils . nullSafeToString ( d )  ;", "}", "METHOD_END"], "methodName": ["printDoubles"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return    \" hello    \"     +    person ;", "}", "METHOD_END"], "methodName": ["sayHelloTo"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "foo    =    s ;", "}", "METHOD_END"], "methodName": ["setFoo"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "this . inventions    =    inventions ;", "}", "METHOD_END"], "methodName": ["setInventions"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "placeOfBirth    =    placeOfBirth 2  ;", "this . plaLived    =    new   PlaceOfBirth [  ]  {    placeOfBirth 2     }  ;", "this . plaLivedList . add ( placeOfBirth 2  )  ;", "}", "METHOD_END"], "methodName": ["setPlaceOfBirth"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "this . placesLived    =    placesLived ;", "}", "METHOD_END"], "methodName": ["setPlacesLived"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "this . placesLivedList    =    placesLivedList ;", "}", "METHOD_END"], "methodName": ["setPlacesLivedList"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "this . accessedThroughGetSet    =    b ;", "}", "METHOD_END"], "methodName": ["setSomeProperty"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "this . wonNobelPrize    =    wonNobelPrize ;", "}", "METHOD_END"], "methodName": ["setWonNobelPrize"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "( counter )  +  +  ;", "if    ( valueIn    =  =     1  )     {", "throw   new   IllegalArgumentException (  \" IllegalArgumentException   for    1  \"  )  ;", "}", "if    ( valueIn    =  =     2  )     {", "throw   new   RuntimeException (  \" RuntimeException   for    2  \"  )  ;", "}", "if    ( valueIn    =  =     4  )     {", "throw   new    . TestException (  )  ;", "}", "return   valueIn ;", "}", "METHOD_END"], "methodName": ["throwException"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   pob . getCity (  )  ;", "}", "METHOD_END"], "methodName": ["throwException"], "fileName": "org.springframework.expression.spel.testresources.Inventor"}, {"methodBody": ["METHOD_START", "{", "return   company ;", "}", "METHOD_END"], "methodName": ["getCompany"], "fileName": "org.springframework.expression.spel.testresources.Person"}, {"methodBody": ["METHOD_START", "{", "return   privateName ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.expression.spel.testresources.Person"}, {"methodBody": ["METHOD_START", "{", "this . privateName    =    n ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.expression.spel.testresources.Person"}, {"methodBody": ["METHOD_START", "{", "return   i    *     2  ;", "}", "METHOD_END"], "methodName": ["doubleIt"], "fileName": "org.springframework.expression.spel.testresources.PlaceOfBirth"}, {"methodBody": ["METHOD_START", "{", "return   city ;", "}", "METHOD_END"], "methodName": ["getCity"], "fileName": "org.springframework.expression.spel.testresources.PlaceOfBirth"}, {"methodBody": ["METHOD_START", "{", "this . city    =    s ;", "}", "METHOD_END"], "methodName": ["setCity"], "fileName": "org.springframework.expression.spel.testresources.PlaceOfBirth"}, {"methodBody": ["METHOD_START", "{", "return   crossStreets ;", "}", "METHOD_END"], "methodName": ["getCrossStreets"], "fileName": "org.springframework.expression.spel.testresources.TestAddress"}, {"methodBody": ["METHOD_START", "{", "return   street ;", "}", "METHOD_END"], "methodName": ["getStreet"], "fileName": "org.springframework.expression.spel.testresources.TestAddress"}, {"methodBody": ["METHOD_START", "{", "this . crossStreets    =    crossStreets ;", "}", "METHOD_END"], "methodName": ["setCrossStreets"], "fileName": "org.springframework.expression.spel.testresources.TestAddress"}, {"methodBody": ["METHOD_START", "{", "this . street    =    street ;", "}", "METHOD_END"], "methodName": ["setStreet"], "fileName": "org.springframework.expression.spel.testresources.TestAddress"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.springframework.expression.spel.testresources.TestPerson"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.expression.spel.testresources.TestPerson"}, {"methodBody": ["METHOD_START", "{", "this . address    =    address ;", "}", "METHOD_END"], "methodName": ["setAddress"], "fileName": "org.springframework.expression.spel.testresources.TestPerson"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.expression.spel.testresources.TestPerson"}]